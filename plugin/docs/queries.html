<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Laravel 9.x 中文文档</title>
    <link rel="stylesheet" href="../style/idea.css">
<link rel="stylesheet" href="../style/bd0cbd7aa15e5518a47099735133bf3a-vendors.css">
<link rel="stylesheet" href="../style/a91e47e2539b98438cb4c6c3a665d642-app.css">
    <style>
        div.markdown-body {
            margin: 0 10px;
        }
    </style>
</head>

<body>
    <div class="markdown-body"><h1 id="数据库-查询构造器">数据库: 查询构造器</h1>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C">获取结果</a><ul>
<li><a href="#%E5%88%86%E5%9D%97%E7%BB%93%E6%9E%9C">分块结果</a></li>
<li><a href="#streaming-results-lazily">Lazily 流式传输结果</a></li>
<li><a href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a></li>
</ul>
</li>
<li><a href="#select-statements">Select 语句</a></li>
<li><a href="#%E5%8E%9F%E7%94%9F%E8%A1%A8%E8%BE%BE%E5%BC%8F">原生表达式</a></li>
<li><a href="#joins">Joins</a></li>
<li><a href="#unions">Unions</a></li>
<li><a href="#basic-where-clauses">基础 where 语句</a><ul>
<li><a href="#where-clauses">条件查询语句</a></li>
<li><a href="#or-where-clauses">Or Where 语句</a></li>
<li><a href="#json-where-clauses">JSON Where 语句</a></li>
<li><a href="#additional-where-clauses">其他 Where 语句</a></li>
<li><a href="#logical-grouping">逻辑分组</a></li>
</ul>
</li>
<li><a href="#advanced-where-clauses">高级 Where 语句</a><ul>
<li><a href="#where-exists-clauses">Where Exists 语句</a></li>
<li><a href="#subquery-where-clauses">子查询 Where 语句</a></li>
<li><a href="#full-text-where-clauses">全文 Where 子句</a></li>
</ul>
</li>
<li><a href="#ordering-grouping-limit-and-offset">Ordering, Grouping, Limit &amp; Offset</a><ul>
<li><a href="#ordering">排序</a></li>
<li><a href="#grouping">分组</a></li>
<li><a href="#limit-and-offset">Limit &amp; Offset</a></li>
</ul>
</li>
<li><a href="#conditional-clauses">条件语句</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5">插入语句</a><ul>
<li><a href="#auto-incrementing-ids">自增ID</a></li>
</ul>
</li>
<li><a href="#update-statements">更新语句</a><ul>
<li><a href="#updating-json-columns">更新 JSON</a></li>
<li><a href="#increment-and-decrement">自增 &amp; 自减</a></li>
</ul>
</li>
<li><a href="#%E5%88%A0%E9%99%A4%E8%AF%AD%E5%8F%A5">删除语句</a></li>
<li><a href="#%E6%82%B2%E8%A7%82%E9%94%81">悲观锁</a></li>
<li><a href="#%E8%B0%83%E8%AF%95">调试</a></li>
</ul>
<p><a name="introduction"></a></p>
<h2 id="简介">简介</h2>
<p>Laravel的数据库查询生成器为创建和运行数据库查询提供了方便、流畅的界面。它可以用于执行应用程序中的大多数数据库操作，并与Laravel支持的所有数据库系统完美配合。</p>
<p>Laravel 9 查询生成器使用PDO参数绑定来保护应用程序免受SQL注入攻击。无需清理或清理作为查询绑定传递给查询生成器的字符串。</p>
<blockquote>
<p>注意：PDO不支持绑定列名。因此，永远不要允许用户输入指定查询引用的列名，包括「order by」列。</p>
</blockquote>
<p><a name="running-database-queries"></a></p>
<h2 id="获取结果">获取结果</h2>
<p><a name="retrieving-all-rows-from-a-table"></a></p>
<h4 id="从表中检索所有行">从表中检索所有行</h4>
<p>你可以使用 <code>DB</code> facade 提供的 <code>table</code> 方法开始查询。<code>table</code> 方法为指定的表返回一个链式查询构造器实例，允许在查询上链接更多约束，最后使用 <code>get</code> 方法检索查询结果：</p>
<pre><code class="language-php">    <span class="preprocessor token">&lt;?php</span>

    <span class="keyword token">namespace</span> App\Http\Controllers;

    <span class="keyword token">use</span> App\Http\Controllers\Controller;
    <span class="keyword token">use</span> Illuminate\Support\Facades\DB;

    <span class="keyword token">class</span> UserController <span class="keyword token">extends</span> Controller
    {
        <span class="comment token">/**
         * 显示所有应用程序用户的列表。
         *
         *<span class="phpdoc token"> @return</span> \Illuminate\Http\Response
         */</span>
        <span class="keyword token">public</span> <span class="keyword token">function</span> index()
        {
            <span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)-&gt;get();

            <span class="keyword token">return</span> view(<span class="string token">'user.index'</span>, [<span class="string token">'users'</span> =&gt; <span class="variable token">$users</span>]);
        }
    }
</code></pre>
<p><code>get</code> 方法返回包含查询结果的 <code>Illuminate\Support\Collection</code> 实例，每个结果都是 PHP  <code>stdClass</code> 实例。可以将列作为对象的属性来访问每列的值：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\DB;

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)-&gt;get();

<span class="keyword token">foreach</span> (<span class="variable token">$users</span> <span class="keyword token">as</span> <span class="variable token">$user</span>) {
    <span class="keyword token">echo</span> <span class="variable token">$user</span>-&gt;name;
}
</code></pre>
<blockquote>
<p>技巧：Laravel 集合提供了各种及其强大的方法来映射和裁剪数据。有关 Laravel 集合的更多信息，请查看<a href="collections.html">集合文档</a>。</p>
</blockquote>
<p><a name="retrieving-a-single-row-column-from-a-table"></a></p>
<h4 id="从表中检索单行或单列">从表中检索单行或单列</h4>
<p>如果只需要从数据表中检索单行，可以使用 <code>DB</code> facade 中的 <code>first</code> 方法。 此方法将返回单个 <code>stdClass</code> 对象</p>
<pre><code><span class="variable token">$user</span> = DB::table(<span class="string token">'users'</span>)-&gt;where(<span class="string token">'name'</span>, <span class="string token">'John'</span>)-&gt;first();

<span class="keyword token">return</span> <span class="variable token">$user</span>-&gt;email;
</code></pre>
<p>如果不想要整行，可以使用 <code>value</code> 方法从纪录中提取单个值。此方法将直接返回列的值：</p>
<pre><code><span class="variable token">$email</span> = DB::table(<span class="string token">'users'</span>)-&gt;where(<span class="string token">'name'</span>, <span class="string token">'John'</span>)-&gt;value(<span class="string token">'email'</span>);
</code></pre>
<p>如果要通过 <code>id</code> 字段值获取单行数据，可以使用 <code>find</code> 方法：</p>
<pre><code><span class="variable token">$user</span> = DB::table(<span class="string token">'users'</span>)-&gt;find(<span class="number token">3</span>);
</code></pre>
<p><a name="retrieving-a-list-of-column-values"></a></p>
<h4 id="获取某一列的值">获取某一列的值</h4>
<p>如果您想获取包含单列值的集合，则可以使用 <code>pluck</code> 方法。在下面的例子中，我们将获取角色表中标题的集合：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\DB;

<span class="variable token">$titles</span> = DB::table(<span class="string token">'users'</span>)-&gt;pluck(<span class="string token">'title'</span>);

<span class="keyword token">foreach</span> (<span class="variable token">$titles</span> <span class="keyword token">as</span> <span class="variable token">$title</span>) {
    <span class="keyword token">echo</span> <span class="variable token">$title</span>;
}
</code></pre>
<p>您可以通过向 <code>pluck</code> 方法提供第二个参数来指定结果集中要作为键的列：</p>
<pre><code><span class="variable token">$titles</span> = DB::table(<span class="string token">'users'</span>)-&gt;pluck(<span class="string token">'title'</span>, <span class="string token">'name'</span>);

<span class="keyword token">foreach</span> (<span class="variable token">$titles</span> <span class="keyword token">as</span> <span class="variable token">$name</span> =&gt; <span class="variable token">$title</span>) {
    <span class="keyword token">echo</span> <span class="variable token">$title</span>;
}
</code></pre>
<p><a name="chunking-results"></a></p>
<h3 id="分块结果">分块结果</h3>
<p>如果您需要处理成千上万的数据库记录，请考虑使用 <code>DB</code> 提供的 <code>chunk</code> 方法。这个方法一次检索一小块结果，并将每个块反馈到闭包函数中进行处理。例如，让我们以一次 100 条记录的块为单位检索整个 <code>users</code> 表。</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\DB;

DB::table(<span class="string token">'users'</span>)-&gt;orderBy(<span class="string token">'id'</span>)-&gt;chunk(<span class="number token">100</span>, <span class="keyword token">function</span> (<span class="variable token">$users</span>) {
    <span class="keyword token">foreach</span> (<span class="variable token">$users</span> <span class="keyword token">as</span> <span class="variable token">$user</span>) {
        <span class="comment token">//</span>
    }
});
</code></pre>
<p>您可以通过从闭包中返回 <code>false</code> 来停止处理其余的块:</p>
<pre><code>DB::table(<span class="string token">'users'</span>)-&gt;orderBy(<span class="string token">'id'</span>)-&gt;chunk(<span class="number token">100</span>, <span class="keyword token">function</span> (<span class="variable token">$users</span>) {
    <span class="comment token">// Process the records...</span>

    <span class="keyword token">return</span> <span class="keyword token">false</span>;
});
</code></pre>
<p>如果在对结果进行分块时更新数据库记录，那分块结果可能会以意想不到的方式更改。如果您打算在分块时更新检索到的记录，最好使用 <code>chunkById</code> 方法。此方法将根据记录的主键自动对结果进行分页:</p>
<pre><code>DB::table(<span class="string token">'users'</span>)-&gt;where(<span class="string token">'active'</span>, <span class="keyword token">false</span>)
    -&gt;chunkById(<span class="number token">100</span>, <span class="keyword token">function</span> (<span class="variable token">$users</span>) {
        <span class="keyword token">foreach</span> (<span class="variable token">$users</span> <span class="keyword token">as</span> <span class="variable token">$user</span>) {
            DB::table(<span class="string token">'users'</span>)
                -&gt;where(<span class="string token">'id'</span>, <span class="variable token">$user</span>-&gt;id)
                -&gt;update([<span class="string token">'active'</span> =&gt; <span class="keyword token">true</span>]);
        }
    });
</code></pre>
<blockquote>
<p>注意：当在更新或删除块回调中的记录时，对主键或外键的任何更改都可能影响块查询。这可能会导致记录未包含在分块结果中。</p>
</blockquote>
<p><a name="streaming-results-lazily"></a></p>
<h3 id="lazily-流式传输结果">Lazily 流式传输结果</h3>
<p><code>lazy</code> 方法的工作方式类似于 <a href="#chunking-results"><code>chunk</code> 方法</a>，因为它以块的形式执行查询。但是，<code>lazy()</code> 方法不是将每个块传递给回调，而是返回一个 <a href="collections.html#lazy-collections"><code>LazyCollection</code></a>，它可以让您与结果进行交互单个流：</p>
<pre><code class="language-php"><span class="keyword token">use</span> Illuminate\Support\Facades\DB;

DB::table(<span class="string token">'users'</span>)-&gt;orderBy(<span class="string token">'id'</span>)-&gt;lazy()-&gt;each(<span class="keyword token">function</span> (<span class="variable token">$user</span>) {
    <span class="comment token">//</span>
});
</code></pre>
<p>再一次，如果您打算在迭代它们时更新检索到的记录，最好使用 <code>lazyById</code> 或 <code>lazyByIdDesc</code> 方法。 这些方法将根据记录的主键自动对结果进行分页：</p>
<pre><code class="language-php">DB::table(<span class="string token">'users'</span>)-&gt;where(<span class="string token">'active'</span>, <span class="keyword token">false</span>)
    -&gt;lazyById()-&gt;each(<span class="keyword token">function</span> (<span class="variable token">$user</span>) {
        DB::table(<span class="string token">'users'</span>)
            -&gt;where(<span class="string token">'id'</span>, <span class="variable token">$user</span>-&gt;id)
            -&gt;update([<span class="string token">'active'</span> =&gt; <span class="keyword token">true</span>]);
    });
</code></pre>
<blockquote>
<p>注意：在迭代记录时更新或删除记录时，对主键或外键的任何更改都可能影响块查询。这可能会导致记录不包含在结果中。</p>
</blockquote>
<p><a name="aggregates"></a></p>
<h3 id="聚合函数">聚合函数</h3>
<p>查询构建器还提供了多种检索聚合值的方法，例如 <code>count</code>, <code>max</code>, <code>min</code>, <code>avg</code>,和 <code>sum</code>。您可以在构建查询后调用这些方法中的任何一个：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\DB;

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)-&gt;count();

<span class="variable token">$price</span> = DB::table(<span class="string token">'orders'</span>)-&gt;max(<span class="string token">'price'</span>);
</code></pre>
<p>当然，您可以将这些方法与其他子句结合使用，以微调您的合计值的计算方式：</p>
<pre><code><span class="variable token">$price</span> = DB::table(<span class="string token">'orders'</span>)
                -&gt;where(<span class="string token">'finalized'</span>, <span class="number token">1</span>)
                -&gt;avg(<span class="string token">'price'</span>);
</code></pre>
<p><a name="determining-if-records-exist"></a></p>
<h4 id="判断记录是否存在">判断记录是否存在</h4>
<p>除了通过 <code>count</code> 方法可以确定查询条件的结果是否存在之外，还可以使用 <code>exists</code> 和 <code>doesntExist</code> 方法：</p>
<pre><code><span class="keyword token">if</span> (DB::table(<span class="string token">'orders'</span>)-&gt;where(<span class="string token">'finalized'</span>, <span class="number token">1</span>)-&gt;exists()) {
    <span class="comment token">// ...</span>
}

<span class="keyword token">if</span> (DB::table(<span class="string token">'orders'</span>)-&gt;where(<span class="string token">'finalized'</span>, <span class="number token">1</span>)-&gt;doesntExist()) {
    <span class="comment token">// ...</span>
}
</code></pre>
<p><a name="select-statements"></a></p>
<h2 id="select-语句">Select 语句</h2>
<p><a name="specifying-a-select-clause"></a></p>
<h4 id="指定一个-select-语句">指定一个 Select 语句</h4>
<p>当然你可能不是总是希望从数据库表中获取所有列。使用 <code>select</code> 方法，你可以自定义一个 「select」 查询语句来查询指定的字段：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\DB;

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
            -&gt;select(<span class="string token">'name'</span>, <span class="string token">'email as user_email'</span>)
            -&gt;get();
</code></pre>
<p><code>distinct</code> 方法会强制让查询返回的结果不重复：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)-&gt;distinct()-&gt;get();
</code></pre>
<p>如果你已经有了一个查询构造器实例，并且希望在现有的查询语句中加入一个字段，那么你可以使用 <code>addSelect</code> 方法</p>
<pre><code><span class="variable token">$query</span> = DB::table(<span class="string token">'users'</span>)-&gt;select(<span class="string token">'name'</span>);

<span class="variable token">$users</span> = <span class="variable token">$query</span>-&gt;addSelect(<span class="string token">'age'</span>)-&gt;get();
</code></pre>
<p><a name="raw-expressions"></a></p>
<h2 id="原生表达式">原生表达式</h2>
<p>有时可能需要在查询中插入任意字符串。要创建原始字符串表达式，可以使用 <code>DB</code> facade提供的<code>raw</code>方法：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
             -&gt;select(DB::raw(<span class="string token">'count(*) as user_count, status'</span>))
             -&gt;where(<span class="string token">'status'</span>, <span class="string token">'&lt;&gt;'</span>, <span class="number token">1</span>)
             -&gt;groupBy(<span class="string token">'status'</span>)
             -&gt;get();
</code></pre>
<blockquote>
<p>注意：原生表达式将会被当做字符串注入到查询中，因此你应该极度小心避免创建 SQL 注入的漏洞。</p>
</blockquote>
<p><a name="raw-methods"></a></p>
<h3 id="原生表达式-1">原生表达式</h3>
<p>可以使用以下方法代替 <code>DB::raw</code>，将原生表达式插入查询的各个部分。<strong>注意，Laravel 无法保证所有使用原生表达式的查询都受到防 SQL 注入漏洞保护。</strong></p>
<p><a name="selectraw"></a></p>
<h4 id="selectraw"><code>selectRaw</code></h4>
<p><code>selectRaw</code> 方法可以代替 <code>addSelect(DB::raw(...))</code>。该方法的第二个参数是可选项，值是一个绑定参数的数组：</p>
<pre><code><span class="variable token">$orders</span> = DB::table(<span class="string token">'orders'</span>)
                -&gt;selectRaw(<span class="string token">'price * ? as price_with_tax'</span>, [<span class="number token">1.0825</span>])
                -&gt;get();
</code></pre>
<p><a name="whereraw-orwhereraw"></a></p>
<h4 id="whereraw--orwhereraw"><code>whereRaw / orWhereRaw</code></h4>
<p><code>whereRaw</code> 和 <code>orWhereRaw</code> 方法将原生的「where」注入到你的查询中。这两个方法的第二个参数是可选项，值是一个绑定参数的数组：</p>
<pre><code><span class="variable token">$orders</span> = DB::table(<span class="string token">'orders'</span>)
                -&gt;whereRaw(<span class="string token">'price &gt; IF(state = "TX", ?, 100)'</span>, [<span class="number token">200</span>])
                -&gt;get();
</code></pre>
<p><a name="havingraw-orhavingraw"></a></p>
<h4 id="havingraw--orhavingraw"><code>havingRaw / orHavingRaw</code></h4>
<p><code>havingRaw</code> 和 <code>orHavingRaw</code> 方法可以用于将原生字符串作为「having」语句的值。这两个方法的第二个参数是可选项，值是一个绑定参数的数组：</p>
<pre><code><span class="variable token">$orders</span> = DB::table(<span class="string token">'orders'</span>)
                -&gt;select(<span class="string token">'department'</span>, DB::raw(<span class="string token">'SUM(price) as total_sales'</span>))
                -&gt;groupBy(<span class="string token">'department'</span>)
                -&gt;havingRaw(<span class="string token">'SUM(price) &gt; ?'</span>, [<span class="number token">2500</span>])
                -&gt;get();
</code></pre>
<p><a name="orderbyraw"></a></p>
<h4 id="orderbyraw"><code>orderByRaw</code></h4>
<p><code>orderByRaw</code> 方法可用于将原生字符串设置为「order by」语句的值：</p>
<pre><code><span class="variable token">$orders</span> = DB::table(<span class="string token">'orders'</span>)
                -&gt;orderByRaw(<span class="string token">'updated_at - created_at DESC'</span>)
                -&gt;get();
</code></pre>
<p><a name="groupbyraw"></a></p>
<h3 id="groupbyraw"><code>groupByRaw</code></h3>
<p><code>groupByRaw</code> 方法可以用于将原生字符串设置为 <code>group by</code> 语句的值：</p>
<pre><code><span class="variable token">$orders</span> = DB::table(<span class="string token">'orders'</span>)
                -&gt;select(<span class="string token">'city'</span>, <span class="string token">'state'</span>)
                -&gt;groupByRaw(<span class="string token">'city, state'</span>)
                -&gt;get();
</code></pre>
<p><a name="joins"></a></p>
<h2 id="joins">Joins</h2>
<p><a name="inner-join-clause"></a></p>
<h4 id="inner-join--语句">Inner Join  语句</h4>
<p>查询构造器也还可用于向查询中添加连接子句。若要执行基本的「内链接」，你可以对查询构造器实例使用 <code>join</code> 方法。传递给 <code>join</code> 方法的第一个参数是需要连接到的表的名称，而其余参数指定连接的列约束。您甚至还可以在一个查询中连接多个表：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\DB;

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
            -&gt;join(<span class="string token">'contacts'</span>, <span class="string token">'users.id'</span>, <span class="string token">'='</span>, <span class="string token">'contacts.user_id'</span>)
            -&gt;join(<span class="string token">'orders'</span>, <span class="string token">'users.id'</span>, <span class="string token">'='</span>, <span class="string token">'orders.user_id'</span>)
            -&gt;select(<span class="string token">'users.*'</span>, <span class="string token">'contacts.phone'</span>, <span class="string token">'orders.price'</span>)
            -&gt;get();
</code></pre>
<p><a name="left-join-right-join-clause"></a></p>
<h4 id="left-join--right-join--语句">Left Join / Right Join  语句</h4>
<p>如果你想使用 <code>left join</code>或者 <code>right join</code> 代替 <code>inner join</code> ，可以使用 <code>leftJoin</code> 或者 <code>rightJoin</code> 方法。这两个方法与 <code>join</code> 方法用法相同：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
            -&gt;leftJoin(<span class="string token">'posts'</span>, <span class="string token">'users.id'</span>, <span class="string token">'='</span>, <span class="string token">'posts.user_id'</span>)
            -&gt;get();

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
            -&gt;rightJoin(<span class="string token">'posts'</span>, <span class="string token">'users.id'</span>, <span class="string token">'='</span>, <span class="string token">'posts.user_id'</span>)
            -&gt;get();
</code></pre>
<p><a name="cross-join-clause"></a></p>
<h4 id="cross-join--语句">Cross Join  语句</h4>
<p>你可以使用 <code>crossJoin</code> 方法执行「交叉连接」。交叉连接在第一个表和被连接的表之间会生成笛卡尔积：</p>
<pre><code><span class="variable token">$sizes</span> = DB::table(<span class="string token">'sizes'</span>)
            -&gt;crossJoin(<span class="string token">'colors'</span>)
            -&gt;get();
</code></pre>
<p><a name="advanced-join-clauses"></a></p>
<h4 id="高级-join-语句">高级 Join 语句</h4>
<p>您还可以指定更高级的联接子句。首先，将闭包作为第二个参数传递给 <code>join</code> 方法。闭包将收到一个<code>illumb\Database\Query\JoinClause</code>实例，该实例允许您指定对<code>join</code>子句的约束：</p>
<pre><code>DB::table(<span class="string token">'users'</span>)
        -&gt;join(<span class="string token">'contacts'</span>, <span class="keyword token">function</span> (<span class="variable token">$join</span>) {
            <span class="variable token">$join</span>-&gt;on(<span class="string token">'users.id'</span>, <span class="string token">'='</span>, <span class="string token">'contacts.user_id'</span>)-&gt;orOn(...);
        })
        -&gt;get();
</code></pre>
<p>如果你想要在连接上使用「where」风格的语句，你可以在连接上使用 <code>JoinClause</code> 实例中的 <code>where</code> 和 <code>orWhere</code> 方法。这些方法会将列和值进行比较，而不是列和列进行比较：</p>
<pre><code>DB::table(<span class="string token">'users'</span>)
        -&gt;join(<span class="string token">'contacts'</span>, <span class="keyword token">function</span> (<span class="variable token">$join</span>) {
            <span class="variable token">$join</span>-&gt;on(<span class="string token">'users.id'</span>, <span class="string token">'='</span>, <span class="string token">'contacts.user_id'</span>)
                 -&gt;where(<span class="string token">'contacts.user_id'</span>, <span class="string token">'&gt;'</span>, <span class="number token">5</span>);
        })
        -&gt;get();
</code></pre>
<p><a name="subquery-joins"></a></p>
<h4 id="子连接查询">子连接查询</h4>
<p>你可以使用 <code>joinSub</code>，<code>leftJoinSub</code> 和 <code>rightJoinSub</code> 方法关联一个查询作为子查询。他们每一种方法都会接收三个参数：子查询，表别名和定义关联字段的闭包。
如下面这个例子，获取含有用户最近一次发布博客时的 <code>created_at</code> 时间戳的用户集合：</p>
<pre><code><span class="variable token">$latestPosts</span> = DB::table(<span class="string token">'posts'</span>)
                   -&gt;select(<span class="string token">'user_id'</span>, DB::raw(<span class="string token">'MAX(created_at) as last_post_created_at'</span>))
                   -&gt;where(<span class="string token">'is_published'</span>, <span class="keyword token">true</span>)
                   -&gt;groupBy(<span class="string token">'user_id'</span>);

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
        -&gt;joinSub(<span class="variable token">$latestPosts</span>, <span class="string token">'latest_posts'</span>, <span class="keyword token">function</span> (<span class="variable token">$join</span>) {
            <span class="variable token">$join</span>-&gt;on(<span class="string token">'users.id'</span>, <span class="string token">'='</span>, <span class="string token">'latest_posts.user_id'</span>);
        })-&gt;get();
</code></pre>
<p><a name="unions"></a></p>
<h2 id="unions">Unions</h2>
<p>查询构造器还提供了一种简洁的方式将两个或者多个查询「联合」在一起。例如，你可以先创建一个查询，然后使用 <code>union</code> 方法来连接更多的查询：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\DB;

<span class="variable token">$first</span> = DB::table(<span class="string token">'users'</span>)
            -&gt;whereNull(<span class="string token">'first_name'</span>);

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
            -&gt;whereNull(<span class="string token">'last_name'</span>)
            -&gt;union(<span class="variable token">$first</span>)
            -&gt;get();
</code></pre>
<p>查询构造器不仅提供了 <code>union</code> 方法，还提供了一个 <code>unionAll</code> 方法。当查询结合 <code>unionAll</code> 方法使用时，将不会删除重复的结果。<code>unionAll</code> 方法的用法和 <code>union</code> 方法一样。</p>
<p><a name="basic-where-clauses"></a></p>
<h2 id="基础的-where-语句">基础的 Where 语句</h2>
<p><a name="where-clauses"></a></p>
<h3 id="where-语句">Where 语句</h3>
<p>你可以在 where 语句中使用查询构造器的 <code>where</code> 方法。调用 <code>where</code> 方法需要三个基本参数。第一个参数是字段的名称。第二个参数是一个操作符，它可以是数据库中支持的任意操作符。第三个参数是与字段比较的值。</p>
<p>例如。在 users 表中查询 <code>votes</code> 字段等于 <code>100</code> 并且 <code>age</code> 字段大于 <code>35</code> 的数据：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;where(<span class="string token">'votes'</span>, <span class="string token">'='</span>, <span class="number token">100</span>)
                -&gt;where(<span class="string token">'age'</span>, <span class="string token">'&gt;'</span>, <span class="number token">35</span>)
                -&gt;get();
</code></pre>
<p>为了方便起见。如果你想要比较一个字段的值是否 <code>等于</code> 给定的值。你可以将这个给定的值作为第二个参数传递给 where 方法。那么，Laravel 会默认使用 <code>=</code> 操作符：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)-&gt;where(<span class="string token">'votes'</span>, <span class="number token">100</span>)-&gt;get();
</code></pre>
<p>如上所述，您可以使用数据库支持的任意操作符：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;where(<span class="string token">'votes'</span>, <span class="string token">'&gt;='</span>, <span class="number token">100</span>)
                -&gt;get();

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;where(<span class="string token">'votes'</span>, <span class="string token">'&lt;&gt;'</span>, <span class="number token">100</span>)
                -&gt;get();

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;where(<span class="string token">'name'</span>, <span class="string token">'like'</span>, <span class="string token">'T%'</span>)
                -&gt;get();
</code></pre>
<p>您也可以将一个条件数组传递给 <code>where</code> 方法。通常传递给 <code>where</code> 方法的数组中的每一个元素都应该包含 3 个元素：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)-&gt;where([
    [<span class="string token">'status'</span>, <span class="string token">'='</span>, <span class="string token">'1'</span>],
    [<span class="string token">'subscribed'</span>, <span class="string token">'&lt;&gt;'</span>, <span class="string token">'1'</span>],
])-&gt;get();
</code></pre>
<blockquote>
<p>注意：PDO 不支持绑定字段名。因此，你不应该允许让用户输入字段名进行查询引用，包括结果集「排序」语句。</p>
</blockquote>
<p><a name="or-where-clauses"></a></p>
<h3 id="or-where-语句">Or Where 语句</h3>
<p>当链式调用多个 <code>where</code> 方法的时候，这些「where」语句将会被看成是 <code>and</code> 关系。另外，您也可以在查询语句中使用 <code>orWhere</code> 方法来表示 <code>or</code> 关系。<code>orWhere</code> 方法接收的参数和 <code>where</code> 方法接收的参数一样：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                    -&gt;where(<span class="string token">'votes'</span>, <span class="string token">'&gt;'</span>, <span class="number token">100</span>)
                    -&gt;orWhere(<span class="string token">'name'</span>, <span class="string token">'John'</span>)
                    -&gt;get();
</code></pre>
<p>如果您需要在括号内对 <code>or</code> 条件进行分组，那么可以传递一个闭包作为 <code>orWhere</code> 方法的第一个参数：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
            -&gt;where(<span class="string token">'votes'</span>, <span class="string token">'&gt;'</span>, <span class="number token">100</span>)
            -&gt;orWhere(<span class="keyword token">function</span>(<span class="variable token">$query</span>) {
                <span class="variable token">$query</span>-&gt;where(<span class="string token">'name'</span>, <span class="string token">'Abigail'</span>)
                      -&gt;where(<span class="string token">'votes'</span>, <span class="string token">'&gt;'</span>, <span class="number token">50</span>);
            })
            -&gt;get();
</code></pre>
<p>上面的示例将生成以下SQL：</p>
<pre><code class="language-sql">select * from users where votes &gt; <span class="number token">100</span> <span class="keyword token">or</span> (name = <span class="string token">'Abigail'</span> <span class="keyword token">and</span> votes &gt; <span class="number token">50</span>)
</code></pre>
<blockquote>
<p>注意：为了避免应用全局作用出现意外，您应该用 orWhere 调用这个分组。</p>
</blockquote>
<p><a name="json-where-clauses"></a></p>
<h3 id="json-where-语句">JSON Where 语句</h3>
<p>Laravel 也支持 JSON 类型的字段查询，前提是数据库也支持 JSON 类型。目前，有 MySQL 5.7+、PostgreSQL、SQL Server 2016 和 SQLite 3.9.0 支持 JSON 类型 (with the <a href="https://www.sqlite.org/json1.html">JSON1 extension</a>)。可以使用 <code>-&gt;</code> 操作符来查询 JSON 字段：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;where(<span class="string token">'preferences-&gt;dining-&gt;meal'</span>, <span class="string token">'salad'</span>)
                -&gt;get();
</code></pre>
<p>您可以使用 <code>whereJsonContains</code> 方法来查询 JSON 数组。但是 SQLite 数据库不支持该功能：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereJsonContains(<span class="string token">'options-&gt;languages'</span>, <span class="string token">'en'</span>)
                -&gt;get();
</code></pre>
<p>如果您的应用使用的是 MySQL 或者 PostgreSQL 数据库，那么您可以向 <code>whereJsonContains</code> 方法中传递一个数组类型的值：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereJsonContains(<span class="string token">'options-&gt;languages'</span>, [<span class="string token">'en'</span>, <span class="string token">'de'</span>])
                -&gt;get();
</code></pre>
<p>你可以使用 <code>whereJsonLength</code> 方法来查询 JSON 数组的长度：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereJsonLength(<span class="string token">'options-&gt;languages'</span>, <span class="number token">0</span>)
                -&gt;get();

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereJsonLength(<span class="string token">'options-&gt;languages'</span>, <span class="string token">'&gt;'</span>, <span class="number token">1</span>)
                -&gt;get();
</code></pre>
<p><a name="additional-where-clauses"></a></p>
<h3 id="其他-where-语句">其他 Where 语句</h3>
<p><strong>whereBetween / orWhereBetween</strong></p>
<p><code>whereBetween</code> 方法是用来验证字段的值是否在给定的两个值之间：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
           -&gt;whereBetween(<span class="string token">'votes'</span>, [<span class="number token">1</span>, <span class="number token">100</span>])
           -&gt;get();
</code></pre>
<p><strong>whereNotBetween / orWhereNotBetween</strong></p>
<p><code>whereNotBetween</code> 方法是用来验证字段的值是否不在给定的两个值之间：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                    -&gt;whereNotBetween(<span class="string token">'votes'</span>, [<span class="number token">1</span>, <span class="number token">100</span>])
                    -&gt;get();
</code></pre>
<p><strong>whereIn / whereNotIn / orWhereIn / orWhereNotIn</strong></p>
<p><code>whereIn</code> 方法是用来验证一个字段的值是否在给定的数组中：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                    -&gt;whereIn(<span class="string token">'id'</span>, [<span class="number token">1</span>, <span class="number token">2</span>, <span class="number token">3</span>])
                    -&gt;get();
</code></pre>
<p><code>whereNotIn</code> 方法是用来验证一个字段的值是否不在给定的数组中：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                    -&gt;whereNotIn(<span class="string token">'id'</span>, [<span class="number token">1</span>, <span class="number token">2</span>, <span class="number token">3</span>])
                    -&gt;get();
</code></pre>
<blockquote>
<p>注意：如果您在查询中用到了一个很大的数组，那么可以使用 <code>whereIntegerInRaw</code> 方法或者 <code>whereIntegerNotInRaw</code> 方法来减少内存的使用量。</p>
</blockquote>
<p><strong>whereNull / whereNotNull / orWhereNull / orWhereNotNull</strong></p>
<p><code>whereNull</code> 方法是用来验证给定字段的值是否为 <code>NULL</code>：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereNull(<span class="string token">'updated_at'</span>)
                -&gt;get();
</code></pre>
<p><code>whereNotNull</code> 方法是用来验证给定字段的值是否不为 <code>NULL</code></p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereNotNull(<span class="string token">'updated_at'</span>)
                -&gt;get();
</code></pre>
<p><strong>whereDate / whereMonth / whereDay / whereYear / whereTime</strong></p>
<p><code>whereDate</code> 方法是用来比较字段的值与给定的日期值是否相等 （年 - 月 - 日）：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereDate(<span class="string token">'created_at'</span>, <span class="string token">'2016-12-31'</span>)
                -&gt;get();
</code></pre>
<p><code>whereMonth</code> 方法是用来比较字段的值与给定的月份是否相等（月）：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereMonth(<span class="string token">'created_at'</span>, <span class="string token">'12'</span>)
                -&gt;get();
</code></pre>
<p> <code>whereDay</code> 方法可用于将列的值与当月的特定日期进行比较：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereDay(<span class="string token">'created_at'</span>, <span class="string token">'31'</span>)
                -&gt;get();
</code></pre>
<p> <code>whereYear</code>方法可用于将列的值与特定年份进行比较：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereYear(<span class="string token">'created_at'</span>, <span class="string token">'2016'</span>)
                -&gt;get();
</code></pre>
<p><code>WhereTime</code>方法可用于将列的值与特定时间进行比较：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereTime(<span class="string token">'created_at'</span>, <span class="string token">'='</span>, <span class="string token">'11:20:45'</span>)
                -&gt;get();
</code></pre>
<p><strong>whereColumn / orWhereColumn</strong></p>
<p><code>whereColumn</code> 方法是用来比较两个给定的字段的值是否相等：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereColumn(<span class="string token">'first_name'</span>, <span class="string token">'last_name'</span>)
                -&gt;get();
</code></pre>
<p>您也可以将比较运算符传递给<code>whereColumn</code>方法：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereColumn(<span class="string token">'updated_at'</span>, <span class="string token">'&gt;'</span>, <span class="string token">'created_at'</span>)
                -&gt;get();
</code></pre>
<p>您还可以向 <code>whereColumn</code> 方法中传递一个数组。这些条件将使用 <code>and</code> 运算符联接：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;whereColumn([
                    [<span class="string token">'first_name'</span>, <span class="string token">'='</span>, <span class="string token">'last_name'</span>],
                    [<span class="string token">'updated_at'</span>, <span class="string token">'&gt;'</span>, <span class="string token">'created_at'</span>],
                ])-&gt;get();
</code></pre>
<p><a name="logical-grouping"></a></p>
<h3 id="逻辑分组">逻辑分组</h3>
<p>有时您可能需要将括号内的几个「where」子句分组，以实现查询所需的逻辑分组。实际上应该将 <code>orWhere</code> 方法的调用分组到括号中，以避免不可预料的查询逻辑误差。因此可以传递闭包给 <code>where</code> 方法：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
           -&gt;where(<span class="string token">'name'</span>, <span class="string token">'='</span>, <span class="string token">'John'</span>)
           -&gt;where(<span class="keyword token">function</span> (<span class="variable token">$query</span>) {
               <span class="variable token">$query</span>-&gt;where(<span class="string token">'votes'</span>, <span class="string token">'&gt;'</span>, <span class="number token">100</span>)
                     -&gt;orWhere(<span class="string token">'title'</span>, <span class="string token">'='</span>, <span class="string token">'Admin'</span>);
           })
           -&gt;get();
</code></pre>
<p>你可以看到， 通过一个 <code>闭包</code> 写入 <code>where</code> 方法 构建一个查询构造器来约束一个分组。这个 <code>闭包</code> 接收一个查询实例，你可以使用这个实例来设置应该包含的约束。上面的例子将生成以下 SQL：</p>
<pre><code class="language-sql">select * from users where name = <span class="string token">'John'</span> <span class="keyword token">and</span> (votes &gt; <span class="number token">100</span> <span class="keyword token">or</span> title = <span class="string token">'Admin'</span>)
</code></pre>
<blockquote>
<p>提示：你应该用 <code>orWhere</code> 调用这个分组，以避免应用全局作用时出现意外。</p>
</blockquote>
<p><a name="advanced-where-clauses"></a></p>
<h3 id="高级-where-语句">高级 Where 语句</h3>
<p><a name="where-exists-clauses"></a></p>
<h3 id="where-exists-语句">Where Exists 语句</h3>
<p><code>whereExists</code> 方法允许你使用 <code>where exists</code> SQL 语句。 <code>whereExists</code> 方法接收一个 <code>闭包</code> 参数，该闭包获取一个查询构建器实例，从而允许你定义放置在 <code>exists</code> 子句中查询:</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
           -&gt;whereExists(<span class="keyword token">function</span> (<span class="variable token">$query</span>) {
               <span class="variable token">$query</span>-&gt;select(DB::raw(<span class="number token">1</span>))
                     -&gt;from(<span class="string token">'orders'</span>)
                     -&gt;whereColumn(<span class="string token">'orders.user_id'</span>, <span class="string token">'users.id'</span>);
           })
           -&gt;get();
</code></pre>
<p>上面的查询将产生如下的 <code>SQL</code> 语句：:</p>
<pre><code class="language-sql">select * from users
where exists (
    select 1
    from orders
    where orders.user_id = users.id
)
</code></pre>
<p><a name="subquery-where-clauses"></a></p>
<h3 id="子查询-where-语句">子查询 Where 语句</h3>
<p>有时候，你可能需要构造一个 <code>where</code> 子查询，将子查询的结果与给定的值进行比较。你可以通过向 <code>where</code> 方法传递闭包和值来实现此操作。例如，下面的查询将检索最后一次「会员」购买记录是「Pro」类型的所有用户；</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$users</span> = User::where(<span class="keyword token">function</span> (<span class="variable token">$query</span>) {
    <span class="variable token">$query</span>-&gt;select(<span class="string token">'type'</span>)
        -&gt;from(<span class="string token">'membership'</span>)
        -&gt;whereColumn(<span class="string token">'membership.user_id'</span>, <span class="string token">'users.id'</span>)
        -&gt;orderByDesc(<span class="string token">'membership.start_date'</span>)
        -&gt;limit(<span class="number token">1</span>);
}, <span class="string token">'Pro'</span>)-&gt;get();
</code></pre>
<p>或者，您可能需要构建一个 <code>where</code> 子句，将列与子查询的结果进行比较。您可以通过将列、运算符和闭包传递给 <code>where</code> 方法来完成此操作。例如，以下查询将检索金额小于平均值的所有收入记录；</p>
<pre><code><span class="keyword token">use</span> App\Models\Income;

<span class="variable token">$incomes</span> = Income::where(<span class="string token">'amount'</span>, <span class="string token">'&lt;'</span>, <span class="keyword token">function</span> (<span class="variable token">$query</span>) {
    <span class="variable token">$query</span>-&gt;selectRaw(<span class="string token">'avg(i.amount)'</span>)-&gt;from(<span class="string token">'incomes as i'</span>);
})-&gt;get();
</code></pre>
<p><a name="full-text-where-clauses"></a></p>
<h3 id="全文-where-子句">全文 Where 子句</h3>
<blockquote>
<p>注意：MySQL 和 PostgreSQL 目前支持全文 where 子句。</p>
</blockquote>
<p>可以使用<code>where FullText</code>和<code>orWhere FullText</code>方法将全文“WHERE”子句添加到具有<a href="migrations.html#available-index-types">Full Text indexes</a>的列的查询中。这些方法将由Laravel转换为适用于底层数据库系统的SQL。例如，使用MySQL的应用会生成<code>Match AGAINST</code>子句：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
           -&gt;whereFullText(<span class="string token">'bio'</span>, <span class="string token">'web developer'</span>)
           -&gt;get();
</code></pre>
<p><a name="ordering-grouping-limit-and-offset"></a></p>
<h2 id="ordering-grouping-limit--offset">Ordering, Grouping, Limit &amp; Offset</h2>
<p><a name="ordering"></a></p>
<h3 id="排序">排序</h3>
<p><a name="orderby"></a></p>
<h4 id="orderby-方法"><code>orderBy</code> 方法</h4>
<p><code>orderBy</code> 方法允许您按给定列对查询结果进行排序。<code>orderBy</code> 方法接受的第一个参数应该是您希望排序的列，而第二个参数确定排序的方向，可以是 <code>asc</code> 或 <code>desc</code>：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;orderBy(<span class="string token">'name'</span>, <span class="string token">'desc'</span>)
                -&gt;get();
</code></pre>
<p>要按多列排序，您可以根据需要多次调用 <code>orderBy</code>：</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;orderBy(<span class="string token">'name'</span>, <span class="string token">'desc'</span>)
                -&gt;orderBy(<span class="string token">'email'</span>, <span class="string token">'asc'</span>)
                -&gt;get();
</code></pre>
<p><a name="latest-oldest"></a></p>
<h4 id="latest-和-oldest-方法"><code>latest</code> 和 <code>oldest</code> 方法</h4>
<p><code>latest</code> 和 <code>oldest</code> 方法可以方便让你把结果根据日期排序。查询结果默认根据数据表的 <code>created_at</code> 字段进行排序 。或者，你可以传一个你想要排序的列名，通过:</p>
<pre><code><span class="variable token">$user</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;latest()
                -&gt;first();
</code></pre>
<p><a name="random-ordering"></a></p>
<h4 id="随机排序">随机排序</h4>
<p><code>inRandomOrder</code> 方法被用来将查询结果随机排序。例如，你可以使用这个方法去获得一个随机用户:</p>
<pre><code><span class="variable token">$randomUser</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;inRandomOrder()
                -&gt;first();
</code></pre>
<p><a name="removing-existing-orderings"></a></p>
<h4 id="移除已存在的排序">移除已存在的排序</h4>
<p><code>reorder</code> 方法会移除之前已经被应用到查询里的排序:</p>
<pre><code><span class="variable token">$query</span> = DB::table(<span class="string token">'users'</span>)-&gt;orderBy(<span class="string token">'name'</span>);

<span class="variable token">$unorderedUsers</span> = <span class="variable token">$query</span>-&gt;reorder()-&gt;get();
</code></pre>
<p>当你调用 <code>reorder</code> 方法去移除所有已经存在的排序的时候，你可以传递一个列名和排序方式去重新排序整个查询:</p>
<pre><code><span class="variable token">$query</span> = DB::table(<span class="string token">'users'</span>)-&gt;orderBy(<span class="string token">'name'</span>);

<span class="variable token">$usersOrderedByEmail</span> = <span class="variable token">$query</span>-&gt;reorder(<span class="string token">'email'</span>, <span class="string token">'desc'</span>)-&gt;get();
</code></pre>
<p><a name="grouping"></a></p>
<h3 id="分组">分组</h3>
<p><a name="groupby-having"></a></p>
<h4 id="groupby-和-having-方法"><code>groupBy</code> 和 <code>having</code> 方法</h4>
<p>如你所愿，<code>groupBy</code> 和 <code>having</code> 方法可以将查询结果分组。<code>having</code> 方法的使用方法类似于 <code>where</code> 方法:</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;groupBy(<span class="string token">'account_id'</span>)
                -&gt;having(<span class="string token">'account_id'</span>, <span class="string token">'&gt;'</span>, <span class="number token">100</span>)
                -&gt;get();
</code></pre>
<p>你可以使用 <code>havingBetween</code> 方法在一个给定的范围内去过滤结果:</p>
<pre><code><span class="variable token">$report</span> = DB::table(<span class="string token">'orders'</span>)
                -&gt;selectRaw(<span class="string token">'count(id) as number_of_orders, customer_id'</span>)
                -&gt;groupBy(<span class="string token">'customer_id'</span>)
                -&gt;havingBetween(<span class="string token">'number_of_orders'</span>, [<span class="number token">5</span>, <span class="number token">15</span>])
                -&gt;get();
</code></pre>
<p>你可以传多个参数给 <code>groupBy</code> 方法将多列分组:</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;groupBy(<span class="string token">'first_name'</span>, <span class="string token">'status'</span>)
                -&gt;having(<span class="string token">'account_id'</span>, <span class="string token">'&gt;'</span>, <span class="number token">100</span>)
                -&gt;get();
</code></pre>
<p>想要构造更高级的 <code>having</code> 语句, 看 <a href="#raw-methods"><code>havingRaw</code></a> 方法。</p>
<p><a name="limit-and-offset"></a></p>
<h3 id="limit-和-offset">Limit 和 Offset</h3>
<p><a name="skip-take"></a></p>
<h4 id="skip-和-take-方法"><code>skip</code> 和 <code>take</code> 方法</h4>
<p>你可以使用 <code>skip</code> 和 <code>take</code> 方法去限制查询结果的返回数量或者在查询结果中跳过给定数量:</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)-&gt;skip(<span class="number token">10</span>)-&gt;take(<span class="number token">5</span>)-&gt;get();
</code></pre>
<p>或者，你可以使用 <code>limit</code> 和 <code>offset</code> 方法。这些方法在功能上等同于 <code>take</code> 和 <code>skip</code> 方法, 如下:</p>
<pre><code><span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;offset(<span class="number token">10</span>)
                -&gt;limit(<span class="number token">5</span>)
                -&gt;get();
</code></pre>
<p><a name="conditional-clauses"></a></p>
<h2 id="条件语句">条件语句</h2>
<p>有时，您可能希望根据另一个条件将某些查询子句应用于查询。例如，当传入 HTTP 请求有一个给定的值的时候你才需要使用一个<code>where</code> 语句。你可以使用 <code>when</code> 方法去实现:</p>
<pre><code><span class="variable token">$role</span> = <span class="variable token">$request</span>-&gt;input(<span class="string token">'role'</span>);

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;when(<span class="variable token">$role</span>, <span class="keyword token">function</span> (<span class="variable token">$query</span>, <span class="variable token">$role</span>) {
                    <span class="keyword token">return</span> <span class="variable token">$query</span>-&gt;where(<span class="string token">'role_id'</span>, <span class="variable token">$role</span>);
                })
                -&gt;get();
</code></pre>
<p> <code>when</code> 方法只有当第一个参数为 <code>true</code> 的时候才执行给定的闭包。如果第一个参数是 <code>false</code>，闭包将不会被执行。因此，在上面的例子中，只要在传入的请求中存在 <code>role</code> 字段，并且结果为 <code>true</code> 的时候， <code>when</code> 方法里的闭包才会被调用。</p>
<p>你可以将另一个闭包作为第三个参数传递给 <code>when</code> 方法。只有当第一个参数的计算结果为 <code>false</code>时，这个闭包才会执行。为了说明如何使用此功能，我们将使用它来配置查询的默认排序：</p>
<pre><code><span class="variable token">$sortByVotes</span> = <span class="variable token">$request</span>-&gt;input(<span class="string token">'sort_by_votes'</span>);

<span class="variable token">$users</span> = DB::table(<span class="string token">'users'</span>)
                -&gt;when(<span class="variable token">$sortByVotes</span>, <span class="keyword token">function</span> (<span class="variable token">$query</span>, <span class="variable token">$sortByVotes</span>) {
                    <span class="keyword token">return</span> <span class="variable token">$query</span>-&gt;orderBy(<span class="string token">'votes'</span>);
                }, <span class="keyword token">function</span> (<span class="variable token">$query</span>) {
                    <span class="keyword token">return</span> <span class="variable token">$query</span>-&gt;orderBy(<span class="string token">'name'</span>);
                })
                -&gt;get();
</code></pre>
<p><a name="insert-statements"></a></p>
<h2 id="插入语句">插入语句</h2>
<p>查询构建器还提供了一个「插入」方法，可用于将记录插入到数据库表中。 <code>insert</code> 方法接受一个列名和值的数组：</p>
<pre><code>DB::table('users')-&gt;insert([
    'email' =&gt; 'kayla@example.com',
    'votes' =&gt; 0
]);
</code></pre>
<p>你可以通过传递数组数组一次插入多条记录。每个数组代表一个应该插入到表中的记录：</p>
<pre><code>DB::table('users')-&gt;insert([
    ['email' =&gt; 'picard@example.com', 'votes' =&gt; 0],
    ['email' =&gt; 'janeway@example.com', 'votes' =&gt; 0],
]);
</code></pre>
<p><code>insertOrIgnore</code> 方法将在将记录插入数据库时忽略错误：</p>
<pre><code>DB::table('users')-&gt;insertOrIgnore([
    ['id' =&gt; 1, 'email' =&gt; 'sisko@example.com'],
    ['id' =&gt; 2, 'email' =&gt; 'archer@example.com'],
]);
</code></pre>
<blockquote>
<p>注意：<code>insertOrIgnore</code> 将忽略重复记录，也可能会忽略其他类型的错误，具体取决于数据库引擎。例如，<code>insertOrIgnore</code> 将 <a href="https://dev.mysql.com/doc/refman/en/sql-mode.html#ignore-effect-on-execution">绕过 MySQL 的严格模式</a>.</p>
</blockquote>
<p><a name="auto-incrementing-ids"></a></p>
<h4 id="自增-ids">自增 IDs</h4>
<p>如果数据表有自增 ID ，使用 insertGetId 方法来插入记录可以返回 ID 值：</p>
<pre><code><span class="variable token">$id</span> = DB::table(<span class="string token">'users'</span>)-&gt;insertGetId(
    [<span class="string token">'email'</span> =&gt; <span class="string token">'john@example.com'</span>, <span class="string token">'votes'</span> =&gt; <span class="number token">0</span>]
);
</code></pre>
<blockquote>
<p>注意：当使用 PostgreSQL 时，<code>insertGetId</code> 方法将默认把 <code>id</code> 作为自动递增字段的名称。如果你要从其他「字段」来获取 ID ，则需要将字段名称作为第二个参数传递给 <code>insertGetId</code> 方法。</p>
</blockquote>
<p><a name="upserts"></a></p>
<h3 id="upserts">Upserts</h3>
<p><code>upsert</code> 方法将插入不存在的记录，并使用您可以指定的新值更新已经存在的记录。该方法的第一个参数包含要插入或更新的值，而第二个参数列出了在关联表中唯一标识记录的列。 该方法的第三个也是最后一个参数是一个列数组，如果数据库中已经存在匹配的记录，则应该更新这些列：</p>
<pre><code>DB::table('flights')-&gt;upsert([
    ['departure' =&gt; 'Oakland', 'destination' =&gt; 'San Diego', 'price' =&gt; 99],
    ['departure' =&gt; 'Chicago', 'destination' =&gt; 'New York', 'price' =&gt; 150]
], ['departure', 'destination'], ['price']);
</code></pre>
<p>在上面的例子中，Laravel 会尝试插入两条记录。如果已经存在具有相同 <code>departure</code> 和 <code>destination</code> 列值的记录，Laravel 将更新该记录的 <code>price</code> 列。</p>
<blockquote>
<p>注意：除 SQL Server 之外的所有数据库都要求 <code>upsert</code> 方法的第二个参数中的列具有“主”或“唯一”索引。 此外，MySQL 数据库驱动程序忽略 <code>upsert</code> 方法的第二个参数，并始终使用表的“主”和“唯一”索引来检测现有记录。</p>
</blockquote>
<p><a name="update-statements"></a></p>
<h2 id="update-语句">Update 语句</h2>
<p>除了将记录插入数据库之外，查询构建器还可以使用 <code>update</code> 方法更新现有记录。 <code>update</code> 方法与 <code>insert</code> 方法一样，接受一个列和值对数组，指示要更新的列。 <code>update</code> 方法返回受影响的行数。您可以使用 <code>where</code> 子句限制 <code>update</code> 查询：</p>
<pre><code><span class="variable token">$affected</span> = DB::table(<span class="string token">'users'</span>)
              -&gt;where(<span class="string token">'id'</span>, <span class="number token">1</span>)
              -&gt;update([<span class="string token">'votes'</span> =&gt; <span class="number token">1</span>]);
</code></pre>
<p><a name="update-or-insert"></a></p>
<h4 id="更新或新增">更新或新增</h4>
<p>有时您可能希望更新数据库中的现有记录，或者如果不存在匹配记录则创建它。在这种情况下，可以使用 <code>updateOrInsert</code> 方法。<code>updateOrInsert</code> 方法接受两个参数：一个用于查找记录的条件数组，以及一个包含要更该记录的键值对数组。</p>
<p><code>updateOrInsert</code> 方法将尝试使用第一个参数的列和值对来定位匹配的数据库记录。如果记录存在，它将使用第二个参数中的值进行更新。如果找不到记录，将插入一条新记录，其中包含两个参数的合并属性：</p>
<pre><code>DB::table('users')
    -&gt;updateOrInsert(
        ['email' =&gt; 'john@example.com', 'name' =&gt; 'John'],
        ['votes' =&gt; '2']
    );
</code></pre>
<p><a name="updating-json-columns"></a></p>
<h3 id="更新-json-字段">更新 JSON 字段</h3>
<p>更新 JSON 字段时，你可以使用 <code>-&gt;</code> 语法访问 JSON 对象中相应的值。注意，此操作只能支持 <code>MySQL 5.7+</code> 和 <code>PostgreSQL 9.5+</code> ：</p>
<pre><code><span class="variable token">$affected</span> = DB::table(<span class="string token">'users'</span>)
              -&gt;where(<span class="string token">'id'</span>, <span class="number token">1</span>)
              -&gt;update([<span class="string token">'options-&gt;enabled'</span> =&gt; <span class="keyword token">true</span>]);
</code></pre>
<p><a name="increment-and-decrement"></a></p>
<h3 id="自增与自减">自增与自减</h3>
<p>查询构建器还提供了方便的方法来增加或减少给定列的值。这两种方法都至少接受一个参数：要修改的列。可以提供第二个参数来指定列应该增加或减少的数量：</p>
<pre><code>DB::table('users')-&gt;increment('votes');

DB::table('users')-&gt;increment('votes', 5);

DB::table('users')-&gt;decrement('votes');

DB::table('users')-&gt;decrement('votes', 5);
</code></pre>
<p>您还可以在操作期间指定要更新的其他列：</p>
<pre><code>DB::table('users')-&gt;increment('votes', 1, ['name' =&gt; 'John']);
</code></pre>
<p><a name="delete-statements"></a></p>
<h2 id="删除语句">删除语句</h2>
<p>查询构建器的 <code>delete</code> 方法可用于从表中删除记录。 <code>delete</code> 方法返回受影响的行数。您可以通过在调用 <code>delete</code> 方法之前添加“where”子句来限制 <code>delete</code> 语句：</p>
<pre><code><span class="variable token">$deleted</span> = DB::table(<span class="string token">'users'</span>)-&gt;delete();

<span class="variable token">$deleted</span> = DB::table(<span class="string token">'users'</span>)-&gt;where(<span class="string token">'votes'</span>, <span class="string token">'&gt;'</span>, <span class="number token">100</span>)-&gt;delete();
</code></pre>
<p>如果您希望截断整个表，这将从表中删除所有记录并将自动递增 ID 重置为零，您可以使用 <code>truncate</code> 方法：</p>
<pre><code>DB::table('users')-&gt;truncate();
</code></pre>
<p><a name="table-truncation-and-postgresql"></a></p>
<h4 id="截断表--postgresql">截断表 &amp; PostgreSQL</h4>
<p>截断 PostgreSQL 数据库时，将应用 <code>CASCADE</code> 行为。这意味着其他表中所有与外键相关的记录也将被删除。</p>
<p><a name="pessimistic-locking"></a></p>
<h2 id="悲观锁">悲观锁</h2>
<p>查询构建器还包括一些函数，可帮助您在执行 <code>select</code> 语句时实现「悲观锁」。 要使用「共享锁」执行语句，您可以调用 <code>sharedLock</code> 方法。共享锁可防止选定的行被修改，直到您的事务被提交：</p>
<pre><code>DB::table('users')
        -&gt;where('votes', '&gt;', 100)
        -&gt;sharedLock()
        -&gt;get();
</code></pre>
<p>或者，您可以使用 <code>lockForUpdate</code> 方法。「update」锁可防止所选记录被修改或被另一个共享锁选中：</p>
<pre><code>DB::table('users')
        -&gt;where('votes', '&gt;', 100)
        -&gt;lockForUpdate()
        -&gt;get();
</code></pre>
<p><a name="debugging"></a></p>
<h2 id="调试">调试</h2>
<p>您可以在构建查询时使用 <code>dd</code> 和 <code>dump</code> 方法来转储当前查询绑定和 SQL。 <code>dd</code> 方法将显示调试信息，然后停止执行请求。 <code>dump</code> 方法将显示调试信息，但允许请求继续执行：</p>
<pre><code>DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;dd();

DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;dump();
</code></pre>
</div>
    <blockquote style="font-size: 0.9em;">
        本译文仅用于学习和交流目的，转载请务必注明文章译者、出处、和本文链接 <br>
        我们的翻译工作遵照 <a href="https://learnku.com/docs/guide/cc4.0/6589">CC 协议</a>，如果我们的工作有侵犯到您的权益，请及时联系我们。
    </blockquote>
</body>

</html>
