<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Laravel 9.x 中文文档</title>
    <link rel="stylesheet" href="../style/idea.css">
<link rel="stylesheet" href="../style/bd0cbd7aa15e5518a47099735133bf3a-vendors.css">
<link rel="stylesheet" href="../style/a91e47e2539b98438cb4c6c3a665d642-app.css">
    <style>
        div.markdown-body {
            margin: 0 10px;
        }
    </style>
</head>

<body>
    <div class="markdown-body"><h1 id="队列">队列</h1>
<ul>
<li><a href="#introduction">简介</a><ul>
<li><a href="#connections-vs-queues">连接 Vs. 驱动</a></li>
<li><a href="#driver-prerequisites">驱动程序说明 &amp; 先决条件</a></li>
</ul>
</li>
<li><a href="#creating-jobs">创建任务</a><ul>
<li><a href="#generating-job-classes">生成任务类</a></li>
<li><a href="#class-structure">任务类结构</a></li>
<li><a href="#unique-jobs">任务唯一</a></li>
</ul>
</li>
<li><a href="#job-middleware">任务中间件</a><ul>
<li><a href="#rate-limiting">访问限制</a></li>
<li><a href="#preventing-job-overlaps">防止重复任务</a></li>
<li><a href="#throttling-exceptions">限制异常</a></li>
</ul>
</li>
<li><a href="#dispatching-jobs">分发任务</a><ul>
<li><a href="#delayed-dispatching">延迟分发</a></li>
<li><a href="#synchronous-dispatching">同步调度</a></li>
<li><a href="#jobs-and-database-transactions">任务 &amp; 数据库事务</a></li>
<li><a href="#job-chaining">任务链</a></li>
<li><a href="#customizing-the-queue-and-connection">自定义队列 &amp; 连接</a></li>
<li><a href="#max-job-attempts-and-timeout">指定任务最大尝试次数 / 超时值</a></li>
<li><a href="#error-handling">错误处理</a></li>
</ul>
</li>
<li><a href="#job-batching">任务批处理</a><ul>
<li><a href="#defining-batchable-jobs">定义批处理任务</a></li>
<li><a href="#dispatching-batches">分发批处理</a></li>
<li><a href="#adding-jobs-to-batches">将任务加入批处理</a></li>
<li><a href="#inspecting-batches">校验批处理</a></li>
<li><a href="#cancelling-batches">取消批处理</a></li>
<li><a href="#batch-failures">批处理失败</a></li>
<li><a href="#pruning-batches">批量清理</a></li>
</ul>
</li>
<li><a href="#queueing-closures">队列闭包</a></li>
<li><a href="#running-the-queue-worker">运行队列处理器</a><ul>
<li><a href="#the-queue-work-command"><code>queue:work</code> 命令</a></li>
<li><a href="#queue-priorities">队列优先级</a></li>
<li><a href="#queue-workers-and-deployment">队列处理器 &amp; 部署</a></li>
<li><a href="#job-expirations-and-timeouts">任务过期 &amp; 超时</a></li>
</ul>
</li>
<li><a href="#supervisor-configuration">Supervisor 配置</a></li>
<li><a href="#dealing-with-failed-jobs">处理失败队列</a><ul>
<li><a href="#cleaning-up-after-failed-jobs">清理失败任务</a></li>
<li><a href="#retrying-failed-jobs">重试失败任务</a></li>
<li><a href="#ignoring-missing-models">忽略缺失的模型</a></li>
<li><a href="#pruning-failed-jobs">清理失败的任务</a></li>
<li><a href="#storing-failed-jobs-in-dynamodb">在 DynamoDB 中存储失败的任务</a></li>
<li><a href="#disabling-failed-job-storage">禁用失败的任务存储</a></li>
<li><a href="#failed-job-events">任务失败事件</a></li>
</ul>
</li>
<li><a href="#clearing-jobs-from-queues">清理队列任务</a></li>
<li><a href="#monitoring-your-queues">监控你的队列</a></li>
<li><a href="#job-events">任务事件</a></li>
</ul>
<p><a name="introduction"></a></p>
<h2 id="简介">简介</h2>
<p>在构建 Web 应用程序时，你可能需要执行一些任务（例如解析和存储上传的 CSV 文件），但这些任务在典型的 Web 请求中花费的时间太长。幸运的是，Laravel 允许你轻松地创建可在后台排队处理的任务作业。通过将耗时的任务移到队列中，你的应用程序可以以超快的速度响应 Web 请求，并为客户提供更好的用户体验。</p>
<p>Laravel 队列提供了可以跨各种不同队列后台的统一 API，例如 <a href="https://aws.amazon.com/sqs/">Amazon SQS</a>, <a href="https://redis.io">Redis</a> 甚至关系数据库。</p>
<p>队列配置文件存储在 <code>config/queue.php</code> 中。 在这个文件中，你可以找到框架中包含的每个队列驱动程序的连接配置，其中包括数据库，<a href="https://aws.amazon.com/sqs/">Amazon SQS</a>, <a href="https://redis.io">Redis</a>, 和 <a href="https://beanstalkd.github.io/">Beanstalkd</a> 驱动，一个同步驱动程序（供本地使用）。还包括一个用于丢弃排队任务的   <code>null</code> 队列驱动。</p>
<blockquote>
<p>技巧：现在，Laravel 为你的 Redis 队列提供了 Horizon，一个漂亮的仪表盘和配置系统。查看完整的 <a href="horizon.html">Horizon documentation</a> 了解更多信息。</p>
</blockquote>
<p><a name="connections-vs-queues"></a></p>
<h3 id="连接-vs-队列">连接 Vs 队列</h3>
<p>在开始使用 Laravel 队列之前，理解「连接」和「队列」之间的区别非常重要。在 <code>config/queue.php</code> 配置文件中，有一个 <code>connections</code> 配置选项。此选项定义到后端服务（如 Amazon SQS、Beanstalk 或 Redis）的特定连接。然而，任何给定的队列连接都可能有多个「队列」，这些「队列」可能被认为是不同的堆栈或成堆的排队任务。</p>
<p>请注意， <code>queue</code> 配置文件中的每个连接配置示例都包含一个 <code>queue</code> 属性。 这是将任务发送到给定连接时将被分配到的默认队列。换句话说，如果您没有显式地定义任务应该被发送到哪个队列，那么该任务将被放置在连接配置的 <code>queue</code>  属性中定义的队列上：</p>
<pre><code><span class="keyword token">use</span> App\Jobs\ProcessPodcast;

<span class="comment token">// 这个任务将被推送到默认队列...</span>
ProcessPodcast::dispatch();

<span class="comment token">// 这个任务将被推送到 "emails" 队列...</span>
ProcessPodcast::dispatch()-&gt;onQueue(<span class="string token">'emails'</span>);
</code></pre>
<p>有些应用程序可能不需要将任务推到多个队列中，而是倾向于使用一个简单的队列。然而，如果希望对任务的处理方式进行优先级排序或分段时，将任务推送到多个队列就显得特别有用，因为 Laravel 队列工作程序允许您指定哪些队列应该按优先级处理。例如，如果您将任务推送到一个 <code>high</code> 队列，你可能会运行一个赋予它们更高处理优先级的 worker：</p>
<pre><code class="language-shell">php artisan queue:work --queue=high,<span class="keyword token">default</span>
</code></pre>
<p><a name="driver-prerequisites"></a></p>
<h3 id="驱动程序说明和先决条件">驱动程序说明和先决条件</h3>
<p><a name="database"></a></p>
<h4 id="数据库">数据库</h4>
<p>要使用  <code>database</code> 队列驱动程序，你需要一个数据库表来保存任务。要生成创建此表的迁移，请运行 <code>queue:table</code> Artisan 命令。一旦迁移已经创建，你可以使用 <code>migrate</code>命令迁移你的数据库：</p>
<pre><code class="language-shell">php artisan queue:table

php artisan migrate
</code></pre>
<p>最后，请不要忘记通过修改<code>.env</code>文件中的<code>QUEUE_CONNECTION</code>变量从而将 <code>database</code> 作为你的应用队列驱动程序:</p>
<pre><code>QUEUE_CONNECTION=database
</code></pre>
<p><a name="redis"></a></p>
<h4 id="redis">Redis</h4>
<p>要使用 <code>redis</code> 队列驱动程序，需要在 <code>config/database.php</code>配置文件中配置一个 redis 数据库连接。</p>
<p><strong>Redis 集群</strong></p>
<p>如果你的Redis队列当中使用了Redis集群, 那么你的队列名称就必须包含一个 <a href="https://redis.io/topics/cluster-spec#keys-hash-tags">key hash tag</a>。这是为了确保一个给定队列的所有 Redis 键都被放在同一个哈希插槽：</p>
<pre><code>'redis' =&gt; [
    'driver' =&gt; 'redis',
    'connection' =&gt; 'default',
    'queue' =&gt; '{default}',
    'retry_after' =&gt; 90,
],
</code></pre>
<p><strong>阻塞</strong></p>
<p>在使用 Redis 队列时，您可以使用<code>block_for</code> 配置选项来指定在遍历 worker 循环和重新轮询 Redis 数据库之前，驱动程序需要等待多长时间才能使任务变得可用。</p>
<p>根据您的队列负载调整此值要比连续轮询 Redis 数据库中的新任务更加有效。例如，您可以将值设置为  <code>5</code> 以指示驱动程序在等待任务变得可用时应该阻塞 5 秒：</p>
<pre><code>'redis' =&gt; [
    'driver' =&gt; 'redis',
    'connection' =&gt; 'default',
    'queue' =&gt; 'default',
    'retry_after' =&gt; 90,
    'block_for' =&gt; 5,
],
</code></pre>
<blockquote>
<p>注意：将 <code>block_for</code> 设置为 <code>0</code> 将导致队列workers一直阻塞，直到某一个任务变得可用。这还能防止在下一个任务被处理之前处理诸如 <code>SIGTERM</code> 之类的信号。</p>
</blockquote>
<p><a name="other-driver-prerequisites"></a></p>
<h4 id="其他驱动的先决条件">其他驱动的先决条件</h4>
<p>列出的队列驱动需要如下的依赖，这些依赖可通过 Composer 包管理器进行安装：</p>
<div class="content-list" markdown="1">

<ul>
<li>Amazon SQS: <code>aws/aws-sdk-php ~3.0</code></li>
<li>Beanstalkd: <code>pda/pheanstalk ~4.0</code></li>
<li>Redis: <code>predis/predis ~1.0</code> or phpredis PHP 扩展</li>
</ul>
</div>

<p><a name="creating-jobs"></a></p>
<h2 id="创建任务">创建任务</h2>
<p><a name="generating-job-classes"></a></p>
<h3 id="生成任务类">生成任务类</h3>
<p>默认情况下，应用程序的所有的可排队任务都被存储在了 <code>app/Jobs</code> 目录中。如果 <code>app/Jobs</code> 目录不存在，当您运行 <code>make:job</code> Artisan 命令时，将会自动创建该目录：</p>
<pre><code class="language-shell">php artisan make:job ProcessPodcast
</code></pre>
<p>生成的类将会实现 <code>Illuminate\Contracts\Queue\ShouldQueue</code> 接口， 告诉 Laravel ，该任务应该推入队列以异步的方式运行。</p>
<blockquote>
<p>技巧：您可以使用 <a href="artisan.html#stub-customization">stub publishing</a>来自定义任务 stub 。</p>
</blockquote>
<p><a name="class-structure"></a></p>
<h3 id="类结构">类结构</h3>
<p>任务类非常简单，通常只包含一个 <code>handle</code> 方法，在队列处理任务时将会调用它。让我们看一个任务类的示例。在这个例子中，我们假设我们管理一个 podcast 服务，并且需要在上传的 podcast 文件发布之前对其进行处理：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs;

<span class="keyword token">use</span> App\Models\Podcast;
<span class="keyword token">use</span> App\Services\AudioProcessor;
<span class="keyword token">use</span> Illuminate\Bus\Queueable;
<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldQueue;
<span class="keyword token">use</span> Illuminate\Foundation\Bus\Dispatchable;
<span class="keyword token">use</span> Illuminate\Queue\InteractsWithQueue;
<span class="keyword token">use</span> Illuminate\Queue\SerializesModels;

<span class="keyword token">class</span> ProcessPodcast <span class="keyword token">implements</span> ShouldQueue
{
    <span class="keyword token">use</span> Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    <span class="comment token">/**
     * podcast 实例
     *
     *<span class="phpdoc token"> @var</span> \App\Models\Podcast
     */</span>
    <span class="keyword token">protected</span> <span class="variable token">$podcast</span>;

    <span class="comment token">/**
     * 创建一个新的任务实例
     *
     *<span class="phpdoc token"> @param</span>  App\Models\Podcast  $podcast
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> __construct(Podcast <span class="variable token">$podcast</span>)
    {
        <span class="variable token">$this</span>-&gt;podcast = <span class="variable token">$podcast</span>;
    }

    <span class="comment token">/**
     * 运行任务
     *
     *<span class="phpdoc token"> @param</span>  App\Services\AudioProcessor  $processor
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> handle(AudioProcessor <span class="variable token">$processor</span>)
    {
        <span class="comment token">// 处理上传的 podcast...</span>
    }
}
</code></pre>
<p>在本示例中，请注意，我们能够将一个 <a href="eloquent.html">Eloquent model</a> 直接传递到已排队任务的构造函数中。由于任务所使用的 <code>SerializesModels</code>，在任务处理时，Eloquent 模型及其加载的关系将被优雅地序列化和反序列化。</p>
<p>如果你的队列任务在其构造函数中接受一个 Eloquent 模型，那么只有模型的标识符才会被序列化到队列中。当实际处理任务时，队列系统将自动重新从数据库中获取完整的模型实例及其加载的关系。这种用于模型序列化的方式允许将更小的作业有效负载发送给你的队列驱动程序。</p>
<p><a name="handle-method-dependency-injection"></a></p>
<h4 id="handle-方法依赖注入"><code>handle</code> 方法依赖注入</h4>
<p>当任务由队列处理时，将调用 <code>handle</code> 方法。注意，我们可以对任务的 <code>handle</code> 方法进行类型提示依赖。Laravel <a href="container.html">服务容器</a> 会自动注入这些依赖项。</p>
<p>如果您想完全控制容器如何将依赖注入  <code>handle</code> 方法，你可以使用容器的 <code>bindMethod</code>  方法。 <code>bindMethod</code> 方法接受一个可接收任务和容器的回调。在回调中，你可以在任何你想用的地方随意调用 <code>handle</code> 方法。 通常， 你应该从你的 <code>App\Providers\AppServiceProvider</code> <a href="providers.html">服务提供者</a>  中来调用该方法:</p>
<pre><code><span class="keyword token">use</span> App\Jobs\ProcessPodcast;
<span class="keyword token">use</span> App\Services\AudioProcessor;

<span class="variable token">$this</span>-&gt;app-&gt;bindMethod([ProcessPodcast::<span class="keyword token">class</span>, <span class="string token">'handle'</span>], <span class="keyword token">function</span> (<span class="variable token">$job</span>, <span class="variable token">$app</span>) {
    <span class="keyword token">return</span> <span class="variable token">$job</span>-&gt;handle(<span class="variable token">$app</span>-&gt;make(AudioProcessor::<span class="keyword token">class</span>));
});
</code></pre>
<blockquote>
<p>注意：二进制数据，例如原始图像内容，应该在传递到队列任务之前通过 <code>base64_encode</code> 函数传递。否则，在将任务放入队列时，可能无法正确地序列化为 JSON。</p>
</blockquote>
<p><a name="handling-relationships"></a></p>
<h4 id="队列关系">队列关系</h4>
<p>因为加载的关系也会被序列化，所以处理序列化任务的字符串有时会变得相当大。为了防止该关系被序列化，可以在设置属性值时对模型调用 <code>withoutRelations</code> 方法。此方法将返回没有加载关系的模型实例：</p>
<pre><code><span class="comment token">/**
 * 创建新的任务实例
 *
 *<span class="phpdoc token"> @param</span>  \App\Models\Podcast  $podcast
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> __construct(Podcast <span class="variable token">$podcast</span>)
{
    <span class="variable token">$this</span>-&gt;podcast = <span class="variable token">$podcast</span>-&gt;withoutRelations();
}
</code></pre>
<p>此外，当反序列化任务并从数据库中重新检索模型关系时，它们将被完整检索。反序列化任务时，将不会应用在任务排队过程中序列化模型之前应用的任何先前关系约束。因此，如果您希望使用给定关系的子集，则应在排队任务中重新限制该关系。</p>
<p><a name="unique-jobs"></a></p>
<h3 id="unique-jobs">Unique Jobs</h3>
<blockquote>
<p>注意：Unique Jobs需要支持 <a href="cache.html#atomic-locks">locks</a> 的缓存驱动程序。 目前，<code>memcached</code>、<code>redis</code>、<code>dynamodb</code>、<code>database</code>、<code>file</code>和<code>array</code>缓存驱动支持原子锁。 此外，独特的任务约束不适用于批次内的任务。</p>
</blockquote>
<p>有时，您可能希望确保在任何时间点队列中只有一个特定任务的实例。你可以通过在你的工作类上实现 <code>ShouldBeUnique</code> 接口来做到这一点。这个接口不需要你在你的类上定义任何额外的方法：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldQueue;
<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldBeUnique;

<span class="keyword token">class</span> UpdateSearchIndex <span class="keyword token">implements</span> ShouldQueue, ShouldBeUnique
{
    ...
}
</code></pre>
<p>在上面的示例中，<code>UpdateSearchIndex</code> 任务是唯一的。因此，如果任务的另一个实例已经在队列中并且尚未完成处理，则不会分派该任务。</p>
<p>在某些情况下，您可能想要定义一个使任务唯一的特定「键」，或者您可能想要指定一个超时，超过该超时任务不再保持唯一。为此，您可以在任务类上定义 <code>uniqueId</code> 和 <code>uniqueFor</code> 属性或方法：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">use</span> App\Product;
<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldQueue;
<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldBeUnique;

<span class="keyword token">class</span> UpdateSearchIndex <span class="keyword token">implements</span> ShouldQueue, ShouldBeUnique
{
    <span class="comment token">/**
     * 产品实例。
     *
     *<span class="phpdoc token"> @var</span> \App\Product
     */</span>
    <span class="keyword token">public</span> <span class="variable token">$product</span>;

    <span class="comment token">/**
     * 作业的唯一锁将被释放的秒数。
     *
     *<span class="phpdoc token"> @var</span> int
     */</span>
    <span class="keyword token">public</span> <span class="variable token">$uniqueFor</span> = <span class="number token">3600</span>;

    <span class="comment token">/**
     * 任务的唯一 ID。
     *
     *<span class="phpdoc token"> @return</span> string
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> uniqueId()
    {
        <span class="keyword token">return</span> <span class="variable token">$this</span>-&gt;product-&gt;id;
    }
}
</code></pre>
<p>在上面的示例中， <code>UpdateSearchIndex</code> 任务中的 product ID 是唯一的。因此，在现有任务完成处理之前，任何具有相同 product ID 的任务都将被忽略。此外，如果现有任务在一小时内没有得到处理，则释放唯一锁，并将具有相同唯一键的另一个任务分派到该队列。</p>
<p><a name="keeping-jobs-unique-until-processing-begins"></a></p>
<h4 id="在任务处理开始前保证唯一">在任务处理开始前保证唯一</h4>
<p>默认情况下，在任务完成处理或所有重试尝试均失败后，唯一任务将被「解锁」。但是，在某些情况下，您可能希望任务在处理之前立即解锁。为此，您的任务类可以实现  <code>ShouldBeUniqueUntilProcessing</code>  接口，而不是实现 <code>ShouldBeUnique</code> 接口：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">use</span> App\Product;
<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldQueue;
<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldBeUniqueUntilProcessing;

<span class="keyword token">class</span> UpdateSearchIndex <span class="keyword token">implements</span> ShouldQueue, ShouldBeUniqueUntilProcessing
{
    <span class="comment token">// ...</span>
}
</code></pre>
<p><a name="unique-job-locks"></a></p>
<h4 id="唯一任务锁">唯一任务锁</h4>
<p>在底层实现中，当分发 <code>ShouldBeUnique</code> 任务时，Laravel 尝试使用<code>uniqueId</code> 键获取一个   <a href="cache.html#atomic-locks">锁</a> 。如果未获取到锁，则不会分派任务。当任务完成处理或所有重试尝试失败时，将释放此锁。默认情况下，Laravel 将使用默认的缓存驱动程序来获取此锁。但是，如果您希望使用其他驱动程序来获取锁，则可以定义一个 <code>uniqueVia</code> 方法，该方法返回一个缓存驱动对象：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\Cache;

<span class="keyword token">class</span> UpdateSearchIndex <span class="keyword token">implements</span> ShouldQueue, ShouldBeUnique
{
    ...

    <span class="comment token">/**
     * 获取唯一任务锁的缓存驱动程序。
     *
     *<span class="phpdoc token"> @return</span> \Illuminate\Contracts\Cache\Repository
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> uniqueVia()
    {
        <span class="keyword token">return</span> Cache::driver(<span class="string token">'redis'</span>);
    }
}
</code></pre>
<blockquote>
<p>技巧：如果只需要限制任务的并发处理，请改用 <a href="queues.html#preventing-job-overlaps"><code>WithoutOverlapping</code></a> 任务中间件。</p>
</blockquote>
<p><a name="job-middleware"></a></p>
<h2 id="任务中间件">任务中间件</h2>
<p>任务中间件允许你围绕排队任务的执行封装自定义逻辑，从而减少了任务本身的样板代码。例如，看下面的  <code>handle</code> 方法，它利用了 Laravel 的 Redis 速率限制特性，允许每 5 秒只处理一个任务：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\Redis;

<span class="comment token">/**
 * 执行任务
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> handle()
{
    Redis::throttle(<span class="string token">'key'</span>)-&gt;block(<span class="number token">0</span>)-&gt;allow(<span class="number token">1</span>)-&gt;every(<span class="number token">5</span>)-&gt;then(<span class="keyword token">function</span> () {
        info(<span class="string token">'取得了锁...'</span>);

        <span class="comment token">// 处理任务...</span>
    }, <span class="keyword token">function</span> () {
        <span class="comment token">// 无法获取锁...</span>

        <span class="keyword token">return</span> <span class="variable token">$this</span>-&gt;release(<span class="number token">5</span>);
    });
}
</code></pre>
<p>虽然这段代码是有效的， 但是 <code>handle</code> 方法的结构却变得杂乱，因为它掺杂了 Redis 速率限制逻辑。此外，其他任务需要使用速率限制的时候，只能将限制逻辑复制一次。</p>
<p>我们可以定义一个处理速率限制的任务中间件，而不是在 handle 方法中定义速率限制。Laravel 没有任务中间件的默认位置，所以你可以将任务中间件放置在你喜欢的任何位置。在本例中，我们将把中间件放在  <code>app/Jobs/Middleware</code>  目录：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs\Middleware;

<span class="keyword token">use</span> Illuminate\Support\Facades\Redis;

<span class="keyword token">class</span> RateLimited
{
    <span class="comment token">/**
     * 处理队列任务
     *
     *<span class="phpdoc token"> @param</span>  mixed  $job
     *<span class="phpdoc token"> @param</span>  callable  $next
     *<span class="phpdoc token"> @return</span> mixed
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> handle(<span class="variable token">$job</span>, <span class="variable token">$next</span>)
    {
        Redis::throttle(<span class="string token">'key'</span>)
                -&gt;block(<span class="number token">0</span>)-&gt;allow(<span class="number token">1</span>)-&gt;every(<span class="number token">5</span>)
                -&gt;then(<span class="keyword token">function</span> () <span class="keyword token">use</span> (<span class="variable token">$job</span>, <span class="variable token">$next</span>) {
                    <span class="comment token">// 获得了锁</span>

                    <span class="variable token">$next</span>(<span class="variable token">$job</span>);
                }, <span class="keyword token">function</span> () <span class="keyword token">use</span> (<span class="variable token">$job</span>) {
                    <span class="comment token">// 没有获取到锁</span>

                    <span class="variable token">$job</span>-&gt;release(<span class="number token">5</span>);
                });
    }
}
</code></pre>
<p>正如你看到的，类似于 <a href="middleware.html">路由中间件</a>，任务中间件接收正在处理队列任务以及一个回调来继续处理队列任务。</p>
<p>在任务中间件被创建以后，他们可能被关联到通过从任务的 <code>middleware</code>方法返回的任务。这个方法并不存在于 <code>make:job</code>  Artisan 命令搭建的任务中，所以你需要将它添加到你自己的任务类的定义中：</p>
<pre><code><span class="keyword token">use</span> App\Jobs\Middleware\RateLimited;

<span class="comment token">/**
 * 获取一个可以被传递通过的中间件任务。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [<span class="keyword token">new</span> RateLimited];
}
</code></pre>
<blockquote>
<p>技巧：任务中间件也可以分配其他可队列处理的监听事件当中，比如邮件，通知等。</p>
</blockquote>
<p><a name="rate-limiting"></a></p>
<h3 id="访问限制">访问限制</h3>
<p>尽管我们刚刚演示了如何编写自己的访问限制的任务中间件，但 Laravel 实际上内置了一个访问限制中间件，你可以利用它来限制任务。与 <a href="routing.html#defining-rate-limiters">路由限流器</a>一样，任务访问限制器是使用 <code>RateLimiter</code> facade 的 <code>for</code> 方法定义的。</p>
<p>例如，你可能希望允许用户每小时备份一次数据，但不对高级客户施加此类限制。为此，可以在 <code>RateLimiter</code>的 <code>boot</code> 方法中定义  <code>AppServiceProvider</code>：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Cache\RateLimiting\Limit;
<span class="keyword token">use</span> Illuminate\Support\Facades\RateLimiter;

<span class="comment token">/**
 * 注册应用程序服务。
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> boot()
{
    RateLimiter::<span class="keyword token">for</span>(<span class="string token">'backups'</span>, <span class="keyword token">function</span> (<span class="variable token">$job</span>) {
        <span class="keyword token">return</span> <span class="variable token">$job</span>-&gt;user-&gt;vipCustomer()
                    ? Limit::none()
                    : Limit::perHour(<span class="number token">1</span>)-&gt;by(<span class="variable token">$job</span>-&gt;user-&gt;id);
    });
}
</code></pre>
<p>在上面的例子中，我们定义了一个小时访问限制；但是，你可以使用 <code>perMinute</code> 方法轻松定义基于分钟的访问限制。此外，您可以将任何值传递给访问限制的  <code>by</code> 方法，但是，这个值通常用于按客户来区分不同的访问限制：</p>
<pre><code><span class="keyword token">return</span> Limit::perMinute(<span class="number token">50</span>)-&gt;by(<span class="variable token">$job</span>-&gt;user-&gt;id);
</code></pre>
<p>定义速率限制后，您可以使用 Illuminate\Queue\Middleware\RateLimited 中间件将速率限制器附加到备份任务。 每次任务超过速率限制时，此中间件都会根据速率限制持续时间以适当的延迟将任务 释放回队列。</p>
<pre><code><span class="keyword token">use</span> Illuminate\Queue\Middleware\RateLimited;

<span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [<span class="keyword token">new</span> RateLimited(<span class="string token">'backups'</span>)];
}
</code></pre>
<p>将速率受限的任务释放回队列仍然会增加任务的“尝试”总数。您可能希望相应地调整您的任务类上的 <code>tries</code> 和 <code>maxExceptions</code> 属性。或者，您可能希望使用 <a href="#time-based-attempts"><code>retryUntil</code> 方法</a> 来定义不再尝试任务之前的时间量。</p>
<p>如果您不想在速率限制时重试任务，您可以使用 <code>dontRelease</code> 方法：</p>
<pre><code><span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [(<span class="keyword token">new</span> RateLimited(<span class="string token">'backups'</span>))-&gt;dontRelease()];
}
</code></pre>
<blockquote>
<p>技巧：如果你使用 Redis，你可以使用 Illuminate\Queue\Middleware\RateLimitedWithRedis 中间件，它针对 Redis 进行了微调，比基本的限速中间件更高效。</p>
</blockquote>
<p><a name="preventing-job-overlaps"></a></p>
<h3 id="防止任务重叠">防止任务重叠</h3>
<p>Laravel 包含一个 <code>Illuminate\Queue\Middleware\WithoutOverlapping</code> 中间件，允许您根据任意键防止任务重叠。当排队的任务正在修改一次只能由一个任务修改的资源时，这会很有帮助。</p>
<p>例如，假设您有一个更新用户信用评分的排队任务，并且您希望防止同一用户 ID 的信用评分更新任务 重叠。为此，您可以从任务的 <code>middleware</code> 方法返回 <code>WithoutOverlapping</code> 中间件：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Queue\Middleware\WithoutOverlapping;

<span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [<span class="keyword token">new</span> WithoutOverlapping(<span class="variable token">$this</span>-&gt;user-&gt;id)];
}
</code></pre>
<p>任何重叠的任务都将被释放回队列。您还可以指定再次尝试释放的任务之前必须经过的秒数：</p>
<pre><code><span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [(<span class="keyword token">new</span> WithoutOverlapping(<span class="variable token">$this</span>-&gt;order-&gt;id))-&gt;releaseAfter(<span class="number token">60</span>)];
}
</code></pre>
<p>如果您希望立即删除任何重叠的任务以便它们不会被重试，您可以使用 <code>dontRelease</code> 方法：</p>
<pre><code><span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [(<span class="keyword token">new</span> WithoutOverlapping(<span class="variable token">$this</span>-&gt;order-&gt;id))-&gt;dontRelease()];
}
</code></pre>
<p><code>WithoutOverlapping</code> 中间件由 Laravel 的原子锁特性提供支持。有时，您的任务可能会以未释放锁的方式意外失败或超时。因此，您可以使用 <code>expireAfter</code> 方法显式定义锁定过期时间。例如，下面的示例将指示 Laravel 在任务开始处理三分钟后释放 <code>WithoutOverlapping</code> 锁：</p>
<pre><code><span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [(<span class="keyword token">new</span> WithoutOverlapping(<span class="variable token">$this</span>-&gt;order-&gt;id))-&gt;expireAfter(<span class="number token">180</span>)];
}
</code></pre>
<blockquote>
<p>注意：<code>WithoutOverlapping</code> 中间件需要支持 <a href="cache.html#atomic-locks">locks</a> 的缓存驱动程序。 目前，<code>memcached</code>、<code>redis</code>、<code>dynamodb</code>、<code>database</code>、<code>file</code>和<code>array</code>缓存驱动支持原子锁。</p>
</blockquote>
<p><a name="throttling-exceptions"></a></p>
<h3 id="限制异常">限制异常</h3>
<p>Laravel 包含一个 <code>Illuminate\Queue\Middleware\ThrottlesExceptions</code> 中间件，允许您限制异常。一旦任务抛出给定数量的异常，所有进一步执行该任务的尝试都会延迟，直到经过指定的时间间隔。该中间件对于与不稳定的第三方服务交互的任务特别有用。</p>
<p>例如，让我们想象一个队列任务与开始抛出异常的第三方 API 交互。要限制异常，您可以从任务的 <code>middleware</code> 方法返回 <code>ThrottlesExceptions</code> 中间件。通常，此中间件应与实现 <a href="#time-based-attempts">基于时间的尝试</a> 的任务配对：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Queue\Middleware\ThrottlesExceptions;

<span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [<span class="keyword token">new</span> ThrottlesExceptions(<span class="number token">10</span>, <span class="number token">5</span>)];
}

<span class="comment token">/**
 * 确定任务应该超时的时间。
 *
 *<span class="phpdoc token"> @return</span> \DateTime
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> retryUntil()
{
    <span class="keyword token">return</span> now()-&gt;addMinutes(<span class="number token">5</span>);
}
</code></pre>
<p>中间件接受的第一个构造函数参数是任务在被限制之前可以抛出的异常数，而第二个构造函数参数是在任务被限制后再次尝试之前应该经过的分钟数。在上面的代码示例中，如果任务在 5 分钟内抛出 10 个异常，我们将等待 5 分钟，然后再次尝试该任务。</p>
<p>当任务抛出异常但尚未达到异常阈值时，通常会立即重试该任务。但是，您可以通过在将中间件附加到任务时调用 <code>backoff</code> 方法来指定此类任务应延迟的分钟数：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Queue\Middleware\ThrottlesExceptions;

<span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [(<span class="keyword token">new</span> ThrottlesExceptions(<span class="number token">10</span>, <span class="number token">5</span>))-&gt;backoff(<span class="number token">5</span>)];
}
</code></pre>
<p>在内部，这个中间件使用 Laravel 的缓存系统来实现速率限制，并利用任务的类名作为缓存“键”。 在将中间件附加到任务时，您可以通过调用 <code>by</code> 方法来覆盖此键。 如果您有多个任务与同一个第三方服务交互并且您希望它们共享一个共同的节流“桶”，这可能会很有用：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Queue\Middleware\ThrottlesExceptions;

<span class="comment token">/**
 * 获取任务时，应该通过的中间件。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> middleware()
{
    <span class="keyword token">return</span> [(<span class="keyword token">new</span> ThrottlesExceptions(<span class="number token">10</span>, <span class="number token">10</span>))-&gt;by(<span class="string token">'key'</span>)];
}
</code></pre>
<blockquote>
<p>技巧：如果你使用 Redis，你可以使用 Illuminate\Queue\Middleware\ThrottlesExceptionsWithRedis 中间件，它针对 Redis 进行了微调，比基本的异常节流中间件更高效。</p>
</blockquote>
<p><a name="dispatching-jobs"></a></p>
<h2 id="调度任务">调度任务</h2>
<p>一旦你写好了你的任务类，你可以使用任务本身的<code>dispatch</code>方法来调度它。传递给 <code>dispatch</code> 方法的参数将被提供给任务的构造函数：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Http\Controllers;

<span class="keyword token">use</span> App\Http\Controllers\Controller;
<span class="keyword token">use</span> App\Jobs\ProcessPodcast;
<span class="keyword token">use</span> App\Models\Podcast;
<span class="keyword token">use</span> Illuminate\Http\Request;

<span class="keyword token">class</span> PodcastController <span class="keyword token">extends</span> Controller
{
    <span class="comment token">/**
     * 存储一个新的播客。
     *
     *<span class="phpdoc token"> @param</span>  \Illuminate\Http\Request  $request
     *<span class="phpdoc token"> @return</span> \Illuminate\Http\Response
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> store(Request <span class="variable token">$request</span>)
    {
        <span class="variable token">$podcast</span> = Podcast::create(...);

        <span class="comment token">// ...</span>

        ProcessPodcast::dispatch(<span class="variable token">$podcast</span>);
    }
}
</code></pre>
<p>如果您想有条件地分派任务，您可以使用 <code>dispatchIf</code> 和 <code>dispatchUnless</code> 方法：</p>
<pre><code>ProcessPodcast::dispatchIf(<span class="variable token">$accountActive</span>, <span class="variable token">$podcast</span>);

ProcessPodcast::dispatchUnless(<span class="variable token">$accountSuspended</span>, <span class="variable token">$podcast</span>);
</code></pre>
<p><a name="delayed-dispatching"></a></p>
<h3 id="延迟调度">延迟调度</h3>
<p>如果您想指定任务不应立即可供队列工作人员处理，您可以在调度任务时使用“延迟”方法。例如，让我们指定一个任务在分派后 10 分钟内不能用于处理：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Http\Controllers;

<span class="keyword token">use</span> App\Http\Controllers\Controller;
<span class="keyword token">use</span> App\Jobs\ProcessPodcast;
<span class="keyword token">use</span> App\Models\Podcast;
<span class="keyword token">use</span> Illuminate\Http\Request;

<span class="keyword token">class</span> PodcastController <span class="keyword token">extends</span> Controller
{
    <span class="comment token">/**
     * 存储一个新的播客。
     *
     *<span class="phpdoc token"> @param</span>  \Illuminate\Http\Request  $request
     *<span class="phpdoc token"> @return</span> \Illuminate\Http\Response
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> store(Request <span class="variable token">$request</span>)
    {
        <span class="variable token">$podcast</span> = Podcast::create(...);

        <span class="comment token">// ...</span>

        ProcessPodcast::dispatch(<span class="variable token">$podcast</span>)
                    -&gt;delay(now()-&gt;addMinutes(<span class="number token">10</span>));
    }
}
</code></pre>
<blockquote>
<p>注意：Amazon SQS 队列服务的最大延迟时间为 15 分钟。</p>
</blockquote>
<p><a name="dispatching-after-the-response-is-sent-to-browser"></a></p>
<h4 id="响应发送到浏览器后调度">响应发送到浏览器后调度</h4>
<p>或者，<code>dispatchAfterResponse</code> 方法延迟调度任务，直到 HTTP 响应发送到用户的浏览器之后。 即使排队的任务仍在执行，这仍将允许用户开始使用应用程序。这通常应该只用于需要大约一秒钟的工作，例如发送电子邮件。由于它们是在当前 HTTP 请求中处理的，因此以这种方式分派的任务不需要运行队列工作者来处理它们：
    use App\Jobs\SendNotification;</p>
<pre><code>SendNotification::dispatchAfterResponse();
</code></pre>
<p>你也可以<code>dispatch</code>一个闭包并将<code>afterResponse</code>方法链接到<code>dispatch</code>帮助器以在HTTP响应发送到浏览器后执行一个闭包：</p>
<pre><code><span class="keyword token">use</span> App\Mail\WelcomeMessage;
<span class="keyword token">use</span> Illuminate\Support\Facades\Mail;

dispatch(<span class="keyword token">function</span> () {
    Mail::to(<span class="string token">'taylor@example.com'</span>)-&gt;send(<span class="keyword token">new</span> WelcomeMessage);
})-&gt;afterResponse();
</code></pre>
<p><a name="synchronous-dispatching"></a></p>
<h3 id="同步调度">同步调度</h3>
<p>如果您想立即（同步）调度任务，您可以使用 <code>dispatchSync</code> 方法。使用此方法时，任务不会排队，会在当前进程内立即执行：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Http\Controllers;

<span class="keyword token">use</span> App\Http\Controllers\Controller;
<span class="keyword token">use</span> App\Jobs\ProcessPodcast;
<span class="keyword token">use</span> App\Models\Podcast;
<span class="keyword token">use</span> Illuminate\Http\Request;

<span class="keyword token">class</span> PodcastController <span class="keyword token">extends</span> Controller
{
    <span class="comment token">/**
     * 存储一个新的播客。
     *
     *<span class="phpdoc token"> @param</span>  \Illuminate\Http\Request  $request
     *<span class="phpdoc token"> @return</span> \Illuminate\Http\Response
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> store(Request <span class="variable token">$request</span>)
    {
        <span class="variable token">$podcast</span> = Podcast::create(...);

        <span class="comment token">// Create podcast...</span>

        ProcessPodcast::dispatchSync(<span class="variable token">$podcast</span>);
    }
}
</code></pre>
<p><a name="jobs-and-database-transactions"></a></p>
<h3 id="任务--数据库事务">任务 &amp; 数据库事务</h3>
<p>虽然在数据库事务中分派任务非常好，但您应该特别注意确保您的任务实际上能够成功执行。在事务中调度任务时，任务可能会在父事务提交之前由工作人员处理。发生这种情况时，您在数据库事务期间对模型或数据库记录所做的任何更新可能尚未反映在数据库中。此外，在事务中创建的任何模型或数据库记录可能不存在于数据库中。</p>
<p>值得庆幸的是，Laravel 提供了几种解决这个问题的方法。首先，您可以在队列连接的配置数组中设置 <code>after_commit</code> 连接选项：</p>
<pre><code><span class="string token">'redis'</span> =&gt; [
    <span class="string token">'driver'</span> =&gt; <span class="string token">'redis'</span>,
    <span class="comment token">// ...</span>
    <span class="string token">'after_commit'</span> =&gt; <span class="keyword token">true</span>,
],
</code></pre>
<p>当 <code>after_commit</code> 选项为 <code>true</code> 时，你可以在数据库事务中分发任务；Laravel 会等到所有打开的数据库事务都已提交，然后才会开始分发任务。当然，如果当前没有打开的数据库事务，任务将被立即分发。</p>
<p>如果事务因事务期间发生异常而回滚，则在该事务期间分发的已分发任务将被丢弃。</p>
<blockquote>
<p>技巧：将 <code>after_commit</code> 配置选项设置为 <code>true</code> 还会导致所有排队的事件监听器、邮件、通知和广播事件在所有打开的数据库事务提交后才被调度。</p>
</blockquote>
<p><a name="specifying-commit-dispatch-behavior-inline"></a></p>
<h4 id="内联指定提交调度">内联指定提交调度</h4>
<p>如果你没有将 <code>after_commit</code> 队列连接配置选项设置为 <code>true</code>，你可能需要在所有打开的数据库事务提交后才调度特定的任务。为此，你可以将 <code>afterCommit</code> 方法放到你的调度操作上：</p>
<pre><code><span class="keyword token">use</span> App\Jobs\ProcessPodcast;

ProcessPodcast::dispatch(<span class="variable token">$podcast</span>)-&gt;afterCommit();
</code></pre>
<p>同样，如果 <code>after_commit</code> 配置选项设置为 <code>true</code>，则可以指示应立即调度特定作业，而无需等待任何打开的数据库事务提交：</p>
<pre><code>ProcessPodcast::dispatch(<span class="variable token">$podcast</span>)-&gt;beforeCommit();
</code></pre>
<p><a name="job-chaining"></a></p>
<h3 id="任务链">任务链</h3>
<p>任务链允许您指定一组应在主任务成功执行后按顺序运行的排队任务。如果序列中的一个任务失败，其余的任务将不会运行。要执行一个排队的任务链，你可以使用 <code>Bus</code> facade 提供的 <code>chain</code> 方法：</p>
<pre><code><span class="keyword token">use</span> App\Jobs\OptimizePodcast;
<span class="keyword token">use</span> App\Jobs\ProcessPodcast;
<span class="keyword token">use</span> App\Jobs\ReleasePodcast;
<span class="keyword token">use</span> Illuminate\Support\Facades\Bus;

Bus::chain([
    <span class="keyword token">new</span> ProcessPodcast,
    <span class="keyword token">new</span> OptimizePodcast,
    <span class="keyword token">new</span> ReleasePodcast,
])-&gt;dispatch();
</code></pre>
<p>除了链接任务类实例之外，您还可以链接闭包：</p>
<pre><code>Bus::chain([
    <span class="keyword token">new</span> ProcessPodcast,
    <span class="keyword token">new</span> OptimizePodcast,
    <span class="keyword token">function</span> () {
        Podcast::update(...);
    },
])-&gt;dispatch();
</code></pre>
<blockquote>
<p>注意：在任务中使用 <code>$this-&gt;delete()</code> 方法删除任务不会阻止链式任务的处理。只有当链中的任务失败时，链才会停止执行。</p>
</blockquote>
<p><a name="chain-connection-queue"></a></p>
<h4 id="链式连接--队列">链式连接 &amp; 队列</h4>
<p>如果要指定链接任务应使用的连接和队列，可以使用 <code>onConnection</code> 和 <code>onQueue</code> 方法。这些方法指定应使用的队列连接和队列名称，除非为排队任务显式分配了不同的连接/队列：</p>
<pre><code>Bus::chain([
    <span class="keyword token">new</span> ProcessPodcast,
    <span class="keyword token">new</span> OptimizePodcast,
    <span class="keyword token">new</span> ReleasePodcast,
])-&gt;onConnection(<span class="string token">'redis'</span>)-&gt;onQueue(<span class="string token">'podcasts'</span>)-&gt;dispatch();
</code></pre>
<p><a name="chain-failures"></a></p>
<h4 id="链故障">链故障</h4>
<p>链接任务时，您可以使用 <code>catch</code> 方法指定一个闭包，如果链中的任务失败，则应调用该闭包。给定的回调将接收导致任务失败的 <code>Throwable</code> 实例：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\Bus;
<span class="keyword token">use</span> Throwable;

Bus::chain([
    <span class="keyword token">new</span> ProcessPodcast,
    <span class="keyword token">new</span> OptimizePodcast,
    <span class="keyword token">new</span> ReleasePodcast,
])-&gt;<span class="keyword token">catch</span>(<span class="keyword token">function</span> (Throwable <span class="variable token">$e</span>) {
    <span class="comment token">// 链中的任务失败了...</span>
})-&gt;dispatch();
</code></pre>
<p><a name="customizing-the-queue-and-connection"></a></p>
<h3 id="自定义队列--连接">自定义队列 &amp; 连接</h3>
<p><a name="dispatching-to-a-particular-queue"></a></p>
<h4 id="分派到特定队列">分派到特定队列</h4>
<p>通过将任务推送到不同的队列，您可以对排队的任务进行「分类」，甚至可以优先考虑分配给各个队列的工作人员数量。请记住，这不会将任务推送到队列配置文件定义的不同队列「连接」，而只会推送到单个连接中的特定队列。要指定队列，请在调度任务时使用 <code>onQueue</code> 方法：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Http\Controllers;

<span class="keyword token">use</span> App\Http\Controllers\Controller;
<span class="keyword token">use</span> App\Jobs\ProcessPodcast;
<span class="keyword token">use</span> App\Models\Podcast;
<span class="keyword token">use</span> Illuminate\Http\Request;

<span class="keyword token">class</span> PodcastController <span class="keyword token">extends</span> Controller
{
    <span class="comment token">/**
     * 存储一个新的播客。
     *
     *<span class="phpdoc token"> @param</span>  \Illuminate\Http\Request  $request
     *<span class="phpdoc token"> @return</span> \Illuminate\Http\Response
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> store(Request <span class="variable token">$request</span>)
    {
        <span class="variable token">$podcast</span> = Podcast::create(...);

        <span class="comment token">// 创建播客...</span>

        ProcessPodcast::dispatch(<span class="variable token">$podcast</span>)-&gt;onQueue(<span class="string token">'processing'</span>);
    }
}
</code></pre>
<p>或者，您可以通过在任务的构造函数中调用 <code>onQueue</code> 方法来指定任务的队列：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs;

 <span class="keyword token">use</span> Illuminate\Bus\Queueable;
 <span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldQueue;
 <span class="keyword token">use</span> Illuminate\Foundation\Bus\Dispatchable;
 <span class="keyword token">use</span> Illuminate\Queue\InteractsWithQueue;
 <span class="keyword token">use</span> Illuminate\Queue\SerializesModels;

<span class="keyword token">class</span> ProcessPodcast <span class="keyword token">implements</span> ShouldQueue
{
    <span class="keyword token">use</span> Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    <span class="comment token">/**
     * 创建一个新的任务实例。
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> __construct()
    {
        <span class="variable token">$this</span>-&gt;onQueue(<span class="string token">'processing'</span>);
    }
}
</code></pre>
<p><a name="dispatching-to-a-particular-connection"></a></p>
<h4 id="调度到特定连接">调度到特定连接</h4>
<p>如果您的应用程序与多个队列连接交互，您可以使用 <code>onConnection</code> 方法指定将任务推送到哪个连接：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Http\Controllers;

<span class="keyword token">use</span> App\Http\Controllers\Controller;
<span class="keyword token">use</span> App\Jobs\ProcessPodcast;
<span class="keyword token">use</span> App\Models\Podcast;
<span class="keyword token">use</span> Illuminate\Http\Request;

<span class="keyword token">class</span> PodcastController <span class="keyword token">extends</span> Controller
{
    <span class="comment token">/**
     * 存储一个新的播客。
     *
     *<span class="phpdoc token"> @param</span>  \Illuminate\Http\Request  $request
     *<span class="phpdoc token"> @return</span> \Illuminate\Http\Response
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> store(Request <span class="variable token">$request</span>)
    {
        <span class="variable token">$podcast</span> = Podcast::create(...);

        <span class="comment token">// 创建播客...</span>

        ProcessPodcast::dispatch(<span class="variable token">$podcast</span>)-&gt;onConnection(<span class="string token">'sqs'</span>);
    }
}
</code></pre>
<p>您可以将 <code>onConnection</code> 和 <code>onQueue</code> 方法链接在一起，以指定任务的连接和队列：</p>
<pre><code>ProcessPodcast::dispatch(<span class="variable token">$podcast</span>)
              -&gt;onConnection(<span class="string token">'sqs'</span>)
              -&gt;onQueue(<span class="string token">'processing'</span>);
</code></pre>
<p>或者，您可以通过在任务的构造函数中调用 <code>onConnection</code> 方法来指定任务的连接：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs;

 <span class="keyword token">use</span> Illuminate\Bus\Queueable;
 <span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldQueue;
 <span class="keyword token">use</span> Illuminate\Foundation\Bus\Dispatchable;
 <span class="keyword token">use</span> Illuminate\Queue\InteractsWithQueue;
 <span class="keyword token">use</span> Illuminate\Queue\SerializesModels;

<span class="keyword token">class</span> ProcessPodcast <span class="keyword token">implements</span> ShouldQueue
{
    <span class="keyword token">use</span> Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    <span class="comment token">/**
     * 创建一个新的任务实例。
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> __construct()
    {
        <span class="variable token">$this</span>-&gt;onConnection(<span class="string token">'sqs'</span>);
    }
}
</code></pre>
<p><a name="max-job-attempts-and-timeout"></a></p>
<h3 id="指定最大任务尝试超时值">指定最大任务尝试/超时值</h3>
<p><a name="max-attempts"></a></p>
<h4 id="最大尝试次数">最大尝试次数</h4>
<p>如果你的一个队列任务遇到了错误，你可能不希望无限制的重试。因此 Laravel 提供了各种方法来指定一个任务可以尝试多少次或多长时间。</p>
<p>指定任务可尝试的最大次数的其中一个方法是，通过 Artisan 命令行上的 <code>--tries</code> 开关。这将适用于调度作业的所有任务，除非正在处理的任务指定了最大尝试次数。</p>
<pre><code class="language-shell">php artisan queue:work --tries=3
</code></pre>
<p>如果一个任务超过其最大尝试次数，将被视为「失败」的任务。有关处理失败任务的更多信息，可以参考 <a href="#dealing-with-failed-jobs">处理失败队列</a>。</p>
<p>你可以采取更细化的方法来定义任务类本身的最大尝试次数。如果在任务上指定了最大尝试次数，它将优先于命令行上提供的 <code>--tries</code> 开关设定的值：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs;

<span class="keyword token">class</span> ProcessPodcast <span class="keyword token">implements</span> ShouldQueue
{
    <span class="comment token">/**
     * 任务可尝试次数.
     *
     *<span class="phpdoc token"> @var</span> int
     */</span>
    <span class="keyword token">public</span> <span class="variable token">$tries</span> = <span class="number token">5</span>;
}
</code></pre>
<p><a name="time-based-attempts"></a></p>
<h4 id="基于时间的尝试">基于时间的尝试</h4>
<p>除了定义任务失败前尝试的次数之外，还可以定义任务应该超时的时间。这允许在给定的时间范围内尝试任意次数的任务。要定义任务超时的时间，请在任务类中添加 <code>retryUntil</code> 方法。这个方法应返回一个  <code>DateTime</code> 实例：</p>
<pre><code><span class="comment token">/**
 * Determine the time at which the job should timeout.
 *
 *<span class="phpdoc token"> @return</span> \DateTime
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> retryUntil()
{
    <span class="keyword token">return</span> now()-&gt;addMinutes(<span class="number token">10</span>);
}
</code></pre>
<blockquote>
<p>技巧：你也可以在 <a href="events.html#queued-event-listeners">队列事件监听器</a> 上定义一个 <code>tries</code> 属性或 <code>retryUntil</code> 方法。</p>
</blockquote>
<p><a name="max-exceptions"></a></p>
<h4 id="最大尝试">最大尝试</h4>
<p>有时您可能希望指定一个任务可能会尝试多次，但如果重试由给定数量的未处理异常触发（而不是直接由 <code>release</code> 方法释放），则应该失败。为此，您可以在任务类上定义一个 <code>maxExceptions</code> 属性：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs;

<span class="keyword token">use</span> Illuminate\Support\Facades\Redis;

<span class="keyword token">class</span> ProcessPodcast <span class="keyword token">implements</span> ShouldQueue
{
    <span class="comment token">/**
     * 可以尝试任务的次数。
     *
     *<span class="phpdoc token"> @var</span> int
     */</span>
    <span class="keyword token">public</span> <span class="variable token">$tries</span> = <span class="number token">25</span>;

    <span class="comment token">/**
     * 失败前允许的最大未处理异常数。
     *
     *<span class="phpdoc token"> @var</span> int
     */</span>
    <span class="keyword token">public</span> <span class="variable token">$maxExceptions</span> = <span class="number token">3</span>;

    <span class="comment token">/**
     * Execute the job.
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> handle()
    {
        Redis::throttle(<span class="string token">'key'</span>)-&gt;allow(<span class="number token">10</span>)-&gt;every(<span class="number token">60</span>)-&gt;then(<span class="keyword token">function</span> () {
            <span class="comment token">// 获得锁，处理播客...</span>
        }, <span class="keyword token">function</span> () {
            <span class="comment token">// 无法获取锁...</span>
            <span class="keyword token">return</span> <span class="variable token">$this</span>-&gt;release(<span class="number token">10</span>);
        });
    }
}
</code></pre>
<p>在此示例中，如果应用程序无法获得 Redis 锁，则该任务将在 10 秒后被释放，并将继续重试最多 25 次。但是，如果任务抛出三个未处理的异常，则任务将失败。</p>
<p><a name="timeout"></a></p>
<h4 id="超时">超时</h4>
<blockquote>
<p>注意：必须安装 <code>pcntl</code> PHP 扩展以指定任务超时。</p>
</blockquote>
<p>通常，您大致知道您预计排队的任务需要多长时间。出于这个原因，Laravel 允许你指定一个「超时」值。 如果任务的处理时间超过超时值指定的秒数，则处理该任务的任务进程将退出并出现错误。 通常，任务程序将由<a href="#supervisor-configuration" title="在您的服务器上配置的进程管理器">在您的服务器上配置的进程管理器</a>自动重新启动。</p>
<p>同样，任务可以运行的最大秒数可以使用 Artisan 命令行上的 <code>--timeout</code> 开关来指定：</p>
<pre><code class="language-shell">php artisan queue:work --timeout=30
</code></pre>
<p>如果任务因不断超时而超过其最大尝试次数，则它将被标记为失败。</p>
<p>你也可以定义允许任务在任务类本身上运行的最大秒数。如果在任务上指定了超时，它将优先于在命令行上指定的任何超时:</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs;

<span class="keyword token">class</span> ProcessPodcast <span class="keyword token">implements</span> ShouldQueue
{
    <span class="comment token">/**
     * 在超时之前任务可以运行的秒数.
     *
     *<span class="phpdoc token"> @var</span> int
     */</span>
    <span class="keyword token">public</span> <span class="variable token">$timeout</span> = <span class="number token">120</span>;
}
</code></pre>
<p>有些时候，诸如 socket 或在 HTTP 连接之类的 IO 阻止进程可能不会遵守你指定的超时。因此，在使用这些功能时，也应始终尝试使用其 API 指定超时。例如，在使用 Guzzle 时，应始终指定连接并请求的超时时间。</p>
<p><a name="failing-on-timeout"></a></p>
<h4 id="超时失败">超时失败</h4>
<p>如果您希望在超时时将任务标记为 <a href="#dealing-with-failed-jobs">failed</a>，可以在任务类上定义 <code>$failOnTimeout</code> 属性：</p>
<pre><code class="language-php"><span class="comment token">/**
 * 标示是否应在超时时标记为失败.
 *
 *<span class="phpdoc token"> @var</span> bool
 */</span>
<span class="keyword token">public</span> <span class="variable token">$failOnTimeout</span> = <span class="keyword token">true</span>;
</code></pre>
<p><a name="error-handling"></a></p>
<h3 id="错误处理">错误处理</h3>
<p>如果在处理任务时抛出异常，任务将自动释放回队列，以便再次尝试。 任务将继续发布，直到尝试达到你的应用程序允许的最大次数为止。最大尝试次数由 <code>queue:work</code> Artisan 命令中使用的 <code>--tries</code> 开关定义。或者，可以在任务类本身上定义最大尝试次数。有关运行队列处理器的更多信息 <a href="#running-the-queue-worker">可以在下面找到</a>。</p>
<p><a name="manually-releasing-a-job"></a></p>
<h4 id="手动发布">手动发布</h4>
<p>有时你可能希望手动将任务发布回队列，以便稍后再次尝试。你可以通过调用 <code>release</code> 方法来完成此操作：</p>
<pre><code><span class="comment token">/**
 * 执行任务。
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> handle()
{
    <span class="comment token">// ...</span>

    <span class="variable token">$this</span>-&gt;release();
}
</code></pre>
<p>默认情况下，<code>release</code> 方法会将任务发布回队列以供立即处理。但是，通过向 <code>release</code> 方法传递一个整数，你可以指示队列在给定的秒数过去之前不使任务可用于处理：</p>
<pre><code><span class="variable token">$this</span>-&gt;release(<span class="number token">10</span>);
</code></pre>
<p><a name="manually-failing-a-job"></a></p>
<h4 id="手动使任务失败">手动使任务失败</h4>
<p>有时，你可能需要手动将任务标记为 「failed」。为此，您可以调用 fail 方法：</p>
<pre><code><span class="comment token">/**
 * 执行任务。
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> handle()
{
    <span class="comment token">// ...</span>

    <span class="variable token">$this</span>-&gt;fail();
}
</code></pre>
<p>如果你想将你的任务标记为由于你捕获的异常而失败，你可以将异常传递给 fail 方法：</p>
<pre><code><span class="variable token">$this</span>-&gt;fail(<span class="variable token">$exception</span>);
</code></pre>
<blockquote>
<p>技巧：有关失败任务的更多信息，请查看 <a href="#dealing-with-failed-jobs">处理任务失败的文档</a>.</p>
</blockquote>
<p><a name="job-batching"></a></p>
<h2 id="任务批处理">任务批处理</h2>
<p>Laravel 的任务批处理功能允许你轻松地执行一批任务，然后在这批任务执行完毕后执行一些操作。 在开始之前，你应该创建一个数据库迁移来构建一个表来包含有关你的任务批次的元信息，例如它们的完成百分比。这个迁移可以使用 <code>queue:batches-table</code> Artisan 命令生成：</p>
<pre><code class="language-shell">php artisan queue:batches-table

php artisan migrate
</code></pre>
<p><a name="defining-batchable-jobs"></a></p>
<h3 id="定义可批处理任务">定义可批处理任务</h3>
<p>要定义可批处理任务，您应该像往常一样<a href="#creating-jobs">创建可排队任务</a>；但是，您应该将 <code>Illuminate\Bus\Batchable</code> 特征添加到任务类中。此 trait 提供了对 <code>batch</code> 方法的访问，该方法可用于检索任务正在其中执行的当前批处理：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs;

<span class="keyword token">use</span> Illuminate\Bus\Batchable;
<span class="keyword token">use</span> Illuminate\Bus\Queueable;
<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldQueue;
<span class="keyword token">use</span> Illuminate\Foundation\Bus\Dispatchable;
<span class="keyword token">use</span> Illuminate\Queue\InteractsWithQueue;
<span class="keyword token">use</span> Illuminate\Queue\SerializesModels;

<span class="keyword token">class</span> ImportCsv <span class="keyword token">implements</span> ShouldQueue
{
    <span class="keyword token">use</span> Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    <span class="comment token">/**
     * 执行任务。
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> handle()
    {
        <span class="keyword token">if</span> (<span class="variable token">$this</span>-&gt;batch()-&gt;cancelled()) {
            <span class="comment token">// 确定批次是否已取消...</span>

            <span class="keyword token">return</span>;
        }

        <span class="comment token">// 导入 CSV 文件的一部分...</span>
    }
}
</code></pre>
<p><a name="dispatching-batches"></a></p>
<h3 id="调度批次">调度批次</h3>
<p>要调度一批任务，您应该使用 <code>Bus</code> 门面的 <code>batch</code> 方法。 当然，与完成回调结合使用时，批处理主要是有用的。因此，您可以使用 <code>then</code>、<code>catch</code> 和 <code>finally</code> 方法来定义批处理的完成回调。这些回调中的每一个在调用时都会收到一个 <code>Illuminate\Bus\Batch</code> 实例。在此示例中，我们将假设我们正在排队一批任务，每个任务处理 CSV 文件中给定数量的行：</p>
<pre><code><span class="keyword token">use</span> App\Jobs\ImportCsv;
<span class="keyword token">use</span> Illuminate\Bus\Batch;
<span class="keyword token">use</span> Illuminate\Support\Facades\Bus;
<span class="keyword token">use</span> Throwable;

<span class="variable token">$batch</span> = Bus::batch([
    <span class="keyword token">new</span> ImportCsv(<span class="number token">1</span>, <span class="number token">100</span>),
    <span class="keyword token">new</span> ImportCsv(<span class="number token">101</span>, <span class="number token">200</span>),
    <span class="keyword token">new</span> ImportCsv(<span class="number token">201</span>, <span class="number token">300</span>),
    <span class="keyword token">new</span> ImportCsv(<span class="number token">301</span>, <span class="number token">400</span>),
    <span class="keyword token">new</span> ImportCsv(<span class="number token">401</span>, <span class="number token">500</span>),
])-&gt;then(<span class="keyword token">function</span> (Batch <span class="variable token">$batch</span>) {
    <span class="comment token">// 所有任务均已成功完成...</span>
})-&gt;<span class="keyword token">catch</span>(<span class="keyword token">function</span> (Batch <span class="variable token">$batch</span>, Throwable <span class="variable token">$e</span>) {
    <span class="comment token">// 检测到第一批任务失败...</span>
})-&gt;finally(<span class="keyword token">function</span> (Batch <span class="variable token">$batch</span>) {
    <span class="comment token">// 批处理已完成执行...</span>
})-&gt;dispatch();

<span class="keyword token">return</span> <span class="variable token">$batch</span>-&gt;id;
</code></pre>
<p>批次的 ID，可以通过 <code>$batch-&gt;id</code> 属性访问，可用于 <a href="#inspecting-batches">查询 Laravel 命令总线</a> 以获取有关批次已分派后的信息。</p>
<blockquote>
<p>注意：由于批处理回调是由 Laravel 队列序列化并在稍后执行的，因此您不应在回调中使用 <code>$this</code> 变量。</p>
</blockquote>
<p><a name="naming-batches"></a></p>
<h4 id="命名批次">命名批次</h4>
<p>Laravel Horizon 和 Laravel Telescope 等工具如果命名了批次，可能会为批次提供更用户友好的调试信息。要为批处理分配任意名称，您可以在定义批处理时调用 <code>name</code> 方法：</p>
<pre><code><span class="variable token">$batch</span> = Bus::batch([
    <span class="comment token">// ...</span>
])-&gt;then(<span class="keyword token">function</span> (Batch <span class="variable token">$batch</span>) {
    <span class="comment token">// 所有任务均已成功完成...</span>
})-&gt;name(<span class="string token">'Import CSV'</span>)-&gt;dispatch();
</code></pre>
<p><a name="batch-connection-queue"></a></p>
<h4 id="批量连接--队列">批量连接 &amp; 队列</h4>
<p>如果您想指定应该用于批处理任务的连接和队列，您可以使用 <code>onConnection</code> 和 <code>onQueue</code> 方法。所有批处理任务必须在相同的连接和队列中执行：</p>
<pre><code><span class="variable token">$batch</span> = Bus::batch([
    <span class="comment token">// ...</span>
])-&gt;then(<span class="keyword token">function</span> (Batch <span class="variable token">$batch</span>) {
    <span class="comment token">// 所有任务均已成功完成...</span>
})-&gt;onConnection(<span class="string token">'redis'</span>)-&gt;onQueue(<span class="string token">'imports'</span>)-&gt;dispatch();
</code></pre>
<p><a name="chains-within-batches"></a></p>
<h4 id="批内链接">批内链接</h4>
<p>您可以通过将链接的任务放置在数组中来在批处理中定义一组 <a href="#job-chaining">链接的任务</a>。例如，我们可以并行执行两个任务链，并在两个任务链都完成处理后执行回调：</p>
<pre><code><span class="keyword token">use</span> App\Jobs\ReleasePodcast;
<span class="keyword token">use</span> App\Jobs\SendPodcastReleaseNotification;
<span class="keyword token">use</span> Illuminate\Bus\Batch;
<span class="keyword token">use</span> Illuminate\Support\Facades\Bus;

Bus::batch([
    [
        <span class="keyword token">new</span> ReleasePodcast(<span class="number token">1</span>),
        <span class="keyword token">new</span> SendPodcastReleaseNotification(<span class="number token">1</span>),
    ],
    [
        <span class="keyword token">new</span> ReleasePodcast(<span class="number token">2</span>),
        <span class="keyword token">new</span> SendPodcastReleaseNotification(<span class="number token">2</span>),
    ],
])-&gt;then(<span class="keyword token">function</span> (Batch <span class="variable token">$batch</span>) {
    <span class="comment token">// ...</span>
})-&gt;dispatch();
</code></pre>
<p><a name="adding-jobs-to-batches"></a></p>
<h3 id="批量添加任务">批量添加任务</h3>
<p>有些时候，批量向批处理中添加任务可能很有用。当你需要批量处理数千个任务时，这种模式非常好用，而这些任务在 Web 请求期间可能需要很长时间才能调度。因此，你可能希望调度初始批次的「加载器」任务，这些任务与更多任务相结合：</p>
<pre><code><span class="variable token">$batch</span> = Bus::batch([
    <span class="keyword token">new</span> LoadImportBatch,
    <span class="keyword token">new</span> LoadImportBatch,
    <span class="keyword token">new</span> LoadImportBatch,
])-&gt;then(<span class="keyword token">function</span> (Batch <span class="variable token">$batch</span>) {
    <span class="comment token">// 所有任务都成功完成... </span>
})-&gt;name(<span class="string token">'Import Contacts'</span>)-&gt;dispatch();
</code></pre>
<p>在这个例子中，我们将使用 <code>LoadImportBatch</code> 实例为批处理添加其他任务。为了实现这个功能，我们可以对批处理实例使用 <code>add</code> 方法，该方法可以通过 <code>batch</code> 实例访问：</p>
<pre><code><span class="keyword token">use</span> App\Jobs\ImportContacts;
<span class="keyword token">use</span> Illuminate\Support\Collection;

<span class="comment token">/**
 * 执行任务。
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> handle()
{
    <span class="keyword token">if</span> (<span class="variable token">$this</span>-&gt;batch()-&gt;cancelled()) {
        <span class="keyword token">return</span>;
    }

    <span class="variable token">$this</span>-&gt;batch()-&gt;add(Collection::times(<span class="number token">1000</span>, <span class="keyword token">function</span> () {
        <span class="keyword token">return</span> <span class="keyword token">new</span> ImportContacts;
    }));
}
</code></pre>
<blockquote>
<p>注意：你只能将任务添加到当前任务所属的批处理中。</p>
</blockquote>
<p><a name="inspecting-batches"></a></p>
<h3 id="校验批处理">校验批处理</h3>
<p>为批处理完成后提供回调的 <code>Illuminate\Bus\Batch</code> 实例中具有多种属性和方法，可以帮助您与指定的批处理业务进行交互和检查：</p>
<pre><code><span class="comment token">// 批处理的UUID...</span>
<span class="variable token">$batch</span>-&gt;id;

<span class="comment token">// 批处理的名称（如果已经设置的话）...</span>
<span class="variable token">$batch</span>-&gt;name;

<span class="comment token">// 分配给批处理的任务数量...</span>
<span class="variable token">$batch</span>-&gt;totalJobs;

<span class="comment token">// 队列还没处理的任务数量...</span>
<span class="variable token">$batch</span>-&gt;pendingJobs;

<span class="comment token">// 失败的任务数量...</span>
<span class="variable token">$batch</span>-&gt;failedJobs;

<span class="comment token">// 到目前为止已经处理的任务数量...</span>
<span class="variable token">$batch</span>-&gt;processedJobs();

<span class="comment token">// 批处理已经完成的百分比（0-100）...</span>
<span class="variable token">$batch</span>-&gt;progress();

<span class="comment token">// 批处理是否已经完成执行...</span>
<span class="variable token">$batch</span>-&gt;finished();

<span class="comment token">// 取消批处理的运行...</span>
<span class="variable token">$batch</span>-&gt;cancel();

<span class="comment token">// 批处理是否已经取消...</span>
<span class="variable token">$batch</span>-&gt;cancelled();
</code></pre>
<p><a name="returning-batches-from-routes"></a></p>
<h4 id="从路由返回批次">从路由返回批次</h4>
<p>所有 Illuminate\Bus\Batch 实例都是 JSON 可序列化的，这意味着您可以直接从应用程序的一个路由返回它们，以检索包含有关批处理的信息的 JSON 有效负载，包括其完成进度。这样可以方便地在应用程序的 UI 中显示有关批处理完成进度的信息。</p>
<p>要通过 ID 检索批次，您可以使用 <code>Bus</code> 外观的 <code>findBatch</code> 方法：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\Bus;
<span class="keyword token">use</span> Illuminate\Support\Facades\Route;

Route::get(<span class="string token">'/batch/{batchId}'</span>, <span class="keyword token">function</span> (string <span class="variable token">$batchId</span>) {
    <span class="keyword token">return</span> Bus::findBatch(<span class="variable token">$batchId</span>);
});
</code></pre>
<p><a name="cancelling-batches"></a></p>
<h3 id="取消批次">取消批次</h3>
<p>有时您可能需要取消给定批处理的执行。这可以通过调用 <code>Illuminate\Bus\Batch</code> 实例的 <code>cancel</code> 方法来完成：</p>
<pre><code><span class="comment token">/**
 * 执行任务。
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> handle()
{
    <span class="keyword token">if</span> (<span class="variable token">$this</span>-&gt;user-&gt;exceedsImportLimit()) {
        <span class="keyword token">return</span> <span class="variable token">$this</span>-&gt;batch()-&gt;cancel();
    }

    <span class="keyword token">if</span> (<span class="variable token">$this</span>-&gt;batch()-&gt;cancelled()) {
        <span class="keyword token">return</span>;
    }
}
</code></pre>
<p>正如您在前面的示例中可能已经注意到的那样，批处理任务通常应该检查批处理是否在其 <code>handle</code> 方法的开头被取消：</p>
<pre><code><span class="comment token">/**
 * 执行任务。
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> handle()
{
    <span class="keyword token">if</span> (<span class="variable token">$this</span>-&gt;batch()-&gt;cancelled()) {
        <span class="keyword token">return</span>;
    }

    <span class="comment token">// 继续处理...</span>
}
</code></pre>
<p><a name="batch-failures"></a></p>
<h3 id="批处理失败">批处理失败</h3>
<p>当批处理任务失败时，将调用 <code>catch</code> 回调（如果已分配）。此回调仅针对批处理中失败的第一个任务调用。</p>
<p><a name="allowing-failures"></a></p>
<h4 id="允许失败">允许失败</h4>
<p>当批处理中的某个任务失败时，Laravel 会自动将该批处理标记为「已取消」。如果您愿意，您可以禁用此行为，以便任务失败不会自动将批处理标记为已取消。这可以通过在调度批处理时调用 <code>allowFailures</code> 方法来完成：</p>
<pre><code><span class="variable token">$batch</span> = Bus::batch([
    <span class="comment token">// ...</span>
])-&gt;then(<span class="keyword token">function</span> (Batch <span class="variable token">$batch</span>) {
    <span class="comment token">// 所有任务均已成功完成...</span>
})-&gt;allowFailures()-&gt;dispatch();
</code></pre>
<p><a name="retrying-failed-batch-jobs"></a></p>
<h4 id="重试失败的批处理任务">重试失败的批处理任务</h4>
<p>为方便起见，Laravel 提供了一个 <code>queue:retry-batch</code> Artisan 命令，允许您轻松重试给定批次的所有失败任务。 <code>queue:retry-batch</code> 命令接受应该重试失败任务的批处理的 UUID：</p>
<pre><code class="language-shell">php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5
</code></pre>
<p><a name="pruning-batches"></a></p>
<h3 id="修剪批次">修剪批次</h3>
<p>如果不进行剪枝，<code>job_batches</code> 表可以非常快速地积累记录。为了缓解这种情况，您应该 <a href="scheduling.html">schedule</a> <code>queue:prune-batches</code> Artisan 命令每天运行：</p>
<pre><code><span class="variable token">$schedule</span>-&gt;command(<span class="string token">'queue:prune-batches'</span>)-&gt;daily();
</code></pre>
<p>默认情况下，将修剪所有超过 24 小时的已完成批次。您可以在调用命令时使用 <code>hours</code> 选项来确定保留批处理数据的时间。例如，以下命令将删除 48 小时前完成的所有批次：</p>
<pre><code><span class="variable token">$schedule</span>-&gt;command(<span class="string token">'queue:prune-batches --hours=48'</span>)-&gt;daily();
</code></pre>
<p>有时，您的 <code>jobs_batches</code> 表可能会累积从未成功完成的批次的批次记录，例如任务失败且该任务从未成功重试的批次。 您可以使用 <code>unfinished</code> 选项指示 <code>queue:prune-batches</code> 命令修剪这些未完成的批处理记录：</p>
<pre><code><span class="variable token">$schedule</span>-&gt;command(<span class="string token">'queue:prune-batches --hours=48 --unfinished=72'</span>)-&gt;daily();
</code></pre>
<p><a name="queueing-closures"></a></p>
<h2 id="队列闭包">队列闭包</h2>
<p>除了将任务类分派到队列之外，您还可以分派一个闭包。这对于需要在当前请求周期之外执行的快速、简单的任务非常有用。当向队列分派闭包时，闭包的代码内容是加密签名的，因此它不能在传输过程中被修改：</p>
<pre><code><span class="variable token">$podcast</span> = App\Podcast::find(<span class="number token">1</span>);

dispatch(<span class="keyword token">function</span> () <span class="keyword token">use</span> (<span class="variable token">$podcast</span>) {
    <span class="variable token">$podcast</span>-&gt;publish();
});
</code></pre>
<p>使用 <code>catch</code> 方法，您可以提供一个闭包，如果队列中的闭包在耗尽所有队列的<a href="#max-job-attempts-and-timeout">配置重试尝试</a>后未能成功完成，则应执行该闭包：</p>
<pre><code><span class="keyword token">use</span> Throwable;

dispatch(<span class="keyword token">function</span> () <span class="keyword token">use</span> (<span class="variable token">$podcast</span>) {
    <span class="variable token">$podcast</span>-&gt;publish();
})-&gt;<span class="keyword token">catch</span>(<span class="keyword token">function</span> (Throwable <span class="variable token">$e</span>) {
    <span class="comment token">// 这份任务失败了……</span>
});
</code></pre>
<p><a name="running-the-queue-worker"></a></p>
<h2 id="运行队列工作者">运行队列工作者</h2>
<p><a name="the-queue-work-command"></a></p>
<h3 id="queuework-命令"><code>queue:work</code> 命令</h3>
<p>Laravel 包含一个 Artisan 命令，该命令将启动队列进程并在新任务被推送到队列时处理它们。 您可以使用 <code>queue:work</code> Artisan 命令运行任务进程。请注意，一旦 <code>queue:work</code> 命令启动，它将继续运行，直到手动停止或关闭终端：</p>
<pre><code class="language-shell">php artisan queue:work
</code></pre>
<blockquote>
<p>技巧：要让 <code>queue:work</code> 进程在后台永久运行，您应该使用诸如 <a href="#supervisor-configuration">Supervisor</a> 之类的进程监视器来确保队列进程不会停止运行。</p>
</blockquote>
<p>请记住，队列任务者是长期存在的进程，并将启动的应用程序状态存储在内存中。 因此，它们在启动后不会注意到您的代码库中的更改。 因此，在您的部署过程中，请务必<a href="#queue-workers-and-deployment">重新启动您的队列进程</a>。 此外，请记住，您的应用进程创建或修改的任何静态状态都不会在任务之间自动重置。</p>
<p>或者，您可以运行 <code>queue:listen</code> 命令。 使用 <code>queue:listen</code> 命令时，当您想要重新加载更新的代码或重置应用进程状态时，您不必手动重启 worker； 但是，此命令的效率明显低于 <code>queue:work</code> 命令：</p>
<pre><code class="language-shell">php artisan queue:listen
</code></pre>
<p><a name="running-multiple-queue-workers"></a></p>
<h4 id="运行多个队列进程">运行多个队列进程</h4>
<p>要将多个进程分配给一个队列并同时处理任务，您应该简单地启动多个 <code>queue:work</code> 进程。这可以通过终端中的多个选项卡在本地完成，也可以使用流程管理器的配置设置在生产中完成。 <a href="#supervisor-configuration">使用 Supervisor 时</a>，您可以使用 <code>numprocs</code> 配置值。</p>
<p><a name="specifying-the-connection-queue"></a></p>
<h4 id="指定连接--队列">指定连接 &amp; 队列</h4>
<p>您还可以指定进程应该使用哪个队列连接。 传递给 <code>work</code> 命令的连接名称应对应于 <code>config/queue.php</code> 配置文件中定义的连接之一：</p>
<pre><code class="language-shell">php artisan queue:work redis
</code></pre>
<p>默认情况下，<code>queue:work</code> 命令仅处理给定连接上默认队列的任务。但是，您可以通过仅处理给定连接的特定队列来进一步自定义队列工作程序。例如，如果您的所有电子邮件都在您的 <code>redis</code> 队列连接上的 <code>emails</code> 队列中处理，您可以发出以下命令来启动仅处理该队列的进程：</p>
<pre><code class="language-shell">php artisan queue:work redis --queue=emails
</code></pre>
<p><a name="processing-a-specified-number-of-jobs"></a></p>
<h4 id="处理指定数量的任务">处理指定数量的任务</h4>
<p><code>--once</code> 选项可用于指定进程仅处理队列中的单个任务：</p>
<pre><code class="language-shell">php artisan queue:work --once
</code></pre>
<p><code>--max-jobs</code> 选项可用于指示进程处理给定数量的作业，然后退出。当与 <a href="#supervisor-configuration">Supervisor</a> 结合使用时，此选项可能很有用，以便您的进程在处理给定数量的作业后自动重新启动，释放他们可能积累的任何内存：</p>
<pre><code class="language-shell">php artisan queue:work --max-jobs=1000
</code></pre>
<p><a name="processing-all-queued-jobs-then-exiting"></a></p>
<h4 id="处理所有排队的任务然后退出">处理所有排队的任务然后退出</h4>
<p><code>--stop-when-empty</code> 选项可用于指定进程处理所有作业，然后正常退出。如果您希望在队列为空后关闭容器，则此选项在处理 Docker 容器中的 Laravel 队列时很有用：</p>
<pre><code class="language-shell">php artisan queue:work --stop-when-<span class="keyword token">empty</span>
</code></pre>
<p><a name="processing-jobs-for-a-given-number-of-seconds"></a></p>
<h4 id="在给定的秒数内处理任务">在给定的秒数内处理任务</h4>
<p><code>--max-time</code> 选项可用于指示进程在给定的秒数内处理任务，然后退出。当与 <a href="#supervisor-configuration">Supervisor</a> 结合使用时，此选项可能很有用，以便您的进程在处理给定时间的作业后自动重新启动，释放他们可能积累的任何内存：</p>
<pre><code class="language-shell"><span class="comment token"># 处理进程一小时，然后退出...</span>
php artisan queue:work --max-time=<span class="number token">3600</span>
</code></pre>
<p><a name="worker-sleep-duration"></a></p>
<h4 id="进程睡眠时间">进程睡眠时间</h4>
<p>当队列中有任务可用时，进程将继续处理作业，而不会在它们之间产生延迟。但是，<code>sleep</code> 选项决定了如果没有可用的新任务，进程将 <code>sleep</code> 多少秒。 睡眠时，进程不会处理任何新的作业 - 任务将在进程再次唤醒后处理。</p>
<pre><code class="language-shell">php artisan queue:work --sleep=3
</code></pre>
<p><a name="resource-considerations"></a></p>
<h4 id="资源注意事项">资源注意事项</h4>
<p>守护进程队列在处理每个任务之前不会 <code>reboot</code> 框架。因此，您应该在每个任务完成后释放所有繁重的资源。例如，如果您正在使用 GD 库进行图像处理，您应该在处理完图像后使用 <code>imagedestroy</code> 释放内存。</p>
<p><a name="queue-priorities"></a></p>
<h3 id="队列优先级">队列优先级</h3>
<p>有时您可能希望优先处理队列的处理方式。例如，在 <code>config/queue.php</code> 配置文件中，您可以将 <code>redis</code> 连接的默认 <code>queue</code> 设置为 <code>low</code>。 但是，有时您可能希望将作业推送到 <code>high</code> 优先级队列，如下所示：</p>
<pre><code>dispatch((<span class="keyword token">new</span> Job)-&gt;onQueue(<span class="string token">'high'</span>));
</code></pre>
<p>要启动一个进程，在继续处理 <code>low</code> 队列上的任何任务之前验证所有 <code>high</code> 队列任务是否已处理，请将队列名称的逗号分隔列表传递给 <code>work</code> 命令：</p>
<pre><code class="language-shell">php artisan queue:work --queue=high,low
</code></pre>
<p><a name="queue-workers-and-deployment"></a></p>
<h3 id="队列进程--部署">队列进程 &amp; 部署</h3>
<p>由于队列任务是长期存在的进程，因此如果不重新启动，他们不会注意到代码的更改。因此，使用队列任务部署应用程序的最简单方法是在部署过程中重新启动任务。您可以通过发出 <code>queue:restart</code> 命令优雅地重新启动所有进程：</p>
<pre><code class="language-shell">php artisan queue:restart
</code></pre>
<p>此命令将指示所有队列进程在处理完当前任务后正常退出，以免丢失现有任务。由于队列任务将在执行 <code>queue:restart</code> 命令时退出，您应该运行诸如 <a href="#supervisor-configuration">Supervisor</a> 之类的进程管理器来自动重新启动队列任务。</p>
<blockquote>
<p>技巧：队列使用 <a href="cache.html">cache</a> 来存储重启信号，因此您应该在使用此功能之前验证是否为您的应用程序正确配置了缓存驱动程序。</p>
</blockquote>
<p><a name="job-expirations-and-timeouts"></a></p>
<h3 id="任务到期--超时">任务到期 &amp; 超时</h3>
<p><a name="job-expiration"></a></p>
<h4 id="任务到期">任务到期</h4>
<p>在您的 <code>config/queue.php</code> 配置文件中，每个队列连接都定义了一个 <code>retry_after</code> 选项。此选项指定队列连接在重试正在处理的任务之前应等待的秒数。例如，如果 <code>retry_after</code> 的值设置为 <code>90</code>，如果任务已经处理了 90 秒而没有被释放或删除，它将被释放回队列中。 通常，您应该将 <code>retry_after</code> 值设置为您的任务应该合理地完成处理所需的最大秒数。</p>
<blockquote>
<p>注意：唯一不包含 <code>retry_after</code> 值的队列连接是 Amazon SQS。SQS 将根据在 AWS 控制台中管理的 <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html">默认可见性超时</a> 重试任务。</p>
</blockquote>
<p><a name="worker-timeouts"></a></p>
<h4 id="进程超时">进程超时</h4>
<p><code>queue:work</code> Artisan 命令公开了一个 <code>--timeout</code> 选项。 如果任务的处理时间超过超时值指定的秒数，则处理该任务的进程将退出并出现错误。 通常，工作程序将由<a href="#supervisor-configuration">在您的服务器上配置的进程管理器</a>自动重新启动：</p>
<pre><code class="language-shell">php artisan queue:work --timeout=60
</code></pre>
<p><code>retry_after</code> 配置选项和 <code>--timeout</code> CLI 选项是不同的，但它们协同工作以确保任务不会丢失并且任务仅成功处理一次。</p>
<blockquote>
<p>注意：<code>--timeout</code> 值应始终比 <code>retry_after</code> 配置值至少短几秒钟。 这将确保处理冻结任务的进程始终在重试任务之前终止。 如果你的 <code>--timeout</code> 选项比你的 <code>retry_after</code> 配置值长，你的任务可能会被处理两次。</p>
</blockquote>
<p><a name="supervisor-configuration"></a></p>
<h2 id="supervisor-配置">Supervisor 配置</h2>
<p>在生产中，您需要一种方法来保持 <code>queue:work</code> 进程运行。 <code>queue:work</code> 进程可能会因多种原因停止运行，例如超过 worker 超时或执行 <code>queue:restart</code> 命令。</p>
<p>出于这个原因，您需要配置一个进程监视器，它可以检测您的 <code>queue:work</code> 进程何时退出并自动重新启动它们。此外，进程监视器可以让您指定要同时运行多少个 <code>queue:work</code> 进程。Supervisor 是 Linux 环境中常用的进程监视器，我们将在下面的文档中讨论如何配置它。</p>
<p><a name="installing-supervisor"></a></p>
<h4 id="安装-supervisor">安装 Supervisor</h4>
<p>Supervisor 是 Linux 操作系统的进程监视器，如果它们失败，它将自动重新启动您的 <code>queue:work</code> 进程。要在 Ubuntu 上安装 Supervisor，您可以使用以下命令：</p>
<pre><code class="language-shell">sudo apt-get install supervisor
</code></pre>
<blockquote>
<p>技巧：如果您自己配置和管理 Supervisor 听起来很费力，请考虑使用 <a href="https://forge.laravel.com">Laravel Forge</a>，它会自动为您的生产 Laravel 项目安装和配置 Supervisor。</p>
</blockquote>
<p><a name="configuring-supervisor"></a></p>
<h4 id="配置-supervisor">配置 Supervisor</h4>
<p>Supervisor 配置文件通常存储在 <code>/etc/supervisor/conf.d</code> 目录中。在这个目录中，你可以创建任意数量的配置文件来指示 Supervisor 应该如何监控你的进程。例如，让我们创建一个启动和监控 <code>queue:work</code> 进程的 <code>laravel-worker.conf</code> 文件：</p>
<pre><code class="language-ini">[program:laravel-worker]
process_name=%(program_name)s_%(process_num)<span class="number token">02</span>d
command=php /home/forge/app.com/artisan queue:work sqs --sleep=<span class="number token">3</span> --tries=<span class="number token">3</span> --max-time=<span class="number token">3600</span>
autostart=<span class="keyword token">true</span>
autorestart=<span class="keyword token">true</span>
stopasgroup=<span class="keyword token">true</span>
killasgroup=<span class="keyword token">true</span>
user=forge
numprocs=<span class="number token">8</span>
redirect_stderr=<span class="keyword token">true</span>
stdout_logfile=/home/forge/app.com/worker.log
stopwaitsecs=<span class="number token">3600</span>
</code></pre>
<p>在这个例子中，<code>numprocs</code> 指令将指示 Supervisor 运行 8 个 <code>queue:work</code> 进程并监控所有进程，如果它们失败则自动重新启动它们。您应该更改配置的「命令」指令以反映您所需的队列连接和工作选项。</p>
<blockquote>
<p>注意：您应该确保 <code>stopwaitsecs</code> 的值大于运行时间最长的作业所消耗的秒数。否则，Supervisor 可能会在作业完成处理之前将其终止。</p>
</blockquote>
<p><a name="starting-supervisor"></a></p>
<h4 id="开始-supervisor">开始 Supervisor</h4>
<p>创建配置文件后，您可以使用以下命令更新 Supervisor 配置并启动进程：</p>
<pre><code class="language-shell">sudo supervisorctl reread

sudo supervisorctl update

sudo supervisorctl start laravel-worker:*
</code></pre>
<p>有关 Supervisor 的更多信息，请参阅 <a href="http://supervisord.org/index.html">Supervisor 文档</a>。</p>
<p><a name="dealing-with-failed-jobs"></a></p>
<h2 id="处理失败的工作">处理失败的工作</h2>
<p>有时，您队列任务会失败。别担心，事情并不总是按计划进行！ Laravel 提供了一种方便的方法来 <a href="#max-job-attempts-and-timeout">指定应尝试任务的最大次数</a>。在异步任务超过此尝试次数后，它将被插入到 <code>failed_jobs</code> 数据库表中。 <a href="queues.html#synchronous-dispatching">同步调度的任务</a> 不存储在此表中，其异常由应用程序立即处理。</p>
<p>创建 <code>failed_jobs</code> 表的迁移通常已经存在于新的 Laravel 应用程序中。但是，如果您的应用程序不包含此表的迁移，您可以使用 <code>queue:failed-table</code> 命令来创建迁移：</p>
<pre><code class="language-shell">php artisan queue:failed-table

php artisan migrate
</code></pre>
<p>运行 <a href="#running-the-queue-worker">queue worker</a> 进程时，您可以使用 <code>queue:work</code> 命令上的 <code>--tries</code> 开关指定任务应尝试的最大次数。如果您没有为 <code>--tries</code> 选项指定值，则作业将仅尝试一次或与任务类的 <code>$tries</code> 属性指定的次数相同：</p>
<pre><code class="language-shell">php artisan queue:work redis --tries=3
</code></pre>
<p>使用 <code>--backoff</code> 选项，你可以指定 Laravel 在重试遇到异常的任务之前应该等待多少秒。默认情况下，任务会立即释放回队列，以便可以再次尝试：</p>
<pre><code class="language-shell">php artisan queue:work redis --tries=3 --backoff=3
</code></pre>
<p>如果你想配置 Laravel 在重试每个任务遇到异常的任务之前应该等待多少秒，你可以通过在你的任务类上定义一个 <code>backoff</code> 属性来实现：</p>
<pre><code><span class="comment token">/**
 * 重试任务前等待的秒数。
 *
 *<span class="phpdoc token"> @var</span> int
 */</span>
<span class="keyword token">public</span> <span class="variable token">$backoff</span> = <span class="number token">3</span>;
</code></pre>
<p>如果您需要更复杂的逻辑来确定任务的退避时间，您可以在您的任务类上定义一个 <code>backoff</code> 方法：</p>
<pre><code><span class="comment token">/**
* 计算重试任务之前要等待的秒数。
*
*<span class="phpdoc token"> @return</span> int
*/</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> backoff()
{
    <span class="keyword token">return</span> <span class="number token">3</span>;
}
</code></pre>
<p>您可以通过从 <code>backoff</code> 方法返回一组退避值来轻松配置“exponential”退避。在此示例中，第一次重试的重试延迟为 1 秒，第二次重试为 5 秒，第三次重试为 10 秒：</p>
<pre><code><span class="comment token">/**
* 计算重试任务之前要等待的秒数。
*
*<span class="phpdoc token"> @return</span> array
*/</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> backoff()
{
    <span class="keyword token">return</span> [<span class="number token">1</span>, <span class="number token">5</span>, <span class="number token">10</span>];
}
</code></pre>
<p><a name="cleaning-up-after-failed-jobs"></a></p>
<h3 id="任务失败后清理">任务失败后清理</h3>
<p>当特定任务失败时，您可能希望向用户发送警报或恢复该任务部分完成的任何操作。为此，您可以在任务类上定义一个 <code>failed</code> 方法。导致作业失败的 <code>Throwable</code> 实例将被传递给 <code>failed</code> 方法：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Jobs;

<span class="keyword token">use</span> App\Models\Podcast;
<span class="keyword token">use</span> App\Services\AudioProcessor;
<span class="keyword token">use</span> Illuminate\Bus\Queueable;
<span class="keyword token">use</span> Illuminate\Contracts\Queue\ShouldQueue;
<span class="keyword token">use</span> Illuminate\Queue\InteractsWithQueue;
<span class="keyword token">use</span> Illuminate\Queue\SerializesModels;
<span class="keyword token">use</span> Throwable;

<span class="keyword token">class</span> ProcessPodcast <span class="keyword token">implements</span> ShouldQueue
{
    <span class="keyword token">use</span> InteractsWithQueue, Queueable, SerializesModels;

    <span class="comment token">/**
     * 播客实例.
     *
     *<span class="phpdoc token"> @var</span> \App\Podcast
     */</span>
    <span class="keyword token">protected</span> <span class="variable token">$podcast</span>;

    <span class="comment token">/**
     *创建新任务实例
     *
     *<span class="phpdoc token"> @param</span>  \App\Models\Podcast  $podcast
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> __construct(Podcast <span class="variable token">$podcast</span>)
    {
        <span class="variable token">$this</span>-&gt;podcast = <span class="variable token">$podcast</span>;
    }

    <span class="comment token">/**
     * 执行任务。
     *
     *<span class="phpdoc token"> @param</span>  \App\Services\AudioProcessor  $processor
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> handle(AudioProcessor <span class="variable token">$processor</span>)
    {
        <span class="comment token">// 处理上传的播客...</span>
    }

    <span class="comment token">/**
     * Handle a job failure.
     *
     *<span class="phpdoc token"> @param</span>  \Throwable  $exception
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> failed(Throwable <span class="variable token">$exception</span>)
    {
        <span class="comment token">// 向用户发送失败通知等...</span>
    }
}
</code></pre>
<blockquote>
<p>注意：在调用 <code>failed</code> 方法之前实例化任务的新实例；因此，在 <code>handle</code> 方法中可能发生的任何类属性修改都将丢失。</p>
</blockquote>
<p><a name="retrying-failed-jobs"></a></p>
<h3 id="重试失败的任务">重试失败的任务</h3>
<p>要查看已插入到您的 <code>failed_jobs</code> 数据库表中的所有失败任务，您可以使用 <code>queue:failed</code> Artisan 命令：</p>
<pre><code class="language-shell">php artisan queue:failed
</code></pre>
<p><code>queue:failed</code> 命令将列出任务 ID、连接、队列、失败时间和有关任务的其他信息。任务 ID 可用于重试失败的任务。例如，要重试 ID 为 <code>ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece</code> 的失败任务，请发出以下命令：</p>
<pre><code class="language-shell">php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece
</code></pre>
<p>如有必要，可以向命令传递多个 ID:</p>
<pre><code class="language-shell">php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c-34f94a33c24d
</code></pre>
<p>还可以重试指定队列的所有失败任务:</p>
<pre><code class="language-shell">php artisan queue:retry --queue=name
</code></pre>
<p>重试所有失败任务，可以执行 <code>queue:retry</code> 命令，并将 <code>all</code> 作为ID传递:</p>
<pre><code class="language-shell">php artisan queue:retry all
</code></pre>
<p>如果要删除指定的失败任务，可以使用 <code>queue:forget</code> 命令:</p>
<pre><code class="language-shell">php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d
</code></pre>
<blockquote>
<p>技巧：使用 [Horizon](Horizon &quot;Horizon&quot;.html) 时，应该使用 <code>Horizon:forget</code> 命令来删除失败任务，而不是 <code>queue:forget</code> 命令。</p>
</blockquote>
<p>删除 <code>failed_jobs</code> 表中所有失败任务，可以使用 <code>queue:flush</code> 命令:</p>
<pre><code class="language-shell">php artisan queue:flush
</code></pre>
<p><a name="ignoring-missing-models"></a></p>
<h3 id="忽略缺失的模型">忽略缺失的模型</h3>
<p> 向任务中注入 <code>Eloquent</code> 模型时，模型会在注入队列之前自动序列化，并在处理任务时从数据库中重新检索。但是，如果在任务等待消费时删除了模型，则任务可能会失败，抛出 <code>ModelNotFoundException</code> 异常。</p>
<p>为方便起见，可以把将任务的 <code>deleteWhenMissingModels</code> 属性设置为 <code>true</code>，这样会自动删除缺少模型的任务。当此属性设置为 <code>true</code> 时，Laravel 会放弃该任务，并且不会引发异常：</p>
<pre><code><span class="comment token">/**
 * 如果任务的模型不存在，则删除该任务。
 *
 *<span class="phpdoc token"> @var</span> bool
 */</span>
<span class="keyword token">public</span> <span class="variable token">$deleteWhenMissingModels</span> = <span class="keyword token">true</span>;
</code></pre>
<p><a name="pruning-failed-jobs"></a></p>
<h3 id="删除失败的任务">删除失败的任务</h3>
<p>您可以通过调用 <code>queue:prune-failed</code> Artisan 命令删除应用程序的 <code>failed_jobs</code> 表中的所有记录：</p>
<pre><code class="language-shell">php artisan queue:prune-failed
</code></pre>
<p>如果为命令提供 <code>--hours</code> 选项，则仅保留在过去 N 小时内插入的失败任务记录。例如，以下命令将删除超过 48 小时前插入的所有失败任务记录：</p>
<pre><code class="language-shell">php artisan queue:prune-failed --hours=48
</code></pre>
<p><a name="storing-failed-jobs-in-dynamodb"></a></p>
<h3 id="在-dynamodb-中存储失败的任务">在 DynamoDB 中存储失败的任务</h3>
<p>Laravel 还支持将失败的任务记录存储在 <a href="https://aws.amazon.com/dynamodb">DynamoDB</a> 而不是关系数据库表中。但是，您必须创建一个 DynamoDB 表来存储所有失败的任务记录。通常，此表应命名为 <code>failed_jobs</code>，但您应根据应用程序的 <code>queue</code> 配置文件中的 <code>queue.failed.table</code> 配置值命名该表。</p>
<p><code>failed_jobs</code> 表应该有一个名为 <code>application</code> 的字符串主分区键和一个名为 <code>uuid</code> 的字符串主排序键。键的 <code>application</code> 部分将包含应用程序的名称，该名称由应用程序的 <code>app</code> 配置文件中的 <code>name</code> 配置值定义。由于应用程序名称是 DynamoDB 表键的一部分，因此您可以使用同一个表来存储多个 Laravel 应用程序的失败任务。</p>
<p>此外，请确保您安装了 AWS 开发工具包，以便您的 Laravel 应用程序可以与 Amazon DynamoDB 通信：</p>
<pre><code class="language-shell">composer <span class="keyword token">require</span> aws/aws-sdk-php
</code></pre>
<p>接下来，<code>queue.failed.driver</code> 配置选项的值设置为 <code>dynamodb</code>。此外，您应该在失败的作业配置数组中定义 <code>key</code>、<code>secret</code> 和 <code>region</code> 配置选项。 这些选项将用于向 AWS 进行身份验证。 当使用 <code>dynamodb</code> 驱动程序时，<code>queue.failed.database</code> 配置选项不是必须的：</p>
<pre><code class="language-php">'failed' =&gt; [
    'driver' =&gt; env('QUEUE_FAILED_DRIVER', 'dynamodb'),
    'key' =&gt; env('AWS_ACCESS_KEY_ID'),
    'secret' =&gt; env('AWS_SECRET_ACCESS_KEY'),
    'region' =&gt; env('AWS_DEFAULT_REGION', 'us-east-1'),
    'table' =&gt; 'failed_jobs',
],
</code></pre>
<p><a name="disabling-failed-job-storage"></a></p>
<h3 id="禁用失败的任务存储">禁用失败的任务存储</h3>
<p>您可以通过将 <code>queue.failed.driver</code> 配置选项的值设置为 <code>null</code> 来指示 Laravel 丢弃失败的任务而不存储它们。通过 <code>QUEUE_FAILED_DRIVER</code> 环境变量来完成：</p>
<pre><code class="language-ini">QUEUE_FAILED_DRIVER=<span class="keyword token">null</span>
</code></pre>
<p><a name="failed-job-events"></a></p>
<h3 id="失败的任务事件">失败的任务事件</h3>
<p>如果你想注册一个在作业失败时调用的事件监听器，你可以使用 <code>Queue</code> 门面的 <code>failing</code> 方法。例如，我们可以从 Laravel 中包含的 <code>AppServiceProvider</code> 的 <code>boot</code> 方法为这个事件附加一个闭包：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Providers;

<span class="keyword token">use</span> Illuminate\Support\Facades\Queue;
<span class="keyword token">use</span> Illuminate\Support\ServiceProvider;
<span class="keyword token">use</span> Illuminate\Queue\Events\JobFailed;

<span class="keyword token">class</span> AppServiceProvider <span class="keyword token">extends</span> ServiceProvider
{
    <span class="comment token">/**
     * 注册任何应用程序服务。
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> register()
    {
        <span class="comment token">//</span>
    }

    <span class="comment token">/**
     * 引导任何应用程序服务。
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> boot()
    {
        Queue::failing(<span class="keyword token">function</span> (JobFailed <span class="variable token">$event</span>) {
            <span class="comment token">// $event-&gt;connectionName</span>
            <span class="comment token">// $event-&gt;job</span>
            <span class="comment token">// $event-&gt;exception</span>
        });
    }
}
</code></pre>
<p><a name="clearing-jobs-from-queues"></a></p>
<h2 id="从队列中清除任务">从队列中清除任务</h2>
<blockquote>
<p>技巧：使用 <a href="horizon.html">Horizon</a> 时，应使用 <code>horizon:clear</code> 命令从队列中清除作业，而不是使用 <code>queue:clear</code> 命令。</p>
</blockquote>
<p>如果你想从默认连接的默认队列中删除所有任务，你可以使用 <code>queue:clear</code> Artisan 命令来执行此操作：</p>
<pre><code class="language-shell">php artisan queue:clear
</code></pre>
<p>你还可以提供 <code>connection</code> 参数和 <code>queue</code> 选项以从特定连接和队列中删除任务：</p>
<pre><code class="language-shell">php artisan queue:clear redis --queue=emails
</code></pre>
<blockquote>
<p>注意：从队列中清除任务仅适用于 SQS、Redis 和数据库队列驱动程序。 此外，SQS 消息删除过程最多需要 60 秒，因此在你清除队列后 60 秒内发送到 SQS 队列的任务也可能会被删除。</p>
</blockquote>
<p><a name="monitoring-your-queues"></a></p>
<h2 id="监控你的队列新特性">监控你的队列[新特性]</h2>
<p>如果你的队列突然涌入了大量的任务，它会导致队列任务繁重, 从而增加了任务的完成时间，想你所想， Laravel 可以在队列执行超过设定的阈值时候提醒你。</p>
<p>在开始之前， 你需要通过 <code>queue:monitor</code> 命令配置它 <a href="scheduling.html">每分钟执行一次</a>。这个命令可以设定任务的名称，以及你想要设定的任务阈值：</p>
<pre><code class="language-shell">php artisan queue:monitor redis:<span class="keyword token">default</span>,redis:deployments --max=<span class="number token">100</span>
</code></pre>
<p>当你的任务超过设定阈值时候，仅通过这个方法还不足以触发通知，此时会触发一个 <code>Illuminate\Queue\Events\QueueBusy</code> 事件。你可以在你的应用 <code>EventServiceProvider</code> 来监听这个事件，从而将监听结果通知给你的开发团队：</p>
<pre><code class="language-php"><span class="keyword token">use</span> App\Notifications\QueueHasLongWaitTime;
<span class="keyword token">use</span> Illuminate\Queue\Events\QueueBusy;
<span class="keyword token">use</span> Illuminate\Support\Facades\Event;
<span class="keyword token">use</span> Illuminate\Support\Facades\Notification;

<span class="comment token">/**
 * 为你的应用程序注册其他更多事件
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> boot()
{
    Event::listen(<span class="keyword token">function</span> (QueueBusy <span class="variable token">$event</span>) {
        Notification::route(<span class="string token">'mail'</span>, <span class="string token">'dev@example.com'</span>)
                -&gt;notify(<span class="keyword token">new</span> QueueHasLongWaitTime(
                    <span class="variable token">$event</span>-&gt;connection,
                    <span class="variable token">$event</span>-&gt;queue,
                    <span class="variable token">$event</span>-&gt;size
                ));
    });
}
</code></pre>
<p><a name="job-events"></a></p>
<h2 id="任务事件">任务事件</h2>
<p>通过使用 <code>Queue</code> <a href="facades.html">facade</a> 当中的 <code>before</code> 和 <code>after</code> 方法 , 你可以指定在处理排队任务之前或之后执行的回调。如果要为控制面板执行附加日志记录或者增量统计，这些回调会是最佳的机会。通常，你应该从 <a href="providers.html">服务提供者</a> 的 <code>boot</code> 方法中调用，例如，我们可以使用 Laravel 的 <code>AppServiceProvider</code>服务:</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Providers;

<span class="keyword token">use</span> Illuminate\Support\Facades\Queue;
<span class="keyword token">use</span> Illuminate\Support\ServiceProvider;
<span class="keyword token">use</span> Illuminate\Queue\Events\JobProcessed;
<span class="keyword token">use</span> Illuminate\Queue\Events\JobProcessing;

<span class="keyword token">class</span> AppServiceProvider <span class="keyword token">extends</span> ServiceProvider
{
    <span class="comment token">/**
     * 注册全局应用程序服务
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> register()
    {
        <span class="comment token">//</span>
    }

    <span class="comment token">/**
     * 启动全局应用程序服务
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> boot()
    {
        Queue::before(<span class="keyword token">function</span> (JobProcessing <span class="variable token">$event</span>) {
            <span class="comment token">// $event-&gt;connectionName</span>
            <span class="comment token">// $event-&gt;job</span>
            <span class="comment token">// $event-&gt;job-&gt;payload()</span>
        });

        Queue::after(<span class="keyword token">function</span> (JobProcessed <span class="variable token">$event</span>) {
            <span class="comment token">// $event-&gt;connectionName</span>
            <span class="comment token">// $event-&gt;job</span>
            <span class="comment token">// $event-&gt;job-&gt;payload()</span>
        });
    }
}
</code></pre>
<p>通过使用 <code>Queue</code> <a href="facades.html">facade</a> 的  <code>looping</code> 方法 ，你可以在 worker 尝试从队列获取任务之前执行指定的回调。例如，你可以注册一个闭包，用以回滚之前失败任务打开的任何事务：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\DB;
<span class="keyword token">use</span> Illuminate\Support\Facades\Queue;

Queue::looping(<span class="keyword token">function</span> () {
    <span class="keyword token">while</span> (DB::transactionLevel() &gt; <span class="number token">0</span>) {
        DB::rollBack();
    }
});
</code></pre>
</div>
    <blockquote style="font-size: 0.9em;">
        本译文仅用于学习和交流目的，转载请务必注明文章译者、出处、和本文链接 <br>
        我们的翻译工作遵照 <a href="https://learnku.com/docs/guide/cc4.0/6589">CC 协议</a>，如果我们的工作有侵犯到您的权益，请及时联系我们。
    </blockquote>
</body>

</html>
