<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Laravel 9.x 中文文档</title>
    <link rel="stylesheet" href="../style/idea.css">
<link rel="stylesheet" href="../style/bd0cbd7aa15e5518a47099735133bf3a-vendors.css">
<link rel="stylesheet" href="../style/a91e47e2539b98438cb4c6c3a665d642-app.css">
    <style>
        div.markdown-body {
            margin: 0 10px;
        }
    </style>
</head>

<body>
    <div class="markdown-body"><h1 id="laravel-dusk">Laravel Dusk</h1>
<ul>
<li><a href="#introduction">简介</a></li>
<li><a href="#installation">安装</a><ul>
<li><a href="#managing-chromedriver-installations">管理 ChromeDriver 安装</a></li>
<li><a href="#using-other-browsers">使用其他浏览器</a></li>
</ul>
</li>
<li><a href="#getting-started">开始</a><ul>
<li><a href="#generating-tests">创建测试</a></li>
<li><a href="#migrations">数据库迁移</a></li>
<li><a href="#running-tests">运行测试</a></li>
<li><a href="#environment-handling">环境变量处理</a></li>
</ul>
</li>
<li><a href="#browser-basics">浏览器基础</a><ul>
<li><a href="#creating-browsers">创建浏览器</a></li>
<li><a href="#navigation">导航</a></li>
<li><a href="#resizing-browser-windows">调整浏览器窗口大小</a></li>
<li><a href="#browser-macros">浏览器宏</a></li>
<li><a href="#authentication">验证</a></li>
<li><a href="#cookies">Cookies</a></li>
<li><a href="#executing-javascript">执行 JavaScript</a></li>
<li><a href="#taking-a-screenshot">获取截图</a></li>
<li><a href="#storing-console-output-to-disk">输出结果保存到硬盘</a></li>
<li><a href="#storing-page-source-to-disk">输出结果保存到硬盘</a></li>
</ul>
</li>
<li><a href="#interacting-with-elements">与元素交互</a><ul>
<li><a href="#dusk-selectors">Dusk 选择器</a></li>
<li><a href="#text-values-and-attributes">文本、值和属性</a></li>
<li><a href="#interacting-with-forms">使用表单</a></li>
<li><a href="#attaching-files">附加文件</a></li>
<li><a href="#pressing-buttons">按钮</a></li>
<li><a href="#clicking-links">点击链接</a></li>
<li><a href="#using-the-keyboard">使用键盘</a></li>
<li><a href="#using-the-mouse">使用鼠标</a></li>
<li><a href="#javascript-dialogs">JavaScript 对话框</a></li>
<li><a href="#scoping-selectors">作用域选择</a></li>
<li><a href="#waiting-for-elements">等待元素渲染</a></li>
<li><a href="#scrolling-an-element-into-view">将元素滚动到可见区域</a></li>
</ul>
</li>
<li><a href="#available-assertions">可用的断言</a></li>
<li><a href="#pages">网页</a><ul>
<li><a href="#generating-pages">创建网页</a></li>
<li><a href="#configuring-pages">配置网页</a></li>
<li><a href="#navigating-to-pages">导航至网页</a></li>
<li><a href="#shorthand-selectors">选择器简写</a></li>
<li><a href="#page-methods">网页方法</a></li>
</ul>
</li>
<li><a href="#components">组件</a><ul>
<li><a href="#generating-components">创建组件</a></li>
<li><a href="#using-components">使用组件</a></li>
</ul>
</li>
<li><a href="#continuous-integration">持续集成</a><ul>
<li><a href="#running-tests-on-heroku-ci">Heroku CI</a></li>
<li><a href="#running-tests-on-travis-ci">Travis CI</a></li>
<li><a href="#running-tests-on-github-actions">GitHub Actions</a></li>
</ul>
</li>
</ul>
<p><a name="introduction"></a></p>
<h2 id="简介">简介</h2>
<p><a href="https://github.com/laravel/dusk">Laravel Dusk</a> Laravel Dusk 提供了富有表现力、简单易用的浏览器自动化及测试 API 。默认情况下，Dusk 不需要在你的机器上安装 JDK 或者 Selenium 。而是需要使用单独的 <a href="https://sites.google.com/chromium.org/driver">ChromeDriver</a> 进行安装。当然，你也可以自由使用其他的兼容 Selenium 的驱动程序。</p>
<p><a name="installation"></a></p>
<h2 id="安装">安装</h2>
<p>首先，您应该安装 <a href="https://www.google.com/chrome">Google Chrome</a>并将 <code>laravel/dusk</code>  依赖项添加到你的项目中:</p>
<pre><code class="language-shell">composer <span class="keyword token">require</span> --dev laravel/dusk
</code></pre>
<blockquote>
<p>注意：如果你是手动注册 Dusk 服务提供者，一定 <strong>不能</strong> 在你的生产环境中注册，这样可能会导致一些不守规矩的用户拥有控制你应用的权限。</p>
</blockquote>
<p>安装好 Dusk 包后，运行 <code>dusk:install</code>  命令。<code>dusk:install</code> 命令会创建一个 <code>tests/Browser</code> 目录和一个测试例子：</p>
<pre><code class="language-shell">php artisan dusk:install
</code></pre>
<p>接下来，在你的 <code>.env</code> 文件中设置  <code>APP_URL</code>  变量。这个值应该与你在浏览器中打开本应用的 URL 相匹配。</p>
<blockquote>
<p>技巧：如果您使用 <a href="sail.html">Laravel Sail</a> 管理您的本地开发环境，还请查阅  <a href="sail.html#laravel-dusk">configuring and running Dusk tests</a> 的文档。</p>
</blockquote>
<p><a name="managing-chromedriver-installations"></a></p>
<h3 id="管理-chromedriver-安装">管理 ChromeDriver 安装</h3>
<p>如果你想安装与 Laravel Dusk 附带版本不同的 ChromeDriver，可以使用 <code>dusk:chrome-driver</code> 命令:</p>
<pre><code class="language-shell"><span class="comment token"># 为你的操作系统安装最新版本的 ChromeDriver...</span>
php artisan dusk:chrome-driver

<span class="comment token"># 为你的操作系统安装指定版本的 ChromeDriver...</span>
php artisan dusk:chrome-driver <span class="number token">86</span>

<span class="comment token"># 为所有支持的操作系统安装指定版本的 ChromeDriver...</span>
php artisan dusk:chrome-driver --all

<span class="comment token"># 安装与您的操作系统检测到的 Chrome/Chromium 版本匹配的 ChromeDriver 版本...</span>
php artisan dusk:chrome-driver --detect
</code></pre>
<blockquote>
<p>注意：Dusk 要求 <code>chromedriver</code> 二进制文件是可执行的。如果在 Dusk 运行时遇到问题，可以使用以下命令确保二进制文件是可执行的： <code>chmod -R 0755 vendor/laravel/dusk/bin/</code>。</p>
</blockquote>
<p><a name="using-other-browsers"></a></p>
<h3 id="使用其他浏览器">使用其他浏览器</h3>
<p>默认情况下， Dusk 使用 Google Chrome 浏览器和一个单独安装的 <a href="https://sites.google.com/chromium.org/driver">ChromeDriver</a> 来运行你的浏览器测试。当然，你可以运行你自己的 Selenium 服务，用任何你想用的浏览器来进行测试。</p>
<p>如果要这么做，打开你的 <code>tests/DuskTestCase.php</code> 文件，这个是应用测试用例的基类。在这个文件中，你可以移除对 <code>startChromeDriver</code> 方法的调用。这样 Dusk 就不会自动启动 ChromeDriver 了。</p>
<pre><code><span class="comment token">/**
 * Prepare for Dusk test execution.
 *
 *<span class="phpdoc token"> @beforeClass</span>
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">static</span> <span class="keyword token">function</span> prepare()
{
    <span class="comment token">// static::startChromeDriver();</span>
}
</code></pre>
<p>然后，你可以按照自己的意愿修改 <code>driver</code> 方法来连接到你选定的 URL 和端口。此外，你可以修改 「desired capabilities」（期望能力），它将会被传递给 WebDriver：</p>
<pre><code><span class="comment token">/**
 * Create the RemoteWebDriver instance.
 *
 *<span class="phpdoc token"> @return</span> \Facebook\WebDriver\Remote\RemoteWebDriver
 */</span>
<span class="keyword token">protected</span> <span class="keyword token">function</span> driver()
{
    <span class="keyword token">return</span> RemoteWebDriver::create(
        <span class="string token">'http://localhost:4444/wd/hub'</span>, DesiredCapabilities::phantomjs()
    );
}
</code></pre>
<p><a name="getting-started"></a></p>
<h2 id="开始">开始</h2>
<p><a name="generating-tests"></a></p>
<h3 id="创建测试">创建测试</h3>
<p>要创建一个 Dusk 测试，可以使用 <code>dusk:make</code> 命令。创建的测试将会被放在 <code>tests/Browser</code> 目录中：</p>
<pre><code class="language-shell">php artisan dusk:make LoginTest
</code></pre>
<p><a name="migrations"></a></p>
<h3 id="数据库迁移">数据库迁移</h3>
<p>编写的测试，大多数都是从数据库中查询数据的页面，与这些页面进行交互。但是，你的 Dusk 测试不应使用 <code>RefreshDatabase </code> Trait。 <code>RefreshDatabase</code> Trait 利用了数据库事务，该事务在 HTTP 请求中将不适用或不可用。相反，请使用 <code>DatabaseMigrations</code> Trait，该 Trait 将为每个测试重新迁移数据库：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> Tests\Browser;

<span class="keyword token">use</span> App\Models\User;
<span class="keyword token">use</span> Illuminate\Foundation\Testing\DatabaseMigrations;
<span class="keyword token">use</span> Laravel\Dusk\Chrome;
<span class="keyword token">use</span> Tests\DuskTestCase;

<span class="keyword token">class</span> ExampleTest <span class="keyword token">extends</span> DuskTestCase
{
    <span class="keyword token">use</span> DatabaseMigrations;
}
</code></pre>
<blockquote>
<p>注意：执行 Dusk 测试时，可能不会使用 SQLite 内存数据库。由于浏览器在其自己的进程中执行，因此它将无法访问其他进程的内存数据库。</p>
</blockquote>
<p><a name="running-tests"></a></p>
<h3 id="运行时测试">运行时测试</h3>
<p>要运行浏览器测试，请执行 <code>Dask</code> Artisan 命令：</p>
<pre><code class="language-shell">php artisan dusk
</code></pre>
<p>如果您上次运行 <code>dush</code> 命令时测试失败，可以先使用 <code>dusk:fails</code> 命令重新运行失败的测试，以节约时间：</p>
<pre><code class="language-shell">php artisan dusk:fails
</code></pre>
<p><code>dusk</code> 命令接受 PHPUnit 测试运行程序通常接受的任何参数，例如只允许您为给定的<a href="https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.group">组</a>:运行测试</p>
<pre><code class="language-shell">php artisan dusk --group=foo
</code></pre>
<blockquote>
<p>技巧：如果您使用 <a href="sail.html">Laravel Sail</a> 管理您的本地开发环境，还请查阅 <a href="sail.html#laravel-dusk">配置和运行 Dusk 测试</a> 的文档。</p>
</blockquote>
<p><a name="manually-starting-chromedriver"></a></p>
<h4 id="手动启动-chromedriver">手动启动 ChromeDriver</h4>
<p>默认情况下，Dusk 将自动尝试启动 ChromeDriver。如果这不适用于您的特定系统，您可以在运行 <code>dusk</code> 命令之前手动启动 ChromeDriver。如果你选择手动启动 ChromeDriver，你应该注释掉下面的 <code>tests/testcase.php</code> 文件：</p>
<pre><code><span class="comment token">/**
 * Prepare for Dusk test execution.
 *
 *<span class="phpdoc token"> @beforeClass</span>
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">static</span> <span class="keyword token">function</span> prepare()
{
    <span class="comment token">// static::startChromeDriver();</span>
}
</code></pre>
<p>此外，如果在9515以外的端口上启动 ChromeDriver，则应修改同类一的 <code>driver</code> 方法，以映射正确的端口：</p>
<pre><code><span class="comment token">/**
 * 创建RemoteWebDriver实例。
 *
 *<span class="phpdoc token"> @return</span> \Facebook\WebDriver\Remote\RemoteWebDriver
 */</span>
<span class="keyword token">protected</span> <span class="keyword token">function</span> driver()
{
    <span class="keyword token">return</span> RemoteWebDriver::create(
        <span class="string token">'http://localhost:9515'</span>, DesiredCapabilities::chrome()
    );
}
</code></pre>
<p><a name="environment-handling"></a></p>
<h3 id="环境处理">环境处理</h3>
<p>要强制 Dusk 在运行测试时使用它自己的环境文件，请在项目的根目录中创建一个 <code>.env.dusk.{environment}</code> 文件。 例如，如果您要从 <code>local</code> 环境启动 <code>dusk</code> 命令，则应创建一个 <code>.env.dusk.local</code> 文件。</p>
<p>运行测试时，Dusk 会备份你的 <code>.env</code> 文件并将你的 Dusk 环境重命名为 <code>.env</code>。 测试完成后，<code>.env</code> 文件将被恢复。</p>
<p><a name="browser-basics"></a></p>
<h2 id="浏览器基础">浏览器基础</h2>
<p><a name="creating-browsers"></a></p>
<h3 id="创建浏览器">创建浏览器</h3>
<p>首先，让我们编写一个测试来验证我们可以登录到我们的应用程序。生成测试后，我们可以修改它以导航到登录页面，输入一些凭据，然后单击「登录」按钮。要创建浏览器实例，您可以在 Dusk 测试中调用 <code>browse</code> 方法：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> Tests\Browser;

<span class="keyword token">use</span> App\Models\User;
<span class="keyword token">use</span> Illuminate\Foundation\Testing\DatabaseMigrations;
<span class="keyword token">use</span> Laravel\Dusk\Chrome;
<span class="keyword token">use</span> Tests\DuskTestCase;

<span class="keyword token">class</span> ExampleTest <span class="keyword token">extends</span> DuskTestCase
{
    <span class="keyword token">use</span> DatabaseMigrations;

    <span class="comment token">/**
     * 基本的浏览器测试示例。
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> test_basic_example()
    {
        <span class="variable token">$user</span> = User::factory()-&gt;create([
            <span class="string token">'email'</span> =&gt; <span class="string token">'taylor@laravel.com'</span>,
        ]);

        <span class="variable token">$this</span>-&gt;browse(<span class="keyword token">function</span> (<span class="variable token">$browser</span>) <span class="keyword token">use</span> (<span class="variable token">$user</span>) {
            <span class="variable token">$browser</span>-&gt;visit(<span class="string token">'/login'</span>)
                    -&gt;type(<span class="string token">'email'</span>, <span class="variable token">$user</span>-&gt;email)
                    -&gt;type(<span class="string token">'password'</span>, <span class="string token">'password'</span>)
                    -&gt;press(<span class="string token">'Login'</span>)
                    -&gt;assertPathIs(<span class="string token">'/home'</span>);
        });
    }
}
</code></pre>
<p>正如你在上面的例子中看到的，<code>browse</code> 方法接受一个闭包。 Dusk 会自动将一个浏览器实例传递给这个闭包，用于与您的应用程序交互和对应用程序进行断言的主要对象。</p>
<p><a name="creating-multiple-browsers"></a></p>
<h4 id="创建多个浏览器">创建多个浏览器</h4>
<p>有时您可能需要多个浏览器才能正确执行测试。例如，可能需要多个浏览器来测试与 websocket 交互的聊天页面。要创建多个浏览器，只需将更多浏览器参数添加到 <code>browse</code> 方法的闭包签名中：</p>
<pre><code><span class="variable token">$this</span>-&gt;browse(<span class="keyword token">function</span> (<span class="variable token">$first</span>, <span class="variable token">$second</span>) {
    <span class="variable token">$first</span>-&gt;loginAs(User::find(<span class="number token">1</span>))
          -&gt;visit(<span class="string token">'/home'</span>)
          -&gt;waitForText(<span class="string token">'Message'</span>);

    <span class="variable token">$second</span>-&gt;loginAs(User::find(<span class="number token">2</span>))
           -&gt;visit(<span class="string token">'/home'</span>)
           -&gt;waitForText(<span class="string token">'Message'</span>)
           -&gt;type(<span class="string token">'message'</span>, <span class="string token">'Hey Taylor'</span>)
           -&gt;press(<span class="string token">'Send'</span>);

    <span class="variable token">$first</span>-&gt;waitForText(<span class="string token">'Hey Taylor'</span>)
          -&gt;assertSee(<span class="string token">'Jeffrey Way'</span>);
});
</code></pre>
<p><a name="navigation"></a></p>
<h3 id="导航">导航</h3>
<p>可以使用 <code>visit</code> 方法导航到应用程序中的给定 URI：</p>
<pre><code><span class="variable token">$browser</span>-&gt;visit(<span class="string token">'/login'</span>);
</code></pre>
<p>你也可以使用 <code>visitRoute</code> 方法导航到 <a href="routing.html#named-routes">命名路由</a>：</p>
<pre><code><span class="variable token">$browser</span>-&gt;visitRoute(<span class="string token">'login'</span>);
</code></pre>
<p>可以使用 <code>back</code> 和 <code>forward</code> 方法导航 「后退」和 「前进」：</p>
<pre><code><span class="variable token">$browser</span>-&gt;back();

<span class="variable token">$browser</span>-&gt;forward();
</code></pre>
<p>可以使用 <code>refresh</code> 方法刷新页面：</p>
<pre><code><span class="variable token">$browser</span>-&gt;refresh();
</code></pre>
<p><a name="resizing-browser-windows"></a></p>
<h3 id="改变浏览器窗口大小">改变浏览器窗口大小</h3>
<p>可以使用 <code>resize</code> 方法去调整浏览器的窗口大小：</p>
<pre><code><span class="variable token">$browser</span>-&gt;resize(<span class="number token">1920</span>, <span class="number token">1080</span>);
</code></pre>
<p>该 <code>maximize</code> 方法可以将浏览器窗口最大化：</p>
<pre><code><span class="variable token">$browser</span>-&gt;maximize();
</code></pre>
<p>该 <code>fitContent</code> 方法将自动适配浏览器的窗口大小和页面内容的尺寸：</p>
<pre><code><span class="variable token">$browser</span>-&gt;fitContent();
</code></pre>
<p>测试失败时，Dusk 会自动将浏览器窗口缩放至内容大小并拍下屏幕快照，你可以通过调用 <code>disableFitOnFailure</code> 方法来禁用这一特性：</p>
<pre><code><span class="variable token">$browser</span>-&gt;disableFitOnFailure();
</code></pre>
<p>你可以使用 <code>move</code> 方法将浏览器窗口移动到屏幕上的其他位置：</p>
<pre><code><span class="variable token">$browser</span>-&gt;move(<span class="variable token">$x</span> = <span class="number token">100</span>, <span class="variable token">$y</span> = <span class="number token">100</span>);
</code></pre>
<p><a name="browser-macros"></a></p>
<h3 id="浏览器宏">浏览器宏</h3>
<p>如果你想定义一个可以在各种测试中重复使用的自定义浏览器方法，可以在 <code>Browser</code> 类中使用 <code>macro</code> 方法。通常，你应该从 <a href="providers.html">服务提供者</a> 的 <code>boot</code> 方法中调用它：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Providers;

<span class="keyword token">use</span> Illuminate\Support\ServiceProvider;
<span class="keyword token">use</span> Laravel\Dusk\Browser;

<span class="keyword token">class</span> DuskServiceProvider <span class="keyword token">extends</span> ServiceProvider
{
    <span class="comment token">/**
     * Register Dusk's browser macros.
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> boot()
    {
        Browser::macro(<span class="string token">'scrollToElement'</span>, <span class="keyword token">function</span> (<span class="variable token">$element</span> = <span class="keyword token">null</span>) {
            <span class="variable token">$this</span>-&gt;script(<span class="string token">"$('html, body').animate({ scrollTop: $('$element').offset().top }, 0);"</span>);

            <span class="keyword token">return</span> <span class="variable token">$this</span>;
        });
    }
}
</code></pre>
<p>该 <code>macro</code> 函数接收方法名作为其第一个参数，并接收闭包作为其第二个参数。 将宏作为 <code>Browser</code> 实现上的方法调用宏时，将执行宏的闭包：</p>
<pre><code><span class="variable token">$this</span>-&gt;browse(<span class="keyword token">function</span> (<span class="variable token">$browser</span>) <span class="keyword token">use</span> (<span class="variable token">$user</span>) {
    <span class="variable token">$browser</span>-&gt;visit(<span class="string token">'/pay'</span>)
            -&gt;scrollToElement(<span class="string token">'#credit-card-details'</span>)
            -&gt;assertSee(<span class="string token">'Enter Credit Card Details'</span>);
});
</code></pre>
<p><a name="authentication"></a></p>
<h3 id="用户认证">用户认证</h3>
<p>我们经常会测试需要身份验证的页面，你可以使用 Dusk 的 <code>loginAs</code> 方法来避免在每次测试期间与登录页面进行交互。该 <code>loginAs</code> 方法接收用户 ID 或者用户模型实例：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$this</span>-&gt;browse(<span class="keyword token">function</span> (<span class="variable token">$browser</span>) {
    <span class="variable token">$browser</span>-&gt;loginAs(User::find(<span class="number token">1</span>))
          -&gt;visit(<span class="string token">'/home'</span>);
});
</code></pre>
<blockquote>
<p>注意：使用 <code>loginAs</code> 方法后，用户会话在文件中的所有测试被维护。</p>
</blockquote>
<p><a name="cookies"></a></p>
<h3 id="cookies">Cookies</h3>
<p>你可以使用 <code>cookie</code> 方法来获取或者设置加密过的 cookie 的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;cookie(<span class="string token">'name'</span>);

<span class="variable token">$browser</span>-&gt;cookie(<span class="string token">'name'</span>, <span class="string token">'Taylor'</span>);
</code></pre>
<p>使用 <code>plainCookie</code> 则可以获取或者设置未加密过的 cookie 的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;plainCookie(<span class="string token">'name'</span>);

<span class="variable token">$browser</span>-&gt;plainCookie(<span class="string token">'name'</span>, <span class="string token">'Taylor'</span>);
</code></pre>
<p>你可以使用 <code>deleteCookie</code> 方法删除指定的 cookie：</p>
<pre><code><span class="variable token">$browser</span>-&gt;deleteCookie(<span class="string token">'name'</span>);
</code></pre>
<p><a name="executing-javascript"></a></p>
<h3 id="运行-javascript">运行 JavaScript</h3>
<p>可以使用 <code>script</code> 方法在浏览器中执行任意 JavaScript 语句：</p>
<pre><code><span class="variable token">$browser</span>-&gt;script(<span class="string token">'document.documentElement.scrollTop = 0'</span>);

<span class="variable token">$browser</span>-&gt;script([
    <span class="string token">'document.body.scrollTop = 0'</span>,
    <span class="string token">'document.documentElement.scrollTop = 0'</span>,
]);

<span class="variable token">$output</span> = <span class="variable token">$browser</span>-&gt;script(<span class="string token">'return window.location.pathname'</span>);
</code></pre>
<p><a name="taking-a-screenshot"></a></p>
<h3 id="获取截图">获取截图</h3>
<p>你可以使用 <code>screenshot</code> 方法来截图并将其指定文件名存储，所有截图都将存放在 <code>tests/Browser/screenshots</code> 目录下：</p>
<pre><code><span class="variable token">$browser</span>-&gt;screenshot(<span class="string token">'filename'</span>);
</code></pre>
<p><a name="storing-console-output-to-disk"></a></p>
<h3 id="控制台输出结果保存到硬盘">控制台输出结果保存到硬盘</h3>
<p>你可以使用 <code>storeConsoleLog</code> 方法将控制台输出指定文件名并写入磁盘，控制台输出默认存放在 <code>tests/Browser/console</code> 目录下：</p>
<pre><code><span class="variable token">$browser</span>-&gt;storeConsoleLog(<span class="string token">'filename'</span>);
</code></pre>
<p><a name="storing-page-source-to-disk"></a></p>
<h3 id="页面源码保存到硬盘">页面源码保存到硬盘</h3>
<p>你可以使用 <code>storeSource</code> 方法将页面当前源代码指定文件名并写入磁盘，页面源代码默认会存放到 <code>tests/Browser/source</code> 目录：</p>
<pre><code><span class="variable token">$browser</span>-&gt;storeSource(<span class="string token">'filename'</span>);
</code></pre>
<p><a name="interacting-with-elements"></a></p>
<h2 id="与元素交互">与元素交互</h2>
<p><a name="dusk-selectors"></a></p>
<h3 id="dusk-选择器">Dusk 选择器</h3>
<p>编写 Dusk 测试最困难的部分之一就是选择良好的 CSS 选择器与元素进行交互。 随着时间的推移，前端的更改可能会导致如下所示的 CSS 选择器无法通过测试：</p>
<pre><code><span class="comment token">// HTML...</span>

&lt;button&gt;Login&lt;/button&gt;

<span class="comment token">// Test...</span>

<span class="variable token">$browser</span>-&gt;click(<span class="string token">'.login-page .container div &gt; button'</span>);
</code></pre>
<p>Dusk 选择器可以让你专注于编写有效的测试，而不必记住 CSS 选择器。要定义一个选择器，你需要添加一个 <code>dusk</code> 属性在 HTML 元素中。然后在选择器前面加上 <code>@</code> 用来在 Dusk 测试中操作元素：</p>
<pre><code><span class="comment token">// HTML...</span>

&lt;button dusk=<span class="string token">"login-button"</span>&gt;Login&lt;/button&gt;

<span class="comment token">// Test...</span>

<span class="variable token">$browser</span>-&gt;click(<span class="string token">'@login-button'</span>);
</code></pre>
<p><a name="text-values-and-attributes"></a></p>
<h3 id="文本、值--属性">文本、值 &amp; 属性</h3>
<p><a name="retrieving-setting-values"></a></p>
<h4 id="获取--设置值">获取 &amp; 设置值</h4>
<p>Dusk 提供了多个方法用于和页面元素的当前显示文本、值和属性进行交互，例如，要获取匹配指定选择器的元素的「值」，使用 <code>value</code> 方法：</p>
<pre><code><span class="comment token">// 获取值...</span>
<span class="variable token">$value</span> = <span class="variable token">$browser</span>-&gt;value(<span class="string token">'selector'</span>);

<span class="comment token">// 设置值...</span>
<span class="variable token">$browser</span>-&gt;value(<span class="string token">'selector'</span>, <span class="string token">'value'</span>);
</code></pre>
<p>你可以使用 <code>inputValue</code> 方法来获取包含指定字段名称的输入元素的「值」：</p>
<pre><code><span class="variable token">$value</span> = <span class="variable token">$browser</span>-&gt;inputValue(<span class="string token">'field'</span>);
</code></pre>
<p><a name="retrieving-text"></a></p>
<h4 id="获取文本">获取文本</h4>
<p>该 <code>text</code> 方法可以用于获取匹配指定选择器元素文本：</p>
<pre><code><span class="variable token">$text</span> = <span class="variable token">$browser</span>-&gt;text(<span class="string token">'selector'</span>);
</code></pre>
<p><a name="retrieving-attributes"></a></p>
<h4 id="获取属性">获取属性</h4>
<p>最后，该 <code>attribute</code> 方法可以用于获取匹配指定选择器元素属性：</p>
<pre><code><span class="variable token">$attribute</span> = <span class="variable token">$browser</span>-&gt;attribute(<span class="string token">'selector'</span>, <span class="string token">'value'</span>);
</code></pre>
<p><a name="interacting-with-forms"></a></p>
<h3 id="使用表单">使用表单</h3>
<p><a name="typing-values"></a></p>
<h4 id="输入值">输入值</h4>
<p>Dusk 提供了多种方法来与表单和输入元素进行交互。首先，让我们看一个在字段中输入值的示例：</p>
<pre><code><span class="variable token">$browser</span>-&gt;type(<span class="string token">'email'</span>, <span class="string token">'taylor@laravel.com'</span>);
</code></pre>
<p>注意，尽管该方法在需要时接收，但是我们不需要将 CSS 选择器传递给 <code>type</code> 方法。如果没有提供 CSS 选择器，Dusk 会搜索包含指定 <code>name</code> 属性的 <code>input</code> 或 <code>textarea</code> 字段。</p>
<p>要想将文本附加到一个字段之后而且不清除其内容， 你可以使用 <code>append</code> 方法：</p>
<pre><code><span class="variable token">$browser</span>-&gt;type(<span class="string token">'tags'</span>, <span class="string token">'foo'</span>)
        -&gt;append(<span class="string token">'tags'</span>, <span class="string token">', bar, baz'</span>);
</code></pre>
<p>你可以使用 <code>clear</code> 方法清除输入值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;clear(<span class="string token">'email'</span>);
</code></pre>
<p>你可以使用 <code>typeSlowly</code> 方法指示 Dusk 缓慢键入。 默认情况下，Dusk 在两次按键之间将暂停 100 毫秒。 要自定义按键之间的时间量，你可以将适当的毫秒数作为方法的第二个参数传递：</p>
<pre><code><span class="variable token">$browser</span>-&gt;typeSlowly(<span class="string token">'mobile'</span>, <span class="string token">'+1 (202) 555-5555'</span>);

<span class="variable token">$browser</span>-&gt;typeSlowly(<span class="string token">'mobile'</span>, <span class="string token">'+1 (202) 555-5555'</span>, <span class="number token">300</span>);
</code></pre>
<p>你可以使用 <code>appendSlowly</code> 方法缓慢添加文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;type(<span class="string token">'tags'</span>, <span class="string token">'foo'</span>)
        -&gt;appendSlowly(<span class="string token">'tags'</span>, <span class="string token">', bar, baz'</span>);
</code></pre>
<p><a name="dropdowns"></a></p>
<h4 id="下拉菜单">下拉菜单</h4>
<p>需要在下拉菜单中选择值，你可以使用 <code>select</code> 方法。 类似于 <code>type</code> 方法， 该 <code>select</code> 方法并不是一定要传入 CSS 选择器。 当使用 <code>select</code> 方法时，你应该传递选项实际的值而不是它的显示文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;select(<span class="string token">'size'</span>, <span class="string token">'Large'</span>);
</code></pre>
<p>你也可以通过省略第二个参数来随机选择一个选项：</p>
<pre><code><span class="variable token">$browser</span>-&gt;select(<span class="string token">'size'</span>);
</code></pre>
<p>通过将数组作为 <code>select</code> 方法的第二个参数，可以指示该方法选择多个选项：</p>
<pre><code><span class="variable token">$browser</span>-&gt;select(<span class="string token">'categories'</span>, [<span class="string token">'Art'</span>, <span class="string token">'Music'</span>]);
</code></pre>
<p><a name="checkboxes"></a></p>
<h4 id="复选框">复选框</h4>
<p>使用「check」 复选框时，你可以使用 <code>check</code> 方法。 像其他许多与 input 相关的方法，并不是必须传入 CSS 选择器。 如果准确的选择器无法找到的时候，Dusk 会搜索能够与 <code>name</code> 属性匹配的复选框：</p>
<pre><code><span class="variable token">$browser</span>-&gt;check(<span class="string token">'terms'</span>);
</code></pre>
<p>该 <code>uncheck</code> 方法可用于「取消选中」复选框输入：</p>
<pre><code><span class="variable token">$browser</span>-&gt;uncheck(<span class="string token">'terms'</span>);
</code></pre>
<p><a name="radio-buttons"></a></p>
<h4 id="单选按钮">单选按钮</h4>
<p>使用 「select」中单选按钮选项时，你可以使用 <code>radio</code> 这个方法。 像很多其他的与输入相关的方法一样， 它也并不是必须传入 CSS 选择器。如果准确的选择器无法被找到的时候， Dusk 会搜索能够与 <code>name</code> 属性或者 <code>value</code> 属性相匹配的 <code>radio</code> 单选按钮：</p>
<pre><code><span class="variable token">$browser</span>-&gt;radio(<span class="string token">'size'</span>, <span class="string token">'large'</span>);
</code></pre>
<p><a name="attaching-files"></a></p>
<h3 id="附件">附件</h3>
<p>该 <code>attach</code> 方法可以附加一个文件到 <code>file</code>  input 元素中。 像很多其他的与输入相关的方法一样，他也并不是必须传入 CSS 选择器。如果准确的选择器没有被找到的时候， Dusk 会搜索与 <code>name</code> 属性匹配的文件输入框：</p>
<pre><code><span class="variable token">$browser</span>-&gt;attach(<span class="string token">'photo'</span>, __DIR__.<span class="string token">'/photos/mountains.png'</span>);
</code></pre>
<blockquote>
<p>注意：attach 方法需要使用 PHP <code>Zip</code> 扩展，你的服务器必须安装了此扩展。</p>
</blockquote>
<p><a name="pressing-buttons"></a></p>
<h3 id="点击按钮">点击按钮</h3>
<p>可以使用 <code>press</code> 方法来单击页面上的按钮元素。该 <code>press</code> 方法的第一个参数可以是按钮的显示文本，也可以是 CSS/ Dusk 选择器：</p>
<pre><code><span class="variable token">$browser</span>-&gt;press(<span class="string token">'Login'</span>);
</code></pre>
<p>提交表单时，许多应用程序在按下表单后会禁用表单的提交按钮，然后在表单提交的 HTTP 请求完成后重新启用该按钮。要按下按钮并等待按钮被重新启用，可以使用 <code>pressAndWaitFor</code> 方法：</p>
<pre><code><span class="comment token">// Press the button and wait a maximum of 5 seconds for it to be enabled...</span>
<span class="variable token">$browser</span>-&gt;pressAndWaitFor(<span class="string token">'Save'</span>);

<span class="comment token">// Press the button and wait a maximum of 1 second for it to be enabled...</span>
<span class="variable token">$browser</span>-&gt;pressAndWaitFor(<span class="string token">'Save'</span>, <span class="number token">1</span>);
</code></pre>
<p><a name="clicking-links"></a></p>
<h3 id="点击链接">点击链接</h3>
<p>要点击链接，可以在浏览器实例下使用 <code>clickLink</code> 方法。该 <code>clickLink</code> 方法将点击指定文本的链接：</p>
<pre><code><span class="variable token">$browser</span>-&gt;clickLink(<span class="variable token">$linkText</span>);
</code></pre>
<p>您可以使用 <code>seeLink</code> 方法来确定具有给定显示文本的链接在页面上是否可见：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$browser</span>-&gt;seeLink(<span class="variable token">$linkText</span>)) {
    <span class="comment token">// ...</span>
}
</code></pre>
<blockquote>
<p>注意：这些方法与 jQuery 交互。 如果页面上没有 jQuery ， Dusk 会自动将其注入到页面中，以便在测试期间可用。</p>
</blockquote>
<p><a name="using-the-keyboard"></a></p>
<h3 id="使用键盘">使用键盘</h3>
<p>该 <code>keys</code> 方法让你可以再指定元素中输入比 <code>type</code> 方法更加复杂的输入序列。例如，你可以在输入值的同时按下按键。在这个例子中，输入 <code>taylor</code> 时， <code>shift</code> 键也同时被按下。当 <code>taylor</code> 输入完之后， 将会输入 <code>swift</code> 而不会按下任何按键：</p>
<pre><code><span class="variable token">$browser</span>-&gt;keys(<span class="string token">'selector'</span>, [<span class="string token">'{shift}'</span>, <span class="string token">'taylor'</span>], <span class="string token">'swift'</span>);
</code></pre>
<p><code>keys</code> 方法的另一个有价值的用例是向您的应用程序的主要 CSS 选择器发送「键盘快捷键」组合：</p>
<pre><code><span class="variable token">$browser</span>-&gt;keys(<span class="string token">'.app'</span>, [<span class="string token">'{command}'</span>, <span class="string token">'j'</span>]);
</code></pre>
<blockquote>
<p>技巧：所有修饰符键如 <code>{command}</code> 都包裹在 <code>{}</code> 字符中，并且与在 <code>Facebook\WebDriver\WebDriverKeys</code> 类中定义的常量匹配，该类可以 <a href="https://github.com/php-webdriver/php-webdriver/blob/master/lib/WebDriverKeys.php">在 GitHub 上找到</a>。</p>
</blockquote>
<p><a name="using-the-mouse"></a></p>
<h3 id="使用鼠标">使用鼠标</h3>
<p><a name="clicking-on-elements"></a></p>
<h4 id="点击元素">点击元素</h4>
<p>该 <code>click</code> 方法可用于「点击」与给定选择器匹配的元素：</p>
<pre><code><span class="variable token">$browser</span>-&gt;click(<span class="string token">'.selector'</span>);
</code></pre>
<p>该 <code>clickAtXPath</code> 方法可用于「单击」与给定 XPath 表达式匹配的元素：</p>
<pre><code><span class="variable token">$browser</span>-&gt;clickAtXPath(<span class="string token">'//div[@class = "selector"]'</span>);
</code></pre>
<p>该 <code>clickAtPoint</code> 方法可用于「点击」相对于浏览器可视区域的给定坐标对上的最高元素：</p>
<pre><code><span class="variable token">$browser</span>-&gt;clickAtPoint(<span class="variable token">$x</span> = <span class="number token">0</span>, <span class="variable token">$y</span> = <span class="number token">0</span>);
</code></pre>
<p>该 <code>doubleClick</code> 方法可用于模拟鼠标的双击：</p>
<pre><code><span class="variable token">$browser</span>-&gt;doubleClick();
</code></pre>
<p>该 <code>rightClick</code> 方法可用于模拟鼠标的右击：</p>
<pre><code><span class="variable token">$browser</span>-&gt;rightClick();

<span class="variable token">$browser</span>-&gt;rightClick(<span class="string token">'.selector'</span>);
</code></pre>
<p>该 <code>clickAndHold</code> 方法可用于模拟被单击并按住的鼠标按钮。 随后调用 <code>releaseMouse</code> 方法将撤消此行为并释放鼠标按钮：</p>
<pre><code><span class="variable token">$browser</span>-&gt;clickAndHold()
        -&gt;pause(<span class="number token">1000</span>)
        -&gt;releaseMouse();
</code></pre>
<p><a name="mouseover"></a></p>
<h4 id="鼠标悬停">鼠标悬停</h4>
<p>该 <code>mouseover</code> 方法可用于与给定选择器匹配的元素的鼠标悬停动作：</p>
<pre><code><span class="variable token">$browser</span>-&gt;mouseover(<span class="string token">'.selector'</span>);
</code></pre>
<p><a name="drag-drop"></a></p>
<h4 id="拖放">拖放</h4>
<p>该 <code>drag</code> 方法用于将与指定选择器匹配的元素拖到其它元素：</p>
<pre><code><span class="variable token">$browser</span>-&gt;drag(<span class="string token">'.from-selector'</span>, <span class="string token">'.to-selector'</span>);
</code></pre>
<p>或者，可以在单一方向上拖动元素：</p>
<pre><code><span class="variable token">$browser</span>-&gt;dragLeft(<span class="string token">'.selector'</span>, <span class="variable token">$pixels</span> = <span class="number token">10</span>);
<span class="variable token">$browser</span>-&gt;dragRight(<span class="string token">'.selector'</span>, <span class="variable token">$pixels</span> = <span class="number token">10</span>);
<span class="variable token">$browser</span>-&gt;dragUp(<span class="string token">'.selector'</span>, <span class="variable token">$pixels</span> = <span class="number token">10</span>);
<span class="variable token">$browser</span>-&gt;dragDown(<span class="string token">'.selector'</span>, <span class="variable token">$pixels</span> = <span class="number token">10</span>);
</code></pre>
<p>最后，你可以将元素拖动给定的偏移量：</p>
<pre><code><span class="variable token">$browser</span>-&gt;dragOffset(<span class="string token">'.selector'</span>, <span class="variable token">$x</span> = <span class="number token">10</span>, <span class="variable token">$y</span> = <span class="number token">10</span>);
</code></pre>
<p><a name="javascript-dialogs"></a></p>
<h3 id="javascript-对话框">JavaScript 对话框</h3>
<p>Dusk 提供了各种与 JavaScript 对话框进行交互的方法。例如，您可以使用 <code>waitForDialog</code> 方法来等待 JavaScript 对话框的出现。此方法接受一个可选参数，该参数指示等待对话框出现多少秒：</p>
<pre><code><span class="variable token">$browser</span>-&gt;waitForDialog(<span class="variable token">$seconds</span> = <span class="keyword token">null</span>);
</code></pre>
<p>该 <code>assertDialogOpened</code> 方法，断言对话框已经显示，并且其消息与给定值匹配：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertDialogOpened(<span class="string token">'Dialog message'</span>);
</code></pre>
<p><code>typeInDialog</code> 方法，在打开的 JavaScript 提示对话框中输入给定值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;typeInDialog(<span class="string token">'Hello World'</span>);
</code></pre>
<p><code>acceptDialog</code> 方法，通过点击确定按钮关闭打开的 JavaScript 对话框：</p>
<pre><code><span class="variable token">$browser</span>-&gt;acceptDialog();
</code></pre>
<p><code>dismissDialog</code> 方法，通过点击取消按钮关闭打开的 JavaScript 对话框（仅对确认对话框有效）：</p>
<pre><code><span class="variable token">$browser</span>-&gt;dismissDialog();
</code></pre>
<p><a name="scoping-selectors"></a></p>
<h3 id="选择器作用范围">选择器作用范围</h3>
<p>有时可能希望在给定的选择器范围内执行多个操作。比如，可能想要断言表格中存在某些文本，然后点击表格中的一个按钮。那么你可以使用 <code>with</code> 方法实现此需求。在传递给 <code>with</code> 方法的闭包内执行的所有操作都将限于原始选择器：</p>
<pre><code><span class="variable token">$browser</span>-&gt;with(<span class="string token">'.table'</span>, <span class="keyword token">function</span> (<span class="variable token">$table</span>) {
    <span class="variable token">$table</span>-&gt;assertSee(<span class="string token">'Hello World'</span>)
          -&gt;clickLink(<span class="string token">'Delete'</span>);
});
</code></pre>
<p>你可能偶尔需要在当前范围之外执行断言。 你可以使用 <code>elsewhere</code> 和 <code>elsewhereWhenAvailable</code> 方法来完成此操作：</p>
<pre><code> <span class="variable token">$browser</span>-&gt;with(<span class="string token">'.table'</span>, <span class="keyword token">function</span> (<span class="variable token">$table</span>) {
    <span class="comment token">// 当前范围是 `body .table`...</span>

    <span class="variable token">$browser</span>-&gt;elsewhere(<span class="string token">'.page-title'</span>, <span class="keyword token">function</span> (<span class="variable token">$title</span>) {
        <span class="comment token">// 当前范围是 `body .page-title`...</span>
        <span class="variable token">$title</span>-&gt;assertSee(<span class="string token">'Hello World'</span>);
    });

    <span class="variable token">$browser</span>-&gt;elsewhereWhenAvailable(<span class="string token">'.page-title'</span>, <span class="keyword token">function</span> (<span class="variable token">$title</span>) {
        <span class="comment token">// 当前范围是 `body .page-title`...</span>
        <span class="variable token">$title</span>-&gt;assertSee(<span class="string token">'Hello World'</span>);
    });
 });
</code></pre>
<p><a name="waiting-for-elements"></a></p>
<h3 id="等待元素">等待元素</h3>
<p>在测试大面积使用 JavaScript 的应用时，在进行测试之前，通常有必要 「等待」 某些元素或数据可用。Dusk 可轻松实现。使用一系列方法，可以等到页面元素可用，甚至给定的 JavaScript 表达式执行结果为 <code>true</code>。</p>
<p><a name="waiting"></a></p>
<h4 id="等待">等待</h4>
<p>如果需要测试暂停指定的毫秒数， 使用 <code>pause</code> 方法：</p>
<pre><code><span class="variable token">$browser</span>-&gt;pause(<span class="number token">1000</span>);
</code></pre>
<p><a name="waiting-for-selectors"></a></p>
<h4 id="等待选择器">等待选择器</h4>
<p>该 <code>waitFor</code> 方法可以用于暂停执行测试，直到页面上与给定 CSS 选择器匹配的元素被显示。默认情况下，将在暂停超过 5 秒后抛出异常。如有必要，可以传递自定义超时时长作为其第二个参数：</p>
<pre><code><span class="comment token">// 等待选择器不超过 5 秒...</span>
<span class="variable token">$browser</span>-&gt;waitFor(<span class="string token">'.selector'</span>);

<span class="comment token">// 等待选择器不超过 1 秒...</span>
<span class="variable token">$browser</span>-&gt;waitFor(<span class="string token">'.selector'</span>, <span class="number token">1</span>);
</code></pre>
<p>你也可以等待选择器显示给定文字：</p>
<pre><code><span class="comment token">//  等待选择器不超过 5 秒包含给定文字...</span>
<span class="variable token">$browser</span>-&gt;waitForTextIn(<span class="string token">'.selector'</span>, <span class="string token">'Hello World'</span>);

<span class="comment token">//  等待选择器不超过 1 秒包含给定文字...</span>
<span class="variable token">$browser</span>-&gt;waitForTextIn(<span class="string token">'.selector'</span>, <span class="string token">'Hello World'</span>, <span class="number token">1</span>);
</code></pre>
<p>你也可以等待指定选择器从页面消失:</p>
<pre><code><span class="comment token">// 等待不超过 5 秒 直到选择器消失...</span>
<span class="variable token">$browser</span>-&gt;waitUntilMissing(<span class="string token">'.selector'</span>);

<span class="comment token">// 等待不超过 1 秒 直到选择器消失...</span>
<span class="variable token">$browser</span>-&gt;waitUntilMissing(<span class="string token">'.selector'</span>, <span class="number token">1</span>);
</code></pre>
<p>或者，您可以等待与给定选择器匹配的元素被启用或禁用：</p>
<pre><code><span class="comment token">// 最多等待 5 秒钟，直到选择器启用...</span>
<span class="variable token">$browser</span>-&gt;waitUntilEnabled(<span class="string token">'.selector'</span>);

<span class="comment token">// 最多等待 1 秒钟，直到选择器启用...</span>
<span class="variable token">$browser</span>-&gt;waitUntilEnabled(<span class="string token">'.selector'</span>, <span class="number token">1</span>);

<span class="comment token">// 最多等待 5 秒钟，直到选择器被禁用...</span>
<span class="variable token">$browser</span>-&gt;waitUntilDisabled(<span class="string token">'.selector'</span>);

<span class="comment token">// 最多等待 1 秒钟，直到选择器被禁用...</span>
<span class="variable token">$browser</span>-&gt;waitUntilDisabled(<span class="string token">'.selector'</span>, <span class="number token">1</span>);
</code></pre>
<p><a name="scoping-selectors-when-available"></a></p>
<h4 id="限定作用域范围（可用时）">限定作用域范围（可用时）</h4>
<p>有时，你或许希望等待给定选择器出现，然后与匹配选择器的元素进行交互。例如，你可能希望等到模态窗口可用，然后在模态窗口中点击「确定」按钮。在这种情况下，可以使用 <code>whenAvailable</code> 方法。给定回调内的所有要执行的元素操作都将被限定在起始选择器上:</p>
<pre><code><span class="variable token">$browser</span>-&gt;whenAvailable(<span class="string token">'.modal'</span>, <span class="keyword token">function</span> (<span class="variable token">$modal</span>) {
    <span class="variable token">$modal</span>-&gt;assertSee(<span class="string token">'Hello World'</span>)
          -&gt;press(<span class="string token">'OK'</span>);
});
</code></pre>
<p><a name="waiting-for-text"></a></p>
<h4 id="等待文本">等待文本</h4>
<p>该 <code>waitForText</code> 方法可以用于等待页面上给定文字被显示：</p>
<pre><code><span class="comment token">// 等待指定文本不超过 5 秒...</span>
<span class="variable token">$browser</span>-&gt;waitForText(<span class="string token">'Hello World'</span>);

<span class="comment token">// 等待指定文本不超过 1 秒...</span>
<span class="variable token">$browser</span>-&gt;waitForText(<span class="string token">'Hello World'</span>, <span class="number token">1</span>);
</code></pre>
<p>你可以使用 <code>waitUntilMissingText</code> 方法来等待，直到显示的文本已从页面中删除为止:</p>
<pre><code><span class="comment token">// 最多等待 5 秒删除文本...</span>
<span class="variable token">$browser</span>-&gt;waitUntilMissingText(<span class="string token">'Hello World'</span>);

<span class="comment token">// 最多等待 1 秒删除文本...</span>
<span class="variable token">$browser</span>-&gt;waitUntilMissingText(<span class="string token">'Hello World'</span>, <span class="number token">1</span>);
</code></pre>
<p><a name="waiting-for-links"></a></p>
<h4 id="等待链接">等待链接</h4>
<p>该 <code>waitForLink</code> 方法用于等待给定链接文字在页面上显示:</p>
<pre><code><span class="comment token">// 等待链接最多 5 秒...</span>
<span class="variable token">$browser</span>-&gt;waitForLink(<span class="string token">'Create'</span>);

<span class="comment token">// 等待链接最多 1 秒...</span>
<span class="variable token">$browser</span>-&gt;waitForLink(<span class="string token">'Create'</span>, <span class="number token">1</span>);
</code></pre>
<p><a name="waiting-on-the-page-location"></a></p>
<h4 id="等待页面跳转">等待页面跳转</h4>
<p>当给出类似 <code>$browser-&gt;assertPathIs(&#39;/home&#39;)</code> 的路径断言时，如果 <code>window.location.pathname</code> 被异步更新，断言就会失败。可以使用 <code>waitForLocation</code> 方法等待页面跳转到给定路径：</p>
<pre><code><span class="variable token">$browser</span>-&gt;waitForLocation(<span class="string token">'/secret'</span>);
</code></pre>
<p>该 <code>waitForLocation</code> 方法还可用于等待当前窗口位置成为完全限定的 URL：</p>
<pre><code><span class="variable token">$browser</span>-&gt;waitForLocation(<span class="string token">'https://example.com/path'</span>);
</code></pre>
<p>还可以使用 <a href="routing.html#named-routes">被命名的路由</a> 等待跳转：</p>
<pre><code><span class="variable token">$browser</span>-&gt;waitForRoute(<span class="variable token">$routeName</span>, <span class="variable token">$parameters</span>);
</code></pre>
<p><a name="waiting-for-page-reloads"></a></p>
<h4 id="等待页面重新加载">等待页面重新加载</h4>
<p>如果要在页面重新加载后断言，可以使用 <code>waitForReload</code> 方法：</p>
<pre><code><span class="keyword token">use</span> Laravel\Dusk\Browser;

<span class="variable token">$browser</span>-&gt;waitForReload(<span class="keyword token">function</span> (Browser <span class="variable token">$browser</span>) {
    <span class="variable token">$browser</span>-&gt;press(<span class="string token">'Submit'</span>);
})
-&gt;assertSee(<span class="string token">'Success!'</span>);
</code></pre>
<p>由于需要等待页面重新加载通常发生在单击按钮之后，为了方便起见，您可以使用 <code>clickAndWaitForReload</code> 方法：</p>
<pre><code><span class="variable token">$browser</span>-&gt;clickAndWaitForReload(<span class="string token">'.selector'</span>)
        -&gt;assertSee(<span class="string token">'something'</span>);
</code></pre>
<p><a name="waiting-on-javascript-expressions"></a></p>
<h4 id="等待-javascript-表达式">等待 JavaScript 表达式</h4>
<p>有时候会希望暂停测试的执行，直到给定的 JavaScript 表达式执行结果为 <code>true</code>。可以使用 <code>waitUntil</code> 方法轻松地达成此目的。 通过这个方法执行表达式，不需要包含 <code>return</code> 关键字或者结束分号：</p>
<pre><code><span class="comment token">// 等待表达式为 true 5 秒时间...</span>
<span class="variable token">$browser</span>-&gt;waitUntil(<span class="string token">'App.data.servers.length &gt; 0'</span>);

<span class="comment token">// 等待表达式为 true 1 秒时间...</span>
<span class="variable token">$browser</span>-&gt;waitUntil(<span class="string token">'App.data.servers.length &gt; 0'</span>, <span class="number token">1</span>);
</code></pre>
<p><a name="waiting-on-vue-expressions"></a></p>
<h4 id="等待-vue-表达式">等待 Vue 表达式</h4>
<p>该 <code>waitUntilVue</code> 和 <code>waitUntilVueIsNot</code> 方法可以一直等待，直到 <a href="https://vuejs.org">Vue 组件</a> 的属性包含给定的值：</p>
<pre><code><span class="comment token">// 一直等待，直到组件属性包含给定的值...</span>
<span class="variable token">$browser</span>-&gt;waitUntilVue(<span class="string token">'user.name'</span>, <span class="string token">'Taylor'</span>, <span class="string token">'@user'</span>);

<span class="comment token">// 一直等待，直到组件属性不包含给定的值...</span>
<span class="variable token">$browser</span>-&gt;waitUntilVueIsNot(<span class="string token">'user.name'</span>, <span class="keyword token">null</span>, <span class="string token">'@user'</span>);
</code></pre>
<p><a name="waiting-with-a-callback"></a></p>
<h4 id="等待回调">等待回调</h4>
<p>Dusk 中的许多 「wait」 方法都依赖于底层方法 waitUsing。你可以直接用这个方法去等待一个回调函数返回 <code>waitUsing</code> 。你可以直接用这个方法去等待一个回调函数返回 <code>true</code>。该 <code>waitUsing</code> 方法接收一个最大的等待秒数，闭包执行间隔时间，闭包，以及一个可选的失败信息：</p>
<pre><code><span class="variable token">$browser</span>-&gt;waitUsing(<span class="number token">10</span>, <span class="number token">1</span>, <span class="keyword token">function</span> () <span class="keyword token">use</span> (<span class="variable token">$something</span>) {
    <span class="keyword token">return</span> <span class="variable token">$something</span>-&gt;isReady();
}, <span class="string token">"Something wasn't ready in time."</span>);
</code></pre>
<p><a name="scrolling-an-element-into-view"></a></p>
<h3 id="滚动元素到视图中">滚动元素到视图中</h3>
<p>有时您可能无法单击某个元素，因为该元素在浏览器的可见区域之外。该 <code>scrollIntoView</code> 方法可以将元素滚动到浏览器可视窗口内：</p>
<pre><code><span class="variable token">$browser</span>-&gt;scrollIntoView(<span class="string token">'.selector'</span>)
        -&gt;click(<span class="string token">'.selector'</span>);
</code></pre>
<p><a name="available-assertions"></a></p>
<h2 id="可用的断言">可用的断言</h2>
<p>Dusk 提供了各种你可以对应用使用的断言。所有可用的断言罗列如下：</p>
<style>
    .collection-method-list > p {
        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;
        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;
    }

    .collection-method-list a {
        display: block;
    }
</style>

<div class="collection-method-list" markdown="1">

<p><a href="#assert-title">assertTitle</a>
<a href="#assert-title-contains">assertTitleContains</a>
<a href="#assert-url-is">assertUrlIs</a>
<a href="#assert-scheme-is">assertSchemeIs</a>
<a href="#assert-scheme-is-not">assertSchemeIsNot</a>
<a href="#assert-host-is">assertHostIs</a>
<a href="#assert-host-is-not">assertHostIsNot</a>
<a href="#assert-port-is">assertPortIs</a>
<a href="#assert-port-is-not">assertPortIsNot</a>
<a href="#assert-path-begins-with">assertPathBeginsWith</a>
<a href="#assert-path-is">assertPathIs</a>
<a href="#assert-path-is-not">assertPathIsNot</a>
<a href="#assert-route-is">assertRouteIs</a>
<a href="#assert-query-string-has">assertQueryStringHas</a>
<a href="#assert-query-string-missing">assertQueryStringMissing</a>
<a href="#assert-fragment-is">assertFragmentIs</a>
<a href="#assert-fragment-begins-with">assertFragmentBeginsWith</a>
<a href="#assert-fragment-is-not">assertFragmentIsNot</a>
<a href="#assert-has-cookie">assertHasCookie</a>
<a href="#assert-has-plain-cookie">assertHasPlainCookie</a>
<a href="#assert-cookie-missing">assertCookieMissing</a>
<a href="#assert-plain-cookie-missing">assertPlainCookieMissing</a>
<a href="#assert-cookie-value">assertCookieValue</a>
<a href="#assert-plain-cookie-value">assertPlainCookieValue</a>
<a href="#assert-see">assertSee</a>
<a href="#assert-dont-see">assertDontSee</a>
<a href="#assert-see-in">assertSeeIn</a>
<a href="#assert-dont-see-in">assertDontSeeIn</a>
<a href="#assert-see-anything-in">assertSeeAnythingIn</a>
<a href="#assert-see-nothing-in">assertSeeNothingIn</a>
<a href="#assert-script">assertScript</a>
<a href="#assert-source-has">assertSourceHas</a>
<a href="#assert-source-missing">assertSourceMissing</a>
<a href="#assert-see-link">assertSeeLink</a>
<a href="#assert-dont-see-link">assertDontSeeLink</a>
<a href="#assert-input-value">assertInputValue</a>
<a href="#assert-input-value-is-not">assertInputValueIsNot</a>
<a href="#assert-checked">assertChecked</a>
<a href="#assert-not-checked">assertNotChecked</a>
<a href="#assert-radio-selected">assertRadioSelected</a>
<a href="#assert-radio-not-selected">assertRadioNotSelected</a>
<a href="#assert-selected">assertSelected</a>
<a href="#assert-not-selected">assertNotSelected</a>
<a href="#assert-select-has-options">assertSelectHasOptions</a>
<a href="#assert-select-missing-options">assertSelectMissingOptions</a>
<a href="#assert-select-has-option">assertSelectHasOption</a>
<a href="#assert-select-missing-option">assertSelectMissingOption</a>
<a href="#assert-value">assertValue</a>
<a href="#assert-value-is-not">assertValueIsNot</a>
<a href="#assert-attribute">assertAttribute</a>
<a href="#assert-attribute-contains">assertAttributeContains</a>
<a href="#assert-aria-attribute">assertAriaAttribute</a>
<a href="#assert-data-attribute">assertDataAttribute</a>
<a href="#assert-visible">assertVisible</a>
<a href="#assert-present">assertPresent</a>
<a href="#assert-not-present">assertNotPresent</a>
<a href="#assert-missing">assertMissing</a>
<a href="#assert-input-present">assertInputPresent</a>
<a href="#assert-input-missing">assertInputMissing</a>
<a href="#assert-dialog-opened">assertDialogOpened</a>
<a href="#assert-enabled">assertEnabled</a>
<a href="#assert-disabled">assertDisabled</a>
<a href="#assert-button-enabled">assertButtonEnabled</a>
<a href="#assert-button-disabled">assertButtonDisabled</a>
<a href="#assert-focused">assertFocused</a>
<a href="#assert-not-focused">assertNotFocused</a>
<a href="#assert-authenticated">assertAuthenticated</a>
<a href="#assert-guest">assertGuest</a>
<a href="#assert-authenticated-as">assertAuthenticatedAs</a>
<a href="#assert-vue">assertVue</a>
<a href="#assert-vue-is-not">assertVueIsNot</a>
<a href="#assert-vue-contains">assertVueContains</a>
<a href="#assert-vue-does-not-contain">assertVueDoesNotContain</a></p>
</div>



<p><a name="assert-title"></a></p>
<h4 id="asserttitle">assertTitle</h4>
<p>断言页面标题为给定文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertTitle(<span class="variable token">$title</span>);
</code></pre>
<p><a name="assert-title-contains"></a></p>
<h4 id="asserttitlecontains">assertTitleContains</h4>
<p>断言页面标题包含给定文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertTitleContains(<span class="variable token">$title</span>);
</code></pre>
<p><a name="assert-url-is"></a></p>
<h4 id="asserturlis">assertUrlIs</h4>
<p>断言当前的 URL（不包含 query string）是给定的字符串：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertUrlIs(<span class="variable token">$url</span>);
</code></pre>
<p><a name="assert-scheme-is"></a></p>
<h4 id="assertschemeis">assertSchemeIs</h4>
<p>断言当前的 URL scheme 是给定的 scheme：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSchemeIs(<span class="variable token">$scheme</span>);
</code></pre>
<p><a name="assert-scheme-is-not"></a></p>
<h4 id="assertschemeisnot">assertSchemeIsNot</h4>
<p>断言当前的 URL scheme 不是给定的 scheme：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSchemeIsNot(<span class="variable token">$scheme</span>);
</code></pre>
<p><a name="assert-host-is"></a></p>
<h4 id="asserthostis">assertHostIs</h4>
<p>断言当前的 URL host 是给定的 host：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertHostIs(<span class="variable token">$host</span>);
</code></pre>
<p><a name="assert-host-is-not"></a></p>
<h4 id="asserthostisnot">assertHostIsNot</h4>
<p>断言当前的 URL host 不是给定的 host：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertHostIsNot(<span class="variable token">$host</span>);
</code></pre>
<p><a name="assert-port-is"></a></p>
<h4 id="assertportis">assertPortIs</h4>
<p>断言当前的 URL 端口是给定的端口：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertPortIs(<span class="variable token">$port</span>);
</code></pre>
<p><a name="assert-port-is-not"></a></p>
<h4 id="assertportisnot">assertPortIsNot</h4>
<p>断言当前的 URL 端口不是给定的端口：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertPortIsNot(<span class="variable token">$port</span>);
</code></pre>
<p><a name="assert-path-begins-with"></a></p>
<h4 id="assertpathbeginswith">assertPathBeginsWith</h4>
<p>断言当前的 URL 路径以给定的路径开始：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertPathBeginsWith(<span class="string token">'/home'</span>);
</code></pre>
<p><a name="assert-path-is"></a></p>
<h4 id="assertpathis">assertPathIs</h4>
<p>断言当前的路径是给定的路径：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertPathIs(<span class="string token">'/home'</span>);
</code></pre>
<p><a name="assert-path-is-not"></a></p>
<h4 id="assertpathisnot">assertPathIsNot</h4>
<p>断言当前的路径不是给定的路径：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertPathIsNot(<span class="string token">'/home'</span>);
</code></pre>
<p><a name="assert-route-is"></a></p>
<h4 id="assertrouteis">assertRouteIs</h4>
<p>断言给定的 URL 是给定的 <a href="routing.html#named-routes">命名路由</a> 的 URL:</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertRouteIs(<span class="variable token">$name</span>, <span class="variable token">$parameters</span>);
</code></pre>
<p><a name="assert-query-string-has"></a></p>
<h4 id="assertquerystringhas">assertQueryStringHas</h4>
<p>断言给定的查询字符串参数存在：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertQueryStringHas(<span class="variable token">$name</span>);
</code></pre>
<p>断言给定的查询字符串参数存在并且具有给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertQueryStringHas(<span class="variable token">$name</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-query-string-missing"></a></p>
<h4 id="assertquerystringmissing">assertQueryStringMissing</h4>
<p>断言缺少给定的查询字符串参数：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertQueryStringMissing(<span class="variable token">$name</span>);
</code></pre>
<p><a name="assert-fragment-is"></a></p>
<h4 id="assertfragmentis">assertFragmentIs</h4>
<p>断言 URL 的当前哈希片段与给定的片段匹配：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertFragmentIs(<span class="string token">'anchor'</span>);
</code></pre>
<p><a name="assert-fragment-begins-with"></a></p>
<h4 id="assertfragmentbeginswith">assertFragmentBeginsWith</h4>
<p>断言 URL 的当前哈希片段以给定片段开头：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertFragmentBeginsWith(<span class="string token">'anchor'</span>);
</code></pre>
<p><a name="assert-fragment-is-not"></a></p>
<h4 id="assertfragmentisnot">assertFragmentIsNot</h4>
<p>断言 URL 的当前哈希片段与给定的片段不匹配：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertFragmentIsNot(<span class="string token">'anchor'</span>);
</code></pre>
<p><a name="assert-has-cookie"></a></p>
<h4 id="asserthascookie">assertHasCookie</h4>
<p>断言给定的加密 cookie 存在：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertHasCookie(<span class="variable token">$name</span>);
</code></pre>
<p><a name="assert-has-plain-cookie"></a></p>
<h4 id="asserthasplaincookie">assertHasPlainCookie</h4>
<p>断言给定的未加密 cookie 存在：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertHasPlainCookie(<span class="variable token">$name</span>);
</code></pre>
<p><a name="assert-cookie-missing"></a></p>
<h4 id="assertcookiemissing">assertCookieMissing</h4>
<p>断言给定的加密 cookie 不存在：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertCookieMissing(<span class="variable token">$name</span>);
</code></pre>
<p><a name="assert-plain-cookie-missing"></a></p>
<h4 id="assertplaincookiemissing">assertPlainCookieMissing</h4>
<p>断言给定的未加密 cookie 不存在：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertPlainCookieMissing(<span class="variable token">$name</span>);
</code></pre>
<p><a name="assert-cookie-value"></a></p>
<h4 id="assertcookievalue">assertCookieValue</h4>
<p>断言加密的 cookie 具有给定值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertCookieValue(<span class="variable token">$name</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-plain-cookie-value"></a></p>
<h4 id="assertplaincookievalue">assertPlainCookieValue</h4>
<p>断言未加密的 cookie 具有给定值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertPlainCookieValue(<span class="variable token">$name</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-see"></a></p>
<h4 id="assertsee">assertSee</h4>
<p>断言在页面中有给定的文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSee(<span class="variable token">$text</span>);
</code></pre>
<p><a name="assert-dont-see"></a></p>
<h4 id="assertdontsee">assertDontSee</h4>
<p>断言在页面中没有给定的文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertDontSee(<span class="variable token">$text</span>);
</code></pre>
<p><a name="assert-see-in"></a></p>
<h4 id="assertseein">assertSeeIn</h4>
<p>断言在选择器中有给定的文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSeeIn(<span class="variable token">$selector</span>, <span class="variable token">$text</span>);
</code></pre>
<p><a name="assert-dont-see-in"></a></p>
<h4 id="assertdontseein">assertDontSeeIn</h4>
<p>断言在选择器中不存在给定的文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertDontSeeIn(<span class="variable token">$selector</span>, <span class="variable token">$text</span>);
</code></pre>
<p><a name="assert-see-anything-in"></a></p>
<h4 id="assertseeanythingin">assertSeeAnythingIn</h4>
<p>断言在选择器中存在任意的文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSeeAnythingIn(<span class="variable token">$selector</span>);
</code></pre>
<p><a name="assert-see-nothing-in"></a></p>
<h4 id="assertseenothingin">assertSeeNothingIn</h4>
<p>断言在选择器中不存在文本：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSeeNothingIn(<span class="variable token">$selector</span>);
</code></pre>
<p><a name="assert-script"></a></p>
<h4 id="assertscript">assertScript</h4>
<p>断言给定的 JavaScript 表达式结果为给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertScript(<span class="string token">'window.isLoaded'</span>)
        -&gt;assertScript(<span class="string token">'document.readyState'</span>, <span class="string token">'complete'</span>);
</code></pre>
<p><a name="assert-source-has"></a></p>
<h4 id="assertsourcehas">assertSourceHas</h4>
<p>断言在页面中存在给定的源码：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSourceHas(<span class="variable token">$code</span>);
</code></pre>
<p><a name="assert-source-missing"></a></p>
<h4 id="assertsourcemissing">assertSourceMissing</h4>
<p>断言页面中没有给定的源码：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSourceMissing(<span class="variable token">$code</span>);
</code></pre>
<p><a name="assert-see-link"></a></p>
<h4 id="assertseelink">assertSeeLink</h4>
<p>断言在页面中存在指定的链接：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSeeLink(<span class="variable token">$linkText</span>);
</code></pre>
<p><a name="assert-dont-see-link"></a></p>
<h4 id="assertdontseelink">assertDontSeeLink</h4>
<p>断言页面中没有指定的链接：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertDontSeeLink(<span class="variable token">$linkText</span>);
</code></pre>
<p><a name="assert-input-value"></a></p>
<h4 id="assertinputvalue">assertInputValue</h4>
<p>断言输入框（input）有给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertInputValue(<span class="variable token">$field</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-input-value-is-not"></a></p>
<h4 id="assertinputvalueisnot">assertInputValueIsNot</h4>
<p>断言输入框没有给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertInputValueIsNot(<span class="variable token">$field</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-checked"></a></p>
<h4 id="assertchecked">assertChecked</h4>
<p>断言复选框（checkbox）被选中：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertChecked(<span class="variable token">$field</span>);
</code></pre>
<p><a name="assert-not-checked"></a></p>
<h4 id="assertnotchecked">assertNotChecked</h4>
<p>断言复选框没有被选中：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertNotChecked(<span class="variable token">$field</span>);
</code></pre>
<p><a name="assert-radio-selected"></a></p>
<h4 id="assertradioselected">assertRadioSelected</h4>
<p>断言单选框（radio）被选中：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertRadioSelected(<span class="variable token">$field</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-radio-not-selected"></a></p>
<h4 id="assertradionotselected">assertRadioNotSelected</h4>
<p>断言单选框（radio）没有被选中：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertRadioNotSelected(<span class="variable token">$field</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-selected"></a></p>
<h4 id="assertselected">assertSelected</h4>
<p>断言下拉框有给定的值:</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSelected(<span class="variable token">$field</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-not-selected"></a></p>
<h4 id="assertnotselected">assertNotSelected</h4>
<p>断言下拉框没有给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertNotSelected(<span class="variable token">$field</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-select-has-options"></a></p>
<h4 id="assertselecthasoptions">assertSelectHasOptions</h4>
<p>断言给定的数组值是可选的：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSelectHasOptions(<span class="variable token">$field</span>, <span class="variable token">$values</span>);
</code></pre>
<p><a name="assert-select-missing-options"></a></p>
<h4 id="assertselectmissingoptions">assertSelectMissingOptions</h4>
<p>断言给定的数组值是不可选的：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSelectMissingOptions(<span class="variable token">$field</span>, <span class="variable token">$values</span>);
</code></pre>
<p><a name="assert-select-has-option"></a></p>
<h4 id="assertselecthasoption">assertSelectHasOption</h4>
<p>断言给定的值在给定的地方是可供选择的：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSelectHasOption(<span class="variable token">$field</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-select-missing-option"></a></p>
<h4 id="assertselectmissingoption">assertSelectMissingOption</h4>
<p>断言给定的值不可选：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertSelectMissingOption(<span class="variable token">$field</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-value"></a></p>
<h4 id="assertvalue">assertValue</h4>
<p>断言选择器范围内的元素存在指定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertValue(<span class="variable token">$selector</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-value-is-not"></a></p>
<h4 id="assertvalueisnot">assertValueIsNot</h4>
<p>断言选择器范围内的元素不存在指定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertValueIsNot(<span class="variable token">$selector</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-attribute"></a></p>
<h4 id="assertattribute">assertAttribute</h4>
<p>断言与给定选择器匹配的元素在提供的属性中具有给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertAttribute(<span class="variable token">$selector</span>, <span class="variable token">$attribute</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-attribute-contains"></a></p>
<h4 id="assertattributecontains">assertAttributeContains</h4>
<p>断言匹配给定选择器的元素在提供的属性中包含给定值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertAttributeContains(<span class="variable token">$selector</span>, <span class="variable token">$attribute</span>, <span class="variable token">$value</span>);
</code></pre>
<p><a name="assert-aria-attribute"></a></p>
<h4 id="assertariaattribute">assertAriaAttribute</h4>
<p>断言与给定选择器匹配的元素在给定的 aria 属性中具有给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertAriaAttribute(<span class="variable token">$selector</span>, <span class="variable token">$attribute</span>, <span class="variable token">$value</span>);
</code></pre>
<p>例如，给定标记 <code>&lt;button aria-label=&quot;Add&quot;&gt;&lt;/button&gt;</code>，您可以像这样声明 <code>aria-label</code> 属性：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertAriaAttribute(<span class="string token">'button'</span>, <span class="string token">'label'</span>, <span class="string token">'Add'</span>)
</code></pre>
<p><a name="assert-data-attribute"></a></p>
<h4 id="assertdataattribute">assertDataAttribute</h4>
<p>断言与给定选择器匹配的元素在提供的 data 属性中具有给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertDataAttribute(<span class="variable token">$selector</span>, <span class="variable token">$attribute</span>, <span class="variable token">$value</span>);
</code></pre>
<p>例如，给定标记 <code>&lt;tr id=&quot;row-1&quot; data-content=&quot;attendees&quot;&gt;&lt;/tr&gt;</code>，您可以像这样断言 <code>data-label</code> 属性：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertDataAttribute(<span class="string token">'#row-1'</span>, <span class="string token">'content'</span>, <span class="string token">'attendees'</span>)
</code></pre>
<p><a name="assert-visible"></a></p>
<h4 id="assertvisible">assertVisible</h4>
<p>断言匹配给定选择器的元素可见:</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertVisible(<span class="variable token">$selector</span>);
</code></pre>
<p><a name="assert-present"></a></p>
<h4 id="assertpresent">assertPresent</h4>
<p>断言匹配给定选择器的元素存在：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertPresent(<span class="variable token">$selector</span>);
</code></pre>
<p><a name="assert-not-present"></a></p>
<h4 id="assertnotpresent">assertNotPresent</h4>
<p>断言源中不存在与给定选择器匹配的元素：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertNotPresent(<span class="variable token">$selector</span>);
</code></pre>
<p><a name="assert-missing"></a></p>
<h4 id="assertmissing">assertMissing</h4>
<p>断言匹配给定选择器的元素不可见：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertMissing(<span class="variable token">$selector</span>);
</code></pre>
<p><a name="assert-input-present"></a></p>
<h4 id="assertinputpresent">assertInputPresent</h4>
<p>断言具有给定名称的输入存在：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertInputPresent(<span class="variable token">$name</span>);
</code></pre>
<p><a name="assert-input-missing"></a></p>
<h4 id="assertinputmissing">assertInputMissing</h4>
<p>断言源中不存在具有给定名称的输入：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertInputMissing(<span class="variable token">$name</span>);
</code></pre>
<p><a name="assert-dialog-opened"></a></p>
<h4 id="assertdialogopened">assertDialogOpened</h4>
<p>断言已打开带有给定消息的 JavaScript 对话框：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertDialogOpened(<span class="variable token">$message</span>);
</code></pre>
<p><a name="assert-enabled"></a></p>
<h4 id="assertenabled">assertEnabled</h4>
<p>断言给定的字段已启用：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertEnabled(<span class="variable token">$field</span>);
</code></pre>
<p><a name="assert-disabled"></a></p>
<h4 id="assertdisabled">assertDisabled</h4>
<p>断言给定的字段被禁用：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertDisabled(<span class="variable token">$field</span>);
</code></pre>
<p><a name="assert-button-enabled"></a></p>
<h4 id="assertbuttonenabled">assertButtonEnabled</h4>
<p>断言给定的按钮已启用：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertButtonEnabled(<span class="variable token">$button</span>);
</code></pre>
<p><a name="assert-button-disabled"></a></p>
<h4 id="assertbuttondisabled">assertButtonDisabled</h4>
<p>断言给定的按钮被禁用：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertButtonDisabled(<span class="variable token">$button</span>);
</code></pre>
<p><a name="assert-focused"></a></p>
<h4 id="assertfocused">assertFocused</h4>
<p>断言给定的字段是焦点：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertFocused(<span class="variable token">$field</span>);
</code></pre>
<p><a name="assert-not-focused"></a></p>
<h4 id="assertnotfocused">assertNotFocused</h4>
<p>断言给定字段未聚焦：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertNotFocused(<span class="variable token">$field</span>);
</code></pre>
<p><a name="assert-authenticated"></a></p>
<h4 id="assertauthenticated">assertAuthenticated</h4>
<p>断言用户已通过身份验证：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertAuthenticated();
</code></pre>
<p><a name="assert-guest"></a></p>
<h4 id="assertguest">assertGuest</h4>
<p>断言用户未通过身份验证：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertGuest();
</code></pre>
<p><a name="assert-authenticated-as"></a></p>
<h4 id="assertauthenticatedas">assertAuthenticatedAs</h4>
<p>断言用户已作为给定用户进行身份验证：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertAuthenticatedAs(<span class="variable token">$user</span>);
</code></pre>
<p><a name="assert-vue"></a></p>
<h4 id="assertvue">assertVue</h4>
<p>Dusk 甚至允许您对 <a href="https://vuejs.org">Vue 组件</a> 数据的状态进行断言。例如，假设您的应用程序包含以下 Vue 组件：</p>
<pre><code><span class="comment token">// HTML...</span>

&lt;profile dusk=<span class="string token">"profile-component"</span>&gt;&lt;/profile&gt;

<span class="comment token">// 组件定义...</span>

Vue.component(<span class="string token">'profile'</span>, {
    template: <span class="string token">'&lt;div&gt;{{ user.name }}&lt;/div&gt;'</span>,

    data: <span class="keyword token">function</span> () {
        <span class="keyword token">return</span> {
            user: {
                name: <span class="string token">'Taylor'</span>
            }
        };
    }
});
</code></pre>
<p>你可以像这样断言 Vue 组件的状态：</p>
<pre><code><span class="comment token">/**
 * 一个基本的 Vue 测试示例
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> testVue()
{
    <span class="variable token">$this</span>-&gt;browse(<span class="keyword token">function</span> (Browser <span class="variable token">$browser</span>) {
        <span class="variable token">$browser</span>-&gt;visit(<span class="string token">'/'</span>)
                -&gt;assertVue(<span class="string token">'user.name'</span>, <span class="string token">'Taylor'</span>, <span class="string token">'@profile-component'</span>);
    });
}
</code></pre>
<p><a name="assert-vue-is-not"></a></p>
<h4 id="assertvueisnot">assertVueIsNot</h4>
<p>断言 Vue 组件数据的属性不匹配给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertVueIsNot(<span class="variable token">$property</span>, <span class="variable token">$value</span>, <span class="variable token">$componentSelector</span> = <span class="keyword token">null</span>);
</code></pre>
<p><a name="assert-vue-contains"></a></p>
<h4 id="assertvuecontains">assertVueContains</h4>
<p>断言 Vue 组件数据的属性是一个数组，并包含给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertVueContains(<span class="variable token">$property</span>, <span class="variable token">$value</span>, <span class="variable token">$componentSelector</span> = <span class="keyword token">null</span>);
</code></pre>
<p><a name="assert-vue-does-not-contain"></a></p>
<h4 id="assertvuedoesnotcontain">assertVueDoesNotContain</h4>
<p>断言 Vue 组件数据的属性是一个数组，且不包含给定的值：</p>
<pre><code><span class="variable token">$browser</span>-&gt;assertVueDoesNotContain(<span class="variable token">$property</span>, <span class="variable token">$value</span>, <span class="variable token">$componentSelector</span> = <span class="keyword token">null</span>);
</code></pre>
<p><a name="pages"></a></p>
<h2 id="pages">Pages</h2>
<p>有时，测试需要按顺序执行几个复杂的操作。这会使测试代码更难阅读和理解。 Dusk Pages 允许您定义语义化的操作，然后可以通过单一方法在给定页面上执行这些操作。Pages 还可以为应用或单个页面定义通用选择器的快捷方式。</p>
<p><a name="generating-pages"></a></p>
<h3 id="生成-pages">生成 Pages</h3>
<p><code>dusk:page</code> Artisan 命令可以生成页面对象。所有的页面对象都位于 <code>tests/Browser/Pages</code> 目录：</p>
<pre><code>php artisan dusk:page Login
</code></pre>
<p><a name="configuring-pages"></a></p>
<h3 id="配置-pages">配置 Pages</h3>
<p>默认情况下，页面具有三种方法：<code>url</code>、<code>assert</code> 和 <code>elements</code>。我们现在将讨论 <code>url</code> 和 <code>assert</code> 方法。 <code>elements</code> 方法将 <a href="#shorthand-selectors">在下面更详细地讨论</a>。</p>
<p><a name="the-url-method"></a></p>
<h4 id="url-方法"><code>url</code> 方法</h4>
<p><code>url</code> 方法应该返回表示页面 URL 的路径。 Dusk 将会在浏览器中使用这个 URL 来导航到具体页面：</p>
<pre><code><span class="comment token">/**
 * 获取页面的 URL。
 *
 *<span class="phpdoc token"> @return</span> string
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> url()
{
    <span class="keyword token">return</span> <span class="string token">'/login'</span>;
}
</code></pre>
<p><a name="the-assert-method"></a></p>
<h4 id="assert-方法"><code>assert</code> 方法</h4>
<p><code>assert</code> 方法可以作出任何断言来验证浏览器是否在指定页面上。实际上没有必要在这个方法中放置任何东西；但是，你可以按自己的需求来做出这些断言。导航到页面时，这些断言将自动运行：</p>
<pre><code><span class="comment token">/**
 * 断言浏览器当前处于指定页面。
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> assert(Browser <span class="variable token">$browser</span>)
{
    <span class="variable token">$browser</span>-&gt;assertPathIs(<span class="variable token">$this</span>-&gt;url());
}
</code></pre>
<p><a name="navigating-to-pages"></a></p>
<h3 id="导航至页面">导航至页面</h3>
<p>一旦页面定义好之后，你可以使用 <code>visit</code> 方法导航至页面：</p>
<pre><code><span class="keyword token">use</span> Tests\Browser\Pages\Login;

<span class="variable token">$browser</span>-&gt;visit(<span class="keyword token">new</span> Login);
</code></pre>
<p>有时您可能已经在给定的页面上，需要将页面的选择器和方法「加载」到当前的测试上下文中。 这在通过按钮重定向到指定页面而没有明确导航到该页面时很常见。 在这种情况下，您可以使用 <code>on</code> 方法加载页面：</p>
<pre><code><span class="keyword token">use</span> Tests\Browser\Pages\CreatePlaylist;

<span class="variable token">$browser</span>-&gt;visit(<span class="string token">'/dashboard'</span>)
        -&gt;clickLink(<span class="string token">'Create Playlist'</span>)
        -&gt;on(<span class="keyword token">new</span> CreatePlaylist)
        -&gt;assertSee(<span class="string token">'@create'</span>);
</code></pre>
<p><a name="shorthand-selectors"></a></p>
<h3 id="选择器简写">选择器简写</h3>
<p>该 <code>elements</code> 方法允许你为页面中的任何 CSS 选择器定义简单易记的简写。例如，让我们为应用登录页中的 email 输入框定义一个简写：</p>
<pre><code><span class="comment token">/**
 * 获取页面元素的简写
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> elements()
{
    <span class="keyword token">return</span> [
        <span class="string token">'@email'</span> =&gt; <span class="string token">'input[name=email]'</span>,
    ];
}
</code></pre>
<p>一旦定义了简写，你就可以用这个简写来代替之前在页面中使用的完整 CSS 选择器：</p>
<pre><code><span class="variable token">$browser</span>-&gt;type(<span class="string token">'@email'</span>, <span class="string token">'taylor@laravel.com'</span>);
</code></pre>
<p><a name="global-shorthand-selectors"></a></p>
<h4 id="全局的选择器简写">全局的选择器简写</h4>
<p>安装 Dusk 之后， <code>Page</code> 基类存放在你的 <code>tests/Browser/Pages</code> 目录。该类中包含一个 <code>siteElements</code> 方法，这个方法可以用来定义全局的选择器简写，这样在你应用中每个页面都可以使用这些全局选择器简写了：</p>
<pre><code><span class="comment token">/**
 * 获取站点全局的选择器简写。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">static</span> <span class="keyword token">function</span> siteElements()
{
    <span class="keyword token">return</span> [
        <span class="string token">'@element'</span> =&gt; <span class="string token">'#selector'</span>,
    ];
}
</code></pre>
<p><a name="page-methods"></a></p>
<h3 id="页面方法">页面方法</h3>
<p>除了页面中已经定义的默认方法之外，你还可以定义在整个测试过程中会使用到的其他方法。例如，假设我们正在开发一个音乐管理应用，在应用中每个页面都可能需要一个公共的方法来创建播放列表，而不是在每一个测试类中都重写一遍创建播放列表的逻辑，这时候你可以在你的页面类中定义一个  <code>createPlaylist</code>方法：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> Tests\Browser\Pages;

<span class="keyword token">use</span> Laravel\Dusk\Browser;

<span class="keyword token">class</span> Dashboard <span class="keyword token">extends</span> Page
{
    <span class="comment token">// 其他页面方法...</span>

    <span class="comment token">/**
     * 创建一个新的播放列表
     *
     *<span class="phpdoc token"> @param</span>  \Laravel\Dusk\Browser  $browser
     *<span class="phpdoc token"> @param</span>  string  $name
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> createPlaylist(Browser <span class="variable token">$browser</span>, <span class="variable token">$name</span>)
    {
        <span class="variable token">$browser</span>-&gt;type(<span class="string token">'name'</span>, <span class="variable token">$name</span>)
                -&gt;check(<span class="string token">'share'</span>)
                -&gt;press(<span class="string token">'Create Playlist'</span>);
    }
}
</code></pre>
<p>方法被定义之后，你可以在任何使用到该页的测试中使用它了。浏览器实例会自动作为第一个参数传递给自定义页面方法：</p>
<pre><code><span class="keyword token">use</span> Tests\Browser\Pages\Dashboard;

<span class="variable token">$browser</span>-&gt;visit(<span class="keyword token">new</span> Dashboard)
        -&gt;createPlaylist(<span class="string token">'My Playlist'</span>)
        -&gt;assertSee(<span class="string token">'My Playlist'</span>);
</code></pre>
<p><a name="components"></a></p>
<h2 id="组件">组件</h2>
<p>组件类似于 Dusk 的 「页面对象」，不过它更多的是贯穿整个应用程序中频繁重用的 UI 和功能片断，比如说导航条或信息通知弹窗。因此，组件并不会绑定于某个明确的 URL。</p>
<p><a name="generating-components"></a></p>
<h3 id="生成组件">生成组件</h3>
<p>使用 <code>dusk:component</code> Artisan 命令即可生成组件。新生成的组件位于 <code>tests/Browser/Components</code> 目录下：</p>
<pre><code>php artisan dusk:component DatePicker
</code></pre>
<p>如上所示，这是生成一个 「日期选择器」（date picker） 组件的示例，这个组件可能会贯穿使用在你应用程序的许多页面中。在整个测试套件的大量测试页面中，手动编写日期选择的浏览器自动化逻辑会非常麻烦。 更方便的替代办法是，定义一个表示日期选择器的 Dusk 组件，然后把自动化逻辑封装在该组件内：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> Tests\Browser\Components;

<span class="keyword token">use</span> Laravel\Dusk\Browser;
<span class="keyword token">use</span> Laravel\Dusk\Component <span class="keyword token">as</span> BaseComponent;

<span class="keyword token">class</span> DatePicker <span class="keyword token">extends</span> BaseComponent
{
    <span class="comment token">/**
     * 获取组件的 root selector。
     *
     *<span class="phpdoc token"> @return</span> string
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> selector()
    {
        <span class="keyword token">return</span> <span class="string token">'.date-picker'</span>;
    }

    <span class="comment token">/**
     * 断言浏览器包含组件。
     *
     *<span class="phpdoc token"> @param</span>  Browser  $browser
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> assert(Browser <span class="variable token">$browser</span>)
    {
        <span class="variable token">$browser</span>-&gt;assertVisible(<span class="variable token">$this</span>-&gt;selector());
    }

    <span class="comment token">/**
     * 读取组件的元素简写。
     *
     *<span class="phpdoc token"> @return</span> array
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> elements()
    {
        <span class="keyword token">return</span> [
            <span class="string token">'@date-field'</span> =&gt; <span class="string token">'input.datepicker-input'</span>,
            <span class="string token">'@year-list'</span> =&gt; <span class="string token">'div &gt; div.datepicker-years'</span>,
            <span class="string token">'@month-list'</span> =&gt; <span class="string token">'div &gt; div.datepicker-months'</span>,
            <span class="string token">'@day-list'</span> =&gt; <span class="string token">'div &gt; div.datepicker-days'</span>,
        ];
    }

    <span class="comment token">/**
     * 选择给定日期。
     *
     *<span class="phpdoc token"> @param</span>  \Laravel\Dusk\Browser  $browser
     *<span class="phpdoc token"> @param</span>  int  $year
     *<span class="phpdoc token"> @param</span>  int  $month
     *<span class="phpdoc token"> @param</span>  int  $day
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> selectDate(Browser <span class="variable token">$browser</span>, <span class="variable token">$year</span>, <span class="variable token">$month</span>, <span class="variable token">$day</span>)
    {
        <span class="variable token">$browser</span>-&gt;click(<span class="string token">'@date-field'</span>)
                -&gt;within(<span class="string token">'@year-list'</span>, <span class="keyword token">function</span> (<span class="variable token">$browser</span>) <span class="keyword token">use</span> (<span class="variable token">$year</span>) {
                    <span class="variable token">$browser</span>-&gt;click(<span class="variable token">$year</span>);
                })
                -&gt;within(<span class="string token">'@month-list'</span>, <span class="keyword token">function</span> (<span class="variable token">$browser</span>) <span class="keyword token">use</span> (<span class="variable token">$month</span>) {
                    <span class="variable token">$browser</span>-&gt;click(<span class="variable token">$month</span>);
                })
                -&gt;within(<span class="string token">'@day-list'</span>, <span class="keyword token">function</span> (<span class="variable token">$browser</span>) <span class="keyword token">use</span> (<span class="variable token">$day</span>) {
                    <span class="variable token">$browser</span>-&gt;click(<span class="variable token">$day</span>);
                });
    }
}
</code></pre>
<p><a name="using-components"></a></p>
<h3 id="使用组件">使用组件</h3>
<p>一旦定义了组件，在任何测试页面的日期选择器中选定一个日期就很轻松了。并且，如果需要修改选定日期的逻辑，仅修改该组件即可：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> Tests\Browser;

<span class="keyword token">use</span> Illuminate\Foundation\Testing\DatabaseMigrations;
<span class="keyword token">use</span> Laravel\Dusk\Browser;
<span class="keyword token">use</span> Tests\Browser\Components\DatePicker;
<span class="keyword token">use</span> Tests\DuskTestCase;

<span class="keyword token">class</span> ExampleTest <span class="keyword token">extends</span> DuskTestCase
{
    <span class="comment token">/**
     * 基本的组件测试示例。
     *
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> testBasicExample()
    {
        <span class="variable token">$this</span>-&gt;browse(<span class="keyword token">function</span> (Browser <span class="variable token">$browser</span>) {
            <span class="variable token">$browser</span>-&gt;visit(<span class="string token">'/'</span>)
                    -&gt;within(<span class="keyword token">new</span> DatePicker, <span class="keyword token">function</span> (<span class="variable token">$browser</span>) {
                        <span class="variable token">$browser</span>-&gt;selectDate(<span class="number token">2019</span>, <span class="number token">1</span>, <span class="number token">30</span>);
                    })
                    -&gt;assertSee(<span class="string token">'January'</span>);
        });
    }
}
</code></pre>
<p><a name="continuous-integration"></a></p>
<h2 id="持续集成">持续集成</h2>
<blockquote>
<p>注意：大多数 Dusk 持续集成配置都希望您的 Laravel 应用程序使用端口 8000 上的内置 PHP 开发服务器提供服务。因此，您应该确保您的持续集成环境有一个 <code>APP_URL</code> 境变量，值为 <code>http://127.0.0.1:8000</code>。</p>
</blockquote>
<p><a name="running-tests-on-heroku-ci"></a></p>
<h3 id="heroku-ci">Heroku CI</h3>
<p>要在 <a href="https://www.heroku.com/continuous-integration">Heroku CI</a> 运行 Dusk 测试，请将以下 Google Chrome buildpack 和 脚本添加到 Heroku 的 <code>app.json</code> 文件中：</p>
<pre><code>{
  "environments": {
    "test": {
      "buildpacks": [
        { "url": "heroku/php" },
        { "url": "https://github.com/heroku/heroku-buildpack-google-chrome" }
      ],
      "scripts": {
        "test-setup": "cp .env.testing .env",
        "test": "nohup bash -c './vendor/laravel/dusk/bin/chromedriver-linux &gt; /dev/null 2&gt;&amp;1 &amp;' &amp;&amp; nohup bash -c 'php artisan serve --no-reload &gt; /dev/null 2&gt;&amp;1 &amp;' &amp;&amp; php artisan dusk"
      }
    }
  }
}
</code></pre>
<p><a name="running-tests-on-travis-ci"></a></p>
<h3 id="travis-ci">Travis CI</h3>
<p>要在 <a href="https://travis-ci.org/">Travis CI</a> 运行 Dusk 测试，可以使用下面这个 <code>.travis.yml</code> 配置。由于 Travis CI 不是一个图形化的环境，我们还需要一些额外的步骤以便启动 Chrome 浏览器。此外，我们将会使用 <code>php artisan serve</code> 来启动 PHP 自带的 Web 服务器：</p>
<pre><code class="language-yaml">language: php

php:
  - <span class="number token">7.3</span>

addons:
  chrome: stable

install:
  - cp .env.testing .env
  - travis_retry composer install --no-interaction --prefer-dist
  - php artisan key:generate
  - php artisan dusk:chrome-driver

before_script:
  - google-chrome-stable --headless --disable-gpu --remote-debugging-port=<span class="number token">9222</span> http:<span class="comment token">//localhost &amp;</span>
  - php artisan serve --no-reload &amp;

script:
  - php artisan dusk
</code></pre>
<p><a name="running-tests-on-github-actions"></a></p>
<h3 id="github-actions">GitHub Actions</h3>
<p>如果你正在使用 <a href="https://github.com/features/actions">Github Actions</a> 来运行你的 Dusk 测试，你应该使用以下这份配置文件为起点。像 TravisCI 一样，我们使用 <code>php artisan serve</code> 命令来启动 PHP 的内置 Web 服务：</p>
<pre><code class="language-yaml">name: CI
on: [push]
jobs:

  dusk-php:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Prepare The Environment
        run: cp .env.example .env
      - name: Create Database
        run: |
          sudo systemctl start mysql
          mysql --user=<span class="string token">"root"</span> --password=<span class="string token">"root"</span> -e <span class="string token">"CREATE DATABASE 'my-database' character set UTF8mb4 collate utf8mb4_bin;"</span>
      - name: Install Composer Dependencies
        run: composer install --no-progress --prefer-dist --optimize-autoloader
      - name: Generate Application Key
        run: php artisan key:generate
      - name: Upgrade Chrome Driver
        run: php artisan dusk:chrome-driver `/opt/google/chrome/chrome --version | cut -d <span class="string token">" "</span> -f3 | cut -d <span class="string token">"."</span> -f1`
      - name: Start Chrome Driver
        run: ./vendor/laravel/dusk/bin/chromedriver-linux &amp;
      - name: Run Laravel Server
        run: php artisan serve --no-reload &amp;
      - name: Run Dusk Tests
        env:
          APP_URL: <span class="string token">"http://127.0.0.1:8000"</span>
        run: php artisan dusk
      - name: Upload Screenshots
        <span class="keyword token">if</span>: failure()
        uses: actions/upload-artifact@v2
        with:
          name: screenshots
          path: tests/Browser/screenshots
      - name: Upload Console Logs
        <span class="keyword token">if</span>: failure()
        uses: actions/upload-artifact@v2
        with:
          name: console
          path: tests/Browser/console
</code></pre>
</div>
    <blockquote style="font-size: 0.9em;">
        本译文仅用于学习和交流目的，转载请务必注明文章译者、出处、和本文链接 <br>
        我们的翻译工作遵照 <a href="https://learnku.com/docs/guide/cc4.0/6589">CC 协议</a>，如果我们的工作有侵犯到您的权益，请及时联系我们。
    </blockquote>
</body>

</html>
