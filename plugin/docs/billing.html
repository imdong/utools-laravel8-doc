<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Laravel 9.x 中文文档</title>
    <link rel="stylesheet" href="../style/idea.css">
<link rel="stylesheet" href="../style/bd0cbd7aa15e5518a47099735133bf3a-vendors.css">
<link rel="stylesheet" href="../style/a91e47e2539b98438cb4c6c3a665d642-app.css">
    <style>
        div.markdown-body {
            margin: 0 10px;
        }
    </style>
</head>

<body>
    <div class="markdown-body"><h1 id="laravel-cashier-stripe">Laravel Cashier (Stripe)</h1>
<ul>
<li><a href="#introduction">简介</a></li>
<li><a href="#upgrading-cashier">升级 Cashier</a></li>
<li><a href="#installation">安装</a><ul>
<li><a href="#database-migrations">数据库迁移</a></li>
</ul>
</li>
<li><a href="#configuration">配置信息</a><ul>
<li><a href="#billable-model">计费模型</a></li>
<li><a href="#api-keys">API 密钥</a></li>
<li><a href="#currency-configuration">货币配置</a></li>
<li><a href="#tax-configuration">税务配置</a></li>
<li><a href="#logging">日志</a></li>
<li><a href="#using-custom-models">使用自定义模型</a></li>
</ul>
</li>
<li><a href="#customers">消费者</a><ul>
<li><a href="#retrieving-customers">获取消费者</a></li>
<li><a href="#creating-customers">创建消费者</a></li>
<li><a href="#updating-customers">更新消费者</a></li>
<li><a href="#balances">余额</a></li>
<li><a href="#tax-ids">税号</a></li>
<li><a href="#syncing-customer-data-with-stripe">使用 Stripe 同步客户数据</a></li>
<li><a href="#billing-portal">计费门户</a></li>
</ul>
</li>
<li><a href="#payment-methods">支付方式</a><ul>
<li><a href="#storing-payment-methods">存储支付方式</a></li>
<li><a href="#retrieving-payment-methods">检索支付方式</a></li>
<li><a href="#check-for-a-payment-method">判断用户是否有支付方式</a></li>
<li><a href="#updating-the-default-payment-method">更新默认支付方式</a></li>
<li><a href="#adding-payment-methods">添加支付方式</a></li>
<li><a href="#deleting-payment-methods">删除支付方式</a></li>
</ul>
</li>
<li><a href="#subscriptions">订阅内容</a><ul>
<li><a href="#creating-subscriptions">创建订阅</a></li>
<li><a href="#checking-subscription-status">检查订阅状态</a></li>
<li><a href="#changing-prices">修改价格</a></li>
<li><a href="#subscription-quantity">订阅数量</a></li>
<li><a href="#multiprice-subscriptions">多方案订阅计划</a></li>
<li><a href="#metered-billing">计量计费</a></li>
<li><a href="#subscription-taxes">订阅税</a></li>
<li><a href="#subscription-anchor-date">订阅锚定日期</a></li>
<li><a href="#cancelling-subscriptions">取消订阅</a></li>
<li><a href="#resuming-subscriptions">恢复订阅</a></li>
</ul>
</li>
<li><a href="#subscription-trials">订阅试用</a><ul>
<li><a href="#with-payment-method-up-front">预先使用付款方式</a></li>
<li><a href="#without-payment-method-up-front">没有预先付款方式</a></li>
<li><a href="#extending-trials">延长试用期</a></li>
</ul>
</li>
<li><a href="#handling-stripe-webhooks">处理 Stripe Webhooks</a><ul>
<li><a href="#defining-webhook-event-handlers">定义 Webhook 事件处理器</a></li>
<li><a href="#verifying-webhook-signatures">验证 Webhook 签名</a></li>
</ul>
</li>
<li><a href="#single-charges">单次收费</a><ul>
<li><a href="#simple-charge">基本使用</a></li>
<li><a href="#charge-with-invoice">带发票的支付</a></li>
<li><a href="#refunding-charges">退款</a></li>
</ul>
</li>
<li><a href="#checkout">结账</a><ul>
<li><a href="#product-checkouts">产品结账</a></li>
<li><a href="#single-charge-checkouts">单次支付结账</a></li>
<li><a href="#subscription-checkouts">订阅结账</a></li>
<li><a href="#collecting-tax-ids">收集税号</a></li>
</ul>
</li>
<li><a href="#invoices">发票</a><ul>
<li><a href="#retrieving-invoices">获取发票</a></li>
<li><a href="#upcoming-invoices">即将发布的发票</a></li>
<li><a href="#previewing-subscription-invoices">预览订阅发票</a></li>
<li><a href="#generating-invoice-pdfs">生成发票 PDF</a></li>
</ul>
</li>
<li><a href="#handling-failed-payments">处理支付失败</a></li>
<li><a href="#strong-customer-authentication">强大的客户身份验证 (SCA)</a><ul>
<li><a href="#payments-requiring-additional-confirmation">需要额外确认的支付</a></li>
<li><a href="#off-session-payment-notifications">非会话支付通知</a></li>
</ul>
</li>
<li><a href="#stripe-sdk">Stripe SDK</a></li>
<li><a href="#testing">测试</a></li>
</ul>
<p><a name="introduction"></a></p>
<h2 id="简介">简介</h2>
<p><a href="https://github.com/laravel/cashier-stripe">Laravel Cashier Stripe</a> 为 <a href="https://stripe.com">Stripe</a> 的订阅计费服务提供了一个富有表现力、流畅的接口。它处理了几乎所有你害怕编写的订阅计费样板代码。除了基本的订阅管理，Cashier 还可以处理优惠券、交换订阅、订阅 「数量」、取消宽限期，甚至生成发票 PDF。</p>
<p><a name="upgrading-cashier"></a></p>
<h2 id="升级-cashier">升级 Cashier</h2>
<p>升级到新版本的 Cashier 时，请务必仔细阅读 <a href="https://github.com/laravel/cashier-stripe/blob/master/UPGRADE.md">升级指南</a>。</p>
<blockquote>
<p>注意：为了防止破坏性变更，Cashier 使用固定的 Stripe API 版本。 Cashier 13 使用 Stripe API 版本 <code>2020-08-27</code> 。Stripe API 版本将在次要版本上更新，以利用新的 Stripe 功能和改进。</p>
</blockquote>
<p><a name="installation"></a></p>
<h2 id="安装">安装</h2>
<p>首先，使用 Composer 为 Stripe 安装 Cashier 扩展包：</p>
<pre><code class="language-shell">composer <span class="keyword token">require</span> laravel/cashier
</code></pre>
<blockquote>
<p>注意：为确保 Cashier 正确处理所有 Stripe 事件，请记得 <a href="#handling-stripe-webhooks">设置 Cashier 的 webhook</a>。</p>
</blockquote>
<p><a name="database-migrations"></a></p>
<h3 id="数据库迁移">数据库迁移</h3>
<p>Cashier 的服务提供器注册了自己的数据库迁移目录，因此请记住在安装此包后迁移数据库。Cashier 迁移将向 <code>users</code> 表中添加多个列，并创建一个新的 <code>subscriptions</code> 表来保存客户的所有订阅：</p>
<pre><code class="language-shell">php artisan migrate
</code></pre>
<p>如果需要覆盖 Cashier 附带的迁移，可以使用 <code>vendor:publish</code> Artisan 命令发布它们：</p>
<pre><code class="language-shell">php artisan vendor:publish --tag=&quot;cashier-migrations&quot;
</code></pre>
<p>如果你想阻止 Cashier 的迁移完全运行，可以使用 Cashier 提供的<code>ignoreMigrations</code> 方法。通常应在 <code>AppServiceProvider</code> 类的 <code>register</code> 方法中调用此方法：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Cashier;

<span class="comment token">/**
 * Register any application services.
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> register()
{
    Cashier::ignoreMigrations();
}
</code></pre>
<blockquote>
<p>注意：Stripe 建议用于存储 Stripe 标识符的任何列都应区分大小写。因此，在使用 MySQL 时，应该确保将 <code>stripe_id</code> 列排序规则设置为 <code>utf8_bin</code> 。更多关于这方面的信息可以在 <a href="https://stripe.com/docs/upgrades#what-changes-does-stripe-consider-to-be-backwards-compatible">Stripe 文档</a> 中找到。</p>
</blockquote>
<p><a name="configuration"></a></p>
<h2 id="配置">配置</h2>
<p><a name="billable-model"></a></p>
<h3 id="订单模型">订单模型</h3>
<p>在使用 Cashier 之前，需要将 <code>Billable</code> trait 添加到可订单模型定义中。通常会放在 <code>App\Models\User</code> 模型中。这个特性提供了多个方法以便执行常用支付任务，如创建订阅、应用优惠券和更新支付方法信息：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Billable;

<span class="keyword token">class</span> User <span class="keyword token">extends</span> Authenticatable
{
    <span class="keyword token">use</span> Billable;
}
</code></pre>
<p>Cashier 默认假设你的 Billable 模型是 Laravel 自带的 <code>App\Models\User</code> 类。如果需要修改可以在 <code>useCustomerModel</code> 方法定义一个不同的模型。通常此方法在 <code>AppServiceProvider</code> 类的<code>boot</code>方法中被调用：</p>
<pre><code><span class="keyword token">use</span> App\Models\Cashier\User;
<span class="keyword token">use</span> Laravel\Cashier\Cashier;

<span class="comment token">/**
 * Bootstrap any application services.
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> boot()
{
    Cashier::useCustomerModel(User::<span class="keyword token">class</span>);
}
</code></pre>
<blockquote>
<p>注意：如果你使用的不是 Laravel 自带的 <code>App\Models\User</code> 模型，需要发布并修改默认的 <a href="#installation">Cashier 迁移</a> 文件以匹配你使用模型对应的表名。</p>
</blockquote>
<p><a name="api-keys"></a></p>
<h3 id="api-秘钥">API 秘钥</h3>
<p>接下来需要在 <code>.env</code> 文件中配置 Stripe 秘钥，可以在 Stripe 后台控制面板中获取Stripe API 秘钥：</p>
<pre><code class="language-ini">STRIPE_KEY=your-stripe-key
STRIPE_SECRET=your-stripe-secret
</code></pre>
<p><a name="currency-configuration"></a></p>
<h3 id="货币配置">货币配置</h3>
<p>Cashier 默认货币是美元 (USD)，可以在 <code>.env</code> 中设置 <code>CASHIER_CURRENCY</code> 环境变量来修改默认的货币配置：</p>
<pre><code class="language-ini">CASHIER_CURRENCY=eur
</code></pre>
<p>除了配置 Cashier 的货币之外，还可以在格式化用于显示在发票上的金额时指定本地化配置。在底层，Cashier 使用了 <a href="https://www.php.net/manual/en/class.numberformatter.php">PHP 的 <code>NumberFormatter</code> 类</a> 来设置本地货币：</p>
<pre><code class="language-ini">CASHIER_CURRENCY_LOCALE=nl_BE
</code></pre>
<blockquote>
<p>注意：为了使用本地化配置而不是 <code>en</code>，需要确保安装了 PHP <code>ext-intl</code> PHP 扩展并在服务器上启用配置。</p>
</blockquote>
<p><a name="tax-configuration"></a></p>
<h3 id="税务配置">税务配置</h3>
<p>感谢<a href="https://stripe.com/tax">Stripe  税务</a>，可以自动计算 Stripe 生成的所有发票的税费。 可以通过应用程序的 <code>App\Providers\AppServiceProvider</code>类的 <code>boot</code> 方法中调用 <code>calculateTaxes</code> 来启用自动税务计算：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Cashier;

<span class="comment token">/**
 * Bootstrap any application services.
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> boot()
{
    Cashier::calculateTaxes();
}
</code></pre>
<p>启动税务计算后，任何新订阅和生成的一次性发票都会进行自动税务计算。</p>
<p>为了使这个功能正常使用，客户的账单明细中例如客户姓名、住址、发票 ID 需要同步到 Stripe。你可以使用 Cashier 提供的 <a href="#syncing-customer-data-with-stripe">客户数据同步</a> 和 <a href="#tax-ids">Tax ID</a> 方法来完成此操作。</p>
<blockquote>
<p>注意：遗憾的是，目前不支持计算 <a href="#single-charges">单笔交易</a> 或 <a href="#single-charge-checkouts">单笔交易支付</a>。此外 Stripe Tax 目在测试期间仅限“受邀”使用。你可以通过 <a href="https://stripe.com/tax#request-access">Stripe Tax 网站</a>请求访问 Stripe 税务。</p>
</blockquote>
<p><a name="logging"></a></p>
<h3 id="日志">日志</h3>
<p>Cashier 允许你指定日志通道来记录所有与 Stripe 相关的异常。可以通过在  <code>.env</code> 中配置 <code>CASHIER_LOGGER</code> 来指定：</p>
<pre><code class="language-ini">CASHIER_LOGGER=stack
</code></pre>
<p>对 Stripe 的 API 调用生成的异常将通过应用程序的默认日志通道记录。</p>
<p><a name="using-custom-models"></a></p>
<h3 id="使用自定义模型">使用自定义模型</h3>
<p>你可以通过定义自己的模型并扩展相应的 <code>Cashier</code> 模型来自由扩展 Cashier 内部的模型，增加一些方法：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Subscription <span class="keyword token">as</span> CashierSubscription;

<span class="keyword token">class</span> Subscription <span class="keyword token">extends</span> CashierSubscription
{
    <span class="comment token">// ...</span>
}
</code></pre>
<p>定义模型后，可以通过 <code>Laravel\Cashier\Cashier</code> 类配置 Cashier 使用自定义的模型。通常还需要在 <code>App\Providers\AppServiceProvider</code> 类的 <code>boot</code> 中注册一下：</p>
<pre><code><span class="keyword token">use</span> App\Models\Cashier\Subscription;
<span class="keyword token">use</span> App\Models\Cashier\SubscriptionItem;

<span class="comment token">/**
 * Bootstrap any application services.
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> boot()
{
    Cashier::useSubscriptionModel(Subscription::<span class="keyword token">class</span>);
    Cashier::useSubscriptionItemModel(SubscriptionItem::<span class="keyword token">class</span>);
}
</code></pre>
<p><a name="customers"></a></p>
<h2 id="消费者">消费者</h2>
<p><a name="retrieving-customers"></a></p>
<h3 id="查询消费者">查询消费者</h3>
<p>你可以使用 <code>Cashier::findBillable</code> 方法通过 Stripe ID 查询消费者信息。该方法返回的是一个 billable 模型实例：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Cashier;

<span class="variable token">$user</span> = Cashier::findBillable(<span class="variable token">$stripeId</span>);
</code></pre>
<p><a name="creating-customers"></a></p>
<h3 id="创建消费者">创建消费者</h3>
<p>有时候，你可能希望在不开始订阅的情况下创建一个 Stripe 消费者。这可以通过 <code>createAsStripeCustomer</code> 方法来实现：</p>
<pre><code><span class="variable token">$stripeCustomer</span> = <span class="variable token">$user</span>-&gt;createAsStripeCustomer();
</code></pre>
<p>消费者在 Stripe 中创建后，可以过一段时间再开始订阅。还可以使用可选的 <code>$options</code> 数组传入所有 <a href="https://stripe.com/docs/api/customers/create">Stripe API 支持的创建消费者参数</a> 额外支持的参数：</p>
<pre><code><span class="variable token">$stripeCustomer</span> = <span class="variable token">$user</span>-&gt;createAsStripeCustomer(<span class="variable token">$options</span>);
</code></pre>
<p>如果你要返回消费者对象，你可以使用 <code>asStripeCustomer</code> 方法：</p>
<pre><code><span class="variable token">$stripeCustomer</span> = <span class="variable token">$user</span>-&gt;asStripeCustomer();
</code></pre>
<p>此外，可以使用 <code>createOrGetStripeCustomer</code> 方法来获取不确定查询的 Stripe 消费者在 Stripe 中是否已经存在。如果不存在，这个方法会创建一个消费者：</p>
<pre><code><span class="variable token">$stripeCustomer</span> = <span class="variable token">$user</span>-&gt;createOrGetStripeCustomer();
</code></pre>
<p><a name="updating-customers"></a></p>
<h3 id="更新消费者">更新消费者</h3>
<p>有时候，你可能想要使用额外的信息直接更新 Stripe 顾客信息，可以使用 <code>updateStripeCustomer</code> 方法来完成。这个方法接受 <a href="https://stripe.com/docs/api/customers/update">Stripe API</a> 数组：</p>
<pre><code><span class="variable token">$stripeCustomer</span> = <span class="variable token">$user</span>-&gt;updateStripeCustomer(<span class="variable token">$options</span>);
</code></pre>
<p><a name="balances"></a></p>
<h3 id="余额">余额</h3>
<p>Stripe 允许你借记贷记消费者的“余额”。余额将体现在发票上面为借记或贷记。可以使用 <code>balance</code> 方法检测用户的可用余额。<code>balance</code> 方法会返回消费者货币余额格式化后的字符串：</p>
<pre><code><span class="variable token">$balance</span> = <span class="variable token">$user</span>-&gt;balance();
</code></pre>
<p>要计入用户的余额，可以为 <code>applyBalance</code> 方法提供一个负值。如果愿意的话可以提供描述信息：</p>
<pre><code><span class="variable token">$user</span>-&gt;applyBalance(-<span class="number token">500</span>, <span class="string token">'Premium customer top-up.'</span>);
</code></pre>
<p>提供一个正数值给 <code>applyBalance</code> 方法将增加客户的余额：</p>
<pre><code><span class="variable token">$user</span>-&gt;applyBalance(<span class="number token">300</span>, <span class="string token">'Bad usage penalty.'</span>);
</code></pre>
<p> <code>applyBalance</code> 方法会创建一条客户余额流水记录。可以通过调用 <code>balanceTransactions</code> 方法获取余额交易记录，这有助于提供借记或贷记记录给客户查看：</p>
<pre><code><span class="comment token">// Retrieve all transactions...</span>
<span class="variable token">$transactions</span> = <span class="variable token">$user</span>-&gt;balanceTransactions();

<span class="keyword token">foreach</span> (<span class="variable token">$transactions</span> <span class="keyword token">as</span> <span class="variable token">$transaction</span>) {
    <span class="comment token">// Transaction amount...</span>
    <span class="variable token">$amount</span> = <span class="variable token">$transaction</span>-&gt;amount(); <span class="comment token">// $2.31</span>

    <span class="comment token">// Retrieve the related invoice when available...</span>
    <span class="variable token">$invoice</span> = <span class="variable token">$transaction</span>-&gt;invoice();
}
</code></pre>
<p><a name="tax-ids"></a></p>
<h3 id="税号">税号</h3>
<p>Cashier 提供了一种管理客户税号的简便方法。<code>taxIds</code> 例如，<code>taxIds</code> 方法可用于检索作为集合分配给客户的所有 <a href="https://stripe.com/docs/api/customer_tax_ids/object">税号</a>：
    $taxIds = $user-&gt;taxIds();</p>
<p>您还可以通过标识符检索客户的特定税号：</p>
<pre><code><span class="variable token">$taxId</span> = <span class="variable token">$user</span>-&gt;findTaxId(<span class="string token">'txi_belgium'</span>);
</code></pre>
<p>您可以通过向 <code>createTaxId</code> 方法提供有效的 <a href="https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object-type">type</a> 和值来创建新的税号：</p>
<pre><code><span class="variable token">$taxId</span> = <span class="variable token">$user</span>-&gt;createTaxId(<span class="string token">'eu_vat'</span>, <span class="string token">'BE0123456789'</span>);
</code></pre>
<p><code>createTaxId</code> 方法将立即将增值税 ID 添加到客户的帐户中。 <a href="https://stripe.com/docs/invoicing/customer/tax-ids#validation">增值税 ID 的验证也由 Stripe 完成</a>； 然而，这是一个异步的过程。 您可以通过订阅 <code>customer.tax_id.updated</code> webhook 事件并检查 [增值税 ID <code>verification</code> 参数]（<a href="https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object-">https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object-</a> 确认）。 有关处理 webhook 的更多信息，请参阅 <a href="#handling-stripe-webhooks">有关定义 webhook 处理程序的文档</a>。</p>
<p>您可以使用 <code>deleteTaxId</code> 方法删除税号：</p>
<pre><code><span class="variable token">$user</span>-&gt;deleteTaxId(<span class="string token">'txi_belgium'</span>);
</code></pre>
<p><a name="syncing-customer-data-with-stripe"></a></p>
<h3 id="使用-stripe-同步客户数据">使用 Stripe 同步客户数据</h3>
<p>通常，当您的应用程序的用户更新他们的姓名、电子邮件地址或其他也由 Stripe 存储的信息时，您应该通知 Stripe 更新。 这样一来，Stripe 的信息副本将与您的应用程序同步。</p>
<p>要自动执行此操作，您可以在计费模型上定义一个事件侦听器，以响应模型的「更新」事件。然后，在您的事件监听器中，您可以在模型上调用 <code>syncStripeCustomerDetails</code> 方法：</p>
<pre><code><span class="keyword token">use</span> <span class="keyword token">function</span> Illuminate\Events\queueable;

<span class="comment token">/**
 * 模型的「引导」方法。
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">protected</span> <span class="keyword token">static</span> <span class="keyword token">function</span> booted()
{
    <span class="keyword token">static</span>::updated(queueable(<span class="keyword token">function</span> (<span class="variable token">$customer</span>) {
        <span class="keyword token">if</span> (<span class="variable token">$customer</span>-&gt;hasStripeId()) {
            <span class="variable token">$customer</span>-&gt;syncStripeCustomerDetails();
        }
    }));
}
</code></pre>
<p>现在，每次更新您的客户模型时，其信息都会与 Stripe 同步。 为方便起见，Cashier 会在初始创建客户时自动将您客户的信息与 Stripe 同步。</p>
<p>您可以通过覆盖 Cashier 提供的各种方法来自定义用于将客户信息同步到 Stripe 的列。 例如，当 Cashier 将客户信息同步到 Stripe 时，您可以重写 <code>stripeName</code> 方法来自定义应该被视为客户「姓名」的属性：</p>
<pre><code><span class="comment token">/**
 * 获取应同步到 Stripe 的客户名称。
 *
 *<span class="phpdoc token"> @return</span> string|null
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> stripeName()
{
    <span class="keyword token">return</span> <span class="variable token">$this</span>-&gt;company_name;
}
</code></pre>
<p>同样，您可以复写 <code>stripeEmail</code>、<code>stripePhone</code> 和 <code>stripeAddress</code> 方法。 当<a href="https://stripe.com/docs/api/customers/update">更新 Stripe 客户对象</a> 时，这些方法会将信息同步到其相应的客户参数。 如果您希望完全控制客户信息同步过程，您可以复写 <code>syncStripeCustomerDetails</code> 方法。</p>
<p><a name="billing-portal"></a></p>
<h3 id="订单入口">订单入口</h3>
<p>Stripe 提供了一个简单的方式来<a href="https://stripe.com/docs/billing/subscriptions/customer-portal">设置订单入口</a>以便用户可以管理订阅、支付方法、以及查看历史账单。你可以在控制器或路由中使用 <code>redirectToBillingPortal</code> 方法将用户重定向到账单入口： </p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/billing-portal'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;redirectToBillingPortal();
});
</code></pre>
<p>默认情况下，当用户完成对订阅的管理后，会将能够通过 Stripe 计费门户中的链接返回到应用的 home 路由，你可以通过传递 URL 作为 <code>redirectToBillingPortal</code> 方法的参数来自定义用户返回的 URL： </p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/billing-portal'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;redirectToBillingPortal(route(<span class="string token">'billing'</span>));
});
</code></pre>
<p>如果你只想要生成订单入口的 URL，可以使用 <code>billingPortalUrl</code> 方法： </p>
<pre><code><span class="variable token">$url</span> = <span class="variable token">$request</span>-&gt;user()-&gt;billingPortalUrl(route(<span class="string token">'billing'</span>));
</code></pre>
<p><a name="payment-methods"></a></p>
<h2 id="支付方式">支付方式</h2>
<p><a name="storing-payment-methods"></a></p>
<h3 id="存储支付方式">存储支付方式</h3>
<p>为了使用 Stripe 创建订阅或者进行「一次性」支付，你需要存储支付方法并从 <code>Stripe</code> 中获取对应的标识符。这种方式可用于实现你是否计划使用这个支付方法进行订阅还是单次收费，下面我们分别来介绍这两种方法。 </p>
<p><a name="payment-methods-for-subscriptions"></a></p>
<h4 id="用于订阅的支付方法">用于订阅的支付方法</h4>
<p>当我们为消费者存储信用卡支付方式以便将来使用时，必须使用 Stripe Setup Intents API 来安全地收集顾客的支付方式细节，比如回调错误信息 。「Setup Intents」用于告知 Stripe 使用顾客的支付方法进行收费的意图。Cashier 的 <code>Billable</code> Trait 包含了 <code>createSetupIntent</code> 方法来创建新的「Setup Intent」，你需要在渲染收集顾客支付方法细节表单的路由或控制器方法中调用这个方法：</p>
<pre><code><span class="keyword token">return</span> view(<span class="string token">'update-payment-method'</span>, [
    <span class="string token">'intent'</span> =&gt; <span class="variable token">$user</span>-&gt;createSetupIntent()
]);
</code></pre>
<p>创建完 Setup Intent 并将其传递给视图之后，你需要在收集支付方法的元素中添加它的 secret。例如，参考下面这个「更新支付方法」表单： </p>
<pre><code class="language-html">&lt;input id="card-holder-name" type="text"&gt;

&lt;!-- Stripe Elements Placeholder --&gt;
&lt;div id="card-element"&gt;&lt;/div&gt;

&lt;button id="card-button" data-secret="{{ $intent-&gt;client_secret }}"&gt;
    Update Payment Method
&lt;/button&gt;
</code></pre>
<p>接下来，会通过 Stripe.js 库添加一个 <a href="https://stripe.com/docs/stripe-js">Stripe 元素</a>到表单，并安全地收集顾客的支付细节： </p>
<pre><code class="language-html">&lt;script src=<span class="string token">"https://js.stripe.com/v3/"</span>&gt;&lt;/script&gt;

&lt;script&gt;
    <span class="keyword token">const</span> stripe = Stripe(<span class="string token">'stripe-public-key'</span>);

    <span class="keyword token">const</span> elements = stripe.elements();
    <span class="keyword token">const</span> cardElement = elements.create(<span class="string token">'card'</span>);

    cardElement.mount(<span class="string token">'#card-element'</span>);
&lt;/script&gt;
</code></pre>
<p>然后，使用 <a href="https://stripe.com/docs/stripe-js/reference#stripe-handle-card-setup">Stripe 的 handleCardSetup 方法</a>验证信用卡并从 Stripe 获取一个安全的「支付方法标识符」： </p>
<pre><code class="language-js"><span class="keyword token">const</span> cardHolderName = document.getElementById(<span class="string token">'card-holder-name'</span>);
<span class="keyword token">const</span> cardButton = document.getElementById(<span class="string token">'card-button'</span>);
<span class="keyword token">const</span> clientSecret = cardButton.dataset.secret;

cardButton.addEventListener(<span class="string token">'click'</span>, async (e) =&gt; {
    <span class="keyword token">const</span> { setupIntent, error } = await stripe.confirmCardSetup(
        clientSecret, {
            payment_method: {
                card: cardElement,
                billing_details: { name: cardHolderName.value }
            }
        }
    );

    <span class="keyword token">if</span> (error) {
        <span class="comment token">// 显示错误信息给用户...</span>
    } <span class="keyword token">else</span> {
        <span class="comment token">// 信用卡验证成功...</span>
    }
});
</code></pre>
<p>在 Stripe 验证卡后，您可以将生成的 <code>setupIntent.payment_method</code> 标识符传递给您的 Laravel 应用程序，并在其中将其附加到客户。支付方式可以是<a href="#adding-payment-methods">添加为新的支付方式</a> 或<a href="#updating-the-default-payment-method">用于更新默认支付方式</a>。您还可以立即使用付款方式标识符来<a href="#creating-subscriptions">创建新订阅</a>。</p>
<blockquote>
<p>技巧：如果你想要了解更多关于 Setup Intents 以及获取顾客支付细节的信息，可以参考 <a href="https://stripe.com/docs/payments/save-and-reuse#php">Stripe 官方文档</a>。</p>
</blockquote>
<p><a name="payment-methods-for-single-charges"></a></p>
<h4 id="用于单次付费的支付方法">用于单次付费的支付方法</h4>
<p>当然，如果消费者支付方法使用的是单次付费，我们只需要使用支付方法标识符一次即可。由于 Stripe 本身的限制，你不可以使用存储的默认顾客支付方法进行单次付费，必须允许顾客通过 Stripe.js 库进入他们的支付方法细节。例如，参考下面这个表单： </p>
<pre><code class="language-html">&lt;input id="card-holder-name" type="text"&gt;

&lt;!-- Stripe Elements Placeholder --&gt;
&lt;div id="card-element"&gt;&lt;/div&gt;

&lt;button id="card-button"&gt;
    Process Payment
&lt;/button&gt;
</code></pre>
<p>接下来跟上面文档相似，通过 Stripe.js 库添加 <a href="https://stripe.com/docs/stripe-js">Stripe 元素</a> 到这个表单，并安全地收集顾客的支付细节： </p>
<pre><code class="language-html">&lt;script src=<span class="string token">"https://js.stripe.com/v3/"</span>&gt;&lt;/script&gt;

&lt;script&gt;
    <span class="keyword token">const</span> stripe = Stripe(<span class="string token">'stripe-public-key'</span>);

    <span class="keyword token">const</span> elements = stripe.elements();
    <span class="keyword token">const</span> cardElement = elements.create(<span class="string token">'card'</span>);

    cardElement.mount(<span class="string token">'#card-element'</span>);
&lt;/script&gt;
</code></pre>
<p>然后，使用 <a href="https://stripe.com/docs/stripe-js/reference#stripe-create-payment-method">Stripe 的 createPaymentMethod 方法</a>验证信用卡并获取一个安全的「支付方法标识符」： </p>
<pre><code class="language-js"><span class="keyword token">const</span> cardHolderName = document.getElementById(<span class="string token">'card-holder-name'</span>);
<span class="keyword token">const</span> cardButton = document.getElementById(<span class="string token">'card-button'</span>);

cardButton.addEventListener(<span class="string token">'click'</span>, async (e) =&gt; {
    <span class="keyword token">const</span> { paymentMethod, error } = await stripe.createPaymentMethod(
        <span class="string token">'card'</span>, cardElement, {
            billing_details: { name: cardHolderName.value }
        }
    );

    <span class="keyword token">if</span> (error) {
        <span class="comment token">// Display "error.message" to the user...</span>
    } <span class="keyword token">else</span> {
        <span class="comment token">// The card has been verified successfully...</span>
    }
});
</code></pre>
<p>如果信用卡验证成功，就可以传递 <code>paymentMethod.id</code> 到你的 Laravel 应用并处理<a href="https://learnku.com/docs/laravel/8.5/billing/10421#Simple-Charge">一次性付费</a>。 </p>
<p><a name="retrieving-payment-methods"></a></p>
<h3 id="获取支付方法">获取支付方法</h3>
<p>Billable 模型实例上的 <code>paymentMethods</code> 方法会返回 <code>Laravel\Cashier\PaymentMethod</code> 实例集合： </p>
<pre><code><span class="variable token">$paymentMethods</span> = <span class="variable token">$user</span>-&gt;paymentMethods();
</code></pre>
<p>默认情况下，此方法将返回 <code>card</code> 类型的付款方式。 要检索不同类型的付款方式，您可以将 <code>type</code> 作为参数传递给该方法：</p>
<pre><code><span class="variable token">$paymentMethods</span> = <span class="variable token">$user</span>-&gt;paymentMethods(<span class="string token">'sepa_debit'</span>);
</code></pre>
<p>要获取消费者默认的支付方法，可以使用 <code>defaultPaymentMethod</code> 方法： </p>
<pre><code><span class="variable token">$paymentMethod</span> = <span class="variable token">$user</span>-&gt;defaultPaymentMethod();
</code></pre>
<p>还可以使用 <code>findPaymentMethod</code> 方法通过 Billable 模型获取指定支付方法： </p>
<pre><code><span class="variable token">$paymentMethod</span> = <span class="variable token">$user</span>-&gt;findPaymentMethod(<span class="variable token">$paymentMethodId</span>);
</code></pre>
<p><a name="check-for-a-payment-method"></a></p>
<h3 id="判断消费者是否拥有支付方法">判断消费者是否拥有支付方法</h3>
<p>要判断某个 <code>Billable</code> 模型对应账户是否有默认的支付方法，可以使用 <code>hasDefaultPaymentMethod</code> 方法： </p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;hasDefaultPaymentMethod()) {
    <span class="comment token">//</span>
}
</code></pre>
<p>要判断某个 <code>Billable</code> 模型对应账户是否有支付方法，可以使用 <code>hasPaymentMethod</code> 方法： </p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;hasPaymentMethod()) {
    <span class="comment token">//</span>
}
</code></pre>
<p>此方法将确定计费模型是否具有 <code>card</code> 类型的付款方式。 要确定模型是否存在另一种类型的付款方式，您可以将 <code>type</code> 作为参数传递给该方法：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;hasPaymentMethod(<span class="string token">'sepa_debit'</span>)) {
    <span class="comment token">//</span>
}
</code></pre>
<p><a name="updating-the-default-payment-method"></a></p>
<h3 id="更新默认支付方式">更新默认支付方式</h3>
<p>更新顾客的默认支付方式信息 可以用 <code>updateDefaultPaymentMethod</code> 方法 ，该方法接收一个 Stripe 支付方法标识符并将新的支付方法分配为默认的支付方法： </p>
<pre><code><span class="variable token">$user</span>-&gt;updateDefaultPaymentMethod(<span class="variable token">$paymentMethod</span>);
</code></pre>
<p>要同步应用的默认支付方法信息到 Stripe 顾客的默认支付方式信息，可以使用 <code>updateDefaultPaymentMethodFromStripe</code> 方法: </p>
<pre><code><span class="variable token">$user</span>-&gt;updateDefaultPaymentMethodFromStripe();
</code></pre>
<blockquote>
<p>注意：消费者的默认支付方式只能用于发票和创建新的订阅，由于 Stripe 的限制，不能将其用于单次付费。 </p>
</blockquote>
<p><a name="adding-payment-methods"></a></p>
<h3 id="添加支付方式">添加支付方式</h3>
<p>要添加新的支付方式，可以调用 Billable 用户的 <code>addPaymentMethod</code> 方法，并传递支付方法标识符：</p>
<pre><code><span class="variable token">$user</span>-&gt;addPaymentMethod(<span class="variable token">$paymentMethod</span>);
</code></pre>
<blockquote>
<p>技巧：要了解如何获取支付方法标识符，请参考<a href="https://learnku.com/docs/laravel/8.5/billing/10421#storing-payment-methods">支付方式存储文档</a>. </p>
</blockquote>
<p><a name="deleting-payment-methods"></a></p>
<h3 id="删除支付方式">删除支付方式</h3>
<p>删除一个支付方法，你可以调用要删除的 <code>Laravel\Cashier\PaymentMethod</code> 实例上的 <code>delete</code> 方法：</p>
<pre><code><span class="variable token">$paymentMethod</span>-&gt;delete();
</code></pre>
<p>删除指定 Billable 模型上的所有支付方法信息可以使用 <code>deletePaymentMethods</code> 方法： </p>
<pre><code><span class="variable token">$user</span>-&gt;deletePaymentMethod(<span class="string token">'pm_visa'</span>);
</code></pre>
<p><code>deletePaymentMethods</code> 方法将删除计费模型的所有付款方式信息：</p>
<pre><code><span class="variable token">$user</span>-&gt;deletePaymentMethods();
</code></pre>
<p>默认情况下，此方法将删除 <code>card</code> 类型的付款方式。 要删除不同类型的付款方式，您可以将 <code>type</code> 作为参数传递给该方法：</p>
<pre><code><span class="variable token">$user</span>-&gt;deletePaymentMethods(<span class="string token">'sepa_debit'</span>);
</code></pre>
<blockquote>
<p>注意：如果用户有活动订阅，您的应用程序不应允许他们删除其默认付款方式。</p>
</blockquote>
<p><a name="subscriptions"></a></p>
<h2 id="订阅内容">订阅内容</h2>
<p>订阅提供了一种为消费者设置定期付款的方式。由收银员管理的 Stripe 订阅 提供对多个订阅计划、订阅数量、试用等的支持。 </p>
<p><a name="creating-subscriptions"></a></p>
<h3 id="创建订阅">创建订阅</h3>
<p>创建一个订阅，首先要获取一个账单模型的实例，通常是 <code>App\Models\User</code> 的实例。获取到该模型实例之后，可以使用 <code>newSubscription</code> 方法来创建该模型的订阅：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::post(<span class="string token">'/user/subscribe'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="variable token">$request</span>-&gt;user()-&gt;newSubscription(
        <span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>
    )-&gt;create(<span class="variable token">$request</span>-&gt;paymentMethodId);

    <span class="comment token">// ...</span>
});
</code></pre>
<p><code>newSubscription</code> 方法的第一个参数是该订阅的名字，如果应用只有一个订阅，可以将其称作 <code>default</code> 或 <code>primary</code>，第二个参数用于指定用户订阅的计划，这个值对应 <code>Stripe</code> 中相应计划的标识符。</p>
<p><code>create</code> 方法接收 <a href="https://laravelacademy.org/post/22032#toc-13">Stripe 支付方法标识符</a>或者 Stripe <code>PaymentMethod</code> 对象的 <code>create</code> 方法会自动创建这个 Stripe 订阅，同时更新数据库中 Stripe 的消费者 ID（即 <code>users</code> 表中的 <code>stripe_id</code>）和其它相关的账单信息。 </p>
<blockquote>
<p>注意：直接传递支付方法标识符到 create () 订阅方法还会自动将其添加到用户存储的支付方法中。</p>
</blockquote>
<p><a name="collecting-recurring-payments-via-invoice-emails"></a></p>
<h4 id="通过发票电子邮件收集定期付款">通过发票电子邮件收集定期付款</h4>
<p>您可以指示 Stripe 在每次定期付款到期时通过电子邮件将发票发送给客户，而不是自动收取客户的定期付款。 然后，客户可以在收到发票后手动支付发票。 通过发票收取定期付款时，客户无需预先提供付款方式：</p>
<pre><code><span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)-&gt;createAndSendInvoice();
</code></pre>
<p>客户在取消订阅之前必须支付发票的时间取决于您在 <a href="https://dashboard.stripe.com/settings/billing/automatic">Stripe 仪表板</a> 中的订阅和发票设置。</p>
<p><a name="subscription-quantities"></a></p>
<h4 id="数量">数量</h4>
<p>如果你想要在创建订阅时设置计划的具体数量，可以使用 <code>quantity</code> 方法： </p>
<pre><code><span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
     -&gt;quantity(<span class="number token">5</span>)
     -&gt;create(<span class="variable token">$paymentMethod</span>);
</code></pre>
<p><a name="additional-details"></a></p>
<h4 id="其它细节">其它细节</h4>
<p>如果你想要指定其它<a href="https://stripe.com/docs/api/customers/create">消费者</a>或者<a href="https://stripe.com/docs/api/subscriptions/create">订阅细节</a>，你可以将其作为第二个参数传递给 <code>create</code> 方法： </p>
<pre><code><span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)-&gt;create(<span class="variable token">$paymentMethod</span>, [
    <span class="string token">'email'</span> =&gt; <span class="variable token">$email</span>,
], [
    <span class="string token">'metadata'</span> =&gt; [<span class="string token">'note'</span> =&gt; <span class="string token">'Some extra information.'</span>],
]);
</code></pre>
<p><a name="coupons"></a></p>
<h4 id="优惠券">优惠券</h4>
<p>如果你想在创建订阅的时候使用优惠券，你可以使用 <code>withCoupon</code> 方法:</p>
<pre><code><span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
     -&gt;withCoupon(<span class="string token">'code'</span>)
     -&gt;create(<span class="variable token">$paymentMethod</span>);
</code></pre>
<p>或者，如果你想使用 <a href="https://stripe.com/docs/billing/subscriptions/discounts/codes">Stripe 推广代码</a>，可以使用 <code>withPromotionCode</code> 方法：</p>
<pre><code><span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
     -&gt;withPromotionCode(<span class="string token">'promo_code'</span>)
     -&gt;create(<span class="variable token">$paymentMethod</span>);
</code></pre>
<p><a name="adding-subscriptions"></a></p>
<h4 id="添加订阅">添加订阅</h4>
<p>如果你想要为已经有默认支付方式的消费者添加订阅，可以在使用 <code>newSubscription</code> 方法时使用 <code>add</code> 方法：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)-&gt;add();
</code></pre>
<p><a name="creating-subscriptions-from-the-stripe-dashboard"></a></p>
<h4 id="从-stripe-面板中创建订阅">从 Stripe 面板中创建订阅</h4>
<p>你也可以从 Stripe 面板中创建订阅。在面板中创建订阅时候，收银员将同步新添加的订阅，并为它们分配一个名称为 <code>default</code> 的订阅。要自定义分配给仪表板创建订阅的订阅名，<a href="https://learnku.com/docs/laravel/8.5/billing/10421#defining-webhook-event-handlers">扩展’ WebhookController ‘</a>并覆盖 <code>newSubscriptionName</code> 方法。 </p>
<p>此外，只能通过 Stripe 面板中创建一种订阅类型。如果应用程序提供使用不同名称的多个订阅，则只能通过 Stripe 面板添加一种订阅类型。 </p>
<p>最后，应该始终确保对应用程序提供的每种订阅类型只添加一个活动订阅。如果消费者有两个 <code>default</code> 订阅，那么收银员只会使用最近添加的订阅，即使这两个订阅都将与应用程序的数据库同步。 </p>
<p><a name="checking-subscription-status"></a></p>
<h3 id="检查订阅状态">检查订阅状态</h3>
<p>客户订阅您的应用程序后，您可以使用各种便捷的方法检查他们的订阅状态。首先，如果客户有活动订阅，则 <code>subscribed</code> 方法会返回 <code>true</code>，即使订阅当前处于试用期也是如此。<code>subscribed</code> 方法接受订阅的名称作为它的第一个参数:</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscribed(<span class="string token">'default'</span>)) {
    <span class="comment token">//</span>
}
</code></pre>
<p><code>subscribed</code> 方法也可以用于<a href="https://learnku.com/docs/laravel/8.5/middleware">路由中间件</a> , 基于消费者订阅状态允许你对路由和控制器的访问进行过滤：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Http\Middleware;

<span class="keyword token">use</span> Closure;

<span class="keyword token">class</span> EnsureUserIsSubscribed
{
    <span class="comment token">/**
     * 处理传入的请求。
     *
     *<span class="phpdoc token"> @param</span>  \Illuminate\Http\Request  $request
     *<span class="phpdoc token"> @param</span>  \Closure  $next
     *<span class="phpdoc token"> @return</span> mixed
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> handle(<span class="variable token">$request</span>, Closure <span class="variable token">$next</span>)
    {
        <span class="keyword token">if</span> (<span class="variable token">$request</span>-&gt;user() &amp;&amp; ! <span class="variable token">$request</span>-&gt;user()-&gt;subscribed(<span class="string token">'default'</span>)) {
            <span class="comment token">// 该用户不是付费用户...</span>
            <span class="keyword token">return</span> redirect(<span class="string token">'billing'</span>);
        }

        <span class="keyword token">return</span> <span class="variable token">$next</span>(<span class="variable token">$request</span>);
    }
}
</code></pre>
<p>如果你想要判断一个消费者是否还在试用期，可以使用 <code>onTrial</code> 方法，该方法对于还处于试用期的用户显示警告信息很有用：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;onTrial()) {
    <span class="comment token">//</span>
}
</code></pre>
<p><code>subscribedToProduct</code> 方法可用于根据给定 Stripe 产品的标识符确定用户是否订阅了给定产品。 在 Stripe 中，产品是价格的集合。 在此示例中，我们将确定用户的 <code>默认</code> 订阅是否主动订阅了应用程序的 <code>高级</code> 产品。 给定的 Stripe 产品标识符应与您在 Stripe 仪表板中的产品标识符之一相对应：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscribedToProduct(<span class="string token">'prod_premium'</span>, <span class="string token">'default'</span>)) {
    <span class="comment token">//</span>
}



<span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscribedToProduct([<span class="string token">'prod_basic'</span>, <span class="string token">'prod_premium'</span>], <span class="string token">'default'</span>)) {
    <span class="comment token">//</span>
}
</code></pre>
<p><code>subscribedToPrice</code> 方法可用于确定客户的订阅是否对应于给定的价格 ID：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscribedToPrice(<span class="string token">'price_basic_monthly'</span>, <span class="string token">'default'</span>)) {
    <span class="comment token">//</span>
}
</code></pre>
<p><code>recurring</code> 方法可用于确定用户当前是否已订阅并且不再处于试用期内：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;recurring()) {
    <span class="comment token">//</span>
}
</code></pre>
<blockquote>
<p>注意：如果消费者有两个具有相同名称的订阅，则 subscription 方法将始终返回最近的订阅。例如，消费者可能有两条名为 default 的订阅记录；但是，其中一个订阅可能是旧的、过期的订阅，而另一个是当前的、活动的订阅。最新的订阅将始终返回，而旧的订阅将保留在数据库中以进行历史回顾。</p>
</blockquote>
<p><a name="cancelled-subscription-status"></a></p>
<h4 id="已取消的订阅状态">已取消的订阅状态</h4>
<p>要判断消费者是否曾经是有效的订阅者，但现在取消了订阅，可以使用 <code>cancelled</code> 方法：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;canceled()) {
    <span class="comment token">//</span>
}
</code></pre>
<p>还可以判断消费者是否曾经取消过订阅，但现在仍然在「宽限期」直到完全失效。例如，如果一个消费者在 3 月 5 号取消了一个实际有效期到 3 月 10 号的订阅，该消费者处于「宽限期」直到 3 月 10 号。注意 <code>subscribed</code> 方法在此期间仍然返回 <code>true</code>。 </p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;onGracePeriod()) {
    <span class="comment token">//</span>
}
</code></pre>
<p>要去定消费者已经取消订阅并且不在「宽限期」内，可以使用 <code>ended</code> 方法： </p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;ended()) {
    <span class="comment token">//</span>
}
</code></pre>
<p><a name="incomplete-and-past-due-status"></a></p>
<h4 id="未完成和过期状态">未完成和过期状态</h4>
<p>如果某个订阅要求创建完订阅后进行二次付款操作，将被标记为 <code>incomplete</code>。订阅状态被存储在 <code>Cashier subscriptions</code> 数据表的 <code>stripe_status</code> 字段。</p>
<p>类似的，如果在切换订阅计划时也需要进行二次付款操作，对应的订阅会被标记为 <code>past_due</code>。当你的订阅处于这种状态时，只有等到消费者确认支付后它们才会被激活。我们可以使用 <code>Billable</code> 模型或者订阅实例的 <code>hasIncompletePayment</code> 方法来检查某个订阅是否存在未完成支付：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;hasIncompletePayment(<span class="string token">'default'</span>)) {
    <span class="comment token">//</span>
}

<span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;hasIncompletePayment()) {
    <span class="comment token">//</span>
}
</code></pre>
<p>如果某个订阅存在未完成支付，你需要引导消费者到 Cashier 的支付确认页面，并传递 <code>latestPayment</code> 标识符。你可以使用订阅实例上的 <code>latestPayment</code> 方法来获取这个标识符：</p>
<pre><code class="language-html">&lt;a href="{{ route('cashier.payment', $subscription-&gt;latestPayment()-&gt;id) }}"&gt;
    Please confirm your payment.
&lt;/a&gt;
</code></pre>
<p>如果你想要订阅在 <code>past_due</code> 状态下依然有效，可以使用 Cashier 提供的 <code>keepPastDueSubscriptionsActive</code> 方法，通常，该方法需要在 <code>AppServiceProvider</code> 的 <code>boot</code> 方法中调用：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Cashier;

<span class="comment token">/**
 * Register any application services.
 *
 *<span class="phpdoc token"> @return</span> void
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> register()
{
    Cashier::keepPastDueSubscriptionsActive();
}
</code></pre>
<blockquote>
<p>注意：当某个订阅处于 <code>incomplete</code> 状态，只有等到支付被确认后才能进行修改。因此，当订阅处于 <code>incomplete</code> 状态时，执行 <code>swap</code> 和 <code>updateQuantity</code> 方法会抛出异常。</p>
</blockquote>
<p><a name="subscription-scopes"></a></p>
<h4 id="订阅范围">订阅范围</h4>
<p>大多数订阅状态也可用作查询范围，以便你可以轻松地查询数据库中处于给定状态的订阅：</p>
<pre><code><span class="comment token">// 获取所有有效订阅...</span>
<span class="variable token">$subscriptions</span> = Subscription::query()-&gt;active()-&gt;get();

<span class="comment token">// Get all of the canceled subscriptions for a user...</span>
<span class="variable token">$subscriptions</span> = <span class="variable token">$user</span>-&gt;subscriptions()-&gt;canceled()-&gt;get();
</code></pre>
<p>所有内置的订阅查询范围列表如下：</p>
<pre><code>Subscription::query()-&gt;active();
Subscription::query()-&gt;canceled();
Subscription::query()-&gt;ended();
Subscription::query()-&gt;incomplete();
Subscription::query()-&gt;notCanceled();
Subscription::query()-&gt;notOnGracePeriod();
Subscription::query()-&gt;notOnTrial();
Subscription::query()-&gt;onGracePeriod();
Subscription::query()-&gt;onTrial();
Subscription::query()-&gt;pastDue();
Subscription::query()-&gt;recurring();
</code></pre>
<p><a name="changing-prices"></a></p>
<h3 id="修改计划">修改计划</h3>
<p>消费者订阅应用后，有时候想要改变到新的订阅计划，需要将消费者切换到新的订阅，传递计划标识符到 swap 方法：</p>
<p>在交换价格时，假设用户想要重新激活他们的订阅（如果之前取消订阅）。 给定的价格标识符应对应于 Stripe 仪表板中可用的 Stripe 价格标识符：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$user</span> = App\Models\User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;swap(<span class="string token">'price_yearly'</span>);
</code></pre>
<p>如果消费者在试用，试用期将会被维护。还有，如果订阅存在多个，数量也可以被维护。</p>
<p>如果你想要切换计划并取消消费者所在的所有试用期，可以使用 skipTrial 方法：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)
        -&gt;skipTrial()
        -&gt;swap(<span class="string token">'price_yearly'</span>);
</code></pre>
<p>如果你想要切换计划并立即为消费者开具发票，而不是等到下一个结算周期，可以使用 <code>swapAndInvoice</code> 方法：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;swapAndInvoice(<span class="string token">'price_yearly'</span>);
</code></pre>
<p><a name="prorations"></a></p>
<h4 id="按比例分配">按比例分配</h4>
<p>默认情况下，Stripe 会在订阅计划间切换时按比例进行分配，<code>noProrate</code> 可用于在修改订阅计划时不使用按比例分配机制：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;noProrate()-&gt;swap(<span class="string token">'price_yearly'</span>);
</code></pre>
<p>更多关于订阅计划按比例分配的细节，请参考 <a href="https://stripe.com/docs/billing/subscriptions/prorations">Stripe 官方文档</a>。</p>
<blockquote>
<p>注意：在 <code>wapAndInvoice</code> 方法之前执行 <code>noProrate</code> 方法不会影响按比例分配。发票始终都会开具。</p>
</blockquote>
<p><a name="subscription-quantity"></a></p>
<h3 id="订阅数量">订阅数量</h3>
<p>有时候订阅也会被数量影响，例如，应用中每个账户每月需要付费 $10，要简单增加或减少订阅数量，使用 <code>incrementQuantity</code> 和 <code>decrementQuantity</code> 方法： </p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;incrementQuantity();

<span class="comment token">// 向订阅的当前数量添加五个...</span>
<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;incrementQuantity(<span class="number token">5</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;decrementQuantity();

<span class="comment token">// 从订阅的当前数量中减去五...</span>
<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;decrementQuantity(<span class="number token">5</span>);
</code></pre>
<p>你也可以使用 <code>updateQuantity</code> 方法指定具体的数量：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;updateQuantity(<span class="number token">10</span>);
</code></pre>
<p><code>noProrate</code> 方法可用于更新订阅数量而无需对收费进行评级：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;noProrate()-&gt;updateQuantity(<span class="number token">10</span>);
</code></pre>
<p>想要了解更多订阅数量信息，可以参考 <a href="https://stripe.com/docs/subscriptions/quantities">Stripe 官方文档</a>.</p>
<p><a name="multiprice-subscription-quantities"></a></p>
<h4 id="多方案订阅数量">多方案订阅数量</h4>
<p>如果你的订阅是<a href="https://learnku.com/docs/laravel/8.5/billing/10421#multiplan-subscriptions">多方案订阅计划</a> , 你应该将其数量要递增或递减的计划的名称作为第二个参数传递给递增 / 递减方法</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;incrementQuantity(<span class="number token">1</span>, <span class="string token">'price_chat'</span>);
</code></pre>
<p><a name="multiprice-subscriptions"></a></p>
<h3 id="多方案订阅计划">多方案订阅计划</h3>
<p><a href="https://stripe.com/docs/billing/subscriptions/multiplan">多方案订阅计划</a> 可以分配多个付费方案给单个订阅计划。例如，假设你正在构建一个顾客咨询服务应用，其中包含了一个基础的￥10 / 月的订阅方案，但是如果提供附加的实时聊天服务，需要支付￥15 / 月，订阅信息存储在收银员的 <code>Subscription_items</code> 数据库表中：</p>
<p>可以通过将计划数组作为第二个参数传递给 <code>newSubscription</code> 方法，为给定的订阅指定多个计划：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::post(<span class="string token">'/user/subscribe'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="variable token">$request</span>-&gt;user()-&gt;newSubscription(<span class="string token">'default'</span>, [
        <span class="string token">'price_monthly'</span>,
        <span class="string token">'price_chat'</span>,
    ])-&gt;create(<span class="variable token">$request</span>-&gt;paymentMethodId);

    <span class="comment token">// ...</span>
});
</code></pre>
<p>在上面的示例代码中，消费者的 <code>default</code> 订阅添加了两个订阅计划。这两个计划都将按各自的计费间隔收费。如果需要，可以使用 <code>Quantity</code> 方法来表示每个计划的具体数量：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, [<span class="string token">'price_monthly'</span>, <span class="string token">'price_chat'</span>])
    -&gt;quantity(<span class="number token">5</span>, <span class="string token">'price_chat'</span>)
    -&gt;create(<span class="variable token">$paymentMethod</span>);
</code></pre>
<p>如果您想为现有订阅添加其他价格，可以调用订阅的 <code>addPrice</code> 方法：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;addPrice(<span class="string token">'price_chat'</span>);
</code></pre>
<p>上面的示例代码会添加新方案并且顾客会在下个支付周期为其支付。如果你想要让顾客立即支付，可以使用 <code>addPlanAndInvoice</code> 方法：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;addPriceAndInvoice(<span class="string token">'price_chat'</span>);
</code></pre>
<p>如果你想要添加指定数量的方案，可以将数量值作为第二个参数传递给 <code>addPlan</code> 或者 <code>addPlanAndInvoice</code> 方法：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;addPrice(<span class="string token">'price_chat'</span>, <span class="number token">5</span>);
</code></pre>
<p>你也可以使用 <code>removePlan</code> 方法从订阅计划中移除这些方案：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;removePrice(<span class="string token">'price_chat'</span>);
</code></pre>
<blockquote>
<p>注意：不能移除订阅计划中最后一个方案（至少需要保留一个）, 相反，需要通过取消订阅的方式移除该方案。</p>
</blockquote>
<p><a name="swapping-prices"></a></p>
<h4 id="多方案订阅切换">多方案订阅切换</h4>
<p>您还可以更改多价订阅的附加价格。 例如，假设客户订阅了带有 <code>price_chat</code> 附加价格的 <code>price_basic</code>，并且您想将客户从 <code>price_basic</code> 升级到 <code>price_pro</code> 价格：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;swap([<span class="string token">'price_pro'</span>, <span class="string token">'price_chat'</span>]);
</code></pre>
<p>执行上面的示例时，带有 <code>price_basic</code> 的底层订阅项目被删除，而带有<code>price_chat</code> 的订阅项目被保留。 此外，还会为 <code>price_pro</code> 创建一个新的订阅项目。</p>
<p>您还可以通过将一组键/值对传递给“swap”方法来指定订阅项目选项。 例如，您可能需要指定订阅价格的数量：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;swap([
    <span class="string token">'price_pro'</span> =&gt; [<span class="string token">'quantity'</span> =&gt; <span class="number token">5</span>],
    <span class="string token">'price_chat'</span>
]);
</code></pre>
<p>如果您想交换订阅的单一价格，您可以使用订阅项目本身的“swap”方法来实现。 如果您想保留订阅的其他价格上的所有现有元数据，此方法特别有用：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)
        -&gt;findItemOrFail(<span class="string token">'price_basic'</span>)
        -&gt;swap(<span class="string token">'price_pro'</span>);
</code></pre>
<p><a name="proration"></a></p>
<h4 id="按比例分配-1">按比例分配</h4>
<p>默认情况下，在多价订阅中添加或删除价格时，Stripe 将按比例收取费用。 如果您想在没有按比例分配的情况下进行价格调整，您应该将 <code>noProrate</code> 方法链接到您的价格操作：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;noProrate()-&gt;removePrice(<span class="string token">'price_chat'</span>);
</code></pre>
<p><a name="swapping-quantities"></a></p>
<h4 id="数量-1">数量</h4>
<p>如果您想更新单个订阅价格的数量，您可以使用 <a href="#subscription-quantity">现有数量方法</a> 将价格名称作为附加参数传递给该方法：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;incrementQuantity(<span class="number token">5</span>, <span class="string token">'price_chat'</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;decrementQuantity(<span class="number token">3</span>, <span class="string token">'price_chat'</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;updateQuantity(<span class="number token">10</span>, <span class="string token">'price_chat'</span>);
</code></pre>
<blockquote>
<p>注意：当订阅有多个价格时，“Subscription”模型上的“stripe_price”和“quantity”属性将为“null”。 要访问单个价格属性，您应该使用 <code>Subscription</code> 模型上可用的 <code>items</code> 关系。</p>
</blockquote>
<p><a name="subscription-items"></a></p>
<h4 id="订阅项目">订阅项目</h4>
<p>当订阅有多个价格时，它将有多个订阅“项目”存储在数据库的 <code>subscription_items</code> 表中。 您可以通过订阅上的 <code>items</code> 关系访问这些：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$subscriptionItem</span> = <span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;items-&gt;first();

<span class="comment token">// 检索特定商品的 Stripe 价格和数量...</span>
<span class="variable token">$stripePrice</span> = <span class="variable token">$subscriptionItem</span>-&gt;stripe_price;
<span class="variable token">$quantity</span> = <span class="variable token">$subscriptionItem</span>-&gt;quantity;
</code></pre>
<p>您还可以使用 <code>findItemOrFail</code> 方法检索特定价格：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$subscriptionItem</span> = <span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;findItemOrFail(<span class="string token">'price_chat'</span>);
</code></pre>
<p><a name="metered-billing"></a></p>
<h3 id="计量计费">计量计费</h3>
<p><a href="https://stripe.com/docs/billing/subscriptions/metered-billing">计量计费</a> 允许您根据客户在计费周期内的产品使用情况向他们收费。 例如，您可以根据客户每月发送的短信或电子邮件的数量向他们收费。</p>
<p>要开始使用计量计费，您首先需要在 Stripe 仪表板中创建一个具有计量价格的新产品。 然后，使用 <code>meteredPrice</code> 将计量价格 ID 添加到客户订阅中：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::post(<span class="string token">'/user/subscribe'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="variable token">$request</span>-&gt;user()-&gt;newSubscription(<span class="string token">'default'</span>)
        -&gt;meteredPrice(<span class="string token">'price_metered'</span>)
        -&gt;create(<span class="variable token">$request</span>-&gt;paymentMethodId);

    <span class="comment token">// ...</span>
});
</code></pre>
<p>您也可以通过 <a href="#checkout">Stripe Checkout</a> 开始计量订阅：</p>
<pre><code><span class="variable token">$checkout</span> = Auth::user()
        -&gt;newSubscription(<span class="string token">'default'</span>, [])
        -&gt;meteredPrice(<span class="string token">'price_metered'</span>)
        -&gt;checkout();

<span class="keyword token">return</span> view(<span class="string token">'your-checkout-view'</span>, [
    <span class="string token">'checkout'</span> =&gt; <span class="variable token">$checkout</span>,
]);
</code></pre>
<p><a name="reporting-usage"></a></p>
<h4 id="报告使用情况">报告使用情况</h4>
<p>当您的客户使用您的应用程序时，您将向 Stripe 报告他们的使用情况，以便准确计费。 要增加计量订阅的使用量，您可以使用 <code>reportUsage</code> 方法：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;reportUsage();
</code></pre>
<p>默认情况下，计费周期会添加 1 的“使用量”。 或者，您可以传递特定数量的“使用量”以添加到客户在计费期间的使用量：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;reportUsage(<span class="number token">15</span>);
</code></pre>
<p>如果您的应用程序在单个订阅中提供多个价格，您将需要使用 <code>reportUsageFor</code> 方法来指定要报告使用情况的计量价格：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;reportUsageFor(<span class="string token">'price_metered'</span>, <span class="number token">15</span>);
</code></pre>
<p>有时，您可能需要更新之前报告的使用情况。 为此，您可以将时间戳或“DateTimeInterface”实例作为第二个参数传递给“reportUsage”。 这样做时，Stripe 将更新在给定时间报告的使用情况。 您可以继续更新以前的使用记录，因为给定的日期和时间仍在当前计费周期内：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;reportUsage(<span class="number token">5</span>, <span class="variable token">$timestamp</span>);
</code></pre>
<p><a name="retrieving-usage-records"></a></p>
<h4 id="检索使用记录">检索使用记录</h4>
<p>要检索客户过去的使用情况，您可以使用订阅实例的 <code>usageRecords</code> 方法：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$usageRecords</span> = <span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;usageRecords();
</code></pre>
<p>如果您的应用程序在单个订阅中提供多个价格，您可以使用 <code>usageRecordsFor</code> 方法指定您希望检索使用记录的计量价格：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$usageRecords</span> = <span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;usageRecordsFor(<span class="string token">'price_metered'</span>);
</code></pre>
<p><code>usageRecords</code> 和 <code>usageRecordsFor</code> 方法返回一个包含使用记录关联数组的 Collection 实例。 您可以遍历此数组以显示客户的总使用量：</p>
<pre><code>@<span class="keyword token">foreach</span> (<span class="variable token">$usageRecords</span> <span class="keyword token">as</span> <span class="variable token">$usageRecord</span>)
    - Period Starting: {{ <span class="variable token">$usageRecord</span>[<span class="string token">'period'</span>][<span class="string token">'start'</span>] }}
    - Period Ending: {{ <span class="variable token">$usageRecord</span>[<span class="string token">'period'</span>][<span class="string token">'end'</span>] }}
    - Total Usage: {{ <span class="variable token">$usageRecord</span>[<span class="string token">'total_usage'</span>] }}
@<span class="keyword token">endforeach</span>
</code></pre>
<p>有关返回的所有使用数据以及如何使用 Stripe 的基于光标的分页的完整参考，请参阅 <a href="https://stripe.com/docs/api/usage_records/subscription_item_summary_list">官方 Stripe API 文档</a>。</p>
<p><a name="subscription-taxes"></a></p>
<h3 id="订阅-taxes">订阅 Taxes</h3>
<blockquote>
<p>注意：您可以<a href="#tax-configuration">使用 StripeTax 自动计算税金</a>，而不是手动计算税率</p>
</blockquote>
<p>要指定用户为订阅支付的税率，您应该在计费模型上实现 <code>taxRates</code> 方法并返回一个包含 Stripe 税率 ID 的数组。 您可以在 <a href="https://dashboard.stripe.com/test/tax-rates">您的 Stripe 仪表板</a> 中定义这些税率：</p>
<pre><code><span class="comment token">/**
 * 应适用于客户订阅的税率。
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> taxRates()
{
    <span class="keyword token">return</span> [<span class="string token">'txr_id'</span>];
}
</code></pre>
<p><code>taxRates</code> 方法使您可以逐个客户应用税率，这可能有助于跨越多个国家和税率的用户群。</p>
<p>如果您提供多价订阅，您可以通过在计费模型上实现 <code>priceTaxRates</code> 方法为每个价格定义不同的税率：</p>
<pre><code><span class="comment token">/**
 * The tax rates that should apply to the customer's subscriptions.
 *
 *<span class="phpdoc token"> @return</span> array
 */</span>
<span class="keyword token">public</span> <span class="keyword token">function</span> priceTaxRates()
{
    <span class="keyword token">return</span> [
        <span class="string token">'price_monthly'</span> =&gt; [<span class="string token">'txr_id'</span>],
    ];
}
</code></pre>
<blockquote>
<p>注意：<code>taxRates</code> 方法仅适用于订阅费用。 如果您使用 Cashier 进行“一次性”收费，您将需要手动指定当时的税率。</p>
</blockquote>
<p><a name="syncing-tax-rates"></a></p>
<h4 id="同步税率">同步税率</h4>
<p>更改 <code>taxRates</code> 方法返回的硬编码税率 ID 时，用户现有订阅的税费设置将保持不变。 如果您希望使用新的 <code>taxRates</code> 值更新现有订阅的税值，则应在用户的订阅实例上调用 <code>syncTaxRates</code> 方法：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;syncTaxRates();
</code></pre>
<p>这还将同步任何多价订阅项目税率。 如果您的应用程序提供多价订阅，您应该确保您的计费模型实现了 <code>priceTaxRates</code> 方法 <a href="#subscription-taxes">如上所述</a>。</p>
<p><a name="tax-exemption"></a></p>
<h4 id="免税">免税</h4>
<p>Cashier 还提供了 <code>isNotTaxExempt</code>、<code>isTaxExempt</code> 和 <code>reverseChargeApplies</code> 方法来确定客户是否免税。 这些方法将调用 Stripe API 来确定客户的免税状态：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;isTaxExempt();
<span class="variable token">$user</span>-&gt;isNotTaxExempt();
<span class="variable token">$user</span>-&gt;reverseChargeApplies();
</code></pre>
<blockquote>
<p>注意：这些方法也适用于任何 <code>Laravel\Cashier\Invoice</code> 对象。 但是，当在“发票”对象上调用时，这些方法将在创建发票时确定豁免状态。</p>
</blockquote>
<p><a name="subscription-anchor-date"></a></p>
<h3 id="订阅锚定日期">订阅锚定日期</h3>
<p>默认情况下，计费周期锚点是订阅的创建日期，或者，如果使用试用期，则为试用结束的日期。 如果您想修改计费锚定日期，可以使用 <code>anchorBillingCycleOn</code> 方法：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::post(<span class="string token">'/user/subscribe'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="variable token">$anchor</span> = Carbon::parse(<span class="string token">'first day of next month'</span>);

    <span class="variable token">$request</span>-&gt;user()-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
                -&gt;anchorBillingCycleOn(<span class="variable token">$anchor</span>-&gt;startOfDay())
                -&gt;create(<span class="variable token">$request</span>-&gt;paymentMethodId);

    <span class="comment token">// ...</span>
});
</code></pre>
<p>有关管理订阅计费周期的更多信息，请参阅 <a href="https://stripe.com/docs/billing/subscriptions/billing-cycle">Stripe 计费周期文档</a></p>
<p><a name="cancelling-subscriptions"></a></p>
<h3 id="取消订阅">取消订阅</h3>
<p>要取消订阅，请在用户订阅上调用 <code>cancel</code> 方法：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;cancel();
</code></pre>
<p>取消订阅后，Cashier 会自动在您的 <code>subscriptions</code> 数据库表中设置 <code>ends_at</code> 列。 此列用于了解 <code>subscribed</code> 方法应该何时开始返回 <code>false</code>。</p>
<p>例如，如果客户在 3 月 1 日取消订阅，但订阅计划到 3 月 5 日才结束，则 <code>subscribed</code> 方法将继续返回 <code>true</code> 直到 3 月 5 日。 这样做是因为通常允许用户继续使用应用程序，直到他们的计费周期结束。</p>
<p>您可以使用 <code>onGracePeriod</code> 方法确定用户是否已取消订阅但仍处于“宽限期”：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;onGracePeriod()) {
    <span class="comment token">//</span>
}
</code></pre>
<p>如果您想立即取消订阅，请在用户订阅上调用 <code>cancelNow</code> 方法：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;cancelNow();
</code></pre>
<p>如果您希望立即取消订阅并为任何剩余的未开票计量使用或新的/待定的按比例发票项目开具发票，请在用户的订阅上调用 <code>cancelNowAndInvoice</code> 方法：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;cancelNowAndInvoice();
</code></pre>
<p>您也可以选择在特定时间取消订阅：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;cancelAt(
    now()-&gt;addDays(<span class="number token">10</span>)
);
</code></pre>
<p><a name="resuming-subscriptions"></a></p>
<h3 id="恢复订阅">恢复订阅</h3>
<p>如果客户取消了他们的订阅并且您希望恢复它，您可以在订阅上调用 <code>resume</code> 方法。 客户必须仍在其“宽限期”内才能恢复订阅：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;resume();
</code></pre>
<p>如果客户取消订阅，然后在订阅完全过期之前恢复订阅，则不会立即向客户收费。 相反，他们的订阅将被重新激活，并将按原始计费周期计费。</p>
<p><a name="subscription-trials"></a></p>
<h2 id="订阅-trials">订阅 Trials</h2>
<p><a name="with-payment-method-up-front"></a></p>
<h3 id="预先使用付款方式">预先使用付款方式</h3>
<p>如果您想为您的客户提供试用期，同时仍然预先收集付款方式信息，您应该在创建订阅时使用 <code>trialDays</code> 方法：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::post(<span class="string token">'/user/subscribe'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="variable token">$request</span>-&gt;user()-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
                -&gt;trialDays(<span class="number token">10</span>)
                -&gt;create(<span class="variable token">$request</span>-&gt;paymentMethodId);

    <span class="comment token">// ...</span>
});
</code></pre>
<p>此方法将在数据库中的订阅记录上设置试用期结束日期，并指示 Stripe 在此日期之后才开始向客户收费。 当使用 <code>trialDays</code> 方法时，Cashier 将覆盖为 Stripe 中的价格配置的任何默认试用期。</p>
<blockquote>
<p>注意：如果客户的订阅没有在试用期结束日期之前取消，他们将在试用期结束后立即收费，因此您应该确保通知您的用户他们的试用期结束日期。</p>
</blockquote>
<p><code>trialUntil</code> 方法允许你提供一个 <code>DateTime</code> 实例来指定试用期的结束时间：</p>
<pre><code><span class="keyword token">use</span> Carbon\Carbon;

<span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
            -&gt;trialUntil(Carbon::now()-&gt;addDays(<span class="number token">10</span>))
            -&gt;create(<span class="variable token">$paymentMethod</span>);
</code></pre>
<p>您可以使用用户实例的“onTrial”方法或订阅实例的“onTrial”方法来确定用户是否在试用期内。 下面的两个例子是等价的：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;onTrial(<span class="string token">'default'</span>)) {
    <span class="comment token">//</span>
}

<span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;onTrial()) {
    <span class="comment token">//</span>
}
</code></pre>
<p>您可以使用 <code>endTrial</code> 方法立即结束订阅试用：</p>
<pre><code><span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;endTrial();
</code></pre>
<p><a name="defining-trial-days-in-stripe-cashier"></a></p>
<h4 id="在-stripe-中定义试用天数--cashier">在 Stripe 中定义试用天数 / Cashier</h4>
<p>您可以选择在 Stripe 仪表板中定义您的价格收到多少试用天，或者始终使用 Cashier 明确传递它们。 如果您选择在 Stripe 中定义价格的试用天数，您应该知道新订阅（包括过去订阅过的客户的新订阅）将始终收到试用期，除非您明确调用 <code>skipTrial()</code> 方法.</p>
<p><a name="without-payment-method-up-front"></a></p>
<h3 id="没有预付款方式">没有预付款方式</h3>
<p>如果您想提供试用期而不预先收集用户的付款方式信息，您可以将用户记录上的“trial_ends_at”列设置为您想要的试用结束日期。 这通常在用户注册期间完成：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$user</span> = User::create([
    <span class="comment token">// ...</span>
    <span class="string token">'trial_ends_at'</span> =&gt; now()-&gt;addDays(<span class="number token">10</span>),
]);
</code></pre>
<blockquote>
<p>注意：请务必在计费模型的类定义中为 <code>trial_ends_at</code> 属性添加 <a href="eloquent-mutators.html##date-casting">日期转换</a>。</p>
</blockquote>
<p>Cashier 将这种类型的试用称为“通用试用”，因为它不附加到任何现有订阅。 如果当前日期未超过 <code>trial_ends_at</code> 的值，可计费模型实例上的 <code>onTrial</code> 方法将返回 <code>true</code>：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;onTrial()) {
    <span class="comment token">// 用户在试用期内...</span>
}
</code></pre>
<p>一旦你准备好为用户创建一个实际的订阅，你可以像往常一样使用<code>newSubscription</code>方法：</p>
<pre><code><span class="variable token">$user</span> = User::find(<span class="number token">1</span>);

<span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)-&gt;create(<span class="variable token">$paymentMethod</span>);
</code></pre>
<p>要检索用户的试用结束日期，您可以使用 <code>trialEndsAt</code> 方法。 如果用户正在试用，此方法将返回一个 Carbon 日期实例，如果不是，则返回“null”。 如果您想获取除默认订阅之外的特定订阅的试用结束日期，您还可以传递可选订阅名称参数：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;onTrial()) {
    <span class="variable token">$trialEndsAt</span> = <span class="variable token">$user</span>-&gt;trialEndsAt(<span class="string token">'main'</span>);
}
</code></pre>
<p>如果您想明确知道用户处于 “generic” 试用期并且尚未创建实际订阅，您也可以使用 <code>onGenericTrial</code> 方法：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;onGenericTrial()) {
    <span class="comment token">// 用户在他们的 “generic” 试用期内...</span>
}
</code></pre>
<p><a name="extending-trials"></a></p>
<h3 id="延长试用">延长试用</h3>
<p><code>extendTrial</code> 方法允许您在创建订阅后延长订阅的试用期。 如果试用期已经过期并且客户已经被收取订阅费用，您仍然可以为他们提供延长试用期。 试用期内花费的时间将从客户的下一张发票中扣除：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$subscription</span> = User::find(<span class="number token">1</span>)-&gt;subscription(<span class="string token">'default'</span>);

<span class="comment token">// 从现在起 7 天后结束试用...</span>
<span class="variable token">$subscription</span>-&gt;extendTrial(
    now()-&gt;addDays(<span class="number token">7</span>)
);

<span class="comment token">// 试用期再增加 5 天...</span>
<span class="variable token">$subscription</span>-&gt;extendTrial(
    <span class="variable token">$subscription</span>-&gt;trial_ends_at-&gt;addDays(<span class="number token">5</span>)
);
</code></pre>
<p><a name="handling-stripe-webhooks"></a></p>
<h2 id="处理-stripe-webhook">处理 Stripe webhook</h2>
<blockquote>
<p>技巧：您可以使用 <a href="https://stripe.com/docs/stripe-cli">the Stripe CLI</a> 在本地开发期间帮助测试 webhook。</p>
</blockquote>
<p>Stripe 可以通过 webhook 通知您的应用程序各种事件。 默认情况下，指向 Cashier 的 webhook 控制器的路由由 Cashier 服务提供者自动注册。 此控制器将处理所有传入的 webhook 请求。</p>
<p>默认情况下，Cashier webhook 控制器将自动处理取消订阅失败的次数过多（由您的 Stripe 设置定义）、客户更新、客户删除、订阅更新和付款方式更改； 然而，我们很快就会发现，你可以扩展这个控制器来处理你喜欢的任何 Stripe webhook 事件。</p>
<p>为确保您的应用程序可以处理 Stripe webhook，请务必在 Stripe 控制面板中配置 webhook URL。 默认情况下，Cashier 的 webhook 控制器响应 <code>/stripe/webhook</code> URL 路径。您应该在 Stripe 控制面板中启用的所有 webhook 的完整列表是：</p>
<ul>
<li><code>customer.subscription.created</code></li>
<li><code>customer.subscription.updated</code></li>
<li><code>customer.subscription.deleted</code></li>
<li><code>customer.updated</code></li>
<li><code>customer.deleted</code></li>
<li><code>invoice.payment_action_required</code></li>
</ul>
<p>为方便起见，Cashier 包含一个 <code>cashier:webhook</code> Artisan 命令。 此命令将在 Stripe 中创建一个 webhook，用于监听 Cashier 所需的所有事件：</p>
<pre><code class="language-shell">php artisan cashier:webhook
</code></pre>
<p>默认情况下，创建的 webhook 将指向由 <code>APP_URL</code> 环境变量和 Cashier 包含的 <code>cashier.webhook</code> 路由定义的 URL。 如果您想使用不同的 URL，可以在调用命令时提供 <code>--url</code> 选项：</p>
<pre><code class="language-shell">php artisan cashier:webhook --url &quot;https://example.com/stripe/webhook&quot;
</code></pre>
<p>创建的 webhook 将使用与您的 Cashier 版本兼容的 Stripe API 版本。 如果你想使用不同的 Stripe 版本，你可以提供 <code>--api-version</code> 选项：</p>
<pre><code class="language-shell">php artisan cashier:webhook --api-version=&quot;2019-12-03&quot;
</code></pre>
<p>创建后，webhook 将立即激活。 如果您希望创建 webhook 但在准备好之前将其禁用，您可以在调用命令时提供 <code>--disabled</code> 选项：</p>
<pre><code class="language-shell">php artisan cashier:webhook --disabled
</code></pre>
<blockquote>
<p>注意：确保使用 Cashier 包含的 <a href="#verifying-webhook-signatures">webhook 签名验证</a> 中间件保护传入的 Stripe webhook 请求。</p>
</blockquote>
<p><a name="webhooks-csrf-protection"></a></p>
<h4 id="webhook-和-csrf-保护">Webhook 和 CSRF 保护</h4>
<p>由于 Stripe webhook 需要绕过 Laravel 的 <a href="csrf.html">CSRF 保护</a>，因此请务必在应用程序的 <code>App\Http\Middleware\VerifyCsrfToken</code> 中间件中将 URI 列为异常或列出路由在 <code>web</code> 中间件组之外：</p>
<pre><code><span class="keyword token">protected</span> <span class="variable token">$except</span> = [
    <span class="string token">'stripe/*'</span>,
];
</code></pre>
<p><a name="defining-webhook-event-handlers"></a></p>
<h3 id="定义-webhook-事件处理程序">定义 webhook 事件处理程序</h3>
<p>Cashier 自动处理因收费失败和其他常见的 Stripe webhook 事件而取消的订阅。 但是，如果您有其他想要处理的 webhook 事件，您可以通过收听 Cashier 调度的以下事件来实现：</p>
<ul>
<li><code>Laravel\Cashier\Events\WebhookReceived</code></li>
<li><code>Laravel\Cashier\Events\WebhookHandled</code></li>
</ul>
<p>这两个事件都包含 Stripe webhook 的完整负载。 例如，如果你想处理 <code>invoice.payment_succeeded</code> webhook，你可以注册一个 <a href="events.html#defining-listeners">listener</a> 来处理事件：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Listeners;

<span class="keyword token">use</span> Laravel\Cashier\Events\WebhookReceived;

<span class="keyword token">class</span> StripeEventListener
{
    <span class="comment token">/**
     * 处理收到的 Stripe webhook。
     *
     *<span class="phpdoc token"> @param</span>  \Laravel\Cashier\Events\WebhookReceived  $event
     *<span class="phpdoc token"> @return</span> void
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> handle(WebhookReceived <span class="variable token">$event</span>)
    {
        <span class="keyword token">if</span> (<span class="variable token">$event</span>-&gt;payload[<span class="string token">'type'</span>] === <span class="string token">'invoice.payment_succeeded'</span>) {
            <span class="comment token">// 处理传入事件...</span>
        }
    }
}
</code></pre>
<p>一旦你的监听器被定义，你可以在你的应用程序的<code>EventServiceProvider</code>中注册它：</p>
<pre><code><span class="preprocessor token">&lt;?php</span>

<span class="keyword token">namespace</span> App\Providers;

<span class="keyword token">use</span> App\Listeners\StripeEventListener;
<span class="keyword token">use</span> Illuminate\Foundation\Support\Providers\EventServiceProvider <span class="keyword token">as</span> ServiceProvider;
<span class="keyword token">use</span> Laravel\Cashier\Events\WebhookReceived;

<span class="keyword token">class</span> EventServiceProvider <span class="keyword token">extends</span> ServiceProvider
{
    <span class="keyword token">protected</span> <span class="variable token">$listen</span> = [
        WebhookReceived::<span class="keyword token">class</span> =&gt; [
            StripeEventListener::<span class="keyword token">class</span>,
        ],
    ];
}
</code></pre>
<p><a name="verifying-webhook-signatures"></a></p>
<h3 id="验证-webhook-签名">验证 Webhook 签名</h3>
<p>为了保护您的 webhook，您可以使用 <a href="https://stripe.com/docs/webhooks/signatures">Stripe 的 webhook 签名</a>。 为方便起见，Cashier 自动包含一个中间件，用于验证传入的 Stripe webhook 请求是否有效。</p>
<p>要启用 webhook 验证，请确保在应用程序的 .env 文件中设置了 <code>STRIPE_WEBHOOK_SECRET</code> 环境变量。 可以从您的 Stripe 帐户仪表板中检索 webhook <code>secret</code>。</p>
<p><a name="single-charges"></a></p>
<h2 id="单次-charges">单次 Charges</h2>
<p><a name="simple-charge"></a></p>
<h3 id="简单-charge">简单 Charge</h3>
<blockquote>
<p>注意：<code>charge</code> 方法接受您希望以应用程序使用的货币的最低分母收取的金额。例如，使用美元时，金额应以便士表示。</p>
</blockquote>
<p>如果您想向客户一次性收费，您可以在可计费模型实例上使用 <code>charge</code> 方法。您需要[提供付款方式标识符]（#单笔费用的付款方式）作为 <code>charge</code> 方法的第二个参数：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::post(<span class="string token">'/purchase'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="variable token">$stripeCharge</span> = <span class="variable token">$request</span>-&gt;user()-&gt;charge(
        <span class="number token">100</span>, <span class="variable token">$request</span>-&gt;paymentMethodId
    );

    <span class="comment token">// ...</span>
});
</code></pre>
<p><code>charge</code> 方法接受一个数组作为它的第三个参数，允许您将任何您希望的选项传递给底层的 Stripe 电荷创建。 有关创建费用时可用选项的更多信息，请参阅 <a href="https://stripe.com/docs/api/charges/create">Stripe 文档</a>：</p>
<pre><code><span class="variable token">$user</span>-&gt;charge(<span class="number token">100</span>, <span class="variable token">$paymentMethod</span>, [
    <span class="string token">'custom_option'</span> =&gt; <span class="variable token">$value</span>,
]);
</code></pre>
<p>您也可以在没有潜在客户或用户的情况下使用“收费”方法。 为此，请在应用程序的计费模型的新实例上调用 <code>charge</code> 方法：</p>
<pre><code><span class="keyword token">use</span> App\Models\User;

<span class="variable token">$stripeCharge</span> = (<span class="keyword token">new</span> User)-&gt;charge(<span class="number token">100</span>, <span class="variable token">$paymentMethod</span>);
</code></pre>
<p>如果充电失败，<code>charge</code> 方法会抛出异常。 如果收费成功，方法会返回一个 <code>Laravel\Cashier\Payment</code> 的实例：</p>
<pre><code><span class="keyword token">try</span> {
    <span class="variable token">$payment</span> = <span class="variable token">$user</span>-&gt;charge(<span class="number token">100</span>, <span class="variable token">$paymentMethod</span>);
} <span class="keyword token">catch</span> (<span class="keyword token">Exception</span> <span class="variable token">$e</span>) {
    <span class="comment token">//</span>
}
</code></pre>
<p><a name="charge-with-invoice"></a></p>
<h3 id="用发票收费">用发票收费</h3>
<p>有时您可能需要一次性收费并向客户提供 PDF 收据。 <code>invoicePrice</code> 方法可以让你做到这一点。 例如，让我们为客户开具五件新衬衫的发票：</p>
<pre><code><span class="variable token">$user</span>-&gt;invoicePrice(<span class="string token">'price_tshirt'</span>, <span class="number token">5</span>);
</code></pre>
<p>发票将立即根据用户的默认付款方式收取。 <code>invoicePrice</code> 方法也接受一个数组作为它的第三个参数。 此数组包含发票项目的计费选项。 该方法接受的第四个参数也是一个数组，其中应包含发票本身的计费选项：</p>
<pre><code><span class="variable token">$user</span>-&gt;invoicePrice(<span class="string token">'price_tshirt'</span>, <span class="number token">5</span>, [
    <span class="string token">'discounts'</span> =&gt; [
        [<span class="string token">'coupon'</span> =&gt; <span class="string token">'SUMMER21SALE'</span>]
    ],
], [
    <span class="string token">'default_tax_rates'</span> =&gt; [<span class="string token">'txr_id'</span>],
]);
</code></pre>
<p>或者，您可以使用 <code>invoiceFor</code> 方法对客户的默认付款方式进行“一次性”收费：</p>
<pre><code><span class="variable token">$user</span>-&gt;invoiceFor(<span class="string token">'One Time Fee'</span>, <span class="number token">500</span>);
</code></pre>
<p>虽然 <code>invoiceFor</code> 方法可供您使用，但建议您使用具有预定义价格的 <code>invoicePrice</code> 方法。 通过这样做，您将可以在您的 Stripe 仪表板中访问更好的分析和数据，以了解您在每个产品的基础上的销售情况。</p>
<blockquote>
<p>注意：<code>invoicePrice</code> 和 <code>invoiceFor</code> 方法将创建一个 Stripe 发票，该发票将重试失败的计费尝试。 如果您不希望发票重试失败的费用，则需要在第一次失败的费用后使用 Stripe API 关闭它们。</p>
</blockquote>
<p><a name="refunding-charges"></a></p>
<h3 id="退款费用">退款费用</h3>
<p>如果您需要退还 Stripe 费用，您可以使用 <code>refund</code> 方法。 此方法接受 Stripe <a href="#payment-methods-for-single-charges">payment intent ID</a> 作为其第一个参数：</p>
<pre><code><span class="variable token">$payment</span> = <span class="variable token">$user</span>-&gt;charge(<span class="number token">100</span>, <span class="variable token">$paymentMethodId</span>);

<span class="variable token">$user</span>-&gt;refund(<span class="variable token">$payment</span>-&gt;id);
</code></pre>
<p><a name="invoices"></a></p>
<h2 id="发票">发票</h2>
<p><a name="retrieving-invoices"></a></p>
<h3 id="检索发票">检索发票</h3>
<p>您可以使用 <code>invoices</code> 方法轻松检索可计费模型的发票数组。 <code>invoices</code> 方法返回 <code>Laravel\Cashier\Invoice</code> 实例的集合：</p>
<pre><code><span class="variable token">$invoices</span> = <span class="variable token">$user</span>-&gt;invoices();
</code></pre>
<p>如果您想在结果中包含待处理的发票，您可以使用 <code>invoicesIncludingPending</code> 方法：</p>
<pre><code><span class="variable token">$invoices</span> = <span class="variable token">$user</span>-&gt;invoicesIncludingPending();
</code></pre>
<p>您可以使用 <code>findInvoice</code> 方法通过其 ID 检索特定发票：</p>
<pre><code><span class="variable token">$invoice</span> = <span class="variable token">$user</span>-&gt;findInvoice(<span class="variable token">$invoiceId</span>);
</code></pre>
<p><a name="displaying-invoice-information"></a></p>
<h4 id="显示发票信息">显示发票信息</h4>
<p>在为客户列出发票时，您可以使用发票的方法显示相关的发票信息。 例如，您可能希望在表格中列出每张发票，以便用户轻松下载其中任何一张：</p>
<pre><code>&lt;table&gt;
    @<span class="keyword token">foreach</span> (<span class="variable token">$invoices</span> <span class="keyword token">as</span> <span class="variable token">$invoice</span>)
        &lt;tr&gt;
            &lt;td&gt;{{ <span class="variable token">$invoice</span>-&gt;date()-&gt;toFormattedDateString() }}&lt;/td&gt;
            &lt;td&gt;{{ <span class="variable token">$invoice</span>-&gt;total() }}&lt;/td&gt;
            &lt;td&gt;&lt;a href=<span class="string token">"/user/invoice/{{ $invoice-&gt;id }}"</span>&gt;Download&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
    @<span class="keyword token">endforeach</span>
&lt;/table&gt;
</code></pre>
<p><a name="upcoming-invoices"></a></p>
<h3 id="进货发票">进货发票</h3>
<p>要检索客户即将收到的发票，您可以使用 <code>upcomingInvoice</code> 方法：</p>
<pre><code><span class="variable token">$invoice</span> = <span class="variable token">$user</span>-&gt;upcomingInvoice();
</code></pre>
<p>类似地，如果客户有多个订阅，您还可以检索特定订阅的即将到来的发票：</p>
<pre><code><span class="variable token">$invoice</span> = <span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;upcomingInvoice();
</code></pre>
<p><a name="previewing-subscription-invoices"></a></p>
<h3 id="预览订阅发票">预览订阅发票</h3>
<p>使用 <code>previewInvoice</code> 方法，您可以在更改价格之前预览发票。 这将允许您确定在进行给定价格更改时客户发票的外观：</p>
<pre><code><span class="variable token">$invoice</span> = <span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;previewInvoice(<span class="string token">'price_yearly'</span>);
</code></pre>
<p>您可以将一组价格传递给 <code>previewInvoice</code> 方法，以便预览具有多个新价格的发票：
    $invoice = $user-&gt;subscription(&#39;default&#39;)-&gt;previewInvoice([&#39;price_yearly&#39;, &#39;price_metered&#39;]);</p>
<p><a name="generating-invoice-pdfs"></a></p>
<h3 id="生成发票-pdf">生成发票 PDF</h3>
<p>在路由或控制器中，您可以使用 <code>downloadInvoice</code> 方法生成给定发票的 PDF 下载。 此方法将自动生成下载发票所需的正确 HTTP 响应：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/user/invoice/{invoice}'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>, <span class="variable token">$invoiceId</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;downloadInvoice(<span class="variable token">$invoiceId</span>, [
        <span class="string token">'vendor'</span> =&gt; <span class="string token">'Your Company'</span>,
        <span class="string token">'product'</span> =&gt; <span class="string token">'Your Product'</span>,
    ]);
});
</code></pre>
<p>默认情况下，发票上的所有数据都来自存储在 Stripe 中的客户和发票数据。 但是，您可以通过提供一个数组作为 <code>downloadInvoice</code> 方法的第二个参数来自定义其中的一些数据。 此数组允许您自定义信息，例如您的公司和产品详细信息：</p>
<pre><code><span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;downloadInvoice(<span class="variable token">$invoiceId</span>, [
    <span class="string token">'vendor'</span> =&gt; <span class="string token">'Your Company'</span>,
    <span class="string token">'product'</span> =&gt; <span class="string token">'Your Product'</span>,
    <span class="string token">'street'</span> =&gt; <span class="string token">'Main Str. 1'</span>,
    <span class="string token">'location'</span> =&gt; <span class="string token">'2000 Antwerp, Belgium'</span>,
    <span class="string token">'phone'</span> =&gt; <span class="string token">'+32 499 00 00 00'</span>,
    <span class="string token">'email'</span> =&gt; <span class="string token">'info@example.com'</span>,
    <span class="string token">'url'</span> =&gt; <span class="string token">'https://example.com'</span>,
    <span class="string token">'vendorVat'</span> =&gt; <span class="string token">'BE123456789'</span>,
], <span class="string token">'my-invoice'</span>);
</code></pre>
<p><code>downloadInvoice</code> 方法还允许通过其第三个参数自定义文件名。 此文件名将自动以 <code>.pdf</code> 为后缀：</p>
<pre><code><span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;downloadInvoice(<span class="variable token">$invoiceId</span>, [], <span class="string token">'my-invoice'</span>);
</code></pre>
<p><a name="custom-invoice-render"></a></p>
<h4 id="自定义发票渲染器">自定义发票渲染器</h4>
<p>Cashier 还可以使用自定义发票渲染器。 默认情况下，Cashier 使用 <code>DompdfInvoiceRenderer</code> 实现，它利用 <a href="https://github.com/dompdf/dompdf">dompdf</a> PHP 库来生成 Cashier 的发票。 但是，你可以通过实现 <code>Laravel\Cashier\Contracts\InvoiceRenderer</code> 接口来使用任何你想要的渲染器。 例如，您可能希望使用对第三方 PDF 呈现服务的 API 调用来呈现发票 PDF：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Support\Facades\Http;
<span class="keyword token">use</span> Laravel\Cashier\Contracts\InvoiceRenderer;
<span class="keyword token">use</span> Laravel\Cashier\Invoice;

<span class="keyword token">class</span> ApiInvoiceRenderer <span class="keyword token">implements</span> InvoiceRenderer
{
    <span class="comment token">/**
     * 呈现给定的发票并返回原始 PDF 字节。
     *
     *<span class="phpdoc token"> @param</span>  \Laravel\Cashier\Invoice. $invoice
     *<span class="phpdoc token"> @param</span>  array  $data
     *<span class="phpdoc token"> @param</span>  array  $options
     *<span class="phpdoc token"> @return</span> string
     */</span>
    <span class="keyword token">public</span> <span class="keyword token">function</span> render(Invoice <span class="variable token">$invoice</span>, <span class="keyword token">array</span> <span class="variable token">$data</span> = [], <span class="keyword token">array</span> <span class="variable token">$options</span> = []): string
    {
        <span class="variable token">$html</span> = <span class="variable token">$invoice</span>-&gt;view(<span class="variable token">$data</span>)-&gt;render();

        <span class="keyword token">return</span> Http::get(<span class="string token">'https://example.com/html-to-pdf'</span>, [<span class="string token">'html'</span> =&gt; <span class="variable token">$html</span>])-&gt;get()-&gt;body();
    }
}
</code></pre>
<p>一旦你实现了发票渲染器合约，你应该在你的应用程序的 config/cashier.php 配置文件中更新 <code>cashier.invoices.renderer</code> 配置值。 此配置值应设置为自定义渲染器实现的类名。</p>
<p><a name="checkout"></a></p>
<h2 id="结账">结账</h2>
<p>Cashier Stripe 还提供对 <a href="https://stripe.com/payments/checkout">Stripe Checkout</a> 的支持。 Stripe Checkout 通过提供预构建的托管支付页面，消除了实施自定义页面以接受付款的痛苦。</p>
<p>以下文档包含有关如何开始使用 Stripe Checkout with Cashier 的信息。 要了解有关 Stripe Checkout 的更多信息，您还应该考虑查看 <a href="https://stripe.com/docs/payments/checkout">Stripe 自己的 Checkout 文档</a>。</p>
<p><a name="product-checkouts"></a></p>
<h3 id="产品结账">产品结账</h3>
<p>您可以在计费模型上使用“checkout”方法对已在 Stripe 仪表板中创建的现有产品执行结帐。 <code>checkout</code> 方法将启动一个新的 Stripe Checkout 会话。 默认情况下，您需要传递 Stripe Price ID：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/product-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;checkout(<span class="string token">'price_tshirt'</span>);
});
</code></pre>
<p>如果需要，您还可以指定产品数量：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/product-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;checkout([<span class="string token">'price_tshirt'</span> =&gt; <span class="number token">15</span>]);
});
</code></pre>
<p>当客户访问此路线时，他们将被重定向到 Stripe 的结帐页面。 默认情况下，当用户成功完成或取消购买时，他们将被重定向到您的 <code>home</code> 路由位置，但您可以使用 <code>success_url</code> 和 <code>cancel_url</code> 选项指定自定义回调 URL：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/product-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;checkout([<span class="string token">'price_tshirt'</span> =&gt; <span class="number token">1</span>], [
        <span class="string token">'success_url'</span> =&gt; route(<span class="string token">'your-success-route'</span>),
        <span class="string token">'cancel_url'</span> =&gt; route(<span class="string token">'your-cancel-route'</span>),
    ]);
});
</code></pre>
<p>在定义 <code>success_url</code> 结帐选项时，您可以指示 Stripe 在调用 URL 时将结帐会话 ID 添加为查询字符串参数。 为此，请将文字字符串 <code>{CHECKOUT_SESSION_ID}</code> 添加到您的 <code>success_url</code> 查询字符串。Stripe 将用实际的结帐会话 ID 替换此占位符：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;
<span class="keyword token">use</span> Stripe\Checkout\Session;
<span class="keyword token">use</span> Stripe\Customer;

Route::get(<span class="string token">'/product-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;checkout([<span class="string token">'price_tshirt'</span> =&gt; <span class="number token">1</span>], [
        <span class="string token">'success_url'</span> =&gt; route(<span class="string token">'checkout-success'</span>) . <span class="string token">'?session_id={CHECKOUT_SESSION_ID}'</span>,
        <span class="string token">'cancel_url'</span> =&gt; route(<span class="string token">'checkout-cancel'</span>),
    ]);
});

Route::get(<span class="string token">'/checkout-success'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="variable token">$checkoutSession</span> = <span class="variable token">$request</span>-&gt;user()-&gt;stripe()-&gt;checkout-&gt;sessions-&gt;retrieve(<span class="variable token">$request</span>-&gt;get(<span class="string token">'session_id'</span>));

    <span class="keyword token">return</span> view(<span class="string token">'checkout.success'</span>, [<span class="string token">'checkoutSession'</span> =&gt; <span class="variable token">$checkoutSession</span>]);
})-&gt;name(<span class="string token">'checkout-success'</span>);
</code></pre>
<p><a name="checkout-promotion-codes"></a></p>
<h4 id="兑换码">兑换码</h4>
<p>默认情况下，Stripe Checkout 不允许 <a href="https://stripe.com/docs/billing/subscriptions/discounts/codes">用户可兑换促销代码</a>。 幸运的是，有一种简单的方法可以为您的结帐页面启用这些功能。 为此，您可以调用 <code>allowPromotionCodes</code> 方法：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/product-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()
        -&gt;allowPromotionCodes()
        -&gt;checkout(<span class="string token">'price_tshirt'</span>);
});
</code></pre>
<p><a name="single-charge-checkouts"></a></p>
<h3 id="单次收费结账">单次收费结账</h3>
<p>您还可以对尚未在 Stripe 仪表板中创建的临时产品进行简单收费。 为此，您可以在计费模型上使用 <code>checkoutCharge</code> 方法，并向其传递可计费金额、产品名称和可选数量。 当客户访问此路线时，他们将被重定向到 Stripe 的结帐页面：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/charge-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()-&gt;checkoutCharge(<span class="number token">1200</span>, <span class="string token">'T-Shirt'</span>, <span class="number token">5</span>);
});
</code></pre>
<blockquote>
<p>注意：当使用 <code>checkoutCharge</code> 方法时，Stripe 将始终在您的 Stripe 仪表板中创建新产品和价格。 因此，我们建议您在 Stripe 仪表板中预先创建产品，并改用 <code>checkout</code> 方法。</p>
</blockquote>
<p><a name="subscription-checkouts"></a></p>
<h3 id="订阅结帐">订阅结帐</h3>
<blockquote>
<p>注意：使用 Stripe Checkout 进行订阅需要您在 Stripe 仪表板中启用 <code>customer.subscription.created</code> webhook。 此 webhook 将在您的数据库中创建订阅记录并存储所有相关的订阅项。</p>
</blockquote>
<p>您也可以使用 Stripe Checkout 来启动订阅。 在使用 Cashier 的订阅构建器方法定义您的订阅后，您可以调用 <code>checkout </code> 方法。 当客户访问此路线时，他们将被重定向到 Stripe 的结帐页面：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/subscription-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()
        -&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
        -&gt;checkout();
});
</code></pre>
<p>与产品结帐一样，您可以自定义成功和取消 URL：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/subscription-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()
        -&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
        -&gt;checkout([
            <span class="string token">'success_url'</span> =&gt; route(<span class="string token">'your-success-route'</span>),
            <span class="string token">'cancel_url'</span> =&gt; route(<span class="string token">'your-cancel-route'</span>),
        ]);
});
</code></pre>
<p>当然，您也可以为订阅结帐启用促销代码：</p>
<pre><code><span class="keyword token">use</span> Illuminate\Http\Request;

Route::get(<span class="string token">'/subscription-checkout'</span>, <span class="keyword token">function</span> (Request <span class="variable token">$request</span>) {
    <span class="keyword token">return</span> <span class="variable token">$request</span>-&gt;user()
        -&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
        -&gt;allowPromotionCodes()
        -&gt;checkout();
});
</code></pre>
<blockquote>
<p>注意：不幸的是，在开始订阅时，Stripe Checkout 不支持所有订阅计费选项。 在订阅生成器上使用 <code>anchorBillingCycleOn</code> 方法、设置按比例分配行为或设置支付行为在 Stripe Checkout 会话期间不会有任何影响。 请查阅 <a href="https://stripe.com/docs/api/checkout/sessions/create">Stripe Checkout Session API 文档</a> 以查看可用的参数。</p>
</blockquote>
<p><a name="stripe-checkout-trial-periods"></a></p>
<h4 id="条纹结帐和试用期">条纹结帐和试用期</h4>
<p>当然，您可以在构建将使用 Stripe Checkout 完成的订阅时定义试用期：</p>
<pre><code><span class="variable token">$checkout</span> = Auth::user()-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
    -&gt;trialDays(<span class="number token">3</span>)
    -&gt;checkout();
</code></pre>
<p>但是，试用期必须至少为 48 小时，这是 Stripe Checkout 支持的最短试用时间。</p>
<p><a name="stripe-checkout-subscriptions-and-webhooks"></a></p>
<h4 id="subscriptions--webhooks">Subscriptions &amp; Webhooks</h4>
<p>请记住，Stripe 和 Cashier 通过 webhook 更新订阅状态，因此当客户在输入付款信息后返回应用程序时，订阅可能尚未激活。 要处理这种情况，您可能希望显示一条消息，通知用户他们的付款或订阅处于待处理状态。</p>
<p><a name="collecting-tax-ids"></a></p>
<h3 id="收税id">收税ID</h3>
<p>Checkout 还支持收集客户的税号。 要在结帐会话上启用此功能，请在创建会话时调用 <code>collectTaxIds</code> 方法：</p>
<pre><code><span class="variable token">$checkout</span> = <span class="variable token">$user</span>-&gt;collectTaxIds()-&gt;checkout(<span class="string token">'price_tshirt'</span>);
</code></pre>
<p>调用此方法时，客户可以使用一个新的复选框，允许他们指示他们是否作为公司进行采购。 如果是这样，他们将有机会提供他们的税号。</p>
<blockquote>
<p>注意：如果您已经在应用程序的服务提供者中配置了<a href="#tax-configuration">自动征税</a>，那么该功能将自动启用，无需调用 <code>collectTaxIds</code> 方法。</p>
</blockquote>
<p><a name="handling-failed-payments"></a></p>
<h2 id="处理失败的付款">处理失败的付款</h2>
<p>有时，订阅或单笔费用的付款可能会失败。 当这种情况发生时，Cashier 会抛出一个 <code>Laravel\Cashier\Exceptions\IncompletePayment</code> 异常，通知你发生了这种情况。 捕获此异常后，您有两个选择如何继续。</p>
<p>首先，您可以将您的客户重定向到 Cashier 附带的专用付款确认页面。 该页面已经有一个通过 Cashier 的服务提供商注册的关联命名路由。 因此，您可能会捕获 <code>IncompletePayment</code> 异常并将用户重定向到付款确认页面：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Exceptions\IncompletePayment;

<span class="keyword token">try</span> {
    <span class="variable token">$subscription</span> = <span class="variable token">$user</span>-&gt;newSubscription(<span class="string token">'default'</span>, <span class="string token">'price_monthly'</span>)
                            -&gt;create(<span class="variable token">$paymentMethod</span>);
} <span class="keyword token">catch</span> (IncompletePayment <span class="variable token">$exception</span>) {
    <span class="keyword token">return</span> redirect()-&gt;route(
        <span class="string token">'cashier.payment'</span>,
        [<span class="variable token">$exception</span>-&gt;payment-&gt;id, <span class="string token">'redirect'</span> =&gt; route(<span class="string token">'home'</span>)]
    );
}
</code></pre>
<p>在付款确认页面上，将提示客户再次输入他们的信用卡信息并执行 Stripe 要求的任何其他操作，例如“3D Secure”确认。 确认付款后，用户将被重定向到上面指定的 <code>redirect</code> 参数提供的 URL。 重定向后，“message”（字符串）和“success”（整数）查询字符串变量将被添加到 URL。 支付页面目前支持以下支付方式类型：</p>
<div class="content-list" markdown="1">

<ul>
<li>Credit Cards</li>
<li>Alipay</li>
<li>Bancontact</li>
<li>BECS Direct Debit</li>
<li>EPS</li>
<li>Giropay</li>
<li>iDEAL</li>
<li>SEPA Direct Debit</li>
</ul>
</div>



<p>或者，您可以让 Stripe 为您处理付款确认。在这种情况下，您可以在 Stripe 控制面板中<a href="https://dashboard.stripe.com/account/billing/automatic">设置 Stripe 的自动结算电子邮件</a>，而不是重定向到付款确认页面。但是，如果捕获到 <code>IncompletePayment</code> 异常，您仍应通知用户他们将收到一封包含进一步付款确认说明的电子邮件。</p>
<p>对于使用 <code>Billable</code> 特征的模型，可能会为以下方法引发付款异常：<code>charge</code>、<code>invoiceFor</code> 和 <code>invoice</code>。与订阅交互时，<code>SubscriptionBuilder</code> 上的 <code>create</code> 方法，以及 <code>Subscription</code> 和 <code>SubscriptionItem</code> 模型上的 <code>incrementAndInvoice</code> 和 <code>swapAndInvoice</code> 方法可能会抛出不完整的支付异常。</p>
<p>可以使用计费模型或订阅实例上的“hasIncompletePayment”方法来确定现有订阅是否有不完整的付款：</p>
<pre><code><span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;hasIncompletePayment(<span class="string token">'default'</span>)) {
    <span class="comment token">//</span>
}

<span class="keyword token">if</span> (<span class="variable token">$user</span>-&gt;subscription(<span class="string token">'default'</span>)-&gt;hasIncompletePayment()) {
    <span class="comment token">//</span>
}
</code></pre>
<p>您可以通过检查异常实例上的 <code>payment</code> 属性来得出未完成付款的具体状态：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Exceptions\IncompletePayment;

<span class="keyword token">try</span> {
    <span class="variable token">$user</span>-&gt;charge(<span class="number token">1000</span>, <span class="string token">'pm_card_threeDSecure2Required'</span>);
} <span class="keyword token">catch</span> (IncompletePayment <span class="variable token">$exception</span>) {
    <span class="comment token">// 获取付款意向状态...</span>
    <span class="variable token">$exception</span>-&gt;payment-&gt;status;

    <span class="comment token">// 检查具体情况...</span>
    <span class="keyword token">if</span> (<span class="variable token">$exception</span>-&gt;payment-&gt;requiresPaymentMethod()) {
        <span class="comment token">// ...</span>
    } <span class="keyword token">elseif</span> (<span class="variable token">$exception</span>-&gt;payment-&gt;requiresConfirmation()) {
        <span class="comment token">// ...</span>
    }
}
</code></pre>
<p><a name="strong-customer-authentication"></a></p>
<h2 id="强大的客户认证">强大的客户认证</h2>
<p>如果您的企业或您的一位客户位于欧洲，您将需要遵守欧盟的强客户认证 (SCA) 法规。 这些规定由欧盟于 2019 年 9 月实施，以防止支付欺诈。 幸运的是，Stripe 和 Cashier 已准备好构建符合 SCA 的应用程序。</p>
<blockquote>
<p>注意：在开始之前，请查看 <a href="https://stripe.com/guides/strong-customer-authentication">关于 PSD2 和 SCA 的 Stripe 指南</a> 以及他们的 [关于新 SCA API 的文档](<a href="https://stripe.com">https://stripe.com</a> /docs/strong-customer-authentication）。</p>
</blockquote>
<p><a name="payments-requiring-additional-confirmation"></a></p>
<h3 id="需要额外确认的付款">需要额外确认的付款</h3>
<p>SCA 法规通常需要额外的验证才能确认和处理付款。 当这种情况发生时，Cashier 会抛出一个 <code>Laravel\Cashier\Exceptions\IncompletePayment</code> 异常，通知你需要额外的验证。 有关如何处理这些异常的更多信息，请参阅有关 <a href="#handling-failed-payments">处理失败的付款</a> 的文档。</p>
<p>Stripe 或 Cashier 提供的支付确认屏幕可能会针对特定银行或发卡机构的支付流程进行定制，并且可能包括额外的卡确认、临时小额费用、单独的设备身份验证或其他形式的验证。</p>
<p><a name="incomplete-and-past-due-state"></a></p>
<h4 id="不完整和逾期状态">不完整和逾期状态</h4>
<p>当付款需要额外确认时，订阅将保持在“未完成”或“过去到期”状态，如“stripe_status”数据库列所示。 付款确认完成后，Cashier 将自动激活客户的订阅，并且 Stripe 通过 webhook 通知您的应用程序完成。</p>
<p>有关 <code>incomplete</code> 和 <code>past_due</code> 状态的更多信息，请参阅 <a href="#incomplete-and-past-due-status">我们关于这些状态的附加文档</a>。</p>
<p><a name="off-session-payment-notifications"></a></p>
<h3 id="场外付款通知">场外付款通知</h3>
<p>由于 SCA 法规要求客户即使在订阅处于活动状态时也偶尔验证其付款详细信息，因此当需要确认会话外付款时，Cashier 可以向客户发送通知。 例如，这可能在续订订阅时发生。 可以通过将 <code>CASHIER_PAYMENT_NOTIFICATION</code> 环境变量设置为通知类来启用收银员的付款通知。 默认情况下，此通知被禁用。 当然，Cashier 包含一个您可以用于此目的的通知类，但如果需要，您可以自由地提供自己的通知类：</p>
<pre><code class="language-ini">CASHIER_PAYMENT_NOTIFICATION=Laravel\Cashier\Notifications\ConfirmPayment
</code></pre>
<p>为确保发送会话外付款确认通知，请确认您的应用程序的 <a href="#handling-stripe-webhooks">Stripe webhook 已配置</a> 并且在您的 Stripe 仪表板中启用了 <code>invoice.payment_action_required</code> webhook。 此外，你的 <code>Billable</code> 模型也应该使用 Laravel 的 <code>Illuminate\Notifications\Notifiable</code> trait。</p>
<blockquote>
<p>注意：即使客户手动进行需要额外确认的付款，也会发送通知。 不幸的是，Stripe 无法知道付款是手动完成的还是“非会话”完成的。 但是，如果客户在确认付款后访问付款页面，他们只会看到“付款成功”消息。 不允许客户意外确认两次相同的付款并导致意外的第二次收费。</p>
</blockquote>
<p><a name="stripe-sdk"></a></p>
<h2 id="stripe-sdk">Stripe SDK</h2>
<p>Cashier 的许多对象都是 Stripe SDK 对象的包装器。 如果您想直接与 Stripe 对象交互，您可以使用 <code>asStripe</code> 方法方便地检索它们：</p>
<pre><code><span class="variable token">$stripeSubscription</span> = <span class="variable token">$subscription</span>-&gt;asStripeSubscription();

<span class="variable token">$stripeSubscription</span>-&gt;application_fee_percent = <span class="number token">5</span>;

<span class="variable token">$stripeSubscription</span>-&gt;save();
</code></pre>
<p>您也可以使用 <code>updateStripeSubscription</code> 方法直接更新 Stripe 订阅：</p>
<pre><code><span class="variable token">$subscription</span>-&gt;updateStripeSubscription([<span class="string token">'application_fee_percent'</span> =&gt; <span class="number token">5</span>]);
</code></pre>
<p>如果您想直接使用 <code>Stripe\StripeClient</code> 客户端，可以调用 <code>Cashier</code> 类的 <code>stripe</code> 方法。 例如，您可以使用此方法访问“StripeClient”实例并从您的 Stripe 帐户中检索价格列表：</p>
<pre><code><span class="keyword token">use</span> Laravel\Cashier\Cashier;

<span class="variable token">$prices</span> = Cashier::stripe()-&gt;prices-&gt;all();
</code></pre>
<p><a name="testing"></a></p>
<h2 id="测试">测试</h2>
<p>在测试使用 Cashier 的应用程序时，您可以模拟对 Stripe API 的实际 HTTP 请求； 但是，这需要您部分地重新实现 Cashier 自己的行为。 因此，我们建议允许您的测试使用实际的 Stripe API。 虽然速度较慢，但是它可以让您更加确信您的应用程序正在按预期工作，并且任何慢速测试都可以放在他们自己的 PHPUnit 测试组中。</p>
<p>测试时，请记住 Cashier 本身已经有一个很棒的测试套件，因此您应该只专注于测试您自己的应用程序的订阅和支付流程，而不是每个底层的 Cashier 行为。</p>
<p>首先，将 Stripe 密钥的 <strong>testing</strong> 版本添加到您的 <code>phpunit.xml</code> 文件中：</p>
<pre><code>&lt;env name="STRIPE_SECRET" value="sk_test_&lt;your-key&gt;"/&gt;
</code></pre>
<p>现在，每当您在测试时与 Cashier 交互时，它都会向您的 Stripe 测试环境发送实际的 API 请求。为方便起见，您应该使用您可能在测试期间使用的订阅 / 计划预先填写您的 Stripe 测试帐户。</p>
<blockquote>
<p>技巧：为了测试各种计费场景，例如信用卡拒付和失败，您可以使用 Stripe 提供的大量的 <a href="https://stripe.com/docs/testing">测试卡号和令牌</a> 。</p>
</blockquote>
</div>
    <blockquote style="font-size: 0.9em;">
        本译文仅用于学习和交流目的，转载请务必注明文章译者、出处、和本文链接 <br>
        我们的翻译工作遵照 <a href="https://learnku.com/docs/guide/cc4.0/6589">CC 协议</a>，如果我们的工作有侵犯到您的权益，请及时联系我们。
    </blockquote>
</body>

</html>
