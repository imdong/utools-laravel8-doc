[{"t":"releases (发行说明)","d":"# 发行说明\r\n\r\n- [版本化方案](#versioning-scheme)\r\n- [支持策略](#support-policy)\r\n- [Laravel 9](#laravel-9)\r\n\r\n<a name=\"versioning-scheme\"></a>\r\n## 版本化方案\r\n\r\nLaravel 及官方发布的包皆遵循 [语义化版本](https://semver.org)。主要的框架版本每年「2 月」发布，而次要的和补丁版本可能每周发布一次。次要版本和修补程序版本应 **从不** 包含非兼容性的更改。\r\n\r\n你从应用或包中引用 Laravel 框架或其组件时，应始终使用版本约束，如 `^9.0`，因为 Laravel 的主要版本确实包含非兼容性更改。但是，我们努力确保您可以在一天或更短的时间内更新到新的主要版本。\r\n\r\n<a name=\"named-arguments\"></a>\r\n#### 命名参数\r\n\r\n目前，PHP 的 [命名参数](https://www.php.net/manual/zh/functions.arguments.php#functions.named-arguments)  功能还没有被 Laravel 的向后兼容性指南所涵盖。我们可以在必要时选择重命名函数参数，以改进 Laravel 代码库。因此，在调用 Laravel 方法时使用命名参数应该谨慎，并且要理解参数名将来可能会改变。\r\n\r\n<a name=\"support-policy\"></a>\r\n## 支持策略\r\n\r\n对于所有 Laravel 发行版本，BUG 修复的期限为 18 个月，安全修复的期限为 2 年。对于包括 Lumen 在内的所有额外的库，只有最新的版本才会得到 BUG 修复。此外，请查阅 Laravel 支持的 [数据库版本](/docs/laravel/9.x/database#introduction)。\r\n\r\n\r\n\r\n<table><tbody>\r\n    <tr>\r\n        <th>版本</th><th> PHP (*) </th><th>发行时间</th><th>Bug 修复截止时间</th><th>安全修复截止时间</th>\r\n    </tr>\r\n    <tr>\r\n        <td style=\"background:rgb(244 157 55); \">6 (LTS)  </td>\r\n        <td>7.2 - 8.0</td>\r\n        <td>2019年9月3日  </td>\r\n\t\t<td>2022年1月25日 </td>\r\n        <td>2022年9月6日 </td>\r\n    </tr>\r\n    <tr>\r\n        <td style =\"background:rgba(249 50 44);\">7</td>\r\n        <td> 7.2 - 8.0</td>\r\n         <td>2020年3月3日  </td>\r\n\t\t<td>2020年10月6日 </td>\r\n        <td>2021年3月3日 </td>\r\n    </tr>\r\n\t <tr>\r\n        <td >8</td>\r\n        <td> 7.3 - 8.1</td>\r\n         <td>2020年9月8日  </td>\r\n\t\t<td>2022年7月26日 </td>\r\n        <td>2023年1月24日 </td>\r\n    </tr>\r\n\t<tr>\r\n        <td >9</td>\r\n        <td>8.0 - 8.1</td>\r\n         <td>2022年2月8日  </td>\r\n\t\t<td>2023年8月8日 </td>\r\n        <td>2024年2月8日 </td>\r\n    </tr>\r\n<tr>\r\n        <td >10</td>\r\n        <td>8.0 - 8.1</td>\r\n         <td>2023年2月7日  </td>\r\n\t\t<td>2024年8月7日 </td>\r\n        <td>2025年2月7日 </td>\r\n    </tr>\r\n</table>\r\n        <span><div style=\"height:0.75rem; margin-right:0.5rem; width:0.75rem;background:rgba(249 50 44);display:inline-block; \"></div>\r\n\t\t<div style=\" display:inline;\">生命周期结束</div></span>\r\n        <div style=\"height:0.75rem; margin-right:0.5rem; width:0.75rem;background:rgb(244 157 55); display:inline-block; \"></div>\r\n        <div style=\" display:inline;\">仅安全修复</div>\r\n\t\t\r\n(*) 支持的PHP版本\r\n\r\n<a name=\"laravel-9\"></a>\r\n## Laravel 9\r\n\r\n正如你所知，随着 Laravel 8 的发布，Laravel 已经过渡到了年度发布。以前，主要版本每6个月发布一次。这一转变旨在减轻社区的维护负担，并挑战我们的开发团队在不引入突破性更改的情况下提供惊人、强大的新功能。因此，我们在不破坏向后兼容性的情况下，向 Laravel 8 提供了各种强大的功能，例如并行测试支持、改进的 Breeze starter 工具包、HTTP 客户端改进，甚至还有新的 Eloquent  关联关系类型，例如`oFMany`(一对多检索)。\r\n\r\n因此，在当前版本中发布新功能的承诺可能会导致未来的「主要」版本主要用于「维护」任务，例如升级上游依赖项，这可以在这些发行说明中看到。\r\n\r\nLaravel 9 延续了 Laravel 8.x 的改进通过引入对 Symfony 6.0 组件、Symfony Mailer、Flysystem 3.0、改进的 `routes:list` 输出、Laravel Scout 数据库驱动程序、新的 Eloquent 访问器 / 修改器语法、通过枚举的隐式路由绑定，以及其他各种错误修复和可用性改进。\r\n\r\n<a name=\"php-8\"></a>\r\n### PHP 8.0\r\n\r\nLaravel 9.x 至少需要 PHP8.0.2。\r\n\r\n<a name=\"symfony-mailer\"></a>\r\n### Symfony Mailer\r\n\r\n_Symfony Mailer 的支持是由 [Dries Vints](https://github.com/driesvints)_, [James Brooks](https://github.com/jbrooksuk), 和 [Julius Kiekbusch](https://github.com/Jubeki).\r\n\r\nLaravel 以前的版本使用了 [Swift Mailer](https://swiftmailer.symfony.com/docs/introduction.html) 库发送外发邮件。然而，该库已不再维护，由 Symfony Mailer 继承。\r\n\r\n\r\n\r\n请查看 [升级指南](/docs/laravel/9.x/upgrade#symfony-mailer) 以了解有关确保您的应用程序与 Symfony Mailer 兼容的更多信息。\r\n\r\n<a name=\"flysystem-3\"></a>\r\n### Flysystem 3.x\r\n\r\nFlysystem 3.x 的支持由 [Dries Vints](https://github.com/driesvints) 提供。\r\nLaravel 9.x 将我们上游的 Flysystem 依赖升级到 Flysystem 3.x。 Flysystem 为 `Storage` 门面提供的所有文件系统交互提供支持。\r\n\r\n请查看 [升级指南](/docs/laravel/9.x/upgrade#flysystem-3) 以了解有关确保您的应用程序与 Flysystem 3.x 兼容的更多信息。\r\n\r\n<a name=\"eloquent-accessors-and-mutators\"></a>\r\n### Eloquent 访问器/修改器 改进\r\n\r\n改进的 Eloquent 访问器/修改器由 [Taylor Otwell](https://github.com/taylorotwell) 贡献。\r\n\r\nLaravel 9.x 提供了一种新的方式来定义 Eloquent [访问器和修改器](/docs/laravel/9.x/eloquent-mutators#accessors-and-mutators)。在以前的 Laravel 版本中，定义访问器和修改器的唯一方法是在模型上定义前缀方法，如下所示：\r\n\r\n```php\r\npublic function getNameAttribute($value)\r\n{\r\n    return strtoupper($value);\r\n}\r\n\r\npublic function setNameAttribute($value)\r\n{\r\n    $this->attributes['name'] = $value;\r\n}\r\n```\r\n\r\n然而，在 Laravel 9.x 中，你可以使用一个不带前缀的方法定义访问器和修改器，该方法的返回类型是`Illuminate\\Database\\Eloquent\\Casts\\Attribute`：\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n\r\npublic function name(): Attribute\r\n{\r\n    return new Attribute(\r\n        get: fn ($value) => strtoupper($value),\r\n        set: fn ($value) => $value,\r\n    );\r\n}\r\n```\r\n\r\n此外，这种定义访问器的新方法将缓存由属性返回的对象值，就像 [自定义转换类](/docs/laravel/9.x/eloquent-mutators#custom-casts)：\r\n\r\n```php\r\nuse App\\Support\\Address;\r\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n\r\npublic function address(): Attribute\r\n{\r\n    return new Attribute(\r\n        get: fn ($value, $attributes) => new Address(\r\n            $attributes['address_line_one'],\r\n            $attributes['address_line_two'],\r\n        ),\r\n        set: fn (Address $value) => [\r\n            'address_line_one' => $value->lineOne,\r\n            'address_line_two' => $value->lineTwo,\r\n        ],\r\n    );\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"enum-casting\"></a>\r\n### Enum Eloquent 属性转换\r\n\r\n> 注意：枚举转换仅适用于 PHP 8.1+。\r\n\r\n枚举转换由 [Mohamed Said](https://github.com/themsaid) 贡献。\r\n\r\nEloquent 现在允许您将属性值转换为 PHP [\"backed\" enums](https://www.php.net/manual/en/language.enumerations.backed.php)。 为此，您可以在模型的 `$casts` 属性数组中指定要转换的属性和枚举：\r\n\r\n    use App\\Enums\\ServerStatus;\r\n\r\n    /**\r\n     * The attributes that should be cast.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'status' => ServerStatus::class,\r\n    ];\r\n\r\n一旦你在你的模型上定义了转换，当你与属性交互时，指定的属性将自动转换为枚举：\r\n\r\n    if ($server->status == ServerStatus::provisioned) {\r\n        $server->status = ServerStatus::ready;\r\n\r\n        $server->save();\r\n    }\r\n\r\n<a name=\"implicit-route-bindings-with-enums\"></a>\r\n### 使用枚举的隐式路由绑定\r\n\r\n隐式路由绑定由 [Nuno Maduro](https://github.com/nunomaduro)贡献。\r\n\r\nPHP 8.1 引入了对 [Enums](https://www.php.net/manual/en/language.enumerations.backed.php) 的支持。 Laravel 9.x 引入了在路由定义中键入提示 Enum 的能力，并且 Laravel 只会在该路由段是 URI 中的有效 Enum 值时调用该路由。 否则，将自动返回 HTTP 404 响应。 例如，给定以下枚举：\r\n\r\n```php\r\nenum Category: string\r\n{\r\n    case Fruits = 'fruits';\r\n    case People = 'people';\r\n}\r\n```\r\n\r\n你可以定义一个只有在 `{category}` 路由段是 `fruits` 或 `people` 时才会被调用的路由。 否则，将返回 HTTP 404 响应：\r\n\r\n```php\r\nRoute::get('/categories/{category}', function (Category $category) {\r\n    return $category->value;\r\n});\r\n```\r\n\r\n\r\n\r\n<a name=\"forced-scoping-of-route-bindings\"></a>\r\n### 路由绑定的强制作用域\r\n\r\n路由绑定的强制作用域由 [Claudio Dekker](https://github.com/claudiodekker)贡献.\r\n\r\n在之前的 Laravel 版本中，您可能希望在路由定义中限定第二个 Eloquent 模型，使其必须是之前 Eloquent 模型的子模型。 例如，考虑这个通过 slug 为特定用户检索博客文章的路由定义：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {\r\n        return $post;\r\n    });\r\n\r\n当使用自定义键控隐式绑定作为嵌套路由参数时，Laravel 将自动限定查询范围以通过其父级检索嵌套模型，使用约定来猜测父级上的关系名称。 但是，当自定义键用于子路由绑定时，Laravel 之前仅支持此行为。\r\n\r\n然而，在 Laravel 9.x 中，即使没有提供自定义键，你现在也可以指示 Laravel 限定“子”绑定。 为此，您可以在定义路由时调用 `scopeBindings` 方法：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\r\n        return $post;\r\n    })->scopeBindings();\r\n\r\n或者，您可以指示整个路由定义组使用范围绑定：\r\n\r\n    Route::scopeBindings()->group(function () {\r\n        Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\r\n            return $post;\r\n        });\r\n    });\r\n\r\n<a name=\"controller-route-groups\"></a>\r\n### 控制器路由组\r\n\r\n控制器路由组改进由 [Luke Downing](https://github.com/lukeraymonddowning)贡献.\r\n\r\n\r\n\r\n您现在可以使用 `controller` 方法为组内的所有路由定义公共控制器。 然后，在定义路由时，您只需要提供它们调用的控制器方法：\r\n\r\n    use App\\Http\\Controllers\\OrderController;\r\n\r\n    Route::controller(OrderController::class)->group(function () {\r\n        Route::get('/orders/{id}', 'show');\r\n        Route::post('/orders', 'store');\r\n    });\r\n\r\n<a name=\"full-text\"></a>\r\n### 全文索引 / Where 子句\r\n\r\n全文索引和\"where\"子句由 [Taylor Otwell](https://github.com/taylorotwell) 和 [Dries Vints](https://github.com/driesvints)贡献。\r\n\r\n使用 MySQL 或 PostgreSQL 时，现在可以将 `fullText` 方法添加到列定义中以生成全文索引：\r\n\r\n    $table->text('bio')->fullText();\r\n\r\n此外，`whereFullText` 和 `orWhereFullText` 方法可用于将全文“where”子句添加到具有[全文索引]的列的查询中（/docs/laravel/9.x/migrations#available-index -类型）。 这些方法将被 Laravel 转换成适合底层数据库系统的 SQL。 例如，将为使用 MySQL 的应用程序生成一个 `MATCH AGAINST` 子句：\r\n\r\n    $users = DB::table('users')\r\n               ->whereFullText('bio', 'web developer')\r\n               ->get();\r\n\r\n<a name=\"laravel-scout-database-engine\"></a>\r\n### Laravel Scout 数据库引擎\r\n\r\nLaravel Scout 数据库引擎由 [Taylor Otwell](https://github.com/taylorotwell) and [Dries Vints](https://github.com/driesvints)贡献。\r\n\r\n如果您的应用程序与中小型数据库交互或工作量较小，您现在可以使用 Scout 的“数据库”引擎，而不是 Algolia 或 MeiliSearch 等专用搜索服务。 数据库引擎将在过滤现有数据库的结果时使用“where like”子句和全文索引，以确定查询的适用搜索结果。\r\n\r\n\r\n\r\n要了解有关 Scout 数据库引擎的更多信息，请参阅 [Scout 文档](/docs/laravel/9.x/scout)。\r\n\r\n<a name=\"rendering-inline-blade-templates\"></a>\r\n### 渲染内联 Blade 模板\r\n\r\n渲染内联 Blade 模板由 [Jason Beggs](https://github.com/jasonlbeggs) 和 [Toby Zerner](https://github.com/tobyzerner)贡献。\r\n\r\n有时您可能需要将原始 Blade 模板字符串转换为有效的 HTML。 您可以使用 `Blade` 门面提供的 `render` 方法来完成此操作。 `render` 方法接受 Blade 模板字符串和提供给模板的可选数据数组：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Blade;\r\n\r\nreturn Blade::render('Hello, {{ $name }}', ['name' => 'Julian Bashir']);\r\n```\r\n\r\n类似地，`renderComponent` 方法可用于通过将组件实例传递给该方法来渲染给定的类组件：\r\n\r\n```php\r\nuse App\\View\\Components\\HelloComponent;\r\n\r\nreturn Blade::renderComponent(new HelloComponent('Julian Bashir'));\r\n```\r\n\r\n<a name=\"slot-name-shortcut\"></a>\r\n### Slot 名称快捷方式\r\n\r\nSlot 名称快捷方式由 [Caleb Porzio](https://github.com/calebporzio)贡献。\r\n\r\n在以前的 Laravel 版本中，slot名称是使用 `x-slot` 标签上的 `name` 属性提供的：\r\n\r\n```blade\r\n<x-alert>\r\n    <x-slot name=\"title\">\r\n        Server Error\r\n    </x-slot>\r\n\r\n    <strong>Whoops!</strong> Something went wrong!\r\n</x-alert>\r\n```\r\n\r\n但是，从 Laravel 9.x 开始，您可以使用更方便、更短的语法来指定slot的名称：\r\n\r\n```xml\r\n<x-slot:title>\r\n    Server Error\r\n</x-slot>\r\n```\r\n\r\n<a name=\"checked-selected-blade-directives\"></a>\r\n### Checked / Selected blade指令\r\n\r\nChecked and selected Blade 指令由 [Ash Allen](https://github.com/ash-jc-allen) 和 [Taylor Otwell](https://github.com/taylorotwell)贡献。\r\n\r\n为方便起见，您现在可以使用 `@checked` 指令轻松指示给定的 HTML 复选框输入是否已“选中”。 如果提供的条件评估为 `true`，则此指令将回显 `checked`：\r\n\r\n```blade\r\n<input type=\"checkbox\"\r\n        name=\"active\"\r\n        value=\"active\"\r\n        @checked(old('active', $user->active)) />\r\n```\r\n\r\n\r\n\r\n同样，`@selected` 指令可用于指示是否应该“选择”给定的选择选项：\r\n\r\n```blade\r\n<select name=\"version\">\r\n    @foreach ($product->versions as $version)\r\n        <option value=\"{{ $version }}\" @selected(old('version') == $version)>\r\n            {{ $version }}\r\n        </option>\r\n    @endforeach\r\n</select>\r\n```\r\n\r\n<a name=\"bootstrap-5-pagination-views\"></a>\r\n### Bootstrap 5 分页视图\r\n\r\nBootstrap 5 分页视图由 [Jared Lewis](https://github.com/jrd-lewis)贡献。\r\n\r\nLaravel 现在包含使用 [Bootstrap 5](https://getbootstrap.com/) 构建的分页视图。 要使用这些视图而不是默认的 Tailwind 视图，您可以在 `App\\Providers\\AppServiceProvider` 类的 `boot` 方法中调用分页器的 `useBootstrapFive` 方法：\r\n\r\n    use Illuminate\\Pagination\\Paginator;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Paginator::useBootstrapFive();\r\n    }\r\n\r\n<a name=\"improved-validation-of-nested-array-data\"></a>\r\n### 改进了嵌套数组数据的验证\r\n\r\n嵌套数组数据的验证由 [Steve Bauman](https://github.com/stevebauman)贡献。\r\n\r\n有时，在为属性分配验证规则时，您可能需要访问给定嵌套数组元素的值。 您现在可以使用 `Rule::forEach` 方法完成此操作。 `forEach` 方法接受一个闭包，该闭包将为验证中的数组属性的每次迭代调用，并将接收属性的值和显式的、完全扩展的属性名称。 闭包应该返回一个规则数组来分配给数组元素：\r\n\r\n    use App\\Rules\\HasPermission;\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'companies.*.id' => Rule::forEach(function ($value, $attribute) {\r\n            return [\r\n                Rule::exists(Company::class, 'id'),\r\n                new HasPermission('manage-company', $value),\r\n            ];\r\n        }),\r\n    ]);\r\n\r\n<a name=\"laravel-breeze-api\"></a>\r\n### Laravel Breeze API & Next.js\r\n\r\n\r\n\r\nLaravel Breeze API 和 Next.js 由 [Taylor Otwell](https://github.com/taylorotwell) and [Miguel Piedrafita](https://twitter.com/m1guelpf)贡献。\r\n\r\n[Laravel Breeze](/docs/laravel/9.x/starter-kits#breeze-and-next) 入门套件已获得“API”脚手架模式和免费 [Next.js](https://nextjs.org ) [前端实现](https://github.com/laravel/breeze-next)。 这个初学者工具包脚手架可用于快速启动用作后端的 Laravel 应用程序，以及用于 JavaScript 前端的 Laravel Sanctum 认证 API。\r\n\r\n<a name=\"exception-page\"></a>\r\n### 改进 Ignition 错误页面\r\n\r\nIgnition由 [Spatie](https://spatie.be/)贡献。\r\n\r\nSpatie 创建的开源异常调试页面 Ignition 已经从头开始重新设计。 新的、改进的 Ignition 随 Laravel 9.x 一起提供，包括浅色/深色主题、可定制的“在编辑器中打开”功能等等。\r\n\r\n<p align=\"center\">\r\n<img width=\"100%\" src=\"https://cdn.learnku.com/uploads/images/202202/18/25486/juwOpUFX7p.png!large\"/>\r\n</p>\r\n\r\n<a name=\"improved-route-list\"></a>\r\n### 改进的 `route:list` CLI 输出\r\n\r\n改进的 `route:list` CLI 输出由 [Nuno Maduro](https://github.com/nunomaduro)贡献。\r\n\r\n`route:list` CLI 输出在 Laravel 9.x 版本中得到了显着改进，在探索你的路由定义时提供了一个美妙的新体验。\r\n\r\n<p align=\"center\">\r\n<img src=\"https://cdn.learnku.com/uploads/images/202202/18/25486/rbbkbh2QKT.png!large\"/>\r\n</p>\r\n\r\n<a name=\"test-coverage-support-on-artisan-test-Command\"></a>\r\n### 使用 Artisan `test` 命令测试覆盖率\r\n\r\n使用 Artisan `test` 命令时的测试覆盖率由 [Nuno Maduro](https://github.com/nunomaduro)贡献。\r\n\r\nArtisan `test` 命令收到了一个新的 `--coverage` 选项，您可以使用它来探索您的测试为您的应用程序提供的代码覆盖率：\r\n\r\n```shell\r\nphp artisan test --coverage\r\n```\r\n\r\n\r\n\r\n测试覆盖率结果将直接显示在 CLI 输出中。\r\n\r\n<p align=\"center\">\r\n<img width=\"100%\" src=\"https://cdn.learnku.com/uploads/images/202202/18/30138/GnM8gJDNhu.png!large\"/>\r\n</p>\r\n\r\n此外，如果您想指定测试覆盖率必须满足的最低阈值，您可以使用该 `--min` 选项。如果未达到给定的最小阈值，则测试套件将失败：\r\n\r\n```shell\r\nphp artisan test --coverage --min=80.3\r\n```\r\n\r\n<p align=\"center\">\r\n<img width=\"100%\" src=\"https://cdn.learnku.com/uploads/images/202202/18/30138/06IIcEzXFN.png!large\"/>\r\n</p>\r\n\r\n<a name=\"soketi-echo-server\"></a>\r\n### Soketi Echo 服务器\r\n\r\n_Soketi Echo 服务器由 [Alex Renoki](https://github.com/rennokki)_ 开发。\r\n\r\n虽然不是 Laravel 9.x 独有的，但 Laravel 最近协助编写了 Soketi 的文档，这是一个为 Node.js 编写的与 [Laravel Echo](/docs/laravel/9.x/broadcasting) 兼容的 Web Socket 服务器。Soketi 为那些喜欢管理自己的 Web Socket 服务器的应用程序提供了一个很好的、开源的替代 Pusher 和 Ably。\r\n\r\n有关使用 Soketi 的更多信息，请参阅 [广播文档](/docs/laravel/9.x/broadcasting) 和 [Soketi 文档](https://docs.soketi.app/)。\r\n\r\n<a name=\"improved-collections-ide-support\"></a>\r\n### 改进的集合 IDE 支持\r\n\r\n_[Nuno Maduro](https://github.com/nunomaduro)_ 贡献了改进的集合 IDE 支持。\r\n\r\nLaravel 9.x 为集合组件添加了改进的“通用”样式类型定义，改进了 IDE 和静态分析支持。 [PHPStorm](https://blog.jetbrains.com/phpstorm/2021/12/phpstorm-2021-3-release/#support_for_future_laravel_collections) 或 [PHPStan](https://phpstan.org) 等 IDE 静态分析工具现在可以更好地理解 Laravel 集合。\r\n\r\n<p align=\"center\">\r\n<img width=\"100%\" src=\"https://cdn.learnku.com/uploads/images/202202/18/30138/zzM0Yn3RSa.gif!large\"/>\r\n</p>\r\n\r\n\r\n\r\n<a name=\"new-helpers\"></a>\r\n### 新助手\r\n\r\nLaravel 9.x 引入了两个新的、方便的辅助函数，你可以在自己的应用程序中使用它们。\r\n\r\n<a name=\"new-helpers-str\"></a>\r\n#### `str`\r\n\r\n该 `str` 函数返回 `Illuminate\\Support\\Stringable` 给定字符串的新实例。这个函数等价于 `Str::of` 方法：\r\n\r\n    $string = str('Taylor')->append(' Otwell');\r\n\r\n    // 'Taylor Otwell'\r\n\r\n如果没有为 `str` 函数提供参数，则函数返回 `Illuminate\\Support\\Str` 的实例：\r\n\r\n    $snake = str()->snake('LaravelFramework');\r\n\r\n    // 'laravel_framework'\r\n\r\n<a name=\"new-helpers-to-route\"></a>\r\n#### `to_route`\r\n\r\n该 `to_route` 函数为给定的命名路由生成重定向 HTTP 响应，提供了一种从路由和控制器重定向到命名路由的表达方式：\r\n\r\n    return to_route('users.show', ['user' => 1]);\r\n\r\n如有必要，您可以将应分配给重定向的 HTTP 状态代码和任何其他响应标头作为第三和第四个参数传递给 to_route 方法：\r\n\r\n    return to_route('users.show', ['user' => 1], 302, ['X-Framework' => 'Laravel']);\r\n\r\n","p":"docs/releases.html"},{"t":"upgrade (升级指南)","d":"#  升级指南\r\n\r\n- [从 8.x 升级到 9.0](#upgrade-9.0)\r\n\r\n<a name=\"high-impact-changes\"></a>\r\n## 高影响变化\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [更新依赖](#updating-dependencies)\r\n- [Flysystem 3.x](#flysystem-3)\r\n- [Symfony Mailer](#symfony-mailer)\r\n\r\n</div>\r\n\r\n<a name=\"medium-impact-changes\"></a>\r\n## 中影响变化\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [Belongs To Many `firstOrNew`, `firstOrCreate`, and `updateOrCreate` 方法](#belongs-to-many-first-or-new)\r\n- [Custom Casts & `null`](#custom-casts-and-null)\r\n- [Default HTTP Client Timeout](#http-client-default-timeout)\r\n- [PHP Return Types](#php-return-types)\r\n- [Postgres \"Schema\" Configuration](#postgres-schema-configuration)\r\n- [The `assertDeleted` Method](#the-assert-deleted-method)\r\n- [The `lang` Directory](#the-lang-directory)\r\n- [The `password` Rule](#the-password-rule)\r\n- [The `when` / `unless` Methods](#when-and-unless-methods)\r\n- [Unvalidated Array Keys](#unvalidated-array-keys)\r\n\r\n</div>\r\n\r\n<a name=\"upgrade-9.0\"></a>\r\n## 从 8.x 升级到 9.0\r\n\r\n<a name=\"estimated-upgrade-time-10-minutes\"></a>\r\n#### 预计升级时间: 30 分钟\r\n\r\n> 技巧：我们应该试图记录每个可能的重大改变. 由于一些破坏性的变更位于框架的模糊部分，因此这些更改只有一部分可能会实际影响你的应用程序. 想要节省时间? 你可以看 [Laravel Shift](https://laravelshift.com/) 来帮助你的应用自动化升级。\r\n\r\n<a name=\"updating-dependencies\"></a>\r\n### 更新依赖\r\n\r\n**影响的可能性: 高**\r\n\r\n#### 要求 PHP 8.0.2\r\n\r\nLaravel 现在 需要 PHP 8.0.2 or 更高。\r\n\r\n#### Composer 依赖\r\n\r\n你应该在你应用程序的 `composer.json` 文件中更新依赖包的版本\r\n\r\n- `laravel/framework` 至 `^9.0`\r\n- `nunomaduro/collision` 至 `^6.1`\r\n\r\n另外，请在 `composer.json` 文件中用 `\"spatie/laravel-ignition\": \"^1.0\"` 替换掉 `facade/ignition`\r\n\r\n以下官方包的新版本已经支持 Laravel 9.x 。如有需要，你应该在升级前阅读它们各自的升级指南：\r\n\r\n- [Vonage Notification Channel (v3.0)](https://github.com/laravel/vonage-notification-channel/blob/3.x/UPGRADE.md) (Replaces Nexmo)\r\n\r\n最后，检查应用程序使用的任何其他第三方包，并验证是否使用了正确的支持 Laravel 9 的版本。\r\n\r\n<a name=\"php-return-types\"></a>\r\n#### PHP 返回类型\r\n\r\nPHP 开始过渡到要求在 PHP 方法（如 `offsetGet`、`offsetSet` 等）上定义返回类型。有鉴于此，Laravel 9 在其代码库中实现了这些返回类型。通常，这应该不会影响用户编写的代码；但是，如果您通过扩展 Laravel 的核心类来重写这些方法之一，则需要将这些返回类型添加到您自己的应用程序或包代码中：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `count(): int`\r\n- `getIterator(): Traversable`\r\n- `getSize(): int`\r\n- `jsonSerialize(): array`\r\n- `offsetExists($key): bool`\r\n- `offsetGet($key): mixed`\r\n- `offsetSet($key, $value): void`\r\n- `offsetUnset($key): void`\r\n\r\n</div>\r\n\r\n此外，返回类型被添加到实现 PHP 的 `SessionHandlerInterface` 接口的方法中。同样，这个更改不太可能影响您自己的应用程序或包代码：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `open($savePath, $sessionName): bool`\r\n- `close(): bool`\r\n- `read($sessionId): string|false`\r\n- `write($sessionId, $data): bool`\r\n- `destroy($sessionId): bool`\r\n- `gc($lifetime): int`\r\n\r\n</div>\r\n\r\n<a name=\"application\"></a>\r\n### Application\r\n\r\n<a name=\"the-application-contract\"></a>\r\n#### `Application` 契约\r\n\r\n**影响程度：低**\r\n\r\n`Illuminate\\Contracts\\Foundation\\Application` 接口的 `storagePath` 方法已更新为接受 `$path` 参数。如果要实现此接口，则应相应地更新实现代码：\r\n\r\n    public function storagePath($path = '');\r\n    \r\n同样，`Illuminate\\Foundation\\Application` 类的 `langPath` 方法已更新为接受 `$path` 参数：\r\n\r\n    public function langPath($path = '');\r\n\r\n\r\n\r\n#### 异常处理程序`ignore`方法\r\n\r\n**影响的可能性：低**\r\n\r\n异常处理程序的 `ignore` 方法现在是 `public` 而不是 `protected`。此方法不包含在默认应用程序框架中；但是，如果您手动定义了此方法，则应将其可见性更新为“public”：\r\n\r\n```php\r\npublic function ignore(string $class);\r\n```\r\n\r\n### Blade\r\n\r\n#### 惰性集合和 `$loop` 变量\r\n\r\n**影响的可能性：低**\r\n\r\n当在 Blade 模板中迭代 `LazyCollection` 实例时，`$loop` 变量不再可用，因为访问该变量会导致整个 `LazyCollection` 被加载到内存中，因此在这种情况下使用惰性集合是毫无意义的。\r\n\r\n### 集合\r\n\r\n#### `Enumerable` 契约\r\n\r\n**影响的可能性：低**\r\n\r\n`Illuminate\\Support\\Enumerable` 合约现在定义了 `sole` 方法。如果您手动实现此接口，则应更新您的实现以显示此新方法：\r\n\r\n```php\r\npublic function sole($key = null, $operator = null, $value = null);\r\n```\r\n\r\n#### `reduceWithKeys` 方法\r\n\r\n`reduceWithKeys` 方法已被删除，因为 `reduce` 方法提供了相同的功能。你可以简单地更新你的代码来调用 `reduce` 而不是 `reduceWithKeys`。\r\n\r\n#### `reduceMany` 方法\r\n\r\n`reduceMany` 方法已重命名为 `reduceSpread`，以便与其他类似方法的命名保持一致。\r\n\r\n### 容器\r\n\r\n#### `Container` 契约\r\n\r\n**影响的可能性：非常低**\r\n\r\n`Illuminate\\Contracts\\Container\\Container` 契约有两个方法定义：`scoped` 和 `scopedIf`。如果您手动实施此契约，您应该更新您的实施以显示这些新方法。\r\n\r\n#### `ContextualBindingBuilder` 契约\r\n\r\n**影响的可能性：非常低**\r\n\r\n`Illuminate\\Contracts\\Container\\ContextualBindingBuilder` 契约现在定义了 `giveConfig` 方法。如果您手动实现此接口，则应更新您的实现以显示此新方法：\r\n\r\n```php\r\npublic function giveConfig($key, $default = null);\r\n```\r\n\r\n### 数据库\r\n\r\n<a name=\"postgres-schema-configuration\"></a>\r\n#### Postgres \"Schema\" 配置选项\r\n\r\n**影响程度：中**\r\n\r\n在 `config/database.php` 配置文件中用配置 Postgres 连接搜索路径的 `schema` 配置选项应重命名为 `search_path`。\r\n\r\n<a name=\"schema-builder-doctrine-method\"></a>\r\n#### Schema Builder `registerCustomDoctrineType` 方法\r\n\r\n**影响程度：低**\r\n\r\n`registerCustomDoctrineType` 方法已从 `Illuminate\\Database\\Schema\\Builder` 类中删除。您可以在 `DB` 上使用 `registerDoctrineType` 方法，或者在 `config/database.php` 配置文件中注册自定义的 Doctrine 类型。\r\n\r\n### Eloquent\r\n\r\n<a name=\"custom-casts-and-null\"></a>\r\n#### 自定义强制转换和 `null`\r\n\r\n**影响程度：中**\r\n\r\n在 Laravel 的先前版本中，如果将强制转换属性设置为 `null`，则不会调用自定义强制转换类的 `set` 方法。但是，此行为与 Laravel 文档不一致。在 Laravel 9.x 中，将调用 cast 类的 `set` 方法，并使用 `null` 作为提供的 `$value` 参数。因此，应确保自定义强制转换能够充分处理这个场景：\r\n\r\n```php\r\n/**\r\n * Prepare the given value for storage.\r\n *\r\n * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n * @param  string  $key\r\n * @param  AddressModel  $value\r\n * @param  array  $attributes\r\n * @return array\r\n */\r\npublic function set($model, $key, $value, $attributes)\r\n{\r\n    if (! $value instanceof AddressModel) {\r\n        throw new InvalidArgumentException('The given value is not an Address instance.');\r\n    }\r\n\r\n    return [\r\n        'address_line_one' => $value->lineOne,\r\n        'address_line_two' => $value->lineTwo,\r\n    ];\r\n}\r\n```\r\n\r\n<a name=\"belongs-to-many-first-or-new\"></a>\r\n#### Belongs To Many 的 `firstOrNew`、`firstOrCreate` 和 `updateOrCreate` 方法\r\n\r\n**影响程度：中**\r\n\r\n`belongsToMany` 关系的 `firstOrNew`、`firstOrCreate` 和 `updateOrCreate` 方法都接受一个属性数组作为其第一个参数。在 Laravel 的先前版本中，这个属性数组相当于现有记录的 `pivot` 中间表。\r\n\r\n\r\n\r\n但是，这种行为是意料之外的，通常是不受欢迎的。相反，这些方法现在将属性数组与相关模型的表进行比较：\r\n\r\n```php\r\n$user->roles()->updateOrCreate([\r\n    'name' => 'Administrator',\r\n]);\r\n```\r\n\r\n此外，该 `firstOrCreate` 方法现在接受一个 `$values` 数组作为其第二个参数。 当创建相关模型时，如果该模型不存在，则该数组将与该方法的第一个参数 (`$attributes`) 合并。此更改使此方法与其他关系类型提供的 `firstOrCreate` 方法一致：\r\n\r\n```php\r\n$user->roles()->firstOrCreate([\r\n    'name' => 'Administrator',\r\n], [\r\n    'created_by' => $user->id,\r\n]);\r\n```\r\n\r\n#### `touch` 方法\r\n\r\n**影响的可能性：低**\r\n\r\n该 `touch` 方法现在接受要触摸的属性。如果你之前覆盖了这个方法，你应该更新你的方法签名来反映这个新参数：\r\n\r\n```php\r\npublic function touch($attribute = null);\r\n```\r\n\r\n### Encryption\r\n\r\n#### Encrypter 契约\r\n\r\n**影响的可能性：低**\r\n\r\n该 `Illuminate\\Contracts\\Encryption\\Encrypter` 合约现在定义了一个方法 `getKey`。如果您手动实现此接口，则应相应地更新您的实现：\r\n\r\n```php\r\npublic function getKey();\r\n```\r\n\r\n### Facades\r\n\r\n#### `getFacadeAccessor` 方法\r\n\r\n**影响的可能性：低**\r\n\r\n该 `getFacadeAccessor` 方法必须始终返回容器绑定键。在之前的 Laravel 版本中，这个方法可以返回一个对象实例；但是，不再支持此行为。如果您已经编写了自己的外观，则应确保此方法返回容器绑定字符串：\r\n\r\n```php\r\n/**\r\n * Get the registered name of the component.\r\n *\r\n * @return string\r\n */\r\nprotected static function getFacadeAccessor()\r\n{\r\n    return Example::class;\r\n}\r\n```\r\n\r\n### Filesystem\r\n\r\n#### `FILESYSTEM_DRIVER` 环境变量\r\n\r\n**影响的可能性：低**\r\n\r\n\r\n`FILESYSTEM_DRIVER` 环境变量已重命名为 `FILESYSTEM_DISK` 以更准确地反映其用法。此更改仅影响应用程序框架； 但是，如果您愿意，欢迎您更新自己的应用程序的环境变量以反映此更改。\r\n\r\n#### \"Cloud\" 磁盘\r\n\r\n**影响的可能性：低**\r\n\r\n`cloud` 磁盘配置选项已于 2020 年 11 月从默认应用程序骨架中删除。此更改仅影响应用程序骨架。如果您在应用程序中使用“云”磁盘，则应将此配置值保留在您自己的应用程序的框架中。\r\n\r\n<a name=\"flysystem-3\"></a>\r\n### Flysystem 3.x\r\n\r\n**影响的可能性：高**\r\n\r\nLaravel 9.x 已从 [Flysystem](https://flysystem.thephpleague.com/v2/docs/) 1.x 迁移到 3.x。 在底层，Flysystem 支持 `Storage` 门面提供的所有文件操作方法。 鉴于此，您的应用程序中可能需要进行一些更改； 但是，我们已尝试使这种过渡尽可能无缝。\r\n\r\n#### 驱动器前置条件\r\n\r\n在使用 S3、FTP 或 SFTP 驱动程序之前，您需要通过 Composer 包管理器安装相应的包：\r\n\r\n- Amazon S3: `composer require -W league/flysystem-aws-s3-v3 \"^3.0\"`\r\n- FTP: `composer require league/flysystem-ftp \"^3.0\"`\r\n- SFTP: `composer require league/flysystem-sftp-v3 \"^3.0\"`\r\n\r\n#### 覆盖现有文件\r\n\r\n`put`、`write`、`writeStream` 等写操作现在默认覆盖现有文件。 如果您不想覆盖现有文件，则应在执行写入操作之前手动检查文件是否存在。\r\n\r\n#### 读取不存在的文件\r\n\r\n在之前的 Laravel 版本中，尝试读取不存在的文件会抛出 `Illuminate\\Contracts\\Filesystem\\FileNotFoundException`,Laravel9 则会返回`null`。\r\n\r\n\r\n\r\n#### 删除不存在的文件\r\n\r\n尝试 `删除` 一个不存在的文件现在返回 `true`。\r\n\r\n#### 缓存适配器\r\n\r\nFlysystem 不再支持“缓存适配器”。 因此，它们已从 Laravel 中删除，并且任何相关配置（例如磁盘配置中的 `cache` 键）都可以删除。\r\n\r\n#### 自定义文件系统\r\n\r\n对注册自定义文件系统驱动程序所需的步骤进行了轻微更改。 因此，如果您正在定义自己的自定义文件系统驱动程序，或者使用定义自定义驱动程序的包，您应该更新您的代码和依赖项。\r\n\r\n例如，在 Laravel 8.x 中，自定义文件系统驱动程序可能会像这样注册：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Storage;\r\nuse League\\Flysystem\\Filesystem;\r\nuse Spatie\\Dropbox\\Client as DropboxClient;\r\nuse Spatie\\FlysystemDropbox\\DropboxAdapter;\r\n\r\nStorage::extend('dropbox', function ($app, $config) {\r\n    $client = new DropboxClient(\r\n        $config['authorization_token']\r\n    );\r\n\r\n    return new Filesystem(new DropboxAdapter($client));\r\n});\r\n```\r\n\r\n但是，在 Laravel 9.x 中，给 `Storage::extend` 方法的回调应该直接返回 `Illuminate\\Filesystem\\FilesystemAdapter` 的实例：\r\n\r\n```php\r\nuse Illuminate\\Filesystem\\FilesystemAdapter;\r\nuse Illuminate\\Support\\Facades\\Storage;\r\nuse League\\Flysystem\\Filesystem;\r\nuse Spatie\\Dropbox\\Client as DropboxClient;\r\nuse Spatie\\FlysystemDropbox\\DropboxAdapter;\r\n\r\nStorage::extend('dropbox', function ($app, $config) {\r\n    $adapter = new DropboxAdapter(new DropboxClient(\r\n        $config['authorization_token']\r\n    ););\r\n\r\n    return new FilesystemAdapter(\r\n        new Filesystem($adapter, $config),\r\n        $adapter,\r\n        $config\r\n    );\r\n});\r\n```\r\n\r\n### Helpers\r\n\r\n<a name=\"data-get-function\"></a>\r\n#### The `data_get` Helper & Iterable Objects\r\n\r\n**`data_get` 助手和可迭代对象**\r\n\r\n以前，`data_get` 帮助器可用于检索数组和 `Collection` 实例上的嵌套数据；然而，这个助手现在可以检索所有可迭代对象的嵌套数据。\r\n\r\n<a name=\"str-function\"></a>\r\n\r\n\r\n#### `str` 助手函数\r\n\r\n**影响的可能性：非常低**\r\n\r\nLaravel 9.x 现在包含一个全局 `str` [辅助函数](/docs/laravel/9.x/helpers#method-str)。 如果你在你的应用程序中定义了一个全局的 `str` 助手，你应该重命名或删除它，这样它就不会与 Laravel 自己的 `str` 助手冲突。\r\n\r\n<a name=\"when-and-unless-methods\"></a>\r\n#### `when` / `unless` 方法\r\n\r\n**影响的可能性：中等**\r\n\r\n你可能知道，`when` 和 `unless` 方法由整个框架中的各种类提供。 如果方法的第一个参数的布尔值评估为 `true` 或 `false`，则这些方法可用于有条件地执行操作：\r\n\r\n```php\r\n$collection->when(true, function ($collection) {\r\n    $collection->merge([1, 2, 3]);\r\n});\r\n```\r\n\r\n因此，在 Laravel 的早期版本中，将闭包传递给 `when` 或 `unless` 方法意味着条件操作将始终执行，因为与闭包对象（或任何其他对象）的松散比较总是评估为 `true` . 这通常会导致意想不到的结果，因为开发人员希望将闭包的**结果**用作确定条件操作是否执行的布尔值。\r\n\r\n因此，在 Laravel 9.x 中，任何传递给 `when` 或 `unless` 方法的闭包都将被执行，并且闭包返回的值将被视为 `when` 和 `unless` 方法使用的布尔值：\r\n\r\n```php\r\n$collection->when(function ($collection) {\r\n    // This closure is executed...\r\n    return false;\r\n}, function ($collection) {\r\n    // Not executed since first closure returned \"false\"...\r\n    $collection->merge([1, 2, 3]);\r\n});\r\n```\r\n\r\n### HTTP 客户端\r\n\r\n<a name=\"http-client-default-timeout\"></a>\r\n#### 默认超时时间\r\n\r\n**影响的可能性：中等**\r\n\r\n[HTTP 客户端](/docs/laravel/9.x/http-client) 现在默认超时为 30 秒。 也就是说，如果服务器在 30 秒内没有响应，就会抛出异常。以前，在 HTTP 客户端上没有配置默认超时长度，导致请求有时会无限期地“挂起”。\r\n\r\n\r\n\r\n如果您希望为给定请求指定更长的超时时间，您可以使用 `timeout` 方法：\r\n\r\n    $response = Http::timeout(120)->get(...);\r\n\r\n#### HTTP Fake 和 中间件\r\n\r\n**影响的可能性：低**\r\n\r\n以前，当 [HTTP 客户端](/docs/laravel/9.x/http-client) 被\"faked\"时，Laravel 不会执行任何提供的 Guzzle HTTP 中间件。 然而，在 Laravel 9.x 中，即使 HTTP 客户端被伪造，Guzzle HTTP 中间件也会被执行。\r\n\r\n#### HTTP Fake 和 依赖注入\r\n\r\n**影响的可能性：低**\r\n\r\n在之前的 Laravel 版本中，调用 `Http::fake()` 方法不会影响注入到类构造函数中的 `Illuminate\\Http\\Client\\Factory` 实例。 然而，在 Laravel 9.x 中，`Http::fake()` 将确保通过依赖注入注入其他服务的 HTTP 客户端返回虚假响应。 这种行为更符合其他 facade 和 fake 的行为。\r\n\r\n<a name=\"symfony-mailer\"></a>\r\n### Symfony Mailer\r\n\r\n**影响的可能性：高**\r\n\r\nLaravel 9.x 中最大的变化之一是从 SwiftMailer（截至 2021 年 12 月不再维护）到 Symfony Mailer 的过渡。 但是，我们已尝试使您的应用程序尽可能无缝地过渡。 话虽如此，请仔细查看下面的更改列表，以确保您的应用程序完全兼容。\r\n\r\n#### 驱动程序前置条件\r\n\r\n要继续使用 Mailgun 传输，您的应用程序应该需要 `symfony/mailgun-mailer` 和 `symfony/http-client` Composer 包：\r\n\r\n```shell\r\ncomposer require symfony/mailgun-mailer symfony/http-client\r\n```\r\n\r\n`wildbit/swiftmailer-postmark` Composer 包应该从你的应用程序中删除。相反，您的应用程序应该需要 `symfony/postmark-mailer` 和 `symfony/http-client` Composer 包：\r\n\r\n```shell\r\ncomposer require symfony/postmark-mailer symfony/http-client\r\n```\r\n\r\n\r\n\r\n#### 更新的返回类型\r\n\r\n该 `send`，`html`，`text` 和 `plain` 方法不再返回接收邮件的收件人数量。相反，返回一个实例 `Illuminate\\Mail\\SentMessage` 。 此对象包含一个 `Symfony\\Component\\Mailer\\SentMessage` 实例，可通过 `getSymfonySentMessage` 方法或通过在对象上动态调用方法来访问。\r\n\r\n#### 重命名为「Swift」方法\r\n\r\n各种与 SwiftMailer 相关的方法，其中一些没有被记录，已经被重命名为它们的 Symfony Mailer 对应方法。例如，该 `withSwiftMessage` 方法已重命名为 `withSymfonyMessage`:\r\n\r\n    // Laravel 8.x...\r\n    $this->withSwiftMessage(function ($message) {\r\n        $message->getHeaders()->addTextHeader(\r\n            'Custom-Header', 'Header Value'\r\n        );\r\n    });\r\n\r\n    // Laravel 9.x...\r\n    use Symfony\\Component\\Mime\\Email;\r\n\r\n    $this->withSymfonyMessage(function (Email $message) {\r\n        $message->getHeaders()->addTextHeader(\r\n            'Custom-Header', 'Header Value'\r\n        );\r\n    });\r\n\r\n> 注意：请参阅查看 [Symfony Mailer 文档](https://symfony.com/doc/6.0/mailer.html#creating-sending-messages) 以了解与 `Symfony\\Component\\Mime\\Email` 对象的所有可能交互。\r\n\r\n下面的列表包含重命名方法的更全面的概述。其中许多方法是用于直接与  `SwiftMailer/Symfony Mailer` 交互的低级方法，因此在大多数 Laravel 应用程序中可能不常用：\r\n\r\n    Message::getSwiftMessage();\r\n    Message::getSymfonyMessage();\r\n\r\n    Mailable::withSwiftMessage($callback);\r\n    Mailable::withSymfonyMessage($callback);\r\n\r\n    MailMessage::withSwiftMessage($callback);\r\n    MailMessage::withSymfonyMessage($callback);\r\n\r\n    Mailer::getSwiftMailer();\r\n    Mailer::getSymfonyTransport();\r\n\r\n    Mailer::setSwiftMailer($swift);\r\n    Mailer::setSymfonyTransport(TransportInterface $transport);\r\n\r\n    MailManager::createTransport($config);\r\n    MailManager::createSymfonyTransport($config);\r\n\r\n#### 代理 `Illuminate\\Mail\\Message` 方法\r\n\r\n该 `Illuminate\\Mail\\Message` 通常将缺少的方法代理给底层的 `Swift_Message` 实例。 但是，缺少的方法现在被代理为 `Symfony\\Component\\Mime\\Email` 的实例。 因此，以前依赖缺失方法代理给 Swift Mailer 的任何代码都应该更新为对应的 Symfony Mailer 对应代码。\r\n\r\n\r\n\r\n同样，许多应用程序可能不会与这些方法交互，因为它们没有记录在 Laravel 文档中：\r\n\r\n    // Laravel 8.x...\r\n    $message\r\n        ->setFrom('taylor@laravel.com')\r\n        ->setTo('example@example.org')\r\n        ->setSubject('Order Shipped')\r\n        ->setBody('<h1>HTML</h1>', 'text/html')\r\n        ->addPart('Plain Text', 'text/plain');\r\n\r\n    // Laravel 9.x...\r\n    $message\r\n        ->from('taylor@laravel.com')\r\n        ->to('example@example.org')\r\n        ->subject('Order Shipped')\r\n        ->html('<h1>HTML</h1>')\r\n        ->text('Plain Text');\r\n\r\n#### 生成的消息 ID\r\n\r\nSwiftMailer 提供了定义自定义域以通过 `mime.idgenerator.idright` 配置选项包含在生成的消息 ID 中的能力。Symfony Mailer 不支持此功能。相反，Symfony Mailer 会根据发件人自动生成一个 Message ID。\r\n#### 强制重新连接\r\n\r\n不再可能强制传输重新连接（例如，当邮件程序通过守护进程运行时）。相反，Symfony Mailer 将尝试自动重新连接到传输并在重新连接失败时抛出异常。\r\n\r\n#### SMTP 流选项\r\n\r\n不再支持为 SMTP 传输定义流选项。相反，如果支持，您必须直接在配置中定义相关选项。例如，要禁用 TLS 对等验证：\r\n\r\n    'smtp' => [\r\n        // Laravel 8.x...\r\n        'stream' => [\r\n            'ssl' => [\r\n                'verify_peer' => false,\r\n            ],\r\n        ],\r\n\r\n        // Laravel 9.x...\r\n        'verify_peer' => false,\r\n    ],\r\n\r\n要了解有关可用配置选项的更多信息，请查看 [Symfony Mailer 文档](https://symfony.com/doc/6.0/mailer.html#transport-setup)。\r\n\r\n> 注意：尽管有上述示例，但通常不建议您禁用 SSL 验证，因为它引入了「中间人」攻击的可能性。\r\n\r\n\r\n\r\n#### SMTP `授权模式`\r\n\r\n不再需要在 `mail` 配置文件中定义 SMTP `auth_mode`。 Symfony Mailer 和 SMTP 服务器将自动协商身份验证模式。\r\n\r\n#### 失败的收件人\r\n\r\n发送消息后不再检索失败的收件人列表。 相反，如果消息发送失败，则会抛出 `Symfony\\Component\\Mailer\\Exception\\TransportExceptionInterface` 异常。建议在发送消息之前验证电子邮件地址，而不是依赖于在发送消息后检索无效的电子邮件地址。\r\n\r\n### 扩展包\r\n\r\n<a name=\"the-lang-directory\"></a>\r\n#### `lang` 目录\r\n\r\n**影响的可能性：中等**\r\n\r\n在新的 Laravel 应用程序中，`resources/lang` 目录现在位于项目根目录（`lang`）中。如果你的包发布语言文件到这个目录，应该确保你的包发布到 `app()->langPath()` 而不是硬编码的路径。\r\n\r\n<a name=\"queue\"></a>\r\n### 队列\r\n\r\n<a name=\"the-opis-closure-library\"></a>\r\n#### `opis/closure` 库\r\n\r\n**影响的可能性：低**\r\n\r\nLaravel 对 `opis/closure` 的依赖已被 `laravel/serializable-closure` 取代。除非你直接与 `opis/closure` 库进行交互，否则这不会导致应用程序发生任何重大更改。此外，之前不推荐使用的 `Illuminate\\Queue\\SerializableClosureFactory` 和 `Illuminate\\Queue\\SerializableClosure` 类已被删除。如果你直接与 `opis/closure` 库交互或使用任何已删除的类，请改用 [Laravel Serializable Closure](https://github.com/laravel/serializable-closure)。\r\n\r\n#### 失败的 Job Provider `flush` 方法\r\n\r\n**影响的可能性：低**\r\n\r\n`Illuminate\\Queue\\Failed\\FailedJobProviderInterface` 接口定义的 `flush` 方法现在接受一个 `$hours` 参数，该参数决定失败的任务在被 `queue:flush` 刷新之前必须存在多长时间（以小时为单位） 命令。如果你手动实现 `FailedJobProviderInterface`，请更新它以反映此新参数：\r\n\r\n```php\r\npublic function flush($hours = null);\r\n```\r\n\r\n\r\n\r\n### Session\r\n\r\n####  `getSession` 方法\r\n\r\n**影响程度: 低**\r\n\r\n`Symfony\\Component\\HttpFoundaton\\RequestLaravel` 类继承于 Laravel 的 `Illuminate\\Http\\Request` 类，它提供了 `getSession` 方法来获取当前的会话存储处理器。Laravel 没有记录此方法，因为大多数 Laravel 应用程序通过 Laravel 的 `session` 方法与 session 交互。\r\n\r\n`getSession` 方法先前返回了 `Illuminate\\Session\\Store` 的实例或者 `null`；但是，由于 Symfony 6.x 版本强制返回类型为 `Symfony\\Component\\HttpFoundation\\Session\\SessionInterface`, 所以现在 `getSession` 会返回 `SessionInterface` 的实现，或者在没有可用的 session 时抛出一个 `\\Symfony\\Component\\HttpFoundation\\Exception\\SessionNotFoundException` 的异常。\r\n\r\n### 测试\r\n\r\n<a name=\"the-assert-deleted-method\"></a>\r\n#### `assertDeleted` 方法\r\n\r\n**影响程度: 中**\r\n\r\n所有调用 `assertDeleted` 的方法应该修改为 `assertModelMissing` 。\r\n\r\n### TrustProxies 中间件\r\n\r\n**影响程度: 低**\r\n\r\n如果您是通过升级 Laravel 8 至 Laravel 9 的方式来导入全新的 Laravel 9 框架，您可能需要更新应用程序的 `trusted proxy` 中间件。\r\n\r\n在您的 `app/Http/Middleware/TrustProxies.php` 文件中，修改 `use Fideloper\\Proxy\\TrustProxies as Middleware` 为 `use Illuminate\\Http\\Middleware\\TrustProxies as Middleware`。\r\n\r\n继续在`app/Http/Middleware/TrustProxies.php`文件 修改注释中的:\r\n\t@var array|string|null\r\n改为\r\n\t@var array<int, string>|string|null\r\n\r\n接下来, 在 `app/Http/Middleware/TrustProxies.php`， 您需要更改 `$headers` 属性的定义:\r\n\r\n```php\r\n// Before...\r\nprotected $headers = Request::HEADER_X_FORWARDED_ALL;\r\n\r\n// After...\r\nprotected $headers =\r\n    Request::HEADER_X_FORWARDED_FOR |\r\n    Request::HEADER_X_FORWARDED_HOST |\r\n    Request::HEADER_X_FORWARDED_PORT |\r\n    Request::HEADER_X_FORWARDED_PROTO |\r\n    Request::HEADER_X_FORWARDED_AWS_ELB;\r\n```\r\n\r\n最后，您可以删除 `fideloper/proxy` 的 Composer 依赖项：\r\n\r\n```shell\r\ncomposer remove fideloper/proxy\r\n```\r\n\r\n\r\n\r\n### 验证\r\n\r\n#### 表单请求 `validated` 方法\r\n\r\n**影响的可能性：低**\r\n\r\n表单请求提供的 `validated` 方法现在接受 `$key` 和 `$default` 参数。如果您手动覆盖此方法的定义，则应更新方法的签名以反映这些新参数：\r\n\r\n```php\r\npublic function validated($key = null, $default = null)\r\n```\r\n\r\n<a name=\"the-password-rule\"></a>\r\n#### `password` 规则\r\n\r\n**影响的可能性：中等**\r\n\r\n验证给定输入值是否与经过身份验证的用户的当前密码匹配的 `password` 规则已重命名为 `current_password`。\r\n\r\n<a name=\"unvalidated-array-keys\"></a>\r\n#### 未验证的数组键\r\n\r\n**影响的可能性：中等**\r\n\r\n在以前的 Laravel 版本中，您需要手动指示 Laravel 的验证器从它返回的“已验证”数据中排除未验证的数组键，尤其是结合未指定允许键列表的“数组”规则。\r\n\r\n然而，在 Laravel 9.x 中，即使没有通过 `array` 规则指定允许的键，未验证的数组键也总是从“已验证”数据中排除。 通常，这种行为是最预期的行为，之前的 `excludeUnvalidatedArrayKeys` 方法只是作为临时措施添加到 Laravel 8.x 中，以保持向后兼容性。\r\n\r\n尽管不建议这样做，但您可以通过在应用程序的服务提供者之一的 `boot` 方法中调用新的 `includeUnvalidatedArrayKeys` 方法来选择加入以前的 Laravel 8.x 行为：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Validator;\r\n\r\n/**\r\n * Register any application services.\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Validator::includeUnvalidatedArrayKeys();\r\n}\r\n```\r\n\r\n#### Middleware\r\n\r\n从 Laravel 8 升级到 Laravel 9 的过程中，可能会出现与 `TrustedProxy` 中间件相关的错误 `Undefined constant Illuminate\\Http\\Request::HEADER_X_FORWARDED_ALL` 从而导致升级中断，解决方法如下：\r\n\r\n修改文件 `app/Http/Middleware/TrustProxies.php`中：\r\n\r\n原文 `Use Fideloper\\Proxy\\TrustProxies as Middle;`\r\n\r\n修改为 `Use Illuminate\\Http\\Middleware\\TrustProxies as Middleware;`\r\n\r\n修改 `$headers` 的赋值为：\r\n\r\n```\r\nprotected $headers =\r\n    Request::HEADER_X_FORWARDED_FOR |\r\n    Request::HEADER_X_FORWARDED_HOST |\r\n    Request::HEADER_X_FORWARDED_PORT |\r\n    Request::HEADER_X_FORWARDED_PROTO |\r\n    Request::HEADER_X_FORWARDED_AWS_ELB;\r\n```\r\n\r\n最后，移除旧的依赖： `composer remove fideloper/proxy` 即可继续执行升级步骤。\r\n\r\n<a name=\"miscellaneous\"></a>\r\n### Miscellaneous\r\n\r\n我们还鼓励您查看 `laravel/laravel` [GitHub 存储库](https://github.com/laravel/laravel) 中的更改 虽然其中许多更改不是必需的，但您可能希望使这些文件与您的应用程序保持同步。 本升级指南将涵盖其中一些更改，但其他更改（例如对配置文件或注释的更改）将不会涵盖。 您可以使用 [GitHub 比较工具](https://github.com/laravel/laravel/compare/8.x...9.x) 轻松查看更改并选择哪些更新对您很重要。\r\n\r\n","p":"docs/upgrade.html"},{"t":"contributions (贡献导引)","d":"# 贡献导引\r\n\r\n- [Bug 报告](#bug-reports)\r\n- [帮助支持](#support-questions)\r\n- [核心发展讨论](#core-development-discussion)\r\n- [哪个分支？](#which-branch)\r\n- [编译资源](#compiled-assets)\r\n- [安全漏洞](#security-vulnerabilities)\r\n- [代码风格](#coding-style)\r\n    - [PHPDoc](#phpdoc)\r\n    - [StyleCI](#styleci)\r\n- [行为守则](#code-of-conduct)\r\n\r\n<a name=\"bug-reports\"></a>\r\n## Bug 报告\r\n\r\n为了鼓励积极的合作，Laravel 强烈鼓励提交 pull request，而不仅仅是提交「Bug 报告」。「Bug 报告」也可以包含失败测试的 pull request 的形式发送。只有在标记为「准备好审核」（而不是处于「草稿」状态）并且新功能的所有测试都通过时，才会审核拉取请求。停留在「草稿」状态的、非活动的拉取请求将在几天后关闭。\r\n\r\n然而，如果你提交了一个 Bug 报告，你的问题（issue）应该包含一个标题和对问题的清晰描述。你还应该包含尽可能多的相关信息以及演示该问题的代码示例。错误报告的目标是使您自己（以及其他人）能够轻松地复现错误并开发修复程序。\r\n\r\n请记住，创建 Bug 报告是希望有相同问题的其他人能够与您协作解决它。不要期望 Bug 报告能够自动查看任何活动或者其他人跳转自此来修复它。创建 Bug 报告有助于你自己和其他人开始修复问题。如果你想加入，你可以通过修复 [issues 列表](https://github.com/issues?q=is%3Aopen+is%3Aissue+label%3Abug+user%3Alaravel) 来提供帮助。你必须通过 GitHub 认证才能查看 Laravel 的所有问题。\r\n\r\n\r\nLaravel 源码托管在 GitHub 上，每个项目都有一个仓库：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [Laravel Application](https://github.com/laravel/laravel)\r\n- [Laravel Art](https://github.com/laravel/art)\r\n- [Laravel Documentation](https://github.com/laravel/docs)\r\n- [Laravel Dusk](https://github.com/laravel/dusk)\r\n- [Laravel Cashier Stripe](https://github.com/laravel/cashier)\r\n- [Laravel Cashier Paddle](https://github.com/laravel/cashier-paddle)\r\n- [Laravel Echo](https://github.com/laravel/echo)\r\n- [Laravel Envoy](https://github.com/laravel/envoy)\r\n- [Laravel Framework](https://github.com/laravel/framework)\r\n- [Laravel Homestead](https://github.com/laravel/homestead)\r\n- [Laravel Homestead Build Scripts](https://github.com/laravel/settler)\r\n- [Laravel Horizon](https://github.com/laravel/horizon)\r\n- [Laravel Jetstream](https://github.com/laravel/jetstream)\r\n- [Laravel Passport](https://github.com/laravel/passport)\r\n- [Laravel Sail](https://github.com/laravel/sail)\r\n- [Laravel Sanctum](https://github.com/laravel/sanctum)\r\n- [Laravel Scout](https://github.com/laravel/scout)\r\n- [Laravel Socialite](https://github.com/laravel/socialite)\r\n- [Laravel Telescope](https://github.com/laravel/telescope)\r\n- [Laravel Website](https://github.com/laravel/laravel.com-next)\r\n\r\n</div>\r\n\r\n<a name=\"support-questions\"></a>\r\n## 帮助支持\r\n\r\nLaravel 的 GitHub issue 不打算提供 Laravel 的帮助或支持。相反，可以使用以下途径之一:\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [GitHub 讨论](https://github.com/laravel/framework/discussions)\r\n- [Laracasts 论坛](https://laracasts.com/discuss)\r\n- [Laravel.io 论坛](https://laravel.io/forum)\r\n- [StackOverflow](https://stackoverflow.com/questions/tagged/laravel)\r\n- [Discord](https://discord.gg/laravel)\r\n- [Larachat](https://larachat.co)\r\n- [IRC](https://web.libera.chat/?nick=artisan&channels=#laravel)\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"core-development-discussion\"></a>\r\n## 核心开发讨论\r\n\r\n你可以在 Laravel 框架存储库的 [GitHub 讨论区](https://github.com/laravel/framework/discussions) 中提出新功能或对现有 Laravel 行为的改进。 如果您提出一项新功能，请愿意至少实现一些完成该功能所需的代码。\r\n\r\n在 [Laravel Discord 服务器](https://discord.gg/laravel) 的 `#internals` 频道中进行了有关错误、新功能和现有功能实现的非正式讨论。 Laravel 的维护者 Taylor Otwell 通常在工作日的上午 8 点至下午 5 点（UTC-06:00 或美国/芝加哥）出现在频道中，并在其他时间偶尔出现在频道中。\r\n\r\n<a name=\"which-branch\"></a>\r\n## 哪个分支？\r\n\r\n**所有**错误修复应发送到最新的稳定分支。 错误修复不应该被发送到 `master` 分支，除非它们修复了仅存在于即将发布的版本中的功能。\r\n\r\n**与当前版本**完全向后兼容**的**次要**功能可能会发送到最新的稳定分支。\r\n\r\n**主要** 新功能应始终发送到包含即将发布的版本的 `master` 分支。\r\n\r\n如果您不确定您的功能是否符合主要或次要功能，请在 [Laravel Discord 服务器](https://discord.gg/laravel) 的 `#internals` 频道中询问 Taylor Otwell。\r\n\r\n<a name=\"compiled-assets\"></a>\r\n## 编译文件\r\n\r\n如果您提交的更改会影响已编译文件，例如 `laravel/laravel` 存储库的 `resources/css` 或 `resources/js` 中的大部分文件，请不要提交已编译文件。 由于它们的体积很大，维护者实际上无法对其进行审查。 这可能被用作将恶意代码注入 Laravel 的一种方式。 为了防御性地防止这种情况发生，所有编译的文件都将由 Laravel 维护者生成和提交。\r\n\r\n\r\n\r\n<a name=\"security-vulnerabilities\"></a>\r\n## 安全漏洞\r\n\r\n如果你发现 Laravel 中存在安全漏洞，请发送电子邮件至 <a href=\"mailto:taylor@laravel.com\">taylor@laravel.com</a> 给 Taylor Otwell。 所有安全漏洞都将得到及时解决。\r\n\r\n<a name=\"coding-style\"></a>\r\n## 编码风格\r\n\r\nLaravel 遵循 [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) 编码标准和 [PSR- 4](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md) 自动加载标准。\r\n\r\n<a name=\"phpdoc\"></a>\r\n### PHP文档\r\n\r\n下面是一个有效的 Laravel 文档块的示例。 请注意，`@param` 属性后跟两个空格、参数类型、另外两个空格，最后是变量名：\r\n\r\n    /**\r\n     * 向容器注册绑定。\r\n     *\r\n     * @param  string|array  $abstract\r\n     * @param  \\Closure|string|null  $concrete\r\n     * @param  bool  $shared\r\n     * @return void\r\n     *\r\n     * @throws \\Exception\r\n     */\r\n    public function bind($abstract, $concrete = null, $shared = false)\r\n    {\r\n        //\r\n    }\r\n\r\n<a name=\"styleci\"></a>\r\n### StyleCI\r\n\r\n如果您的代码样式不完美，请不要担心！ [StyleCI](https://styleci.io/) 将在合并拉取请求后自动将任何样式修复合并到 Laravel 存储库中。 这使我们能够专注于贡献的内容，而不是代码风格。\r\n\r\n<a name=\"code-of-conduct\"></a>\r\n## 行为准则\r\n\r\nLaravel 行为准则源自 Ruby 行为准则。 任何违反行为准则的行为都可以报告给 Taylor Otwell (taylor@laravel.com)：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- 参与者将容忍反对意见。\r\n- 参与者必须确保他们的语言和行为没有人身攻击和贬低个人言论。\r\n- 在解释他人的言行时，参与者应始终保持良好的意图。\r\n- 不能容忍可合理视为骚扰的行为。\r\n\r\n</div>\r\n\r\n","p":"docs/contributions.html"},{"t":"installation (安装)","d":"# 安装\r\n\r\n- [认识 Laravel](#meet-laravel)\r\n  - [为什么选择 Laravel?](#why-laravel)\r\n- [你的第一个 Laravel 项目](#your-first-laravel-project)\r\n  - [macOS 入门](#getting-started-on-macos)\r\n  - [Windows 入门](#getting-started-on-windows)\r\n  - [Linux 入门](#getting-started-on-linux)\r\n  - [选择 Sail 服务](#choosing-your-sail-services)\r\n  - [通过 Composer 安装](#installation-via-composer)\r\n- [初始化](#initial-configuration)\r\n  - [基于环境的配置](#environment-based-configuration)\r\n  - [目录配置](#directory-configuration)\r\n- [下一步](#next-steps)\r\n  - [将 Laravel 用作全栈框架](#laravel-the-fullstack-framework)\r\n  - [将 Laravel 用作 API 后端](#laravel-the-api-backend)\r\n\r\n<a name=\"meet-laravel\"></a>\r\n## 认识 Laravel\r\n\r\nLaravel 是一个 Web应用框架， 有着表现力强、语法优雅的特点。Web 框架为创建应用提供了一个结构和起点，你只需要专注于创造，我们来为你处理细节。\r\n\r\nLaravel 致力于提供出色的开发体验，同时提供强大的特性，例如完全的依赖注入，富有表现力的数据库抽象层，队列和计划任务，单元和集成测试等等。\r\n\r\n无论你是刚刚接触 PHP 和 Web 框架的新人，亦或是有着多年经验的老手， Laravel 都是一个可以与你一同成长的框架。我们将帮助你迈出成为 Web 开发者的第一步，或是将你的经验提高到下一个等级。我们迫不及待的想看看你的作品。\r\n\r\n<a name=\"why-laravel\"></a>\r\n### 为什么选择 Laravel?\r\n\r\n有非常多的工具和框架可以被用于构建一个 Web 应用。但我们相信 Laravel 是构建现代化、全栈 Web 应用的最佳选择。\r\n\r\n#### 一个渐进式框架\r\n\r\n我们喜欢称 Laravel 是一个「渐进式」框架。意思是 Laravel 将与你一同成长。如果你是首次进入 Web 开发， Laravel 大量的文档、指南和 [视频教程](https://laracasts.com) 将帮助你熟悉使用技巧而不至于不知所措。\r\n\r\n如果你是高级开发人员，Laravel 为你提供了强大的工具用于 [依赖注入](/docs/laravel/9.x/container)、[单元测试](/docs/laravel/9.x/testing)、[队列](/docs/laravel/9.x/queues)、[广播系统](/docs/laravel/9.x/broadcasting) 等等。Laravel 为构建专业的 Web 应用程序进行了微调，并准备好处理企业工作负载。\r\n\r\n#### 一个可扩展的框架\r\n\r\nLaravel 具有难以置信的可扩展性。由于 PHP 的灵活性以及 Laravel 对 Redis 等快速分布式缓存系统的内置支持，使用 Laravel 进行扩展是轻而易举的事。事实上，Laravel 应用程序已经很容易扩展到每月处理数亿个请求。\r\n\r\n需要压缩开发费用吗？ [Laravel Vapor](https://vapor.laravel.com) 允许你在 AWS 最新的无服务器技术上以几乎无限的规模运行 Laravel 应用程序。\r\n\r\n#### 一个社区化的框架\r\n\r\nLaravel 结合了 PHP 生态系统中最好的软件包，提供了最健壮、对开发人员友好的框架。此外，来自世界各地的数千名有才华的开发人员[为框架做出了贡献](https://github.com/laravel/framework)。谁知道呢，也许你就是下一个 Laravel 的贡献者。\r\n\r\n<a name=\"your-first-laravel-project\"></a>\r\n## 你的第一个 Laravel 项目\r\n\r\n我们希望尽可能轻松地开始使用 Laravel。在你自己的计算机上开发和运行 Laravel 项目有多种选择。虽然你可能希望以后再研究这些选项，但 Laravel 提供了 [Sail](/docs/laravel/9.x/sail)，使用 [Docker](https://www.docker.com) 运行 Laravel 项目的内置解决方案\r\n\r\nDocker 是一种在小型、轻量级的「容器」中运行应用程序和服务的工具，它不会干扰本地计算机安装的软件或配置。这意味着你不必担心在个人计算机上配置或设置复杂的开发工具，例如 web 服务器和数据库。要开始，你只需安装 [Docker Desktop](https://www.docker.com/products/docker-desktop)。\r\n\r\nLaravel Sail 是一个轻量级的命令行界面，用于与 Laravel 的默认 Docker 配置进行交互。Sail 为使用 PHP、MySQL 和 Redis 构建 Laravel 应用程序提供了一个很好的起点，而无需之前的 Docker 经验。\r\n\r\n> 技巧：已经是 Docker 专家？别担心！关于 Sail 的一切都可以使用Laravel 附带的文件 `docker-compose.yml` 进行自定义。\r\n\r\n<a name=\"getting-started-on-macos\"></a>\r\n### macOS 入门\r\n\r\n如果你在 Mac 上开发并且已经安装了 [Docker Desktop](https://www.docker.com/products/docker-desktop)，你可以使用一个简单的终端命令来创建一个新的 Laravel 项目。 例如，要在名为「example-app」的目录中创建一个新的 Laravel 应用程序，你可以在终端中运行以下命令：\r\n\r\n```shell\r\ncurl -s \"https://laravel.build/example-app\" | bash\r\n```\r\n\r\n当然，你可以将此 URL 中的「example-app」更改为你喜欢的任何内容。Laravel 应用程序的目录将在你执行命令的目录中创建。\r\n\r\n创建项目后，你可以导航到应用程序目录并启动 Laravel Sail。Laravel Sail 提供了一个简单的命令行界面，用于与 Laravel 的默认 Docker 配置进行交互：\r\n\r\n```shell\r\ncd example-app\r\n./vendor/bin/sail up\r\n```\r\n\r\n第一次运行 Sail `up` 命令时， Sail 的应用程序容器将在你的机器上构建。这可能需要几分钟。 **不用担心，随后尝试启动 Sail 会快得多。**\r\n\r\n启动应用程序的 Docker 容器后，你可以在 Web 浏览器中访问应用程序： http://localhost 。\r\n\r\n> 技巧：要继续了解有关 Laravel Sail 的更多信息，请查看其 [完整文档](/docs/laravel/9.x/sail)。\r\n\r\n<a name=\"getting-started-on-windows\"></a>\r\n### Windows 入门\r\n\r\n在新建 Laravel 应用前，请确保你的 Windows 电脑已经安装了 [Docker Desktop](https://www.docker.com/products/docker-desktop)。之后，请确保已经安装并启用了适用于 Linux 的 Windows 子系统 2 （WSL2）。 WSL 允许你在 Windows 10 上运行 Linux 二进制文件。关于如何安装并启用 WSL2，请参阅微软 [开发者环境文档](https://docs.microsoft.com/en-us/windows/wsl/install-win10)。\r\n\r\n> 技巧：安装并启用 WSL2 后，请确保 Docker Desktop 已经 [配置为使用 WSL2 后端](https://docs.docker.com/docker-for-windows/wsl/)。\r\n\r\n接下来，准备创建你的第一个 Laravel 项目。启动 [Windows Terminal](https://www.microsoft.com/en-us/p/windows-terminal/9n0dx20hk701?rtc=1&activetab=pivot:overviewtab)，为 WSL2 Linux 操作系统打开一个终端。之后，你可以使用简单的命令来新建 Laravel 项目。比如，想要在「example-app」文件夹中新建 Laravel 应用，可以在终端中运行以下命令：\r\n\r\n```shell\r\ncurl -s https://laravel.build/example-app | bash\r\n```\r\n\r\n当然，你可以任意更改 URL 中的「example-app」。Laravel 应用将被创建在执行命令的文件夹中。\r\n\r\n创建项目后，你可以切换到应用目录并启动 Laravel Sail。Laravel Sail 提供了一个简单的命令行接口，用于和 Laravel 默认 Docker 配置进行交互：\r\n\r\n```shell\r\ncd example-app\r\n./vendor/bin/sail up\r\n```\r\n\r\n在你首次运行 Sail 的 `up` 命令的时候，Sail 的应用容器将会在你的机器上进行编译。这个过程将会花费几分钟时间。**不要担心，以后就会很快了。**\r\n\r\n一旦应用的 Docker 容器启动了，你便可在 Web 浏览器中通过 http://localhost 访问你的应用了。\r\n\r\n> 技巧：要继续学习更多关于 Laravel Sail 的知识，请参阅 [详细文档](/docs/laravel/9.x/sail)。\r\n\r\n#### 使用 WSL2 进行开发\r\n\r\n当然，你需要能够修改在 WSL2 安装中创建的 Laravel 应用程序文件。我们推荐你使用微软的 [Visual Studio Code](https://code.visualstudio.com) 编辑器并搭配其 [Remote Development](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack) 扩展，它们可以帮助你解决这个问题。\r\n\r\n一旦这些工具成功安装，你可以使用 Windows Terminal 在应用根目录执行 `code .` 命令来打开任何 Laravel 项目。\r\n\r\n<a name=\"getting-started-on-linux\"></a>\r\n### 在 Linux 使用 Laravel Sail\r\n\r\n如果在 Linux 开发，并且已经安装了 [Docker Compose](https://docs.docker.com/compose/install/)，你可以使用简单的终端命令来创建一个新的 Laravel 项目。例如，要在「example-app」目录中创建新的 Laravel 应用，你可以在终端中运行如下命令：\r\n\r\n```shell\r\ncurl -s https://laravel.build/example-app | bash\r\n```\r\n\r\n当然，你可以将 URL 中的「example-app」替换为任何你喜欢的内容。Laravel 应用程序的目录将在执行命令的目录中创建。\r\n\r\n在项目创建完成后，你可以导航至应用目录和启动 Laravel Sail。Laravel Sail 提供了一个简单的命令行接口，用于与 Laravel 的默认 Docker 配置进行交互：\r\n\r\n```shell\r\ncd example-app\r\n./vendor/bin/sail up\r\n```\r\n\r\n在你首次运行 Sail 的 `up` 命令的时候，Sail 的应用容器将会在你的机器上进行编译。这个过程将会花费一段时间。**不要担心，以后就会很快了。**\r\n\r\n一旦应用的 Docker 容器启动了，你便可在 Web 浏览器中通过 http://localhost 访问你的应用了。\r\n\r\n> 技巧：要继续学习更多关于 Laravel Sail 的知识，请参阅 [详细文档](/docs/laravel/9.x/sail)。\r\n\r\n<a name=\"choosing-your-sail-services\"></a>\r\n### 选择你的 Sail 服务\r\n\r\n当通过 Sail 创建一个新的 Laravel 应用程序时, 你可以通过 `with` 查询变量来选择哪些服务需要配置到你的新应用程序的 `docker-compose.yml` 文件。 可选择的服务包括 `mysql`，`pgsql`，`mariadb`，`redis`，`memcached`，`meilisearch`，`minio`，`selenium` 和 `mailhog`：\r\n\r\n```shell\r\ncurl -s \"https://laravel.build/example-app?with=mysql,redis\" | bash\r\n```\r\n\r\n如果你没有制定你想配置的服务, 默认将配置 `mysql`，`redis`，`meilisearch`，`mailhog` 和 `selenium`。\r\n\r\n你可以通过在 URL 中添加 [容器开发](/docs/laravel/9.x/sail#using-devcontainers)\r\n参数来指定 Sail 默认安装的服务。\r\n\r\n```shell\r\ncurl -s \"https://laravel.build/example-app?with=mysql,redis&devcontainer\" | bash\r\n```\r\n\r\n<a name=\"installation-via-composer\"></a>\r\n### 通过 Composer 安装\r\n\r\n如果你的终端已经安装了 PHP 和 Composer，你可以直接使用 Composer 来创建一个新的 Laravel 项目。 当应用程序创建完成后，你可以通过 Artisan CLI 的 `serve` 命令来启动 Laravel 的本地服务：\r\n\r\n```shell\r\ncomposer create-project laravel/laravel example-app\r\ncd example-app\r\nphp artisan serve\r\n```\r\n\r\n<a name=\"the-laravel-installer\"></a>\r\n#### 通过 Laravel 安装器\r\n\r\n或者, 你可以通过 Laravel 安装器作为全局 Composer 依赖：\r\n\r\n```shell\r\ncomposer global require laravel/installer\r\nlaravel new example-app\r\ncd example-app\r\nphp artisan serve\r\n```\r\n\r\n请确保将 Composer 的全局 vendor bin 目录放置在你的系统环境变量 `$PATH` 中，以便系统可以找到 `laravel` 的可执行文件。在不同的操作系统中，该目录的路径也不相同；下面列出一些常见的位置：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- macOS: `$HOME/.composer/vendor/bin`\r\n- Windows: `%USERPROFILE%\\AppData\\Roaming\\Composer\\vendor\\bin`\r\n- GNU / Linux Distributions: `$HOME/.config/composer/vendor/bin` or `$HOME/.composer/vendor/bin`\r\n\r\n</div>\r\n\r\n为方便起见，Laravel 安装程序还可以为你的新项目创建一个 Git 仓库。如需创建 Git 仓库，请在创建新项目时通过 `--git` 指定：\r\n\r\n```shell\r\nlaravel new example-app --git\r\n```\r\n此命令将为你的项目初始化一个新的 Git 仓库并自动提交基础的 Laravel 框架。使用 `git` 命令前请确保你已正确安装并配置 Git。你还可以使用该 `--branch` 命令来设置初始的分支名称：\r\n\r\n```shell\r\nlaravel new example-app --git --branch=\"main\"\r\n```\r\n\r\n除了使用 `--git` 命令之外，你还可以使用 `--github` 命令在 GitHub 上创建相应的私有仓库：\r\n\r\n```shell\r\nlaravel new example-app --github\r\n```\r\n\r\n创建的仓库将在 `https://github.com/<your-account>/example-app` 上。 使用 `github` 命令前请确保你已正确安装 [GitHub CLI](https://cli.github.com) 并已通过 GitHub 进行身份验证。此外，你还应该安装 `git` 并正确配置。如果需要，你可以传递 GitHub CLI 支持的其它命令：\r\n\r\n```shell\r\nlaravel new example-app --github=\"--public\"\r\n```\r\n\r\n你可以使用 `--organization` 命令在特定的 GitHub 组织下创建仓库：\r\n\r\n```shell\r\nlaravel new example-app --github=\"--public\" --organization=\"laravel\"\r\n```\r\n\r\n## 初始配置\r\nLaravel 框架的所有配置文件都存储在 `config` 目录中。每个选项都有文档记录，所以请随意浏览这些文件并熟悉可用的选项。\r\n\r\nLaravel 几乎不需要额外的配置。你可以自由地开始开发！然而，你可能希望查看 `config/app.php` 文件及其文档。它包含几个选项，比如 `timezone` 和 `locale`，你可能希望根据你的应用程序进行更改。\r\n\r\n<a name=\"environment-based-configuration\"></a>\r\n### 基于环境的配置\r\n\r\n由于 Laravel 的许多配置选项值可能会根据你的应用程序是在本地计算机上还是在生产 Web 服务器上运行而有所不同，因此许多重要的配置值是使用 `.env` 存在于应用程序根目录中的文件来定义的。\r\n\r\n你的 `.env` 文件不应提交到应用程序的源代码管理，因为每个使用你的应用程序的开发人员/服务器可能需要不同的环境配置。此外，如果入侵者获得对你的源代码控制存储库的访问权限，这将是一个安全风险，因为任何敏感凭据都会被暴露。\r\n\r\n> 技巧：有关 `.env` 基于文件和环境的配置的更多信息，请查看完整的 [配置文档](/docs/laravel/9.x/configuration#environment-configuration)。\r\n\r\n<a name=\"directory-configuration\"></a>\r\n### 目录配置\r\n\r\nLaravel 应该始终从为你的 Web 服务器配置的「Web 目录」的根目录中提供服务。你不应该尝试从「Web 目录」的子目录中提供 Laravel 应用程序。尝试这样做可能会暴露应用程序中存在的敏感文件。\r\n\r\n<a name=\"next-steps\"></a>\r\n## 下一步\r\n\r\n现在你已经创建了 Laravel 项目，你可能想知道接下来要学习什么。首先，我们强烈建议你通过阅读以下文档来熟悉 Laravel 的工作原理：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [请求生命周期](/docs/laravel/9.x/lifecycle)\r\n- [配置](/docs/laravel/9.x/configuration)\r\n- [目录结构](/docs/laravel/9.x/structure)\r\n- [服务容器](/docs/laravel/9.x/container)\r\n- [Facades](/docs/laravel/9.x/facades)\r\n\r\n</div>\r\n\r\n你想如何使用 Laravel 也将决定你旅程的下一步。有多种使用 Laravel 的方法，我们将探讨以下框架的两个主要用例。\r\n\r\n<a name=\"laravel-the-fullstack-framework\"></a>\r\n### Laravel 全栈框架\r\n\r\nLaravel 可以作为一个全栈框架。「全栈」框架是指你将使用 Laravel 将请求路由到你的应用程序，并通过 [Blade 模板](/docs/laravel/9.x/blade) 或使用单页应用程序混合技术 [Inertia.js](https://inertiajs.com) 呈现你的前端。这是使用 Laravel 框架最常见的方式。\r\n\r\n如果这是你计划使用 Laravel 的方式，你可能需要查看我们关于 [路由](/docs/laravel/9.x/routing)，[视图](/docs/laravel/9.x/views)，或者 [Eloquent ORM](/docs/laravel/9.x/eloquent) 的文档。此外，你可能有兴趣了解 [Livewire](https://laravel-livewire.com) 和 [Inertia.js](https://inertiajs.com) 等社区软件包。这些包允许你将 Laravel 用作全栈框架，同时享受单页 JavaScript 应用程序提供的许多 UI 优势。\r\n\r\n如果你使用 Laravel 作为全栈框架，我们也强烈建议你学习如何使用 [Laravel Mix](/docs/laravel/9.x/mix) 编译应用程序的 CSS 和 JavaScript 。\r\n\r\n> 技巧：如果你想尽快构建你的应用程序，请查看我们的官方 [应用程序入门工具包](/docs/laravel/9.x/starter-kits)。\r\n\r\n<a name=\"laravel-the-api-backend\"></a>\r\n### Laravel API 后端\r\n\r\nLaravel 也可以作为 JavaScript 单页应用程序或移动应用程序的 API 后端。例如，你可以使用 Laravel 作为 [Next.js](https://nextjs.org) 应用程序的 API 后端。在这种情况下，你可以使用 Laravel 为你的应用程序提供 [身份验证](/docs/laravel/9.x/sanctum) 和数据存储/检索，同时还可以利用 Laravel 的强大服务，例如队列、电子邮件、通知等。\r\n\r\n如果这是你计划使用 Laravel 的方式，你可能需要查看我们关于 [路由](/docs/laravel/9.x/routing), [Laravel Sanctum](/docs/laravel/9.x/sanctum) 和 [Eloquent ORM](/docs/laravel/9.x/eloquent) 的文档。\r\n\r\n> 技巧：需要抢先搭建 Laravel 后端和 Next.js 前端的脚手架？Laravel Breeze 提供了 [API 堆栈](/docs/laravel/9.x/starter-kits#breeze-and-next) 以及 [Next.js 前端实现](https://github.com/laravel/breeze-next) ，因此你可以在几分钟内开始使用。","p":"docs/installation.html"},{"t":"configuration (配置)","d":"# 配置\r\n\r\n- [介绍](#introduction)\r\n- [环境配置](#environment-configuration)\r\n     - [环境变量类型](#environment-variable-types)\r\n     - [检索环境配置](#retrieving-environment-configuration)\r\n     - [确定当前环境](#determining-the-current-environment)\r\n- [访问配置值](#accessing-configuration-values)\r\n- [配置缓存](#configuration-caching)\r\n- [调试模式](#debug-mode)\r\n- [维护模式](#maintenance-mode)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 框架的所有配置文件都存储在 `config` 目录中。 每个选项都记录在案，因此请随意查看文件并熟悉可用的选项。\r\n\r\n这些配置文件允许您配置诸如数据库连接信息、邮件服务器信息以及各种其他核心配置值（例如应用程序时区和加密密钥）之类的内容。\r\n\r\n<a name=\"environment-configuration\"></a>\r\n## 环境配置\r\n\r\n根据应用程序运行的环境设置不同的配置值通常很有帮助。 例如，您可能希望在本地使用与在生产服务器上不同的缓存驱动程序。\r\n\r\n为了让这件事变得轻而易举，Laravel 使用了 [DotEnv](https://github.com/vlucas/phpdotenv) PHP 库。 在全新的 Laravel 安装中，应用程序的根目录将包含一个 `.env.example` 文件，该文件定义了许多常见的环境变量。 在 Laravel 安装过程中，该文件会自动复制到 `.env`。\r\n\r\nLaravel 的默认 `.env` 文件包含一些常见的配置值，这些值可能会根据您的应用程序是在本地运行还是在生产 Web 服务器上运行而有所不同。 然后使用 Laravel 的 `env` 函数从 `config` 目录中的各种 Laravel 配置文件中检索这些值。\r\n\r\n\r\n\r\n如果您正在与团队一起开发，您可能希望继续在您的应用程序中包含一个 `.env.example` 文件。 通过将占位符值放入示例配置文件中，您团队中的其他开发人员可以清楚地看到运行您的应用程序需要哪些环境变量。\r\n\r\n> 技巧：`.env` 文件中的任何变量都可以被外部环境变量覆盖，例如服务器级或系统级环境变量。\r\n\r\n<a name=\"environment-file-security\"></a>\r\n#### 环境文件安全\r\n\r\n您的 `.env` 文件不应提交给应用程序的源代码管理，因为每个使用您的应用程序的开发人员/服务器可能需要不同的环境配置。 此外，如果入侵者获得对您的源代码控制存储库的访问权限，这将是一个安全风险，因为任何敏感凭据都会被暴露。\r\n\r\n<a name=\"additional-environment-files\"></a>\r\n#### 附加环境文件\r\n\r\n在加载应用程序的环境变量之前，Laravel 会确定是否已经从外部提供了 `APP_ENV` 环境变量，或者是否指定了 `--env` CLI 参数。 如果是这样，Laravel 将尝试加载一个 `.env.[APP_ENV]` 文件（如果它存在）。 如果它不存在，将加载默认的 `.env` 文件。\r\n\r\n<a name=\"environment-variable-types\"></a>\r\n### 环境变量类型\r\n\r\n`.env` 文件中的所有变量通常都被解析为字符串，因此创建了一些保留值以允许您从 `env()` 函数返回更广泛的类型：\r\n\r\n`.env` Value  | `env()` Value\r\n------------- | -------------\r\ntrue | (bool) true\r\n(true) | (bool) true\r\nfalse | (bool) false\r\n(false) | (bool) false\r\nempty | (string) ''\r\n(empty) | (string) ''\r\nnull | (null) null\r\n(null) | (null) null\r\n\r\n\r\n\r\n如果您需要使用包含空格的值定义环境变量，可以通过将值括在双引号中来实现：\r\n\r\n```ini\r\nAPP_NAME=\"My Application\"\r\n```\r\n\r\n<a name=\"retrieving-environment-configuration\"></a>\r\n### 获取环境配置\r\n\r\n当应用程序收到请求时，```.env``` 文件中列出的所有变量将被加载到 PHP 的超级全局变量 ```$_ENV``` 中。你可以使用 ```env``` 函数检索这些变量的值。实际上，如果你看过 Laravel 的配置文件，就能注意到有数个选项已经使用了这个函数：\r\n\r\n    'debug' => env('APP_DEBUG', false),\r\n\r\nenv 函数的第二个参数是「默认值」。 当没有找到对应环境变量时将返回 「默认值」\r\n\r\n<a name=\"determining-the-current-environment\"></a>\r\n### 获取当前环境配置\r\n\r\n当前应用的环境配置是从你的  `.env` 文件中的 `APP_ENV` 变量配置的。你可以通过 `App` [facade](/docs/laravel/9.x/facades) 的 `environment` 函数获取：\r\n\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $environment = App::environment();\r\n\r\n你还可以将参数传递给 `environment`  函数，以确定当前环境是否匹配给定的值。当环境匹配给参数它将返回  `true`\r\n\r\n    if (App::environment('local')) {\r\n        // 当前环境是 local\r\n    }\r\n\r\n    if (App::environment(['local', 'staging'])) {\r\n        // 当前环境是 local 或 staging ...\r\n    }\r\n\r\n> 技巧：当前应用程序的环境检测，可以通过定义服务器级`APP_ENV`环境变量来覆盖。\r\n\r\n<a name=\"accessing-configuration-values\"></a>\r\n## 访问配置值\r\n\r\n\r\n\r\n您可以在应用程序的任何位置使用全局 `config` 辅助函数轻松访问配置值。 可以使用“点”语法访问配置值，其中包括您希望访问的文件名和选项。 也可以指定默认值，如果配置选项不存在，将返回：\r\n\r\n    $value = config('app.timezone');\r\n\r\n    // 如果配置值不存在，则检索默认值...\r\n    $value = config('app.timezone', 'Asia/Seoul');\r\n\r\n要在运行时设置配置值，请将数组传递给 `config` 助手：\r\n\r\n    config(['app.timezone' => 'America/Chicago']);\r\n\r\n<a name=\"configuration-caching\"></a>\r\n## 配置缓存\r\n\r\n为了提高应用程序的速度，您应该使用 `config:cache` Artisan 命令将所有配置文件缓存到一个文件中。 这会将应用程序的所有配置选项组合到一个文件中，框架可以快速加载该文件。\r\n\r\n您通常应该在生产部署过程中运行 `php artisan config:cache` 命令。 该命令不应在本地开发期间运行，因为在应用程序开发过程中经常需要更改配置选项。\r\n\r\n> 注意：如果您在部署过程中执行 `config:cache` 命令，则应确保仅从配置文件中调用 `env` 函数。 一旦配置被缓存，`.env` 文件将不会被加载； 因此，`env` 函数只会返回外部的系统级环境变量。\r\n\r\n<a name=\"debug-mode\"></a>\r\n\r\n\r\n## 调试模式\r\n\r\n`config/app.php` 配置文件中的 `debug` 选项决定了实际向用户显示的错误信息量。 默认情况下，此选项设置为尊重 `APP_DEBUG` 环境变量的值，该变量存储在您的 `.env` 文件中。\r\n\r\n对于本地开发，您应该将 `APP_DEBUG` 环境变量设置为 `true`。 **在您的生产环境中，此值应始终为 `false`。 如果在生产环境中将该变量设置为 `true`，您可能会将敏感的配置值暴露给应用程序的最终用户。**\r\n\r\n<a name=\"maintenance-mode\"></a>\r\n## 维护模式\r\n\r\n当您的应用程序处于维护模式时，将为您的应用程序的所有请求显示一个自定义视图。 这使得在更新或执行维护时可以轻松“禁用”您的应用程序。 维护模式检查包含在应用程序的默认中间件堆栈中。 如果应用程序处于维护模式，则会抛出一个 `Symfony\\Component\\HttpKernel\\Exception\\HttpException` 实例，状态码为 503。\r\n\r\n要启用维护模式，请执行 `down` Artisan 命令：\r\n\r\n```shell\r\nphp artisan down\r\n```\r\n\r\n如果您希望 `Refresh` HTTP 标头与所有维护模式响应一起发送，您可以在调用 `down` 命令时提供 `refresh` 选项。 `Refresh` 标头将指示浏览器在指定秒数后自动刷新页面：\r\n\r\n```shell\r\nphp artisan down --refresh=15\r\n```\r\n\r\n您还可以为 `down` 命令提供 `retry` 选项，该选项将设置为 `Retry-After` HTTP 标头的值，尽管浏览器通常会忽略此标头：\r\n\r\n```shell\r\nphp artisan down --retry=60\r\n```\r\n\r\n\r\n\r\n<a name=\"bypassing-maintenance-mode\"></a>\r\n#### 绕过维护模式\r\n\r\n即使在维护模式下，您也可以使用 `secret` 选项来指定维护模式绕过令牌：\r\n\r\n```shell\r\nphp artisan down --secret=\"1630542a-246b-4b66-afa1-dd72a4c43515\"\r\n```\r\n\r\n将应用程序置于维护模式后，您可以导航到与此令牌匹配的应用程序 URL，Laravel 将向您的浏览器发出维护模式绕过 cookie：\r\n\r\n```shell\r\nhttps://example.com/1630542a-246b-4b66-afa1-dd72a4c43515\r\n```\r\n\r\n访问此隐藏路由时，您将被重定向到应用程序的 `/` 路由。 将 cookie 发送到您的浏览器后，您将能够正常浏览应用程序，就好像它未处于维护模式一样。\r\n\r\n> 技巧：维护模式 `secret` 通常应由字母数字字符和破折号`-`组成。您应该避免在 URL 中使用具有特殊含义的字符，例如 `?`。\r\n\r\n<a name=\"pre-rendering-the-maintenance-mode-view\"></a>\r\n#### 预渲染维护模式视图\r\n\r\n如果您在部署期间使用 `php artisan down` 命令，如果您的用户在您的 Composer 依赖项或其他基础架构组件更新时访问应用程序，他们仍可能偶尔会遇到错误。 这是因为 Laravel 框架的重要部分必须启动才能确定您的应用程序处于维护模式并使用模板引擎呈现维护模式视图。\r\n\r\n出于这个原因，Laravel 允许您预渲染一个维护模式视图，该视图将在请求周期的最开始返回。 此视图在您的应用程序的任何依赖项加载之前呈现。 您可以使用 `down` 命令的 `render` 选项预渲染您选择的模板：\r\n\r\n```shell\r\nphp artisan down --render=\"errors::503\"\r\n```\r\n\r\n\r\n\r\n<a name=\"redirecting-maintenance-mode-requests\"></a>\r\n#### 重定向维护模式请求\r\n\r\n在维护模式下，Laravel 将显示用户尝试访问的所有应用程序 URL 的维护模式视图。 如果你愿意，你可以指示 Laravel 将所有请求重定向到一个特定的 URL。 这可以使用 `redirect` 选项来完成。 例如，您可能希望将所有请求重定向到 `/` URI：\r\n\r\n```shell\r\nphp artisan down --redirect=/\r\n```\r\n\r\n<a name=\"disabling-maintenance-mode\"></a>\r\n#### 禁用维护模式\r\n\r\n要禁用维护模式，请使用 `up` 命令：\r\n\r\n```shell\r\nphp artisan up\r\n```\r\n\r\n> 技巧：您可以通过在 `resources/views/errors/503.blade.php` 中定义自己的模板来自定义默认维护模式模板。\r\n\r\n<a name=\"maintenance-mode-queues\"></a>\r\n#### 维护模式 & 队列\r\n\r\n当您的应用程序处于维护模式时，将不会处理任何 [排队作业](/docs/laravel/9.x/queues)。 一旦应用程序退出维护模式，作业将继续正常处理。\r\n\r\n<a name=\"alternatives-to-maintenance-mode\"></a>\r\n#### 维护模式的替代方案\r\n\r\n由于维护模式要求您的应用程序有几秒钟的停机时间，因此请考虑使用 [Laravel Vapor](https://vapor.laravel.com) 和 [Envoyer](https://envoyer.io) 等替代方案来完成零停机部署 与 Laravel。\r\n\r\n","p":"docs/configuration.html"},{"t":"structure (目录结构)","d":"# 目录结构\r\n\r\n- [介绍](#introduction)\r\n- [根目录](#the-root-directory)\r\n    - [`app` 目录](#the-root-app-directory)\r\n    - [`bootstrap` 目录](#the-bootstrap-directory)\r\n    - [`config` 目录](#the-config-directory)\r\n    - [`database` 目录](#the-database-directory)\r\n    - [`lang` 目录](#the-lang-directory)\r\n    - [`public` 目录](#the-public-directory)\r\n    - [`resources` 目录](#the-resources-directory)\r\n    - [`routes` 目录](#the-routes-directory)\r\n    - [`storage` 目录](#the-storage-directory)\r\n    - [`tests` 目录](#the-tests-directory)\r\n    - [`vendor` 目录](#the-vendor-directory)\r\n- [App 目录](#the-app-directory)\r\n    - [`Broadcasting` 目录](#the-broadcasting-directory)\r\n    - [`Console` 目录](#the-console-directory)\r\n    - [`Events` 目录](#the-events-directory)\r\n    - [`Exceptions` 目录](#the-exceptions-directory)\r\n    - [`Http` 目录](#the-http-directory)\r\n    - [`Jobs` 目录](#the-jobs-directory)\r\n    - [`Listeners` 目录](#the-listeners-directory)\r\n    - [`Mail` 目录](#the-mail-directory)\r\n    - [`Models` 目录](#the-models-directory)\r\n    - [`Notifications` 目录](#the-notifications-directory)\r\n    - [`Policies` 目录](#the-policies-directory)\r\n    - [`Providers` 目录](#the-providers-directory)\r\n    - [`Rules` 目录](#the-rules-directory)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n默认的 Laravel 应用程序结构旨在为大型和小型应用程序提供一个很好的起点。 但是您可以随意组织您的应用程序。 Laravel 几乎不限制任何给定类的位置，只要 Composer 可以自动加载该类。\r\n\r\n<a name=\"the-root-directory\"></a>\r\n## 根目录\r\n\r\n<a name=\"the-root-app-directory\"></a>\r\n#### App 目录\r\n\r\n`app` 目录包含应用程序的核心代码。 我们将很快更详细地探索这个目录； 但是，您应用程序中的几乎所有类都将在此目录中。\r\n\r\n<a name=\"the-bootstrap-directory\"></a>\r\n#### Bootstrap 目录\r\n\r\n`bootstrap` 目录包含启动框架的 `app.php` 文件。 该目录还包含一个「cache」目录，其中包含用于性能优化的框架生成文件，例如路由和服务缓存文件。 您通常不需要修改此目录中的任何文件。\r\n\r\n\r\n\r\n<a name=\"the-config-directory\"></a>\r\n#### Config 目录\r\n\r\n顾名思义，`config`目录包含应用程序的所有配置文件。最好把这些文件都浏览一遍，并熟悉所有可用的选项。\r\n\r\n<a name=\"the-database-directory\"></a>\r\n#### Database 目录\r\n\r\n`database` 目录包含数据库迁移，模型工厂和种子生成器文件。如果你愿意，你还可以把它作为 SQLite 数据库存放目录。\r\n\r\n<a name=\"the-lang-directory\"></a>\r\n#### Lang 目录\r\n\r\n`lang` 目录包含应用程序的所有语言文件。\r\n\r\n<a name=\"the-public-directory\"></a>\r\n#### Public 目录\r\n\r\n`public` 目录包含 `index.php` 文件，该文件是进入你应用程序的所有请求的入口，并配置自动加载。该目录还包含你的资源，如图像、JavaScript 脚本和 CSS 样式。\r\n\r\n<a name=\"the-resources-directory\"></a>\r\n#### Resources 目录\r\n\r\n`resources` 目录包含了 [views](/docs/laravel/9.x/views) 以及未编译的资源文件（如 CSS 或 JavaScript）。此目录还包含所有的语言文件。\r\n\r\n<a name=\"the-routes-directory\"></a>\r\n#### Routes 目录\r\n\r\n`routes` 目录包含应用程序的所有路由定义。默认情况下，Laravel 包含几个路由文件： `web.php`，`api.php`，`console.php` 以及 `channels.php`。\r\n\r\n`web.php` 文件包含 `RouteServiceProvider` 放置在 `web` 中间件组中的路由，该中间件组提供会话状态，CSRF 保护和 cookie 加密，如果你的应用程序不提供无状态的 RESTful API，那么你的所有路由都很可能在 `web.php` 文件。\r\n\r\n\r\n\r\n`api.php` 文件包含 `RouteServiceProvider` 放置在 `api` 中间件组中的路由。 这些路由旨在是无状态的，因此通过这些路由进入应用程序的请求旨在[通过令牌]（/docs/laravel/9.x/sanctum）进行身份验证，并且无法访问会话状态。\r\n\r\n`console.php` 文件是您可以定义所有基于闭包的控制台命令的地方。 每个闭包都绑定到一个命令实例，允许一种简单的方法与每个命令的 IO 方法进行交互。 即使此文件没有定义 HTTP 路由，它也会定义应用程序中基于控制台的入口点（路由）。\r\n\r\n`channels.php` 文件是您可以注册应用程序支持的所有 [事件广播](/docs/laravel/9.x/broadcasting) 频道的地方。\r\n\r\n<a name=\"the-storage-directory\"></a>\r\n#### Storage 目录\r\n\r\n`storage` 目录包含你的日志、编译的 Blade 模板、基于文件的会话、文件缓存和框架生成的其他文件。 该目录分为 `app`、`framework` 和 `logs` 目录。 `app` 目录可用于存储应用程序生成的任何文件。`framework` 目录用于存储框架生成的文件和缓存。 最后，`logs` 目录包含应用程序的日志文件。\r\n\r\n`storage/app/public` 目录可用于存储用户生成的文件，例如个人资料头像，这些文件应该可以公开访问。 你应该在 `public/storage` 创建一个指向这个目录的符号链接。 您可以使用 `php artisan storage:link` Artisan 命令创建链接。\r\n\r\n<a name=\"the-tests-directory\"></a>\r\n#### Tests 目录\r\n\r\n\r\n\r\n`tests` 目录包含您的自动化测试。 开箱即用的示例 [PHPUnit](https://phpunit.de/) 单元测试和功能测试。 每个测试类都应以单词「Test」作为后缀。 您可以使用 `phpunit` 或 `php vendor/bin/phpunit` 命令运行测试。 或者，如果您想要更详细和更漂亮的测试结果表示，您可以使用 `php artisan test` Artisan 命令运行测试。\r\n\r\n<a name=\"the-vendor-directory\"></a>\r\n#### Vendor 目录\r\n\r\n`vendor` 目录包含您的 [Composer](https://getcomposer.org) 依赖项。\r\n\r\n<a name=\"the-app-directory\"></a>\r\n## App 目录\r\n\r\n您的大部分应用程序都位于 `app` 目录中。默认情况下，此目录在 `App` 下命名，并由 Composer 使用 [PSR-4 自动加载标准] (https://www.php-fig.org/psr/psr-4/) 自动加载。\r\n\r\n`app` 目录包含各种附加目录，例如 `Console`、`Http` 和 `Providers`。将 `Console` 和 `Http` 目录视为为应用程序核心提供 API。 HTTP 协议和 CLI 都是与应用程序交互的机制，但实际上并不包含应用程序逻辑。换句话说，它们是向您的应用程序发出命令的两种方式。 `Console` 目录包含您的所有 Artisan 命令，而 `Http` 目录包含您的控制器、中间件和请求。\r\n\r\n当您使用 `make` Artisan 命令生成类时，会在 `app` 目录中生成各种其他目录。因此，例如，在您执行 `make:job` Artisan 命令生成作业类之前，`app/Jobs` 目录将不存在。\r\n\r\n> 技巧：`app` 目录中的许多类可以由 Artisan 通过命令生成。 要查看可用命令，请在终端中运行 `php artisan list make` 命令。\r\n\r\n\r\n\r\n<a name=\"the-broadcasting-directory\"></a>\r\n#### Broadcasting 目录\r\n\r\n`Broadcasting` 目录包含应用程序的所有广播频道类。 这些类是使用 `make:channel` 命令生成的。 此目录默认不存在，但会在您创建第一个频道时为您创建。 要了解有关频道的更多信息，请查看有关 [事件广播](/docs/laravel/9.x/broadcasting) 的文档。\r\n\r\n<a name=\"the-console-directory\"></a>\r\n#### Console 目录\r\n\r\n`Console` 目录包含应用程序的所有自定义 Artisan 命令。 这些命令可以使用 `make:command` 命令生成。 该目录还包含您的控制台内核，这是您注册自定义 Artisan 命令和定义 [计划任务](/docs/laravel/9.x/scheduling) 的地方。\r\n\r\n<a name=\"the-events-directory\"></a>\r\n#### Events 目录\r\n\r\n此目录默认不存在，但会由 `event:generate` 和 `make:event` Artisan 命令为您创建。 `Events` 目录包含 [事件类](/docs/laravel/9.x/events)。 事件可用于提醒应用程序的其他部分发生了给定的操作，从而提供了极大的灵活性和解耦性。\r\n\r\n<a name=\"the-exceptions-directory\"></a>\r\n#### Exceptions 目录\r\n\r\n`Exceptions` 目录包含应用程序的异常处理程序，也是放置应用程序抛出的任何异常的好地方。 如果您想自定义记录或呈现异常的方式，您应该修改此目录中的 `Handler` 类。\r\n\r\n<a name=\"the-http-directory\"></a>\r\n#### Http 目录\r\n\r\n`Http` 目录包含您的控制器、中间件和表单请求。 几乎所有处理进入应用程序的请求的逻辑都将放在这个目录中。\r\n\r\n\r\n\r\n<a name=\"the-jobs-directory\"></a>\r\n#### Jobs 目录\r\n\r\n该目录默认不存在，但如果您执行 `make:job` Artisan 命令，则会为您创建。 `Jobs` 目录包含您的应用程序的 [队列作业](/docs/laravel/9.x/queues)。 作业可能由您的应用程序排队或在当前请求生命周期内同步运行。 在当前请求期间同步运行的作业有时被称为「命令」，因为它们是 [命令模式](https://en.wikipedia.org/wiki/Command_pattern) 的实现。\r\n\r\n<a name=\"the-listeners-directory\"></a>\r\n#### Listeners 目录\r\n\r\n此目录默认不存在，但如果您执行 `event:generate` 或 `make:listener` Artisan 命令，则会为您创建。 `Listeners` 目录包含处理你的 [events](/docs/laravel/9.x/events) 的类。 事件侦听器接收事件实例并执行逻辑以响应被触发的事件。 例如，`UserRegistered` 事件可能由`SendWelcomeEmail`监听器处理。\r\n\r\n<a name=\"the-mail-directory\"></a>\r\n#### Mail 目录\r\n\r\n该目录默认不存在，但如果您执行 `make:mail` Artisan 命令，则会为您创建。 `Mail` 目录包含您的应用程序发送的所有 [代表电子邮件的类](/docs/laravel/9.x/mail)。 Mail 对象允许您将构建电子邮件的所有逻辑封装在一个简单的类中，该类可以使用 `Mail::send` 方法发送。\r\n\r\n<a name=\"the-models-directory\"></a>\r\n#### Models 目录\r\n\r\n`Models` 目录包含所有 [Eloquent 模型类](/docs/laravel/9.x/eloquent)。 Laravel 中包含的 Eloquent ORM 提供了一个漂亮、简单的 ActiveRecord 实现来处理你的数据库。 每个数据库表都有一个相应的「模型」，用于与该表进行交互。 模型允许您查询表中的数据，以及将新记录插入表中。\r\n\r\n\r\n<a name=\"the-notifications-directory\"></a>\r\n#### Notifications 目录\r\n\r\n默认情况下，此目录不存在，但如果你执行 `make:notification` Artisan 命令时会自动生成。 `Notifications` 目录包含所有你发送给应用程序的「事务性」 [消息通知](/docs/laravel/9.x/notifications) 。例如关于应用程序内发生的事件的简单通知。Laravel 的通知功能抽象了通过各种驱动程序发送的通知，如电子邮件通知、Slack 信息、SMS 短信通知或数据库存储。\r\n\r\n<a name=\"the-policies-directory\"></a>\r\n#### Policies 目录\r\n\r\n默认情况下，此目录不存在，但如果您执行 `make:policy` Artisan 命令会生成。 `Policies` 目录包含应用程序的 [ 授权策略类 ](/docs/laravel/9.x/authorization) 。这些类用于确定用户是否可以对资源执行给定的操作。\r\n\r\n<a name=\"the-providers-directory\"></a>\r\n#### Providers 目录\r\n\r\n`Providers` 目录包含程序中所有的 [服务提供者](/docs/laravel/9.x/providers) 。服务提供者通过在服务容器中绑定服务、注册事件或执行任何其他任务来引导应用程序以应对传入请求。\r\n\r\n在一个新的 Laravel 应用程序中，这个目录已经包含了几个提供者。您可以根据需要将自己的提供程序添加到此目录。\r\n\r\n<a name=\"the-rules-directory\"></a>\r\n#### Rules 目录\r\n\r\n默认情况下，此目录不存在，但如果您执行 `make:rule` Artisan 命令后会生成。 `Rules` 目录包含应用程序用户自定义的验证规则。这些验证规则用于将复杂的验证逻辑封装在一个简单的对象中。有关更多信息，请查看 [ 表单验证](/docs/laravel/9.x/validation)。\r\n\r\n","p":"docs/structure.html"},{"t":"starter-kits (入门套件)","d":"# 入门套件\r\n\r\n- [介绍](#introduction)\r\n- [Laravel Breeze](#laravel-breeze)\r\n    - [安装](#laravel-breeze-installation)\r\n    - [Breeze & Inertia](#breeze-and-inertia)\r\n    - [Breeze & Next.js / API](#breeze-and-next)\r\n- [Laravel Jetstream](#laravel-jetstream)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n为了让您开始构建新的 Laravel 应用程序，我们很高兴提供身份验证和应用程序入门工具包。 这些工具包会自动为您的应用程序提供注册和验证应用程序用户所需的路由、控制器和视图。\r\n\r\n虽然欢迎您使用这些入门套件，但它们不是必需的。 只需安装一个新的 Laravel 副本，您就可以自由地从头开始构建自己的应用程序。 无论哪种方式，我们都知道你会创造出伟大的东西！\r\n\r\n<a name=\"laravel-breeze\"></a>\r\n## Laravel Breeze\r\n\r\n[Laravel Breeze](https://github.com/laravel/breeze) 是 Laravel 的所有 [认证功能](/docs/laravel/9.x/authentication) 的最小、简单的实现，包括登录、注册、密码重置、电子邮件验证和密码确认。 Laravel Breeze 的默认视图层由简单的 [Blade 模板](/docs/laravel/9.x/blade) 组成，并使用 [Tailwind CSS](https://tailwindcss.com) 进行样式设置。\r\n\r\nBreeze 为开始一个全新的 Laravel 应用程序提供了一个很好的起点，对于计划使用 [Laravel Livewire](https://laravel-livewire.com) 将其 Blade 模板提升到新水平的项目来说，它也是一个很好的选择。\r\n\r\n<a name=\"laravel-breeze-installation\"></a>\r\n### 安装\r\n\r\n首先，你应该[创建一个新的 Laravel 应用程序](/docs/laravel/9.x/installation)，配置你的数据库，然后运行你的[数据库迁移](/docs/laravel/9.x/migrations)：\r\n\r\n```shell\r\ncurl -s https://laravel.build/example-app | bash\r\n\r\ncd example-app\r\n\r\nphp artisan migrate\r\n```\r\n\r\n一旦你创建了一个新的 Laravel 应用程序，你就可以使用 Composer 安装 Laravel Breeze：\r\n\r\n```shell\r\ncomposer require laravel/breeze --dev\r\n```\r\n\r\n\r\n\r\nComposer 安装好 Laravel Breeze 包后，你可以运行 `breeze:install` Artisan 命令。 此命令将身份验证视图、路由、控制器和其他资源发布到您的应用程序。 Laravel Breeze 将其所有代码发布到您的应用程序，以便您可以完全控制和查看其功能和实现。 安装 Breeze 后，您还应该编译您的资产，以便您的应用程序的 CSS 文件可用：\r\n\r\n```shell\r\nphp artisan breeze:install\r\n\r\nnpm install\r\nnpm run dev\r\nphp artisan migrate\r\n```\r\n\r\n接下来，您可以在 Web 浏览器中导航到应用程序的 `/login` 或 `/register` URL。 Breeze 的所有路由都在 `routes/auth.php` 文件中定义。\r\n\r\n> 技巧：要了解有关编译应用程序的 CSS 和 JavaScript 的更多信息，请查看 [Laravel Mix 文档](/docs/laravel/9.x/mix#running-mix)。\r\n\r\n<a name=\"breeze-and-inertia\"></a>\r\n### Breeze & Inertia\r\n\r\nLaravel Breeze 还提供了一个由 Vue 或 React 提供支持的 [Inertia.js](https://inertiajs.com) 前端实现。 要使用 Inertia 堆栈，请在执行 `breeze:install` Artisan 命令时指定 `vue` 或 `react` 作为所需的堆栈：\r\n\r\n```shell\r\nphp artisan breeze:install vue\r\n\r\n// 或...\r\n\r\nphp artisan breeze:install react\r\n\r\nnpm install\r\nnpm run dev\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"breeze-and-next\"></a>\r\n### Breeze & Next.js / API\r\n\r\nLaravel Breeze 还可以构建一个身份验证 API，该 API 已准备好对现代 JavaScript 应用程序进行身份验证，例如由 [Next](https://nextjs.org)、[Nuxt](https://nuxtjs.org) 等提供支持的应用程序。 首先，在执行 `breeze:install` Artisan 命令时，将 `api` 堆栈指定为所需的堆栈：\r\n\r\n```shell\r\nphp artisan breeze:install api\r\n\r\nphp artisan migrate\r\n```\r\n\r\n\r\n\r\n在安装过程中，Breeze 会在您的应用程序 `.env` 文件中添加一个 `FRONTEND_URL` 环境变量。此 URL 应该是您的 JavaScript 应用程序的 URL。在本地开发期间这通常是 `http://localhost:3000`。此外，您应该确保您 `APP_URL` 的设置为 `http://localhost:8000`，这是 `serve` Artisan 命令使用的默认 URL。\r\n\r\n<a name=\"next-reference-implementation\"></a>\r\n#### Next.js 参考实现\r\n\r\n最后，您已准备好将此后端与您选择的前端配对。 [GitHub 上提供](https://github.com/laravel/breeze-next)了 Breeze 前端的 Next 参考实现。该前端由 Laravel 维护，包含与 Breeze 提供的传统 Blade 和 Inertia 堆栈相同的用户界面。\r\n\r\n<a name=\"laravel-jetstream\"></a>\r\n## Laravel Jetstream\r\n\r\nLaravel Breeze 提供了一个简单的、最小化的起点来构建 Laravel 应用，而 Jetstream 则通过更强大的功能和额外的前端技术堆栈来对应用功能进行增强。 **对于那些刚接触 Laravel 的人，我们建议在学习 Laravel Jetstream 之前先学习 Laravel Breeze。**\r\n\r\nJetstream 为 Laravel 提供了精美设计的应用程序脚手架代码，包括登录、注册、邮箱验证、双因子认证、会话管理、基于 Laravel Sanctum 的 API 支持，以及可选的团队管理功能。Jetstream 使用  [Tailwind CSS](https://tailwindcss.com) 设计样式，并提供 [Livewire](https://laravel-livewire.com) 或 [Inertia.js](https://inertiajs.com) 驱动的前端脚手架技术栈供你选择。\r\n\r\nLaravel Jetstream 的安装使用完整文档位于 [Jetstream 官方文档](https://jetstream.laravel.com/2.x/introduction.html).\r\n\r\n","p":"docs/starter-kits.html"},{"t":"deployment (部署)","d":"# 部署\r\n\r\n- [简介](#introduction)\r\n- [服务器要求](#server-requirements)\r\n- [服务器配置](#server-configuration)\r\n    - [Nginx](#nginx)\r\n- [优化](#optimization)\r\n    - [优化自动加载器](#autoloader-optimization)\r\n    - [优化配置加载](#optimizing-configuration-loading)\r\n    - [优化路由加载](#optimizing-route-loading)\r\n    - [优化视图加载](#optimizing-view-loading)\r\n- [Debug 模式](#debug-mode)\r\n- [使用 Forge / Vapor 部署](#deploying-with-forge-or-vapor)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n当你准备在生产环境部署 Laravel 应用时，请注意以下几点以使你的应用尽可能高效地运行。本文将会提供几个范本以使你的 Laravel 应用部署妥当。\r\n\r\n<a name=\"server-requirements\"></a>\r\n## 服务器要求\r\n\r\nLaravel 框架对系统有一些要求，请确保你的 Web 服务器至少满足以下 PHP 版本及扩展需求。\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- PHP >= 8.0\r\n- BCMath PHP 扩展\r\n- Ctype PHP 扩展\r\n- DOM PHP 扩展\r\n- Fileinfo PHP 扩展\r\n- JSON PHP 扩展\r\n- Mbstring PHP 扩展\r\n- OpenSSL PHP 扩展\r\n- PCRE PHP 扩展\r\n- PDO PHP 扩展\r\n- Tokenizer PHP 扩展\r\n- XML PHP 扩展\r\n\r\n</div>\r\n\r\n<a name=\"server-configuration\"></a>\r\n## 服务器配置\r\n\r\n<a name=\"nginx\"></a>\r\n### Nginx\r\n\r\n当你想要部署应用到 Nginx 服务器上时，你可能会用到下面这个配置文件作为一个范本来配置你的 Web 服务器。这份文件很可能需要根据你的服务器配置进行一些自定义的修改。 **如果你想要一些协助以便更好地管理服务器，可以考虑使用 Laravel 服务器管理及部署第一方服务 [Laravel Forge](https://forge.laravel.com)。**\r\n\r\n\r\n\r\n请确保，就像下面的配置一样，您的 Web 服务器将所有请求定向到项目目录的 `public/index.php` 文件。 不应该将 `index.php` 文件移动到项目的根目录，因为从项目根目录提供应用程序会将许多敏感配置文件暴露到公网：\r\n\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    listen [::]:80;\r\n    server_name example.com;\r\n    root /srv/example.com/public;\r\n\r\n    add_header X-Frame-Options \"SAMEORIGIN\";\r\n    add_header X-Content-Type-Options \"nosniff\";\r\n\r\n    index index.php;\r\n\r\n    charset utf-8;\r\n\r\n    location / {\r\n        try_files $uri $uri/ /index.php?$query_string;\r\n    }\r\n\r\n    location = /favicon.ico { access_log off; log_not_found off; }\r\n    location = /robots.txt  { access_log off; log_not_found off; }\r\n\r\n    error_page 404 /index.php;\r\n\r\n    location ~ \\.php$ {\r\n        fastcgi_pass unix:/var/run/php/php8.0-fpm.sock;\r\n        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;\r\n        include fastcgi_params;\r\n    }\r\n\r\n    location ~ /\\.(?!well-known).* {\r\n        deny all;\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"optimization\"></a>\r\n## 优化\r\n\r\n<a name=\"autoloader-optimization\"></a>\r\n### 优化自动加载\r\n\r\n将项目部署到生产环境时，请确保您正在优化 Composer 的类自动加载器映射，以便 Composer 可以快速找到要为给定类加载的正确文件：\r\n\r\n```shell\r\ncomposer install --optimize-autoloader --no-dev\r\n```\r\n\r\n> 技巧：除了优化自动加载器之外，您应该始终确保在项目的源代码控制存储库中包含一个 `composer.lock` 文件。 当存在 `composer.lock` 文件时，可以更快地安装项目的依赖项。\r\n\r\n<a name=\"optimizing-configuration-loading\"></a>\r\n### 优化配置加载\r\n\r\n将应用程序部署到生产环境时，应确保在部署过程中运行 `config:cache` Artisan 命令 来提前缓存一些 配置 等信息：\r\n\r\n```shell\r\nphp artisan config:cache\r\n```\r\n\r\n\r\n\r\n该命令会将 Laravel 的所有配置文件合并到一个缓存文件中，这大大减少了框架在加载配置值时必须访问文件系统的次数。\r\n\r\n> 注意：如果您在部署过程中执行 `config:cache` 命令，则应确保仅从配置文件中调用 `env` 函数。 一旦配置被缓存，`.env` 文件将不会被加载，所有对 `.env` 变量的 `env` 函数的调用都将返回 `null`。\r\n\r\n<a name=\"optimizing-route-loading\"></a>\r\n### 优化路由加载\r\n\r\n如果您正在构建具有许多路由的大型应用程序，则应确保在部署过程中运行 `route:cache` Artisan 命令：\r\n\r\n```shell\r\nphp artisan route:cache\r\n```\r\n\r\n此命令将所有路由注册减少到缓存文件中的单个方法调用中，从而在注册数百条路由时提高路由注册的性能。\r\n\r\n<a name=\"optimizing-view-loading\"></a>\r\n### 优化视图加载\r\n\r\n将应用程序部署到生产环境时，应确保在部署过程中运行 `view:cache` Artisan 命令：\r\n\r\n```shell\r\nphp artisan view:cache\r\n```\r\n\r\n此命令预编译所有 Blade 视图，因此它们不会按需编译，从而提高返回视图的每个请求的性能。\r\n\r\n<a name=\"debug-mode\"></a>\r\n## 调试模式\r\n\r\n`config/app.php` 配置文件中的调试选项决定了实际向用户显示了多少有关错误的信息。默认情况下，此选项设置为尊重 APP_DEBUG 环境变量的值，该变量存储在您的 `.env` 文件中。\r\n\r\n\r\n\r\n**在您的生产环境中，此值应始终为 `false`。 如果在生产环境中将 `APP_DEBUG` 变量设置为 `true`，则可能会将敏感配置值暴露给应用程序的最终用户。**\r\n\r\n<a name=\"deploying-with-forge-or-vapor\"></a>\r\n## 使用 Forge / Vapor 进行部署\r\n\r\n<a name=\"laravel-forge\"></a>\r\n#### Laravel Forge\r\n\r\n如果您还没有准备好管理自己的服务器配置，或者不习惯配置运行强大的 Laravel 应用程序所需的所有各种服务，[Laravel Forge](https://forge.laravel.com) 是一个很棒的选择。\r\n\r\nLaravel Forge 可以在 DigitalOcean、Linode、AWS 等各种基础设施提供商上创建服务器。此外，Forge 安装和管理构建强大的 Laravel 应用程序所需的所有工具，例如 Nginx、MySQL、Redis、Memcached、Beanstalk 等。\r\n\r\n<a name=\"laravel-vapor\"></a>\r\n#### Laravel Vapor\r\n\r\n如果你想要一个为 Laravel 调整的完全无服务器、自动扩展的部署平台，请查看 [Laravel Vapor](https://vapor.laravel.com)。 Laravel Vapor 是 Laravel 的无服务器部署平台，由 AWS 提供支持。在 Vapor 上启动您的 Laravel 基础架构，并爱上无服务器的可扩展简单性。Laravel Vapor 由 Laravel 的创建者进行了微调，可以与框架无缝协作，这样你就可以像以前一样继续编写 Laravel 应用程序。\r\n\r\n","p":"docs/deployment.html"},{"t":"lifecycle (请求生命周期)","d":"# 请求生命周期\r\n\r\n- [介绍](#介绍)\r\n- [生命周期概述](#生命周期概述)\r\n    - [第一步](#第一步)\r\n    - [HTTP / Console 内核](#http-console-kernels)\r\n    - [服务提供者](#服务提供者)\r\n    - [路由](#路由)\r\n    - [请求结束](#请求结束)\r\n- [关注服务提供者](#关注服务提供者)\r\n\r\n<a name=\"介绍\"></a>\r\n## 介绍\r\n\r\n在「真实世界」中使用任何工具时，如果你了解该工具的工作原理，你会更加自信。应用程序开发也不例外。当您了解开发工具的功能时，你会觉得使用它们更舒服、更自信。\r\n\r\n本文的目的是让您对 Laravel 框架的工作原理有一个良好的、高层次的理解。通过更好地了解整个框架，一切感觉都不那么「神奇」，你将更有信心构建你的应用程序。如果你不明白所有的规则，不要灰心！只要试着对正在发生的事情有一个基本的掌握，你的知识就会随着你探索文档的其他部分而增长。\r\n\r\n<a name=\"生命周期概述\"></a>\r\n## 生命周期概述\r\n\r\n<a name=\"第一步\"></a>\r\n### 第一步\r\n\r\nLaravel 应用程序的所有请求的入口点都是 `public/index.php` 文件。所有请求都由你的 `web` 服务器（Apache/Nginx）配置定向到此文件。那个 `index.php` 文件不包含太多代码。相反，它是加载框架其余部分的起点。\r\n\r\n该 `index.php` 文件将加载 `Composer` 生成的自动加载器定义，然后从 `bootstrap/app.php` 中检索 `Laravel `应用程序的实例。`Laravel` 本身采取的第一个操作是创建应用 / [服务容器](/docs/laravel/9.x/container) 的实例。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<a name=\"http-console-kernels\"></a>\r\n### HTTP / Console 内核\r\n\r\n接下来，根据进入应用的请求类型，传入的请求将被发送到 `HTTP` 内核或者 `Console` 内核。这两个内核充当所有请求流经的中心位置。现在，我们只关注位于 `app/Http/Kernel.php` 中的 `HTTP` 内核。\r\n\r\n`HTTP` 内核继承了 `Illuminate\\Foundation\\Http\\Kernel` 类，该类定义了一个将在执行请求之前运行的 `bootstrappers` 数组。这个数组用来在实际处理请求之前完成：配置异常处理、配置日志、[检测应用程序环境](/docs/laravel/9.x/configuration#environment-configuration)，以及其它需要完成的任务。\r\n\r\nHTTP 内核还定义了一个 HTTP [中间件](/docs/laravel/9.x/middleware) 列表，所有请求在被应用程序处理之前都必须通过该列表。这些中间件处理读写 [HTTP 会话](/docs/laravel/9.x/session)，确定应用程序是否处于维护模式，[校验 CSRF 令牌](/docs/laravel/9.x/csrf) 等等。我们接下来会做详细的讨论。\r\n\r\nHTTP 内核的 `handle` 方法的签名非常简单：它接收 `Request` 接口并返回 `Response` 接口。把内核想象成一个代表整个应用程序的大黑匣子。向它提供 HTTP 请求，它将返回 HTTP 响应。\r\n\r\n<a name=\"service-providers\"></a>\r\n### 服务提供者\r\n\r\n最重要的内核引导操作之一是为应用程序加载 [服务提供者](/docs/laravel/9.x/providers) 。应用程序的所有服务提供程序都在 `config/app.php` 文件中的 `providers` 数组。\r\n\r\n\r\n\r\nLaravel 将遍历这个提供者列表并实例化它们中的每一个。实例化提供程序后，将在所有提供程序上调用 register 方法。然后，一旦所有的提供者都被注册了，就会对每个提供程序调用 `boot` 方法。服务提供者可能依赖于在执行 `boot` 方法时注册并可用的每个容器绑定。\r\n\r\n服务提供者负责引导框架的所有不同组件，如数据库、队列、验证和路由组件。基本上，Laravel 提供的每个主要功能都是由服务提供商引导和配置的。由于它们引导和配置框架提供的许多特性，服务提供者是整个 Laravel 引导过程中最重要的部分。\r\n\r\n<a name=\"路由\"></a>\r\n### 路由\r\n\r\n应用程序中最重要的服务提供者之一是 `App\\Providers\\RouteServiceProvider`。此服务提供者加载应用程序的 `routes` 目录中包含的路由文件。继续，打开`RouteServiceProvider` 代码，看看它是如何工作的！\r\n\r\n一旦应用程序被引导并且所有服务提供者都被注册，「请求」将被传递给路由器进行调度。路由器将请求发送到路由或控制器，并运行任何路由特定的中间件。\r\n\r\n中间件为过滤或检查进入应用程序的 HTTP 请求提供了一种方便的机制。例如，Laravel 包含一个这样的中间件，用于验证应用程序的用户是否经过身份验证。如果用户未通过身份验证，中间件将用户重定向到登录页。但是，如果用户经过身份验证，中间件将允许请求进一步进入应用程序。一些中间件被分配给应用程序中的所有路由，比如那些在 HTTP 内核的 `$middleware` 属性中定义的路由，而一些只被分配给特定的路由或路由组。您可以通过阅读完整的 [中间件文档](/docs/laravel/9.x/middleware) 来了解关于中间件的信息。\r\n\r\n如果请求通过了所有匹配路由分配的中间件，则执行路由或控制器方法，并通过路由的中间件链路返回路由或控制器方法的响应。\r\n\r\n<a name=\"finishing-up\"></a>\r\n### 最后\r\n\r\n一旦路由或控制器方法返回一个响应，该响应将通过路由的中间件返回，从而使应用程序有机会修改或检查传出的响应。\r\n最后，一旦响应通过中间件返回，HTTP 内核的 `handle` 方法将返回响应对象，并且 `index.php` 文件在返回的响应上调用 `send` 方法。 `send` 方法将响应内容发送到用户的 web 浏览器。至此，我们已经完成了整个 Laravel 请求生命周期的旅程！\r\n\r\n<a name=\"关注服务提供者\"></a>\r\n## 关注服务提供者\r\n\r\n服务提供者确实是引导 Laravel 应用程序的关键。创建应用程序实例，注册服务提供者，并将请求传递给引导应用程序。就这么简单！\r\n牢牢掌握服务提供者的构建和其对 Laravel 应用处理机制的原理是非常有价值的。你的应用的默认服务提供会存放在 `app/Providers` 目录下面。\r\n\r\n默认情况下，`AppServiceProvider` 是空白的。这里是用于你添加应用自身的引导处理和服务容器绑定的一个非常棒的地方。在大型项目中，您可能希望创建多个服务提供者，每个服务提供者都为应用程序使用的特定服务提供更细粒度的引导。\r\n","p":"docs/lifecycle.html"},{"t":"container (服务容器)","d":"# 服务容器\r\n\r\n- [介绍](#introduction)\r\n    - [零配置解决方案](#zero-configuration-resolution)\r\n    - [何时使用容器](#when-to-use-the-container)\r\n- [绑定](#binding)\r\n    - [绑定基础](#binding-basics)\r\n    - [接口到实现的绑定](#binding-interfaces-to-implementations)\r\n    - [上下文绑定](#contextual-binding)\r\n    - [绑定原语](#binding-primitives)\r\n    - [绑定变长参数类型](#binding-typed-variadics)\r\n    - [标签](#tagging)\r\n    - [继承绑定](#extending-bindings)\r\n- [解析](#resolving)\r\n    - [make 方法](#the-make-method)\r\n    - [自动注入](#automatic-injection)\r\n- [方法调用 & 注入](#method-invocation-and-injection)\r\n- [容器事件](#container-events)\r\n- [PSR-11](#psr-11)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 服务容器是一个用于管理类依赖以及实现依赖注入的强有力工具。依赖注入这个名词表面看起来花哨，实质上是指：通过构造函数，或者某些情况下通过「setter」方法将类依赖「注入」到类中。\r\n我们来看一个简单的例子：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Repositories\\UserRepository;\r\n    use App\\Models\\User;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * user 仓库的实现\r\n         *\r\n         * @var UserRepository\r\n         */\r\n        protected $users;\r\n\r\n        /**\r\n         * 创建一个新的控制器实例\r\n         *\r\n         * @param  UserRepository  $users\r\n         * @return void\r\n         */\r\n        public function __construct(UserRepository $users)\r\n        {\r\n            $this->users = $users;\r\n        }\r\n\r\n        /**\r\n         * 展示给定用户的信息\r\n         *\r\n         * @param  int  $id\r\n         * @return Response\r\n         */\r\n        public function show($id)\r\n        {\r\n            $user = $this->users->find($id);\r\n\r\n            return view('user.profile', ['user' => $user]);\r\n        }\r\n    }\r\n\r\n在此示例中，`UserController` 控制器需要从数据源中获取 `users`。 因此，我们可以注入一个能够获取 users 的服务。 在这种情况下，我们的存储仓库 `UserRepository` 极有可能使用 [Eloquent](/docs/laravel/9.x/eloquent) 从数据库中检索用户信息。 然而，由于仓库是通过 UserRepository 注入的，我们可以轻易的将其切换为另一个实现。 另外，这种方式的便利之处也体现在：当需要为应用编写测试的时候，我们也可以很轻松地 “模拟” 或者创建一个 UserRepository 存储层的伪实现来操作。\r\n\r\n\r\n深入理解服务容器，对于构建一个强大的、大型的应用，以及对 Laravel 核心本身的贡献都是至关重要的。\r\n\r\n<a name=\"zero-configuration-resolution\"></a>\r\n### 零配置解决方案\r\n\r\n如果一个类没有依赖项或只依赖于其他具体类（而不是接口），则不需要指定容器如何解析该类。例如，您可以将以下代码放在 `routes/web.php` 文件中：\r\n\r\n    <?php\r\n\r\n    class Service\r\n    {\r\n        //\r\n    }\r\n\r\n    Route::get('/', function (Service $service) {\r\n        die(get_class($service));\r\n    });\r\n\r\n在这个例子中，点击应用程序的 `/` 路由将自动解析 `Service` 类并将其注入到路由的处理程序中。 这是一个有趣的改变。 这意味着您可以开发应用程序并利用依赖注入，而不必担心臃肿的配置文件。\r\n\r\n很荣幸的通知您,在构建 Laravel 应用程序时，您将要编写的许多类都可以通过容器自动接收它们的依赖关系，包括 [控制器](/docs/laravel/9.x/controllers)、[事件监听器](/docs/laravel/9.x/events)、 [中间件](/docs/laravel/9.x/middleware) 等等。 此外，您可以在 [队列系统](/docs/laravel/9.x/queues) 的 `handle` 方法中键入提示依赖项。 一旦你尝到了自动和零配置依赖注入的力量，你就会觉得没有它是不可以开发的。\r\n\r\n<a name=\"when-to-use-the-container\"></a>\r\n### 何时使用容器\r\n\r\n得益于零配置解决方案，通常情况下，你只需要在路由、控制器、事件侦听器和其他地方键入提示依赖项，而不必手动与容器打交道。例如，可以在路由定义中键入 `Illuminate\\Http\\Request` 对象，以便轻松访问当前请求的 Request 类。尽管我们不必与容器交互来编写此代码，但它在幕后管理着这些依赖项的注入：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/', function (Request $request) {\r\n        // ...\r\n    });\r\n\r\n\r\n\r\n在许多情况下，由于自动依赖注入和 [facades](/docs/laravel/9.x/facades)，你在构建 Laravel 应用程序的时候无需手动绑定或解析容器中的任何内容。那么，你将在什么时候手动与容器打交道呢？让我们来看看下面两种情况。\r\n\r\n首先，如果您编写了一个实现接口的类，并希望在路由或类的构造函数上键入该接口的提示，则必须 [告诉容器如何解析该接口](#binding-interfaces-to-implementations)。第二，如果您正在 [编写一个 Laravel包](/docs/laravel/9.x/packages) 计划与其他 Laravel 开发人员共享，那么您可能需要将包的服务绑定到容器中。\r\n\r\n<a name=\"binding\"></a>\r\n## 绑定\r\n\r\n<a name=\"binding-basics\"></a>\r\n### 基础绑定\r\n\r\n<a name=\"simple-bindings\"></a>\r\n#### 简单绑定\r\n\r\n几乎所有的服务容器绑定都会在 [服务提供者](/docs/laravel/9.x/providers) 中注册，下面示例中的大多数将演示如何在该上下文（服务提供者）中使用容器。\r\n\r\n在服务提供者中，你总是可以通过 `$this->app` 属性访问容器。我们可以通过容器的 `bind` 方法注册绑定，`bind` 方法的第一个参数为要绑定的类或接口名，第二个参数是一个返回类实例的闭包：\r\n\r\n    use App\\Services\\Transistor;\r\n    use App\\Services\\PodcastParser;\r\n\r\n    $this->app->bind(Transistor::class, function ($app) {\r\n        return new Transistor($app->make(PodcastParser::class));\r\n    });\r\n\r\n注意，我们接受容器本身作为解析器的参数。然后，我们可以使用容器来解析正在构建的对象的子依赖。\r\n\r\n如前所述，您通常会与服务提供商内部的容器进行交互；但是，如果您希望与服务提供商外部的容器进行交互，则可以通过 `App` [facade](/docs/laravel/9.x/facades) 进行:\r\n\r\n    use App\\Services\\Transistor;\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    App::bind(Transistor::class, function ($app) {\r\n        // ...\r\n    });\r\n\r\n> 技巧：如果类不依赖于任何接口，则不需要将它们绑定到容器中。不需要指示容器如何构建这些对象，因为它可以使用反射自动解析这些对象。\r\n\r\n\r\n\r\n<a name=\"binding-a-singleton\"></a>\r\n#### 单例的绑定\r\n\r\n`singleton` 方法将类或接口绑定到只应解析一次的容器中。解析单例绑定后，后续调用容器时将返回相同的对象实例：\r\n\r\n    use App\\Services\\Transistor;\r\n    use App\\Services\\PodcastParser;\r\n\r\n    $this->app->singleton(Transistor::class, function ($app) {\r\n        return new Transistor($app->make(PodcastParser::class));\r\n    });\r\n\r\n<a name=\"binding-scoped\"></a>\r\n#### 绑定作用域单例\r\n\r\n该 `scoped` 方法将一个类或接口绑定到容器中，该容器只应在给定的 Laravel 请求/作业生命周期内解析一次。虽然该方法与 `singleton` 方法类似，但是当 Laravel 应用程序开始一个新的 “生命周期” 时， 使用 `scoped` 方法注册的实例 将被刷新，例如当 [Laravel Octane](/docs/laravel/9.x/octane) 工作者处理新请求或 Laravel [队列工作者](/docs/laravel/9.x/queues) 处理新作业时：\r\n\r\n    use App\\Services\\Transistor;\r\n    use App\\Services\\PodcastParser;\r\n\r\n    $this->app->scoped(Transistor::class, function ($app) {\r\n        return new Transistor($app->make(PodcastParser::class));\r\n    });\r\n\r\n<a name=\"binding-instances\"></a>\r\n#### 绑定实例\r\n\r\n还可以使用 `instance` 方法将现有对象实例绑定到容器中。给定实例将始终在后续调用容器时返回：\r\n\r\n    use App\\Services\\Transistor;\r\n    use App\\Services\\PodcastParser;\r\n\r\n    $service = new Transistor(new PodcastParser);\r\n\r\n    $this->app->instance(Transistor::class, $service);\r\n\r\n<a name=\"binding-interfaces-to-implementations\"></a>\r\n### 绑定接口至实现\r\n\r\n服务容器的一个非常强大的特性是它能够将接口绑定到给定的实现。例如，假设我们有一个  `EventPusher` 接口和一个 `RedisEventPusher` 实现。一旦我们对这个接口的 `RedisEventPusher` 实现进行了编码，我们就可以像这样在服务容器中注册它：\r\n\r\n    use App\\Contracts\\EventPusher;\r\n    use App\\Services\\RedisEventPusher;\r\n\r\n    $this->app->bind(EventPusher::class, RedisEventPusher::class);\r\n\r\n\r\n\r\n此语句告诉容器，当类需要 `EventPusher` 的实现时，它应该注入 `RedisEventPusher`。现在我们可以在容器解析的类的构造函数中加上 `EventPusher` 接口作为类型提示。请记住，控制器、事件侦听器、中间件和 Laravel 应用程序中的各种其他的类始终使用容器进行解析：\r\n\r\n    use App\\Contracts\\EventPusher;\r\n\r\n    /**\r\n     * 创建一个新的实例\r\n     *\r\n     * @param  \\App\\Contracts\\EventPusher  $pusher\r\n     * @return void\r\n     */\r\n    public function __construct(EventPusher $pusher)\r\n    {\r\n        $this->pusher = $pusher;\r\n    }\r\n\r\n<a name=\"contextual-binding\"></a>\r\n### 上下文绑定\r\n\r\n> 译者注：所谓「上下文绑定」就是根据上下文进行动态的绑定，指依赖的上下文关系。\r\n\r\n有时你可能有两个类使用相同的接口，但是你希望将不同的实现分别注入到各自的类中。例如，两个控制器可能依赖于 `Illuminate\\Contracts\\Filesystem\\Filesystem` [契约](/docs/laravel/9.x/contracts) 的不同实现。Laravel 提供了一个简单流畅的方式来定义这种行为：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n    use App\\Http\\Controllers\\UploadController;\r\n    use App\\Http\\Controllers\\VideoController;\r\n    use Illuminate\\Contracts\\Filesystem\\Filesystem;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $this->app->when(PhotoController::class)\r\n              ->needs(Filesystem::class)\r\n              ->give(function () {\r\n                  return Storage::disk('local');\r\n              });\r\n\r\n    $this->app->when([VideoController::class, UploadController::class])\r\n              ->needs(Filesystem::class)\r\n              ->give(function () {\r\n                  return Storage::disk('s3');\r\n              });\r\n\r\n<a name=\"binding-primitives\"></a>\r\n### 绑定原语\r\n\r\n有时您可能有一个类接收一些注入的类，但也需要一个注入的原语值，如整数。您可以轻松地使用上下文绑定来注入类可能需要的任何值：\r\n\r\n    $this->app->when('App\\Http\\Controllers\\UserController')\r\n              ->needs('$variableName')\r\n              ->give($value);\r\n\r\n\r\n\r\n有时一个类可能依赖于一组 [标记的](#tagging) 实例。使用 `giveTagged` 方法，您可以轻松地使用该标记注入所有容器绑定：\r\n\r\n    $this->app->when(ReportAggregator::class)\r\n        ->needs('$reports')\r\n        ->giveTagged('reports');\r\n\r\n如果您需要从应用程序的某个配置文件中注入一个值，您可以使用 `giveConfig` 方法：\r\n\r\n    $this->app->when(ReportAggregator::class)\r\n        ->needs('$timezone')\r\n        ->giveConfig('app.timezone');\r\n\r\n<a name=\"binding-typed-variadics\"></a>\r\n### 绑定变长参数类型\r\n\r\n有时，您可能有一个使用可变构造函数参数接收类型对象数组的类：\r\n\r\n    <?php\r\n\r\n    use App\\Models\\Filter;\r\n    use App\\Services\\Logger;\r\n\r\n    class Firewall\r\n    {\r\n        /**\r\n         *  日志实例\r\n         *\r\n         * @var \\App\\Services\\Logger\r\n         */\r\n        protected $logger;\r\n\r\n        /**\r\n         * 过滤器实例组\r\n         *\r\n         * @var array\r\n         */\r\n        protected $filters;\r\n\r\n        /**\r\n         * 创建一个类实例\r\n         *\r\n         * @param  \\App\\Services\\Logger  $logger\r\n         * @param  array  $filters\r\n         * @return void\r\n         */\r\n        public function __construct(Logger $logger, Filter ...$filters)\r\n        {\r\n            $this->logger = $logger;\r\n            $this->filters = $filters;\r\n        }\r\n    }\r\n\r\n使用上下文绑定，您可以通过为 `give` 方法提供一个闭包来解析此依赖关系，该闭包返回一个已解析的 `Filter` 实例数组：\r\n\r\n    $this->app->when(Firewall::class)\r\n              ->needs(Filter::class)\r\n              ->give(function ($app) {\r\n                    return [\r\n                        $app->make(NullFilter::class),\r\n                        $app->make(ProfanityFilter::class),\r\n                        $app->make(TooLongFilter::class),\r\n                    ];\r\n              });\r\n\r\n为方便起见，您也可以只提供一个类名数组，以便在 `Firewall` 需要 `Filter` 实例时由容器解析：\r\n\r\n    $this->app->when(Firewall::class)\r\n              ->needs(Filter::class)\r\n              ->give([\r\n                  NullFilter::class,\r\n                  ProfanityFilter::class,\r\n                  TooLongFilter::class,\r\n              ]);\r\n\r\n<a name=\"variadic-tag-dependencies\"></a>\r\n#### 变长参数的关联标签\r\n\r\n有时，一个类可能具有类型提示为给定类的可变依赖项（`Report ...$reports`）。使用 `needs` 和 `giveTagged` 方法，您可以轻松地为给定依赖项注入所有带有该 [标签](#tagging) 的所有容器绑定：\r\n\r\n    $this->app->when(ReportAggregator::class)\r\n        ->needs(Report::class)\r\n        ->giveTagged('reports');\r\n\r\n\r\n\r\n<a name=\"tagging\"></a>\r\n### 标签\r\n\r\n有时，您可能需要解决所有特定“类别”的绑定。例如，也许您正在构建一个报告分析器，它接收许多不同的 `Report` 接口实现的数组。注册 `Report` 实现后，您可以使用 `tag` 方法为它们分配标签：\r\n\r\n    $this->app->bind(CpuReport::class, function () {\r\n        //\r\n    });\r\n\r\n    $this->app->bind(MemoryReport::class, function () {\r\n        //\r\n    });\r\n\r\n    $this->app->tag([CpuReport::class, MemoryReport::class], 'reports');\r\n\r\n一旦服务被打上标签，你就可以通过容器的 `tagged` 方法轻松地解析它们：\r\n\r\n    $this->app->bind(ReportAnalyzer::class, function ($app) {\r\n        return new ReportAnalyzer($app->tagged('reports'));\r\n    });\r\n\r\n<a name=\"extending-bindings\"></a>\r\n### 继承绑定\r\n\r\n`extend` 方法允许修改已解析的服务。例如，解析服务时，可以运行其他代码来修饰或配置服务。 `extend` 方法接受闭包，该闭包应返回修改后的服务作为其唯一参数。闭包接收正在解析的服务和容器实例：\r\n\r\n    $this->app->extend(Service::class, function ($service, $app) {\r\n        return new DecoratedService($service);\r\n    });\r\n\r\n<a name=\"resolving\"></a>\r\n## 解析\r\n\r\n<a name=\"the-make-method\"></a>\r\n### `make` 方法\r\n\r\n您可以使用 `make` 方法从容器中解析类实例。`make` 方法接受您希望解析的类或接口的名称：\r\n\r\n    use App\\Services\\Transistor;\r\n\r\n    $transistor = $this->app->make(Transistor::class);\r\n\r\n如果您的某些类的依赖项无法通过容器解析，您可以通过将它们作为关联数组传递给 `makeWith` 方法来注入它们。例如，我们可以手动传递 `Transistor` 服务所需的`$id` 构造函数参数：\r\n\r\n    use App\\Services\\Transistor;\r\n\r\n    $transistor = $this->app->makeWith(Transistor::class, ['id' => 1]);\r\n\r\n如果你在服务提供商之外的代码位置无法访问 `$app` 变量，则可以使用 `App` [facade](/docs/laravel/9.x/facades) 从容器解析类实例：\r\n\r\n    use App\\Services\\Transistor;\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $transistor = App::make(Transistor::class);\r\n\r\n如果希望将 Laravel 容器实例本身注入到由容器解析的类中，可以在你的类的构造函数中添加 `Illuminate\\container\\container`：\r\n\r\n    use Illuminate\\Container\\Container;\r\n\r\n    /**\r\n     * 实例化一个类\r\n     *\r\n     * @param  \\Illuminate\\Container\\Container  $container\r\n     * @return void\r\n     */\r\n    public function __construct(Container $container)\r\n    {\r\n        $this->container = $container;\r\n    }\r\n\r\n<a name=\"自动注入\"></a>\r\n### 自动注入\r\n\r\n另外，并且更重要的是，你可以简单地使用「类型提示」的方式在类的构造函数中注入那些需要容器解析的依赖项，包括 [控制器](/docs/laravel/9.x/controllers)，[事件监听](/docs/laravel/9.x/events)，[中间件](/docs/laravel/9.x/middleware) 等 。此外，你也可以在 [队列任务](/docs/laravel/9.x/queues) 的 `handle` 方法中使用「类型提示」注入依赖。实际上，这才是大多数对象应该被容器解析的方式。\r\n\r\n例如，你可以在控制器的构造函数中添加一个 repository 的类型提示，然后这个 repository 将会被自动解析并注入类中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Repositories\\UserRepository;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * user 仓库实例\r\n         *\r\n         * @var \\App\\Repositories\\UserRepository\r\n         */\r\n        protected $users;\r\n\r\n        /**\r\n         * 创建一个控制器实例\r\n         *\r\n         * @param  \\App\\Repositories\\UserRepository  $users\r\n         * @return void\r\n         */\r\n        public function __construct(UserRepository $users)\r\n        {\r\n            $this->users = $users;\r\n        }\r\n\r\n        /**\r\n         * 使用给定的 ID 显示 user\r\n         *\r\n         * @param  int  $id\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function show($id)\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"method-invocation-and-injection\"></a>\r\n## 方法调用和注入\r\n\r\n有时您可能希望调用对象实例上的方法，同时允许容器自动注入该方法的依赖项。例如，给定以下类：\r\n\r\n    <?php\r\n\r\n    namespace App;\r\n\r\n    use App\\Repositories\\UserRepository;\r\n\r\n    class UserReport\r\n    {\r\n        /**\r\n         * 生成新的用户报告\r\n         *\r\n         * @param  \\App\\Repositories\\UserRepository  $repository\r\n         * @return array\r\n         */\r\n        public function generate(UserRepository $repository)\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n您可以通过容器调用 `generate` 方法，如下所示：\r\n\r\n    use App\\UserReport;\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $report = App::call([new UserReport, 'generate']);\r\n\r\n`call` 方法接受任何可调用的 PHP 方法。容器的 `call` 方法甚至可以用于调用闭包，同时自动注入其依赖项：\r\n\r\n    use App\\Repositories\\UserRepository;\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $result = App::call(function (UserRepository $repository) {\r\n        // ...\r\n    });\r\n\r\n<a name=\"container-events\"></a>\r\n## 容器事件\r\n\r\n服务容器每次解析对象时都会触发一个事件。您可以使用 `resolving` 方法监听此事件：\r\n\r\n    use App\\Services\\Transistor;\r\n\r\n    $this->app->resolving(Transistor::class, function ($transistor, $app) {\r\n        // 当容器解析 \"Transistor\" 类型的对象时调用...\r\n    });\r\n\r\n    $this->app->resolving(function ($object, $app) {\r\n        // 当容器解析任何类型的对象时调用...\r\n    });\r\n\r\n如您所见，正在解析的对象将被传递给回调，从而允许您在对象提供给其使用者之前设置对象的任何其他属性。\r\n\r\n<a name=\"psr-11\"></a>\r\n## PSR-11\r\n\r\nLaravel 的服务容器实现了 [PSR-11](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.md) 接口。因此，您可以添加 PSR-11 容器接口的类型提示来获取 Laravel 容器的实例：\r\n\r\n    use App\\Services\\Transistor;\r\n    use Psr\\Container\\ContainerInterface;\r\n\r\n    Route::get('/', function (ContainerInterface $container) {\r\n        $service = $container->get(Transistor::class);\r\n\r\n        //\r\n    });\r\n\r\n如果无法解析给定的标识符，将引发异常。如果标识符从未绑定，则异常将是`Psr\\Container\\NotFoundExceptionInterface` 的实例。如果标识符已绑定但无法解析，则将抛出`Psr\\Container\\ContainerExceptionInterface` 的实例。\r\n\r\n","p":"docs/container.html"},{"t":"providers (服务提供者)","d":"# 服务提供者\r\n\r\n- [简介](#简介)\r\n- [编写服务提供者](#编写服务提供者)\r\n    - [注册方法](#注册方法)\r\n    - [引导方法](#引导方法)\r\n- [注册提供者](#注册提供者)\r\n- [延迟加载提供者](#延迟加载提供者)\r\n\r\n<a name=\"简介\"></a>\r\n## 简介\r\n\r\n服务提供者是所有 Laravel 应用程序的引导中心。你的应用程序，以及通过服务器引导的 Laravel 核心服务都是通过服务提供器引导。\r\n\r\n但是，「引导」是什么意思呢？通常，我们可以理解为 **注册**，比如注册服务容器绑定，事件监听器，中间件，甚至是路由。服务提供者是配置应用程序的中心。\r\n\r\n当你打开 Laravel 的 `config/app.php` 文件时，你会看到 `providers` 数组。数组中的内容是应用程序要加载的所有服务提供者的类。当然，其中有很多「延迟」提供者，他们并不会在每次请求的时候都加载，只有他们的服务实际被需要时才会加载。\r\n\r\n本篇你将会学到如何编写自己的服务提供者，并将其注册到你的 Laravel 应用程序中。\r\n\r\n> 技巧 如果您想了解有关 Laravel 如何处理请求并在内部工作的更多信息，请查看有关 Laravel 的文档 [请求生命周期](/docs/laravel/9.x/lifecycle)。\r\n\r\n<a name=\"编写服务提供者\"></a>\r\n## 编写服务提供者\r\n\r\n所有的服务提供者都会继承 `Illuminate\\Support\\ServiceProvider` 类。大多服务提供者都包含一个 `register` 和一个 `boot` 方法。在 `register` 方法中，你只需要将服务绑定到 [服务容器](/docs/laravel/9.x/container)。而不要尝试在 `register` 方法中注册任何监听器，路由，或者其他任何功能。\r\n\r\n\r\n\r\n使用 Artisan 命令行工具，通过 `make:provider` 命令可以生成一个新的提供者：\r\n\r\n```shell\r\nphp artisan make:provider RiakServiceProvider\r\n```\r\n\r\n<a name=\"注册方法\"></a>\r\n### 注册方法\r\n\r\n如上所述，在 `register` 方法中，你只需要将服务绑定到 [服务容器](/docs/laravel/9.x/container) 中。而不要尝试在 `register` 方法中注册任何监听器，路由，或者其他任何功能。否则，你可能会意外地使用到尚未加载的服务提供者提供的服务。\r\n\r\n让我们来看一个基础的服务提供者。在任何服务提供者方法中，你总是通过 `$app` 属性来访问服务容器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Services\\Riak\\Connection;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class RiakServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册应用服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            $this->app->singleton(Connection::class, function ($app) {\r\n                return new Connection(config('riak'));\r\n            });\r\n        }\r\n    }\r\n\r\n这个服务提供者只是定义了一个 `register` 方法，并且使用这个方法在服务容器中定义了一个 `Riak\\Connection` 接口。如果你不理解服务容器的工作原理，请查看其 [文档](/docs/laravel/9.x/container)。\r\n\r\n<a name=\"bindings 和 singletons 的特性\"></a>\r\n#### bindings 和 singletons 的特性\r\n\r\n如果你的服务提供器注册了许多简单的绑定，你可能想用 `bindings` 和 `singletons` 属性替代手动注册每个容器绑定。当服务提供器被框架加载时，将自动检查这些属性并注册相应的绑定：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Contracts\\DowntimeNotifier;\r\n    use App\\Contracts\\ServerProvider;\r\n    use App\\Services\\DigitalOceanServerProvider;\r\n    use App\\Services\\PingdomDowntimeNotifier;\r\n    use App\\Services\\ServerToolsProvider;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 所有需要注册的容器绑定\r\n         *\r\n         * @var array\r\n         */\r\n        public $bindings = [\r\n            ServerProvider::class => DigitalOceanServerProvider::class,\r\n        ];\r\n\r\n        /**\r\n         * 所有需要注册的容器单例\r\n         *\r\n         * @var array\r\n         */\r\n        public $singletons = [\r\n            DowntimeNotifier::class => PingdomDowntimeNotifier::class,\r\n            ServerProvider::class => ServerToolsProvider::class,\r\n        ];\r\n    }\r\n\r\n\r\n\r\n<a name=\"引导方法\"></a>\r\n### 引导方法\r\n\r\n如果我们要在服务提供者中注册一个 [视图合成器](/docs/laravel/9.x/views#view-composers) 该怎么做？这就需要用到 `boot` 方法了。**该方法在所有服务提供者被注册以后才会被调用**，这就是说我们可以在其中访问框架已注册的所有其它服务：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class ComposerServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 启动所有的应用服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            View::composer('view', function () {\r\n                //\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"启动方法的依赖注入\"></a>\r\n#### 启动方法的依赖注入\r\n\r\n你可以为服务提供者的 `boot` 方法设置类型提示。[服务容器](/docs/laravel/9.x/container) 会自动注入你所需要的依赖：\r\n\r\n    use Illuminate\\Contracts\\Routing\\ResponseFactory;\r\n\r\n    /**\r\n     * 引导所有的应用服务\r\n     *\r\n     * @param  \\Illuminate\\Contracts\\Routing\\ResponseFactory  $response\r\n     * @return void\r\n     */\r\n    public function boot(ResponseFactory $response)\r\n    {\r\n        $response->macro('serialized', function ($value) {\r\n            //\r\n        });\r\n    }\r\n\r\n<a name=\"注册服务提供者\"></a>\r\n## 注册服务提供者\r\n\r\n所有服务提供者都是通过配置文件 `config/app.php` 进行注册。该文件包含了一个列出所有服务提供者名字的 `providers` 数组，默认情况下，其中列出了所有核心服务提供者，这些服务提供者启动 Laravel 核心组件，比如邮件、队列、缓存等等。\r\n\r\n要注册提供器，只需要将其添加到数组：\r\n\r\n    'providers' => [\r\n        // 其他服务提供者\r\n\r\n        App\\Providers\\ComposerServiceProvider::class,\r\n    ],\r\n\r\n<a name=\"延迟加载提供者\"></a>\r\n## 延迟加载提供者\r\n\r\n如果你的服务提供者 **只** 在 [服务容器](/docs/laravel/9.x/container) 中注册，可以选择延迟加载该绑定直到注册绑定的服务真的需要时再加载，延迟加载这样的一个提供者将会提升应用的性能，因为它不会在每次请求时都从文件系统加载。\r\n\r\n\r\n\r\nLaravel 编译并保存延迟服务提供者提供的所有服务的列表，以及其服务提供者类的名称。因此，只有当你在尝试解析其中一项服务时，Laravel 才会加载服务提供者。\r\n\r\n要延迟加载提供者，需要实现 `\\Illuminate\\Contracts\\Support\\DeferrableProvider` 接口并置一个 `provides` 方法。这个 `provides` 方法返回该提供者注册的服务容器绑定：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Services\\Riak\\Connection;\r\n    use Illuminate\\Contracts\\Support\\DeferrableProvider;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class RiakServiceProvider extends ServiceProvider implements DeferrableProvider\r\n    {\r\n        /**\r\n         * 注册所有的应用服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            $this->app->singleton(Connection::class, function ($app) {\r\n                return new Connection($app['config']['riak']);\r\n            });\r\n        }\r\n\r\n        /**\r\n         * 获取服务提供者的服务\r\n         * \r\n         * @return array\r\n         */\r\n        public function provides()\r\n        {\r\n            return [Connection::class];\r\n        }\r\n    }\r\n\r\n","p":"docs/providers.html"},{"t":"facades (Facades)","d":"# Facades\r\n\r\n- [简介](#introduction)\r\n- [何时使用 Facades](#when-to-use-facades)\r\n    - [Facades Vs 依赖注入](#facades-vs-dependency-injection)\r\n    - [Facades Vs 助手函数](#facades-vs-helper-functions)\r\n- [Facades 工作原理](#how-facades-work)\r\n- [实时 Facades](#real-time-facades)\r\n- [Facade 参考类](#facade-class-reference)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在整个 Laravel 文档中，您将看到通过 Facades 与 Laravel 特性交互的代码示例。Facades 为应用程序的 [服务容器 ](/docs/laravel/9.x/container)中可用的类提供了「静态代理」。在 Laravel 这艘船上有许多 Facades，提供了几乎所有 Laravel 的特征。\r\n\r\nLaravel Facades 充当服务容器中底层类的「静态代理」，提供简洁、富有表现力的好处，同时保持比传统静态方法更多的可测试性和灵活性。如果你不完全理解引擎盖下的 Facades 是如何工作的，那也没问题，跟着流程走，继续学习 Laravel。\r\n\r\nLaravel 的所有 Facades 都在 `Illuminate\\Support\\Facades` 命名空间中定义。因此，我们可以很容易地访问这样一个 Facades：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    Route::get('/cache', function () {\r\n        return Cache::get('key');\r\n    });\r\n\r\n在整个 Laravel 文档中，许多示例将使用 Facades 来演示框架的各种特性。\r\n\r\n<a name=\"helper-functions\"></a>\r\n#### 辅助函数\r\n\r\n为了补充 Facades，Laravel 提供了各种全局 「助手函数」，使它更容易与常见的 Laravel 功能进行交互。可以与之交互的一些常用助手函数有 `view`， `response`， `url`， `config`，等。Laravel 提供的每个助手函数都有相应的特性；但是，在专用的 [辅助函数文档](/docs/laravel/9.x/helpers) 中有一个完整的列表。\r\n\r\n\r\n\r\n例如，我们可以简单地使用 `response` 函数，而不是使用 `Illuminate\\Support\\Facades\\Response` Facade 来生成 JSON 响应。因为 helper 函数是全局可用的，所以不需要导入任何类就可以使用它们：\r\n\r\n    use Illuminate\\Support\\Facades\\Response;\r\n\r\n    Route::get('/users', function () {\r\n        return Response::json([\r\n            // ...\r\n        ]);\r\n    });\r\n\r\n    Route::get('/users', function () {\r\n        return response()->json([\r\n            // ...\r\n        ]);\r\n    });\r\n\r\n<a name=\"when-to-use-facades\"></a>\r\n## 什么时候使用 Facades\r\n\r\nFacade 有很多好处。它们提供了一种简洁、令人难忘的语法，允许您使用 Laravel 的特性，而无需记住必须手动注入或配置的长类名。此外，由于它们对 PHP 的动态方法的独特用法，它们很容易测试：\r\n\r\n但是，在使用 Facade 时必须小心。Facade 的主要危险是「范围溢出」。由于 Facade 非常容易使用并且不需要注入，所以让类继续增长并在单个类中使用多个 Facade 是很容易的。通过使用依赖注入，一个大型构造函数给您的视觉反馈减轻了这种可能性，即类增长过大。所以，在使用 Facade 的时候，要特别注意你的类规模，这样它的职责范围就不会太窄。如果你的类太大了，可以考虑把它分成多个较小的类。\r\n\r\n<a name=\"facades-vs-dependency-injection\"></a>\r\n### Facades Vs 依赖注入\r\n\r\n依赖注入的主要好处之一是能够交换注入类的实现。这在测试期间非常有用，因为您可以注入一个 mock 或 stub 并断言在 stub 上调用了各种方法。\r\n\r\n\r\n\r\n通常，真正的静态方法是不可能 mock 或 stub 的。但是由于 Facades 使用动态方法对服务容器中解析出来的对象方法的调用进行了代理， 我们也可以像测试注入类实例一样测试 Facades。比如，像下面的路由：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    Route::get('/cache', function () {\r\n        return Cache::get('key');\r\n    });\r\n\r\n使用 Laravel 的 Facade 测试方法，我们可以编写以下测试用例来验证是否 `Cache::get` 使用我们期望的参数调用了该方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    /**\r\n     * 一个进步功能测试用例\r\n     *\r\n     * @return void\r\n     */\r\n    public function testBasicExample()\r\n    {\r\n        Cache::shouldReceive('get')\r\n             ->with('key')\r\n             ->andReturn('value');\r\n\r\n        $response = $this->get('/cache');\r\n\r\n        $response->assertSee('value');\r\n    }\r\n\r\n<a name=\"facades-vs-helper-functions\"></a>\r\n### Facades Vs 助手函数\r\n\r\n除了 Facades，Laravel 还包含各种「辅助函数」来实现这些常用功能，比如生成视图、触发事件、任务调度或者发送 HTTP 响应。许多辅助函数都有与之对应的 Facade。例如，下面这个 Facades 和辅助函数的作用是一样的：\r\n\r\n    return Illuminate\\Support\\Facades\\View::make('profile');\r\n\r\n    return view('profile');\r\n\r\nFacades 和辅助函数之间没有实际的区别。 当你使用辅助函数时，你可以像测试相应的 Facade 那样进行测试。例如，下面的路由：\r\n\r\n    Route::get('/cache', function () {\r\n        return cache('key');\r\n    });\r\n\r\n在底层实现，辅助函数 `cache` 实际是调用 `Cache` 这个 Facade 的 `get` 方法。因此，尽管我们使用的是辅助函数，我们依然可以带上我们期望的参数编写下面的测试代码来验证该方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    /**\r\n     * 一个基础功能的测试用例\r\n     *\r\n     * @return void\r\n     */\r\n    public function testBasicExample()\r\n    {\r\n        Cache::shouldReceive('get')\r\n             ->with('key')\r\n             ->andReturn('value');\r\n\r\n        $response = $this->get('/cache');\r\n\r\n        $response->assertSee('value');\r\n    }\r\n\r\n\r\n\r\n<a name=\"how-facades-work\"></a>\r\n## Facades 工作原理\r\n\r\n在 Laravel 应用程序中，Facades 是一个提供从容器访问对象的类。完成这项工作的部分属于`Facade` 类。Laravel 的 Facade、以及您创建的任何自定义 Facade，都继承自  `Illuminate\\Support\\Facades\\Facade` 类。\r\n\r\n`Facade` 基类使用 `__callStatic()` 魔术方法将来自 Facade 的调用推迟到从容器解析出对象后。在下面的示例中，调用了 Laravel 缓存系统。看一眼这段代码，人们可能会假设静态的 `get` 方法正在 `Cache` 类上被调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示给定用户的个人资料。\r\n         *\r\n         * @param  int  $id\r\n         * @return Response\r\n         */\r\n        public function showProfile($id)\r\n        {\r\n            $user = Cache::get('user:'.$id);\r\n\r\n            return view('profile', ['user' => $user]);\r\n        }\r\n    }\r\n\r\n请注意，在文件顶部附近，我们正在「导入」`Cache` Facade。这个 Facade 作为访问 `Illuminate\\Contracts\\Cache\\Factory` 接口底层实现的代理。我们使用 Facade 进行的任何调用都将传递给 Laravel 缓存服务的底层实例。\r\n\r\n如果我们查看 `Illuminate\\Support\\Facades\\Cache` 类，您会发现没有静态方法 `get`：\r\n\r\n    class Cache extends Facade\r\n    {\r\n        /**\r\n         * 获取组件的注册名称。\r\n         *\r\n         * @return string\r\n         */\r\n        protected static function getFacadeAccessor() { return 'cache'; }\r\n    }\r\n\r\n相反，`Cache` Facade 继承了 `Facade` 基类并定义了 `getFacadeAccessor()` 方法。此方法的工作是返回服务容器绑定的名称。当用户引用 `Cache` Facade 上的任何静态方法时，Laravel 会从 [服务容器](/docs/laravel/9.x/container) 中解析 `cache` 绑定并运行该对象请求的方法（在这个例子中就是 `get` 方法）\r\n\r\n\r\n\r\n<a name=\"实时 Facades\"></a>\r\n## 实时 Facades\r\n\r\n使用实时 Facade, 你可以将应用程序中的任何类视为 Facade。为了说明这是如何使用的， 让我们首先看一下一些不使用实时 Facade 的代码。例如，假设我们的 `Podcast` 模型有一个 `publish` 方法。 但是，为了发布 Podcast，我们需要注入一个 `Publisher` 实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Contracts\\Publisher;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Podcast extends Model\r\n    {\r\n        /**\r\n         * 发布 Podcast.\r\n         *\r\n         * @param  Publisher  $publisher\r\n         * @return void\r\n         */\r\n        public function publish(Publisher $publisher)\r\n        {\r\n            $this->update(['publishing' => now()]);\r\n\r\n            $publisher->publish($this);\r\n        }\r\n    }\r\n\r\n将 publisher 的实现注入到该方法中，我们可以轻松地测试这种方法，因为我们可以模拟注入的 publisher 。但是，它要求我们每次调用 `publish` 方法时始终传递一个 publisher 实例。 使用实时的 Facades, 我们可以保持同样的可测试性，而不需要显式地通过 `Publisher` 实例。要生成实时 Facade，请在导入类的名称空间中加上 `Facades`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Facades\\App\\Contracts\\Publisher;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Podcast extends Model\r\n    {\r\n        /**\r\n         * 发布 Podcast.\r\n         *\r\n         * @return void\r\n         */\r\n        public function publish()\r\n        {\r\n            $this->update(['publishing' => now()]);\r\n\r\n            Publisher::publish($this);\r\n        }\r\n    }\r\n\r\n当使用实时 Facade 时， publisher 实现将通过使用 `Facades` 前缀后出现的接口或类名的部分来解决服务容器的问题。在测试时，我们可以使用 Laravel 的内置 Facade 测试辅助函数来模拟这种方法调用：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Models\\Podcast;\r\n    use Facades\\App\\Contracts\\Publisher;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Tests\\TestCase;\r\n\r\n    class PodcastTest extends TestCase\r\n    {\r\n        use RefreshDatabase;\r\n\r\n        /**\r\n         * 一个测试用例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_podcast_can_be_published()\r\n        {\r\n            $podcast = Podcast::factory()->create();\r\n\r\n            Publisher::shouldReceive('publish')->once()->with($podcast);\r\n\r\n            $podcast->publish();\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"facade-class-reference\"></a>\r\n## Facade 类参考\r\n\r\n在下面你可以找到每个 Facade 类及其对应的底层类。这是一个查找给定 Facade 类 API 文档的工具。[服务容器绑定](/docs/laravel/9.x/container) 的关键信息也包含在内。\r\n\r\nFacade  |  类  |  服务容器绑定\r\n------------- | ------------- | -------------\r\nApp  |  [Illuminate\\Foundation\\Application](https://laravel.com/api/laravel/9.x/Illuminate/Foundation/Application.html)  |  `app`\r\nArtisan  |  [Illuminate\\Contracts\\Console\\Kernel](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Console/Kernel.html)  |  `artisan`\r\nAuth  |  [Illuminate\\Auth\\AuthManager](https://laravel.com/api/laravel/9.x/Illuminate/Auth/AuthManager.html)  |  `auth`\r\nAuth (Instance)  |  [Illuminate\\Contracts\\Auth\\Guard](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Auth/Guard.html)  |  `auth.driver`\r\nBlade  |  [Illuminate\\View\\Compilers\\BladeCompiler](https://laravel.com/api/laravel/9.x/Illuminate/View/Compilers/BladeCompiler.html)  |  `blade.compiler`\r\nBroadcast  |  [Illuminate\\Contracts\\Broadcasting\\Factory](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Broadcasting/Factory.html)  |  &nbsp;\r\nBroadcast (Instance)  |  [Illuminate\\Contracts\\Broadcasting\\Broadcaster](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Broadcasting/Broadcaster.html)  |  &nbsp;\r\nBus  |  [Illuminate\\Contracts\\Bus\\Dispatcher](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Bus/Dispatcher.html)  |  &nbsp;\r\nCache  |  [Illuminate\\Cache\\CacheManager](https://laravel.com/api/laravel/9.x/Illuminate/Cache/CacheManager.html)  |  `cache`\r\nCache (Instance)  |  [Illuminate\\Cache\\Repository](https://laravel.com/api/laravel/9.x/Illuminate/Cache/Repository.html)  |  `cache.store`\r\nConfig  |  [Illuminate\\Config\\Repository](https://laravel.com/api/laravel/9.x/Illuminate/Config/Repository.html)  |  `config`\r\nCookie  |  [Illuminate\\Cookie\\CookieJar](https://laravel.com/api/laravel/9.x/Illuminate/Cookie/CookieJar.html)  |  `cookie`\r\nCrypt  |  [Illuminate\\Encryption\\Encrypter](https://laravel.com/api/laravel/9.x/Illuminate/Encryption/Encrypter.html)  |  `encrypter`\r\nDate  |  [Illuminate\\Support\\DateFactory](https://laravel.com/api/laravel/9.x/Illuminate/Support/DateFactory.html)  |  `date`\r\nDB  |  [Illuminate\\Database\\DatabaseManager](https://laravel.com/api/laravel/9.x/Illuminate/Database/DatabaseManager.html)  |  `db`\r\nDB (Instance)  |  [Illuminate\\Database\\Connection](https://laravel.com/api/laravel/9.x/Illuminate/Database/Connection.html)  |  `db.connection`\r\nEvent  |  [Illuminate\\Events\\Dispatcher](https://laravel.com/api/laravel/9.x/Illuminate/Events/Dispatcher.html)  |  `events`\r\nFile  |  [Illuminate\\Filesystem\\Filesystem](https://laravel.com/api/laravel/9.x/Illuminate/Filesystem/Filesystem.html)  |  `files`\r\nGate  |  [Illuminate\\Contracts\\Auth\\Access\\Gate](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Auth/Access/Gate.html)  |  &nbsp;\r\nHash  |  [Illuminate\\Contracts\\Hashing\\Hasher](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Hashing/Hasher.html)  |  `hash`\r\nHttp  |  [Illuminate\\Http\\Client\\Factory](https://laravel.com/api/laravel/9.x/Illuminate/Http/Client/Factory.html)  |  &nbsp;\r\nLang  |  [Illuminate\\Translation\\Translator](https://laravel.com/api/laravel/9.x/Illuminate/Translation/Translator.html)  |  `translator`\r\nLog  |  [Illuminate\\Log\\LogManager](https://laravel.com/api/laravel/9.x/Illuminate/Log/LogManager.html)  |  `log`\r\nMail  |  [Illuminate\\Mail\\Mailer](https://laravel.com/api/laravel/9.x/Illuminate/Mail/Mailer.html)  |  `mailer`\r\nNotification  |  [Illuminate\\Notifications\\ChannelManager](https://laravel.com/api/laravel/9.x/Illuminate/Notifications/ChannelManager.html)  |  &nbsp;\r\nPassword  |  [Illuminate\\Auth\\Passwords\\PasswordBrokerManager](https://laravel.com/api/laravel/9.x/Illuminate/Auth/Passwords/PasswordBrokerManager.html)  |  `auth.password`\r\nPassword (Instance)  |  [Illuminate\\Auth\\Passwords\\PasswordBroker](https://laravel.com/api/laravel/9.x/Illuminate/Auth/Passwords/PasswordBroker.html)  |  `auth.password.broker`\r\nQueue  |  [Illuminate\\Queue\\QueueManager](https://laravel.com/api/laravel/9.x/Illuminate/Queue/QueueManager.html)  |  `queue`\r\nQueue (Instance)  |  [Illuminate\\Contracts\\Queue\\Queue](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Queue/Queue.html)  |  `queue.connection`\r\nQueue (Base Class)  |  [Illuminate\\Queue\\Queue](https://laravel.com/api/laravel/9.x/Illuminate/Queue/Queue.html)  |  &nbsp;\r\nRedirect  |  [Illuminate\\Routing\\Redirector](https://laravel.com/api/laravel/9.x/Illuminate/Routing/Redirector.html)  |  `redirect`\r\nRedis  |  [Illuminate\\Redis\\RedisManager](https://laravel.com/api/laravel/9.x/Illuminate/Redis/RedisManager.html)  |  `redis`\r\nRedis (Instance)  |  [Illuminate\\Redis\\Connections\\Connection](https://laravel.com/api/laravel/9.x/Illuminate/Redis/Connections/Connection.html)  |  `redis.connection`\r\nRequest  |  [Illuminate\\Http\\Request](https://laravel.com/api/laravel/9.x/Illuminate/Http/Request.html)  |  `request`\r\nResponse  |  [Illuminate\\Contracts\\Routing\\ResponseFactory](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Routing/ResponseFactory.html)  |  &nbsp;\r\nResponse (Instance)  |  [Illuminate\\Http\\Response](https://laravel.com/api/laravel/9.x/Illuminate/Http/Response.html)  |  &nbsp;\r\nRoute  |  [Illuminate\\Routing\\Router](https://laravel.com/api/laravel/9.x/Illuminate/Routing/Router.html)  |  `router`\r\nSchema  |  [Illuminate\\Database\\Schema\\Builder](https://laravel.com/api/laravel/9.x/Illuminate/Database/Schema/Builder.html)  |  &nbsp;\r\nSession  |  [Illuminate\\Session\\SessionManager](https://laravel.com/api/laravel/9.x/Illuminate/Session/SessionManager.html)  |  `session`\r\nSession (Instance)  |  [Illuminate\\Session\\Store](https://laravel.com/api/laravel/9.x/Illuminate/Session/Store.html)  |  `session.store`\r\nStorage  |  [Illuminate\\Filesystem\\FilesystemManager](https://laravel.com/api/laravel/9.x/Illuminate/Filesystem/FilesystemManager.html)  |  `filesystem`\r\nStorage (Instance)  |  [Illuminate\\Contracts\\Filesystem\\Filesystem](https://laravel.com/api/laravel/9.x/Illuminate/Contracts/Filesystem/Filesystem.html)  |  `filesystem.disk`\r\nURL  |  [Illuminate\\Routing\\UrlGenerator](https://laravel.com/api/laravel/9.x/Illuminate/Routing/UrlGenerator.html)  |  `url`\r\nValidator  |  [Illuminate\\Validation\\Factory](https://laravel.com/api/laravel/9.x/Illuminate/Validation/Factory.html)  |  `validator`\r\nValidator (Instance)  |  [Illuminate\\Validation\\Validator](https://laravel.com/api/laravel/9.x/Illuminate/Validation/Validator.html)  |  &nbsp;\r\nView  |  [Illuminate\\View\\Factory](https://laravel.com/api/laravel/9.x/Illuminate/View/Factory.html)  |  `view`\r\nView (Instance)  |  [Illuminate\\View\\View](https://laravel.com/api/laravel/9.x/Illuminate/View/View.html)  |  &nbsp;\r\n\r\n","p":"docs/facades.html"},{"t":"routing (# 基本路由)","d":" # 路由\r\n\r\n- [基本路由](#basic-routing)\r\n    - [路由重定向](#redirect-routes)\r\n    - [路由视图](#view-routes)\r\n- [路由参数](#route-parameters)\r\n    - [必选参数](#required-parameters)\r\n    - [可选参数](#parameters-optional-parameters)\r\n    - [正则约束](#parameters-regular-expression-constraints)\r\n- [路由命名](#named-routes)\r\n- [路由分组](#route-groups)\r\n    - [中间件](#route-group-middleware)\r\n    - [Controllers](#route-group-controllers)\r\n    - [子域名路由](#route-group-subdomain-routing)\r\n    - [路由前缀](#route-group-prefixes)\r\n    - [路由前缀命名](#route-group-name-prefixes)\r\n- [路由模型绑定](#route-model-binding)\r\n    - [隐式绑定](#implicit-binding)\r\n    - [隐式枚举绑定](#implicit-enum-binding)\r\n    - [显式绑定](#explicit-binding)\r\n- [回退路由](#fallback-routes)\r\n- [限流](#rate-limiting)\r\n    - [定义限流器](#defining-rate-limiters)\r\n    - [独立访客和认证用户的限流](#attaching-rate-limiters-to-routes)\r\n- [伪造表单方法](#form-method-spoofing)\r\n- [访问当前路由](#accessing-the-current-route)\r\n- [跨源资源共享 (CORS)](#cors)\r\n- [路由缓存](#route-caching)\r\n\r\n<a name=\"basic-routing\"></a>\r\n## 基本路由\r\n\r\n最基本的Laravel路由接受一个 URI 和一个闭包，提供了一个简单优雅的方法来定义路由和行为，而不需要复杂的路由配置文件：\r\n\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    Route::get('/greeting', function () {\r\n        return 'Hello World';\r\n    });\r\n\r\n<a name=\"the-default-route-files\"></a>\r\n#### 默认路由文件\r\n\r\n所有 Laravel 路由都定义在你的路由文件中，它位于 `routes` 目录。这些文件会被你的应用程序中的 `App\\Providers\\RouteServiceProvider` 自动加载。`routes/web.php` 文件用于定义 `web` 界面的路由。这些路由被分配给 `web` 中间件组, 它提供了 SESSION 状态和 CSRF 保护等功能。定义在 `routes/api.php` 中的路由都是无状态的，并且被分配了 `api` 中间件组。\r\n\r\n对于大多数应用程序，都是以在 `routes/web.php` 文件定义路由开始的。可以通过在浏览器中输入定义的路由 URL 来访问 `routes/web.php` 中定义的路由。例如，你可以在浏览器中输入 `http://example.com/user` 来访问以下路由：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    Route::get('/user', [UserController::class, 'index']);\r\n\r\n\r\n\r\n定义在 `routes/api.php` 文件中的路由是被 `RouteServiceProvider` 嵌套在一个路由组内。 在这个路由组内, 将自动应用 `/api` URI 前缀，所以你无需手动将其应用于文件中的每个路由。你可以通过修改 `RouteServiceProvider` 类来修改前缀和其他路由组选项。\r\n\r\n<a name=\"available-router-methods\"></a>\r\n#### 可用的路由方法\r\n\r\n路由器允许你注册能响应任何 HTTP 请求的路由：\r\n\r\n    Route::get($uri, $callback);\r\n    Route::post($uri, $callback);\r\n    Route::put($uri, $callback);\r\n    Route::patch($uri, $callback);\r\n    Route::delete($uri, $callback);\r\n    Route::options($uri, $callback);\r\n\r\n有的时候你可能需要注册一个可响应多个 HTTP 请求的路由，这时你可以使用 `match` 方法，也可以使用 `any` 方法注册一个实现响应所有 HTTP 请求的路由：\r\n\r\n    Route::match(['get', 'post'], '/', function () {\r\n        //\r\n    });\r\n\r\n    Route::any('/', function () {\r\n        //\r\n    });\r\n\r\n> 技巧：当定义多个相同路由时，使用 `get`， `post`， `put`， `patch`， `delete`， 和 `options` 方法的路由应该在使用 `any`， `match`， 和 `redirect` 方法的路由之前定义，这样可以确保请求与正确的路由匹配。\r\n\r\n<a name=\"dependency-injection\"></a>\r\n#### 依赖注入\r\n\r\n你可以在路由的回调方法中，以形参的方式声明路由所需要的任何依赖项。这些依赖会被 Laravel 的 [容器](/docs/laravel/9.x/container) 自动解析并注入。 例如, 你可以在闭包中声明 `Illuminate\\Http\\Request` 类，让当前的 HTTP 请求自动注入依赖到你的路由回调中：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/users', function (Request $request) {\r\n        // ...\r\n    });\r\n\r\n\r\n\r\n<a name=\"csrf-protection\"></a>\r\n#### CSRF 保护\r\n\r\n请记住，指向 `POST`、`PUT`、`PATCH`、或 `DELETE` 路由的任何 HTML 表单都应该包含一个 CSRF 令牌字段，否则，这个请求将会被拒绝。可以在 [CSRF 文档](/docs/laravel/9.x/csrf) 中阅读有关 CSRF 更多的信息：\r\n\r\n    <form method=\"POST\" action=\"/profile\">\r\n        @csrf\r\n        ...\r\n    </form>\r\n\r\n<a name=\"redirect-routes\"></a>\r\n### 重定向路由\r\n\r\n如果要定义重定向到另一个 URI 的路由，可以使用 `Route::redirect` 方法。这个方法可以快速的实现重定向，而不再需要去定义完整的路由或者控制器：\r\n\r\n    Route::redirect('/here', '/there');\r\n\r\n默认情况下，`Route::redirect` 返回 `302` 状态码。你可以使用可选的第三个参数来定制状态码：\r\n\r\n    Route::redirect('/here', '/there', 301);\r\n\r\n或者，你可以使用 `Route::permanentRedirect` 方法返回 `301` 状态码：\r\n\r\n    Route::permanentRedirect('/here', '/there');\r\n\r\n> 注意：在重定向路由中使用路由参数时，以下参数由 Laravel 保留，不能使用：  `destination` 和 `status`\r\n\r\n<a name=\"view-routes\"></a>\r\n### 视图路由\r\n\r\n如果你的路由只需要返回一个 [视图](/docs/laravel/9.x/views)，可以使用 `Route::view` 方法。它和 `redirect` 一样方便，不需要定义完整的路由或控制器。`view` 方法有三个参数，其中前两个是必填参数，分别是 URI 和视图名称。第三个参数选填，可以传入一个数组，数组中的数据会被传递给视图：\r\n\r\n    Route::view('/welcome', 'welcome');\r\n\r\n    Route::view('/welcome', 'welcome', ['name' => 'Taylor']);\r\n\r\n> 注意：当在视图路由使用路由参数，下面的参数是由 Laravel 保留，不能使用：`view`， `data`，`status`，和 `headers`\r\n\r\n\r\n\r\n<a name=\"route-parameters\"></a>\r\n## 路由参数\r\n\r\n<a name=\"required-parameters\"></a>\r\n### 必填参数\r\n\r\n有时你将需要捕获路由内的 URI 段。例如，你可能需要从 URL 中捕获用户的 ID。你可以通过定义路由参数来做到这一点：\r\n\r\n    Route::get('/user/{id}', function ($id) {\r\n        return 'User '.$id;\r\n    });\r\n\r\n也可以根据你的需要在路由中定义多个参数：\r\n\r\n    Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {\r\n        //\r\n    });\r\n\r\n路由的参数通常都会被放在 `{}` ，并且参数名只能为字母。下划线 (`_`) 也可以用于路由参数名中。路由参数会按路由定义的顺序依次注入到路由回调或者控制器中，而不受回调或者控制器的参数名称的影响。\r\n\r\n<a name=\"parameters-and-dependency-injection\"></a>\r\n#### 参数和依赖注入\r\n\r\n如果你的路由具有依赖关系，而你希望 Laravel 服务容器自动注入到路由的回调中，则应在依赖关系之后列出路由参数：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/{id}', function (Request $request, $id) {\r\n        return 'User '.$id;\r\n    });\r\n\r\n<a name=\"parameters-optional-parameters\"></a>\r\n### 可选参数\r\n\r\n有时，你可能需要指定一个路由参数，但你希望这个参数是可选的。你可以在参数后面加上 `?` 标记来实现，但前提是要确保路由的相应变量有默认值：\r\n\r\n    Route::get('/user/{name?}', function ($name = null) {\r\n        return $name;\r\n    });\r\n\r\n    Route::get('/user/{name?}', function ($name = 'John') {\r\n        return $name;\r\n    });\r\n\r\n<a name=\"parameters-regular-expression-constraints\"></a>\r\n\r\n\r\n### 正则表达式约束\r\n\r\n你可以使用路由实例上的 where 方法来限制路由参数的格式。 where 方法接受参数的名称和定义如何约束参数的正则表达式：\r\n\r\n    Route::get('/user/{name}', function ($name) {\r\n        //\r\n    })->where('name', '[A-Za-z]+');\r\n\r\n    Route::get('/user/{id}', function ($id) {\r\n        //\r\n    })->where('id', '[0-9]+');\r\n\r\n    Route::get('/user/{id}/{name}', function ($id, $name) {\r\n        //\r\n    })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);\r\n\r\n为方便起见，一些常用的正则表达式模式具有帮助方法，可让你快速将模式约束添加到路由：\r\n\r\n    Route::get('/user/{id}/{name}', function ($id, $name) {\r\n        //\r\n    })->whereNumber('id')->whereAlpha('name');\r\n\r\n    Route::get('/user/{name}', function ($name) {\r\n        //\r\n    })->whereAlphaNumeric('name');\r\n\r\n    Route::get('/user/{id}', function ($id) {\r\n        //\r\n    })->whereUuid('id');\r\n\r\n如果传入的请求与路由模式约束不匹配，将返回 404 HTTP 响应。\r\n\r\n<a name=\"parameters-global-constraints\"></a>\r\n#### 全局约束\r\n\r\n如果你希望路由参数始终受给定正则表达式的约束，你可以使用 `pattern` 方法。 你应该在 `App\\Providers\\RouteServiceProvider` 类的 `boot` 方法中定义这些模式：\r\n\r\n    /**\r\n     * 定义路由模型绑定、模式过滤器等。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Route::pattern('id', '[0-9]+');\r\n    }\r\n\r\n一旦定义了模式，它就会自动应用到使用该参数名称的所有路由：\r\n\r\n    Route::get('/user/{id}', function ($id) {\r\n        // 仅当{id}是数字时执行。。。\r\n    });\r\n\r\n\r\n\r\n<a name=\"parameters-encoded-forward-slashes\"></a>\r\n#### 编码正斜杠\r\n\r\nLaravel 路由组件允许除 `/` 之外的所有字符出现在路由参数值中。 你必须使用 `where` 条件正则表达式明确允许 `/` 成为占位符的一部分：\r\n\r\n    Route::get('/search/{search}', function ($search) {\r\n        return $search;\r\n    })->where('search', '.*');\r\n\r\n> 注意：仅在最后一个路由段中支持编码的正斜杠。\r\n\r\n<a name=\"named-routes\"></a>\r\n## 命名路由\r\n\r\n命名路由允许为特定路由方便地生成URL或重定向。通过将\t`name` 方法链接到路由定义上，可以指定路由的名称：\r\n\r\n    Route::get('/user/profile', function () {\r\n        //\r\n    })->name('profile');\r\n\r\n你还可以为控制器操作指定路由名称：\r\n\r\n    Route::get(\r\n        '/user/profile',\r\n        [UserProfileController::class, 'show']\r\n    )->name('profile');\r\n\r\n> 注意：路由名称应始终是唯一的。\r\n\r\n<a name=\"generating-urls-to-named-routes\"></a>\r\n#### 生成命名路由的 URL\r\n\r\n一旦你为给定的路由分配了一个名字，你可以在通过 Laravel 的 `route` 和 `redirect` 辅助函数生成 URL 或重定向时使用该路由的名称：\r\n\r\n    // 正在生成 URL...\r\n    $url = route('profile');\r\n\r\n    // 正在生成重定向...\r\n    return redirect()->route('profile');\r\n\r\n如果命名路由定义了参数，你可以将参数作为第二个参数传递给 `route` 函数。 给定的参数将自动插入到生成的 URL 的正确位置：\r\n\r\n    Route::get('/user/{id}/profile', function ($id) {\r\n        //\r\n    })->name('profile');\r\n\r\n    $url = route('profile', ['id' => 1]);\r\n\r\n如果你在数组中传递其他参数，这些键/值对将自动添加到生成的 URL 的查询字符串中：\r\n\r\n    Route::get('/user/{id}/profile', function ($id) {\r\n        //\r\n    })->name('profile');\r\n\r\n    $url = route('profile', ['id' => 1, 'photos' => 'yes']);\r\n\r\n    // /user/1/profile?photos=yes\r\n\r\n> 技巧：有时，你可能希望为 URL 参数指定请求范围的默认值，例如当前语言环境。 为此，你可以使用 [`URL::defaults` 方法](/docs/laravel/9.x/urls#default-values)。\r\n\r\n\r\n\r\n<a name=\"inspecting-the-current-route\"></a>\r\n#### 检查当前路由\r\n\r\n如果你想确定当前请求是否路由到给定的命名路由，你可以在 Route 实例上使用 `named` 方法。 例如，你可以从路由中间件检查当前路由名称：\r\n\r\n    /**\r\n     * 处理传入的请求。\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @param  \\Closure  $next\r\n     * @return mixed\r\n     */\r\n    public function handle($request, Closure $next)\r\n    {\r\n        if ($request->route()->named('profile')) {\r\n            //\r\n        }\r\n\r\n        return $next($request);\r\n    }\r\n\r\n<a name=\"route-groups\"></a>\r\n## 路由组\r\n\r\n路由组允许你共享路由属性，例如中间件，而无需在每个单独的路由上定义这些属性。\r\n\r\n嵌套组尝试智能地将属性与其父组「合并」。中间件和 `where` 条件合并，同时附加名称和前缀。 URI 前缀中的命名空间分隔符和斜杠会在适当的地方自动添加。\r\n\r\n<a name=\"route-group-middleware\"></a>\r\n### 路由中间件\r\n\r\n要将 [middleware](/docs/laravel/9.x/middleware) 分配给组内的所有路由，你可以在定义组之前使用 `middleware` 方法。 中间件按照它们在数组中列出的顺序执行：\r\n\r\n    Route::middleware(['first', 'second'])->group(function () {\r\n        Route::get('/', function () {\r\n            // 使用第一个和第二个中间件...\r\n        });\r\n\r\n        Route::get('/user/profile', function () {\r\n            // 使用第一个和第二个中间件...\r\n        });\r\n    });\r\n\r\n<a name=\"route-group-controllers\"></a>\r\n### 控制器\r\n\r\n如果一组路由都使用相同的 [控制器](/docs/laravel/9.x/controllers)，你可以使用 `controller` 方法为组内的所有路由定义公共控制器。然后，在定义路由时，你只需要提供它们调用的控制器方法：\r\n\r\n    use App\\Http\\Controllers\\OrderController;\r\n\r\n    Route::controller(OrderController::class)->group(function () {\r\n        Route::get('/orders/{id}', 'show');\r\n        Route::post('/orders', 'store');\r\n    });\r\n\r\n\r\n\r\n<a name=\"route-group-subdomain-routing\"></a>\r\n### 子域路由\r\n\r\n路由组也可以用来处理子域路由。子域可以像路由 uri 一样被分配路由参数，允许你捕获子域的一部分以便在路由或控制器中使用。子域可以在定义组之前调用 `domain` 方法来指定:\r\n\r\n    Route::domain('{account}.example.com')->group(function () {\r\n        Route::get('user/{id}', function ($account, $id) {\r\n            //\r\n        });\r\n    });\r\n\r\n> 注意：为了确保子域路由是可以访问的，你应该在注册根域路由之前注册子域路由。这将防止根域路由覆盖具有相同 URI 路径的子域路由。\r\n\r\n<a name=\"route-group-prefixes\"></a>\r\n### 路由前缀\r\n\r\n`prefix` 方法可以用给定的 URI 为组中的每个路由做前缀。例如，你可能想要在组内的所有路由 uri 前面加上 `admin` 前缀：\r\n\r\n    Route::prefix('admin')->group(function () {\r\n        Route::get('/users', function () {\r\n            // Matches The \"/admin/users\" URL\r\n        });\r\n    });\r\n\r\n<a name=\"route-group-name-prefixes\"></a>\r\n### 路由名称前缀\r\n\r\n`name` 方法可以用给定字符串作为组中的每个路由名的前缀。例如，你可能想要用 `admin` 作为所有分组路由的前缀。因为给定字符串的前缀与指定的路由名完全一致，所以我们一定要提供末尾 `.` 字符在前缀中：\r\n\r\n    Route::name('admin.')->group(function () {\r\n        Route::get('/users', function () {\r\n            // Route assigned name \"admin.users\"...\r\n        })->name('users');\r\n    });\r\n\r\n<a name=\"route-model-binding\"></a>\r\n\r\n\r\n## 路由模型绑定\r\n\r\n将模型 ID 注入到路由或控制器操作时，你通常会查询数据库以检索与该 ID 对应的模型。Laravel 路由模型绑定提供了一种方便的方法来自动将模型实例直接注入到你的路由中。例如，你可以注入与给定 ID 匹配的整个 `User` 模型实例，而不是注入用户的 ID。\r\n\r\n<a name=\"implicit-binding\"></a>\r\n### 隐式绑定\r\n\r\nLaravel 自动解析定义在路由或控制器操作中的 Eloquent 模型，其类型提示的变量名称与路由段名称匹配。例如：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}', function (User $user) {\r\n        return $user->email;\r\n    });\r\n\r\n由于 `$user` 变量被类型提示为 `App\\Models\\User` Eloquent 模型，并且变量名称与 `{user}` URI 段匹配，Laravel 将自动注入 ID 匹配相应的模型实例 来自请求 URI 的值。如果在数据库中没有找到匹配的模型实例，将自动生成 404 HTTP 响应。\r\n\r\n当然，使用控制器方法时也可以使用隐式绑定。同样，请注意 `{user}` URI 段与控制器中的 `$user` 变量匹配，该变量包含 `App\\Models\\User` 类型提示：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n    use App\\Models\\User;\r\n\r\n    // Route definition...\r\n    Route::get('/users/{user}', [UserController::class, 'show']);\r\n\r\n    // Controller method definition...\r\n    public function show(User $user)\r\n    {\r\n        return view('user.profile', ['user' => $user]);\r\n    }\r\n\r\n<a name=\"implicit-soft-deleted-models\"></a>\r\n#### 软删除模型\r\n\r\n通常，隐式模型绑定不会检索已 [软删除](/docs/laravel/9.x/eloquent#soft-deleting) 的模型。但是，你可以通过将 `withTrashed` 方法链接到你的路由定义来指示隐式绑定来检索这些模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}', function (User $user) {\r\n        return $user->email;\r\n    })->withTrashed();\r\n\r\n<a name=\"customizing-the-key\"></a>\r\n<a name=\"customizing-the-default-key-name\"></a>\r\n#### 自定义密钥\r\n\r\n有时你可能希望使用 id 以外的列来解析 Eloquent 模型。为此，你可以在路由参数定义中指定列：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    Route::get('/posts/{post:slug}', function (Post $post) {\r\n        return $post;\r\n    });\r\n\r\n如果你希望模型绑定在检索给定模型类时始终使用 `id` 以外的数据库列，则可以覆盖 Eloquent 模型上的 `getRouteKeyName` 方法：\r\n\r\n    /**\r\n     * Get the route key for the model.\r\n     *\r\n     * @return string\r\n     */\r\n    public function getRouteKeyName()\r\n    {\r\n        return 'slug';\r\n    }\r\n\r\n<a name=\"implicit-model-binding-scoping\"></a>\r\n#### 自定义键和范围\r\n\r\n当在单个路由定义中隐式绑定多个 Eloquent 模型时，你可能希望限定第二个 Eloquent 模型的范围，使其必须是前一个 Eloquent 模型的子模型。例如，考虑这个通过 slug 为特定用户检索博客文章的路由定义：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {\r\n        return $post;\r\n    });\r\n\r\n当使用自定义键控隐式绑定作为嵌套路由参数时，Laravel 将自动限定查询范围以通过其父级检索嵌套模型，使用约定来猜测父级上的关系名称。 在这种情况下，假设 `User` 模型有一个名为 `posts` 的关系（路由参数名称的复数形式），可用于检索 `Post` 模型。\r\n\r\n如果你愿意，即使未提供自定义键，你也可以指示 Laravel 限定「子」绑定的范围。为此，你可以在定义路由时调用 `scopeBindings` 方法：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\r\n        return $post;\r\n    })->scopeBindings();\r\n\r\n或者，你可以指示整个路由定义组使用范围绑定：\r\n\r\n    Route::scopeBindings()->group(function () {\r\n        Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\r\n            return $post;\r\n        });\r\n    });\r\n\r\n<a name=\"customizing-missing-model-behavior\"></a>\r\n#### 自定义缺失模型行为\r\n\r\n通常，如果未找到隐式绑定模型，则会生成 404 HTTP 响应。但是，你可以通过在定义路由时调用 `missing` 方法来自定义此行为。`missing` 方法接受一个闭包，如果找不到隐式绑定模型，则将调用该闭包：\r\n\r\n    use App\\Http\\Controllers\\LocationsController;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Redirect;\r\n\r\n    Route::get('/locations/{location:slug}', [LocationsController::class, 'show'])\r\n            ->name('locations.view')\r\n            ->missing(function (Request $request) {\r\n                return Redirect::route('locations.index');\r\n            });\r\n\r\n<a name=\"implicit-enum-binding\"></a>\r\n### 隐式枚举绑定\r\n\r\nPHP 8.1 引入了对 [Enums](https://www.php.net/manual/en/language.enumerations.backed.php) 的支持。为了补充这个特性，Laravel 允许你在你的路由定义中键入一个 Enum，并且 Laravel 只会在该路由段对应于一个有效的 Enum 值时调用该路由。否则，将自动返回 404 HTTP 响应。例如，给定以下枚举：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Enums;\r\n\r\nenum Category: string\r\n{\r\n    case Fruits = 'fruits';\r\n    case People = 'people';\r\n}\r\n```\r\n\r\n你可以定义一个只有在 `{category}` 路由段是 `fruits` 或 `people` 时才会被调用的路由。 否则，Laravel 将返回 404 HTTP 响应：\r\n\r\n```php\r\nuse App\\Enums\\Category;\r\nuse Illuminate\\Support\\Facades\\Route;\r\n\r\nRoute::get('/categories/{category}', function (Category $category) {\r\n    return $category->value;\r\n});\r\n```\r\n\r\n<a name=\"explicit-binding\"></a>\r\n### 显式绑定\r\n\r\n你不需要使用 Laravel 隐式的、基于约定的模型解析来使用模型绑定。你还可以显式定义路由参数与模型的对应方式。要注册显式绑定，请使用路由器的“模型”方法为给定参数指定类。 你应该在 RouteServiceProvider 类的 boot 方法的开头定义显式模型绑定：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    /**\r\n     * Define your route model bindings, pattern filters, etc.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Route::model('user', User::class);\r\n\r\n        // ...\r\n    }\r\n\r\n接下来，定义一个包含 `{user}` 参数的路由：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}', function (User $user) {\r\n        //\r\n    });\r\n\r\n由于我们已将所有 `{user}` 参数绑定到 `App\\Models\\User` 模型，该类的一个实例将被注入到路由中。 因此，例如，对 `users/1` 的请求将从 ID 为 `1` 的数据库中注入 `User` 实例。\r\n\r\n如果在数据库中没有找到匹配的模型实例，则会自动生成 404 HTTP 响应。\r\n\r\n<a name=\"customizing-the-resolution-logic\"></a>\r\n#### 自定义解析逻辑\r\n\r\n如果你想定义你自己的模型绑定解析逻辑，你可以使用 `Route::bind` 方法。传递给 `bind` 方法的闭包将接收 URI 段的值，并应返回应注入路由的类的实例。同样，这种定制应该在应用程序的 `RouteServiceProvider` 的 `boot` 方法中进行：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    /**\r\n     * Define your route model bindings, pattern filters, etc.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Route::bind('user', function ($value) {\r\n            return User::where('name', $value)->firstOrFail();\r\n        });\r\n\r\n        // ...\r\n    }\r\n\r\n或者，你可以覆盖 Eloquent 模型上的 `resolveRouteBinding` 方法。此方法将接收 URI 段的值，并应返回应注入路由的类的实例：\r\n\r\n    /**\r\n     * Retrieve the model for a bound value.\r\n     *\r\n     * @param  mixed  $value\r\n     * @param  string|null  $field\r\n     * @return \\Illuminate\\Database\\Eloquent\\Model|null\r\n     */\r\n    public function resolveRouteBinding($value, $field = null)\r\n    {\r\n        return $this->where('name', $value)->firstOrFail();\r\n    }\r\n\r\n如果路由正在使用 [implicit binding scoping](#implicit-model-binding-scoping)，则 `resolveChildRouteBinding` 方法将用于解析父模型的子绑定：\r\n\r\n    /**\r\n     * Retrieve the child model for a bound value.\r\n     *\r\n     * @param  string  $childType\r\n     * @param  mixed  $value\r\n     * @param  string|null  $field\r\n     * @return \\Illuminate\\Database\\Eloquent\\Model|null\r\n     */\r\n    public function resolveChildRouteBinding($childType, $value, $field)\r\n    {\r\n        return parent::resolveChildRouteBinding($childType, $value, $field);\r\n    }\r\n\r\n<a name=\"fallback-routes\"></a>\r\n## fallback 路由\r\n\r\n使用 `Route::fallback` 方法，你可以定义一个在没有其他路由匹配传入请求时将执行的路由。 通常，未处理的请求将通过应用程序的异常处理程序自动呈现「404」页面。但是，由于你通常会在 `routes/web.php` 文件中定义 `fallback` 路由，因此 `web` 中间件组中的所有中间件都将应用于该路由。你可以根据需要随意向此路由添加额外的中间件：\r\n\r\n    Route::fallback(function () {\r\n        //\r\n    });\r\n\r\n> 注意：fallback路由应该始终是你的应用程序注册的最后一个路由。\r\n\r\n<a name=\"rate-limiting\"></a>\r\n## 速率限制\r\n\r\n<a name=\"defining-rate-limiters\"></a>\r\n### 定义速率限制器\r\n\r\nLaravel 包含强大且可自定义的速率限制服务，你可以利用这些服务来限制给定路由或一组路由的流量。首先，你应该定义满足应用程序需求的速率限制器配置。通常，这应该在应用程序的 `App\\Providers\\RouteServiceProvider` 类的 `configureRateLimiting` 方法中完成。\r\n\r\n速率限制器是使用 `RateLimiter` 外观的 `for` 方法定义的。 `for` 方法接受一个速率限制器名称和一个闭包，该闭包返回应该应用于分配给速率限制器的路由的限制配置。限制配置是 `Illuminate\\Cache\\RateLimiting\\Limit` 类的实例。此类包含有用的「构建器」方法，以便你可以快速定义限制。速率限制器名称可以是你希望的任何字符串：\r\n\r\n    use Illuminate\\Cache\\RateLimiting\\Limit;\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    /**\r\n     * Configure the rate limiters for the application.\r\n     *\r\n     * @return void\r\n     */\r\n    protected function configureRateLimiting()\r\n    {\r\n        RateLimiter::for('global', function (Request $request) {\r\n            return Limit::perMinute(1000);\r\n        });\r\n    }\r\n\r\n如果传入的请求超过指定的速率限制，Laravel 将自动返回一个带有 429 HTTP 状态码的响应。如果你想定义自己的响应，应该由速率限制返回，你可以使用 `response` 方法：\r\n\r\n    RateLimiter::for('global', function (Request $request) {\r\n        return Limit::perMinute(1000)->response(function () {\r\n            return response('Custom response...', 429);\r\n        });\r\n    });\r\n\r\n由于速率限制器回调接收传入的 HTTP 请求实例，你可以根据传入的请求或经过身份验证的用户动态构建适当的速率限制：\r\n\r\n    RateLimiter::for('uploads', function (Request $request) {\r\n        return $request->user()->vipCustomer()\r\n                    ? Limit::none()\r\n                    : Limit::perMinute(100);\r\n    });\r\n\r\n<a name=\"segmenting-rate-limits\"></a>\r\n#### 分段速率限制\r\n\r\n有时你可能希望按某个任意值对速率限制进行分段。例如，你可能希望每个 IP 地址每分钟允许用户访问给定路由 100 次。为此，你可以在构建速率限制时使用 `by` 方法：\r\n\r\n    RateLimiter::for('uploads', function (Request $request) {\r\n        return $request->user()->vipCustomer()\r\n                    ? Limit::none()\r\n                    : Limit::perMinute(100)->by($request->ip());\r\n    });\r\n\r\n为了使用另一个示例来说明此功能，我们可以将每个经过身份验证的用户 ID 的路由访问限制为每分钟 100 次，或者对于访客来说，每个 IP 地址每分钟访问 10 次：\r\n\r\n    RateLimiter::for('uploads', function (Request $request) {\r\n        return $request->user()\r\n                    ? Limit::perMinute(100)->by($request->user()->id)\r\n                    : Limit::perMinute(10)->by($request->ip());\r\n    });\r\n\r\n<a name=\"multiple-rate-limits\"></a>\r\n#### 多个速率限制\r\n\r\n如果需要，你可以返回给定速率限制器配置的速率限制数组。将根据路由在数组中的放置顺序评估每个速率限制：\r\n\r\n    RateLimiter::for('login', function (Request $request) {\r\n        return [\r\n            Limit::perMinute(500),\r\n            Limit::perMinute(3)->by($request->input('email')),\r\n        ];\r\n    });\r\n\r\n<a name=\"attaching-rate-limiters-to-routes\"></a>\r\n### 将速率限制器附加到路由\r\n\r\n可以使用 `throttle` [middleware](/docs/laravel/9.x/middleware) 将速率限制器附加到路由或路由组。路由中间件接受你希望分配给路由的速率限制器的名称：\r\n\r\n    Route::middleware(['throttle:uploads'])->group(function () {\r\n        Route::post('/audio', function () {\r\n            //\r\n        });\r\n\r\n        Route::post('/video', function () {\r\n            //\r\n        });\r\n    });\r\n\r\n<a name=\"throttling-with-redis\"></a>\r\n#### 使用 Redis 节流\r\n\r\n通常，`throttle` 中间件映射到 `Illuminate\\Routing\\Middleware\\ThrottleRequests` 类。 此映射在应用程序的 HTTP 内核 (`App\\Http\\Kernel`) 中定义。但是，如果你使用 Redis 作为应用程序的缓存驱动程序，你可能希望更改此映射以使用 `Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis` 类。这个类在使用 Redis 管理速率限制方面更有效：\r\n\r\n    'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis::class,\r\n\r\n<a name=\"form-method-spoofing\"></a>\r\n## 伪造表单方法\r\n\r\nHTML 表单不支持「PUT」，「PATCH」或「DELETE」请求。所以，当定义「PUT」，「PATCH」或「DELETE」路由用在 HTML 表单时，你将需要一个隐藏的加「_method」字段在表单中。该「_method」字段的值将会与 HTTP 请求一起发送。\r\n\r\n    <form action=\"/example\" method=\"POST\">\r\n        <input type=\"hidden\" name=\"_method\" value=\"PUT\">\r\n        <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\">\r\n    </form>\r\n\r\n为方便起见，你可以使用 `@method` [Blade 指令](/docs/laravel/9.x/blade) 生成 `_method` 输入字段：\r\n\r\n    <form action=\"/example\" method=\"POST\">\r\n        @method('PUT')\r\n        @csrf\r\n    </form>\r\n\r\n<a name=\"accessing-the-current-route\"></a>\r\n## 访问当前路由\r\n\r\n你可以使用 `Route Facade` 的 `current`、`currentRouteName` 和 `currentRouteAction` 方法来访问有关处理传入请求的路由的信息：\r\n\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    $route = Route::current(); // Illuminate\\Routing\\Route\r\n    $name = Route::currentRouteName(); // string\r\n    $action = Route::currentRouteAction(); // string\r\n\r\n你可以参考[Route facade 的底层类](https://laravel.com/api/laravel/9.x/Illuminate/Routing/Router.html) 和 [Route 实例](https://laravel.com/api/laravel/9.x/Illuminate/Routing/Route.html) 的 API 文档查看路由器和路由类上可用的所有方法。\r\n\r\n<a name=\"cors\"></a>\r\n## 跨域资源共享 (CORS)\r\n\r\nLaravel 可以使用你配置的值自动响应 CORS `OPTIONS` HTTP 请求。所有 CORS 设置都可以在应用程序的 `config/cors.php` 配置文件中进行配置。 `OPTIONS` 请求将由默认包含在全局中间件堆栈中的 `HandleCors` [中间件](/docs/laravel/9.x/middleware) 自动处理。你的全局中间件堆栈位于应用程序的 HTTP 内核 (`App\\Http\\Kernel`) 中。\r\n\r\n> 技巧：有关 CORS 和 CORS 标头的更多信息，请参阅 [MDN 关于 CORS 的 Web 文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers)。\r\n\r\n<a name=\"route-caching\"></a>\r\n## 路由缓存\r\n\r\n在将应用程序部署到生产环境时，你应该利用 Laravel 的路由缓存。使用路由缓存将大大减少注册所有应用程序路由所需的时间。要生成路由缓存，请执行 `route:cache` Artisan 命令：\r\n\r\n```shell\r\nphp artisan route:cache\r\n```\r\n\r\n运行此命令后，你的缓存路由文件将在每个请求上加载。请记住，如果你添加任何新路线，你将需要生成新的路线缓存。因此，你应该只在项目部署期间运行 `route:cache` 命令。\r\n\r\n你可以使用 `route:clear` 命令清除路由缓存：\r\n\r\n```shell\r\nphp artisan route:clear\r\n```\r\n\r\n\r\n<a name=\"自定义秘钥\"></a>\r\n<a name=\"自定义键和范围\"></a>\r\n","p":"docs/routing.html"},{"t":"middleware (中间件)","d":"# 中间件\r\n\r\n- [介绍](#introduction)\r\n- [定义中间件](#defining-middleware)\r\n- [注册中间件](#registering-middleware)\r\n     - [全局中间件](#global-middleware)\r\n     - [将中间件分配给路由](#assigning-middleware-to-routes)\r\n     - [中间件组](#middleware-groups)\r\n     - [排序中间件](#sorting-middleware)\r\n- [中间件参数](#middleware-parameters)\r\n- [可终止的中间件](#terminable-middleware)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n中间件提供了一种方便的机制来检查和过滤进入应用程序的 HTTP 请求。 例如，Laravel 包含一个中间件，用于验证您的应用程序的用户是否经过身份验证。 如果用户未通过身份验证，中间件会将用户重定向到应用程序的登录屏幕。 但是，如果用户通过了身份验证，中间件将允许请求进一步进入应用程序。\r\n\r\n除了身份验证之外，还可以编写其他中间件来执行各种任务。例如，日志中间件可能会将所有传入请求记录到您的应用程序。Laravel 框架中包含了几个中间件，包括用于身份验证和 CSRF 保护的中间件。 所有这些中间件都位于 `app/Http/Middleware` 目录中。\r\n\r\n<a name=\"defining-middleware\"></a>\r\n## 定义中间件\r\n\r\n要创建新的中间件，请使用 `make:middleware` Artisan 命令：\r\n\r\n```shell\r\nphp artisan make:middleware EnsureTokenIsValid\r\n```\r\n\r\n此命令将在您的 `app/Http/Middleware` 目录中放置一个新的 `EnsureTokenIsValid` 类。在这个中间件中，如果提供的 `token` 输入匹配指定的值，我们将只允许访问路由。否则，我们会将用户重定向回 `home` URI：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n\r\n    class EnsureTokenIsValid\r\n    {\r\n        /**\r\n         * Handle an incoming request.\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Closure  $next\r\n         * @return mixed\r\n         */\r\n        public function handle($request, Closure $next)\r\n        {\r\n            if ($request->input('token') !== 'my-secret-token') {\r\n                return redirect('home');\r\n            }\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n\r\n\r\n如您所见，如果给定的 `token` 与我们的秘密令牌不匹配，中间件将向客户端返回 HTTP 重定向； 否则，请求将被进一步传递到应用程序中。要将请求更深入地传递到应用程序中（允许中间件「通过」），您应该使用 `$request` 调用 `$next` 回调。\r\n\r\n最好将中间件设想为一系列「层」HTTP 请求在到达您的应用程序之前必须通过。每一层都可以检查请求，甚至完全拒绝它。\r\n\r\n> 技巧：所有中间件都通过 [服务容器](/docs/laravel/9.x/container) 解析，因此您可以在中间件的构造函数中键入提示您需要的任何依赖项。\r\n\r\n<a name=\"before-after-middleware\"></a>\r\n<a name=\"middleware-and-responses\"></a>\r\n#### 中间件和响应\r\n\r\n当然，中间件可以在将请求更深入地传递到应用程序之前或之后执行任务。 例如，以下中间件将在应用程序处理请求之前**执行一些任务**：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n\r\n    class BeforeMiddleware\r\n    {\r\n        public function handle($request, Closure $next)\r\n        {\r\n            // 执行操作\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n但是，此中间件将在**请求由应用程序处理后**执行其任务：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n\r\n    class AfterMiddleware\r\n    {\r\n        public function handle($request, Closure $next)\r\n        {\r\n            $response = $next($request);\r\n\r\n            // 执行操作\r\n\r\n            return $response;\r\n        }\r\n    }\r\n\r\n<a name=\"registering-middleware\"></a>\r\n## 注册中间件\r\n\r\n<a name=\"global-middleware\"></a>\r\n### 全局中间件\r\n\r\n如果您希望在对应用程序的每个 HTTP 请求期间运行中间件，请在 `app/Http/Kernel.php` 类的 `$middleware` 属性中列出中间件类。\r\n\r\n<a name=\"assigning-middleware-to-routes\"></a>\r\n### 将中间件分配给路由\r\n\r\n如果您想将中间件分配给特定的路由，您应该首先在应用程序的 `app/Http/Kernel.php` 文件中为中间件分配一个键。默认情况下，该类的 `$routeMiddleware` 属性包含 Laravel 中包含的中间件的条目。 您可以将自己的中间件添加到此列表中，并为其分配您选择的键：\r\n\r\n    // 在 App\\Http\\Kernel 类中...\r\n\r\n    protected $routeMiddleware = [\r\n        'auth' => \\App\\Http\\Middleware\\Authenticate::class,\r\n        'auth.basic' => \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\r\n        'bindings' => \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n        'cache.headers' => \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class,\r\n        'can' => \\Illuminate\\Auth\\Middleware\\Authorize::class,\r\n        'guest' => \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\r\n        'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,\r\n        'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\r\n        'verified' => \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,\r\n    ];\r\n\r\n一旦在 HTTP 内核中定义了中间件，您就可以使用 `middleware` 方法将中间件分配给路由：\r\n\r\n    Route::get('/profile', function () {\r\n        //\r\n    })->middleware('auth');\r\n\r\n您可以通过将一组中间件名称传递给 `middleware` 方法来为路由分配多个中间件：\r\n\r\n    Route::get('/', function () {\r\n        //\r\n    })->middleware(['first', 'second']);\r\n\r\n分配中间件时，您还可以传递完全限定的类名：\r\n\r\n    use App\\Http\\Middleware\\EnsureTokenIsValid;\r\n\r\n    Route::get('/profile', function () {\r\n        //\r\n    })->middleware(EnsureTokenIsValid::class);\r\n\r\n<a name=\"excluding-middleware\"></a>\r\n#### 排除中间件\r\n\r\n将中间件分配给一组路由时，您可能偶尔需要阻止将中间件应用于组内的单个路由。您可以使用 `withoutMiddleware` 方法完成此操作：\r\n\r\n    use App\\Http\\Middleware\\EnsureTokenIsValid;\r\n\r\n    Route::middleware([EnsureTokenIsValid::class])->group(function () {\r\n        Route::get('/', function () {\r\n            //\r\n        });\r\n\r\n        Route::get('/profile', function () {\r\n            //\r\n        })->withoutMiddleware([EnsureTokenIsValid::class]);\r\n    });\r\n\r\n您还可以从整个 [组](/docs/laravel/9.x/routing#route-groups) 路由定义中排除一组给定的中间件：\r\n\r\n    use App\\Http\\Middleware\\EnsureTokenIsValid;\r\n\r\n    Route::withoutMiddleware([EnsureTokenIsValid::class])->group(function () {\r\n        Route::get('/profile', function () {\r\n            //\r\n        });\r\n    });\r\n\r\n`withoutMiddleware` 方法只能移除路由中间件，不适用于[全局中间件](#global-middleware)。\r\n\r\n<a name=\"middleware-groups\"></a>\r\n### 中间件组\r\n\r\n有时您可能希望将多个中间件组合在一个键下，以使它们更容易分配给路由。您可以使用 HTTP 内核的 `$middlewareGroups` 属性来完成此操作。\r\n\r\n开箱即用，Laravel 带有 `web` 和 `api` 中间件组，其中包含您可能希望应用于 Web 和 API 路由的常见中间件。请记住，这些中间件组会由应用程序的 `App\\Providers\\RouteServiceProvider` 服务提供者自动应用于相应的 `web` 和 `api` 路由文件中的路由：\r\n\r\n    /**\r\n     * 应用程序的路由中间件组。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $middlewareGroups = [\r\n        'web' => [\r\n            \\App\\Http\\Middleware\\EncryptCookies::class,\r\n            \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class,\r\n            \\Illuminate\\Session\\Middleware\\StartSession::class,\r\n            // \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,\r\n            \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\r\n            \\App\\Http\\Middleware\\VerifyCsrfToken::class,\r\n            \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n        ],\r\n\r\n        'api' => [\r\n            'throttle:api',\r\n            \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n        ],\r\n    ];\r\n\r\n可以使用与单个中间件相同的语法将中间件组分配给路由和控制器操作。同样，中间件组使一次将许多中间件分配给路由更加方便：\r\n\r\n    Route::get('/', function () {\r\n        //\r\n    })->middleware('web');\r\n\r\n    Route::middleware(['web'])->group(function () {\r\n        //\r\n    });\r\n\r\n> 技巧：开箱即用，`web` 和 `api` 中间件组会通过 `App\\Providers\\RouteServiceProvider` 自动应用于应用程序对应的 `routes/web.php` 和 `routes/api.php` 文件。\r\n\r\n<a name=\"sorting-middleware\"></a>\r\n### 排序中间件\r\n\r\n很少，您可能需要您的中间件按特定顺序执行，但在将它们分配给路由时无法控制它们的顺序。 在这种情况下，您可以使用 `app/Http/Kernel.php` 文件的 `$middlewarePriority` 属性指定中间件优先级。默认情况下，您的 HTTP 内核中可能不存在此属性。如果它不存在，您可以在下面复制其默认定义：\r\n\r\n    /**\r\n     * 中间件的优先级排序列表。\r\n     *\r\n     * 这会强制非全局中间件始终按给定顺序排列。\r\n     *\r\n     * @var string[]\r\n     */\r\n    protected $middlewarePriority = [\r\n        \\Illuminate\\Cookie\\Middleware\\EncryptCookies::class,\r\n        \\Illuminate\\Session\\Middleware\\StartSession::class,\r\n        \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\r\n        \\Illuminate\\Contracts\\Auth\\Middleware\\AuthenticatesRequests::class,\r\n        \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\r\n        \\Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis::class,\r\n        \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,\r\n        \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n        \\Illuminate\\Auth\\Middleware\\Authorize::class,\r\n    ];\r\n\r\n<a name=\"middleware-parameters\"></a>\r\n## 中间件参数\r\n\r\n中间件也可以接收额外的参数。例如，如果您的应用程序需要在执行给定操作之前验证经过身份验证的用户是否具有给定的「角色」，您可以创建一个 `EnsureUserHasRole` 中间件，该中间件接收角色名称作为附加参数。\r\n\r\n额外的中间件参数将在 `$next` 参数之后传递给中间件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n\r\n    class EnsureUserHasRole\r\n    {\r\n        /**\r\n         * 处理传入的请求。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Closure  $next\r\n         * @param  string  $role\r\n         * @return mixed\r\n         */\r\n        public function handle($request, Closure $next, $role)\r\n        {\r\n            if (! $request->user()->hasRole($role)) {\r\n                // 重定向...\r\n            }\r\n\r\n            return $next($request);\r\n        }\r\n\r\n    }\r\n\r\n在定义路由时，可以指定中间件参数，方法是使用 `:` 分隔中间件名称和参数。多个参数应以逗号分隔：\r\n\r\n    Route::put('/post/{id}', function ($id) {\r\n        //\r\n    })->middleware('role:editor');\r\n\r\n<a name=\"terminable-middleware\"></a>\r\n## 可终止的中间件\r\n\r\n有时，在将 HTTP 响应发送到浏览器之后，中间件可能需要做一些工作。如果您在中间件上定义了一个 `terminate` 方法，并且您的 Web 服务器使用 FastCGI，则在将响应发送到浏览器后会自动调用 `terminate` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Illuminate\\Session\\Middleware;\r\n\r\n    use Closure;\r\n\r\n    class TerminatingMiddleware\r\n    {\r\n        /**\r\n         * 处理传入的请求。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Closure  $next\r\n         * @return mixed\r\n         */\r\n        public function handle($request, Closure $next)\r\n        {\r\n            return $next($request);\r\n        }\r\n\r\n        /**\r\n         * 在响应发送到浏览器后处理任务。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Illuminate\\Http\\Response  $response\r\n         * @return void\r\n         */\r\n        public function terminate($request, $response)\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n`terminate` 方法应该同时接收请求和响应。一旦你定义了一个可终止的中间件，你应该将它添加到 `app/Http/Kernel.php` 文件中的路由或全局中间件列表中。\r\n\r\n当在中间件上调用 `terminate` 方法时，Laravel 会从 [服务容器](/docs/laravel/9.x/container) 解析一个新的中间件实例。如果您想在调用 `handle` 和 `terminate` 方法时使用相同的中间件实例，请使用容器的 `singleton` 方法向容器注册中间件。 通常这应该在你的 AppServiceProvider 的 register 方法中完成：\r\n\r\n    use App\\Http\\Middleware\\TerminatingMiddleware;\r\n\r\n    /**\r\n     * 注册任何应用程序服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->app->singleton(TerminatingMiddleware::class);\r\n    }\r\n\r\n\r\n[//]: <> (什么鬼啊，没有东西，又提交不了)\r\n\r\n<a name=\"before-after-middleware\"></a>\r\n<a name=\"middleware-and-responses\"></a>\r\n","p":"docs/middleware.html"},{"t":"csrf (CSRF 保护)","d":"# CSRF 保护\r\n\r\n- [简介](#csrf-introduction)\r\n- [阻止CSRF请求](#preventing-csrf-requests)\r\n    - [排除URLS](#csrf-excluding-uris)\r\n- [X-CSRF-Token](#csrf-x-csrf-token)\r\n- [X-XSRF-Token](#csrf-x-xsrf-token)\r\n\r\n<a name=\"csrf-introduction\"></a>\r\n## 简介\r\n\r\n跨站点请求伪造是一种恶意利用，利用这种手段，代表经过身份验证的用户执行未经授权的命令。值得庆幸的是，Laravel 可以轻松保护您的应用程序免受[跨站点请求伪造](https://en.wikipedia.org/wiki/Cross-site_request_forgery)（CSRF）攻击。\r\n\r\n<a name=\"csrf-explanation\"></a>\r\n#### 漏洞的解释\r\n\r\n如果您不熟悉跨站点请求伪造，我们讨论一个利用此漏洞的示例。假设您的应用程序有一个  `/user/email` 路由，它接受 `POST` 请求来更改经过身份验证用户的电子邮件地址。最有可能的情况是，此路由希望 `email` 输入字段包含用户希望开始使用的电子邮件地址。\r\n\r\n没有 CSRF 保护，恶意网站可能会创建一个HTML表单，指向您的应用程序 `/user/email` 路由，并提交恶意用户自己的电子邮件地址：\r\n\r\n```blade\r\n<form action=\"https://your-application.com/user/email\" method=\"POST\">\r\n    <input type=\"email\" value=\"malicious-email@example.com\">\r\n</form>\r\n\r\n<script>\r\n    document.forms[0].submit();\r\n</script>\r\n```\r\n\r\n如果恶意网站在页面加载时自动提交了表单，则恶意用户只需要诱使您的应用程序的一个毫无戒心的用户访问他们的网站，他们的电子邮件地址就会在您的应用程序中更改。\r\n\r\n为了防止这种漏洞，我们需要检查每一个传入的 `POST`，`PUT`，`PATCH` 或 `DELETE` 请求以获取恶意应用程序无法访问的秘密会话值。\r\n\r\n<a name=\"阻止CSRF请求\"></a>\r\n## 阻止 CSRF 请求\r\n\r\nLaravel 为应用程序管理的每个活动 [用户会话](/docs/laravel/9.x/session) 自动生成 CSRF 「令牌」。此令牌用于验证经过身份验证的用户是实际向应用程序发出请求的人。由于此令牌存储在用户的会话中，并且每次重新生成会话时都会更改，因此恶意应用程序将无法访问它。\r\n\r\n当前会话的 CSRF 令牌可以通过请求的会话或通过 `csrf_token` 辅助函数进行访问：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/token', function (Request $request) {\r\n        $token = $request->session()->token();\r\n\r\n        $token = csrf_token();\r\n\r\n        // ...\r\n    });\r\n\r\n每当您在应用程序中定义 HTML 表单时，都应在表单中包含一个隐藏的 CSRF `_token` 字段，以便 CSRF 保护中间件可以验证请求。为了方便起见，您可以使用 `@csrf` Blade 指令生成隐藏的令牌输入字段：\r\n\r\n```blade\r\n<form method=\"POST\" action=\"/profile\">\r\n    @csrf\r\n\r\n    <!-- 等同于... -->\r\n    <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\" />\r\n</form>\r\n```\r\n\r\n`App\\Http\\Middleware\\VerifyCsrfToken` [中间件](/docs/laravel/9.x/middleware)，其包括在在 `web` 由默认中间件基，将自动验证在请求输入的令牌匹配令牌存储在会话。当这两个令牌匹配时，我们知道经过身份验证的用户就是发起请求的用户。\r\n\r\n<a name=\"csrf-tokens-and-spas\"></a>\r\n### CSRF Tokens & SPAs\r\n\r\n如果您正在构建一个将 Laravel 用作 API 后端的 SPA，您应该查阅 [Laravel Sanctum 文档](/docs/laravel/9.x/sanctum)，以获取有关使用 API 进行身份验证和防范 CSRF 漏洞的信息。\r\n\r\n\r\n<a name=\"csrf-excluding-uris\"></a>\r\n### 从 CSRF 保护中排除 URI\r\n\r\n有时你可能希望从 CSRF 保护中排除一组 URI。例如，如果您使用 [Stripe](https://stripe.com) 处理付款并使用他们的 webhook 系统，则需要将你的 Stripe webhook 处理程序路由从 CSRF 保护中排除，因为 Stripe 不会知道要向您的路由发送什么 CSRF 令牌。\r\n\r\n通常，你应该将这些类型的路由放在 `App\\Providers\\RouteServiceProvider` 应用于 routes/web.php 文件中的所有路由的 `web` 中间件组之外。但是，你现在也可以通过将路由的 URI 添加到 `VerifyCsrfToken` 中间件的 `$except` 属性来排除路由：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware;\r\n\r\n    class VerifyCsrfToken extends Middleware\r\n    {\r\n        /**\r\n         * 从 CSRF 验证中排除的 URI。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $except = [\r\n            'stripe/*',\r\n            'http://example.com/foo/bar',\r\n            'http://example.com/foo/*',\r\n        ];\r\n    }\r\n\r\n> 技巧：为方便起见，[运行测试](/docs/laravel/9.x/testing)时自动禁用所有路由的 CSRF 中间件。\r\n\r\n<a name=\"csrf-x-csrf-token\"></a>\r\n## X-CSRF-TOKEN\r\n\r\n除了检查 CSRF 令牌作为 POST 参数外，`App\\Http\\Middleware\\VerifyCsrfToken` 中间件还将检查 `X-CSRF-TOKEN` 请求标头。 例如，你可以将令牌存储在 HTML 的 `meta` 标签中：\r\n\r\n```blade\r\n<meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\r\n```\r\n\r\n然后，您可以指示 jQuery 之类的库自动将令牌添加到所有请求标头。 这为使用传统 JavaScript 技术的基于 AJAX 的应用程序提供了简单、方便的 CSRF 保护：\r\n\r\n```js\r\n$.ajaxSetup({\r\n    headers: {\r\n        'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\r\n    }\r\n});\r\n```\r\n\r\n\r\n\r\n<a name=\"csrf-x-xsrf-token\"></a>\r\n## X-XSRF-TOKEN\r\n\r\nLaravel 将当前的 CSRF 令牌存储在一个加密的 `XSRF-TOKEN` cookie 中，该 cookie 包含在框架生成的每个响应中。您可以使用 cookie 值来设置 `X-XSRF-TOKEN` 请求标头。\r\n\r\n这个 cookie 主要是为了方便开发人员发送的，因为一些 JavaScript 框架和库，如 Angular 和 Axios，会自动将其值放在同源请求的 `X-XSRF-TOKEN` 标头中。\r\n\r\n> 技巧：默认情况下，`resources/js/bootstrap.js` 文件包含 Axios HTTP 库，它会自动为您发送 `X-XSRF-TOKEN` 标头。\r\n\r\n","p":"docs/csrf.html"},{"t":"controllers (控制器)","d":"# 控制器\r\n\r\n- [介绍](#introduction)\r\n- [编写控制器](#writing-controllers)\r\n     - [基本控制器](#basic-controllers)\r\n     - [单动作控制器](#single-action-controllers)\r\n- [控制器中间件](#controller-middleware)\r\n- [资源控制器](#resource-controllers)\r\n     - [部分资源路由](#restful-partial-resource-routes)\r\n     - [嵌套资源](#restful-nested-resources)\r\n     - [命名资源路由](#restful-naming-resource-routes)\r\n     - [命名资源路由参数](#restful-naming-resource-route-parameters)\r\n     - [范围资源路由](#restful-scoping-resource-routes)\r\n     - [本地化资源 URI](#restful-localizing-resource-uris)\r\n     - [补充资源控制器](#restful-supplementing-resource-controllers)\r\n- [依赖注入 & 控制器](#dependency-injection-and-controllers)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n您可能希望使用“控制器”类来组织此行为，而不是将所有请求处理逻辑定义为路由文件中的闭包。 控制器可以将相关的请求处理逻辑分组到一个类中。 例如，一个 `UserController` 类可能会处理所有与用户相关的传入请求，包括显示、创建、更新和删除用户。 默认情况下，控制器存储在 `app/Http/Controllers` 目录中。\r\n\r\n<a name=\"writing-controllers\"></a>\r\n## 编写控制器\r\n\r\n<a name=\"basic-controllers\"></a>\r\n### 基本控制器\r\n\r\n让我们看一个基本控制器的例子。 请注意，控制器扩展了 Laravel 中包含的基本控制器类 `App\\Http\\Controllers\\Controller`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\User;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示给定用户的个人资料。\r\n         *\r\n         * @param  int  $id\r\n         * @return \\Illuminate\\View\\View\r\n         */\r\n        public function show($id)\r\n        {\r\n            return view('user.profile', [\r\n                'user' => User::findOrFail($id)\r\n            ]);\r\n        }\r\n    }\r\n\r\n您可以像这样定义此控制器方法的路由：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    Route::get('/user/{id}', [UserController::class, 'show']);\r\n\r\n当传入的请求与指定的路由 URI 匹配时，将调用 `App\\Http\\Controllers\\UserController` 类的 `show` 方法，并将路由参数传递给该方法。\r\n\r\n> 技巧：控制器并不是 **必须** 继承基础类。如果控制器没有继承基础类，你将无法使用一些便捷的功能，比如 `middleware` 和 `authorize` 方法。\r\n\r\n\r\n\r\n<a name=\"single-action-controllers\"></a>\r\n### 单动作控制器\r\n\r\n如果控制器动作特别复杂，您可能会发现将整个控制器类专用于该单个动作很方便。为此，您可以在控制器中定义一个 `__invoke` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\User;\r\n\r\n    class ProvisionServer extends Controller\r\n    {\r\n        /**\r\n         * 配置新的 Web 服务器。\r\n         *\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function __invoke()\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n为单动作控制器注册路由时，不需要指定控制器方法。相反，您可以简单地将控制器的名称传递给路由器：\r\n\r\n    use App\\Http\\Controllers\\ProvisionServer;\r\n\r\n    Route::post('/server', ProvisionServer::class);\r\n\r\n您可以使用 `make:controller` Artisan 命令的 `--invokable` 选项生成可调用控制器：\r\n\r\n```shell\r\nphp artisan make:controller ProvisionServer --invokable\r\n```\r\n\r\n> 技巧：可以使用 [stub 定制](/docs/laravel/9.x/artisan#stub-customization) 自定义控制器模板。\r\n\r\n<a name=\"controller-middleware\"></a>\r\n## 控制器中间件\r\n\r\n[中间件](/docs/laravel/9.x/middleware) 可以在您的路由文件中分配给控制器的路由：\r\n\r\n    Route::get('profile', [UserController::class, 'show'])->middleware('auth');\r\n\r\n或者，您可能会发现在控制器的构造函数中指定中间件很方便。使用控制器构造函数中的 `middleware` 方法，您可以将中间件分配给控制器的操作：\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * Instantiate a new controller instance.\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->middleware('auth');\r\n            $this->middleware('log')->only('index');\r\n            $this->middleware('subscribed')->except('store');\r\n        }\r\n    }\r\n\r\n控制器还允许您使用闭包注册中间件。这提供了一种方便的方法来为单个控制器定义内联中间件，而无需定义整个中间件类：\r\n\r\n    $this->middleware(function ($request, $next) {\r\n        return $next($request);\r\n    });\r\n\r\n\r\n\r\n<a name=\"resource-controllers\"></a>\r\n## 资源型控制器\r\n\r\n如果你将应用程序中的每个 Eloquent 模型都视为资源，那么通常对应用程序中的每个资源都执行相同的操作。例如，假设你的应用程序中包含一个 `Photo` 模型和一个 `Movie` 模型。用户可能可以创建，读取，更新或者删除这些资源。\r\n\r\nLaravel 的资源路由通过单行代码即可将典型的「CURD (增删改查)」路由分配给控制器。首先，我们可以使用 Artisan 命令 `make:controller` 的 `--resource` 选项来快速创建一个控制器：\r\n\r\n```shell\r\nphp artisan make:controller PhotoController --resource\r\n```\r\n\r\n这个命令将会生成一个控制器 `app/Http/Controllers/PhotoController.php`。其中包括每个可用资源操作的方法。接下来，你可以给控制器注册一个资源路由：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::resource('photos', PhotoController::class);\r\n\r\n这个单一的路由声明创建了多个路由来处理资源上的各种行为。生成的控制器为每个行为保留了方法，而且你可以通过运行 Artisan 命令 `route:list` 来快速了解你的应用程序。\r\n\r\n你可以通过将数组传参到 resources 方法中的方式来一次性的创建多个资源控制器：\r\n\r\n    Route::resources([\r\n        'photos' => PhotoController::class,\r\n        'posts' => PostController::class,\r\n    ]);\r\n\r\n<a name=\"资源控制器操作处理\"></a>\r\n#### 资源控制器操作处理\r\n\r\nVerb      | URI                    | Action       | Route Name\r\n----------|------------------------|--------------|---------------------\r\nGET       | `/photos`              | index        | photos.index\r\nGET       | `/photos/create`       | create       | photos.create\r\nPOST      | `/photos`              | store        | photos.store\r\nGET       | `/photos/{photo}`      | show         | photos.show\r\nGET       | `/photos/{photo}/edit` | edit         | photos.edit\r\nPUT/PATCH | `/photos/{photo}`      | update       | photos.update\r\nDELETE    | `/photos/{photo}`      | destroy      | photos.destroy\r\n\r\n\r\n\r\n<a name=\"customizing-missing-model-behavior\"></a>\r\n#### 自定义缺失模型行为\r\n\r\n通常，如果未找到隐式绑定的资源模型，则会生成状态码为 404 的 HTTP 响应。 但是，你可以通过在定义资源路由时调用 `missing` 的方法来自定义该行为。`missing` 方法接受一个闭包，如果对于任何资源的路由都找不到隐式绑定模型，则将调用该闭包：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Redirect;\r\n\r\n    Route::resource('photos', PhotoController::class)\r\n            ->missing(function (Request $request) {\r\n                return Redirect::route('photos.index');\r\n            });\r\n\r\n<a name=\"specifying-the-resource-model\"></a>\r\n#### 指定资源模型\r\n\r\n如果你使用了路由模型的绑定 [路由模型绑定](https://learnku.com/docs/laravel/8.5/routing#route-model-binding) 并且想在资源控制器的方法中使用类型提示，你可以在生成控制器的时候使用 `--model` 选项：\r\n\r\n```shell\r\nphp artisan make:controller PhotoController --model=Photo --resource\r\n```\r\n\r\n<a name=\"generating-form-requests\"></a>\r\n#### 生成表单请求\r\n\r\n您可以在生成资源控制器时提供 `--requests` 选项来让 Artisan 为控制器的 storage 和 update 方法生成 [表单请求类](/docs/laravel/9.x/validation#form-request-validation) ：\r\n\r\n```shell\r\nphp artisan make:controller PhotoController --model=Photo --resource --requests\r\n```\r\n\r\n<a name=\"restful-partial-resource-routes\"></a>\r\n### 部分资源路由\r\n\r\n当声明资源路由时，你可以指定控制器处理的部分行为，而不是所有默认的行为：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::resource('photos', PhotoController::class)->only([\r\n        'index', 'show'\r\n    ]);\r\n\r\n    Route::resource('photos', PhotoController::class)->except([\r\n        'create', 'store', 'update', 'destroy'\r\n    ]);\r\n\r\n<a name=\"api-resource-routes\"></a>\r\n\r\n\r\n#### API 资源路由\r\n\r\n当声明用于 API 的资源路由时，通常需要排除显示 HTML 模板的路由。例如 `create` 和 `edit`。为了方便，你可以使用 `apiResource` 方法来排除这两个路由：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::apiResource('photos', PhotoController::class);\r\n\r\n你也可以传递一个数组给 `apiResources` 方法来同时注册多个 API 资源控制器：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n    use App\\Http\\Controllers\\PostController;\r\n\r\n    Route::apiResources([\r\n        'photos' => PhotoController::class,\r\n        'posts' => PostController::class,\r\n    ]);\r\n\r\n要快速生成不包含 `create` 或 `edit` 方法的 API 资源控制器，你可以在执行 `make:controller` 命令时使用 `--api` 参数：\r\n\r\n```shell\r\nphp artisan make:controller PhotoController --api\r\n```\r\n\r\n<a name=\"restful-nested-resources\"></a>\r\n### 嵌套资源\r\n\r\n有时可能需要定义一个嵌套的资源型路由。例如，照片资源可能被添加了多个评论。那么可以在路由中使用 `.` 符号来声明资源型控制器：\r\n\r\n    use App\\Http\\Controllers\\PhotoCommentController;\r\n\r\n    Route::resource('photos.comments', PhotoCommentController::class);\r\n\r\n该路由会注册一个嵌套资源，可以使用如下 URI 访问：\r\n\r\n    /photos/{photo}/comments/{comment}\r\n\r\n<a name=\"scoping-nested-resources\"></a>\r\n#### 限定嵌套资源的范围\r\n\r\nLaravel 的 [隐式模型绑定](/docs/laravel/9.x/routing#implicit-model-binding-scoping) 特性可以自动限定嵌套绑定的范围，以便确认已解析的子模型会自动属于父模型。定义嵌套路由时，使用 `scoped` 方法，可以开启自动范围限定，也可以指定 Laravel 应该按照哪个字段检索子模型资源，有关如何完成此操作的更多信息，请参见有关 [范围资源路由](#restful-scoping-resource-routes) 的文档。\r\n\r\n\r\n\r\n<a name=\"shallow-nesting\"></a>\r\n#### 浅层嵌套\r\n\r\n通常，并不是在所有情况下都需要在 URI 中同时拥有父 ID 和子 ID，因为子 ID 已经是唯一的标识符。当使用唯一标识符（如自动递增的主键）来标识 URL 中的模型时，可以选择使用「浅嵌套」的方式定义路由：\r\n\r\n    use App\\Http\\Controllers\\CommentController;\r\n\r\n    Route::resource('photos.comments', CommentController::class)->shallow();\r\n\r\n上面的路由定义方式会定义以下路由：\r\n\r\nVerb      | URI                               | Action       | Route Name\r\n----------|-----------------------------------|--------------|---------------------\r\nGET       | `/photos/{photo}/comments`        | index        | photos.comments.index\r\nGET       | `/photos/{photo}/comments/create` | create       | photos.comments.create\r\nPOST      | `/photos/{photo}/comments`        | store        | photos.comments.store\r\nGET       | `/comments/{comment}`             | show         | comments.show\r\nGET       | `/comments/{comment}/edit`        | edit         | comments.edit\r\nPUT/PATCH | `/comments/{comment}`             | update       | comments.update\r\nDELETE    | `/comments/{comment}`             | destroy      | comments.destroy\r\n\r\n<a name=\"restful-naming-resource-routes\"></a>\r\n### 命名资源路由\r\n\r\n默认情况下，所有的资源控制器行为都有一个路由名称。你可以传入 `names` 数组来覆盖这些名称：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::resource('photos', PhotoController::class)->names([\r\n        'create' => 'photos.build'\r\n    ]);\r\n\r\n<a name=\"restful-naming-resource-route-parameters\"></a>\r\n### 命名资源路由参数\r\n\r\n默认情况下，`Route::resource` 会根据资源名称的「单数」形式创建资源路由的路由参数。你可以使用 `parameters` 方法来轻松地覆盖资源路由名称。传入 `parameters` 方法应该是资源名称和参数名称的关联数组：\r\n\r\n    use App\\Http\\Controllers\\AdminUserController;\r\n\r\n    Route::resource('users', AdminUserController::class)->parameters([\r\n        'users' => 'admin_user'\r\n    ]);\r\n\r\n \r\n\r\n上面的示例将会为资源的 `show` 路由生成以下的 URL：\r\n\r\n    /users/{admin_user}\r\n\r\n<a name=\"restful-scoping-resource-routes\"></a>\r\n### 限定范围的资源路由\r\n\r\nLaravel 的 [作用域隐式模型绑定](/docs/laravel/9.x/routing#implicit-model-binding-scoping) 功能可以自动确定嵌套绑定的范围，以便确认已解析的子模型属于父模型。通过在定义嵌套资源时使用 `scoped` 方法，你可以启用自动范围界定，并指示 Laravel 应该通过以下方式来检索子资源的哪个字段：\r\n\r\n    use App\\Http\\Controllers\\PhotoCommentController;\r\n\r\n    Route::resource('photos.comments', PhotoCommentController::class)->scoped([\r\n        'comment' => 'slug',\r\n    ]);\r\n\r\n此路由将注册一个有范围的嵌套资源，该资源可以通过以下 URI 进行访问：\r\n\r\n    /photos/{photo}/comments/{comment:slug}\r\n\r\n当使用一个自定义键的隐式绑定作为嵌套路由参数时，Laravel 会自动限定查询范围，按照约定的命名方式去父类中查找关联方法，然后检索到对应的嵌套模型。在这种情况下，将假定 `Photo` 模型有一个叫 `comments`（路由参数名的复数）的关联方法，通过这个方法可以检索到 `Comment` 模型。\r\n\r\n<a name=\"restful-localizing-resource-uris\"></a>\r\n### 本地化资源 URIs\r\n\r\n默认情况下，`Route::resource` 将会用英文动词创建资源 URIs。如果需要自定义 `create` 和 `edit` 行为的动名词，你可以在 `App\\Providers\\RouteServiceProvider` 的 `boot` 方法中使用 `Route::resourceVerbs` 方法实现：\r\n\r\n    /**\r\n     * 定义你的路由模型绑定，模式过滤器等\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Route::resourceVerbs([\r\n            'create' => 'crear',\r\n            'edit' => 'editar',\r\n        ]);\r\n\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n一旦这些动词被定义，资源路由注册，例如`route::resource('fotos', PhotoController::class)`将产生以下URI：\r\n\r\n    /fotos/crear\r\n\r\n    /fotos/{foto}/editar\r\n\r\n<a name=\"restful-supplementing-resource-controllers\"></a>\r\n### 补充资源控制器\r\n\r\n如果您需要向资源控制器添加超出默认资源路由集的其他路由，则应在调用 `Route::resource` 方法之前定义这些路由；否则，由 `resource` 方法定义的路由可能会无意中优先于您的补充路由：\r\n\r\n    use App\\Http\\Controller\\PhotoController;\r\n\r\n    Route::get('/photos/popular', [PhotoController::class, 'popular']);\r\n    Route::resource('photos', PhotoController::class);\r\n\r\n> 技巧：请记住让您的控制器保持集中。如果您发现自己经常需要典型资源操作集之外的方法，请考虑将控制器拆分为两个更小的控制器。\r\n\r\n<a name=\"dependency-injection-and-controllers\"></a>\r\n## 依赖注入和控制器\r\n\r\n<a name=\"constructor-injection\"></a>\r\n#### 构造函数注入\r\n\r\nLaravel [服务容器](/docs/laravel/9.x/container) 用于解析所有 Laravel 控制器。因此，您可以在其构造函数中对控制器可能需要的任何依赖项进行类型提示。声明的依赖项将自动解析并注入到控制器实例中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Repositories\\UserRepository;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 用户存储库实例。\r\n         */\r\n        protected $users;\r\n\r\n        /**\r\n         * 创建一个新的控制器实例。\r\n         *\r\n         * @param  \\App\\Repositories\\UserRepository  $users\r\n         * @return void\r\n         */\r\n        public function __construct(UserRepository $users)\r\n        {\r\n            $this->users = $users;\r\n        }\r\n    }\r\n\r\n<a name=\"method-injection\"></a>\r\n#### 方法注入\r\n\r\n除了构造函数注入之外，您还可以类型提示依赖于控制器的方法。方法注入的一个常见用例是将 `Illuminate\\Http\\Request` 实例注入到控制器方法中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个新用户。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $name = $request->name;\r\n\r\n            //\r\n        }\r\n    }\r\n\r\n\r\n\r\n如果你的控制器方法要从路由参数中获取输入内容，请在你的依赖项之后列出你的路由参数。例如，你可以像下方这样定义路由：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    Route::put('/user/{id}', [UserController::class, 'update']);\r\n\r\n如下所示，您依然可以类型提示 `Illuminate\\Http\\Request` 并通过定义您的控制器方法访问 `id` 参数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 修改指定的用户。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  string  $id\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function update(Request $request, $id)\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n","p":"docs/controllers.html"},{"t":"requests (请求 请求)","d":"# 请求 请求\r\n\r\n- [简介](#introduction)\r\n- [与请求交互](#interacting-with-the-request)\r\n    - [访问请求](#accessing-the-request)\r\n    - [请求路径和方法](#request-path-and-method)\r\n    - [请求头](#request-headers)\r\n    - [请求 IP 地址](#request-ip-address)\r\n    - [内容协商](#content-negotiation)\r\n    - [PSR-7 请求](#psr7-requests)\r\n- [接收数据](#input)\r\n    - [检索数据](#retrieving-input)\r\n    - [确定是否存在数据](#determining-if-input-is-present)\r\n    - [合并新增数据](#merging-additional-input)\r\n    - [旧数据](#old-input)\r\n    - [Cookies](#cookies)\r\n    - [输入整理和规范化](#nput-trimming-and-normalization)\r\n- [文件](#files)\r\n    - [检索上传的文件](#retrieving-uploaded-files)\r\n    - [存储上传的文件](#storing-uploaded-files)\r\n- [配置受信任的代理](#configuring-trusted-proxies)\r\n- [配置受信任的主机](#configuring-trusted-hosts)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 的 `Illuminate\\Http\\Request`  类提供了一种面向对象的方法,可以与应用程序处理的当前 HTTP 请求进行交互, 以及检索与请求一起提交的输入内容，cookies 和文件。\r\n\r\n<a name=\"interacting-with-the-request\"></a>\r\n## 与请求交互\r\n\r\n<a name=\"accessing-the-request\"></a>\r\n### 访问请求\r\n\r\n要通过依赖注入获得当前 HTTP 请求的实例，您应该在路由闭包或控制器方法上导入 `Illuminate\\Http\\Request` 类。 传入的请求实例将由 Laravel [服务容器](/docs/laravel/9.x/container) 自动注入：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个新用户.\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $name = $request->input('name');\r\n\r\n            //\r\n        }\r\n    }\r\n\r\n如上所述，你也可以在路由闭包上导入`Illuminate\\Http\\Request` 类。服务容器在执行时将自动传入请求注入到闭包中：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/', function (Request $request) {\r\n        //\r\n    });\r\n\r\n\r\n\r\n<a name=\"dependency-injection-route-parameters\"></a>\r\n#### 依赖注入和路由参数\r\n\r\n如果控制器方法也需要路由的参数传入，则应在其引入的依赖后面列出路由参数。您的路由应该定义如下：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    Route::put('/user/{id}', [UserController::class, 'update']);\r\n\r\n您应该注入 `Illuminate\\Http\\Request`, 并通过如下定义控制器方法，来访问 `id` 路由参数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 更新指定用户\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  string  $id\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function update(Request $request, $id)\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n<a name=\"request-path-and-method\"></a>\r\n### 请求路径和方法\r\n\r\n`Illuminate\\Http\\Request` 实例提供了多种方法来检查传入的 Http 请求，并扩展了 `Symfony\\Component\\HttpFoundation\\Request` 类。下面我们将讨论几个最重要的方法。\r\n\r\n<a name=\"retrieving-the-request-path\"></a>\r\n#### 检索请求路径\r\n\r\n`path` 方法返回请求的路径信息。因此，如果传入请求的目标是 `http://example.com/foo/bar`，则 `path` 方法将返回 `foo/bar`：\r\n\r\n    $uri = $request->path();\r\n\r\n<a name=\"inspecting-the-request-path\"></a>\r\n#### 检查请求路径 / 路由\r\n\r\n`is` 方法允许您验证传入的请求路径是否与给定的模式匹配。使用此方法时，可以使用 `*` 字符作为通配符：\r\n\r\n    if ($request->is('admin/*')) {\r\n        //\r\n    }\r\n\r\n使用 `routeIs` 方法，可以确定传入请求是否与[命名路由](/docs/laravel/9.x/routing#named-routes)匹配：\r\n\r\n    if ($request->routeIs('admin.*')) {\r\n        //\r\n    }\r\n\r\n\r\n\r\n<a name=\"retrieving-the-request-url\"></a>\r\n#### 检索请求 URL\r\n\r\n要检索传入请求的完整 URL，你可以使用 `url` 或 `fullUrl` 方法。`url` 方法将返回不包含查询字符串的 URL，而 `fullUrl` 方法包含查询字符串：\r\n\r\n    $url = $request->url();\r\n\r\n    $urlWithQueryString = $request->fullUrl();\r\n\r\n如果要将查询字符串数据附加到当前URL，可以调用 `fullUrlWithQuery` 方法。此方法将给定的查询字符串变量数组与当前查询字符串合并：\r\n\r\n    $request->fullUrlWithQuery(['type' => 'phone']);\r\n\r\n<a name=\"retrieving-the-request-method\"></a>\r\n#### 检索请求方法\r\n\r\n`method` 方法将返回请求的 HTTP 动词。你可以使用 `isMethod` 方法来验证 HTTP 动词是否匹配给定的字符串：\r\n\r\n    $method = $request->method();\r\n\r\n    if ($request->isMethod('post')) {\r\n        //\r\n    }\r\n\r\n<a name=\"request-headers\"></a>\r\n### 请求头\r\n\r\n你可以使用 `header` 方法从 `Illuminate\\Http\\Request` 实例中检索一个请求头。如果请求中不存在该头，将返回 `null`。然而，`header` 方法接受一个可选的第二个参数，如果请求中不存在该头，将返回该参数：\r\n\r\n    $value = $request->header('X-Header-Name');\r\n\r\n    $value = $request->header('X-Header-Name', 'default');\r\n\r\n`hasHeader` 方法可用来确定请求是否包含一个给定的头：\r\n\r\n    if ($request->hasHeader('X-Header-Name')) {\r\n        //\r\n    }\r\n\r\n为了方便起见，`bearerToken` 方法可用来从 `Authorization` 头中检索一个 bearer 令牌。如果这样的头不存在，将返回一个空字符串：\r\n\r\n    $token = $request->bearerToken();\r\n\r\n<a name=\"request-ip-address\"></a>\r\n\r\n\r\n### 请求 IP 地址\r\n\r\n`ip` 方法可用来检索向你的应用程序发出请求的客户机的 `IP` 地址：\r\n\r\n    $ipAddress = $request->ip();\r\n\r\n<a name=\"content-negotiation\"></a>\r\n### 请求协商\r\n\r\n`Laravel` 提供一些通过 `Accept` 头检查传入请求的请求内容类型的方法。首先，`getAcceptableContentTypes` 方法将返回一个包含通过请求接受的所有内容类型的数组：\r\n\r\n    $contentTypes = $request->getAcceptableContentTypes();\r\n\r\n`accepts` 方法接受内容类型的数组，如果请求接受任何内容类型，则返回 `true`。否则，将返回 `false`：\r\n\r\n    if ($request->accepts(['text/html', 'application/json'])) {\r\n        // ...\r\n    }\r\n\r\n你可以使用 `prefers` 方法来确定给定内容类型数组中哪种内容类型最受请求青睐。如果请求不接受任何提供的内容类型，则将返回 `null`：\r\n\r\n    $preferred = $request->prefers(['text/html', 'application/json']);\r\n\r\n由于许多应用程序仅提供 `HTML` 或 `JSON`，因此你可以使用 `expectsJson` 方法来快速确定传入的请求是否需要 `JSON` 响应：\r\n\r\n    if ($request->expectsJson()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"psr7-requests\"></a>\r\n### PSR-7 Requests\r\n\r\n[PSR-7 标准](https://www.php-fig.org/psr/psr-7/) 指定 HTTP 消息的接口，包括请求和响应。如果要获取 PSR-7 请求的实例而不是 Laravel 请求，则首先需要安装一些库。Laravel 使用 *Symfony HTTP Message Bridge* 组件将典型的 Laravel 请求和响应转换为 PSR-7 兼容的实现：\r\n\r\n```shell\r\ncomposer require symfony/psr-http-message-bridge\r\ncomposer require nyholm/psr7\r\n```\r\n\r\n\r\n\r\n一旦安装了这些库，就可以通过在路由闭包或控制器方法上键入请求接口的类型来获取 PSR-7 请求：\r\n\r\n    use Psr\\Http\\Message\\ServerRequestInterface;\r\n\r\n    Route::get('/', function (ServerRequestInterface $request) {\r\n        //\r\n    });\r\n\r\n> 技巧：如果从路由或控制器返回 PSR-7 响应实例，它将自动转换回 Laravel 响应实例并由框架显示。\r\n\r\n<a name=\"input\"></a>\r\n## 输入\r\n\r\n<a name=\"retrieving-input\"></a>\r\n### 检索输入\r\n\r\n<a name=\"retrieving-all-input-data\"></a>\r\n#### 检索所有输入数据\r\n\r\n可以使用 `all` 方法以 `array` 的形式检索所有传入请求的输入数据。无论传入的请求是来自 HTML 表单还是 XHR 请求，都可以使用此方法。\r\n\r\n    $input = $request->all();\r\n\r\n使用 `collect` 方法，您可以将所有传入请求的输入数据检索为[collection](/docs/laravel/9.x/collections)：\r\n\r\n    $input = $request->collect();\r\n\r\n`collect` 方法还允许您以集合的形式检索传入请求输入的子集：\r\n\r\n    $request->collect('users')->each(function ($user) {\r\n        // ...\r\n    });\r\n\r\n<a name=\"retrieving-an-input-value\"></a>\r\n#### 检索一个输入值\r\n\r\n使用一些简单的方法，可以从 `Illuminate\\Http\\Request` 实例获取所有的用户输入数据，而不用在意用户使用的是哪种 HTTP 动词。不管是什么 HTTP 动词， `input` 方法都可以用来获取用户的输入数据：\r\n\r\n    $name = $request->input('name');\r\n\r\n可以将默认值作为第二个参数传递给 `input` 方法。如果请求中不存在第一个参数指定的字段的输入值，则将返回此值：\r\n\r\n    $name = $request->input('name', 'Sally');\r\n\r\n\r\n\r\n当使用包含数组输入的表单时，请使用「.」符号来访问数组：\r\n\r\n    $name = $request->input('products.0.name');\r\n\r\n    $names = $request->input('products.*.name');\r\n\r\n可以不带任何参数地调用 `input` 方法，以便将所有输入值作为关联数组进行检索：\r\n\r\n    $input = $request->input();\r\n\r\n<a name=\"retrieving-input-from-the-query-string\"></a>\r\n#### 从查询字符串中检索输入\r\n\r\n当 `input` 方法从整个请求有效负载（包括查询字符串）中检索值时，`query` 方法将仅从查询字符串中检索值：\r\n\r\n    $name = $request->query('name');\r\n\r\n如果请求的查询字符串的值不存在，则将返回此方法的第二个参数：\r\n\r\n    $name = $request->query('name', 'Helen');\r\n\r\n你可以不带任何参数地调用 `query` 方法，以将所有查询字符串值作为关联数组来检索：\r\n\r\n    $query = $request->query();\r\n\r\n<a name=\"retrieving-json-input-values\"></a>\r\n#### 检索 JSON 输入值\r\n\r\n向应用程序发送 JSON 请求时，只要将请求的 `Content-Type` 标头正确设置为 `application/json`，就可以通过 `input` 方法访问 JSON 数据。甚至可以使用 `.` 语法来检索嵌套在 JSON 数组中的值：\r\n\r\n    $name = $request->input('user.name');\r\n\r\n<a name=\"retrieving-boolean-input-values\"></a>\r\n#### 检索布尔输入值\r\n\r\n当处理诸如复选框之类的 HTML 元素时，你的应用程序可能会收到实际上是字符串的「true」值。例如，「true」或「on」。为了方便起见，你可以使用 boolean 方法将这些值作为布尔值检索。`boolean` 方法为 1，「1」，true，「true」，「on」和「yes」返回 `true`。所有其他值将返回 `false`：\r\n\r\n    $archived = $request->boolean('archived');\r\n\r\n\r\n\r\n<a name=\"retrieving-date-input-values\"></a>\r\n#### 检索日期输入值\r\n\r\n为方便起见，包含日期/时间的输入值可以使用 `date` 方法作为实例检索。如果请求不包含具有给定名称的输入值，则返回 `null`：\r\n\r\n    $birthday = $request->date('birthday');\r\n\r\n`date` 方法接受的第二个和第三个参数可分别用于指定日期的格式和时区：\r\n\r\n    $elapsed = $request->date('elapsed', '!H:i', 'Europe/Madrid');\r\n\r\n如果输入值存在，但格式无效，将抛出 `InvalidArgumentException`；因此，建议您在调用 `date` 方法之前验证输入。\r\n\r\n<a name=\"retrieving-input-via-dynamic-properties\"></a>\r\n#### 通过动态属性检索输入\r\n\r\n您还可以使用 `Illuminate\\Http\\Request` 实例上的动态属性访问用户输入。例如，如果你的应用程序形式之一包含一个 `name` 字段，则可以像下面这样访问该字段的值：\r\n\r\n    $name = $request->name;\r\n\r\n使用动态属性时，Laravel 将首先在请求有效负载中查找参数的值。如果不存在，Laravel 将在匹配的路线参数中搜索该字段。\r\n\r\n<a name=\"retrieving-a-portion-of-the-input-data\"></a>\r\n#### 检索输入数据的一部分\r\n\r\n如果需要检索输入数据的子集，则可以使用 `only` 和 `except` 方法。这两种方法都接受单个 `数组` 或动态参数列表：\r\n\r\n    $input = $request->only(['username', 'password']);\r\n\r\n    $input = $request->only('username', 'password');\r\n\r\n    $input = $request->except(['credit_card']);\r\n\r\n    $input = $request->except('credit_card');\r\n\r\n> 注意：`only` 方法返回你请求的所有键 / 值对；但是，它不会返回请求中不存在的键 / 值对。\r\n\r\n\r\n\r\n<a name=\"determining-if-input-is-present\"></a>\r\n### 判断输入值是否存在\r\n\r\n你可以使用 `has` 来判断当前请求中是否含有指定的值。如果请求中存在该值则 `has` 方法将会返回 `true`：\r\n\r\n    if ($request->has('name')) {\r\n        //\r\n    }\r\n\r\n当给定一个数组时，`has` 将会判断指定的值是否全部存在：\r\n\r\n    if ($request->has(['name', 'email'])) {\r\n        //\r\n    }\r\n\r\n如果请求中存在该值则 `whenHas` 方法将会执行指定的闭包：\r\n\r\n    $request->whenHas('name', function ($input) {\r\n        //\r\n    });\r\n\r\n第二个闭包可以传递给 `whenHas` 方法，如果请求中不存在指定的值，则将执行该方法：\r\n\r\n    $request->whenHas('name', function ($input) {\r\n        // \"name\" 值存在...\r\n    }, function () {\r\n        // \"name\" 值不存在...\r\n    });\r\n\r\n`hasAny` 方法将会在指定的值有一个存在的情况下返回 `true`：\r\n\r\n    if ($request->hasAny(['name', 'email'])) {\r\n        //\r\n    }\r\n\r\n如果你想要判断一个值在请求中是否存在，并且不为空，可以使用 `filled` 方法：\r\n\r\n    if ($request->filled('name')) {\r\n        //\r\n    }\r\n\r\n如果请求中存在该值且不为空则 `whenFilled` 方法将会执行指定的闭包：\r\n\r\n    $request->whenFilled('name', function ($input) {\r\n        //\r\n    });\r\n\r\n第二个闭包可以传递给 `WhenFilled` 方法，如果指定的值不存在或为空，则将执行该方法：\r\n\r\n    $request->whenFilled('name', function ($input) {\r\n        // \"name\" 存在且不为空...\r\n    }, function () {\r\n        // \"name\" 不存在或为空...\r\n    });\r\n\r\n如果你想要判断一个值在请求中是否缺失，可以使用 `missing` 方法：\r\n\r\n    if ($request->missing('name')) {\r\n        //\r\n    }\r\n\r\n\r\n\r\n<a name=\"merging-additional-input\"></a>\r\n### 合并附加输入\r\n\r\n有时您可能需要手动将其他输入合并到请求的现有输入数据中。为此，您可以使用 `merge` 方法：\r\n\r\n    $request->merge(['votes' => 0]);\r\n\r\n如果请求的输入数据中不存在相应的键，则可以使用 `mergeIfMissing` 方法将输入合并到请求中：\r\n\r\n    $request->mergeIfMissing(['votes' => 0]);\r\n\r\n<a name=\"old-input\"></a>\r\n### 旧数据\r\n\r\nLaravel 允许你在两次请求之间保持数据。这个特性在有效性校验出错后重新填充表单时非常有用。不过，如果你使用 Laravel 自带的 [表单验证](/docs/laravel/9.x/validation)，不需要自己手动调用这些方法，因为一些 Laravel 内置的验证功能会自动调用它们。\r\n\r\n<a name=\"flashing-input-to-the-session\"></a>\r\n#### 将输入数据闪存到 Session\r\n\r\n`Illuminate\\Http\\Request` 类的 `flash` 方法可以把当前的输入闪存到 [session](/docs/laravel/9.x/session)，因此在用户向应用发起的下一次请求时它们仍然可用：\r\n\r\n    $request->flash();\r\n\r\n你也可以使用 `flashOnly` 方法和 `flashExcept` 方法将请求数据的子集传送给 Session。这些方法在将密码之类的敏感数据排除在 Session 外的情况下非常有用：\r\n\r\n    $request->flashOnly(['username', 'email']);\r\n\r\n    $request->flashExcept('password');\r\n\r\n<a name=\"flashing-input-then-redirecting\"></a>\r\n#### 闪存数据并跳转\r\n\r\n如果你需要经常保存输入到 Session 然后重定向到之前的页面，可以通过在跳转函数后链式调用 `withInput` 方法轻易地实现：\r\n\r\n    return redirect('form')->withInput();\r\n\r\n    return redirect()->route('user.create')->withInput();\r\n\r\n    return redirect('form')->withInput(\r\n        $request->except('password')\r\n    );\r\n\r\n\r\n\r\n<a name=\"retrieving-old-input\"></a>\r\n#### 获取旧数据\r\n\r\n若要获取上一次请求所保存的旧数据，可以使用 `Illuminate\\Http\\Request` 实例的 `old` 方法。`old` 方法会从 [Session](/docs/laravel/9.x/session) 取出之前被闪存的输入数据：\r\n\r\n    $username = $request->old('username');\r\n\r\nLaravel 也提供了全局辅助函数 `old`。如果你要在 [Blade 模板](/docs/laravel/9.x/blade) 中显示旧的输入，使用 `old` 辅助函数将会更加方便。如果给定字段没有旧的输入，则会返回 `null`：\r\n\r\n    <input type=\"text\" name=\"username\" value=\"{{ old('username') }}\">\r\n\r\n<a name=\"cookies\"></a>\r\n### Cookies\r\n\r\n<a name=\"retrieving-cookies-from-requests\"></a>\r\n#### 从请求中获取 Cookie\r\n\r\nLaravel 框架创建的所有 `cookie` 均已加密并使用身份验证代码签名，这意味着如果客户端更改了它们，它们将被视为无效。若要从请求中检索 `cookie` 值，请在 `Illuminate\\Http\\Request` 实例上使用 `cookie` 方法：\r\n\r\n    $value = $request->cookie('name');\r\n\r\n<a name=\"input-trimming-and-normalization\"></a>\r\n## 输入过滤 & 规范化\r\n\r\n默认情况下，Laravel 在应用程序的全局中间件堆栈中包含 `App\\Http\\Middleware\\TrimStrings` 和 `App\\Http\\Middleware\\ConvertEmptyStringsToNull` 中间件。 这些中间件在 `App\\Http\\Kernel` 类的全局中间件堆栈中列出。 这些中间件将自动修剪请求中的所有传入字符串字段，并将所有空字符串字段转换为 `null`。 这使您不必担心路由和控制器中的这些规范化问题。\r\n\r\n如果您想禁用此行为，则可以通过从 `App\\Http\\Kernel` 类的 `$middleware` 属性中删除这两个中间件，将它们从应用程序的中间件堆栈中删除。\r\n\r\n\r\n\r\n<a name=\"files\"></a>\r\n## 文件\r\n\r\n<a name=\"retrieving-uploaded-files\"></a>\r\n### 获取上传的文件\r\n\r\n您可以使用 `file` 方法或使用动态属性从 `Illuminate\\Http\\Request` 实例中访问上传的文件。 该 `file` 方法返回 `Illuminate\\Http\\UploadedFile` 的实例，该类继承了 PHP 的 `SplFileInfo` 类的同时也提供了各种与文件交互的方法：\r\n\r\n    $file = $request->file('photo');\r\n\r\n    $file = $request->photo;\r\n\r\n当然你也可以使用 `hasFile` 确认请求中是否存在文件：\r\n\r\n    if ($request->hasFile('photo')) {\r\n        //\r\n    }\r\n\r\n<a name=\"validating-successful-uploads\"></a>\r\n#### 验证成功上传\r\n\r\n除了检查上传的文件是否存在外，你也可以通过 `isValid` 方法验证上传的文件是否有效：\r\n\r\n    if ($request->file('photo')->isValid()) {\r\n        //\r\n    }\r\n\r\n<a name=\"file-paths-extensions\"></a>\r\n#### 文件路径和扩展名\r\n\r\n`UploadedFile` 类还包含用于访问文件的全限定路径及其扩展名的方法。 `extension` 方法会根据文件内容判断文件的扩展名。该扩展名可能会和客户端提供的扩展名不同：\r\n\r\n    $path = $request->photo->path();\r\n\r\n    $extension = $request->photo->extension();\r\n\r\n<a name=\"other-file-methods\"></a>\r\n#### 其他文件方法\r\n\r\n`UploadedFile` 实例上还有许多可用的方法。可以查看该类的 [API 文档](https://github.com/symfony/symfony/blob/6.0/src/Symfony/Component/HttpFoundation/File/UploadedFile.php) 了解这些方法的详细信息。\r\n\r\n<a name=\"storing-uploaded-files\"></a>\r\n### 存储上传的文件\r\n\r\n要存储上传的文件，通常会使用已配置的 [文件系统](/docs/laravel/9.x/filesystem)。你可以使用 `UploadedFile` 的 `store` 方法把上传文件移动到你的某个磁盘上，该文件可能是本地文件系统中的一个位置，甚至像 Amazon S3 这样的云存储位置。\r\n\r\n\r\n\r\n`store` 方法接受相对于文件系统配置的根目录应存储文件的路径。 该路径不能包含文件名，因为将自动生成一个唯一的 ID 作为文件名。\r\n\r\n`store` 方法还接受一个可选的第二个参数作为应用于存储文件的磁盘的名称。 该方法将返回文件相对于磁盘根目录的路径：\r\n\r\n    $path = $request->photo->store('images');\r\n\r\n    $path = $request->photo->store('images', 's3');\r\n\r\n如果您不希望自动生成文件名，则可以使用 `storeAs` 方法，它接受路径、文件名和磁盘名作为其参数：\r\n\r\n    $path = $request->photo->storeAs('images', 'filename.jpg');\r\n\r\n    $path = $request->photo->storeAs('images', 'filename.jpg', 's3');\r\n\r\n> 技巧：有关 Laravel 中文件存储的更多信息，请查看完整的 [文件存储文档](/docs/laravel/9.x/filesystem)。\r\n\r\n<a name=\"configuring-trusted-proxies\"></a>\r\n## 配置受信任的代理\r\n\r\n在终止 TLS / SSL 证书的负载平衡器后面运行应用程序时，您可能会注意到，使用 `url` 帮助程序时，应用程序有时不会生成 HTTPS 链接。通常，这是因为正在从端口 `80` 上的负载平衡器转发应用程序的流量，并且不知道它应该生成安全链接。\r\n\r\n为了解决这个问题，您可以使用 Laravel 应用程序中包含的 `App\\Http\\Middleware\\TrustProxies` 中间件，该中间件可让您快速自定义应用程序应信任的负载均衡器或代理。您的受信任代理应该在此中间件的 `$proxies` 属性上以数组形式列出。 除了配置受信任的代理外，您还可以配置应受信任的代理 `$headers` ：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Illuminate\\Http\\Middleware\\TrustProxies as Middleware;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class TrustProxies extends Middleware\r\n    {\r\n        /**\r\n         * 此应用程序的受信任代理。\r\n         *\r\n         * @var string|array\r\n         */\r\n        protected $proxies = [\r\n            '192.168.1.1',\r\n            '192.168.1.2',\r\n        ];\r\n\r\n        /**\r\n         * 应用于检测代理的标头。\r\n         *\r\n         * @var int\r\n         */\r\n        protected $headers = Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_HOST | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO;\r\n    }\r\n\r\n> 技巧：技巧：如果你使用 AWS 弹性负载平衡，你的 `$headers` 值应该是 `Request::HEADER_X_FORWARDED_AWS_ELB`。如果您想查看更多可用于 `$headers` 的属性信息，请查阅 Symfony 的文档 [信任代理](https://symfony.com/doc/current/deployment/proxies.html)。\r\n\r\n\r\n<a name=\"trusting-all-proxies\"></a>\r\n#### 信任所有代理\r\n\r\n如果你正在使用 Amazon AWS 或者其它「云」的负载均衡服务，当你不知道负载均衡的实际 IP 地址时，你可以使用 `*` 来信任所有代理：\r\n\r\n    /**\r\n     * 当前应用的可信代理\r\n     *\r\n     * @var string|array\r\n     */\r\n    protected $proxies = '*';\r\n\r\n<a name=\"configuring-trusted-hosts\"></a>\r\n## 配置受信任的 Host\r\n\r\n默认情况下，Laravel 将响应它收到的所有请求，而不管 HTTP 请求的 `Host` 头的内容如何。此外，在 web 请求期间生成应用程序的绝对 URL 时，将使用 `Host` 头的值。\r\n\r\n通常，您应该将 web 服务器（如 Nginx 或 Apache）配置为只向应用程序发送与给定主机名匹配的请求。但是，如果您无法直接自定义 web 服务器，并且需要指示 Laravel 仅响应某些主机名，则可以通过为应用程序启用`App\\Http\\Middleware\\TrustHosts` 中间件来实现。\r\n\r\n`TrustHosts` 中间件已包含在应用程序的 `$middleware` 堆栈中；但是，您应该取消注释以使其变为活动状态。在此中间件的 `hosts` 方法中，您可以指定应用程序应响应的主机名。带有其他 `Host` 值标头的传入请求将被拒绝：\r\n\r\n    /**\r\n     * 获取应该信任的主机模式。\r\n     *\r\n     * @return array\r\n     */\r\n    public function hosts()\r\n    {\r\n        return [\r\n            'laravel.test',\r\n            $this->allSubdomainsOfApplicationUrl(),\r\n        ];\r\n    }\r\n\r\n`allSubdomainsOfApplicationUrl` 辅助方法将返回一个正则表达式，匹配应用程序的 `app.url` 配置值的所有子域。在构建使用通配符子域的应用程序时，此帮助方法提供了一种方便的方法来允许应用程序的所有子域。\r\n\r\n\r\n\r\n","p":"docs/requests.html"},{"t":"responses (响应)","d":"# 响应\r\n\r\n- [创建响应](#creating-responses)\r\n\t- [响应字符串或数组](#strings-arrays)\r\n\t- [响应 Response 对象](#response-objects)\r\n    - [添加响应头](#attaching-headers-to-responses)\r\n    - [添加响应 Cookies](#attaching-cookies-to-responses)\r\n    - [Cookies & 加密](#cookies-and-encryption)\r\n- [重定向](#redirects)\r\n    - [重定向到命名路由](#redirecting-named-routes)\r\n    - [重定向到控制器方法](#redirecting-controller-actions)\r\n    - [重定向到外部域名](#redirecting-external-domains)\r\n    - [重定向并使用闪存的 Session 数据](#redirecting-with-flashed-session-data)\r\n- [其它响应类型](#other-response-types)\r\n    - [视图响应](#view-responses)\r\n    - [JSON 响应](#json-responses)\r\n    - [文件下载](#file-downloads)\r\n    - [文件响应](#file-responses)\r\n- [响应宏](#response-macros)\r\n\r\n<a name=\"creating-responses\"></a>\r\n## 创建响应\r\n\r\n<a name=\"strings-arrays\"></a>\r\n#### 字符串 & 数组\r\n\r\n所有路由和控制器处理完业务逻辑之后都会返回响应到用户的浏览器，Laravel 提供了多种不同的响应方式，其中最基本就是从路由或控制器返回一个简单的字符串，框架会自动将这个字符串转化为一个完整的 HTTP 响应：\r\n\r\n    Route::get('/', function () {\r\n        return 'Hello World';\r\n    });\r\n\r\n除了从路由和控制器返回字符串之外，您还可以返回数组。 框架会自动将数组转换为 JSON 响应：\r\n\r\n    Route::get('/', function () {\r\n        return [1, 2, 3];\r\n    });\r\n\r\n> 技巧：你知道从路由或控制器还可以返回 [Eloquent 集合](/docs/laravel/9.x/eloquent-collections) 么？他们也会自动转化为 JSON 响应！\r\n\r\n<a name=\"response-objects\"></a>\r\n#### Response 对象\r\n\r\n通常情况下会只返回简单的字符串或数组，大多数时候，需要返回一个完整的 `Illuminate\\Http\\Response` 实例或是 [视图](/docs/laravel/9.x/views)。\r\n\r\n返回一个完整的 `Response` 实例允许你自定义返回的 HTTP 状态码和返回头信息。`Response` 实例继承自 `Symfony\\Component\\HttpFoundation\\Response` 类，该类提供了各种构建 HTTP 响应的方法：\r\n\r\n    Route::get('/home', function () {\r\n        return response('Hello World', 200)\r\n                      ->header('Content-Type', 'text/plain');\r\n    });\r\n\r\n\r\n\r\n<a name=\"eloquent-models-and-collections\"></a>\r\n#### Eloquent 模型 和 集合\r\n\r\n你也可以直接从你的路由和控制器返回 [Eloquent ORM](/docs/laravel/9.x/eloquent) 模型和集合。当你这样做时，Laravel 将自动将模型和集合转换为 JSON 响应，同时遵循模型的 [隐藏属性](/docs/laravel/9.x/eloquent-serialization#hiding-attributes-from-json)：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{user}', function (User $user) {\r\n        return $user;\r\n    });\r\n\r\n<a name=\"attaching-headers-to-responses\"></a>\r\n### 在响应中附加 header 信息\r\n\r\n请记住，大多数响应方法都是可以链式调用的，它允许你流畅地构建响应实例。例如，在将响应发送回用户之前，可以使用 `header` 方法将一系列头添加到响应中：\r\n\r\n    return response($content)\r\n                ->header('Content-Type', $type)\r\n                ->header('X-Header-One', 'Header Value')\r\n                ->header('X-Header-Two', 'Header Value');\r\n\r\n或者，你可以使用 `withHeaders` 方法指定要添加到响应的标头数组：\r\n\r\n    return response($content)\r\n                ->withHeaders([\r\n                    'Content-Type' => $type,\r\n                    'X-Header-One' => 'Header Value',\r\n                    'X-Header-Two' => 'Header Value',\r\n                ]);\r\n\r\n<a name=\"cache-control-middleware\"></a>\r\n#### 缓存控制中间件\r\n\r\nLaravel 包含一个 `cache.headers` 中间件，可用于快速设置一组路由的 `Cache-Control` 标头。指令应使用相应缓存控制指令的 `蛇形命名法` 等效项提供，并应以分号分隔。如果在指令列表中指定了 `etag`，则响应内容的 MD5 哈希将自动设置为 ETag 标识符：\r\n\r\n    Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {\r\n        Route::get('/privacy', function () {\r\n            // ...\r\n        });\r\n\r\n        Route::get('/terms', function () {\r\n            // ...\r\n        });\r\n    });\r\n\r\n\r\n\r\n<a name=\"attaching-cookies-to-responses\"></a>\r\n### 在响应中附加 Cookie 信息\r\n\r\n可以使用 `cookie` 方法将 cookie 附加到传出的 `illumize\\Http\\Response` 实例。你应将 cookie 的名称、值和有效分钟数传递给此方法：\r\n\r\n    return response('Hello World')->cookie(\r\n        'name', 'value', $minutes\r\n    );\r\n\r\n`cookie` 方法还接受一些使用频率较低的参数。通常，这些参数的目的和意义与 PHP 的原生 [setcookie](https://secure.php.net/manual/en/function.setcookie.php) 的参数相同\r\n\r\n    return response('Hello World')->cookie(\r\n        'name', 'value', $minutes, $path, $domain, $secure, $httpOnly\r\n    );\r\n\r\n如果你希望确保 cookie 与传出响应一起发送，但您还没有该响应的实例，则可以使用 `Cookie` facade 将 cookie 加入队列，以便在发送响应时附加到响应中。 `queue` 方法接受创建 cookie 实例所需的参数。在发送到浏览器之前，这些 cookies 将附加到传出的响应中：\r\n\r\n    use Illuminate\\Support\\Facades\\Cookie;\r\n\r\n    Cookie::queue('name', 'value', $minutes);\r\n\r\n<a name=\"generating-cookie-instances\"></a>\r\n#### 生成 Cookie 实例\r\n\r\n如果要生成一个 `Symfony\\Component\\HttpFoundation\\Cookie` 实例，打算稍后附加到响应实例中，你可以使用全局 `cookie` 助手函数。此 cookie 将不会发送回客户端，除非它被附加到响应实例中：\r\n\r\n    $cookie = cookie('name', 'value', $minutes);\r\n\r\n    return response('Hello World')->cookie($cookie);\r\n\r\n\r\n\r\n<a name=\"expiring-cookies-early\"></a>\r\n#### 提前过期 Cookies\r\n\r\n你可以通过响应中的 `withoutCookie` 方法使 cookie 过期，用于删除 cookie ：\r\n\r\n    return response('Hello World')->withoutCookie('name');\r\n\r\n如果尚未有创建响应的实例，则可以使用 `Cookie` facade 中的 `expire`  方法使 Cookie 过期：\r\n\r\n    Cookie::expire('name');\r\n\r\n<a name=\"cookies-and-encryption\"></a>\r\n### Cookies 和 加密\r\n\r\n默认情况下，由 Laravel 生成的所有 cookie 都经过了加密和签名，因此客户端无法篡改或读取它们。如果要对应用程序生成的部分 cookie 禁用加密，可以使用`App\\Http\\Middleware\\EncryptCookies` 中间件的`$except`属性，该属性位于 `app/Http/Middleware` 目录中：\r\n\r\n    /**\r\n     * 这个名字的 Cookie 将不会加密\r\n     *\r\n     * @var array\r\n     */\r\n    protected $except = [\r\n        'cookie_name',\r\n    ];\r\n\r\n<a name=\"redirects\"></a>\r\n## 重定向\r\n\r\n重定向响应是`Illuminate\\Http\\RedirectResponse` 类的实例，包含将用户重定向到另一个 URL 所需的适当 HTTP 头。Laravel 有几种方法可以生成 `RedirectResponse`实例。最简单的方法是使用全局 `redirect` 助手函数：\r\n\r\n    Route::get('/dashboard', function () {\r\n        return redirect('home/dashboard');\r\n    });\r\n\r\n有时你可能希望将用户重定向到以前的位置，例如当提交的表单无效时。你可以使用全局 `back` 助手函数来执行此操作。由于此功能使用 [session](/docs/laravel/9.x/session)，请确保调用 `back` 函数的路由使用的是 `web` 中间件组：\r\n\r\n    Route::post('/user/profile', function () {\r\n        // 验证请求参数\r\n\r\n        return back()->withInput();\r\n    });\r\n\r\n\r\n\r\n<a name=\"redirecting-named-routes\"></a>\r\n### 重定向到指定名称的路由\r\n\r\n当你在没有传递参数的情况下调用 `redirect` 助手函数时，将返回 `Illuminate\\Routing\\Redirector` 的实例，允许你调用 `Redirector` 实例上的任何方法。例如，要对命名路由生成  `RedirectResponse` ，可以使用 `route` 方法：\r\n\r\n    return redirect()->route('login');\r\n\r\n如果路由中有参数，可以将其作为第二个参数传递给 `route` 方法：\r\n\r\n    // 对于具有以下URI的路由: /profile/{id}\r\n\r\n    return redirect()->route('profile', ['id' => 1]);\r\n\r\n<a name=\"populating-parameters-via-eloquent-models\"></a>\r\n#### 通过 Eloquent 模型填充参数\r\n\r\n如果你要重定向到使用从 Eloquent 模型填充 「ID」 参数的路由，可以直接传递模型本身。ID 将会被自动提取：\r\n\r\n    // 对于具有以下URI的路由: /profile/{id}\r\n\r\n    return redirect()->route('profile', [$user]);\r\n\r\n如果你想要自定义路由参数，你可以指定路由参数 (`/profile/{id:slug}`) 或者重写 Eloquent 模型上的  `getRouteKey` 方法：\r\n\r\n    /**\r\n     * 获取模型的路由键值\r\n     *\r\n     * @return mixed\r\n     */\r\n    public function getRouteKey()\r\n    {\r\n        return $this->slug;\r\n    }\r\n\r\n<a name=\"redirecting-controller-actions\"></a>\r\n### 重定向到控制器行为\r\n\r\n也可以生成重定向到 [controller actions](/docs/laravel/9.x/controllers)。只要把控制器和 action 的名称传递给`action` 方法：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    return redirect()->action([UserController::class, 'index']);\r\n\r\n如果控制器路由有参数，可以将其作为第二个参数传递给 `action` 方法：\r\n\r\n    return redirect()->action(\r\n        [UserController::class, 'profile'], ['id' => 1]\r\n    );\r\n\r\n\r\n\r\n<a name=\"redirecting-external-domains\"></a>\r\n### 重定向到外部域名\r\n\r\n有时候你需要重定向到应用外的域名。可以通过调用 away 方法，它会创建一个不带有任何额外的 URL 编码、有效性校验和检查 `RedirectResponse` 实例：\r\n\r\n    return redirect()->away('https://www.google.com');\r\n\r\n<a name=\"redirecting-with-flashed-session-data\"></a>\r\n### 重定向并使用闪存的 Session 数据\r\n\r\n重定向到新的 URL 的同时 [传送数据给 seesion ](/docs/laravel/9.x/session#flash-data)是很常见的。 通常这是在你将消息发送到 session 后成功执行操作后完成的。为了方便，你可以创建一个 `RedirectResponse` 实例并在链式方法调用中将数据传送给 session：\r\n\r\n    Route::post('/user/profile', function () {\r\n        // ...\r\n\r\n        return redirect('dashboard')->with('status', 'Profile updated!');\r\n    });\r\n\r\n在用户重定向后，你可以显示 [session](/docs/laravel/9.x/session)。例如，你可以使用 [Blade 模板语法](/docs/laravel/9.x/blade)：\r\n\r\n    @if (session('status'))\r\n        <div class=\"alert alert-success\">\r\n            {{ session('status') }}\r\n        </div>\r\n    @endif\r\n\r\n<a name=\"redirecting-with-input\"></a>\r\n#### 使用输入重定向\r\n\r\n你可以使用 `RedirectResponse` 实例提供的 `withInput` 方法将当前请求输入的数据发送到 session ，然后再将用户重定向到新位置。当用户遇到验证错误时，通常会执行此操作。每当输入数据被发送到 session , 你可以很简单的在下一次重新提交的表单请求中 [取回它](/docs/laravel/9.x/requests#retrieving-old-input)：\r\n\r\n    return back()->withInput();\r\n\r\n<a name=\"other-response-types\"></a>\r\n\r\n\r\n## 其他响应类型\r\n\r\n`response` 助手可用于生成其他类型的响应实例。当不带参数调用 `response` 助手时，会返回 `Illuminate\\Contracts\\Routing\\ResponseFactory` [contract](/docs/laravel/9.x/contracts) 的实现。 该契约提供了几种有用的方法来生成响应。\r\n\r\n<a name=\"view-responses\"></a>\r\n### 响应视图\r\n\r\n如果您需要控制响应的状态和标头，但还需要返回 [view](/docs/laravel/9.x/views) 作为响应的内容，您应该使用 `view` 方法：\r\n\r\n    return response()\r\n                ->view('hello', $data, 200)\r\n                ->header('Content-Type', $type);\r\n\r\n当然，如果您不需要传递自定义 HTTP 状态代码或自定义标头，则可以使用全局 `view` 辅助函数。\r\n\r\n<a name=\"json-responses\"></a>\r\n### JSON Responses\r\n\r\n`json` 方法会自动将 `Content-Type` 标头设置为 `application/json`，并使用 `json_encode` PHP 函数将给定的数组转换为 JSON：\r\n\r\n    return response()->json([\r\n        'name' => 'Abigail',\r\n        'state' => 'CA',\r\n    ]);\r\n\r\n如果你想创建一个 JSONP 响应，你可以结合使用 `json` 方法和 `withCallback` 方法：\r\n\r\n    return response()\r\n                ->json(['name' => 'Abigail', 'state' => 'CA'])\r\n                ->withCallback($request->input('callback'));\r\n\r\n<a name=\"file-downloads\"></a>\r\n### 文件下载\r\n\r\n`download` 方法可用于生成强制用户浏览器在给定路径下载文件的响应。 `download` 方法接受文件名作为该方法的第二个参数，这将确定下载文件的用户看到的文件名。 最后，您可以将一组 HTTP 标头作为该方法的第三个参数传递：\r\n\r\n    return response()->download($pathToFile);\r\n\r\n    return response()->download($pathToFile, $name, $headers);\r\n\r\n> 注意：管理文件下载的 Symfony HttpFoundation 要求正在下载的文件具有 ASCII 文件名。\r\n\r\n\r\n\r\n<a name=\"streamed-downloads\"></a>\r\n#### 流式下载\r\n\r\n有时您可能希望将给定操作的字符串响应转换为可下载的响应，而不必将操作的内容写入磁盘。在这种情况下，您可以使用 `streamDownload` 方法。此方法接受回调、文件名和可选的标头数组作为其参数：\r\n\r\n    use App\\Services\\GitHub;\r\n\r\n    return response()->streamDownload(function () {\r\n        echo GitHub::api('repo')\r\n                    ->contents()\r\n                    ->readme('laravel', 'laravel')['contents'];\r\n    }, 'laravel-readme.md');\r\n\r\n<a name=\"file-responses\"></a>\r\n### 文件响应\r\n\r\n`file` 方法可用于直接在用户的浏览器中显示文件，例如图像或 PDF，而不是启动下载。这个方法接受文件的路径作为它的第一个参数和一个头数组作为它的第二个参数：\r\n\r\n    return response()->file($pathToFile);\r\n\r\n    return response()->file($pathToFile, $headers);\r\n\r\n<a name=\"response-macros\"></a>\r\n## Macro 响应\r\n\r\n如果你想定义一个可以在各种路由和控制器中重复使用的自定义响应，你可以使用 `Response Facade` 上的 `macro` 方法。通常，您应该从应用程序的 [服务提供者](/docs/laravel/9.x/providers) 之一的 `boot` 方法调用此方法，例如 `App\\Providers\\AppServiceProvider` 服务提供者：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Response;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * Bootstrap any application services.\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Response::macro('caps', function ($value) {\r\n                return Response::make(strtoupper($value));\r\n            });\r\n        }\r\n    }\r\n\r\n`macro` 函数接受一个名字作为它的第一个参数和一个闭包作为它的第二个参数。当从 `ResponseFactory` 实现或 `response` 助手调用宏名称时，将执行宏的闭包：\r\n\r\n    return response()->caps('foo');\r\n\r\n","p":"docs/responses.html"},{"t":"views (视图)","d":"# 视图\r\n\r\n- [介绍](#introduction)\r\n- [创建和渲染视图](#creating-and-rendering-views)\r\n    - [嵌套视图目录](#nested-view-directories)\r\n    - [创建第一个可用视图](#creating-the-first-available-view)\r\n    - [确定视图是否存在](#determining-if-a-view-exists)\r\n- [向视图传递数据](#passing-data-to-views)\r\n    - [与所有视图分享数据](#sharing-data-with-all-views)\r\n- [视图组件](#view-composers)\r\n    - [视图构造器](#view-creators)\r\n- [视图优化](#optimizing-views)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n当然，直接从路由和控制器返回整个 HTML 文档字符串是不切实际的。值得庆幸的是，视图提供了一种方便的方式来将我们所有的 HTML 放在单独的文件中。视图将您的控制器/应用程序逻辑与您的表示逻辑分开并存储在 `resources/views` 目录中。一个简单的视图可能看起来像这样：\r\n\r\n```blade\r\n<!-- View stored in resources/views/greeting.blade.php -->\r\n\r\n<html>\r\n    <body>\r\n        <h1>Hello, {{ $name }}</h1>\r\n    </body>\r\n</html>\r\n```\r\n\r\n将上述代码存储到 `resources/views/greeting.blade.php` 后，我们可以使用全局辅助函数 `view` 将其返回，例如：\r\n\r\n    Route::get('/', function () {\r\n        return view('greeting', ['name' => 'James']);\r\n    });\r\n\r\n> 技巧：如果您想了解更多关于如何编写 Blade 模板的更多信息？查看完整的 [Blade 文档](/docs/laravel/9.x/blade) 将是最好的开始。\r\n\r\n<a name=\"creating-and-rendering-views\"></a>\r\n## 创建和渲染视图\r\n\r\n您可以通过在应用程序 `resources/views` 目录中放置具有 `.blade.php` 扩展名的文件来创建视图。 该 `.blade.php` 扩展通知框架该文件包含一个 [Blade 模板](/docs/laravel/9.x/blade)。Blade 模板包含 HTML 和 Blade 指令，允许您轻松地回显值、创建「if」语句、迭代数据等。\r\n\r\n\r\n\r\n创建视图后，可以使用全局 `view` 从应用程序的某个路由或控制器返回视图：\r\n\r\n    Route::get('/', function () {\r\n        return view('greeting', ['name' => 'James']);\r\n    });\r\n\r\n也可以使用 `View` 视图门面（Facade）：\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    return View::make('greeting', ['name' => 'James']);\r\n\r\n如您所见，传递给 `view` 的第一个参数对应于 `resources/views` 目录中视图文件的名称。第二个参数是应该对视图可用的数据数组。在这种情况下，我们传递 `name` 变量，它使用 [Blade 语法](/docs/laravel/9.x/blade)显示在视图中。\r\n\r\n<a name=\"nested-view-directories\"></a>\r\n### 嵌套视图目录\r\n\r\n视图也可以嵌套在目录 `resources/views` 的子目录中。「.」符号可用于引用嵌套视图。例如，如果您的视图存储在 `resources/views/admin/profile.blade.php`，您可以从应用程序的路由/控制器之一返回它，如下所示：\r\n\r\n    return view('admin.profile', $data);\r\n\r\n> 注意：查看目录名称不应包含该 `.` 字符。\r\n\r\n<a name=\"creating-the-first-available-view\"></a>\r\n### 创建第一个可用视图\r\n\r\n使用 `View` 门面的 `first` 方法，你可以创建给定数组视图中第一个存在的视图。如果你的应用程序或开发的第三方包允许定制或覆盖视图，这非常有用：\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    return View::first(['custom.admin', 'admin'], $data);\r\n\r\n<a name=\"determining-if-a-view-exists\"></a>\r\n### 判断视图文件是否存在\r\n\r\n如果需要判断视图文件是否存在，可以使用 `View` 门面。如果视图存在， `exists` 方法会返回 `true`：\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    if (View::exists('emails.customer')) {\r\n        //\r\n    }\r\n\r\n\r\n\r\n<a name=\"passing-data-to-views\"></a>\r\n## 向视图传递数据\r\n\r\n正如您在前面的示例中看到的，您可以将数据数组传递给视图，以使该数据可用于视图：\r\n\r\n    return view('greetings', ['name' => 'Victoria']);\r\n\r\n以这种方式传递信息时，数据应该是带有键/值对的数组。向视图提供数据后，您可以使用数据的键访问视图中的每个值，例如 `<?php echo $name; ?>`.\r\n\r\n作为将完整的数据数组传递给 `view` 辅助函数的替代方法，您可以使用该 `with` 方法将单个数据添加到视图中。该 `with` 方法返回视图对象的实例，以便您可以在返回视图之前继续链接方法：\r\n\r\n    return view('greeting')\r\n                ->with('name', 'Victoria')\r\n                ->with('occupation', 'Astronaut');\r\n\r\n<a name=\"sharing-data-with-all-views\"></a>\r\n### 与所有视图共享数据\r\n\r\n有时，您可能需要与应用程序呈现的所有视图共享数据。您可以使用 `View` 门面的 `share` 。你可以在服务提供器的 `boot` 方法中调用视图门面（Facade）的  `share` 。例如，可以将它们添加到 `App\\Providers\\AppServiceProvider` 或者为它们生成一个单独的服务提供器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册应用服务.\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 引导应用服务.\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            View::share('key', 'value');\r\n        }\r\n    }\r\n\r\n<a name=\"view-composers\"></a>\r\n## 视图合成器\r\n\r\n\r\n\r\n视图合成器是在渲染视图时调用的回调或类方法。如果您希望在每次呈现视图时将数据绑定到该视图，则视图编辑器可以帮助您将该逻辑组织到一个位置。如果应用程序中的多个路由或控制器返回相同的视图并且总是需要特定的数据，则视图合成器可能会特别有用。\r\n\r\n通常，视图合成器将在您的应用程序的 [服务提供者](/docs/laravel/9.x/providers)之中注册。在这个例子中，我们假设我们已经创建了一个新 `App\\Providers\\ViewServiceProvider` 的来构建这个逻辑。\r\n\r\n我们将使用 `View` 门面的 `composer` 方法来注册视图合成器。Laravel 不包含基于类的视图编写器的默认目录，因此您可以随意组织它们。例如，您可以创建一个 `app/View/Composers` 目录来存放应用程序的所有视图编写器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\View\\Composers\\ProfileComposer;\r\n    use Illuminate\\Support\\Facades\\View;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class ViewServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册应用服务.\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 引导应用服务.\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            // 使用基于类的生成器...\r\n            View::composer('profile', ProfileComposer::class);\r\n\r\n            // 使用基于闭包的生成器...\r\n            View::composer('dashboard', function ($view) {\r\n                //\r\n            });\r\n        }\r\n    }\r\n\r\n> 注意：记住，如果你创建了新的一个服务提供者来存放你注册视图合成器的代码，那么你需要将这个服务提供器添加到配置文件 `config/app.php` 的 `providers` 数组中。\r\n\r\n\r\n\r\n现在我们注册了视图合成器，每次渲染 `profile` 视图时都会执行`App\\View\\Composers\\ProfileComposer` 类的 `compose` 方法。我们来看一个视图合成器类的例子：\r\n\r\n    <?php\r\n\r\n    namespace App\\View\\Composers;\r\n\r\n    use App\\Repositories\\UserRepository;\r\n    use Illuminate\\View\\View;\r\n\r\n    class ProfileComposer\r\n    {\r\n        /**\r\n         * 用户库的实现.\r\n         *\r\n         * @var \\App\\Repositories\\UserRepository\r\n         */\r\n        protected $users;\r\n\r\n        /**\r\n         * 创建一个 profile 视图生成器.\r\n         *\r\n         * @param  \\App\\Repositories\\UserRepository  $users\r\n         * @return void\r\n         */\r\n        public function __construct(UserRepository $users)\r\n        {\r\n            // 依赖项由服务容器自动解析...\r\n            $this->users = $users;\r\n        }\r\n\r\n        /**\r\n         * 绑定视图数据.\r\n         *\r\n         * @param  \\Illuminate\\View\\View  $view\r\n         * @return void\r\n         */\r\n        public function compose(View $view)\r\n        {\r\n            $view->with('count', $this->users->count());\r\n        }\r\n    }\r\n\r\n如您所见，所有的视图合成器都会通过 [服务容器](/docs/laravel/9.x/container)进行解析，所以你可以在视图合成器的构造函数中类型提示需要注入的依赖项。\r\n\r\n<a name=\"attaching-a-composer-to-multiple-views\"></a>\r\n#### 将视图合成器添加到多个视图\r\n\r\n您可以通过将视图数组作为第一个参数传递给 `composer` 方法，可以一次添加多个视图到视图合成器中：\r\n    use App\\Views\\Composers\\MultiComposer;\r\n\r\n    View::composer(\r\n        ['profile', 'dashboard'],\r\n        MultiComposer::class\r\n    );\r\n\r\n该 `composer` 方法同时也接受通配符 `*` ，表示将所有视图添加到视图合成器中：\r\n\r\n    View::composer('*', function ($view) {\r\n        //\r\n    });\r\n\r\n<a name=\"view-creators\"></a>\r\n### 视图构造器\r\n\r\n视图构造器「creators」和视图合成器非常相似。唯一不同之处在于视图构造器在视图实例化之后执行，而视图合成器在视图即将渲染时执行。使用  `creator` 方法注册视图构造器：\r\n\r\n    use App\\View\\Creators\\ProfileCreator;\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    View::creator('profile', ProfileCreator::class);\r\n\r\n\r\n\r\n<a name=\"optimizing-views\"></a>\r\n## 优化视图\r\n\r\n默认情况下，Blade 模板视图是按需编译的。当执行渲染视图的请求时，Laravel 将确定视图的编译版本是否存在。如果文件存在，Laravel 将比较未编译的视图和已编译的视图是否有修改。如果编译后的视图不存在，或者未编译的视图已被修改，Laravel 将重新编译该视图。\r\n\r\n在请求期间编译视图可能会对性能产生小的负面影响，因此 Laravel 提供了 `view:cache` Artisan 命令来预编译应用程序使用的所有视图。为了提高性能，您可能希望在部署过程中运行此命令：\r\n\r\n```shell\r\nphp artisan view:cache\r\n```\r\n\r\n您可以使用 `view:clear` 命令清除视图缓存：\r\n\r\n```shell\r\nphp artisan view:clear\r\n```\r\n\r\n\r\n","p":"docs/views.html"},{"t":"blade (Blade 模板)","d":"# Blade 模板\r\n\r\n- [简介](#introduction)\r\n- [数据显示](#displaying-data)\r\n    - [HTML 实体编码](#html-entity-encoding)\r\n    - [Blade & JavaScript 框架](#blade-and-javascript-frameworks)\r\n- [Blade 指令](#blade-directives)\r\n    - [If 语句](#if-statements)\r\n    - [Switch 语句](#switch-statements)\r\n    - [循环](#loops)\r\n    - [循环变量](#the-loop-variable)\r\n    - [条件类](#conditional-classes)\r\n    - [Checked / Selected / Disabled](#checked-and-selected)\r\n    - [包括子视图](#including-subviews)\r\n    - [`@once` 指令](#the-once-directive)\r\n    - [PHP](#raw-php)\r\n    - [注释](#comments)\r\n- [组件](#components)\r\n    - [渲染组件](#rendering-components)\r\n    - [组件传参](#passing-data-to-components)\r\n    - [组件属性](#component-attributes)\r\n    - [保留关键字](#reserved-keywords)\r\n    - [插槽](#slots)\r\n    - [内联组件视图](#inline-component-views)\r\n    - [匿名组件](#anonymous-components)\r\n    - [动态组件](#dynamic-components)\r\n    - [手动注册组件](#manually-registering-components)\r\n- [创建布局](#building-layouts)\r\n    - [使用组件的布局](#layouts-using-components)\r\n    - [使用模板继承的布局](#layouts-using-template-inheritance)\r\n- [表单](#forms)\r\n    - [CSRF 字段](#csrf-field)\r\n    - [Method 字段](#method-field)\r\n    - [验证错误](#validation-errors)\r\n- [堆栈](#stacks)\r\n- [服务注入](#service-injection)\r\n- [渲染内联 Blade 模板](#rendering-inline-blade-templates)\r\n- [Blade 扩展](#extending-blade)\r\n    - [自定义 Echo 处理](#custom-echo-handlers)\r\n    - [自定义 if 语句](#custom-if-statements)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nBlade 是 Laravel 提供的一个简单而又强大的模板引擎。 和其他流行的 PHP 模板引擎不同，Blade 并不限制你在视图中使用原生 PHP 代码。实际上，所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何负担。Blade 模板文件使用 `.blade.php` 作为文件扩展名，被存放在 `resources/views` 目录。\r\n\r\nBlade 视图可以使用全局 `view` 函数从 Route 或控制器返回。当然，正如有关 [views](/docs/laravel/9.x/views) 的文档中所描述的，可以使用 `view` 函数的第二个参数将数据传递到 Blade 视图：\r\n\r\n    Route::get('/', function () {\r\n        return view('greeting', ['name' => 'Finn']);\r\n    });\r\n\r\n> 技巧：想要让您的 Blade 模板更上一层楼并轻松构建动态界面？请阅读 [Laravel Livewire](https://laravel-livewire.com)。\r\n\r\n\r\n\r\n<a name=\"displaying-data\"></a>\r\n## 显示数据\r\n\r\n你可以把变量置于花括号中以在视图中显示数据。例如，给定下方的路由：\r\n\r\n    Route::get('/', function () {\r\n        return view('welcome', ['name' => 'Samantha']);\r\n    });\r\n\r\n您可以像如下这样显示 `name` 变量的内容：\r\n\r\n```blade\r\nHello, {{ $name }}.\r\n```\r\n\r\n> 技巧：Blade 的 `{{ }}` 语句将被 PHP 的 `htmlspecialchars` 函数自动转义以防范 XSS 攻击。\r\n\r\n您不仅限于显示传递给视图的变量的内容。您也可以回显任何 PHP 函数的结果。实际上，您可以将所需的任何 PHP 代码放入 Blade echo 语句中：\r\n\r\n```blade\r\nThe current UNIX timestamp is {{ time() }}.\r\n```\r\n\r\n<a name=\"html-entity-encoding\"></a>\r\n### HTML 实体编码\r\n\r\n默认情况下，Blade（和 Laravel `e` 助手）将对 HTML 实体进行双重编码。如果您想禁用双重编码，请从 `AppServiceProvider` 的 `boot` 方法调用 `Blade::withoutDoubleEncoding` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 在此启动任意服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Blade::withoutDoubleEncoding();\r\n        }\r\n    }\r\n\r\n<a name=\"displaying-unescaped-data\"></a>\r\n#### 展示非转义数据\r\n\r\n默认情况下， Blade `{{ }}` 语句将被 PHP 的 `htmlspecialchars` 函数自动转义以防范 XSS 攻击。如果不想您的数据被转义，那么您可使用如下的语法：\r\n\r\n```blade\r\nHello, {!! $name !!}.\r\n```\r\n\r\n> 注意：在应用中显示用户提供的数据时请格外小心，请尽可能的使用转义和双引号语法来防范 XSS 攻击。\r\n\r\n\r\n\r\n<a name=\"blade-and-javascript-frameworks\"></a>\r\n### Blade & JavaScript 框架\r\n\r\n由于许多 JavaScript 框架也使用「花括号」来标识将显示在浏览器中的表达式，因此，您可以使用 @ 符号来表示 Blade 渲染引擎应当保持不变。例如：\r\n\r\n```blade\r\n<h1>Laravel</h1>\r\n\r\nHello, @{{ name }}.\r\n```\r\n\r\n在这个例子中， `@` 符号将被 Blade 移除；当然，Blade 将不会修改 `{{ name }}` 表达式，取而代之的是 JavaScript 模板来对其进行渲染。\r\n\r\n\r\n`@` 符号也用于转义 Blade 指令：\r\n\r\n```blade\r\n{{-- Blade template --}}\r\n@@if()\r\n\r\n<!-- HTML output -->\r\n@if()\r\n```\r\n\r\n<a name=\"rendering-json\"></a>\r\n#### 渲染 JSON\r\n\r\n有时，您可能会将数组传递给视图，以将其呈现为 JSON，以便初始化 JavaScript 变量。 例如：\r\n\r\n```blade\r\n<script>\r\n    var app = <?php echo json_encode($array); ?>;\r\n</script>\r\n```\r\n\r\n或者，您可以使用 `Illuminate\\Support\\Js::from` 方法指令，而不是手动调用 `json_encode`。 `from` 方法接受与 PHP 的 `json_encode` 函数相同的参数；但是，它将确保正确转义生成的 JSON 以包含在 HTML 引号中。 `from` 方法将返回一个字符串 `JSON.parse` JavaScript 语句，它将给定对象或数组转换为有效的 JavaScript 对象：\r\n\r\n```blade\r\n<script>\r\n    var app = {{ Illuminate\\Support\\Js::from($array) }};\r\n</script>\r\n```\r\n\r\nLaravel 应用程序框架的最新版本包括一个 `Js` 门面，它提供了在 Blade 模板中方便地访问此功能：\r\n\r\n```blade\r\n<script>\r\n    var app = {{ Js::from($array) }};\r\n</script>\r\n```\r\n\r\n> 注意：您应该只使用 `Js::from` 渲染已经存在的变量为 JSON。 Blade 模板基于正则表达式，如果尝试将复杂表达式传递给 `Js::from` 可能会导致无法预测的错误。\r\n\r\n\r\n\r\n<a name=\"the-at-verbatim-directive\"></a>\r\n#### `@verbatim` 指令\r\n\r\n如果您在模板中显示很大一部分 JavaScript 变量，您可以将 HTML 嵌入到 `@verbatim` 指令中，这样，您就不需要在每一个 Blade 回显语句前添加 `@` 符号：\r\n\r\n```blade\r\n@verbatim\r\n    <div class=\"container\">\r\n        Hello, {{ name }}.\r\n    </div>\r\n@endverbatim\r\n```\r\n\r\n<a name=\"blade-directives\"></a>\r\n## Blade 指令\r\n\r\n除了模板继承和显示数据以外， Blade 还为常见的 PHP 控制结构提供了便捷的快捷方式，例如条件语句和循环。这些快捷方式为 PHP 控制结构提供了一个非常清晰、简洁的书写方式，同时，还与 PHP 中的控制结构保持了相似的语法特性。\r\n\r\n<a name=\"if-statements\"></a>\r\n### If 语句\r\n\r\n您可以使用 `@if` ， `@elseif` ， `@else` 和 `@endif` 指令构造 `if` 语句。这些指令功能与它们所对应的 PHP 语句完全一致：\r\n\r\n```blade\r\n@if (count($records) === 1)\r\n    // 有一条记录\r\n@elseif (count($records) > 1)\r\n    // 有多条记录\r\n@else\r\n    // 没有记录\r\n@endif\r\n```\r\n\r\n为了方便， Blade 还提供了一个 `@unless` 指令：\r\n\r\n```blade\r\n@unless (Auth::check())\r\n    // 还没有登录\r\n@endunless\r\n```\r\n\r\n> 译注：相当于 `@if (! Auth::check()) @endif`\r\n\r\n除了上面所说条件指令外， `@isset` 和 `@empty` 指令亦可作为它们所对应的 PHP 函数的快捷方式：\r\n\r\n```blade\r\n@isset($records)\r\n    // $records 已经被定义且不为 null ……\r\n@endisset\r\n\r\n@empty($records)\r\n    // $records 为「空」……\r\n@endempty\r\n```\r\n\r\n<a name=\"authentication-directives\"></a>\r\n#### 授权指令\r\n\r\n`@auth` 和 `@guest` 指令可用于快速判断当前用户是否已经获得 [授权](/docs/laravel/9.x/authentication) 或是游客：\r\n\r\n```blade\r\n@auth\r\n    // 用户已经通过认证……\r\n@endauth\r\n\r\n@guest\r\n    // 用户没有通过认证……\r\n@endguest\r\n```\r\n\r\n\r\n\r\n如有需要，您亦可在使用 `@auth` 和 `@guest` 指令时指定 [鉴权守卫](https://learnku.com/docs/laravel/8.x/authentication \"鉴权守卫\")：\r\n\r\n```blade\r\n@auth('admin')\r\n    // 用户已经通过认证...\r\n@endauth\r\n\r\n@guest('admin')\r\n    // 用户没有通过认证...\r\n@endguest\r\n```\r\n\r\n<a name=\"environment-directives\"></a>\r\n#### 环境指令\r\n\r\n您可以使用 `@production` 指令来判断应用是否处于生产环境：\r\n\r\n```blade\r\n@production\r\n    // 生产环境特定内容...\r\n@endproduction\r\n```\r\n\r\n或者，您可以使用 `@env` 指令来判断应用是否运行于指定的环境：\r\n\r\n```blade\r\n@env('staging')\r\n    //  应用运行于「staging」环境...\r\n@endenv\r\n\r\n@env(['staging', 'production'])\r\n    // 应用运行于 「staging」或 [生产] 环境...\r\n@endenv\r\n```\r\n\r\n<a name=\"section-directives\"></a>\r\n#### 区块指令\r\n\r\n您可以使用 `@hasSection` 指令来判断区块是否有内容：\r\n\r\n```blade\r\n@hasSection('navigation')\r\n    <div class=\"pull-right\">\r\n        @yield('navigation')\r\n    </div>\r\n\r\n    <div class=\"clearfix\"></div>\r\n@endif\r\n```\r\n\r\n您可以使用 `sectionMissing` 指令来判断区块是否没有内容：\r\n\r\n```blade\r\n@sectionMissing('navigation')\r\n    <div class=\"pull-right\">\r\n        @include('default-navigation')\r\n    </div>\r\n@endif\r\n```\r\n\r\n<a name=\"switch-statements\"></a>\r\n### Switch Statements\r\n\r\n您可使用 `@switch` ， `@case` ， `@break` ， `@default` 和 `@endswitch` 语句来构造 Switch 语句：\r\n\r\n```blade\r\n@switch($i)\r\n    @case(1)\r\n        First case...\r\n        @break\r\n\r\n    @case(2)\r\n        Second case...\r\n        @break\r\n\r\n    @default\r\n        Default case...\r\n@endswitch\r\n```\r\n\r\n<a name=\"loops\"></a>\r\n### 循环\r\n\r\n除了条件语句， Blade 还提供了与 PHP 循环结构功能相同的指令。同样，这些语句的功能和它们所对应的 PHP 语法一致：\r\n\r\n```blade\r\n@for ($i = 0; $i < 10; $i++)\r\n    The current value is {{ $i }}\r\n@endfor\r\n\r\n@foreach ($users as $user)\r\n    <p>This is user {{ $user->id }}</p>\r\n@endforeach\r\n\r\n@forelse ($users as $user)\r\n    <li>{{ $user->name }}</li>\r\n@empty\r\n    <p>No users</p>\r\n@endforelse\r\n\r\n@while (true)\r\n    <p>I'm looping forever.</p>\r\n@endwhile\r\n```\r\n\r\n> 技巧：在遍历 `foreach` 循环时，您可以使用 [循环变量](#the-loop-variable) 去获取有关循环的有价值的信息，例如，您处于循环的第一个迭代亦或是处于最后一个迭代。\r\n\r\n\r\n\r\n使用循环时，还可以使用 `@continue` 和 `@break` 循环或跳过当前迭代：\r\n\r\n```blade\r\n@foreach ($users as $user)\r\n    @if ($user->type == 1)\r\n        @continue\r\n    @endif\r\n\r\n    <li>{{ $user->name }}</li>\r\n\r\n    @if ($user->number == 5)\r\n        @break\r\n    @endif\r\n@endforeach\r\n```\r\n\r\n您还可以在指令声明中包含继续或中断条件：\r\n\r\n```blade\r\n@foreach ($users as $user)\r\n    @continue($user->type == 1)\r\n\r\n    <li>{{ $user->name }}</li>\r\n\r\n    @break($user->number == 5)\r\n@endforeach\r\n```\r\n\r\n<a name=\"the-loop-variable\"></a>\r\n### Loop 变量\r\n\r\n在遍历 `foreach` 循环时，循环内部可以使用 `$loop` 变量。该变量提供了访问一些诸如当前的循环索引和此次迭代是首次或是末次这样的信息的方式：\r\n\r\n```blade\r\n@foreach ($users as $user)\r\n    @if ($loop->first)\r\n        This is the first iteration.\r\n    @endif\r\n\r\n    @if ($loop->last)\r\n        This is the last iteration.\r\n    @endif\r\n\r\n    <p>This is user {{ $user->id }}</p>\r\n@endforeach\r\n```\r\n\r\n如果您处于嵌套循环中，您可以使用循环的 `$loop` 变量的 `parent` 属性访问父级循环：\r\n\r\n```blade\r\n@foreach ($users as $user)\r\n    @foreach ($user->posts as $post)\r\n        @if ($loop->parent->first)\r\n            This is the first iteration of the parent loop.\r\n        @endif\r\n    @endforeach\r\n@endforeach\r\n```\r\n\r\n该 `$loop` 变量还包含各种各样有用的属性：\r\n\r\n属性  | 描述\r\n------------- | -------------\r\n`$loop->index`  |  当前迭代的索引（从 0 开始）。\r\n`$loop->iteration`  |  当前循环的迭代次数（从 1 开始）。\r\n`$loop->remaining`  |  循环剩余的迭代次数。\r\n`$loop->count`  |  被迭代的数组的元素个数。\r\n`$loop->first`  |  当前迭代是否是循环的首次迭代。\r\n`$loop->last`  |  当前迭代是否是循环的末次迭代。\r\n`$loop->even`  |  当前循环的迭代次数是否是偶数。\r\n`$loop->odd`  |  当前循环的迭代次数是否是奇数。\r\n`$loop->depth`  |  当前循环的嵌套深度。\r\n`$loop->parent`  |  嵌套循环中的父级循环。\r\n\r\n\r\n\r\n<a name=\"conditional-classes\"></a>\r\n### 有条件地编译 class 样式\r\n\r\n该 `@class` 指令有条件地编译 CSS class 样式。该指令接收一个数组，其中数组的键包含您希望添加的一个或多个样式的类名，而值是一个布尔表达式。如果数组元素有一个数值的键，它将始终包含在呈现的 class 列表中：\r\n\r\n```blade\r\n@php\r\n    $isActive = false;\r\n    $hasError = true;\r\n@endphp\r\n\r\n<span @class([\r\n    'p-4',\r\n    'font-bold' => $isActive,\r\n    'text-gray-500' => ! $isActive,\r\n    'bg-red' => $hasError,\r\n])></span>\r\n\r\n<span class=\"p-4 text-gray-500 bg-red\"></span>\r\n```\r\n\r\n<a name=\"checked-and-selected\"></a>\r\n### Checked / Selected / Disabled\r\n\r\n为方便起见，您可以使用该 `@checked` 指令轻松判断给定的 HTML 复选框输入是否被「checked」。如果提供的条件判断为 `true` ，则此指令将回显 `checked`：\r\n\r\n```blade\r\n<input type=\"checkbox\"\r\n        name=\"active\"\r\n        value=\"active\"\r\n        @checked(old('active', $user->active)) />\r\n```\r\n\r\n同样，该 `@selected` 指令可用于判断给定的选项是否被「selected」：\r\n\r\n```blade\r\n<select name=\"version\">\r\n    @foreach ($product->versions as $version)\r\n        <option value=\"{{ $version }}\" @selected(old('version') == $version)>\r\n            {{ $version }}\r\n        </option>\r\n    @endforeach\r\n</select>\r\n```\r\n\r\n此外，该 `@disabled` 指令可用于判断给定元素是否为「disabled」:\r\n\r\n```blade\r\n<button type=\"submit\" @disabled($errors->isNotEmpty())>Submit</button>\r\n```\r\n\r\n<a name=\"including-subviews\"></a>\r\n### 包含子视图\r\n\r\n> 技巧：虽然您可以自由使用该 `@include` 指令，但是 Blade [组件](#components) 提供了类似的功能，并提供了优于该 `@include` 指令的功能，如数据和属性绑定。\r\n\r\nBlade 的 `@include` 指令允许您从一个视图中包含另外一个 Blade 视图。父视图中的所有变量在子视图中都可以使用：\r\n\r\n```blade\r\n<div>\r\n    @include('shared.errors')\r\n\r\n    <form>\r\n        <!-- Form Contents -->\r\n    </form>\r\n</div>\r\n```\r\n\r\n\r\n\r\n尽管子视图可以继承父视图中所有可以使用的数据，但是您也可以传递一个额外的数组，这个数组在子视图中也可以使用:\r\n\r\n```blade\r\n@include('view.name', ['status' => 'complete'])\r\n```\r\n\r\n如果您想要使用 `@include` 包含一个不存在的视图，Laravel 将会抛出一个错误。如果您想要包含一个可能存在也可能不存在的视图，那么您应该使用 `@includeIf` 指令:\r\n\r\n```blade\r\n@includeIf('view.name', ['status' => 'complete'])\r\n```\r\n\r\n如果想要使用 `@include`  包含一个给定值为 `true` 或 `false`的布尔表达式的视图，那么您可以使用 `@includeWhen` 和 `@includeUnless` 指令:\r\n\r\n```blade\r\n@includeWhen($boolean, 'view.name', ['status' => 'complete'])\r\n\r\n@includeUnless($boolean, 'view.name', ['status' => 'complete'])\r\n```\r\n\r\n如果想要包含一个视图数组中第一个存在的视图，您可以使用 `includeFirst` 指令:\r\n\r\n```blade\r\n@includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])\r\n```\r\n\r\n> 注意：在视图中，您应该避免使用 `__DIR__` 和 `__FILE__` 这些常量，因为他们将引用已缓存的和已编译的视图。\r\n\r\n<a name=\"rendering-views-for-collections\"></a>\r\n#### 为集合渲染视图\r\n\r\n您可以使用 Blade 的 `@each` 指令将循环合并在一行内：\r\n\r\n```blade\r\n@each('view.name', $jobs, 'job')\r\n```\r\n\r\n该 `@each` 指令的第一个参数是数组或集合中的元素的要渲染的视图片段。第二个参数是您想要迭代的数组或集合，当第三个参数是一个表示当前迭代的视图的变量名。因此，如果您遍历一个名为 `jobs` 的数组，通常会在视图片段中使用 `job` 变量来访问每一个 job （jobs 数组的元素）。在您的视图片段中，可以使用 `key` 变量来访问当前迭代的键。\r\n\r\n\r\n\r\n您亦可传递第四个参数给 `@each` 指令。当给定的数组为空时，将会渲染该参数所对应的视图。\r\n\r\n```blade\r\n@each('view.name', $jobs, 'job', 'view.empty')\r\n```\r\n\r\n> 注意：通过 `@each` 指令渲染的视图不会继承父视图的变量。如果子视图需要使用这些变量，您可以使用 `@foreach` 和 `@include` 来代替它。\r\n\r\n<a name=\"the-once-directive\"></a>\r\n### `@once` 指令\r\n\r\n该 `@once` 指令允许您定义模板的一部分内容，这部分内容在每一个渲染周期中只会被计算一次。该指令在使用 [堆栈](#stacks) 推送一段特定的 JavaScript 代码到页面的头部环境下是很有用的。例如，如果您想要在循环中渲染一个特定的 [组件](#components) ，您可能希望仅在组件渲染的首次推送 JavaScript 代码到头部：\r\n\r\n```blade\r\n@once\r\n    @push('scripts')\r\n        <script>\r\n            // 您自定义的 JavaScript 代码...\r\n        </script>\r\n    @endpush\r\n@endonce\r\n```\r\n\r\n由于该 `@once` 指令经常与 `@push` 或 `@prepend` 指令一起使用，为了使用方便，我们提供了 `@pushOnce` 和 `@prependOnce` 指令：\r\n\r\n```blade\r\n@pushOnce('scripts')\r\n    <script>\r\n        // 您自定义的 JavaScript 代码...\r\n    </script>\r\n@endPushOnce\r\n```\r\n\r\n<a name=\"raw-php\"></a>\r\n### PHP\r\n\r\n在许多情况下，嵌入 PHP 代码到您的视图中是很有用的。您可以在模板中使用 Blade 的 `@php` 指令执行原生的 PHP 代码块：\r\n\r\n```blade\r\n@php\r\n    $counter = 1;\r\n@endphp\r\n```\r\n\r\n<a name=\"comments\"></a>\r\n### 注释\r\n\r\nBlade 也允许您在视图中定义注释。但是，和 HTML 注释不同， Blade 注释不会被包含在应用返回的 HTML 中：\r\n\r\n```blade\r\n{{-- This comment will not be present in the rendered HTML --}}\r\n```\r\n\r\n\r\n\r\n<a name=\"components\"></a>\r\n## 组件\r\n\r\n组件和插槽的作用与区块和布局的作用一致；不过，有些人可能觉着组件和插槽更易于理解。有两种书写组件的方法：基于类的组件和匿名组件。\r\n\r\n您可以使用 `make:component` Artisan 命令来创建一个基于类的组件。我们将会创建一个简单的  `Alert` 组件用于说明如何使用组件。该 `make:component` 命令将会把组件置于 `App\\View\\Components` 目录中：\r\n\r\n```shell\r\nphp artisan make:component Alert\r\n```\r\n\r\n该 `make:component` 命令将会为组件创建一个视图模板。创建的视图被置于 `resources/views/components` 目录中。在为自己的应用程序编写组件时，会在 `app/View/Components` 目录和 `resources/views/components` 目录中自动发现组件，因此通常不需要进一步的组件注册。\r\n\r\n您还可以在子目录中创建组件：\r\n\r\n```shell\r\nphp artisan make:component Forms/Input\r\n```\r\n\r\n上面的命令将在目录中创建一个 `Input` 组件， `App\\View\\Components\\Forms` 视图将放置在 `resources/views/components/forms` 目录中。\r\n\r\n如果你想创建一个匿名组件（一个只有 Blade 模板并且没有类的组件），你可以在调用命令  `make:component` 使用该`--view`标志：\r\n\r\n```shell\r\nphp artisan make:component forms.input --view\r\n```\r\n\r\n上面的命令将在 `resources/views/components/forms/input.blade.php`创建一个 Blade 文件，该文件中可以通过 `<x-forms.input />`作为组件呈现。\r\n\r\n\r\n\r\n<a name=\"manually-registering-package-components\"></a>\r\n#### 手动注册包组件\r\n\r\n当为您自己的应用编写组件的时候，Laravel 将会自动发现位于 `app/View/Components` 目录和 `resources/views/components` 目录中的组件。\r\n\r\n当然，如果您使用 Blade 组件编译一个包，您可能需要手动注册组件类及其 HTML 标签别名。您应该在包的服务提供者的 `boot` 方法中注册您的组件：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * 驱动您的包的服务\r\n     */\r\n    public function boot()\r\n    {\r\n        Blade::component('package-alert', Alert::class);\r\n    }\r\n\r\n当组件注册完成后，便可使用标签别名来对其进行渲染。\r\n\r\n```blade\r\n<x-package-alert/>\r\n```\r\n\r\n或者，您可以使用该 `componentNamespace` 方法按照约定自动加载组件类。例如，一个 `Nightshade` 包可能有 `Calendar` 和 `ColorPicker` 组件驻留在 `Package\\Views\\Components` 命名空间中：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * 驱动您的包的服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Blade::componentNamespace('Nightshade\\\\Views\\\\Components', 'nightshade');\r\n    }\r\n\r\n这将允许他们的供应商命名空间使用包组件，使用以下 `package-name::` 语法：\r\n\r\n```blade\r\n<x-nightshade::calendar />\r\n<x-nightshade::color-picker />\r\n```\r\n\r\nBlade 将自动检测链接到该组件的类，通过对组件名称进行帕斯卡大小写。使用「点」表示法也支持子目录。\r\n\r\n<a name=\"rendering-components\"></a>\r\n### 显示组件\r\n\r\n要显示一个组件，您可以在 Blade 模板中使用 Blade 组件标签。 Blade 组件以  `x-` 字符串开始，其后紧接组件类 kebab case 形式的名称（即单词与单词之间使用短横线 `-` 进行连接）：\r\n\r\n```blade\r\n<x-alert/>\r\n\r\n<x-user-profile/>\r\n```\r\n\r\n如果组件位于 `App\\View\\Components` 目录的子目录中，您可以使用 `.` 字符来指定目录层级。例如，假设我们有一个组件位于 `App\\View\\Components\\Inputs\\Button.php`，那么我们可以像这样渲染它：\r\n\r\n```blade\r\n<x-inputs.button/>\r\n```\r\n\r\n\r\n\r\n<a name=\"passing-data-to-components\"></a>\r\n### 传递数据到组件中\r\n\r\n您可以使用 HTML 属性传递数据到 Blade 组件中。普通的值可以通过简单的 HTML 属性来传递给组件。PHP 表达式和变量应该通过以 `:` 字符作为前缀的变量来进行传递：\r\n\r\n```blade\r\n<x-alert type=\"error\" :message=\"$message\"/>\r\n```\r\n\r\n您应该在类的构造器中定义组件的必要数据。在组件的视图中，组件的所有 public 类型的属性都是可用的。不必通过组件类的 `render` 方法传递：\r\n\r\n    <?php\r\n\r\n    namespace App\\View\\Components;\r\n\r\n    use Illuminate\\View\\Component;\r\n\r\n    class Alert extends Component\r\n    {\r\n        /**\r\n         * alert 类型。\r\n         *\r\n         * @var string\r\n         */\r\n        public $type;\r\n\r\n        /**\r\n         * alert 消息。\r\n         *\r\n         * @var string\r\n         */\r\n        public $message;\r\n\r\n        /**\r\n         * 创建一个组件实例。\r\n         *\r\n         * @param  string  $type\r\n         * @param  string  $message\r\n         * @return void\r\n         */\r\n        public function __construct($type, $message)\r\n        {\r\n            $this->type = $type;\r\n            $this->message = $message;\r\n        }\r\n\r\n        /**\r\n         * 获取组件的视图 / 内容\r\n         *\r\n         * @return \\Illuminate\\View\\View|\\Closure|string\r\n         */\r\n        public function render()\r\n        {\r\n            return view('components.alert');\r\n        }\r\n    }\r\n\r\n渲染组件时，您可以回显变量名来显示组件的 public 变量的内容：\r\n\r\n```blade\r\n<div class=\"alert alert-{{ $type }}\">\r\n    {{ $message }}\r\n</div>\r\n```\r\n\r\n<a name=\"casing\"></a>\r\n#### 命名方式（Casing）\r\n\r\n组件的构造器的参数应该使用 `驼峰式` 类型，在 HTML 属性中引用参数名时应该使用 `短横线隔开式 kebab-case ：单词与单词之间使用短横线 - 进行连接）` 。例如，给定如下的组件构造器：\r\n\r\n    /**\r\n     * 创建一个组件实例\r\n     *\r\n     * @param  string  $alertType\r\n     * @return void\r\n     */\r\n    public function __construct($alertType)\r\n    {\r\n        $this->alertType = $alertType;\r\n    }\r\n\r\n`$alertType`  参数可以像这样使用：\r\n\r\n```blade\r\n<x-alert alert-type=\"danger\" />\r\n```\r\n\r\n\r\n\r\n<a name=\"escaping-attribute-rendering\"></a>\r\n#### 转义属性渲染\r\n\r\n因为一些 JavaScript 框架，例如 Alpine.js 还可以使用冒号前缀属性，你可以使用双冒号 (`::`) 前缀通知 Blade 属性不是 PHP 表达式。例如，给定以下组件：\r\n\r\n```blade\r\n<x-button ::class=\"{ danger: isDeleting }\">\r\n    Submit\r\n</x-button>\r\n```\r\n\r\nBlade 将渲染出以下 HTML 内容：\r\n\r\n```blade\r\n<button :class=\"{ danger: isDeleting }\">\r\n    Submit\r\n</button>\r\n```\r\n\r\n<a name=\"component-methods\"></a>\r\n#### 组件方法\r\n\r\n除了组件模板可用的公共变量外，还可以调用组件上的任何公共方法。例如，假设一个组件有一个 `isSelected` 方法：\r\n\r\n    /**\r\n     * 确定给定选项是否为当前选定的选项。\r\n     *\r\n     * @param  string  $option\r\n     * @return bool\r\n     */\r\n    public function isSelected($option)\r\n    {\r\n        return $option === $this->selected;\r\n    }\r\n\r\n通过调用与方法名称匹配的变量，可以从组件模板执行此方法：\r\n\r\n```blade\r\n<option {{ $isSelected($value) ? 'selected=\"selected\"' : '' }} value=\"{{ $value }}\">\r\n    {{ $label }}\r\n</option>\r\n```\r\n\r\n<a name=\"using-attributes-slots-within-component-class\"></a>\r\n#### 访问组件类中的属性和插槽\r\n\r\nBlade 组件还允许你访问类的 render 方法中的组件名称、属性和插槽。但是，为了访问这些数据，应该从组件的 `render` 方法返回闭包。闭包将接收一个  `$data` 数组作为它的唯一参数。此数组将包含几个元素，这些元素提供有关组件的信息：\r\n\r\n    /**\r\n     * 获取表示组件的视图 / 内容\r\n     *\r\n     * @return \\Illuminate\\View\\View|\\Closure|string\r\n     */\r\n    public function render()\r\n    {\r\n        return function (array $data) {\r\n            // $data['componentName'];\r\n            // $data['attributes'];\r\n            // $data['slot'];\r\n\r\n            return '<div>Components content</div>';\r\n        };\r\n    }\r\n\r\n\r\n\r\n`componentName` 等于 `x-` 前缀后面的 HTML 标记中使用的名称。所以 `<x-alert />` 的 `componentName` 将是 `alert` 。 `attributes` 元素将包含 HTML 标记上的所有属性。 `slot` 元素是一个 `Illuminate\\Support\\HtmlString`实例，包含组件的插槽内容。\r\n\r\n闭包应该返回一个字符串。如果返回的字符串与现有视图相对应，则将呈现该视图；否则，返回的字符串将作为内联 Blade 视图进行计算。\r\n\r\n<a name=\"additional-dependencies\"></a>\r\n#### 附加依赖项\r\n\r\n如果你的组件需要引入来自 Laravel 的 [服务容器](/docs/laravel/9.x/container)的依赖项，你可以在组件的任何数据属性之前列出这些依赖项，这些依赖项将由容器自动注入：\r\n\r\n```php\r\nuse App\\Services\\AlertCreator;\r\n\r\n/**\r\n * 创建组件实例\r\n *\r\n * @param  \\App\\Services\\AlertCreator  $creator\r\n * @param  string  $type\r\n * @param  string  $message\r\n * @return void\r\n */\r\npublic function __construct(AlertCreator $creator, $type, $message)\r\n{\r\n    $this->creator = $creator;\r\n    $this->type = $type;\r\n    $this->message = $message;\r\n}\r\n```\r\n\r\n<a name=\"hiding-attributes-and-methods\"></a>\r\n#### 隐藏属性/方法\r\n\r\n如果要防止某些公共方法或属性作为变量公开给组件模板，可以将它们添加到组件的 `$except` 数组属性中：\r\n\r\n    <?php\r\n\r\n    namespace App\\View\\Components;\r\n\r\n    use Illuminate\\View\\Component;\r\n\r\n    class Alert extends Component\r\n    {\r\n        /**\r\n         * The alert type.\r\n         *\r\n         * @var string\r\n         */\r\n        public $type;\r\n\r\n        /**\r\n         * 不应向组件模板公开的属性/方法。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $except = ['type'];\r\n    }\r\n\r\n<a name=\"component-attributes\"></a>\r\n### 组件属性\r\n\r\n我们已经研究了如何将数据属性传递给组件；但是，有时你可能需要指定额外的 HTML 属性，例如  `class`，这些属性不是组件运行所需的数据的一部分。通常，你希望将这些附加属性向下传递到组件模板的根元素。例如，假设我们要呈现一个 `alert` 组件，如下所示：\r\n\r\n```blade\r\n<x-alert type=\"error\" :message=\"$message\" class=\"mt-4\"/>\r\n```\r\n\r\n\r\n\r\n所有不属于组件的构造器的属性都将被自动添加到组件的「属性包」中。该属性包将通过 `$attributes` 变量自动传递给组件。您可以通过回显这个变量来渲染所有的属性：\r\n\r\n```blade\r\n<div {{ $attributes }}>\r\n    <!-- Component content -->\r\n</div>\r\n```\r\n\r\n> 注意：此时不支持在组件中使用诸如 `@env` 这样的指令。例如， `<x-alert :live=\"@env('production')\"/>` 不会被编译。\r\n\r\n<a name=\"default-merged-attributes\"></a>\r\n#### 默认 / 合并属性\r\n\r\n某些时候，你可能需要指定属性的默认值，或将其他值合并到组件的某些属性中。为此，你可以使用属性包的 `merge`方法。 此方法对于定义一组应始终应用于组件的默认 CSS 类特别有用：\r\n\r\n```blade\r\n<div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>\r\n    {{ $message }}\r\n</div>\r\n```\r\n\r\n假设我们如下方所示使用该组件：\r\n\r\n```blade\r\n<x-alert type=\"error\" :message=\"$message\" class=\"mb-4\"/>\r\n```\r\n\r\n最终呈现的组件 HTML 将如下所示：\r\n\r\n```blade\r\n<div class=\"alert alert-error mb-4\">\r\n    <!-- Contents of the $message variable -->\r\n</div>\r\n```\r\n\r\n<a name=\"conditionally-merge-classes\"></a>\r\n#### 有条件地合并类\r\n\r\n有时您可能希望在给定条件为 `true` 时合并类。 您可以通过该 `class` 方法完成此操作，该方法接受一个类数组，其中数组键包含您希望添加的一个或多个类，而值是一个布尔表达式。如果数组元素有一个数字键，它将始终包含在呈现的类列表中：\r\n\r\n```blade\r\n<div {{ $attributes->class(['p-4', 'bg-red' => $hasError]) }}>\r\n    {{ $message }}\r\n</div>\r\n```\r\n\r\n\r\n\r\n如果需要将其他属性合并到组件中，可以将 `merge` 方法链接到 `class` 方法中：\r\n\r\n```blade\r\n<button {{ $attributes->class(['p-4'])->merge(['type' => 'button']) }}>\r\n    {{ $slot }}\r\n</button>\r\n```\r\n\r\n> 技巧：如果您需要有条件地编译不应接收合并属性的其他 HTML 元素上的类，您可以使用 [`@class` 指令](#conditional-classes)。\r\n\r\n<a name=\"non-class-attribute-merging\"></a>\r\n#### 非 class 属性的合并\r\n\r\n当合并非 `class` 属性的属性时，提供给 `merge` 方法的值将被视为该属性的「default」值。但是，与 `class` 属性不同，这些属性不会与注入的属性值合并。相反，它们将被覆盖。例如， `button` 组件的实现可能如下所示：\r\n\r\n```blade\r\n<button {{ $attributes->merge(['type' => 'button']) }}>\r\n    {{ $slot }}\r\n</button>\r\n```\r\n\r\n若要使用自定义 `type` 呈现按钮组件，可以在使用该组件时指定它。如果未指定 `type`，则将使用 `button` 作为 type 值：\r\n\r\n```blade\r\n<x-button type=\"submit\">\r\n    Submit\r\n</x-button>\r\n```\r\n\r\n本例中 `button` 组件渲染的 HTML 为：\r\n\r\n```blade\r\n<button type=\"submit\">\r\n    Submit\r\n</button>\r\n```\r\n\r\n如果希望 `class` 以外的属性将其默认值和注入值连接在一起，可以使用 `prepends` 方法。在本例中， `data-controller` 属性始终以 `profile-controller` 开头，并且任何其他注入 `data-controller` 的值都将放在该默认值之后：\r\n\r\n```blade\r\n<div {{ $attributes->merge(['data-controller' => $attributes->prepends('profile-controller')]) }}>\r\n    {{ $slot }}\r\n</div>\r\n```\r\n\r\n<a name=\"filtering-attributes\"></a>\r\n#### 保留属性 / 过滤属性\r\n\r\n可以使用 `filter` 方法筛选属性。如果希望在属性包中保留属性，此方法接受应返回 `true` 的闭包：\r\n\r\n```blade\r\n{{ $attributes->filter(fn ($value, $key) => $key == 'foo') }}\r\n```\r\n\r\n\r\n\r\n为了方便起见，你可以使用 `whereStartsWith` 方法检索其键以给定字符串开头的所有属性：\r\n\r\n```blade\r\n{{ $attributes->whereStartsWith('wire:model') }}\r\n```\r\n\r\n相反，该 `whereDoesntStartWith` 方法可用于排除键以给定字符串开头的所有属性：\r\n\r\n```blade\r\n{{ $attributes->whereDoesntStartWith('wire:model') }}\r\n```\r\n\r\n使用 `first` 方法，可以呈现给定属性包中的第一个属性：\r\n\r\n```blade\r\n{{ $attributes->whereStartsWith('wire:model')->first() }}\r\n```\r\n\r\n如果要检查组件上是否存在属性，可以使用 `has` 方法。此方法接受属性名称作为其唯一参数，并返回一个布尔值，指示该属性是否存在：\r\n\r\n```blade\r\n@if ($attributes->has('class'))\r\n    <div>>存在 class 属性</div>\r\n@endif\r\n```\r\n\r\n可以使用 `get` 方法检索特定属性的值：\r\n\r\n```blade\r\n{{ $attributes->get('class') }}\r\n```\r\n\r\n<a name=\"reserved-keywords\"></a>\r\n### 保留关键字\r\n\r\n默认情况下，为了渲染组件，会保留一些关键字供 Blade 内部使用。以下关键字不能定义为组件中的公共属性或方法名称：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `data`\r\n- `render`\r\n- `resolveView`\r\n- `shouldRender`\r\n- `view`\r\n- `withAttributes`\r\n- `withName`\r\n\r\n</div>\r\n\r\n<a name=\"slots\"></a>\r\n### 插槽\r\n\r\n你通常需要通过「插槽」将其他内容传递给组件。通过回显 `$slot` 变量来呈现组件插槽。为了探索这个概念，我们假设 `alert` 组件具有以下内容：\r\n\r\n```blade\r\n<!-- /resources/views/components/alert.blade.php -->\r\n\r\n<div class=\"alert alert-danger\">\r\n    {{ $slot }}\r\n</div>\r\n```\r\n\r\n我们可以通过向组件中注入内容将内容传递到 `slot` ：\r\n\r\n```blade\r\n<x-alert>\r\n    <strong>Whoops!</strong> Something went wrong!\r\n</x-alert>\r\n```\r\n\r\n\r\n\r\n有时候一个组件可能需要在它内部的不同位置放置多个不同的插槽。我们来修改一下 alert 组件，使其允许注入 「title」:\r\n\r\n```blade\r\n<!-- /resources/views/components/alert.blade.php -->\r\n\r\n<span class=\"alert-title\">{{ $title }}</span>\r\n\r\n<div class=\"alert alert-danger\">\r\n    {{ $slot }}\r\n</div>\r\n```\r\n\r\n您可以使用 `x-slot` 标签来定义命名插槽的内容。任何没有在 `x-slot` 标签中的内容都将传递给  `$slot` 变量中的组件：\r\n\r\n```xml\r\n<x-alert>\r\n    <x-slot:title>\r\n        Server Error\r\n    </x-slot>\r\n\r\n    <strong>Whoops!</strong> Something went wrong!\r\n</x-alert>\r\n```\r\n\r\n<a name=\"scoped-slots\"></a>\r\n#### 作用域插槽\r\n\r\n如果您使用诸如 Vue 这样的 JavaScript 框架，那么您应该很熟悉「作用域插槽」，它允许您从插槽中的组件访问数据或者方法。 Laravel 中也有类似的用法，只需在您的组件中定义 public 方法或属性，并且使用 `$component` 变量来访问插槽中的组件。在此示例中，我们将假设组件在其组件类上定义了 `x-alert` 一个公共方法： `formatAlert`\r\n\r\n```blade\r\n<x-alert>\r\n    <x-slot:title>\r\n        {{ $component->formatAlert('Server Error') }}\r\n    </x-slot>\r\n\r\n    <strong>Whoops!</strong> Something went wrong!\r\n</x-alert>\r\n```\r\n\r\n<a name=\"slot-attributes\"></a>\r\n#### 插槽属性\r\n\r\n像 Blade 组件一样，您可以为插槽分配额外的 [属性](#component-attributes) ，例如 CSS 类名：\r\n\r\n```xml\r\n<x-card class=\"shadow-sm\">\r\n    <x-slot:heading class=\"font-bold\">\r\n        Heading\r\n    </x-slot>\r\n\r\n    Content\r\n\r\n    <x-slot:footer class=\"text-sm\">\r\n        Footer\r\n    </x-slot>\r\n</x-card>\r\n```\r\n\r\n要与插槽属性交互，您可以访问 `attributes` 插槽变量的属性。有关如何与属性交互的更多信息，请参阅有关 [组件属性](#component-attributes) 的文档：\r\n\r\n```blade\r\n@props([\r\n    'heading',\r\n    'footer',\r\n])\r\n\r\n<div {{ $attributes->class(['border']) }}>\r\n    <h1 {{ $heading->attributes->class(['text-lg']) }}>\r\n        {{ $heading }}\r\n    </h1>\r\n\r\n    {{ $slot }}\r\n\r\n    <footer {{ $footer->attributes->class(['text-gray-700']) }}>\r\n        {{ $footer }}\r\n    </footer>\r\n</div>\r\n```\r\n\r\n\r\n\r\n<a name=\"inline-component-views\"></a>\r\n### 内联组件视图\r\n\r\n对于小型组件而言，管理组件类和组件视图模板可能会很麻烦。因此，您可以从 `render` 方法中返回组件的内容：\r\n\r\n    /**\r\n     * 获取组件的视图 / 内容。\r\n     *\r\n     * @return \\Illuminate\\View\\View|\\Closure|string\r\n     */\r\n    public function render()\r\n    {\r\n        return <<<'blade'\r\n            <div class=\"alert alert-danger\">\r\n                {{ $slot }}\r\n            </div>\r\n        blade;\r\n    }\r\n\r\n<a name=\"generating-inline-view-components\"></a>\r\n#### 生成内联视图组件\r\n\r\n要创建一个渲染内联视图的组件，您可以在运行 `make:component` 命令时使用  `inline` ：\r\n\r\n```shell\r\nphp artisan make:component Alert --inline\r\n```\r\n\r\n<a name=\"anonymous-components\"></a>\r\n### 匿名组件\r\n\r\n与行内组件相同，匿名组件提供了一个通过单个文件管理组件的机制。然而，匿名组件使用的是一个没有关联类的单一视图文件。要定义一个匿名组件，您只需将 Blade 模板置于 `resources/views/components` 目录下。例如，假设您在 `resources/views/components/alert.blade.php`中定义了一个组件：\r\n\r\n```blade\r\n<x-alert/>\r\n```\r\n\r\n如果组件在 `components` 目录的子目录中，您可以使用 `.` 字符来指定其路径。例如，假设组件被定义在 `resources/views/components/inputs/button.blade.php` 中，您可以像这样渲染它：\r\n\r\n```blade\r\n<x-inputs.button/>\r\n```\r\n\r\n<a name=\"anonymous-index-components\"></a>\r\n#### 匿名索引组件\r\n\r\n有时，当一个组件由许多 Blade 模板组成时，您可能希望将给定组件的模板分组到一个目录中。例如，想象一个具有以下目录结构的「可折叠」组件：\r\n\r\n```none\r\n/resources/views/components/accordion.blade.php\r\n/resources/views/components/accordion/item.blade.php\r\n```\r\n\r\n\r\n\r\n此目录结构允许您像这样呈现组件及其项目：\r\n\r\n```blade\r\n<x-accordion>\r\n    <x-accordion.item>\r\n        ...\r\n    </x-accordion.item>\r\n</x-accordion>\r\n```\r\n\r\n然而，为了通过 `x-accordion` 渲染组件， 我们被迫将「索引」组件模板放置在 `resources/views/components` 目录中，而不是与其他相关的模板嵌套在 `accordion` 目录中。\r\n\r\n幸运的是，Blade 允许您 `index.blade.php` 在组件的模板目录中放置文件。当 `index.blade.php` 组件存在模板时，它将被呈现为组件的「根」节点。因此，我们可以继续使用上面示例中给出的相同 Blade 语法；但是，我们将像这样调整目录结构：\r\n\r\n```none\r\n/resources/views/components/accordion/index.blade.php\r\n/resources/views/components/accordion/item.blade.php\r\n```\r\n\r\n<a name=\"data-properties-attributes\"></a>\r\n#### 数据 / 属性\r\n\r\n由于匿名组件没有任何关联类，您可能想要区分哪些数据应该被作为变量传递给组件，而哪些属性应该被存放于 [属性包](#component-attributes)中。\r\n\r\n您可以在组件的 Blade 模板的顶层使用 `@props` 指令来指定哪些属性应该作为数据变量。组件中的其他属性都将通过属性包的形式提供。如果您想要为某个数据变量指定一个默认值，您可以将属性名作为数组键，默认值作为数组值来实现：\r\n\r\n```blade\r\n<!-- /resources/views/components/alert.blade.php -->\r\n\r\n@props(['type' => 'info', 'message'])\r\n\r\n<div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>\r\n    {{ $message }}\r\n</div>\r\n```\r\n\r\n\r\n\r\n给定上面的组件定义，我们可以像这样渲染组件：\r\n\r\n```blade\r\n<x-alert type=\"error\" :message=\"$message\" class=\"mb-4\"/>\r\n```\r\n\r\n<a name=\"accessing-parent-data\"></a>\r\n#### 访问父数据\r\n\r\n有时您可能希望从子组件中的父组件访问数据。在这些情况下，您可以使用该 `@aware` 指令。例如，假设我们正在构建一个由父 `<x-menu>` 和 子组成的复杂菜单组件 `<x-menu.item>`：\r\n\r\n```blade\r\n<x-menu color=\"purple\">\r\n    <x-menu.item>...</x-menu.item>\r\n    <x-menu.item>...</x-menu.item>\r\n</x-menu>\r\n```\r\n\r\n该 `<x-menu>` 组件可能具有如下实现：\r\n\r\n```blade\r\n<!-- /resources/views/components/menu/index.blade.php -->\r\n\r\n@props(['color' => 'gray'])\r\n\r\n<ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}>\r\n    {{ $slot }}\r\n</ul>\r\n```\r\n\r\n因为 `color` 只被传递到父级 (`<x-menu>`)中，所以 `<x-menu.item>` 在内部是不可用的。但是，如果我们使用该 `@aware` 指令，我们也可以使其在内部可用 `<x-menu.item>` ：\r\n\r\n```blade\r\n<!-- /resources/views/components/menu/item.blade.php -->\r\n\r\n@aware(['color' => 'gray'])\r\n\r\n<li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}>\r\n    {{ $slot }}\r\n</li>\r\n```\r\n\r\n> 注意：该 `@aware` 指令无法访问未通过 HTML 属性显式传递给父组件的父数据。`@aware` 指令 不能访问未显式传递给父组件的默认值 `@props` 。\r\n\r\n<a name=\"dynamic-components\"></a>\r\n### 动态组件\r\n\r\n有时，您可能需要渲染一个组件，但在运行前不知道要渲染哪一个。这种情况下，您可以使用 Laravel 内置的 `dynamic-component` 组件来渲染一个基于值或变量的组件：\r\n\r\n```blade\r\n<x-dynamic-component :component=\"$componentName\" class=\"mt-4\" />\r\n```\r\n\r\n\r\n\r\n<a name=\"manually-registering-components\"></a>\r\n### 手动注册组件\r\n\r\n> 注意：以下关于手动注册组件的文档主要适用于编写包含视图组件的 Laravel 包的人。如果您不编写包，则组件文档的这一部分可能与您无关。\r\n\r\n当为您自己的应用编写组件的时候，Laravel 将会自动发现位于 `app/View/Components` 目录和  `resources/views/components` 目录中的组件。\r\n\r\n当然，如果您使用 Blade 组件编译一个包，您可能需要手动注册组件类及其 HTML 标签别名。您应该在包的服务提供者的 `boot` 方法中注册您的组件：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use VendorPackage\\View\\Components\\AlertComponent;\r\n\r\n    /**\r\n     * 驱动您的包的服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Blade::component('package-alert', AlertComponent::class);\r\n    }\r\n\r\n当组件注册完成后，便可使用标签别名来对其进行渲染。\r\n\r\n```blade\r\n<x-package-alert/>\r\n```\r\n\r\n#### 自动加载包组件\r\n\r\n或者，您可以使用该 `componentNamespace` 方法按照约定自动加载组件类。例如，一个 `Nightshade` 包可能有 `Calendar` 和 `ColorPicker` 组件驻留在 `Package\\Views\\Components` 命名空间中：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * 驱动您的包的服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Blade::componentNamespace('Nightshade\\\\Views\\\\Components', 'nightshade');\r\n    }\r\n\r\n这将允许他们的供应商命名空间使用包组件，使用以下 `package-name::` 语法：\r\n\r\n```blade\r\n<x-nightshade::calendar />\r\n<x-nightshade::color-picker />\r\n```\r\n\r\nBlade 将自动检测链接到该组件的类，通过对组件名称进行帕斯卡大小写。使用「点」表示法也支持子目录。\r\n\r\n\r\n\r\n<a name=\"building-layouts\"></a>\r\n## 构建布局\r\n\r\n<a name=\"layouts-using-components\"></a>\r\n### 使用组件布局\r\n\r\n大多数 web 应用程序在不同的页面上有相同的总体布局。如果我们必须在创建的每个视图中重复整个布局 HTML，那么维护我们的应用程序将变得非常麻烦和困难。谢天谢地，将此布局定义为单个 [Blade 组件](#components) 并在整个应用程序中非常方便地使用它。\r\n\r\n<a name=\"defining-the-layout-component\"></a>\r\n#### 定义布局组件\r\n\r\n例如，假设我们正在构建一个 todo list 应用程序。我们可以定义如下所示的 `layout` 组件：\r\n\r\n```blade\r\n<!-- resources/views/components/layout.blade.php -->\r\n\r\n<html>\r\n    <head>\r\n        <title>{{ $title ?? 'Todo Manager' }}</title>\r\n    </head>\r\n    <body>\r\n        <h1>Todos</h1>\r\n        <hr/>\r\n        {{ $slot }}\r\n    </body>\r\n</html>\r\n```\r\n\r\n<a name=\"applying-the-layout-component\"></a>\r\n#### 应用布局组件\r\n\r\n一旦定义了 `layout` 组件，我们就可以创建一个使用该组件的 Blade 视图。在本例中，我们将定义一个显示任务列表的简单视图：\r\n\r\n```blade\r\n<!-- resources/views/tasks.blade.php -->\r\n\r\n<x-layout>\r\n    @foreach ($tasks as $task)\r\n        {{ $task }}\r\n    @endforeach\r\n</x-layout>\r\n```\r\n\r\n请记住，注入到组件中的内容将提供给 `layout` 组件中的默认 `$slot` 变量。正如你可能已经注意到的，如果提供了 `$title` 插槽，那么我们的 `layout` 也会尊从该插槽；否则，将显示默认的标题。我们可以使用组件文档中讨论的标准槽语法从任务列表视图中插入自定义标题。 我们可以使用[组件文档](#components)中讨论的标准插槽语法从任务列表视图中注入自定义标题：\r\n\r\n```blade\r\n<!-- resources/views/tasks.blade.php -->\r\n\r\n<x-layout>\r\n    <x-slot:title>\r\n        Custom Title\r\n    </x-slot>\r\n\r\n    @foreach ($tasks as $task)\r\n        {{ $task }}\r\n    @endforeach\r\n</x-layout>\r\n```\r\n\r\n\r\n\r\n现在我们已经定义了布局和任务列表视图，我们只需要从路由中返回 `task` 视图即可：\r\n\r\n    use App\\Models\\Task;\r\n\r\n    Route::get('/tasks', function () {\r\n        return view('tasks', ['tasks' => Task::all()]);\r\n    });\r\n\r\n<a name=\"layouts-using-template-inheritance\"></a>\r\n### 使用模板继承进行布局\r\n\r\n<a name=\"defining-a-layout\"></a>\r\n#### 定义一个布局\r\n\r\n布局也可以通过 「模板继承」 创建。在引入 [组件](#components) 之前，这是构建应用程序的主要方法。\r\n\r\n让我们看一个简单的例子做开头。首先，我们将检查页面布局。由于大多数 web 应用程序在不同的页面上保持相同的总体布局，因此将此布局定义为单一视图非常方便：\r\n\r\n```blade\r\n<!-- resources/views/layouts/app.blade.php -->\r\n\r\n<html>\r\n    <head>\r\n        <title>App Name - @yield('title')</title>\r\n    </head>\r\n    <body>\r\n        @section('sidebar')\r\n            这是一个主要的侧边栏\r\n        @show\r\n\r\n        <div class=\"container\">\r\n            @yield('content')\r\n        </div>\r\n    </body>\r\n</html>\r\n```\r\n\r\n如你所见，此文件包含经典的 HTML 标记。但是，请注意 `@section` 和 `@yield` 指令。顾名思义， `@section` 指令定义内容的一部分，而 `@yield` 指令用于显示给定部分的内容。\r\n\r\n现在我们已经为应用程序定义了一个布局，让我们定义一个继承该布局的子页面。\r\n\r\n<a name=\"extending-a-layout\"></a>\r\n#### 继承布局\r\n\r\n定义子视图时，请使用 `@extends` Blade 指令指定子视图应「继承」的布局。扩展 Blade 布局的视图可以使用 `@section` 指令将内容注入布局的节点中。请记住，如上面的示例所示，这些部分的内容将使用 `@yield` 显示在布局中：\r\n\r\n```blade\r\n<!-- resources/views/child.blade.php -->\r\n\r\n@extends('layouts.app')\r\n\r\n@section('title', 'Page Title')\r\n\r\n@section('sidebar')\r\n    @parent\r\n\r\n    <p>This is appended to the master sidebar.</p>\r\n@endsection\r\n\r\n@section('content')\r\n    <p>This is my body content.</p>\r\n@endsection\r\n```\r\n\r\n\r\n\r\n在本例中，`sidebar` 部分使用 `@parent`  指令将内容追加（而不是覆盖）到局部的侧栏位置。在呈现视图时， `@parent` 指令将被布局的内容替换。\r\n\r\n> 技巧：与前面的示例相反，本 `sidebar` 节以 `@endsection` 结束，而不是以 `@show` 结束。 `@endsection` 指令将只定义一个节，`@show` 将定义并 **立即 yield** 该节。\r\n\r\n该 `@yield` 指令还接受默认值作为其第二个参数。如果要生成的节点未定义，则将呈现此内容：\r\n\r\n```blade\r\n@yield('content', 'Default content')\r\n```\r\n\r\n<a name=\"forms\"></a>\r\n## 表单\r\n\r\n<a name=\"csrf-field\"></a>\r\n### CSRF 字段\r\n\r\n无论何时在应用程序中定义 HTML 表单，都应该在表单中包含一个隐藏的 CSRF 令牌字段，以便 [CSRF 保护中间件](/docs/laravel/9.x/csrf) 可以验证请求。你可以使用 `@csrf` Blade 指令生成令牌字段：\r\n\r\n```blade\r\n<form method=\"POST\" action=\"/profile\">\r\n    @csrf\r\n\r\n    ...\r\n</form>\r\n```\r\n\r\n<a name=\"method-field\"></a>\r\n### Method 字段\r\n\r\n由于 HTML 表单不能发出 `PUT`、`PATCH`或 `DELETE` 请求，因此需要添加一个隐藏的 `_method` 字段来欺骗这些 HTTP 动词。 `@method` Blade 指令可以为你创建此字段：\r\n\r\n```blade\r\n<form action=\"/foo/bar\" method=\"POST\">\r\n    @method('PUT')\r\n\r\n    ...\r\n</form>\r\n```\r\n\r\n<a name=\"validation-errors\"></a>\r\n### 表单校验错误\r\n\r\n该 `@error` 指令可用于快速检查给定属性是否存在 [验证错误消息](/docs/laravel/9.x/validation#quick-displaying-the-validation-errors) 。在 `@error` 指令中，可以回显 `$message` 变量以显示错误消息：\r\n\r\n```blade\r\n<!-- /resources/views/post/create.blade.php -->\r\n\r\n<label for=\"title\">Post Title</label>\r\n\r\n<input id=\"title\"\r\n    type=\"text\"\r\n    class=\"@error('title') is-invalid @enderror\">\r\n\r\n@error('title')\r\n    <div class=\"alert alert-danger\">{{ $message }}</div>\r\n@enderror\r\n```\r\n\r\n\r\n\r\n由于该 `@error` 指令编译为「if」语句，因此您可以在 `@else` 属性没有错误时使用该指令来呈现内容：\r\n\r\n```blade\r\n<!-- /resources/views/auth.blade.php -->\r\n\r\n<label for=\"email\">Email address</label>\r\n\r\n<input id=\"email\"\r\n    type=\"email\"\r\n    class=\"@error('email') is-invalid @else is-valid @enderror\">\r\n```\r\n\r\n你可以将 [特定错误包的名称](/docs/laravel/9.x/validation#named-error-bags) 作为第二个参数传递给 `@error` 指令，以便在包含多个表单的页面上检索验证错误消息：\r\n\r\n```blade\r\n<!-- /resources/views/auth.blade.php -->\r\n\r\n<label for=\"email\">Email address</label>\r\n\r\n<input id=\"email\"\r\n    type=\"email\"\r\n    class=\"@error('email', 'login') is-invalid @enderror\">\r\n\r\n@error('email', 'login')\r\n    <div class=\"alert alert-danger\">{{ $message }}</div>\r\n@enderror\r\n```\r\n\r\n<a name=\"stacks\"></a>\r\n## 堆栈\r\n\r\nBlade 允许你推送到可以在其他视图或布局中的其他地方渲染的命名堆栈。这对于指定子视图所需的任何 JavaScript 库特别有用：\r\n\r\n```blade\r\n@push('scripts')\r\n    <script src=\"/example.js\"></script>\r\n@endpush\r\n```\r\n\r\n你可以根据需要多次推入堆栈。要呈现完整的堆栈内容，请将堆栈的名称传递给 `@stack` 指令：\r\n\r\n```blade\r\n<head>\r\n    <!-- Head Contents -->\r\n\r\n    @stack('scripts')\r\n</head>\r\n```\r\n\r\n如果要将内容前置到堆栈的开头，应使用 `@prepend` 指令：\r\n\r\n```blade\r\n@push('scripts')\r\n    这是第二加载的...\r\n@endpush\r\n\r\n// Later...\r\n\r\n@prepend('scripts')\r\n    这是第一加载的...\r\n@endprepend\r\n```\r\n\r\n<a name=\"service-injection\"></a>\r\n## 服务注入\r\n\r\n该 `@inject` 指令可用于从 Laravel [服务容器](/docs/laravel/9.x/container)中检索服务。传递给 `@inject` 的第一个参数是要将服务放入的变量的名称，而第二个参数是要解析的服务的类或接口名称：\r\n\r\n```blade\r\n@inject('metrics', 'App\\Services\\MetricsService')\r\n\r\n<div>\r\n    Monthly Revenue: {{ $metrics->monthlyRevenue() }}.\r\n</div>\r\n```\r\n\r\n\r\n\r\n<a name=\"rendering-inline-blade-templates\"></a>\r\n## 渲染内联 Blade 模板\r\n\r\n有时您可能需要将原始 Blade 模板字符串转换为有效的 HTML。您可以使用 `Blade` 门面提供的 `render` 方法来完成此操作。该 `render` 方法接受 Blade 模板字符串和提供给模板的可选数据数组：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Blade;\r\n\r\nreturn Blade::render('Hello, {{ $name }}', ['name' => 'Julian Bashir']);\r\n```\r\n\r\nLaravel 通过将内联 Blade 模板写入 `storage/framework/views` 目录来呈现它们。如果你希望 Laravel 在渲染 Blade 模板后删除这些临时文件，你可以为 `deleteCachedView` 方法提供参数：\r\n\r\n```php\r\nreturn Blade::render(\r\n    'Hello, {{ $name }}',\r\n    ['name' => 'Julian Bashir'],\r\n    deleteCachedView: true\r\n);\r\n```\r\n\r\n<a name=\"extending-blade\"></a>\r\n## 扩展 Blade\r\n\r\nBlade 允许你使用 `directive` 方法定义自己的自定义指令。当 Blade 编译器遇到自定义指令时，它将使用该指令包含的表达式调用提供的回调。\r\n\r\n下面的示例创建了一个 `@datetime($var)` 指令，该指令格式化给定的 `$var`，它应该是 `DateTime` 的一个实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册应用的服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 启动应用的服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Blade::directive('datetime', function ($expression) {\r\n                return \"<?php echo ($expression)->format('m/d/Y H:i'); ?>\";\r\n            });\r\n        }\r\n    }\r\n\r\n正如你所见，我们将 `format` 方法应用到传递给指令中的任何表达式上。因此，在本例中，此指令生成的最终 PHP 将是：\r\n\r\n    <?php echo ($var)->format('m/d/Y H:i'); ?>\r\n\r\n> 注意：更新 Blade 指令的逻辑后，需要删除所有缓存的 Blade 视图。可以使用 `view:clear` Artisan 命令。\r\n\r\n\r\n\r\n<a name=\"custom-echo-handlers\"></a>\r\n### 自定义回显处理程序\r\n\r\n如果您试图使用 Blade 来「回显」一个对象， 该对象的 `__toString` 方法将被调用。该[`__toString`](https://www.php.net/manual/en/language.oop5.magic.php#object.tostring) 方法是 PHP 内置的「魔术方法」之一。但是，有时您可能无法控制 `__toString` 给定类的方法，例如当您与之交互的类属于第三方库时。\r\n\r\n在这些情况下，Blade 允许您为该特定类型的对象注册自定义回显处理程序。为此，您应该调用 Blade 的 `stringable` 方法。该 `stringable` 方法接受一个闭包。这个闭包类型应该提示它负责呈现的对象的类型。通常，应该在应用程序的 `AppServiceProvider` 类的 `boot` 方法中调用该`stringable` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use Money\\Money;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Blade::stringable(function (Money $money) {\r\n            return $money->formatTo('en_GB');\r\n        });\r\n    }\r\n\r\n定义自定义回显处理程序后，您可以简单地回显 Blade 模板中的对象：\r\n\r\n```blade\r\nCost: {{ $money }}\r\n```\r\n\r\n<a name=\"custom-if-statements\"></a>\r\n### 自定义 if 声明\r\n\r\n在定义简单的自定义条件语句时，编写自定义指令通常比较复杂。因此，Blade 提供了一个  `Blade::if` 方法，允许你使用闭包快速定义自定义条件指令。例如，让我们定义一个自定义条件来检查为应用程序配置的默认 「存储」。我们可以在 `AppServiceProvider` 的 `boot` 方法中执行此操作：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * 启动应用的服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Blade::if('disk', function ($value) {\r\n            return config('filesystems.default') === $value;\r\n        });\r\n    }\r\n\r\n一旦定义了自定义条件，就可以在模板中使用它:\r\n\r\n```blade\r\n@disk('local')\r\n    <!-- 应用正在使用 local 存储 ... -->\r\n@elsedisk('s3')\r\n    <!-- 应用正在使用 s3 存储 ... -->\r\n@else\r\n    <!-- 应用正在使用其他存储 ... -->\r\n@enddisk\r\n\r\n@unlessdisk('local')\r\n    <!-- 应用当前没有使用 local 存储 ... -->\r\n@enddisk\r\n```\r\n\r\n","p":"docs/blade.html"},{"t":"urls (生成 URL)","d":"# 生成 URL\r\n\r\n- [简介](#introduction)\r\n- [基础](#the-basics)\r\n    - [生成基础 URL](#generating-basic-urls)\r\n    - [访问当前 URL](#accessing-the-current-url)\r\n- [命名路由的URL](#urls-for-named-routes)\r\n    - [签名 URL](#signed-urls)\r\n- [控制器行为的URL](#urls-for-controller-actions)\r\n- [默认值](#default-values)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 提供了几个辅助函数来为应用程序生成 URL。主要用于在模板和 API 响应中构建 URL 或者在应用程序的其它部分生成重定向响应。\r\n\r\n<a name=\"the-basics\"></a>\r\n## 基础\r\n\r\n<a name=\"generating-basic-urls\"></a>\r\n### 生成基础 URL\r\n\r\n辅助函数 `url` 可以用于应用的任何一个 URL。生成的 URL 将自动使用当前请求中的方案 (HTTP 或 HTTPS) 和主机：\r\n\r\n    $post = App\\Models\\Post::find(1);\r\n\r\n    echo url(\"/posts/{$post->id}\");\r\n\r\n    // http://example.com/posts/1\r\n\r\n<a name=\"accessing-the-current-url\"></a>\r\n### 访问当前 URL\r\n\r\n如果没有给辅助函数 `url` 提供路径，则会返回一个 `Illuminate\\Routing\\UrlGenerator` 实例，来允许你访问有关当前 URL 的信息：\r\n\r\n    // 获取当前 URL 没有 query string...\r\n    echo url()->current();\r\n\r\n    // 获取当前 URL 包括 query string...\r\n    echo url()->full();\r\n\r\n    // 获取上个请求 URL\r\n    echo url()->previous();\r\n\r\n上面的这些方法都可以通过 `URL` [facade](/docs/laravel/9.x/facades) 访问：\r\n\r\n    use Illuminate\\Support\\Facades\\URL;\r\n\r\n    echo URL::current();\r\n\r\n<a name=\"urls-for-named-routes\"></a>\r\n## 命名路由的 URL\r\n\r\n辅助函数 `route` 可以用于生成指定 [命名路由](/docs/laravel/9.x/routing#named-routes) 的 URL。命名路由生成的 URL 不与路由上定义的 URL 相耦合。因此，就算路由的 URL 有任何改变，都不需要对 `route` 函数调用进行任何更改。例如，假设你的应用程序包含以下路由：\r\n\r\n    Route::get('/post/{post}', function (Post $post) {\r\n        //\r\n    })->name('post.show');\r\n\r\n\r\n\r\n要生成此路由的 URL ，可以像这样使用辅助函数 `route` ：\r\n\r\n    echo route('post.show', ['post' => 1]);\r\n\r\n    // http://example.com/post/1\r\n\r\n当然，辅助函数 `route` 也可以用于为具有多个参数的路由生成 URL：\r\n\r\n    Route::get('/post/{post}/comment/{comment}', function (Post $post, Comment $comment) {\r\n        //\r\n    })->name('comment.show');\r\n\r\n    echo route('comment.show', ['post' => 1, 'comment' => 3]);\r\n\r\n    // http://example.com/post/1/comment/3\r\n\r\n任何与路由定义参数对应不上的附加数组元素都将添加到 URL 的查询字符串中：\r\n\r\n    echo route('post.show', ['post' => 1, 'search' => 'rocket']);\r\n\r\n    // http://example.com/post/1?search=rocket\r\n\r\n<a name=\"eloquent-models\"></a>\r\n#### Eloquent Models\r\n\r\n你通常使用 [Eloquent 模型](/docs/laravel/9.x/eloquent) 的主键生成 URL。因此，您可以将 Eloquent 模型作为参数值传递。`route` 辅助函数将自动提取模型的主键：\r\n\r\n    echo route('post.show', ['post' => $post]);\r\n\r\n<a name=\"signed-urls\"></a>\r\n### 签名 URL\r\n\r\nLaravel 允许你轻松地为命名路径创建「签名」URL，这些 URL 在查询字符串后附加了「签名」哈希，允许 Laravel 验证 URL 自创建以来未被修改过。签名 URL 对于可公开访问但需要一层防止 URL 操作的路由特别有用。\r\n\r\n例如，你可以使用签名 URL 来实现通过电子邮件发送给客户的公共「取消订阅」链接。要创建指向路径的签名 URL ，请使用 `URL` facade 的 `signedRoute` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\URL;\r\n\r\n    return URL::signedRoute('unsubscribe', ['user' => 1]);\r\n\r\n\r\n\r\n如果要生成具有有效期的临时签名路由 URL，可以使用以下 `temporarySignedRoute` 方法，当 Laravel 验证一个临时的签名路由 URL 时，它会确保编码到签名 URL 中的过期时间戳没有过期：\r\n\r\n    use Illuminate\\Support\\Facades\\URL;\r\n\r\n    return URL::temporarySignedRoute(\r\n        'unsubscribe', now()->addMinutes(30), ['user' => 1]\r\n    );\r\n\r\n<a name=\"validating-signed-route-requests\"></a>\r\n#### 验证签名路由请求\r\n\r\n要验证传入请求是否具有有效签名，你应该对传入的 `Illuminate\\Http\\Request` 实例中调用 `hasValidSignature` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/unsubscribe/{user}', function (Request $request) {\r\n        if (! $request->hasValidSignature()) {\r\n            abort(401);\r\n        }\r\n\r\n        // ...\r\n    })->name('unsubscribe');\r\n\r\n有时，你可能需要允许你的应用程序前端将数据附加到签名 URL，例如在执行客户端分页时。因此，你可以指定在使用 `hasValidSignatureWhileIgnoring` 方法验证签名 URL 时应忽略的请求查询参数。请记住，忽略参数将允许任何人根据请求修改这些参数：\r\n\r\n    if (! $request->hasValidSignatureWhileIgnoring(['page', 'order'])) {\r\n        abort(401);\r\n    }\r\n\r\n或者，你可以将 `Illuminate\\Routing\\Middleware\\ValidateSignature` [中间件](/docs/laravel/9.x/middleware) 分配给路由。如果它不存在，则应该在 HTTP 内核的 `routeMiddleware` 数组中为此中间件分配一个键：\r\n\r\n    /**\r\n     * 应用程序的路由中间件\r\n     *\r\n     * 这些中间件可以分配给组或单独使用\r\n     *\r\n     * @var array\r\n     */\r\n    protected $routeMiddleware = [\r\n        'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,\r\n    ];\r\n\r\n一旦在内核中注册了中间件，就可以将其附加到路由。如果传入的请求没有有效的签名，中间件将自动返回 `403` HTTP 响应：\r\n\r\n    Route::post('/unsubscribe/{user}', function (Request $request) {\r\n        // ...\r\n    })->name('unsubscribe')->middleware('signed');\r\n\r\n\r\n\r\n<a name=\"responding-to-invalid-signed-routes\"></a>\r\n#### 响应无效的签名路由\r\n\r\n当有人访问已过期的签名 URL 时，他们将收到一个通用的错误页面，显示 `403` HTTP 状态代码。然而，你可以通过在异常处理程序中为 `InvalidSignatureException` 异常定义自定义“可渲染”闭包来自定义此行为。这个闭包应该返回一个 HTTP 响应：\r\n\r\n\r\n    use Illuminate\\Routing\\Exceptions\\InvalidSignatureException;\r\n\r\n    /**\r\n     * 为应用程序注册异常处理回调\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->renderable(function (InvalidSignatureException $e) {\r\n            return response()->view('error.link-expired', [], 403);\r\n        });\r\n    }\r\n\r\n<a name=\"urls-for-controller-actions\"></a>\r\n## 控制器行为的 URL\r\n\r\n`action` 功能可以为给定的控制器行为生成 URL。\r\n\r\n    use App\\Http\\Controllers\\HomeController;\r\n\r\n    $url = action([HomeController::class, 'index']);\r\n\r\n如果控制器方法接收路由参数，你可以通过第二个参数传递：\r\n\r\n    $url = action([UserController::class, 'profile'], ['id' => 1]);\r\n\r\n<a name=\"default-values\"></a>\r\n## 默认值\r\n\r\n对于某些应用程序，你可能希望为某些 URL 参数的请求范围指定默认值。例如，假设有些路由定义了 `{locale}` 参数：\r\n\r\n    Route::get('/{locale}/posts', function () {\r\n        //\r\n    })->name('post.index');\r\n\r\n每次都通过 `locale` 来调用辅助函数 `route` 也是一件很麻烦的事情。因此，使用 `URL::defaults` 方法定义这个参数的默认值，可以让该参数始终存在当前请求中。然后就能从 [路由中间件](/docs/laravel/9.x/middleware#assigning-middleware-to-routes) 调用此方法来访问当前请求：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Support\\Facades\\URL;\r\n\r\n    class SetDefaultLocaleForUrls\r\n    {\r\n        /**\r\n         * 处理传入的请求\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Closure  $next\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function handle($request, Closure $next)\r\n        {\r\n            URL::defaults(['locale' => $request->user()->locale]);\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n\r\n\r\n一旦设置了 `locale` 参数的默认值，你就不再需要通过辅助函数 `route` 生成 URL 时传递它的值。\r\n\r\n<a name=\"url-defaults-middleware-priority\"></a>\r\n#### 默认 URL & 中间件优先级\r\n\r\n设置 URL 的默认值会影响 Laravel 对隐式模型绑定的处理。因此，你应该通过[设置中间件优先级](/docs/9.x/middleware#sorting-middleware)来确保在 Laravel 自己的 `SubstituteBindings` 中间件执行之前设置 URL 的默认值。你可以通过在您的应用的 HTTP kernel 文件中的 `$middlewarePriority` 属性里把您的中间件放在 `SubstituteBindings` 中间件之前。\r\n\r\n`$middlewarePriority` 这个属性在 `Illuminate\\Foundation\\Http\\Kernel` 这个基类里。你可以复制一份到你的应用程序的 HTTP kernel 文件中以便做修改:\r\n\r\n    /**\r\n     * 根据优先级排序的中间件列表\r\n     *\r\n     * 这将保证非全局中间件按照既定顺序排序\r\n     *\r\n     * @var array\r\n     */\r\n    protected $middlewarePriority = [\r\n        // ...\r\n         \\App\\Http\\Middleware\\SetDefaultLocaleForUrls::class,\r\n         \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n         // ...\r\n    ];\r\n\r\n","p":"docs/urls.html"},{"t":"session (HTTP 会话机制)","d":"# HTTP 会话机制\r\n\r\n- [简介](#introduction)\r\n    - [配置](#configuration)\r\n    - [驱动程序先决条件](#driver-prerequisites)\r\n- [使用 Session](#using-the-session)\r\n    - [获取数据](#retrieving-data)\r\n    - [存储数据](#storing-data)\r\n    - [闪存数据](#flash-data)\r\n    - [删除数据](#deleting-data)\r\n    - [重新生成 Session ID](#regenerating-the-session-id)\r\n- [Session Blocking](#session-blocking)\r\n- [添加自定义 Session 驱动](#adding-custom-session-drivers)\r\n    - [实现驱动](#implementing-the-driver)\r\n    - [注册驱动](#registering-the-driver)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介 \r\n\r\n由于 HTTP 驱动的应用程序是无状态的，Session 提供了一种在多个请求之间存储有关用户信息的方法，这类信息一般都存储在后续请求可以访问的持久存储/后端中。\r\n\r\nLaravel 通过同一个可读性强的 API 处理各种自带的后台驱动程序。支持诸如比较热门的 [Memcached](https://memcached.org)，[Redis](https://redis.io) 和数据库。\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\nSession 的配置文件存储在 `config/session.php` 文件中。请务必查看此文件中对于你而言可用的选项。默认情况下，Laravel 为绝大多数应用程序配置的 Session 驱动为 `file` 驱动，它适用于大多数程序。如果你的应用程序需要在多个 Web 服务器之间进行负载平衡，你应该选择一个所有服务器都可以访问的集中式存储，例如 Redis 或数据库。\r\n\r\n在生产环境中，你可以考虑使用 `memcached` 或 `redis`  驱动，让 Session 的性能更加出色。\r\n\r\nSession `driver` 的配置预设了每个请求存储 Session 数据的位置。Laravel 自带了几个不错而且开箱即用的驱动：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `file` - Sessions 存储在 `storage/framework/sessions` 中。\r\n- `cookie` - Sessions 被存储在安全加密的 cookie 中。\r\n- `database` - Sessions 被存储在关系型数据库中。\r\n- `memcached` / `redis` - Sessions 被存储在基于高速缓存的存储系统中。\r\n- `dynamodb` - Sessions 被存储在 AWS DynamoDB 中.\r\n- `array` - Sessions 存储在 PHP 数组中，但不会被持久化。\r\n\r\n</div>\r\n\r\n> 技巧：数组驱动一般用于 [测试](/docs/laravel/9.x/testing) 并且防止存储在 Session 中的数据被持久化。\r\n\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动先决条件\r\n\r\n<a name=\"database\"></a>\r\n#### 数据库\r\n\r\n使用 `database` Session 驱动时，你需要创建一个记录 Session 的表。下面是  `Schema` 的声明示例：\r\n\r\n    Schema::create('sessions', function ($table) {\r\n        $table->string('id')->primary();\r\n        $table->foreignId('user_id')->nullable()->index();\r\n        $table->string('ip_address', 45)->nullable();\r\n        $table->text('user_agent')->nullable();\r\n        $table->text('payload');\r\n        $table->integer('last_activity')->index();\r\n    });\r\n\r\n你可以使用Artisan 命令  `session:table` 生成这个迁移。了解更多数据库迁移，请查看完整的文档 [迁移文档](/docs/laravel/9.x/migrations)：\r\n\r\n```shell\r\nphp artisan session:table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"redis\"></a>\r\n#### Redis\r\n\r\n在 Laravel 使用 Redis Session 驱动前，你需要安装 PhpRedis PHP 扩展，可以通过 PECL 或者 通过 Composer 安装这个 `predis/predis` 包 (~1.0)。\r\n更多关于 Redis 配置信息, 查询 Laravel 的 [ Redis 文档 ](/docs/laravel/9.x/redis#configuration)。\r\n\r\n> 技巧：在 `session` 配置文件里,  `connection` 选项可以用来设置 Session 使用 Redis 连接方式。\r\n\r\n<a name=\"interacting-with-the-session\"></a>\r\n## 使用 Session \r\n\r\n<a name=\"retrieving-data\"></a>\r\n### 获取数据\r\n\r\n在 Laravel 中有两种基本的 Session 使用方式：全局 `session` 助手函数和通过 `Request` 实例。首先看下通过 `Request` 实例访问 Session ,它可以隐式绑定路由闭包或者控制器方法。记住，Laravel 会自动注入控制器方法的依赖。 [服务容器](/docs/laravel/9.x/container)：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示指定用户个人资料。\r\n         *\r\n         * @param  Request  $request\r\n         * @param  int  $id\r\n         * @return Response\r\n         */\r\n        public function show(Request $request, $id)\r\n        {\r\n            $value = $request->session()->get('key');\r\n\r\n            //\r\n        }\r\n    }\r\n\r\n\r\n\r\n当你从 Session 获取数据时， 你也可以在 `get` 方法第二个参数里传递一个 default 默认值，如果 Session 里不存在键值对 key 的数据结果，这个默认值就会返回。如果你传递给 `get` 方法一个闭包作为默认值，这个闭包会被执行并且返回结果。\r\n\r\n    $value = $request->session()->get('key', 'default');\r\n\r\n    $value = $request->session()->get('key', function () {\r\n        return 'default';\r\n    });\r\n\r\n<a name=\"the-global-session-helper\"></a>\r\n#### 全局 Session  助手函数\r\n\r\n你也可以在 Session 里 使用 PHP 全局 `session` 函数获取和储存数据。当这个 `session` 函数以一个单独的字符串形式被调用时，它将会返回这个 Session 键值对的结果。当函数以 key / value 数组形式被调用时，这些值会被存储在 Session 里：\r\n\r\n    Route::get('/home', function () {\r\n        // 从 Session 获取数据 ...\r\n        $value = session('key');\r\n\r\n        // 设置默认值...\r\n        $value = session('key', 'default');\r\n\r\n        // 在Session 里存储一段数据 ...\r\n        session(['key' => 'value']);\r\n    });\r\n\r\n> 技巧：通过 HTTP 请求实例与通过 `session` 助手函数方式使用 Session 之间没有实际区别。两种方式都是 [可测试的](/docs/laravel/9.x/testing) ，你所有的测试用例中都可以通过 `assertSessionHas` 方法进行断言。\r\n\r\n<a name=\"retrieving-all-session-data\"></a>\r\n#### 获取所有 Session 数据\r\n\r\n如果你想要从 Session 里获取所有数据，你可以使用  `all` 方法：\r\n\r\n    $data = $request->session()->all();\r\n\r\n\r\n\r\n<a name=\"determining-if-an-item-exists-in-the-session\"></a>\r\n#### 判断 Session 里是否存在条目\r\n\r\n判断 Session 里是否存在一个条目, 你可以使用 `has` 方法。如果条目存在且不为 `null`，`has` 方法返回 `true`：\r\n\r\n    if ($request->session()->has('users')) {\r\n        //\r\n    }\r\n\r\n判断 Session 里是否存在一个即使结果值为 `null` 的条目，你可以使用 `exists` 方法：\r\n\r\n    if ($request->session()->exists('users')) {\r\n        //\r\n    }\r\n\r\n要确定某个条目是否在会话中不存在，你可以使用 `missing` 方法。如果条目为 `null` 或条目不存在，`missing` 方法返回 `true`：\r\n\r\n    if ($request->session()->missing('users')) {\r\n        //\r\n    }\r\n\r\n<a name=\"storing-data\"></a>\r\n### 存储数据\r\n\r\nSession 里存储数据， 你通常将使用 Request 实例中的 `put` 方法 或者 `session` 助手函数：\r\n\r\n    // 通过 Request 实例存储 ...\r\n    $request->session()->put('key', 'value');\r\n\r\n    // 通过全局 Session 助手函数存储 ...\r\n    session(['key' => 'value']);\r\n\r\n<a name=\"pushing-to-array-session-values\"></a>\r\n#### Session 存储数组\r\n\r\n`push` 方法可以把一个新值推入到以数组形式存储的 session 值里。例如：如果  `user.teams` 键值对有一个关于团队名字的数组，你可以推入一个新值到这个数组里：\r\n\r\n    $request->session()->push('user.teams', 'developers');\r\n\r\n<a name=\"retrieving-deleting-an-item\"></a>\r\n#### 获取 & 删除条目\r\n\r\n`pull` 方法会从 Session 里获取并且删除一个条目，只需要一步如下：\r\n\r\n    $value = $request->session()->pull('key', 'default');\r\n\r\n<a name=\"#incrementing-and-decrementing-session-values\"></a>\r\n\r\n\r\n#### 递增 / 递减会话值\r\n\r\n如果你的会话数据包含有你希望递增或递减的整数，你可以使用 `increment` 和 `decrement` 方法：\r\n\r\n    $request->session()->increment('count');\r\n\r\n    $request->session()->increment('count', $incrementBy = 2);\r\n\r\n    $request->session()->decrement('count');\r\n\r\n    $request->session()->decrement('count', $decrementBy = 2);\r\n\r\n<a name=\"flash-data\"></a>\r\n### 闪存数据\r\n\r\n有时候你可能想在 Session 中保存数据用于下一次请求，这时你可以使用 `flash` 方法。使用这个方法保存在 Session 中的数据，只会保留到下一个 HTTP 请求到来之前，然后就会被删除。闪存数据主要用于短期的状态消息：\r\n\r\n    $request->session()->flash('status', 'Task was successful!');\r\n\r\n如果你需要在更多的请求中使用到该一次性数据，你可以使用 `reflash` 方法，该方法会将所有一次性数据保留到下一次请求。如果你想保存指定的一次性数据，你可以用 `keep` 方法：\r\n\r\n    $request->session()->reflash();\r\n\r\n    $request->session()->keep(['username', 'email']);\r\n\r\n要仅为当前请求保留闪存数据，你可以使用 `now` 方法：\r\n\r\n    $request->session()->now('status', 'Task was successful!');\r\n\r\n<a name=\"deleting-data\"></a>\r\n### 删除数据\r\n\r\n`forget` 方法会从 Session 中删除指定数据，如果想从 Session 中删除所有数据，可以使用 `flush` 方法：\r\n\r\n    // 删除单个值...\r\n    $request->session()->forget('name');\r\n\r\n    // 删除多个值...\r\n    $request->session()->forget(['name', 'status']);\r\n\r\n    $request->session()->flush();\r\n\r\n\r\n\r\n<a name=\"regenerating-the-session-id\"></a>\r\n### 重新生成 Session ID\r\n\r\n重新生成 Session ID 经常被用来阻止恶意用户使用 [Session Fixation](https://owasp.org/www-community/attacks/Session_fixation) 攻击你的应用。\r\n\r\n 如果你正在使用 [入门套件](/docs/laravel/9.x/starter-kits) 或者 [Laravel Fortify](/docs/laravel/9.x/fortify)中的任意一种， Laravel 会在认证阶段自动生成 Session ID；然而如果你需要手动重新生成 Session ID ，可以使用 `regenerate` 方法：\r\n\r\n    $request->session()->regenerate();\r\n\r\n如果你需要重新生成 Session ID 并同时删除所有 Session 里的数据，可以使用 `invalidate` 方法：\r\n\r\n    $request->session()->invalidate();\r\n\r\n<a name=\"session-blocking\"></a>\r\n## Session 阻塞\r\n\r\n> 注意：应用 Session 阻塞功能，你的应用必须使用一个支持 [原子锁](/docs/laravel/9.x/cache#atomic-locks) 的缓存驱动。目前，可用的缓存驱动有 `memcached`， `dynamodb`， `redis` 和 `database` 等。另外，你可能不会使用 `cookie` Session 驱动。\r\n\r\n默认情况下，Laravel 允许使用同一 Session 的请求并发地执行，举例来说，如果你使用一个 JavaScript HTTP 库向你的应用执行两次 HTTP 请求，它们将同时执行。对多数应用这不是问题，然而 在一小部分应用中可能出现 Session 数据丢失，这些应用会向两个不同的应用端并发请求，并同时写入数据到 Session。\r\n\r\n为了解决这个问题，Laravel 允许你限制指定 Session 的并发请求。首先，你可以在路由定义时使用`block` 链式方法。在这个示例中，一个到 `/profile` 的路由请求会拿到一把 Session 锁。当它处在锁定状态时，任何使用相同 Session ID 的到 `/profile` 或者`/order` 的路由请求都必须等待，直到第一个请求处理完成后再继续执行：\r\n\r\n    Route::post('/profile', function () {\r\n        //\r\n    })->block($lockSeconds = 10, $waitSeconds = 10)\r\n\r\n    Route::post('/order', function () {\r\n        //\r\n    })->block($lockSeconds = 10, $waitSeconds = 10)\r\n\r\n\r\n\r\n`block` 方法接受两个可选参数。第一个参数是 Session 锁在释放之前应保持的最大秒数。当然，如果程序在最大值前已执行完成，锁就会提前释放。\r\n\r\n第二个参数是尝试获得 Session 锁时等待的时间秒数。如果无法在设定的时间秒数内获得Session 锁，则抛出一个 `Illuminate\\Contracts\\Cache\\LockTimeoutException` 异常。\r\n\r\n如果不传参，那么 Session 锁默认锁定最大时间是10秒，请求锁最大的等待时间也是10秒：\r\n\r\n    Route::post('/profile', function () {\r\n        //\r\n    })->block()\r\n\r\n<a name=\"adding-custom-session-drivers\"></a>\r\n## 添加自定义 Session 驱动\r\n\r\n<a name=\"implementing-the-driver\"></a>\r\n#### 实现驱动\r\n\r\n如果现存的 Session 驱动不能满足你的需求，Laravel 允许你自定义 Session Handler。你的自定义驱动应实现 PHP 内置的 `SessionHandlerInterface` ，这个接口仅包含几个方法。以下是 MongoDB 驱动实现的代码片段：\r\n\r\n    <?php\r\n\r\n    namespace App\\Extensions;\r\n\r\n    class MongoSessionHandler implements \\SessionHandlerInterface\r\n    {\r\n        public function open($savePath, $sessionName) {}\r\n        public function close() {}\r\n        public function read($sessionId) {}\r\n        public function write($sessionId, $data) {}\r\n        public function destroy($sessionId) {}\r\n        public function gc($lifetime) {}\r\n    }\r\n\r\n> 技巧：Laravel 没有内置存放扩展的目录，你可以放置在任意目录下，这个示例里，我们创建了一个 `Extensions` 目录存放 `MongoSessionHandler` 。\r\n\r\n\r\n由于这些方法的含义并非通俗易懂，因此我们快速浏览下每个方法：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `open` 方法通常用于基于文件的 Session 存储系统。因为 Laravel 附带了一个 `file` Session 驱动。你无须在里面写任何代码。可以简单地忽略掉。\r\n- `close` 方法跟 `open` 方法很像，通常也可以忽略掉。对大多数驱动来说，它不是必须的。\r\n- `read` 方法应返回与给定的 `$sessionId` 关联的 Session 数据的字符串格式。在你的驱动中获取或存储 Session 数据时，无须作任何序列化和编码的操作，Laravel 会自动为你执行序列化。\r\n- `write` 方法将与 `$sessionId` 关联的给定的 `$data` 字符串写入到一些持久化存储系统，如 MongoDB 或者其他你选择的存储系统。再次，你无须进行任何序列化操作，Laravel 会自动为你处理。\r\n- `destroy` 方法应可以从持久化存储中删除与 `$sessionId` 相关联的数据。\r\n- `gc` 方法应可以销毁给定的 `$lifetime`（UNIX 时间戳格式 ）之前的所有 Session 数据。对于像 Memcached 和 Redis 这类拥有过期机制的系统来说，本方法可以置空。\r\n\r\n</div>\r\n\r\n<a name=\"registering-the-driver\"></a>\r\n#### 注册驱动\r\n\r\n一旦你的驱动实现了，需要注册到 Laravel 。在 Laravel 中添加额外的驱动到 Session 后端 ，你可以使用 `Session` [Facade](/docs/laravel/9.x/facades) 提供的 `extend` 方法。你应该在  [服务提供者](/docs/laravel/9.x/providers) 中的 `boot` 方法中调用 `extend` 方法。可以通过已有的 `App\\Providers\\AppServiceProvider` 或者创建一个新的服务提供者执行此操作：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Extensions\\MongoSessionHandler;\r\n    use Illuminate\\Support\\Facades\\Session;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class SessionServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 启动任意应用服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Session::extend('mongo', function ($app) {\r\n                // 返回一个 SessionHandlerInterface 接口的实现 ...\r\n                return new MongoSessionHandler;\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n\r\n一旦 Session 驱动注册完成，就可以在 `config/session.php` 配置文件选择使用 `mongo` 驱动。\r\n\r\n","p":"docs/session.html"},{"t":"validation (Validation)","d":"# Validation\r\n\r\n- [简介](#introduction)\r\n- [快速验证](#validation-quickstart)\r\n    - [定义路由](#quick-defining-the-routes)\r\n    - [创建控制器](#quick-creating-the-controller)\r\n    - [编写验证逻辑](#quick-writing-the-validation-logic)\r\n    - [显示验证的错误信息](#quick-displaying-the-validation-errors)\r\n    - [回填表单](#repopulating-forms)\r\n    - [可选字段的注意事项](#a-note-on-optional-fields)\r\n- [表单请求验证](#form-request-validation)\r\n    - [创建表单请求验证](#creating-form-requests)\r\n    - [表单请求认证授权](#authorizing-form-requests)\r\n    - [自定义验证错误信息](#customizing-the-error-messages)\r\n    - [准备验证数据](#preparing-input-for-validation)\r\n- [手动创建验证器](#manually-creating-validators)\r\n    - [自动重定向](#automatic-redirection)\r\n    - [命名错误信息包](#named-error-bags)\r\n    - [自定义错误信息](#manual-customizing-the-error-messages)\r\n    - [验证后的钩子](#after-validation-hook)\r\n- [处理验证字段](#working-with-validated-input)\r\n- [处理错误信息](#working-with-error-messages)\r\n    - [在语言文件中指定自定义消息](#specifying-custom-messages-in-language-files)\r\n    - [在语言文件中指定属性](#specifying-attribute-in-language-files)\r\n    - [在语言文件中指定值](#specifying-values-in-language-files)\r\n- [可用的验证规则](#available-validation-rules)\r\n- [按条件添加验证规则](#conditionally-adding-rules)\r\n- [数组的验证](#validating-arrays)\r\n    - [验证多维数组字段](#validating-nested-array-input)\r\n- [密码的验证](#validating-passwords)\r\n- [自定义验证规则](#custom-validation-rules)\r\n    - [使用规则类](#using-rule-objects)\r\n    - [使用闭包](#using-closures)\r\n    - [隐式规则](#implicit-rules)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 提供了几种不同的方法来验证传入应用程序的数据。最常见的做法是在所有传入的 HTTP 请求中使用 `validate` 方法。但是，我们还将讨论其他验证方法。\r\n\r\nLaravel 包含了各种方便的验证规则，你可以将它们应用于数据，甚至可以验证给定数据库表中的值是否唯一。我们将详细介绍每个验证规则，以便你熟悉 Laravel 的所有验证功能。\r\n\r\n\r\n\r\n<a name=\"validation-quickstart\"></a>\r\n## 快速验证\r\n\r\n为了了解 Laravel 强大的验证功能，我们来看一个表单验证并将错误消息展示给用户的完整示例。通过阅读概述，这将会对你如何使用 Laravel 验证传入的请求数据有一个很好的理解：\r\n\r\n<a name=\"quick-defining-the-routes\"></a>\r\n### 定义路由\r\n\r\n首先，假设我们在 `routes/web.php` 路由文件中定义了下面这些路由：\r\n\r\n    use App\\Http\\Controllers\\PostController;\r\n\r\n    Route::get('/post/create', [PostController::class, 'create']);\r\n    Route::post('/post', [PostController::class, 'store']);\r\n\r\n`GET` 路由会显示一个供用户创建新博客文章的表单，而 `POST` 路由会将新的博客文章存储到数据库中。\r\n\r\n<a name=\"quick-creating-the-controller\"></a>\r\n### 创建控制器\r\n\r\n接下来，让我们一起来看看处理这些路由的简单控制器。我们暂时留空了 store 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 显示创建博客文章的表单。\r\n         *\r\n         * @return \\Illuminate\\View\\View\r\n         */\r\n        public function create()\r\n        {\r\n            return view('post.create');\r\n        }\r\n\r\n        /**\r\n         * 存储一篇新的博客文章。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            // Validate and store the blog post...\r\n        }\r\n    }\r\n\r\n<a name=\"quick-writing-the-validation-logic\"></a>\r\n### 编写验证逻辑\r\n\r\n现在我们开始在 `store` 方法中编写用来验证新的博客文章的逻辑代码。为此，我们将使用 `Illuminate\\Http\\Request` 类提供的 `validate` 方法。如果验证通过，你的代码会继续正常运行。如果验证失败，则会抛出`Illuminate\\Validation\\ValidationException`异常，并自动将对应的错误响应返回给用户。\r\n\r\n\r\n如果在传统 HTTP 请求期间验证失败，则会生成对先前 URL 的重定向响应。如果传入的请求是 XHR，将将返回包含验证错误信息的 JSON 响应。\r\n\r\n为了深入理解 `validate` 方法，让我们接着回到 `store` 方法中：\r\n\r\n    /**\r\n     * 存储一篇新的博客文章。\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return \\Illuminate\\Http\\Response\r\n     */\r\n    public function store(Request $request)\r\n    {\r\n        $validated = $request->validate([\r\n            'title' => 'required|unique:posts|max:255',\r\n            'body' => 'required',\r\n        ]);\r\n\r\n        // 博客文章验证通过...\r\n    }\r\n\r\n如您所见，验证规则被传递到 `validate` 方法中。不用担心 - 所有可用的验证规则均已[记录在案](#available-validation-rules)。另外再提醒一次，如果验证失败，会自动生成一个对应的响应。如果验证通过，那我们的控制器会继续正常运行。\r\n或者，验证规则可以使用数组而不是单个 `|` 分隔的字符串：\r\n\r\n    $validatedData = $request->validate([\r\n        'title' => ['required', 'unique:posts', 'max:255'],\r\n        'body' => ['required'],\r\n    ]);\r\n\r\n\r\n另外，你可以使用 `validateWithBag` 方法来验证请求，并将所有错误信息储存在一个[命名错误信息包](#named-error-bags)：\r\n\r\n    $validatedData = $request->validateWithBag('post', [\r\n        'title' => ['required', 'unique:posts', 'max:255'],\r\n        'body' => ['required'],\r\n    ]);\r\n\r\n<a name=\"stopping-on-first-validation-failure\"></a>\r\n#### 在首次验证失败时停止运行\r\n\r\n有时候我们希望某个字段在第一次验证失败后就停止运行验证规则，只需要将 `bail` 添加到规则中\r\n\r\n    $request->validate([\r\n        'title' => 'bail|required|unique:posts|max:255',\r\n        'body' => 'required',\r\n    ]);\r\n\r\n在这个例子中，如果 `title` 字段没有通过 `unique` 规则，那么不会继续验证 `max` 规则。规则会按照分配时的顺序来验证。\r\n\r\n\r\n\r\n<a name=\"a-note-on-nested-attributes\"></a>\r\n#### 嵌套字段的说明\r\n\r\n如果你的 HTTP 请求包含「嵌套」参数，你可以在验证规则中使用 `.` 语法来指定这些参数：\r\n\r\n    $request->validate([\r\n        'title' => 'required|unique:posts|max:255',\r\n        'author.name' => 'required',\r\n        'author.description' => 'required',\r\n    ]);\r\n\r\n另外，如果你的字段名称包含点，则可以通过使用反斜杠将点转义，以防止将其解释为 `.` 语法：\r\n\r\n    $request->validate([\r\n        'title' => 'required|unique:posts|max:255',\r\n        'v1\\.0' => 'required',\r\n    ]);\r\n\r\n<a name=\"quick-displaying-the-validation-errors\"></a>\r\n### 显示验证错误信息\r\n\r\n那么，如果传入的请求参数未通过给定的验证规则呢？正如前面所提到的，Laravel 会自动将用户重定向到之前的位置。另外，所有的验证错误信息和 [请求输入](/docs/laravel/9.x/requests#retrieving-old-input) 都将自动存储到 [闪存 session](/docs/laravel/9.x/session#flash-data) 中。\r\n\r\n`Illuminate\\View\\Middleware\\ShareErrorsFromSession` 中间件与应用程序的所有视图共享一个 `$errors` 变量，该变量由 `web` 中间件组提供。当应用该中间件时，`$errors` 变量在你的视图中始终可用，从而使你可以方便地假定 `$errors` 变量始终被定义并且可以安全地使用。`$errors` 变量是`Illuminate\\Support\\MessageBag` 的一个实例。有关使用此对象的更多信息，请 [参阅这篇文档](#working-with-error-messages)。\r\n\r\n所以，在如下的例子中，当表单验证失败时，用户将被重定向到控制器的 `create` 方法中，我们可在视图中显示错误信息：\r\n\r\n```blade\r\n<!-- /resources/views/post/create.blade.php -->\r\n\r\n<h1>Create Post</h1>\r\n\r\n@if ($errors->any())\r\n    <div class=\"alert alert-danger\">\r\n        <ul>\r\n            @foreach ($errors->all() as $error)\r\n                <li>{{ $error }}</li>\r\n            @endforeach\r\n        </ul>\r\n    </div>\r\n@endif\r\n\r\n<!-- Create Post Form -->\r\n```\r\n\r\n\r\n\r\n<a name=\"quick-customizing-the-error-messages\"></a>\r\n#### 自定义错误消息\r\n\r\nLaravel 的内置验证规则每个都有一条错误消息，位于应用程序的 `lang/en/validation.php` 文件中。在此文件中，你将找到每个验证规则的翻译条目。你可以根据应用程序的需求随意更改或修改这些消息。\r\n\r\n此外，你可以将此文件复制到另一个翻译语言的目录中，以翻译应用程序语言的消息。要了解有关 Laravel 本地化的更多信息，请查看完整的 [本地化文档](/docs/laravel/9.x/localization)。\r\n\r\n<a name=\"quick-xhr-requests-and-validation\"></a>\r\n#### XHR 请求 & 验证\r\n\r\n在如下示例中，我们使用传统形式将数据发送到应用程序。但是，许多应用程序从 JavaScript 驱动的前端接收 XHR 请求。在 XHR 请求期间使用 `validate` 方法时，Laravel 将不会生成重定向响应。相反，Laravel 会生成一个包含所有验证错误的 JSON 响应。该 JSON 响应将以 `422` HTTP 状态码发送。\r\n\r\n<a name=\"the-at-error-directive\"></a>\r\n#### `@error` 指令\r\n\r\n你亦可使用 `@error` [Blade](/docs/laravel/9.x/blade) 指令方便地检查给定的属性是否存在验证错误信息。在 `@error` 指令中，你可以输出 `$message` 变量以显示错误信息：\r\n\r\n```blade\r\n<!-- /resources/views/post/create.blade.php -->\r\n\r\n<label for=\"title\">Post Title</label>\r\n\r\n<input id=\"title\"\r\n    type=\"text\"\r\n    name=\"title\"\r\n    class=\"@error('title') is-invalid @enderror\">\r\n\r\n@error('title')\r\n    <div class=\"alert alert-danger\">{{ $message }}</div>\r\n@enderror\r\n```\r\n\r\n如果您使用 [命名错误包](#named-error-bags)，您可以将错误包的名称作为第二个参数传递给 `@error` 指令：\r\n\r\n```blade\r\n<input ... class=\"@error('title', 'post') is-invalid @enderror\">\r\n```\r\n\r\n\r\n\r\n<a name=\"repopulating-forms\"></a>\r\n### 回填表单\r\n\r\n当 Laravel 由于验证错误而生成重定向响应时，框架将自动 [将所有请求的输入闪存到 session 中](/docs/laravel/9.x/session#flash-data)。这样做是为了方便你在下一个请求期间访问输入，并重新填充用户尝试提交的表单。\r\n\r\n要从先前的请求中检索闪存的输入，请在 `Illuminate\\Http\\Request` 的实例上调用 `old` 方法。 `old` 方法将从 [session](/docs/laravel/9.x/session) 中提取先前闪存的输入数据：\r\n\r\n    $title = $request->old('title');\r\n\r\nLaravel 还提供了一个全局性的 `old`。如果要在 [Blade 模板](/docs/laravel/9.x/blade) 中显示旧输入，则使用 `old` 来重新填充表单会更加方便。如果给定字段不存在旧输入，则将返回 `null`：\r\n\r\n```blade\r\n<input type=\"text\" name=\"title\" value=\"{{ old('title') }}\">\r\n```\r\n\r\n<a name=\"a-note-on-optional-fields\"></a>\r\n### 关于可选字段的注意事项\r\n\r\n默认情况下， 在您的 Laravel 应用的全局中间件堆栈 `App\\Http\\Kernel` 类中包含了 `TrimStrings` 和 `ConvertEmptyStringsToNull` 中间件。因此，如果你不想让 `null` 被验证器标识为非法的话，你需要将「可选」字段标志为 `nullable`。例如：\r\n\r\n    $request->validate([\r\n        'title' => 'required|unique:posts|max:255',\r\n        'body' => 'required',\r\n        'publish_at' => 'nullable|date',\r\n    ]);\r\n\r\n在上述例子中，我们指定了 `publish_at` 字段可以是`null`的或者是一个有效的日期格式。如果 `nullable` 修饰词没有被添加到规则定义中，验证器会将 `null` 视为无效的日期格式。\r\n\r\n\r\n\r\n<a name=\"form-request-validation\"></a>\r\n## 验证表单请求\r\n\r\n<a name=\"creating-form-requests\"></a>\r\n### 创建表单请求验证\r\n\r\n面对更复杂的验证场景，您可以创建一个「表单请求」。表单请求是一个包含了验证逻辑的自定义请求类。要创建一个表单请求类，请使用 `make:request` Artisan CLI 命令：\r\n\r\n```shell\r\nphp artisan make:request StorePostRequest\r\n```\r\n\r\n该命令生成的表单请求类将被置于 `app/Http/Requests` 目录中。如果这个目录不存在，在您运行 `make:request` 命令后将会创建这个目录。Laravel 生成的每个表单请求都有两个方法：`authorize` 和 `rules`。\r\n\r\n正如您可能已经猜到的那样，`authorize` 方法负责确定当前经过身份验证的用户是否可以执行请求操作，而 `rules` 方法则返回适用于请求数据的验证规则：\r\n\r\n    /**\r\n     * 获取应用于该请求的验证规则。\r\n     *\r\n     * @return array\r\n     */\r\n    public function rules()\r\n    {\r\n        return [\r\n            'title' => 'required|unique:posts|max:255',\r\n            'body' => 'required',\r\n        ];\r\n    }\r\n\r\n> 技巧：你可以向 `rules` 方法传入所需的任何依赖项。它们将被 Laravel [服务容器](/docs/laravel/9.x/container) 自动解析。\r\n\r\n所以，验证规则是如何运行的呢？您所需要做的就是在控制器方法中类型提示传入的请求。在调用控制器方法之前验证传入的表单请求，这意味着您不需要在控制器中写任何验证逻辑：\r\n\r\n    /**\r\n     * 存储新的博客文章。\r\n     *\r\n     * @param  \\App\\Http\\Requests\\StorePostRequest  $request\r\n     * @return Illuminate\\Http\\Response\r\n     */\r\n    public function store(StorePostRequest $request)\r\n    {\r\n        // 传入的请求通过验证...\r\n\r\n        // 获取通过验证的数据...\r\n        $validated = $request->validated();\r\n\r\n        // 获取部分通过验证的数据...\r\n        $validated = $request->safe()->only(['name', 'email']);\r\n        $validated = $request->safe()->except(['name', 'email']);\r\n    }\r\n\r\n\r\n\r\n如果验证失败，就会生成一个让用户返回到先前位置的重定向响应。这些错误也会被闪存到 session 中，以便这些错误都可以在页面中显示出来。如果传入的请求是 XHR，会向用户返回具有 422 状态代码和验证错误信息的 JSON 数据的 HTTP 响应。\r\n\r\n<a name=\"adding-after-hooks-to-form-requests\"></a>\r\n#### 在表单请求后添加钩子\r\n\r\n如果您想在表单请求「之后」添加验证钩子，可以使用 `withValidator` 方法。这个方法接收一个完整的验证构造器，允许你在验证结果返回之前调用任何方法：\r\n\r\n    /**\r\n     * 配置验证实例。\r\n     *\r\n     * @param  \\Illuminate\\Validation\\Validator  $validator\r\n     * @return void\r\n     */\r\n    public function withValidator($validator)\r\n    {\r\n        $validator->after(function ($validator) {\r\n            if ($this->somethingElseIsInvalid()) {\r\n                $validator->errors()->add('field', 'Something is wrong with this field!');\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n<a name=\"request-stopping-on-first-validation-rule-failure\"></a>\r\n#### 单个验证规则失败后停止\r\n\r\n通过向您的请求类添加 `stopOnFirstFailure` 属性，您可以通知验证器一旦发生单个验证失败后，停止验证所有规则。\r\n\r\n    /**\r\n     * 表示验证器是否应在第一个规则失败时停止。\r\n     *\r\n     * @var bool\r\n     */\r\n    protected $stopOnFirstFailure = true;\r\n\r\n<a name=\"customizing-the-redirect-location\"></a>\r\n#### 自定义重定向\r\n\r\n如前所述，当表单请求验证失败时，将会生成一个让用户返回到先前位置的重定向响应。当然，您也可以自由定义此行为。如果您要这样做，可以在表单请求中定义一个 `$redirect` 属性：\r\n\r\n    /**\r\n     * 如果验证失败，用户应重定向到的 URI。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $redirect = '/dashboard';\r\n\r\n\r\n\r\n或者，如果你想将用户重定向到一个命名路由，你可以定义一个 `$redirectRoute` 属性来代替：\r\n\r\n    /**\r\n     * 如果验证失败，用户应该重定向到的路由。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $redirectRoute = 'dashboard';\r\n\r\n<a name=\"authorizing-form-requests\"></a>\r\n### 表单请求授权验证\r\n\r\n表单请求类内也包含了 `authorize` 方法。在这个方法中，您可以检查经过身份验证的用户确定其是否具有更新给定资源的权限。例如，您可以判断用户是否拥有更新文章评论的权限。最有可能的是，您将通过以下方法与你的 [授权与策略](/docs/laravel/9.x/authorization) 进行交互：\r\n\r\n    use App\\Models\\Comment;\r\n\r\n    /**\r\n     * 确定用户是否有请求权限。\r\n     *\r\n     * @return bool\r\n     */\r\n    public function authorize()\r\n    {\r\n        $comment = Comment::find($this->route('comment'));\r\n\r\n        return $comment && $this->user()->can('update', $comment);\r\n    }\r\n\r\n由于所有的表单请求都是继承了 Laravel 中的请求基类，所以我们可以使用 `user` 方法去获取当前认证登录的用户。同时请注意上述例子中对 `route` 方法的调用。这个方法允许你在被调用的路由上获取其定义的 URI 参数，譬如下面例子中的 `{comment}` 参数：\r\n\r\n    Route::post('/comment/{comment}');\r\n\r\n因此，如果您的应用程序正在使用 [路由模型绑定](/docs/laravel/9.x/routing#route-model-binding)，则可以通过将解析的模型作为请求从而让您的代码更加简洁：\r\n\r\n    return $this->user()->can('update', $this->comment);\r\n\r\n如果 `authorize` 方法返回 `false`，则会自动返回一个包含 403 状态码的 HTTP 响应，也不会运行控制器的方法。\r\n\r\n\r\n\r\n如果您打算在应用程序的其它部分处理请求的授权逻辑，只需从 `authorize` 方法返回 `true`：\r\n\r\n    /**\r\n     * 判断用户是否有请求权限。\r\n     *\r\n     * @return bool\r\n     */\r\n    public function authorize()\r\n    {\r\n        return true;\r\n    }\r\n\r\n> 技巧：你可以向 `authorize` 方法传入所需的任何依赖项。它们会自动被 Laravel 提供的 [服务容器](/docs/laravel/9.x/container) 自动解析。\r\n\r\n<a name=\"customizing-the-error-messages\"></a>\r\n### 自定义错误消息\r\n\r\n你可以通过重写表单请求的 `messages` 方法来自定义错误消息。此方法应返回属性 / 规则对及其对应错误消息的数组：\r\n\r\n    /**\r\n     * 获取已定义验证规则的错误消息。\r\n     *\r\n     * @return array\r\n     */\r\n    public function messages()\r\n    {\r\n        return [\r\n            'title.required' => 'A title is required',\r\n            'body.required' => 'A message is required',\r\n        ];\r\n    }\r\n\r\n<a name=\"customizing-the-validation-attributes\"></a>\r\n#### 自定义验证属性\r\n\r\nLaravel 的许多内置验证规则错误消息都包含 `:attribute` 占位符。如果您希望将验证消息的 `:attribute` 部分替换为自定义属性名称，则可以重写 `attributes` 方法来指定自定义名称。此方法应返回属性 / 名称对的数组：\r\n\r\n    /**\r\n     * 获取验证错误的自定义属性\r\n     *\r\n     * @return array\r\n     */\r\n    public function attributes()\r\n    {\r\n        return [\r\n            'email' => 'email address',\r\n        ];\r\n    }\r\n\r\n<a name=\"preparing-input-for-validation\"></a>\r\n### 准备验证输入\r\n\r\n如果您需要在应用验证规则之前修改或清理请求中的任何数据，您可以使用 `prepareForValidation` 方法：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    /**\r\n     * 准备验证数据。\r\n     *\r\n     * @return void\r\n     */\r\n    protected function prepareForValidation()\r\n    {\r\n        $this->merge([\r\n            'slug' => Str::slug($this->slug),\r\n        ]);\r\n    }\r\n\r\n\r\n\r\n<a name=\"manually-creating-validators\"></a>\r\n## 手动创建验证器\r\n\r\n如果您不想在请求中使用 `validate` 方法，您可以使用 `Validator` [门面](/docs/laravel/9.x/facades) 手动创建一个验证器实例。门面中的 `make` 方法将会生成一个新的验证器实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 存储一篇博客文章。\r\n         *\r\n         * @param  Request  $request\r\n         * @return Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $validator = Validator::make($request->all(), [\r\n                'title' => 'required|unique:posts|max:255',\r\n                'body' => 'required',\r\n            ]);\r\n\r\n            if ($validator->fails()) {\r\n                return redirect('post/create')\r\n                            ->withErrors($validator)\r\n                            ->withInput();\r\n            }\r\n\r\n            // 获取通过验证的数据...\r\n            $validated = $validator->validated();\r\n\r\n            // 获取部分通过验证的数据...\r\n            $validated = $validator->safe()->only(['name', 'email']);\r\n            $validated = $validator->safe()->except(['name', 'email']);\r\n\r\n            //存储博客文章...\r\n        }\r\n    }\r\n\r\n`make` 方法中的第一个参数是期望校验的数据。第二个参数是应用到数据上的校验规则。\r\n\r\n如果校验失败，您可以使用 `withErrors` 方法将错误信息闪存至 session 中。使用该方法时，`$errors` 会自动与之后的视图共享，您可以很方便将其回显给用户。`withErrors` 方法接受验证器实例，`MessageBag` 或是 PHP `数组`。\r\n\r\n#### 单个验证规则失败后停止\r\n\r\n`stopOnFirstFailure` 方法将通知验证器，一旦发生单个验证失败，它应该停止验证所有属性\r\n\r\n    if ($validator->stopOnFirstFailure()->fails()) {\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n<a name=\"automatic-redirection\"></a>\r\n### 自动重定向\r\n\r\n如果您想要在手动创建验证器实例的同时，使用请求的 `validate` 方法的自动重定向功能，那么您可以在现有的验证器实例上调用 `validate` 方法。如果校验失败，用户将被自动重定向，或在 XHR 请求下，将会返回一个 JSON 响应：\r\n\r\n    Validator::make($request->all(), [\r\n        'title' => 'required|unique:posts|max:255',\r\n        'body' => 'required',\r\n    ])->validate();\r\n\r\n如果校验失败，您可以使用 `validateWithBag` 方法将错误信息存储到 [命名错误包](#named-error-bags) 中\r\n\r\n    Validator::make($request->all(), [\r\n        'title' => 'required|unique:posts|max:255',\r\n        'body' => 'required',\r\n    ])->validateWithBag('post');\r\n\r\n<a name=\"named-error-bags\"></a>\r\n### 命名错误包\r\n\r\n如果您的一个页面中存在多个表单，您可以为错误的 `MessageBag` 命名，用于检索指定表单的错误信息。只需将名称作为 `withErrors` 的第二个参数传递给它：\r\n\r\n    return redirect('register')->withErrors($validator, 'login');\r\n\r\n您可以通过 `$errors` 变量访问命名后的 `MessageBag` 实例：\r\n\r\n```blade\r\n{{ $errors->login->first('email') }}\r\n```\r\n\r\n<a name=\"manual-customizing-the-error-messages\"></a>\r\n### 自定义错误消息\r\n\r\n如果需要，您可以提供验证程序实例使用的自定义错误消息，而不是 Laravel 提供的默认错误消息。有几种指定自定义消息的方法。首先，您可以将自定义消息作为第三个参数传递给 `Validator::make` 方法：\r\n\r\n    $validator = Validator::make($input, $rules, $messages = [\r\n        'required' => 'The :attribute field is required.',\r\n    ]);\r\n\r\n\r\n\r\n在此示例中，`:attribute` 占位符将被验证中的字段的实际名称替换。您也可以在验证消息中使用其它占位符。例如：\r\n\r\n    $messages = [\r\n        'same' => 'The :attribute and :other must match.',\r\n        'size' => 'The :attribute must be exactly :size.',\r\n        'between' => 'The :attribute value :input is not between :min - :max.',\r\n        'in' => 'The :attribute must be one of the following types: :values',\r\n    ];\r\n\r\n<a name=\"specifying-a-custom-message-for-a-given-attribute\"></a>\r\n#### 为给定属性指定自定义消息\r\n\r\n有时您可能希望只为特定属性指定自定义错误消息。您可以使用 `.` 表示法。首先指定属性名称，然后指定规则：\r\n\r\n    $messages = [\r\n        'email.required' => 'We need to know your email address!',\r\n    ];\r\n\r\n<a name=\"specifying-custom-attribute-values\"></a>\r\n#### 指定自定义属性值\r\n\r\nLaravel 的许多内置错误消息都包含一个 `:attribute` 占位符，该占位符已被验证中的字段或属性的名称替换。为了自定义用于替换特定字段的这些占位符的值，你可以将自定义属性的数组作为第四个参数传递给 `Validator::make` 方法：\r\n\r\n    $validator = Validator::make($input, $rules, $messages, [\r\n        'email' => 'email address',\r\n    ]);\r\n\r\n<a name=\"after-validation-hook\"></a>\r\n### 验证后钩子\r\n\r\n验证器允许您在完成验证操作后执行附加的回调。以便您处理下一步的验证，甚至是往信息集合中添加更多的错误信息。您可以在验证器实例上使用 `after` 方法实现：\r\n\r\n    $validator = Validator::make(...);\r\n\r\n    $validator->after(function ($validator) {\r\n        if ($this->somethingElseIsInvalid()) {\r\n            $validator->errors()->add(\r\n                'field', 'Something is wrong with this field!'\r\n            );\r\n        }\r\n    });\r\n\r\n    if ($validator->fails()) {\r\n        //\r\n    }\r\n\r\n\r\n\r\n<a name=\"working-with-validated-input\"></a>\r\n## 处理验证字段\r\n\r\n在使用表单请求或手动创建的验证器实例验证传入请求数据后，您可能希望检索经过验证的请求数据。 这可以通过多种方式实现。 首先，您可以在表单请求或验证器实例上调用 `validated` 方法。 此方法返回已验证的数据数组：\r\n\r\n    $validated = $request->validated();\r\n\r\n    $validated = $validator->validated();\r\n\r\n或者，您可以在表单请求或验证器实例上调用 `safe` 方法。 此方法返回一个 `Illuminate\\Support\\ValidatedInput` 的实例。 该实例对象包含 `only`、`except` 和 `all` 方法来检索已验证数据的子集或整个已验证数据数组：\r\n\r\n    $validated = $request->safe()->only(['name', 'email']);\r\n\r\n    $validated = $request->safe()->except(['name', 'email']);\r\n\r\n    $validated = $request->safe()->all();\r\n\r\n此外，`Illuminate\\Support\\ValidatedInput` 实例可以像数组一样被迭代和访问：\r\n\r\n    // 迭代验证数据...\r\n    foreach ($request->safe() as $key => $value) {\r\n        //\r\n    }\r\n\r\n    // 访问验证数据数组...\r\n    $validated = $request->safe();\r\n\r\n    $email = $validated['email'];\r\n\r\n如果您想向已验证的数据添加其它字段，您可以调用 `merge` 方法：\r\n\r\n    $validated = $request->safe()->merge(['name' => 'Taylor Otwell']);\r\n\r\n如果您想将经过验证的数据作为 [collection](/docs/laravel/9.x/collections) 实例检索，您可以调用 `collect` 方法：\r\n\r\n    $collection = $request->safe()->collect();\r\n\r\n<a name=\"working-with-error-messages\"></a>\r\n## 处理错误信息\r\n\r\n通过 `Validator` 实例调用 `errors` 方法，它会返回一个 `Illuminate\\Support\\MessageBag` 实例，该实例包含了各种可以很方便地处理错误信息的方法。并自动给所有视图提供 `$errors` 变量，也是 `MessageBag` 类的一个实例。\r\n\r\n\r\n\r\n<a name=\"retrieving-the-first-error-message-for-a-field\"></a>\r\n#### 检索特定字段的第一个错误信息\r\n\r\n您可以使用 `first` 方法检索给定字段的第一个错误信息：\r\n\r\n    $errors = $validator->errors();\r\n\r\n    echo $errors->first('email');\r\n\r\n<a name=\"retrieving-all-error-messages-for-a-field\"></a>\r\n#### 检索特定字段的所有错误信息\r\n\r\n您可以使用 `get` 方法检索给定字段所有信息的数组：\r\n\r\n    foreach ($errors->get('email') as $message) {\r\n        //\r\n    }\r\n\r\n如果要验证表单的数组字段，您可以使用 `*` 字符来获取每一个数组元素的所有错误信息：\r\n\r\n    foreach ($errors->get('attachments.*') as $message) {\r\n        //\r\n    }\r\n\r\n<a name=\"retrieving-all-error-messages-for-all-fields\"></a>\r\n#### 检索所有字段的所有错误信息\r\n\r\n您可以使用 all 方法获取所有字段的所有错误信息的数组：\r\n\r\n    foreach ($errors->all() as $message) {\r\n        //\r\n    }\r\n\r\n<a name=\"determining-if-messages-exist-for-a-field\"></a>\r\n#### 判断特定字段是否含有错误信息\r\n\r\n`has` 方法可用于判断给定字段是否包含任何错误信息：\r\n\r\n    if ($errors->has('email')) {\r\n        //\r\n    }\r\n\r\n<a name=\"specifying-custom-messages-in-language-files\"></a>\r\n### 在语言文件中指定自定义消息\r\n\r\nLaravel 的内置验证规则每个都对应一个错误消息，位于应用程序的 `lang/en/validation.php` 文件中。在此文件中，您将找到每个验证规则的翻译条目。您可以根据应用程序的需求随意更改或修改这些消息。\r\n\r\n此外，您可以将此文件复制到另一个翻译语言目录中，以翻译应用程序语言的消息。要了解有关 Laravel 本地化的更多信息，请查看完整的[本地化文档](/docs/laravel/9.x/localization)。\r\n\r\n\r\n\r\n<a name=\"custom-messages-for-specific-attributes\"></a>\r\n#### 特定属性的自定义消息\r\n\r\n您可以在应用程序的验证语言文件中自定义用于指定属性和规则组合的错误消息。为此，请将消息自定义项添加到应用程序的 `lang/xx/validation.php` 语言文件的 `custom` 数组中：\r\n\r\n    'custom' => [\r\n        'email' => [\r\n            'required' => 'We need to know your email address!',\r\n            'max' => 'Your email address is too long!'\r\n        ],\r\n    ],\r\n\r\n<a name=\"specifying-attribute-in-language-files\"></a>\r\n### 在语言文件中指定属性\r\n\r\nLaravel 的许多内置错误消息都包含一个 `:attribute：` 占位符，该占位符已被验证中的字段或属性的名称替换。如果您希望将验证消息的 `:attribute` 部分替换为自定义值，则可以在 `lang/xx/validation.php` 语言文件的 `attributes` 数组中指定自定义属性名称：\r\n\r\n    'attributes' => [\r\n        'email' => 'email address',\r\n    ],\r\n\r\n<a name=\"specifying-values-in-language-files\"></a>\r\n### 在语言文件中指定值\r\n\r\nLaravel 的一些内置验证规则错误消息中包含一个 `:value` 占位符，该占位符被 request 属性的当前值替换。但是，有时你可能需要将验证消息的 `:value` 部分替换为该值的自定义表示形式。例如，考虑以下规则，该规则指定如果 `payment_type` 的值为 `cc`，则要求提供信用卡号：\r\n\r\n    Validator::make($request->all(), [\r\n        'credit_card_number' => 'required_if:payment_type,cc'\r\n    ]);\r\n\r\n如果此验证规则失败，将产生以下错误消息：\r\n\r\n```none\r\nThe credit card number field is required when payment type is cc.\r\n```\r\n\r\n\r\n\r\n你可以通过定义 `values` 数组在 `lang/xx/validation.php` 语言文件中指定更用户友好的提示，而不是将 `cc` 显示为支付类型值：\r\n\r\n    'values' => [\r\n        'payment_type' => [\r\n            'cc' => 'credit card'\r\n        ],\r\n    ],\r\n\r\n定义了 values 后，验证规则将产生以下错误消息：\r\n\r\n```none\r\nThe credit card number field is required when payment type is credit card.\r\n```\r\n\r\n<a name=\"available-validation-rules\"></a>\r\n## 可用的验证规则\r\n\r\n下方列出了所有可用的验证规则及其功能：\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\r\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[Accepted](#rule-accepted)\r\n[Accepted If](#rule-accepted-if)\r\n[Active URL](#rule-active-url)\r\n[After (Date)](#rule-after)\r\n[After Or Equal (Date)](#rule-after-or-equal)\r\n[Alpha](#rule-alpha)\r\n[Alpha Dash](#rule-alpha-dash)\r\n[Alpha Numeric](#rule-alpha-num)\r\n[Array](#rule-array)\r\n[Bail](#rule-bail)\r\n[Before (Date)](#rule-before)\r\n[Before Or Equal (Date)](#rule-before-or-equal)\r\n[Between](#rule-between)\r\n[Boolean](#rule-boolean)\r\n[Confirmed](#rule-confirmed)\r\n[Current Password](#rule-current-password)\r\n[Date](#rule-date)\r\n[Date Equals](#rule-date-equals)\r\n[Date Format](#rule-date-format)\r\n[Declined](#rule-declined)\r\n[Declined If](#rule-declined-if)\r\n[Different](#rule-different)\r\n[Digits](#rule-digits)\r\n[Digits Between](#rule-digits-between)\r\n[Dimensions (Image Files)](#rule-dimensions)\r\n[Distinct](#rule-distinct)\r\n[Email](#rule-email)\r\n[Ends With](#rule-ends-with)\r\n[Enum](#rule-enum)\r\n[Exclude](#rule-exclude)\r\n[Exclude If](#rule-exclude-if)\r\n[Exclude Unless](#rule-exclude-unless)\r\n[Exclude Without](#rule-exclude-without)\r\n[Exists (Database)](#rule-exists)\r\n[File](#rule-file)\r\n[Filled](#rule-filled)\r\n[Greater Than](#rule-gt)\r\n[Greater Than Or Equal](#rule-gte)\r\n[Image (File)](#rule-image)\r\n[In](#rule-in)\r\n[In Array](#rule-in-array)\r\n[Integer](#rule-integer)\r\n[IP Address](#rule-ip)\r\n[MAC Address](#rule-mac)\r\n[JSON](#rule-json)\r\n[Less Than](#rule-lt)\r\n[Less Than Or Equal](#rule-lte)\r\n[Max](#rule-max)\r\n[MIME Types](#rule-mimetypes)\r\n[MIME Type By File Extension](#rule-mimes)\r\n[Min](#rule-min)\r\n[Multiple Of](#multiple-of)\r\n[Not In](#rule-not-in)\r\n[Not Regex](#rule-not-regex)\r\n[Nullable](#rule-nullable)\r\n[Numeric](#rule-numeric)\r\n[Password](#rule-password)\r\n[Present](#rule-present)\r\n[Prohibited](#rule-prohibited)\r\n[Prohibited If](#rule-prohibited-if)\r\n[Prohibited Unless](#rule-prohibited-unless)\r\n[Prohibits](#rule-prohibits)\r\n[Regular Expression](#rule-regex)\r\n[Required](#rule-required)\r\n[Required If](#rule-required-if)\r\n[Required Unless](#rule-required-unless)\r\n[Required With](#rule-required-with)\r\n[Required With All](#rule-required-with-all)\r\n[Required Without](#rule-required-without)\r\n[Required Without All](#rule-required-without-all)\r\n[Required Array Keys](#rule-required-array-keys)\r\n[Same](#rule-same)\r\n[Size](#rule-size)\r\n[Sometimes](#validating-when-present)\r\n[Starts With](#rule-starts-with)\r\n[String](#rule-string)\r\n[Timezone](#rule-timezone)\r\n[Unique (Database)](#rule-unique)\r\n[URL](#rule-url)\r\n[UUID](#rule-uuid)\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"rule-accepted\"></a>\r\n#### accepted\r\n\r\n待验证字段必须是 `yes` ，`on` ，`1` 或 `true`。这对于验证「服务条款」的接受或类似字段时很有用。\r\n\r\n<a name=\"rule-accepted-if\"></a>\r\n#### accepted_if:anotherfield,value,...\r\n\r\n如果另一个正在验证的字段等于指定的值，则验证中的字段必须为 `yes` ，`on` ，`1` 或 `true`。 这对于验证「服务条款」接受或类似字段很有用。\r\n\r\n<a name=\"rule-active-url\"></a>\r\n#### active_url\r\n\r\n根据 `dns_get_record` PHP 函数，验证中的字段必须具有有效的 A 或 AAAA 记录。 提供的 URL 的主机名使用 `parse_url` PHP 函数提取，然后传递给 `dns_get_record`。\r\n\r\n<a name=\"rule-after\"></a>\r\n#### after:_date_\r\n\r\n验证中的字段必须是给定日期之后的值。日期将被传递给 `strtotime` PHP 函数中，以便转换为有效的 `DateTime` 实例：\r\n\r\n    'start_date' => 'required|date|after:tomorrow'\r\n\r\n你也可以指定另一个要与日期比较的字段，而不是传递要由 strtotime 处理的日期字符串：\r\n\r\n    'finish_date' => 'required|date|after:start_date'\r\n\r\n<a name=\"rule-after-or-equal\"></a>\r\n#### after\\_or\\_equal:_date_\r\n\r\n待验证字段的值对应的日期必须在给定日期之后或与给定的日期相同。可参阅 [after](#rule-after) 规则获取更多信息。\r\n\r\n<a name=\"rule-alpha\"></a>\r\n#### alpha\r\n\r\n待验证字段只能由字母组成。\r\n\r\n<a name=\"rule-alpha-dash\"></a>\r\n#### alpha_dash\r\n\r\n待验证字段可以含有字母、数字，短破折号（-）和下划线（_）。\r\n\r\n\r\n\r\n<a name=\"rule-alpha-num\"></a>\r\n#### alpha_num\r\n\r\n待验证字段只能由字母和数字组成。\r\n\r\n<a name=\"rule-array\"></a>\r\n#### array\r\n\r\n待验证字段必须是有效的 PHP 数组。\r\n\r\n当向 `array` 规则提供附加值时，输入数组中的每个键都必须出现在提供给规则的值列表中。在以下示例中，输入数组中的 `admin` 键无效，因为它不包含在提供给 `array` 规则的值列表中：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $input = [\r\n        'user' => [\r\n            'name' => 'Taylor Otwell',\r\n            'username' => 'taylorotwell',\r\n            'admin' => true,\r\n        ],\r\n    ];\r\n\r\n    Validator::make($input, [\r\n        'user' => 'array:username,locale',\r\n    ]);\r\n\r\n通常，你应该始终指定允许出现在数组中的数组键。\r\n\r\n<a name=\"rule-bail\"></a>\r\n#### bail\r\n\r\n在首次验证失败后立即终止验证。\r\n\r\n虽然 `bail` 规则只会在遇到验证失败时停止验证特定字段，但 `stopOnFirstFailure` 方法会通知验证器，一旦发生单个验证失败，它应该停止验证所有属性：\r\n\r\n    if ($validator->stopOnFirstFailure()->fails()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"rule-before\"></a>\r\n#### before:_date_\r\n\r\n待验证字段的值对应的日期必须在给定的日期之前。日期将会传递给 PHP 函数 `strtotime`。此外，与 [`after`](#rule-after) 规则一致，可以将另外一个待验证的字段作为 `date` 的值。\r\n \r\n<a name=\"rule-before-or-equal\"></a>\r\n#### before\\_or\\_equal:_date_\r\n\r\n\r\n\r\n待验证字段的值对应的日期必须在给定的日期之前。日期将会传递给 PHP 函数 `strtotime`。此外，与 [`after`](#rule-after)规则一致，可以将另外一个待验证的字段作为 `date` 的值。 \r\n\r\n<a name=\"rule-between\"></a>\r\n#### between:_min_,_max_\r\n\r\n验证字段的大小必须在给定的 min 和 max 之间。字符串、数字、数组和文件的计算方式都使用 [`size`](#rule-size) 方法。\r\n\r\n<a name=\"rule-boolean\"></a>\r\n#### boolean\r\n\r\n验证的字段必须可以转换为 Boolean 类型。 可接受的输入为 `true`, `false`, `1`, `0`, `\"1\"`, 和 `\"0\"`。\r\n\r\n<a name=\"rule-confirmed\"></a>\r\n#### confirmed\r\n\r\nconfirmed可以验证密码和确认密码是否相同，验证字段必须具有匹配字段 `{field}_confirmation` 。例如，验证字段为 `password` ，输入中必须存在与之匹配的 `password_confirmation` 字段。\r\n\r\n<a name=\"rule-current-password\"></a>\r\n#### current_password\r\n\r\n验证字段必须与已验证用户的密码匹配。 您可以使用规则的第一个参数指定 [authentication guard](/docs/laravel/9.x/authentication#eaa0d4)：\r\n\r\n    'password' => 'current_password:api'\r\n\r\n<a name=\"rule-date\"></a>\r\n#### date\r\n\r\n根据 PHP `strtotime` 函数，验证的字段必须是有效的日期。\r\n\r\n<a name=\"rule-date-equals\"></a>\r\n#### date_equals:_date_\r\n\r\n验证字段必须等于给定日期。日期将传递到 PHP `strtotime` 函数中，以便转换为有效的 `DateTime` 实例。\r\n\r\n<a name=\"rule-date-format\"></a>\r\n\r\n\r\n#### date_format:_format_\r\n\r\n验证字段必须匹配给定的 _format_（日期格式）。当验证某个字段的时候，你应该只使用 `date`  或者 `date_format`  **其中一个** ，而不是同时使用。此验证规则支持 PHP 所有的 [DateTime](https://www.php.net/manual/en/class.datetime.php) 类。\r\n\r\n<a name=\"rule-declined\"></a>\r\n#### declined\r\n\r\n正在验证的字段必须是 `\"no\"`，`\"off\"`，`0`或者 `false`。\r\n\r\n<a name=\"rule-declined-if\"></a>\r\n#### declined_if:anotherfield,value,...\r\n\r\n正在验证的字段必须是 `\"no\"`，`\"off\"`，`0`或者 `false`。 如果正在验证的另一个字段等于指定值。\r\n\r\n<a name=\"rule-different\"></a>\r\n#### different:_field_\r\n\r\n验证的字段值必须与字段 _field_ 的值不同。\r\n\r\n<a name=\"rule-digits\"></a>\r\n#### digits:_value_\r\n\r\n验证的字段必须为 _numeric_ ，并且必须具有确切长度 _value_ 。\r\n\r\n<a name=\"rule-digits-between\"></a>\r\n#### digits_between:_min_,_max_\r\n\r\n验证的字段必须为 _numeric_ ，并且长度必须在给定的 _min_ 和 _max_ 之间。\r\n\r\n<a name=\"rule-dimensions\"></a>\r\n#### dimensions\r\n\r\n验证的文件必须是图片并且图片比例必须符合规则:\r\n\r\n    'avatar' => 'dimensions:min_width=100,min_height=200'\r\n\r\n可用的规则为: _min\\_width_， _max\\_width_， _min\\_height_， _max\\_height_， _width_， _height_， _ratio_。\r\n\r\n _ratio_ 约束应该表示为宽度除以高度。 这可以通过像 `3/2` 这样的语句或像 `1.5`这样的 `float` 来指定：\r\n\r\n    'avatar' => 'dimensions:ratio=3/2'\r\n\r\n由于此规则需要多个参数，因此你可以 `Rule::dimensions` 方法来构造可读性高的规则：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'avatar' => [\r\n            'required',\r\n            Rule::dimensions()->maxWidth(1000)->maxHeight(500)->ratio(3 / 2),\r\n        ],\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"rule-distinct\"></a>\r\n#### distinct\r\n\r\n验证数组时，指定的字段不能有任何重复值：\r\n\r\n    'foo.*.id' => 'distinct'\r\n\r\nDistinct 默认使用松散的变量比较。要使用严格比较，您可以将`strict`参数添加到验证规则定义中：\r\n\r\n    'foo.*.id' => 'distinct:strict'\r\n\r\n你可以在验证规则的参数中添加 `ignore_case` ，以使规则忽略大小写差异：\r\n\r\n    'foo.*.id' => 'distinct:ignore_case'\r\n\r\n<a name=\"rule-email\"></a>\r\n#### email\r\n\r\n验证的字段必须符合 `e-mail` 地址格式。当前版本，此种验证规则由[`egulias/email-validator`](https://github.com/egulias/EmailValidator) 提供支持。默认情况下，使用 `RFCValidation` 验证样式，但你也可以应用其他验证样式：\r\n\r\n    'email' => 'email:rfc,dns'\r\n\r\n上面的示例将应用 `RFCValidation` 和 `DNSCheckValidation` 验证。以下是你可以应用的验证样式的完整列表：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `rfc`: `RFCValidation`\r\n- `strict`: `NoRFCWarningsValidation`\r\n- `dns`: `DNSCheckValidation`\r\n- `spoof`: `SpoofCheckValidation`\r\n- `filter`: `FilterEmailValidation`\r\n\r\n</div>\r\n\r\n当下版本 `filter` 验证规则使用 PHP 的 `filter_var` 方法进行验证，在 5.8 版本接入 Laravel 。\r\n\r\n> 注意： `dns` 和 `spoof` 验证器需要PHP的 `intl` 扩展。\r\n\r\n<a name=\"rule-ends-with\"></a>\r\n#### ends_with:_foo_,_bar_,...\r\n\r\n被验证的字段必须以给定值之一结尾。\r\n\r\n<a name=\"rule-enum\"></a>\r\n#### enum\r\n\r\n`Enum` 规则是一个基于类的规则，验证指定的字段是否包含一个有效的枚举值。`Enum` 规则接受枚举的名称作为其唯一的构造函数参数：\r\n\r\n    use App\\Enums\\ServerStatus;\r\n    use Illuminate\\Validation\\Rules\\Enum;\r\n\r\n    $request->validate([\r\n        'status' => [new Enum(ServerStatus::class)],\r\n    ]);\r\n\r\n> 注意：枚举仅适用于PHP 8.1+。\r\n\r\n\r\n\r\n<a name=\"rule-exclude\"></a>\r\n#### exclude\r\n\r\n`validate` 和 `validated` 方法中将会排除掉当前验证的字段。\r\n\r\n<a name=\"rule-exclude-if\"></a>\r\n#### exclude_if:_anotherfield_,_value_\r\n\r\n如果 _anotherfield_ 等于 _value_ ，`validate` 和 `validated` 方法中会排除掉当前的字段。\r\n\r\n<a name=\"rule-exclude-unless\"></a>\r\n#### exclude_unless:_anotherfield_,_value_\r\n\r\n除非 _anotherfield_ 等于 _value_ ，否则 `validate` 和 `validated` 方法中会排除掉当前的字段。如果 _value_ 为 `null` （`exclude_unless:name,null`），那么成立的条件就是被比较的字段（对应规则中的 `name` ）为 `null` 或者表单中没有该字段（对应规则中的 `name` ）。\r\n\r\n<a name=\"rule-exclude-without\"></a>\r\n#### exclude_without:_anotherfield_\r\n\r\n如果 _anotherfield_ 不在表单数据中，`validate` 和 `validated` 方法中会排除掉当前的字段。\r\n\r\n<a name=\"rule-exists\"></a>\r\n#### exists:_table_,_column_\r\n\r\n验证的字段值必须存在于指定的表中。\r\n\r\n<a name=\"basic-usage-of-exists-rule\"></a>\r\n#### Exists 规则的基本用法\r\n\r\n    'state' => 'exists:states'\r\n\r\n如果未指定 `column` 选项，则将使用字段名称。因此，在这种情况下，该规则将验证 `states` 数据库表是否包含一条记录，该记录的 `state` 列的值与请求的 `state` 属性值匹配。\r\n\r\n<a name=\"specifying-a-custom-column-name\"></a>\r\n#### 指定自定义列名\r\n\r\n你可以将验证规则使用的数据库列名称指定在数据库表名称之后：\r\n\r\n    'state' => 'exists:states,abbreviation'\r\n\r\n\r\n\r\n有时候，你或许需要去明确指定一个具体的数据库连接，用于`exists`查询。你可以通过在表名前面添加一个连接名称来实现这个效果。\r\n\r\n    'email' => 'exists:connection.staff,email'\r\n\r\n你可以明确指定 Eloquent 模型，这个模型将被用来确定表名，这样可以代替直接指定表名的方式。\r\n\r\n    'user_id' => 'exists:App\\Models\\User,id'\r\n\r\n如果你想要自定义一个执行查询的验证规则，你可以使用 `Rule` 类去流畅地定义规则。在这个例子中，我们也将指定验证规则为一个数组，而不再是使用 `|` 分割他们：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'email' => [\r\n            'required',\r\n            Rule::exists('staff')->where(function ($query) {\r\n                return $query->where('account_id', 1);\r\n            }),\r\n        ],\r\n    ]);\r\n\r\n<a name=\"rule-file\"></a>\r\n#### file\r\n\r\n要验证的字段必须是一个成功的已经上传的文件。\r\n\r\n<a name=\"rule-filled\"></a>\r\n#### filled\r\n\r\n当字段存在时，要验证的字段必须是一个非空的。\r\n\r\n<a name=\"rule-gt\"></a>\r\n#### gt:_field_\r\n\r\n要验证的字段必须要大于被给的字段。这两个字段必须是同一个类型。字符串、数字、数组和文件都使用 [`size`](#rule-size) 进行相同的评估。\r\n\r\n<a name=\"rule-gte\"></a>\r\n#### gte:_field_\r\n\r\n要验证的字段必须要大于或等于被给的字段。这两个字段必须是同一个类型。字符串、数字、数组和文件都使用 [`size`](#rule-size) 进行相同的评估。\r\n\r\n\r\n<a name=\"rule-image\"></a>\r\n#### image\r\n\r\n正在验证的文件必须是图像（jpg、jpeg、png、bmp、gif、svg 或 webp）。\r\n\r\n<a name=\"rule-in\"></a>\r\n#### in:_foo_,_bar_,...\r\n\r\n验证字段必须包含在给定的值列表中。由于此规则通常要求你 `implode` 数组，因此可以使用`Rule::in` 方法来流畅地构造规则：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'zones' => [\r\n            'required',\r\n            Rule::in(['first-zone', 'second-zone']),\r\n        ],\r\n    ]);\r\n\r\n当 `in` 规则与 `array` 规则结合使用时，输入数组中的每个值都必须出现在提供给 `in` 规则的值列表中。 在以下示例中，输入数组中的「LAS」机场代码无效，因为它不包含在提供给 `in` 规则的机场列表中：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    $input = [\r\n        'airports' => ['NYC', 'LAS'],\r\n    ];\r\n\r\n    Validator::make($input, [\r\n        'airports' => [\r\n            'required',\r\n            'array',\r\n            Rule::in(['NYC', 'LIT']),\r\n        ],\r\n    ]);\r\n\r\n<a name=\"rule-in-array\"></a>\r\n#### in_array:_anotherfield_.*\r\n\r\n正在验证的字段必须存在于_anotherfield_ 的值中。\r\n\r\n<a name=\"rule-integer\"></a>\r\n#### integer\r\n\r\n验证字段必须是整数。\r\n\r\n> 注意：此验证规则不会验证输入是否为“整数”变量类型，仅验证输入是否为 PHP 的 `FILTER_VALIDATE_INT` 规则所接受的类型。 如果您需要将输入验证为数字，请将此规则与 [`numeric` 验证规则](#rule-numeric) 结合使用。\r\n\r\n<a name=\"rule-ip\"></a>\r\n#### ip\r\n\r\n\r\n\r\n验证的字段必须是 IP 地址。\r\n\r\n<a name=\"ipv4\"></a>\r\n#### ipv4\r\n\r\n验证的字段必须是 IPv4 地址。\r\n\r\n<a name=\"ipv6\"></a>\r\n#### ipv6\r\n\r\n验证的字段必须是 IPv6 地址。\r\n\r\n<a name=\"rule-mac\"></a>\r\n#### mac_address\r\n\r\n验证字段必须是 MAC 地址。\r\n\r\n<a name=\"rule-json\"></a>\r\n#### json\r\n\r\n验证的字段必须是有效的 JSON 字符串。\r\n\r\n<a name=\"rule-lt\"></a>\r\n#### lt:_field_\r\n\r\n验证的字段必须小于给定的字段。这两个字段必须是相同的类型。字符串、数值、数组和文件大小的计算方式与  [`size`](#rule-size) 方法进行评估。\r\n\r\n<a name=\"rule-lte\"></a>\r\n#### lte:_field_\r\n\r\n验证中的字段必须小于或等于给定的字段 。这两个字段必须是相同的类型。字符串、数值、数组和文件大小的计算方式与 [`size`](#rule-size) 方法进行评估。\r\n\r\n<a name=\"rule-max\"></a>\r\n#### max:_value_\r\n\r\n验证中的字段必须小于或等于 _value_ 。字符串、数字、数组或是文件大小的计算方式都用 [`size`](#rule-size) 规则。\r\n\r\n<a name=\"rule-mimetypes\"></a>\r\n#### mimetypes:_text/plain_,...\r\n\r\n验证的文件必须具备与列出的其中一个扩展相匹配的 MIME 类型：\r\n\r\n    'video' => 'mimetypes:video/avi,video/mpeg,video/quicktime'\r\n\r\n为了确定上传文件的 MIME，框架将会读取文件，然后自动推测文件 MIME 类型，这可能与客户端提供的 MIME 类型不一致。\r\n\r\n\r\n\r\n<a name=\"rule-mimes\"></a>\r\n#### mimes:_foo_,_bar_,...\r\n\r\n验证的文件必须具有与列出的其中一个扩展名相对应的 MIME 类型。\r\n\r\n<a name=\"basic-usage-of-mime-rule\"></a>\r\n#### MIME 规则基本用法\r\n\r\n    'photo' => 'mimes:jpg,bmp,png'\r\n\r\n即使你可能只需要验证指定扩展名，但此规则实际上会去验证文件的 MIME 类型，其通过读取文件内容来推测它的 MIME 类型。可以在以下链接中找到完整的 MIME 类型列表及相对应的扩展名：\r\n\r\n[https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types](https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types)\r\n\r\n<a name=\"rule-min\"></a>\r\n#### min:_value_\r\n\r\n验证字段必须具有最小值 _value_ 。字符串，数值，数组，文件大小的计算方式都与  [`size`](#rule-size) 规则一致。\r\n\r\n<a name=\"multiple-of\"></a>\r\n#### multiple_of:_value_\r\n\r\n验证字段必须是 _value_ 的倍数。\r\n\r\n> 注意：使用 `multiple_of` 规则时，需要安装 [`bcmath` PHP 扩展](https://www.php.net/manual/en/book.bc.php) \r\n\r\n<a name=\"rule-not-in\"></a>\r\n#### not_in:_foo_,_bar_,...\r\n\r\n验证字段不能包含在给定的值的列表中。 使用 `Rule::notIn` 方法可以更流畅的构建这个规则：\r\n\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'toppings' => [\r\n            'required',\r\n            Rule::notIn(['sprinkles', 'cherries']),\r\n        ],\r\n    ]);\r\n\r\n<a name=\"rule-not-regex\"></a>\r\n#### not_regex:_pattern_\r\n\r\n验证字段必须与给定的正则表达式不匹配。\r\n\r\n验证时，这个规则使用 PHP `preg_match` 函数。指定的模式应遵循 `preg_match` 所需的相同格式，也包括有效的分隔符。 例如： `'email' => 'not_regex:/^.+$/i'`。\r\n\r\n> 注意：当使用 `regex` / `not_regex` 模式时， 可能需要在数组中指定规则，而不是使用 `|` 分隔符 ，特别是在正则表达式包含 `|` 字符 的情况下。\r\n\r\n\r\n\r\n<a name=\"rule-nullable\"></a>\r\n#### nullable\r\n\r\n验证字段可以为 `null`。\r\n\r\n<a name=\"rule-numeric\"></a>\r\n#### numeric\r\n\r\n验证字段必须为 [数值](https://www.php.net/manual/en/function.is-numeric.php)。\r\n\r\n<a name=\"rule-password\"></a>\r\n#### password\r\n\r\n验证字段必须与当前登录用户的密码相同。\r\n\r\n> 注意：此规则已重命名为 `current_password` ，目的是在 Laravel 9 中将其删除。请改用 [当前密码](#rule-current-password) 规则。\r\n\r\n<a name=\"rule-present\"></a>\r\n#### present\r\n\r\n验证字段必须存在于输入数据中，但可以为空。\r\n\r\n<a name=\"rule-prohibited\"></a>\r\n#### prohibited\r\n\r\n验证字段必须为空或不存在。\r\n\r\n<a name=\"rule-prohibited-if\"></a>\r\n#### prohibited_if:_anotherfield_,_value_,...\r\n\r\n如果 _anotherfield_ 字段等于任何值，则验证中的字段必须为空或不存在。\r\n\r\n<a name=\"rule-prohibited-unless\"></a>\r\n#### prohibited_unless:_anotherfield_,_value_,...\r\n\r\n验证中的字段必须为空或不存在，除非 _anotherfield_ 字段等于 _value_ 。\r\n\r\n<a name=\"rule-prohibits\"></a>\r\n#### prohibits:_anotherfield_,...\r\n\r\n如果验证中的字段存在，则 _anotherfield_ 中不能存在任何字段，即使该字段为空。\r\n\r\n<a name=\"rule-regex\"></a>\r\n#### regex:_pattern_\r\n\r\n验证字段必须与给定的正则表达式匹配。\r\n\r\n验证时，这个规则使用 PHP 的 `preg_match`  函数。 指定的模式应遵循 `preg_match` 所需的相同格式，也包括有效的分隔符。 例如： `'email' => 'regex:/^.+@.+$/i'`.\r\n\r\n> 注意：当使用  `regex` / `not_regex` 模式时， 可能需要在数组中指定规则，而不是使用 `|` 分隔符 ，特别是在正则表达式包含 `|` 字符 的情况下。\r\n\r\n\r\n\r\n<a name=\"rule-required\"></a>\r\n#### required\r\n\r\n验证中的字段必须存在于输入数据中，并且不能为空。如果以下条件之一为真，则字段被视为「空」：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- 值为 `null`。\r\n- 该值为空字符串。\r\n- 该值是一个空数组或空的 `Countable` 对象。\r\n- 该值是一个没有路径的上传文件。\r\n\r\n</div>\r\n\r\n<a name=\"rule-required-if\"></a>\r\n#### required_if:_anotherfield_,_value_,...\r\n\r\n如果 _anotherfield_ 字段等于任何 _value_，则验证中的字段必须存在且不为空。\r\n\r\n如果你想为 `required_if` 规则构造一个更复杂的条件，你可以使用 `Rule::requiredIf` 方法。 此方法接受布尔值或闭包。 当传递一个闭包时，闭包应该返回 `true` 或 `false` 以指示是否需要验证字段：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($request->all(), [\r\n        'role_id' => Rule::requiredIf($request->user()->is_admin),\r\n    ]);\r\n\r\n    Validator::make($request->all(), [\r\n        'role_id' => Rule::requiredIf(function () use ($request) {\r\n            return $request->user()->is_admin;\r\n        }),\r\n    ]);\r\n\r\n<a name=\"rule-required-unless\"></a>\r\n#### required_unless:_anotherfield_,_value_,...\r\n\r\n除非_anotherfield_ 字段等于任何_value_，否则验证中的字段必须存在且不为空。 这也意味着 _anotherfield_ 必须存在于请求数据中，除非 _value_ 为 `null`。 如果 _value_ 为 `null` (`required_unless:name,null`)，则需要验证的字段，除非比较字段为 `null` 或请求数据中缺少比较字段。\r\n\r\n\r\n\r\n<a name=\"rule-required-with\"></a>\r\n#### required_with:_foo_,_bar_,...\r\n\r\n仅当任何指定的字段存在且不为空时，验证下的字段才必须存在且不为空。\r\n\r\n<a name=\"rule-required-with-all\"></a>\r\n#### required_with_all:_foo_,_bar_,...\r\n\r\n仅当所有指定的字段存在且不为空时，验证下的字段才必须存在且不为空。\r\n\r\n<a name=\"rule-required-without\"></a>\r\n#### required_without:_foo_,_bar_,...\r\n\r\n仅当任何指定的字段不存在或为空时，验证下的字段才必须存在且不为空。\r\n\r\n<a name=\"rule-required-without-all\"></a>\r\n#### required_without_all:_foo_,_bar_,...\r\n\r\n仅当所有指定的字段不存在或为空时，验证下的字段才必须存在且不为空。\r\n\r\n<a name=\"rule-required-array-keys\"></a>\r\n#### required_array_keys:_foo_,_bar_,...\r\n\r\n验证的字段必须是一个数组，并且必须至少包含指定的键。\r\n\r\n<a name=\"rule-same\"></a>\r\n#### same:_field_\r\n\r\n给定的 _field_ 必须与正在验证的字段匹配。\r\n\r\n<a name=\"rule-size\"></a>\r\n#### size:_value_\r\n\r\n验证字段的大小必须与给定的_value_匹配。对于字符串数据，_value_ 对应于字符数。 对于数字数据，_value_ 对应于给定的整数值（属性还必须具有 `numeric` 或 `integer` 规则）。 对于数组，_size_ 对应于数组的 `count`。 对于文件，_size_ 对应于以千字节为单位的文件大小。 让我们看一些例子：\r\n\r\n    // 验证一个字符串是否正好是 12 个字符长...\r\n    'title' => 'size:12';\r\n\r\n    // 验证提供的整数是否等于 10...\r\n    'seats' => 'integer|size:10';\r\n\r\n    // 验证一个数组正好有 5 个元素...\r\n    'tags' => 'array|size:5';\r\n\r\n    // 验证上传的文件是否正好为 512 KB...\r\n    'image' => 'file|size:512';\r\n\r\n\r\n\r\n<a name=\"rule-starts-with\"></a>\r\n#### starts_with:_foo_,_bar_,...\r\n\r\n验证字段必须以给定值之一开头。\r\n\r\n<a name=\"rule-string\"></a>\r\n#### string\r\n\r\n验证字段必须是字符串。 如果您想允许该字段也为 `null`，则应为该字段分配 `nullable` 规则。\r\n\r\n<a name=\"rule-timezone\"></a>\r\n#### timezone\r\n\r\n根据 `timezone_identifiers_list` PHP 函数，验证中的字段必须是有效的时区标识符。\r\n\r\n<a name=\"rule-unique\"></a>\r\n#### unique:_table_,_column_\r\n\r\n验证中的字段不能存在于给定的数据库表中。\r\n\r\n**指定自定义表/列名称：**\r\n\r\n您可以指定 Eloquent 模型来确定表名，而不是直接指定表名：\r\n\r\n    'email' => 'unique:App\\Models\\User,email_address'\r\n\r\n`column` 选项可用于指定字段对应的数据库列。 如果未指定 `column` 选项，将使用正在验证的字段的名称。\r\n\r\n    'email' => 'unique:users,email_address'\r\n\r\n**指定自定义数据库连接**\r\n\r\n有时，您可能需要为验证器进行的数据库查询设置自定义连接。 为此，您可以将连接名称添加到表名称之前：\r\n\r\n    'email' => 'unique:connection.users,email_address'\r\n\r\n**强制唯一规则忽略给定 ID：**\r\n\r\n有时，您可能希望在唯一验证期间忽略给定的 ID。 例如，考虑一个包含用户姓名、电子邮件地址和位置的“更新个人资料”屏幕。 您可能需要验证电子邮件地址是否唯一。 但是，如果用户只更改名称字段而不更改电子邮件字段，则您不希望引发验证错误，因为用户已经是相关电子邮件地址的所有者。\r\n\r\n\r\n\r\n为了指示验证器忽略用户 ID，我们将使用 `Rule` 类来流畅地定义规则。 在这个例子中，我们还将验证规则指定为一个数组，而不是使用 `|` 字符来分隔规则：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'email' => [\r\n            'required',\r\n            Rule::unique('users')->ignore($user->id),\r\n        ],\r\n    ]);\r\n\r\n> 注意：你不应该将任何用户控制的请求输入传递给 `ignore` 方法。相反，您应该只传递系统生成的唯一 ID，例如来自 Eloquent 模型实例的自动递增 ID 或 UUID。否则，您的应用程序将容易受到 SQL 注入攻击。\r\n\r\n除了将模型键的值传递给 `ignore` 方法，您还可以传递整个模型实例。 Laravel 会自动从模型中提取密钥：\r\n\r\n    Rule::unique('users')->ignore($user)\r\n\r\n如果您的表使用 `id` 以外的主键列名，则可以在调用 `ignore` 方法时指定列名：\r\n\r\n    Rule::unique('users')->ignore($user->id, 'user_id')\r\n\r\n默认情况下，`unique` 规则将检查与正在验证的属性名称匹配的列的唯一性。但是，您可以将不同的列名作为第二个参数传递给 `unique` 方法：\r\n\r\n    Rule::unique('users', 'email_address')->ignore($user->id),\r\n\r\n**添加额外的 Where 子句：**\r\n\r\n您可以通过使用 `where` 方法自定义查询来指定其他查询条件。例如，让我们添加一个查询条件，将查询范围限定为仅搜索 `account_id` 列值为 `1` 的记录：\r\n\r\n    'email' => Rule::unique('users')->where(function ($query) {\r\n        return $query->where('account_id', 1);\r\n    })\r\n\r\n\r\n\r\n<a name=\"rule-url\"></a>\r\n#### url\r\n\r\n验证字段必须是有效的 URL。\r\n\r\n<a name=\"rule-uuid\"></a>\r\n#### uuid\r\n\r\n验证字段必须是有效的 RFC 4122（版本 1、3、4 或 5）通用唯一标识符 (UUID)。\r\n\r\n<a name=\"conditionally-adding-rules\"></a>\r\n## 有条件地添加规则\r\n\r\n<a name=\"skipping-validation-when-fields-have-certain-values\"></a>\r\n#### 当字段具有特定值时跳过验证\r\n\r\n如果另一个字段具有给定值，您有时可能希望不验证给定字段。 您可以使用 `exclude_if` 验证规则来完成此操作。 在此示例中，如果 `has_appointment` 字段的值为 `false`，则不会验证 `appointment_date` 和 `doctor_name` 字段：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $validator = Validator::make($data, [\r\n        'has_appointment' => 'required|boolean',\r\n        'appointment_date' => 'exclude_if:has_appointment,false|required|date',\r\n        'doctor_name' => 'exclude_if:has_appointment,false|required|string',\r\n    ]);\r\n\r\n或者，您可以使用 `exclude_unless` 规则不验证给定字段，除非另一个字段具有给定值：\r\n\r\n    $validator = Validator::make($data, [\r\n        'has_appointment' => 'required|boolean',\r\n        'appointment_date' => 'exclude_unless:has_appointment,true|required|date',\r\n        'doctor_name' => 'exclude_unless:has_appointment,true|required|string',\r\n    ]);\r\n\r\n<a name=\"validating-when-present\"></a>\r\n#### 验证是否存在\r\n\r\n在某些情况下，您可能希望**仅**如果该字段存在于正在验证的数据中，则对该字段运行验证检查。 要快速完成此操作，请将 `sometimes` 规则添加到您的规则列表中：\r\n\r\n    $v = Validator::make($data, [\r\n        'email' => 'sometimes|required|email',\r\n    ]);\r\n\r\n在上面的示例中，只有在 `$data` 数组中存在 `email` 字段时才会对其进行验证。\r\n\r\n> 技巧：如果您尝试验证应始终存在但可能为空的字段，请查看 [关于可选字段的此注释](#a-note-on-optional-fields)。\r\n\r\n\r\n\r\n<a name=\"complex-conditional-validation\"></a>\r\n#### 复杂的条件验证\r\n\r\n有时您可能希望基于更复杂的条件逻辑添加验证规则。例如，您可能希望仅当另一个字段的值大于 100 时才需要给定字段。或者，您可能需要两个字段才能仅在另一个字段存在时才具有给定值。 添加这些验证规则并不一定很痛苦。首先，使用您的_静态规则_创建一个永远不会改变的 `Validator` 实例：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'email' => 'required|email',\r\n        'games' => 'required|numeric',\r\n    ]);\r\n\r\n假设我们的 Web 应用程序是面向游戏收藏家的。如果游戏收藏家在我们的应用程序中注册并且他们拥有超过 100 款游戏，我们希望他们解释为什么他们拥有这么多游戏。 例如，他们可能经营一家游戏转售店，或者他们只是喜欢收集游戏。要有条件地添加此要求，我们可以在 `Validator` 实例上使用 `sometimes` 方法。\r\n\r\n    $validator->sometimes('reason', 'required|max:500', function ($input) {\r\n        return $input->games >= 100;\r\n    });\r\n\r\n传递给 `sometimes` 方法的第一个参数是我们有条件地验证的字段的名称。 第二个参数是我们要添加的规则列表。 如果作为第三个参数传递的闭包返回 `true`，则将添加规则。 这种方法使构建复杂的条件验证变得轻而易举。 您甚至可以一次为多个字段添加条件验证：\r\n\r\n    $validator->sometimes(['reason', 'cost'], 'required', function ($input) {\r\n        return $input->games >= 100;\r\n    });\r\n\r\n> 技巧：传递给闭包的 `$input` 参数将是 `Illuminate\\Support\\Fluent` 的一个实例，可用于访问您的输入和正在验证的文件。\r\n\r\n\r\n\r\n<a name=\"complex-conditional-array-validation\"></a>\r\n#### 复杂的条件数组验证\r\n\r\n有时您可能希望根据同一嵌套数组中的另一个字段来验证一个字段，该数组的索引您不知道。在这些情况下，您可以允许您的闭包接收第二个参数，该参数将是正在验证的数组中的当前单个项目：\r\n\r\n    $input = [\r\n        'channels' => [\r\n            [\r\n                'type' => 'email',\r\n                'address' => 'abigail@example.com',\r\n            ],\r\n            [\r\n                'type' => 'url',\r\n                'address' => 'https://example.com',\r\n            ],\r\n        ],\r\n    ];\r\n\r\n    $validator->sometimes('channels.*.address', 'email', function ($input, $item) {\r\n        return $item->type === 'email';\r\n    });\r\n\r\n    $validator->sometimes('channels.*.address', 'url', function ($input, $item) {\r\n        return $item->type !== 'email';\r\n    });\r\n\r\n与传递给闭包的 `$input` 参数一样，当属性数据是数组时，`$item` 参数是 `Illuminate\\Support\\Fluent` 的实例；否则，它是一个字符串。\r\n\r\n<a name=\"validating-arrays\"></a>\r\n## 验证数组\r\n\r\n正如 [`array` 验证规则文档](#rule-array) 中所讨论的，`array` 规则接受允许的数组键列表。如果数组中存在任何其他键，则验证将失败：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $input = [\r\n        'user' => [\r\n            'name' => 'Taylor Otwell',\r\n            'username' => 'taylorotwell',\r\n            'admin' => true,\r\n        ],\r\n    ];\r\n\r\n    Validator::make($input, [\r\n        'user' => 'array:username,locale',\r\n    ]);\r\n\r\n通常，您应该始终指定允许出现在数组中的数组键。否则，验证器的 `validate` 和 `validated` 方法将返回所有经过验证的数据，包括数组及其所有键，即使这些键没有被其他嵌套数组验证规则验证。\r\n\r\n<a name=\"validating-nested-array-input\"></a>\r\n### 验证嵌套数组输入\r\n\r\n验证基于嵌套数组的表单输入字段并不一定很痛苦。 您可以使用“点表示法”来验证数组中的属性。 例如，如果传入的 HTTP 请求包含 `photos[profile]` 字段，您可以像这样验证它：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'photos.profile' => 'required|image',\r\n    ]);\r\n\r\n\r\n\r\n您还可以验证数组的每个元素。例如，要验证给定数组输入字段中的每封电子邮件是否唯一，您可以执行以下操作：\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'person.*.email' => 'email|unique:users',\r\n        'person.*.first_name' => 'required_with:person.*.last_name',\r\n    ]);\r\n\r\n同样，在指定 [语言文件中的自定义验证消息](#custom-messages-for-specific-attributes) 时，您可以使用 `*` 字符，从而轻松为基于数组的字段使用单个验证消息：\r\n\r\n    'custom' => [\r\n        'person.*.email' => [\r\n            'unique' => 'Each person must have a unique email address',\r\n        ]\r\n    ],\r\n\r\n<a name=\"accessing-nested-array-data\"></a>\r\n#### 访问嵌套数组数据\r\n\r\n有时，在为属性分配验证规则时，您可能需要访问给定嵌套数组元素的值。您可以使用 `Rule::foreEach` 方法完成此操作。 `forEach` 方法接受一个闭包，该闭包将为验证中的数组属性的每次迭代调用，并将接收属性的值和显式的、完全扩展的属性名称。闭包应该返回一个规则数组来分配给数组元素：\r\n\r\n    use App\\Rules\\HasPermission;\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'companies.*.id' => Rule::forEach(function ($value, $attribute) {\r\n            return [\r\n                Rule::exists(Company::class, 'id'),\r\n                new HasPermission('manage-company', $value),\r\n            ];\r\n        }),\r\n    ]);\r\n\r\n<a name=\"validating-passwords\"></a>\r\n## 验证密码\r\n\r\n为确保密码具有足够的复杂性，您可以使用 Laravel 的 `password` 规则对象：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rules\\Password;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'password' => ['required', 'confirmed', Password::min(8)],\r\n    ]);\r\n\r\n`Password` 规则对象允许您轻松自定义应用程序的密码复杂性要求，例如指定密码至少需要一个字母、数字、符号或混合大小写的字符：\r\n\r\n    // 至少需要 8 个字符...\r\n    Password::min(8)\r\n\r\n    // 至少需要一个字母...\r\n    Password::min(8)->letters()\r\n\r\n    // 至少需要一个大写字母和一个小写字母...\r\n    Password::min(8)->mixedCase()\r\n\r\n    // 至少需要一个数字...\r\n    Password::min(8)->numbers()\r\n\r\n    // 至少需要一个符号...\r\n    Password::min(8)->symbols()\r\n\r\n\r\n\r\n此外，您可以使用 `uncompromised` 方法确保密码没有在公共密码数据泄露事件中被泄露：\r\n\r\n    Password::min(8)->uncompromised()\r\n\r\n在内部，`Password` 规则对象使用 [k-Anonymity](https://en.wikipedia.org/wiki/K-anonymity) 模型来确定密码是否已通过 [haveibeenpwned.com](https://haveibeenpwned.com) 服务而不牺牲用户的隐私或安全。\r\n\r\n默认情况下，如果密码在数据泄露中至少出现一次，则会被视为已泄露。您可以使用 `uncompromised` 方法的第一个参数自定义此阈值：\r\n\r\n    // 确保密码在同一数据泄露中出现少于 3 次...\r\n    Password::min(8)->uncompromised(3);\r\n\r\n当然，您可以将上面示例中的所有方法链接起来：\r\n\r\n    Password::min(8)\r\n        ->letters()\r\n        ->mixedCase()\r\n        ->numbers()\r\n        ->symbols()\r\n        ->uncompromised()\r\n\r\n<a name=\"defining-default-password-rules\"></a>\r\n#### 定义默认密码规则\r\n\r\n您可能会发现在应用程序的单个位置指定密码的默认验证规则很方便。 您可以使用接受闭包的 `Password::defaults` 方法轻松完成此操作。 给`defaults` 方法的闭包应该返回密码规则的默认配置。 通常，应该在应用程序的服务提供者之一的 `boot` 方法中调用 `defaults` 规则：\r\n\r\n```php\r\nuse Illuminate\\Validation\\Rules\\Password;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Password::defaults(function () {\r\n        $rule = Password::min(8);\r\n\r\n        return $this->app->isProduction()\r\n                    ? $rule->mixedCase()->uncompromised()\r\n                    : $rule;\r\n    });\r\n}\r\n```\r\n\r\n然后，当您想将默认规则应用于正在验证的特定密码时，您可以调用不带参数的 `defaults` 方法：\r\n\r\n    'password' => ['required', Password::defaults()],\r\n\r\n\r\n\r\n有时，您可能希望将其他验证规则附加到默认密码验证规则。 您可以使用 `rules` 方法来完成此操作：\r\n\r\n    use App\\Rules\\ZxcvbnRule;\r\n\r\n    Password::defaults(function () {\r\n        $rule = Password::min(8)->rules([new ZxcvbnRule]);\r\n\r\n        // ...\r\n    });\r\n\r\n<a name=\"custom-validation-rules\"></a>\r\n## 自定义验证规则\r\n\r\n<a name=\"using-rule-objects\"></a>\r\n### 使用规则对象\r\n\r\nLaravel 提供了各种有用的验证规则； 但是，您可能希望指定一些您自己的。 注册自定义验证规则的一种方法是使用规则对象。 要生成新的规则对象，您可以使用 `make:rule` Artisan 命令。 让我们使用这个命令生成一个验证字符串是否为大写的规则。 Laravel 会将新规则放在 `app/Rules` 目录中。 如果此目录不存在，Laravel 将在您执行 Artisan 命令创建规则时创建它：\r\n\r\n```shell\r\nphp artisan make:rule Uppercase\r\n```\r\n\r\n创建规则后，我们就可以定义其行为了。 一个规则对象包含两个方法：`passes` 和 `message`。 `passes` 方法接收属性值和名称，应该根据属性值是否有效返回 `true` 或 `false`。 `message` 方法应该返回验证失败时应该使用的验证错误消息：\r\n\r\n    <?php\r\n\r\n    namespace App\\Rules;\r\n\r\n    use Illuminate\\Contracts\\Validation\\Rule;\r\n\r\n    class Uppercase implements Rule\r\n    {\r\n        /**\r\n         * 确定验证规则是否通过。\r\n         *\r\n         * @param  string  $attribute\r\n         * @param  mixed  $value\r\n         * @return bool\r\n         */\r\n        public function passes($attribute, $value)\r\n        {\r\n            return strtoupper($value) === $value;\r\n        }\r\n\r\n        /**\r\n         * 获取验证错误消息。\r\n         *\r\n         * @return string\r\n         */\r\n        public function message()\r\n        {\r\n            return 'The :attribute must be uppercase.';\r\n        }\r\n    }\r\n\r\n\r\n\r\n如果您想从翻译文件中返回错误消息，您可以从您的 `message` 方法中调用 `trans` 助手：\r\n\r\n    /**\r\n     * 获取验证错误消息。\r\n     *\r\n     * @return string\r\n     */\r\n    public function message()\r\n    {\r\n        return trans('validation.uppercase');\r\n    }\r\n\r\n定义规则后，您可以通过将规则对象的实例与其他验证规则一起传递来将其附加到验证器：\r\n\r\n    use App\\Rules\\Uppercase;\r\n\r\n    $request->validate([\r\n        'name' => ['required', 'string', new Uppercase],\r\n    ]);\r\n\r\n#### 访问附加数据\r\n\r\n如果您的自定义验证规则类需要访问所有其他正在验证的数据，您的规则类可以实现 `Illuminate\\Contracts\\Validation\\DataAwareRule` 接口。这个接口需要你的类定义一个 `setData` 方法。Laravel 将自动调用此方法（在验证进行之前），`$data` 包含所有即将验证的数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Rules;\r\n\r\n    use Illuminate\\Contracts\\Validation\\Rule;\r\n    use Illuminate\\Contracts\\Validation\\DataAwareRule;\r\n\r\n    class Uppercase implements Rule, DataAwareRule\r\n    {\r\n        /**\r\n         * 即将进行验证的所有数据\r\n         *\r\n         * @var array\r\n         */\r\n        protected $data = [];\r\n\r\n        // ...\r\n\r\n        /**\r\n         * 设置即将进行验证的所有数据。\r\n         *\r\n         * @param  array  $data\r\n         * @return $this\r\n         */\r\n        public function setData($data)\r\n        {\r\n            $this->data = $data;\r\n\r\n            return $this;\r\n        }\r\n    }\r\n\r\n或者，如果您的验证规则需要访问执行验证的验证器实例，您可以实现 `ValidatorAwareRule` 接口：\r\n\r\n    <?php\r\n\r\n    namespace App\\Rules;\r\n\r\n    use Illuminate\\Contracts\\Validation\\Rule;\r\n    use Illuminate\\Contracts\\Validation\\ValidatorAwareRule;\r\n\r\n    class Uppercase implements Rule, ValidatorAwareRule\r\n    {\r\n        /**\r\n         * 验证器实例。\r\n         *\r\n         * @var \\Illuminate\\Validation\\Validator\r\n         */\r\n        protected $validator;\r\n\r\n        // ...\r\n\r\n        /**\r\n         * 设置当前验证器。\r\n         *\r\n         * @param  \\Illuminate\\Validation\\Validator  $validator\r\n         * @return $this\r\n         */\r\n        public function setValidator($validator)\r\n        {\r\n            $this->validator = $validator;\r\n\r\n            return $this;\r\n        }\r\n    }\r\n\r\n<a name=\"using-closures\"></a>\r\n\r\n\r\n### 使用闭包\r\n\r\n如果您在整个应用程序中只需要一次自定义规则的功能，您可以使用闭包而不是规则对象。闭包接收属性的名称、属性的值和一个在验证失败时应该调用的 `$fail` 回调：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'title' => [\r\n            'required',\r\n            'max:255',\r\n            function ($attribute, $value, $fail) {\r\n                if ($value === 'foo') {\r\n                    $fail('The '.$attribute.' is invalid.');\r\n                }\r\n            },\r\n        ],\r\n    ]);\r\n\r\n<a name=\"implicit-rules\"></a>\r\n### 隐式规则\r\n\r\n默认情况下，当正在验证的属性不存在或包含空字符串时，不会运行正常的验证规则，包括自定义规则。例如，[`unique`](#rule-unique) 规则不会针对空字符串运行：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $rules = ['name' => 'unique:users,name'];\r\n\r\n    $input = ['name' => ''];\r\n\r\n    Validator::make($input, $rules)->passes(); // true\r\n\r\n要使自定义规则即使在属性为空时也能运行，该规则必须暗示该属性是必需的。要创建「隐式」规则，请实现 Illuminate\\Contracts\\Validation\\ImplicitRule 接口。 该接口用作验证器的「标识接口」；因此，除了典型的 `Rule` 接口所需的方法之外，它不包含您需要实现的任何其他方法。\r\n\r\n要生成新的隐式规则对象，您可以使用带有 `--implicit` 选项的 `make:rule` Artisan 命令：\r\n\r\n```shell\r\nphp artisan make:rule Uppercase --implicit\r\n```\r\n\r\n> 注意：「隐式」规则仅_implicit_该属性是必需的。 它是否实际上使缺失或空属性无效取决于您。\r\n\r\n","p":"docs/validation.html"},{"t":"errors (错误处理)","d":"# 错误处理\r\n\r\n- [介绍](#introduction)\r\n- [配置](#configuration)\r\n- [异常处理](#the-exception-handler)\r\n    - [异常报告](#reporting-exceptions)\r\n    - [忽略指定类型异常](#ignoring-exceptions-by-type)\r\n    - [渲染异常](#rendering-exceptions)\r\n    - [Reportable & Renderable 异常](#renderable-exceptions)\r\n- [HTTP 异常](#http-exceptions)\r\n    - [自定义 HTTP 错误页面](#custom-http-error-pages)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n当你开始一个新的 `Laravel` 项目时，它已经为您配置了错误和异常处理。 `App\\Exceptions\\Handler` 类用于记录应用程序触发的所有异常，然后将其呈现回用户。我们将在本文中深入讨论这个类。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n你的 `config/app.php` 配置文件中的 `debug` 选项决定了对于一个错误实际上将显示多少信息给用户。默认情况下，该选项的设置将遵照存储在 `.env` 文件中的 `APP_DEBUG` 环境变量的值。\r\n\r\n对于本地开发，你应该将 `APP_DEBUG` 环境变量的值设置为 `true`。**在生产环境中，该值应始终为 `false`。如果在生产中将该值设置为 `true`，则可能会将敏感配置值暴露给应用程序的终端用户。**\r\n\r\n<a name=\"the-exception-handler\"></a>\r\n## 异常处理\r\n\r\n<a name=\"reporting-exceptions\"></a>\r\n### 异常报告\r\n\r\n所有异常都是由 `App\\Exceptions\\Handler` 类处理。此类包含一个 `register` 方法，可以在其中注册自定义异常报告程序和渲染器回调。我们将详细研究每个概念。异常报告用于记录异常或将其发送到如 [Flare](https://flareapp.io)、[Bugsnag](https://bugsnag.com) 或 [Sentry](https://github.com/getsentry/sentry-laravel) 等外部服务。默认情况下，将根据你的 [日志](/docs/laravel/9.x/logging) 配置来记录异常。不过，你可以用任何自己喜欢的方式来记录异常。\r\n\r\n\r\n\r\n例如，如果您需要以不同的方式报告不同类型的异常，您可以使用 `reportable` 方法注册一个闭包，当需要报告给定的异常的时候便会执行它。 Laravel 将通过检查闭包的类型提示来判断闭包报告的异常类型：\r\n\r\n    use App\\Exceptions\\InvalidOrderException;\r\n\r\n    /**\r\n     * 为应用程序注册异常处理回调\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->reportable(function (InvalidOrderException $e) {\r\n            //\r\n        });\r\n    }\r\n\r\n当您使用 reportable 方法注册一个自定义异常报告回调时， Laravel 依然会使用默认的日志配置记录下应用异常。 如果您想要在默认的日志堆栈中停止这个行为，您可以在定义报告回调时使用 stop 方法：\r\n\r\n    $this->reportable(function (InvalidOrderException $e) {\r\n        //\r\n    })->stop();\r\n\r\n    $this->reportable(function (InvalidOrderException $e) {\r\n        return false;\r\n    });\r\n\r\n> 技巧：要为给定的异常自定义异常报告，您可以使用 [可报告异常](/docs/laravel/9.x/errors#renderable-exceptions)。\r\n\r\n<a name=\"global-log-context\"></a>\r\n#### 全局日志上下文\r\n\r\n在可用的情况下， Laravel 会自动将当前用户的编号作为数据添加到每一条异常日志信息中。您可以通过重写 App\\Exceptions\\Handler 类中的 context 方法来定义您自己的全局上下文数据（环境变量）。此后，每一条异常日志信息都将包含这个信息：\r\n\r\n    /**\r\n     * 获取默认日志的上下文变量\r\n     *\r\n     * @return array\r\n     */\r\n    protected function context()\r\n    {\r\n        return array_merge(parent::context(), [\r\n            'foo' => 'bar',\r\n        ]);\r\n    }\r\n\r\n<a name=\"exception-log-context\"></a>\r\n\r\n\r\n#### 异常日志上下文\r\n\r\n虽然为每条日志消息添加上下文可能很有用，但有时特定异常可能具有您希望包含在日志中的独特上下文。通过在应用程序的自定义异常上定义 `context` 方法，您可以指定应添加到异常日志条目中的与该异常相关的任何数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Exceptions;\r\n\r\n    use Exception;\r\n\r\n    class InvalidOrderException extends Exception\r\n    {\r\n        // ...\r\n\r\n        /**\r\n         * Get the exception's context information.\r\n         *\r\n         * @return array\r\n         */\r\n        public function context()\r\n        {\r\n            return ['order_id' => $this->orderId];\r\n        }\r\n    }\r\n\r\n<a name=\"the-report-helper\"></a>\r\n#### `report` 助手函数\r\n\r\n有时您可能需要报告异常但继续处理当前请求。 `report` 辅助函数允许您通过异常处理程序快速报告异常，而无需向用户呈现错误页面：\r\n\r\n    public function isValid($value)\r\n    {\r\n        try {\r\n            // 验证...\r\n        } catch (Throwable $e) {\r\n            report($e);\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n<a name=\"ignoring-exceptions-by-type\"></a>\r\n### 按类型忽略异常\r\n\r\n在构建应用时，会有一些类型的异常您只想忽略并且永远不会报告。应用的异常处理程序包含一个 `$dontReport` 属性，该属性被初始化为一个空数组。您添加到此属性的任何类都不会被报告；但是，它们可能仍然具有自定义呈现逻辑：\r\n\r\n    use App\\Exceptions\\InvalidOrderException;\r\n\r\n    /**\r\n     * 不应上报的异常类型列表。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $dontReport = [\r\n        InvalidOrderException::class,\r\n    ];\r\n\r\n> 提示：在幕后，Laravel 已经为你忽略了某些类型的错误，例如由 404 HTTP「未找到」错误导致的异常或由无效 CSRF 令牌生成的 419 HTTP 响应。\r\n\r\n<a name=\"rendering-exceptions\"></a>\r\n### 渲染异常\r\n\r\n默认情况下，Laravel 异常处理器会为你把异常转换为 HTTP 响应。然而，你可以自由地为特定类型的异常注册一个自定义的渲染闭包来实现。\r\n\r\n传递给  `renderable` 方法的闭包函数应返回一个 `Illuminate\\Http\\Response` 的实例，它可以通过  `response` 助手函数生成。 Laravel 将会根据闭包的类型提示来推断闭包渲染的异常类型：\r\n\r\n    use App\\Exceptions\\InvalidOrderException;\r\n\r\n    /**\r\n     * 注册异常处理回调\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->renderable(function (InvalidOrderException $e, $request) {\r\n            return response()->view('errors.invalid-order', [], 500);\r\n        });\r\n    }\r\n\r\n你也可以使用 `renderable` 方法来覆盖 Laravel 或 Symfony 内置异常的渲染行为，例如 `NotFoundHttpException`。如果 `renderable` 方法的闭包没有返回值，将使用 Laravel 的默认异常渲染：\r\n\r\n    use Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\r\n\r\n    /**\r\n     * 为应用程序注册异常处理回调。\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->renderable(function (NotFoundHttpException $e, $request) {\r\n            if ($request->is('api/*')) {\r\n                return response()->json([\r\n                    'message' => 'Record not found.'\r\n                ], 404);\r\n            }\r\n        });\r\n    }\r\n\r\n<a name=\"renderable-exceptions\"></a>\r\n### Reportable & Renderable 异常\r\n\r\n除了在异常控制器的 `register`方法中检查异常类型外，你可以直接地在自定义异常里定义 `report` 和 `render` 。当这些方法存在时，它们将被框架自动调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Exceptions;\r\n\r\n    use Exception;\r\n\r\n    class InvalidOrderException extends Exception\r\n    {\r\n        /**\r\n         * 报告异常。\r\n         *\r\n         * @return bool|null\r\n         */\r\n        public function report()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         *渲染异常为 HTTP 响应。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function render($request)\r\n        {\r\n            return response(...);\r\n        }\r\n    }\r\n\r\n\r\n\r\n如果你的异常扩展了一个已经可以渲染的异常，比如内置的 Laravel 或 Symfony 异常，你可以从异常的 `render` 方法返回 `false` 来渲染异常的默认 HTTP 响应：\r\n\r\n    /**\r\n     * 将异常渲染为 HTTP 响应。\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return \\Illuminate\\Http\\Response\r\n     */\r\n    public function render($request)\r\n    {\r\n        // 判断异常是否需要自定义报告...\r\n\r\n        return false;\r\n    }\r\n\r\n如果你的异常中包含了仅在满足特定条件才报告的自定义报告逻辑，你可能需要指示 Laravel 使用默认的异常处理配置报告异常。你可以在异常的 `report` 方法中返回 `false` 实现这个：\r\n\r\n    /**\r\n     * 报告异常。\r\n     *\r\n     * @return bool|null\r\n     */\r\n    public function report()\r\n    {\r\n        // 判断异常是否需要自定义报告...\r\n\r\n        return false;\r\n    }\r\n\r\n> 技巧：你可以通过类型提示输入 `report` 方法所需的依赖项，Laravel的 [服务容器](/docs/laravel/9.x/container) 会自动把它们注入到此方法中。\r\n\r\n<a name=\"http-exceptions\"></a>\r\n## HTTP 异常\r\n\r\n某些异常描述了服务器的 HTTP 错误代码。例如，可能是 「 页面未找到 」 错误 （404），「 未经授权的错误 」（401）或者甚至是开发者造成的 500 错误。要在应用的任意地方生成此类响应，你可以使用 `abort` 辅助函数：\r\n\r\n    abort(404);\r\n\r\n<a name=\"custom-http-error-pages\"></a>\r\n### 自定义 HTTP 错误页\r\n\r\nLaravel 创建了可以轻松显示各种 HTTP 状态码的自定义错误页面。例如，如果你想自定义 404 HTTP 状态码页面，只需创建一个 `resources/views/errors/404.blade.php` 文件。它会用来处理所有应用程序产生的 404 错误。视图目录下所有文件命名都应和它们所响应的 HTTP 状态码一一对应。`abort` 方法会调用 `Symfony\\Component\\HttpKernel\\Exception\\HttpException` 的实例，它将被作为 `$exception` 变量传递给视图：\r\n\r\n    <h2>{{ $exception->getMessage() }}</h2>\r\n\r\n\r\n\r\n你可以使用 Artisan 命令 `vendor:publish` 发布模板，然后根据自己的喜好进行自定义：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-errors\r\n```\r\n\r\n<a name=\"fallback-http-error-pages\"></a>\r\n#### 回退 HTTP 错误页面\r\n\r\n你还可以为给定的一系列 HTTP 状态代码定义「回退」错误页面。如果发生的特定 HTTP 状态代码没有对应的页面，则将呈现此页面。为此，请在应用程序的 `resources/views/errors` 目录中定义一个 `4xx.blade.php` 模板和一个 `5xx.blade.php` 模板。\r\n\r\n","p":"docs/errors.html"},{"t":"logging (Logging)","d":"# Logging\r\n\r\n- [介绍](#introduction)\r\n- [配置](#configuration)\r\n    - [可用通道驱动](#available-channel-drivers)\r\n    - [通道先决条件](#channel-prerequisites)\r\n    - [记录弃用警告](#logging-deprecation-warnings)\r\n- [构建日志堆栈](#building-log-stacks)\r\n- [写日志消息](#writing-log-messages)\r\n    - [上下文信息](#contextual-information)\r\n    - [写入到指定通道](#writing-to-specific-channels)\r\n- [Monolog 通道自定义](#monolog-channel-customization)\r\n    - [为通道自定义 Monolog](#customizing-monolog-for-channels)\r\n    - [创建 Monolog 处理器通道](#creating-monolog-handler-channels)\r\n    - [通过工厂创建通道](#creating-custom-channels-via-factories)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n为了帮助你了解程序中正在发生什么，Laravel 提供了健壮的日志服务，允许你记录日志信息到文件，到系统错误日志，甚至到 Slack 通知你的整个团队。\r\n\r\nLaravel 日志基于「 通道 」。每个通道代表一个具体的记录日志消息的方式。举例来说，`single` 通道会把日志记录到一个单独的文件里， `slack` 通道会发送日志信息到 Slack。基于它们的重要程度，日志可能会被写入到多个通道中去。\r\n\r\nLaravel 使用了 [Monolog](https://github.com/Seldaek/monolog) 库，它为各种强大的日志处理提供支持。Laravel 使配置这些处理器变得小菜一碟，它允许以混合和匹配的方式，自定义你的程序日志处理。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n所有的应用程序日志系统配置都位于 `config/logging.php` 配置文件中。这个文件允许你配置程序的日志通道，因此务必查看每个可用通道和它们的选项。我们将在下面回顾一些常用的选项。\r\n\r\n\r\n\r\nLaravel 默认使用 `stack` 通道记录日志消息。 `stack` 通道被用于将多个日志通道集成到一个单独的通道中去。获得更多构建堆栈信息，请查看 [以下文档](#building-log-stacks) 。\r\n\r\n<a name=\"configuring-the-channel-name\"></a>\r\n#### 配置通道名\r\n\r\n默认情况下，Monolog 用与当前环境匹配的 `channel name` 实例化，例如 `production` 或 `local`。要更改此值，请在通道配置中添加 `name` 选项：\r\n\r\n    'stack' => [\r\n        'driver' => 'stack',\r\n        'name' => 'channel-name',\r\n        'channels' => ['single', 'slack'],\r\n    ],\r\n\r\n<a name=\"available-channel-drivers\"></a>\r\n### 可用的通道驱动\r\n\r\n每个日志通道都由一个驱动程序驱动。驱动程序确定日志消息的实际记录方式和位置。以下日志通道驱动程序在每个 Laravel 应用程序中都可用。大多数驱动程序的条目已经存在于应用程序的 `config/logging.php` 配置文件中，因此请务必查看此文件以熟悉其内容：\r\n\r\n名称 | 说明\r\n------------- | -------------\r\n`custom` | 调用指定工厂来创建通道的驱动程序\r\n`daily` | 一个基于 `RotatingFileHandler` 的每日循环的 Monolog 驱动程序\r\n`errorlog` | 基于 `ErrorLogHandler` 的 Monolog 驱动程序\r\n`monolog` | 可以使用任何支持的 Monolog 处理程序的 Monolog 工厂驱动程序\r\n`null` | 丢弃所有日志消息的驱动程序\r\n`papertrail` | 基于 `SyslogUdpHandler` 的 Monolog 驱动程序\r\n`single` | 单个基于文件或路径的记录器通道 (`StreamHandler`)\r\n`slack` | 基于 `SlackWebhookHandler` 的 Monolog 驱动程序\r\n`stack` | 该通道有助于创建 「多通道」 的包装器\r\n`syslog` | 基于 `SyslogHandler` 的 Monolog 驱动程序\r\n\r\n> 技巧：查看 [高级通道定制](#monolog-channel-customization) 文档，了解有关 `monolog` 和 `custom` 驱动程序的更多信息。\r\n\r\n\r\n\r\n<a name=\"channel-prerequisites\"></a>\r\n### 通道先决条件\r\n\r\n<a name=\"configuring-the-single-and-daily-channels\"></a>\r\n#### 配置单通道和每日通道\r\n\r\n`single` 和 `daily` 通道有三个可选配置选项： `bubble` 、`permission` 和 `locking`。\r\n\r\n名称 | 说明 | 默认值\r\n------------- | ------------- | -------------\r\n`bubble` | 指示消息在处理后是否应跳转到其他通道 | `true`\r\n`locking` | 尝试在写入日志文件之前锁定它 | `false`\r\n`permission` | 日志文件的权限 | `0644`\r\n\r\n<a name=\"configuring-the-papertrail-channel\"></a>\r\n#### 配置 Papertrail 通道\r\n\r\n`papertrail` 通道需要 `host` 和 `port` 配置选项。你可以从 [Papertrail](https://help.papertrailapp.com/kb/configuration/configuring-centralized-logging-from-php-apps/#send-events-from-php-app) 获得这些值。\r\n\r\n<a name=\"configuring-the-slack-channel\"></a>\r\n#### 配置 Slack 通道\r\n\r\n`slack` 通道需要 `url` 配置选项。URL 应该与您为 Slack 团队配置 [incoming webhook](https://slack.com/apps/A0F7XDUAZ-incoming-webhooks) 的 URL 匹配。\r\n\r\n默认情况下，Slack 将仅接收 `critical` 级别及更高级别的日志；但是，你可以在 `config/logging.php` 配置文件中通过修改 Slack 日志通道的配置数组中的 `level` 配置选项来进行调整。\r\n\r\n<a name=\"logging-deprecation-warnings\"></a>\r\n### 记录弃用警告\r\n\r\nPHP、Laravel 和其他库经常通知他们的用户，他们的一些功能已被弃用，并将在未来的版本中删除。如果您想记录这些弃用警告，您可以在应用程序的 `config/logging.php` 配置文件中指定 `deprecations` 的日志通道：\r\n\r\n    'deprecations' => env('LOG_DEPRECATIONS_CHANNEL', 'null'),\r\n\r\n    'channels' => [\r\n        ...\r\n    ]\r\n\r\n或者，您可以定义一个名为 `deprecations` 的日志通道。 如果存在具有此名称的日志通道，它将被用于记录弃用警告：\r\n\r\n    'channels' => [\r\n        'deprecations' => [\r\n            'driver' => 'single',\r\n            'path' => storage_path('logs/php-deprecation-warnings.log'),\r\n        ],\r\n    ],\r\n\r\n\r\n\r\n<a name=\"building-log-stacks\"></a>\r\n## 构建日志堆栈\r\n\r\n如前所述，`stack` 为方便起见，该驱动程序允许你将多个通道合并为一个日志通道。为了说明如何使用日志堆栈，让我们看一下你可能在生产应用程序中看到的示例配置：\r\n\r\n    'channels' => [\r\n        'stack' => [\r\n            'driver' => 'stack',\r\n            'channels' => ['syslog', 'slack'],\r\n        ],\r\n\r\n        'syslog' => [\r\n            'driver' => 'syslog',\r\n            'level' => 'debug',\r\n        ],\r\n\r\n        'slack' => [\r\n            'driver' => 'slack',\r\n            'url' => env('LOG_SLACK_WEBHOOK_URL'),\r\n            'username' => 'Laravel Log',\r\n            'emoji' => ':boom:',\r\n            'level' => 'critical',\r\n        ],\r\n    ],\r\n\r\n让我们剖析此配置。首先，请注意我们的 `stack` 渠道聚集通过它的两个其他渠道 `channels` 选项：`syslog` 和 `slack`。因此，在记录消息时，这两个渠道都将有机会记录消息。但是，正如我们将在下面看到的，这些通道是否实际记录了消息可能取决于消息的重要性 /「级别」。\r\n\r\n<a name=\"log-levels\"></a>\r\n#### 日志级别\r\n\r\n请注意上面示例中的 `syslog` 和 `slack` 通道配置上的 `level` 配置选项。此选项确定消息必须由通道记录的最低「级别」。Monolog，为 Laravel 的日志服务提供了所有在 [RFC 5424 specification](https://tools.ietf.org/html/rfc5424): 中定义的日志级别: **emergency**、 **alert**、 **critical**、 **error**、 **warning**、 **notice**、 **info** 和 **debug**。\r\n\r\n因此，假设我们使用 `debug` 方法记录了一条消息：\r\n\r\n    Log::debug('An informational message.');\r\n\r\n根据我们的配置，`syslog` 通道会将消息写入系统日志。但是，由于错误消息不是 `critical` 或更高级别，因此不会将其发送到 Slack。但是，如果我们记录一个 `emergency` 消息，它将被发送到系统日志和 Slack，因为 `emergency` 级别高于两个通道的最低级别阈值：\r\n\r\n    Log::emergency('The system is down!');\r\n\r\n\r\n\r\n<a name=\"writing-log-messages\"></a>\r\n## 编写日志消息\r\n\r\n您可以使用 `Log` [facade](/docs/laravel/9.x/facades) 将信息写入日志。如前所述，记录器提供 [RFC 5424 规范](https://tools.ietf.org/html/rfc5424) 中定义的八个记录级别： **emergency**、 **alert**、 **critical**、 **error**、 **warning**、 **notice**、 **info** 和 **debug**：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    Log::emergency($message);\r\n    Log::alert($message);\r\n    Log::critical($message);\r\n    Log::error($message);\r\n    Log::warning($message);\r\n    Log::notice($message);\r\n    Log::info($message);\r\n    Log::debug($message);\r\n\r\n您可以调用任何这些方法来记录相应级别的消息。默认情况下，消息将写入您的 `logging` 配置文件配置的默认日志通道：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示给定用户的个人资料。\r\n         *\r\n         * @param  int  $id\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function show($id)\r\n        {\r\n            Log::info('Showing the user profile for user: '.$id);\r\n\r\n            return view('user.profile', [\r\n                'user' => User::findOrFail($id)\r\n            ]);\r\n        }\r\n    }\r\n\r\n<a name=\"contextual-information\"></a>\r\n### 上下文信息\r\n\r\n可以将一组上下文数据传递给日志方法。此上下文数据将被格式化并与日志消息一起显示：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    Log::info('User failed to login.', ['id' => $user->id]);\r\n\r\n有时，您可能希望指定一些应包含在所有后续日志条目中的上下文信息。例如，您可能希望记录与应用程序的每个传入请求相关联的请求 ID。为此，您可以调用 `Log` 门面的 `withContext` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Support\\Facades\\Log;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    class AssignRequestId\r\n    {\r\n        /**\r\n         * 处理传入的请求。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Closure  $next\r\n         * @return mixed\r\n         */\r\n        public function handle($request, Closure $next)\r\n        {\r\n            $requestId = (string) Str::uuid();\r\n\r\n            Log::withContext([\r\n                'request-id' => $requestId\r\n            ]);\r\n\r\n            return $next($request)->header('Request-Id', $requestId);\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"writing-to-specific-channels\"></a>\r\n### 写入特定通道\r\n\r\n有时您可能希望将消息记录到应用程序默认通道以外的通道。您可以使用 `Log` 门面的 `channel` 方法来检索并记录到配置文件中定义的任何通道：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    Log::channel('slack')->info('Something happened!');\r\n\r\n如果您想创建一个由多个通道组成的按需日志堆栈，您可以使用 `stack` 方法：\r\n\r\n    Log::stack(['single', 'slack'])->info('Something happened!');\r\n\r\n<a name=\"on-demand-channels\"></a>\r\n#### 按需通道\r\n\r\n也可以通过在运行时提供配置来创建按需通道，而该配置不存在于应用程序的「日志记录」配置文件中。 为此，您可以将配置数组传递给 `Log` 门面的 `build` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    Log::build([\r\n      'driver' => 'single',\r\n      'path' => storage_path('logs/custom.log'),\r\n    ])->info('Something happened!');\r\n\r\n您可能还希望在按需日志记录堆栈中包含一个按需通道。这可以通过将您的按需通道实例包含在传递给 `stack` 方法的数组中来实现：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    $channel = Log::build([\r\n      'driver' => 'single',\r\n      'path' => storage_path('logs/custom.log'),\r\n    ]);\r\n\r\n    Log::stack(['slack', $channel])->info('Something happened!');\r\n\r\n<a name=\"monolog-channel-customization\"></a>\r\n## Monolog 通道自定义\r\n\r\n<a name=\"customizing-monolog-for-channels\"></a>\r\n### 为通道自定义 Monolog\r\n\r\n有时您可能需要完全控制如何为现有通道配置 Monolog。例如，您可能想要为 Laravel 的内置 `single` 通道配置自定义 Monolog `FormatterInterface` 实现。\r\n\r\n\r\n\r\n首先，在通道的配置上定义一个 `tap` 数组。 `tap` 数组应该包含一个类列表，这些类应该有机会在创建 Monolog 实例后进行自定义（或「tap」）。没有应该放置这些类的常规位置，因此您可以在应用程序中自由创建一个目录来包含这些类：\r\n\r\n    'single' => [\r\n        'driver' => 'single',\r\n        'tap' => [App\\Logging\\CustomizeFormatter::class],\r\n        'path' => storage_path('logs/laravel.log'),\r\n        'level' => 'debug',\r\n    ],\r\n\r\n一旦你在你的通道上配置了 `tap` 选项，你就可以定义自定义你的 Monolog 实例的类了。 这个类只需要一个方法：`__invoke`，它接收一个`Illuminate\\Log\\Logger`实例。 `Illuminate\\Log\\Logger` 实例代理所有对底层 Monolog 实例的方法调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Logging;\r\n\r\n    use Monolog\\Formatter\\LineFormatter;\r\n\r\n    class CustomizeFormatter\r\n    {\r\n        /**\r\n         * Customize the given logger instance.\r\n         *\r\n         * @param  \\Illuminate\\Log\\Logger  $logger\r\n         * @return void\r\n         */\r\n        public function __invoke($logger)\r\n        {\r\n            foreach ($logger->getHandlers() as $handler) {\r\n                $handler->setFormatter(new LineFormatter(\r\n                    '[%datetime%] %channel%.%level_name%: %message% %context% %extra%'\r\n                ));\r\n            }\r\n        }\r\n    }\r\n\r\n> 技巧：您的所有「tap」类都由 [服务容器](/docs/laravel/9.x/container) 解析，因此它们所需的任何构造函数依赖项都将自动注入。\r\n\r\n<a name=\"creating-monolog-handler-channels\"></a>\r\n### 创建 Monolog 处理器通道\r\n\r\nMonolog 有多种 [可用的处理程序](https://github.com/Seldaek/monolog/tree/main/src/Monolog/Handler)，并且 Laravel 没有为每个处理程序包含一个内置通道。 在某些情况下，您可能希望创建一个自定义通道，它只是一个特定的 Monolog 处理程序的实例，它没有相应的 Laravel 日志驱动程序。 这些通道可以使用 `monolog` 驱动轻松创建。\r\n\r\n\r\n\r\n使用 `monolog` 驱动程序时，`handler` 配置选项用于指定将实例化哪个处理程序。或者，可以使用 `with` 配置选项指定处理程序所需的任何构造函数参数：\r\n\r\n    'logentries' => [\r\n        'driver'  => 'monolog',\r\n        'handler' => Monolog\\Handler\\SyslogUdpHandler::class,\r\n        'with' => [\r\n            'host' => 'my.logentries.internal.datahubhost.company.com',\r\n            'port' => '10000',\r\n        ],\r\n    ],\r\n\r\n<a name=\"monolog-formatters\"></a>\r\n#### Monolog 格式化程序\r\n\r\n使用 `monolog` 驱动程序时，Monolog `LineFormatter` 将用作默认格式化程序。但是，您可以使用 `formatter` 和 `formatter_with` 配置选项自定义传递给处理程序的格式化程序类型：\r\n\r\n    'browser' => [\r\n        'driver' => 'monolog',\r\n        'handler' => Monolog\\Handler\\BrowserConsoleHandler::class,\r\n        'formatter' => Monolog\\Formatter\\HtmlFormatter::class,\r\n        'formatter_with' => [\r\n            'dateFormat' => 'Y-m-d',\r\n        ],\r\n    ],\r\n\r\n如果您使用的是能够提供自己的格式化程序的 Monolog 处理程序，您可以将 `formatter` 配置选项的值设置为 `default`：\r\n\r\n    'newrelic' => [\r\n        'driver' => 'monolog',\r\n        'handler' => Monolog\\Handler\\NewRelicHandler::class,\r\n        'formatter' => 'default',\r\n    ],\r\n\r\n<a name=\"creating-custom-channels-via-factories\"></a>\r\n### 通过工厂创建通道\r\n\r\n如果您想定义一个完全自定义的通道，您可以在其中完全控制 Monolog 的实例化和配置，您可以在 `config/logging.php` 配置文件中指定`custom` 驱动程序类型。您的配置应该包括一个 `via` 选项，其中包含将被调用以创建 Monolog 实例的工厂类的名称：\r\n\r\n    'channels' => [\r\n        'example-custom-channel' => [\r\n            'driver' => 'custom',\r\n            'via' => App\\Logging\\CreateCustomLogger::class,\r\n        ],\r\n    ],\r\n\r\n一旦您配置了「custom」驱动程序通道，您就可以定义将创建您的 Monolog 实例的类。这个类只需要一个 __invoke 方法，它应该返回 Monolog 记录器实例。 该方法将接收通道配置数组作为其唯一参数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Logging;\r\n\r\n    use Monolog\\Logger;\r\n\r\n    class CreateCustomLogger\r\n    {\r\n        /**\r\n         * 创建一个自定义 Monolog 实例。\r\n         *\r\n         * @param  array  $config\r\n         * @return \\Monolog\\Logger\r\n         */\r\n        public function __invoke(array $config)\r\n        {\r\n            return new Logger(...);\r\n        }\r\n    }\r\n\r\n","p":"docs/logging.html"},{"t":"laravel-vite-compiles-assets (打包资产 (Vite))","d":"# 打包资产 (Vite)\r\n\r\n- [介绍](#introduction)\r\n- [安装 & 设置](#installation)\r\n  - [安装 Node](#installing-node)\r\n  - [安装 Vite 和 Laravel Plugin](#installing-vite-and-laravel-plugin)\r\n  - [配置 Vite](#configuring-vite)\r\n  - [加载 Scripts 和 Styles](#loading-your-scripts-and-styles)\r\n- [运行 Vite](#running-vite)\r\n- [处理 JavaScript](#working-with-scripts)\r\n  - [别名](#aliases)\r\n  - [Vue](#vue)\r\n  - [React](#react)\r\n  - [Inertia](#inertia)\r\n  - [URL 处理](#url-processing)\r\n- [处理 Stylesheets](#working-with-stylesheets)\r\n- [自定义 Base URLs](#custom-base-urls)\r\n- [环境变量](#environment-variables)\r\n- [服务端渲染 (SSR)](#ssr)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Vite](https://vitejs.dev) 是一个现代的前端构建工具，它提供一个非常快速的开发环境，并将您的代码打包用于生产。使用 Laravel 构建应用程序时，您通常会使用 Vite 将应用程序的 CSS 和 JavaScript 文件绑定到生产环境就绪的资产中。\r\n\r\nLaravel 通过提供官方插件和 Blade 指令来加载您的开发和生产资产。从而与 Vite 无缝衔接。\r\n\r\n> 技巧：您是否运行 Laravel Mix? 在新的 Laravel 安装中，Vite 已经取代 Laravel Mix。如需 Mix 文档，请访问 [Laravel Mix](https://laravel-mix.com/) 站点。如果您想切换到 Vite，请查看我们 [迁移指引](https://github.com/laravel/vite-plugin/blob/main/UPGRADE.md#migrating-from-laravel-mix-to-vite).\r\n\r\n<a name=\"vite-or-mix\"></a>\r\n####  在 Vite 和 Laravel Mix 之间选择\r\n\r\n在过渡到 Vite 之前，当打包资产时，新的 Laravel 应用使用 [Mix](https://laravel-mix.com/)，它由 [webpack](https://webpack.js.org/) 来支持。在构建富 JavaScript 应用时，Vite 致力于提供一个更快和更高效的体验。如果您开发一个单网页应用 (SPA)，包括使用以下工具开发，如 [Inertia](https://inertiajs.com)，Vite 将会更加适合。\r\n\r\n\r\n\r\nVite 也适用于带有 JavaScript \"sprinkles\" 的传统服务端渲染应用程序，包括使用 [Livewire](https://laravel-livewire.com) 。然而，它缺少 Laravel Mix 支持的一些特性，例如将任意资源复制到构建中的能力，而这些资源没有在 JavaScript 应用程序中直接引用。\r\n\r\n<a name=\"迁移回 Mix\"></a>\r\n#### 迁移回 Mix\r\n\r\n您是否使用我们的 Vite 脚手架开始新的 Laravel 应用程序，但需要回到 Laravel Mix 和 webpack ？没问题。请查阅 [从 Vite 迁移到 Mix 官方指南](https://github.com/laravel/vite-plugin/blob/main/UPGRADE.md#migrating-from-vite-to-laravel-mix)。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装 & 设置\r\n\r\n> 技巧：以下文档讨论了如何动手安装和配置 Laravel Vite 插件。然而，Larvel 的 [入门套件](/docs/laravel/9.x/starter-kits) 已经包含了所有这些脚手架，这是开始使用 Laravel 和 Vite 的最快方式。\r\n\r\n<a name=\"installing-node\"></a>\r\n### 安装 Node\r\n\r\n在运行 Vite 和 Laravel 插件之前，您必须确保已安装 Node.js 和 NPM\r\n\r\n```sh\r\nnode -v\r\nnpm -v\r\n```\r\n\r\n你可以使用来自 [Node 官方](https://nodejs.org/en/ownload/) 的简单图形安装程序轻松安装最新的 Node 和 NPM。或者，如果你使用[Laravel Sail](https://laravel.com/docs/laravel/9.x/sail)，你可以通过 Sail 调用 Node 和 NPM：\r\n\r\n\r\n```sh\r\n./vendor/bin/sail node -v\r\n./vendor/bin/sail npm -v\r\n```\r\n\r\n<a name=\"installing-vite-and-laravel-plugin\"></a>\r\n### 安装 Vite 和 Laravel Plugin\r\n\r\n在 Laravel 的全新安装中，您会在应用程序目录结构的根目录中找到一个 `package.json` 文件。 默认的 `package.json` 文件已经包含了你开始使用 Vite 和 Laravel 插件所需的一切。 您可以通过 NPM 安装应用程序的前端依赖项：\r\n\r\n```sh\r\nnpm install\r\n```\r\n\r\n\r\n\r\n<a name=\"configuring-vite\"></a>\r\n### 配置 Vite\r\n\r\nVite是通过项目根目录的 `vite.config.js` 文件配置的。您可以根据自己的需求自由自定义此文件，还可以安装应用程序所需的任何其他插件，例如 `@vitejs/plugin-vue` 或 `@vitejs/plugin-react` 。\r\n\r\nLaravel Vite插件要求您指定应用程序的入口点。这些可能是 JavaScript 或 CSS 文件，和其他预处理语言，例如 Typescript，JSX，TSX 和 SASS。\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel([\r\n            'resources/css/app.css',\r\n            'resources/js/app.js',\r\n        ]),\r\n    ],\r\n});\r\n```\r\n\r\n如果您正在构建 SPA，包括使用 Inertia 构建的应用程序，则 Vite 在没有 CSS 入口点的情况下运行最佳：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel([\r\n            // 'resources/css/app.css',\r\n            'resources/js/app.js',\r\n        ]),\r\n    ],\r\n});\r\n```\r\n\r\n作为替代，您应该通过 JavaScript 导入 CSS。通常，这将在您的应用程序的 `resources/js/app.js` 文件中完成：\r\n\r\n```js\r\nimport './bootstrap';\r\nimport '../css/app.css'; // 新增\r\n```\r\n\r\nLaravel 插件还支持多个入口点和高级配置选项，例如 [SSR 入口点](#ssr)。\r\n\r\n<a name=\"working-with-a-secure-development-server\"></a>\r\n#### 通过一个安全的开发服务器工作\r\n\r\n如果您的开发 Web 服务器在 HTTPS 上运行，包括 Valet 的 [secure command](/docs/laravel/9.x/valet#securing-sites)，您可能会遇到连接到Vite开发服务器的问题。您可以通过将以下内容添加到 `vite.config.js` 配置文件：\r\n\r\n```js\r\nexport default defineConfig({\r\n    // ...\r\n    server: {\r\n        https: true,\r\n        host: 'localhost',\r\n    },\r\n});\r\n```\r\n\r\n\r\n\r\n当您运行 `npm run dev` 命令时，你还需要通过控制台中的「Local」链接来接受浏览器中 Vite 开发服务器的证书警告。\r\n\r\n<a name=\"loading-your-scripts-and-styles\"></a>\r\n### 加载 Scripts 和 Styles\r\n\r\n配置好 Vite 的入口点后，您仅需要在 `@vite()` Blade 指令中引用它们，该指令被添加到你的应用根模板的 `<head>` 中：\r\n\r\n```html\r\n<!doctype html>\r\n<head>\r\n    {{-- ... --}}\r\n\r\n    @vite(['resources/css/app.css', 'resources/js/app.js'])\r\n</head>\r\n```\r\n\r\n如果您通过 JavaScript 引入 CSS，您仅需要包含 JavaScript 入口点：\r\n\r\n```html\r\n<!doctype html>\r\n<head>\r\n    {{-- ... --}}\r\n\r\n    @vite('resources/js/app.js')\r\n</head>\r\n```\r\n\r\n`@vite` 指令将自动检测 Vite 开发服务器并注入 Vite 客户端以启动热模块更换。在构建模式下，这个指令将加载已编译和版本化的资产，包括任何导入的 CSS。\r\n\r\n<a name=\"running-vite\"></a>\r\n## 运行 Vite\r\n\r\n有两种方式可以运行 Vite。您可以通过 `dev` 命令运行开发服务器，它在本地开发是很有用的。这个开发服务器将自动检测您文件的改变并在任何打开的浏览器窗口中立即反映它们。\r\n\r\n或者，运行 `build` 命令，将应用程序的资产做版本和打包，并为您部署到生产环境做准备：\r\n\r\n```shell\r\n# 运行 Vite 开发服务器...\r\nnpm run dev\r\n\r\n# 构建并为生产环境版本化资产...\r\nnpm run build\r\n```\r\n\r\n<a name=\"working-with-scripts\"></a>\r\n## 处理 JavaScript\r\n\r\n<a name=\"aliases\"></a>\r\n### 别名\r\n\r\n默认情况下，Laravel 插件提供一个命令别名去帮助你启动并方便地导入应用程序资产：\r\n```js\r\n{\r\n    '@' => '/resources/js'\r\n}\r\n```\r\n\r\n\r\n\r\n您可以通过将自己的别名添加到 `vite.config.js` 配置文件中来覆盖 `'@'` 别名：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel(['resources/ts/app.tsx']),\r\n    ],\r\n    resolve: {\r\n        alias: {\r\n            '@': '/resources/ts',\r\n        },\r\n    },\r\n});\r\n```\r\n\r\n<a name=\"vue\"></a>\r\n### Vue\r\n\r\n当 Vue 插件和 Laravel 插件一起使用时，以下是需要在 `vite.config.js` 配置文件中包含的几个附加的选项。\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\nimport vue from '@vitejs/plugin-vue';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel(['resources/js/app.js']),\r\n        vue({\r\n            template: {\r\n                transformAssetUrls: {\r\n                    // Vue 插件将重写资产 URLs，当被引用\r\n                    // 在单文件组件中，指向 Laravel Web 服务\r\n                    // 设置它为 `null` 允许 Laravel 插件\r\n                    // 去替代重写资产 URLs 指向到 Vite 服务\r\n                    base: null,\r\n\r\n                    //  Vue 插件将解析绝对 URLs \r\n                    // 并把它们看做磁盘上的绝对路径。\r\n                    // 设置它为 `false` 将保留绝对 URLs \r\n                    // 以便它们可以按照预期直接引用公共资产。\r\n                    includeAbsolute: false,\r\n                },\r\n            },\r\n        }),\r\n    ],\r\n});\r\n```\r\n\r\n> 技巧：Laravel 的 [初学者工具包](/docs/laravel/9.x/starter-kits) 已经包含适合的 Laravel， Vue 和 Vite 配置。检出 [Laravel Breeze](/docs/laravel/9.x/starter-kits#breeze-and-inertia) 以最快的方式开始学习 Laravel, Vue 和 Vite。\r\n\r\n<a name=\"react\"></a>\r\n### React\r\n\r\n当使用 Vite 和 React 时，您将需要确保任何包含 JSX 的文件都有一个 `.jsx` 和 `.tsx` 扩展，记住更新入口点，如果需要 [如上所示](#configuring-vite)。您还需要在现有的 `@vite` 指令旁边包含额外的 `@viteReactRefresh` Blade 指令。\r\n\r\n```blade\r\n@viteReactRefresh\r\n@vite('resources/js/app.jsx')\r\n```\r\n\r\n\r\n\r\n `@viteReactRefresh` 指令必须在 `@vite` 指令之前被调用。\r\n\r\n> 技巧：Laravel 的 初学者工具包 已经包含适合的 Laravel， React 和 Vite 配置。检出 Laravel Breeze 以最快的方式开始学习 Laravel, React 和 Vite。\r\n\r\n<a name=\"inertia\"></a>\r\n### Inertia\r\n\r\nLaravel Vite 插件提供了一个便利的 `resolvePageComponent` 函数去帮助你解决 Inertia 页面组件。以下是一个使用 Vue 3 的助手示例；然而，您也可能需要在其他框架使用这个函数，如 React：\r\n\r\n```js\r\nimport { createApp, h } from 'vue';\r\nimport { createInertiaApp } from '@inertiajs/inertia-vue3';\r\nimport { resolvePageComponent } from 'laravel-vite-plugin/inertia-helpers';\r\n\r\ncreateInertiaApp({\r\n  resolve: (name) => resolvePageComponent(`./Pages/${name}.vue`, import.meta.glob('./Pages/**/*.vue')),\r\n  setup({ el, App, props, plugin }) {\r\n    createApp({ render: () => h(App, props) })\r\n      .use(plugin)\r\n      .mount(el)\r\n  },\r\n});\r\n```\r\n\r\n> 技巧：Laravel 的 初学者工具包 已经包含适合的 Laravel， Inertia 和 Vite 配置。检出 Laravel Breeze 以最快的方式开始学习 Laravel, Inertia 和 Vite。\r\n\r\n<a name=\"url-processing\"></a>\r\n### URL 处理\r\n\r\n当使用 Vite 并在您的应用程序的 HTML，CSS 和 JS 中引用资产时，有几件事情需要考虑。首先，如果您使用绝对路径引用资产，Vite 将不会在构建中包含资产；因此，您需要确认资产在你的公共目录中是可用的。\r\n\r\n当引用相对资产路径时，您应该记住，路径是相对于引用他们的文件的。任何通过相对路径的资产都由 Vite 重新编写，版本控制和绑定。\r\n\r\n\r\n\r\n考虑以下项目结构：\r\n\r\n```nothing\r\npublic/\r\n  taylor.png\r\nresources/\r\n  js/\r\n    Pages/\r\n      Welcome.vue\r\n  images/\r\n    abigail.png\r\n```\r\n\r\n以下示例演示了 Vite 如何处理相对和绝对 URLs：\r\n\r\n```html\r\n<!-- This asset is not handled by Vite and will not be included in the build -->\r\n<img src=\"/taylor.png\">\r\n\r\n<!-- This asset will be re-written, versioned, and bundled by Vite -->\r\n<img src=\"../../images/abigail.png\">\r\n```\r\n\r\n<a name=\"working-with-stylesheets\"></a>\r\n## 处理 Stylesheets\r\n\r\n您可以学习更多有关 Vite 的 CSS 支持在 [Vite 文档](https://vitejs.dev/guide/features.html#css) 中。如果您在使用 PostCSS 插件，比如 [Tailwind](https://tailwindcss.com)，你可以创建一个 `postcss.config.js` 文件在你项目的根目录中，然后 Vite 将自动应用它：\r\n\r\n```js\r\nmodule.exports = {\r\n    plugins: {\r\n        tailwindcss: {},\r\n        autoprefixer: {},\r\n    },\r\n};\r\n```\r\n\r\n<a name=\"custom-base-urls\"></a>\r\n## 自定义 Base URLs\r\n\r\n如果您的 Vite 编译资产被部署到一个与应用程序分离的域，比如通过一个 CDN，您必须明确在应用 `.env` 文件中的 `ASSET_URL` 环境变量：\r\n\r\n```env\r\nASSET_URL=https://cdn.example.com\r\n```\r\n\r\n在配置完资产 URL 时，所有重写的资产 URL，都将以配置中的值作为前缀：\r\n\r\n```URL\r\nhttps://cdn.example.com/build/assets/app.9dce8d17.js\r\n```\r\n\r\n记住 [绝对 URLs 不会被 Vite 重写](#url-processing)，因此也将不会被前置内容。\r\n\r\n<a name=\"environment-variables\"></a>\r\n## 环境变量\r\n\r\n您可以通过在应用程序的 `.env` 文件中使用 `VITE_` 来将环境变量注入到JavaScript中：\r\n\r\n```env\r\nVITE_SENTRY_DSN_PUBLIC=http://example.com\r\n```\r\n\r\n\r\n\r\n您可以通过 `import.meta.env` 对象访问被注入的环境变量：\r\n\r\n```js\r\nimport.meta.env.VITE_SENTRY_DSN_PUBLIC\r\n```\r\n\r\n<a name=\"ssr\"></a>\r\n## 服务端渲染 (SSR)\r\n\r\nLaravel Vite 插件可以轻松的使用 Vite 设置服务端渲染。首先，在 `resources/js/ssr.js` 创建一个 SSR 入口点并通过向 Laravel 插件传递配置选项来指定入口点：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            input: 'resources/js/app.js',\r\n            ssr: 'resources/js/ssr.js',\r\n        }),\r\n    ],\r\n});\r\n```\r\n\r\n为了确保您不会忘记重建 SSR 入口点，我建议在您应用的 `package.json` 增加「构建」脚本去创建您的 SSR 构建：\r\n\r\n```json\r\n\"scripts\": {\r\n     \"dev\": \"vite\",\r\n     \"build\": \"vite build\" // [tl! remove]\r\n     \"build\": \"vite build && vite build --ssr\" // [tl! add]\r\n}\r\n```\r\n\r\n然后，要构建和开启 SSR 服务，可以运行一下命令：\r\n\r\n```sh\r\nnpm run build\r\nnode storage/ssr/ssr.js\r\n```\r\n\r\n> Laravel 的 [初学者工具包](https://learnku.com/docs/laravel/9.x/starter-kits) 已经包含适合的 Laravel， Inertia SSR 和 Vite 配置。检出 [Laravel Breeze](https://learnku.com/docs/laravel/9.x/starter-kits#breeze-and-inertia) 以最快的方式开始学习 Laravel, Inertia SSR 和 Vite。\r\n\r\n","p":"docs/laravel-vite-compiles-assets.html"},{"t":"artisan (Artisan 命令行)","d":"# Artisan 命令行\r\n\r\n- [简介](#introduction)\r\n    - [Tinker 命令 (REPL)](#tinker)\r\n- [编写命令](#writing-commands)\r\n    - [生成命令](#generating-commands)\r\n    - [命令结构](#command-structure)\r\n    - [闭包命令](#closure-commands)\r\n- [定义输入期望](#defining-input-expectations)\r\n    - [参数](#arguments)\r\n    - [选项](#options)\r\n    - [输入数组](#input-arrays)\r\n    - [输入说明](#input-descriptions)\r\n- [I/O 命令](#command-io)\r\n    - [检索输入](#retrieving-input)\r\n    - [交互式输入](#prompting-for-input)\r\n    - [编写输出](#writing-output)\r\n- [注册命令](#registering-commands)\r\n- [在程序中执行命令](#programmatically-executing-commands)\r\n    - [从其他命令调用命令](#calling-commands-from-other-commands)\r\n- [信号处理](#signal-handling)\r\n- [Stub 定制](#stub-customization)\r\n- [响应](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nArtisan 是 Laravel 附带的命令行接口。 Artisan 以 `artisan` 脚本的形式存在于应用的根目录，并提供了许多有用的命令，这些命令可以在构建应用时为你提供帮助。你可以通过 `list` 命令查看所有可用的 Artisan 命令：\r\n\r\n```shell\r\nphp artisan list\r\n```\r\n\r\n每个命令都包含了「help」界面，它会显示和概述命令的可用参数及选项。只需要在命令前加上 `help` 即可查看命令帮助界面：\r\n\r\n```shel\r\nphp artisan help migrate\r\n```\r\n\r\n<a name=\"laravel-sail\"></a>\r\n#### Laravel Sail\r\n\r\n如果你将 [Laravel Sail](/docs/laravel/9.x/sail) 用作本地开发环境，记得使用 `sail` 命令行来调用 Artisan 命令。Sail 将在应用的 Docker 容器中执行 Artisan 命令：\r\n\r\n```shell\r\n./sail artisan list\r\n```\r\n\r\n<a name=\"tinker\"></a>\r\n### Tinker 命令 (REPL)\r\n\r\nLaravel Tinker 是为 Laravel 提供的强大的 REPL（交互式解释器），由 [PsySH](https://github.com/bobthecow/psysh) 提供支持。\r\n\r\n\r\n\r\n<a name=\"installation\"></a>\r\n#### 安装\r\n\r\n所有 Laravel 应用都默认包含了 Tinker。如果你之前已经将 Tinker 从应用中删除，可以使用 Composer 进行手动安装：\r\n\r\n```shell\r\ncomposer require laravel/tinker\r\n```\r\n\r\n> 技巧：正在寻找一个能与 Laravel 交互的图形用户界面吗？试试 [Tinkerwell](https://tinkerwell.app)!\r\n\r\n<a name=\"usage\"></a>\r\n#### 用法\r\n\r\nTinker 让你可以在命令行与你的整个 Laravel 应用进行交互。包括但不限于 Eloquent模型、任务、事件等。通过运行 Artisan 命令 `tinker` 进入 Tinker 环境。\r\n\r\n```shell\r\nphp artisan tinker\r\n```\r\n\r\n你可以通过 `vendor:publish` 命令发布 Tinker 配置文件：\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Tinker\\TinkerServiceProvider\"\r\n```\r\n\r\n> 注意：`Dispatchable` 类中的 `dispatch` 辅助函数和 `dispatch` 方法已被弃用以将任务添加至队列中。因此，当你使用 Tinker 时，请使用 `Bus::dispatch` 或 `Queue::push` 来分发任务。\r\n\r\n<a name=\"command-allow-list\"></a>\r\n#### 命令白名单\r\n\r\nTinker 采用白名单来确定允许哪些 Artisan 命令可以在 shell 中运行。默认情况下，你可以运行 `clear-compiled`、`down`、`env`、`inspire`、`migrate`、`optimize` 和 `up` 命令。如果你想将命令添加到白名单，请将该命令添加到 `tinker.php` 配置文件的 `commands` 数组中：\r\n\r\n    'commands' => [\r\n        // App\\Console\\Commands\\ExampleCommand::class,\r\n    ],\r\n\r\n<a name=\"classes-that-should-not-be-aliased\"></a>\r\n#### 别名黑名单\r\n\r\n大多数情况下，Tinker 会在你引入类时自动为其添加别名。然而，你可能不希望为某些类添加别名。你可以在 `tinker.php` 配置文件中的 `dont_alias` 数组里列举这些类来完成此操作：\r\n\r\n    'dont_alias' => [\r\n        App\\Models\\User::class,\r\n    ],\r\n\r\n\r\n\r\n<a name=\"writing-commands\"></a>\r\n## 编写命令\r\n\r\n除 Artisan 提供的命令外，你也可以编写自己的自定义命令。命令在多数情况下位于 `app/Console/Commands` 目录中。 不过，只要你的命令可以由 Composer 加载，你就可以自由选择自己的存储位置。\r\n\r\n<a name=\"generating-commands\"></a>\r\n### 生成命令\r\n\r\n要创建新命令，可以使用 `make:command` Artisan 命令。该命令将在 `app/Console/Commands` 目录中创建一个新的命令类。如果你的应用程序中不存在此目录，请不要担心，它将在您第一次运行 `make:command` 命令时自动创建：\r\n\r\n```shell\r\nphp artisan make:command SendEmails\r\n```\r\n\r\n<a name=\"command-structure\"></a>\r\n### 命令结构\r\n\r\n生成命令后，应为该类的 `signature` 和 `description` 属性定义适当的值。当在 `list` 屏幕上显示命令时，将使用这些属性。 `signature` 属性还允许您定义 [命令的输入期望值](#defining-input-expectations)。 `handle` 执行命令时将调用该方法。你可以将命令逻辑放在此方法中。\r\n\r\n让我们看一个示例命令。请注意，我们能够通过命令的 `handle` 方法请求我们需要的任何依赖项。Laravel [服务容器](/docs/laravel/9.x/container) 将自动注入此方法签名中带有类型提示的所有依赖项：\r\n\r\n    <?php\r\n\r\n    namespace App\\Console\\Commands;\r\n\r\n    use App\\Models\\User;\r\n    use App\\Support\\DripEmailer;\r\n    use Illuminate\\Console\\Command;\r\n\r\n    class SendEmails extends Command\r\n    {\r\n        /**\r\n         * 命令名称及签名.\r\n         *\r\n         * @var string\r\n         */\r\n        protected $signature = 'mail:send {user}';\r\n\r\n        /**\r\n         * 命令描述.\r\n         *\r\n         * @var string\r\n         */\r\n        protected $description = 'Send a marketing email to a user';\r\n\r\n        /**\r\n         * 创建命令.\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            parent::__construct();\r\n        }\r\n\r\n        /**\r\n         * 执行命令.\r\n         *\r\n         * @param  \\App\\Support\\DripEmailer  $drip\r\n         * @return mixed\r\n         */\r\n        public function handle(DripEmailer $drip)\r\n        {\r\n            $drip->send(User::find($this->argument('user')));\r\n        }\r\n    }\r\n\r\n> 技巧：为了更好地复用代码，请尽量让你的命令类保持轻量并且能够延迟到应用服务中完成。在上面的示例中，我们注入了一个服务类来进行发送电子邮件的「繁重工作」。\r\n\r\n\r\n\r\n<a name=\"closure-commands\"></a>\r\n### 闭包命令\r\n\r\n基于闭包的命令为将控制台命令定义为类提供了一种替代方法。与路由闭包可以替代控制器一样，可以将命令闭包视为命令类的替代。在 `app/Console/Kernel.php` 文件的  `commands` 方法中 ，Laravel 加载 `routes/console.php` 文件：\r\n\r\n    /**\r\n     * 注册闭包命令\r\n     *\r\n     * @return void\r\n     */\r\n    protected function commands()\r\n    {\r\n        require base_path('routes/console.php');\r\n    }\r\n\r\n尽管该文件没有定义 HTTP 路由，但它定义了进入应用程序的基于控制台的入口 (routes) 。在这个文件中，你可以使用 `Artisan::command` 方法定义所有的闭包路由。 `command` 方法接受两个参数： [命令名称](#defining-input-expectations) 和可调用的闭包，闭包接收命令的参数和选项：\r\n\r\n    Artisan::command('mail:send {user}', function ($user) {\r\n        $this->info(\"Sending email to: {$user}!\");\r\n    });\r\n\r\n该闭包绑定到基础命令实例，因此你可以完全访问通常可以在完整命令类上访问的所有辅助方法。\r\n\r\n<a name=\"type-hinting-dependencies\"></a>\r\n#### 类型约束依赖\r\n\r\n除了接受命令参数及选项外，命令闭包也可以使用类型约束从 [服务容器](/docs/laravel/9.x/container) 中解析其他的依赖关系：\r\n\r\n    use App\\Models\\User;\r\n    use App\\Support\\DripEmailer;\r\n\r\n    Artisan::command('mail:send {user}', function (DripEmailer $drip, $user) {\r\n        $drip->send(User::find($user));\r\n    });\r\n\r\n<a name=\"closure-command-descriptions\"></a>\r\n#### 闭包命令说明\r\n\r\n在定义基于闭包的命令时，可以使用 `purpose` 方法向命令添加描述。当你运行 `php artisan list` 或 `php artisan help` 命令时，将显示以下描述：\r\n\r\n    Artisan::command('mail:send {user}', function ($user) {\r\n        // ...\r\n    })->purpose('Send a marketing email to a user');\r\n\r\n\r\n\r\n<a name=\"defining-input-expectations\"></a>\r\n## 定义输入期望\r\n\r\n在编写控制台命令时，通常是通过参数和选项来收集用户输入的。 Laravel 让你可以非常方便地在 `signature` 属性中定义你期望用户输入的内容。`signature` 属性允许使用单一且可读性高，类似路由的语法来定义命令的名称、参数和选项。\r\n\r\n<a name=\"arguments\"></a>\r\n### 参数\r\n\r\n用户提供的所有参数和选项都用花括号括起来。在下面的示例中，该命令定义了一个必需的参数 `user`:\r\n\r\n    /**\r\n     * 命令的名称及其标识\r\n     *\r\n     * @var string\r\n     */\r\n    protected $signature = 'mail:send {user}';\r\n\r\n您亦可创建可选参数或为参数定义默认值：\r\n\r\n    // 可选参数...\r\n    'mail:send {user?}'\r\n\r\n    // 带有默认值的可选参数...\r\n    'mail:send {user=foo}'\r\n\r\n<a name=\"options\"></a>\r\n### 选项\r\n\r\n选项类似于参数，是用户输入的另一种形式。在命令行中指定选项的时候，它们以两个短横线 (--) 作为前缀。这有两种类型的选项：接收值和不接受值。不接收值的选项就像是一个布尔「开关」。我们来看一下这种类型的选项的示例：\r\n\r\n    /**\r\n     * 命令的名称及其标识\r\n     *\r\n     * @var string\r\n     */\r\n    protected $signature = 'mail:send {user} {--queue}';\r\n\r\n在这个例子中，在调用 Artisan 命令时可以指定 `--queue` 的开关。如果传递了 `--queue` 选项，该选项的值将会是 `true`。否则，其值将会是 `false`：\r\n\r\n```shell\r\nphp artisan mail:send 1 --queue\r\n```\r\n\r\n\r\n\r\n<a name=\"options-with-values\"></a>\r\n#### 带值的选项\r\n\r\n接下来，我们来看一下需要带值的选项。如果用户需要为一个选项指定一个值，则需要在选项名称的末尾追加一个 `=` 号：\r\n\r\n    /**\r\n     * 命令名称及标识\r\n     *\r\n     * @var string\r\n     */\r\n    protected $signature = 'mail:send {user} {--queue=}';\r\n\r\n在这个例子中，用户可以像如下所时的方式传递该选项的值。如果在调用命令时未指定该选项，则其值为 `null`：\r\n\r\n```shell\r\nphp artisan mail:send 1 --queue=default\r\n```\r\n\r\n你还可以在选项名称后指定其默认值。如果用户没有传递值给选项，将使用默认的值：\r\n\r\n    'mail:send {user} {--queue=default}'\r\n\r\n<a name=\"option-shortcuts\"></a>\r\n#### 选项简写\r\n\r\n要在定义选项的时候指定一个简写，您可以在选项名前面使用 `|` 隔符将选项名称与其简写分隔开来：\r\n\r\n    'mail:send {user} {--Q|queue}'\r\n\r\n在终端上调用命令时，选项简写的前缀只用一个连字符：\r\n\r\n```shell\r\nphp artisan mail:send 1 -Q\r\n```\r\n\r\n<a name=\"input-arrays\"></a>\r\n### 输入数组\r\n\r\n如果您想要接收数组数组的参数或者选项，您可以使用 `*` 字符。首先，让我们看一下指定了一个数组参数的例子：\r\n\r\n    'mail:send {user*}'\r\n\r\n当调用这个方法的时候，`user` 参数的输入参数将按顺序传递给命令。例如，以下命令将会设置 `user` 的值为 `foo` 和 `bar` ：\r\n\r\n```shell\r\nphp artisan mail:send foo bar\r\n```\r\n\r\n\r\n\r\n `*` 字符可以与可选的参数结合使用，允许您定义零个或多个参数实例：\r\n\r\n    'mail:send {user?*}'\r\n\r\n<a name=\"option-arrays\"></a>\r\n#### 选项数组\r\n\r\n当定义需要多个输入值的选项时，传递给命令的每个选项值都应以选项名称作为前缀：\r\n\r\n    'mail:send {user} {--id=*}'\r\n\r\n这样的命令可以通过传递多个 `--id` 参数来调用：\r\n\r\n```shell\r\nphp artisan mail:send --id=1 --id=2\r\n```\r\n\r\n<a name=\"input-descriptions\"></a>\r\n### 输入说明\r\n\r\n您可以通过使用冒号将参数名称与描述分隔来为输入参数和选项指定说明。如果您需要一些额外的空间来定义命令，可以将它自由的定义在多行中：\r\n\r\n    /**\r\n     * 控制台命令的名称和签名。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $signature = 'mail:send\r\n                            {user : The ID of the user}\r\n                            {--queue : Whether the job should be queued}';\r\n\r\n<a name=\"command-io\"></a>\r\n## 命令 I/O\r\n\r\n<a name=\"retrieving-input\"></a>\r\n### 检索输入\r\n\r\n当命令在执行时，您可能需要访问命令所接受的参数和选项的值。为此，您可以使用 `argument` 和 `option` 方法。如果选项或参数不存在，将会返回`null`：\r\n\r\n    /**\r\n     * 执行控制台命令。\r\n     *\r\n     * @return int\r\n     */\r\n    public function handle()\r\n    {\r\n        $userId = $this->argument('user');\r\n\r\n        //\r\n    }\r\n\r\n如果您需要检索所有的参数做为 `array`，请调用 `arguments` 方法：\r\n\r\n    $arguments = $this->arguments();\r\n\r\n选项的检索与参数一样容易，使用 `option` 方法即可。如果要检索所有的选项做为数组，请调用 `options` 方法：\r\n\r\n    // 检索一个指定的选项...\r\n    $queueName = $this->option('queue');\r\n\r\n    // 检索所有选项做为数组...\r\n    $options = $this->options();\r\n\r\n\r\n\r\n<a name=\"prompting-for-input\"></a>\r\n### 交互式输入\r\n\r\n除了显示输出以外，你还可以要求用户在执行命令期间提供输入。`ask` 方法将询问用户指定的问题来接收用户输入，然后用户输入将会传到你的命令中：\r\n\r\n    /**\r\n     * 执行命令指令\r\n     *\r\n     * @return mixed\r\n     */\r\n    public function handle()\r\n    {\r\n        $name = $this->ask('What is your name?');\r\n    }\r\n\r\n`secret` 方法与 `ask` 相似，区别在于用户的输入将不可见。这个方法在需要输入一些诸如密码之类的敏感信息时是非常有用的：\r\n\r\n    $password = $this->secret('What is the password?');\r\n\r\n<a name=\"asking-for-confirmation\"></a>\r\n#### 请求确认\r\n\r\n如果你需要请求用户进行一个简单的确认，可以使用 `confirm` 方法来实现。默认情况下，这个方法会返回 `false`。当然，如果用户输入 `y` 或 `yes`，这个方法将会返回 `true`。\r\n\r\n    if ($this->confirm('Do you wish to continue?')) {\r\n        //\r\n    }\r\n\r\n如有必要，你可以通过将 `true` 作为第二个参数传递给 `confirm` 方法，这样就可以在默认情况下返回 `true`：\r\n\r\n    if ($this->confirm('Do you wish to continue?', true)) {\r\n        //\r\n    }\r\n\r\n<a name=\"auto-completion\"></a>\r\n#### 自动补全\r\n\r\n`anticipate` 方法可用于为可能的选项提供自动补全功能。用户依然可以忽略自动补全的提示，进行任意回答：\r\n\r\n    $name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);\r\n\r\n或者，你可以将一个闭包作为第二个参数传递给 `anticipate` 方法。每当用户键入字符时，闭包函数都会被调用。闭包函数应该接受一个包含用户输入的字符串形式的参数，并返回一个可供自动补全的选项的数组：\r\n\r\n    $name = $this->anticipate('What is your address?', function ($input) {\r\n        // 返回自动完成配置...\r\n    });\r\n\r\n\r\n\r\n<a name=\"multiple-choice-questions\"></a>\r\n#### 多选择问题\r\n\r\n当询问问题时，如果您需要给用户一个预定义的选择，您可以使用 `choice` 方法。如果没有选项被选择，您可以设置数组索引的默认值去返回，通过这个方法的第三个参数去传入索引：\r\n\r\n    $name = $this->choice(\r\n        'What is your name?',\r\n        ['Taylor', 'Dayle'],\r\n        $defaultIndex\r\n    );\r\n\r\n此外， `choice` 方法接受第四和第五可选参数 ，用于确定选择有效响应的最大尝试次数以及是否允许多次选择：\r\n\r\n    $name = $this->choice(\r\n        'What is your name?',\r\n        ['Taylor', 'Dayle'],\r\n        $defaultIndex,\r\n        $maxAttempts = null,\r\n        $allowMultipleSelections = false\r\n    );\r\n\r\n<a name=\"writing-output\"></a>\r\n### 文字输出\r\n\r\n您可以使用 `line`，`info`，`comment`，`question` 和 `error` 方法，发送输出到控制台。 这些方法中的每一个都会使用合适的 ANSI 颜色以展示不同的用途。例如，我们要为用户展示一些常规信息。通常，`info` 将会以绿色文本在控制台展示。\r\n\r\n    /**\r\n     * 执行控制台命令\r\n     *\r\n     * @return mixed\r\n     */\r\n    public function handle()\r\n    {\r\n        // ...\r\n\r\n        $this->info('The command was successful!');\r\n    }\r\n\r\n输出错误信息，使用 `error` 方法。错误信息通常使用红色字体显示：\r\n\r\n    $this->error('Something went wrong!');\r\n\r\n您可以使用 `line` 方法输出无色文本：\r\n\r\n    $this->line('Display this on the screen');\r\n\r\n您可以使用 `newLine` 方法输出空白行：\r\n\r\n    // 输出单行空白...\r\n    $this->newLine();\r\n\r\n    // 输出三行空白...\r\n    $this->newLine(3);\r\n\r\n\r\n\r\n<a name=\"tables\"></a>\r\n#### 表格\r\n\r\n`table` 方法可以轻松正确地格式化多行/多列数据。您需要做的就是提供表的列名和数据，Laravel 会自动为您计算合适的表格宽度和高度：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $this->table(\r\n        ['Name', 'Email'],\r\n        User::all(['name', 'email'])->toArray()\r\n    );\r\n\r\n<a name=\"progress-bars\"></a>\r\n#### 进度条\r\n\r\n对于长时间运行的任务，显示一个进度条来告知用户任务的完成情况会很有帮助。使用 `withProgressBar` 方法，Laravel 将显示一个进度条，并在给定的可迭代值上推进每次迭代的进度：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = $this->withProgressBar(User::all(), function ($user) {\r\n        $this->performTask($user);\r\n    });\r\n\r\n有时，您可能需要更多手动控制进度条的前进方式。首先，定义流程将迭代的步骤总数。然后，在处理完每个项目后推进进度条：\r\n\r\n    $users = App\\Models\\User::all();\r\n\r\n    $bar = $this->output->createProgressBar(count($users));\r\n\r\n    $bar->start();\r\n\r\n    foreach ($users as $user) {\r\n        $this->performTask($user);\r\n\r\n        $bar->advance();\r\n    }\r\n\r\n    $bar->finish();\r\n\r\n> 技巧：有关更多高级选项，请查看 [Symfony 进度条组件文档](https://symfony.com/doc/current/components/console/helpers/progressbar.html).\r\n\r\n<a name=\"registering-commands\"></a>\r\n## 注册命令\r\n\r\n您的所有控制台命令都在您的应用程序的 `App\\Console\\Kernel` 类中注册，这是您的应用程序的「控制台内核」。在此类的 `commands` 方法中，您将看到对内核的 `load` 方法的调用。 `load` 方法将扫描 `app/Console/Commands` 目录并自动将其中包含的每个命令注册到 Artisan。 您甚至可以自由地调用 `load` 方法来扫描其他目录以查找 Artisan 命令：\r\n\r\n    /**\r\n     * 注册应用程序的命令。\r\n     *\r\n     * @return void\r\n     */\r\n    protected function commands()\r\n    {\r\n        $this->load(__DIR__.'/Commands');\r\n        $this->load(__DIR__.'/../Domain/Orders/Commands');\r\n\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n如有必要，您可以通过将命令的类名添加到 `App\\Console\\Kernel` 类中的 `$commands` 属性来手动注册命令。如果您的内核上尚未定义此属性，则应手动定义它。 当 Artisan 启动时，此属性中列出的所有命令将由 [服务容器](/docs/laravel/9.x/container) 解析并注册到 Artisan：\r\n\r\n    protected $commands = [\r\n        Commands\\SendEmails::class\r\n    ];\r\n\r\n<a name=\"programmatically-executing-commands\"></a>\r\n## 以编程方式执行命令\r\n\r\n有时您可能希望在 CLI 之外执行 Artisan 命令。例如，您可能希望从路由或控制器执行 Artisan 命令。您可以使用 `Artisan` 外观上的 `call` 方法来完成此操作。 `call` 方法接受命令的签名名称或类名作为其第一个参数，以及一个命令参数数组作为第二个参数。将返回退出代码：\r\n\r\n    use Illuminate\\Support\\Facades\\Artisan;\r\n\r\n    Route::post('/user/{user}/mail', function ($user) {\r\n        $exitCode = Artisan::call('mail:send', [\r\n            'user' => $user, '--queue' => 'default'\r\n        ]);\r\n\r\n        //\r\n    });\r\n\r\n或者，您可以将整个 Artisan 命令作为字符串传递给 `call` 方法：\r\n\r\n    Artisan::call('mail:send 1 --queue=default');\r\n\r\n<a name=\"passing-array-values\"></a>\r\n#### 传递数组值\r\n\r\n如果您的命令定义了一个接受数组的选项，您可以将一组值传递给该选项：\r\n\r\n    use Illuminate\\Support\\Facades\\Artisan;\r\n\r\n    Route::post('/mail', function () {\r\n        $exitCode = Artisan::call('mail:send', [\r\n            '--id' => [5, 13]\r\n        ]);\r\n    });\r\n\r\n<a name=\"passing-boolean-values\"></a>\r\n#### 传递布尔值\r\n\r\n如果您需要指定不接受字符串值的选项的值，例如 `migrate:refresh` 命令上的 `--force` 标志，则应传递 `true` 或 `false` 作为 选项：\r\n\r\n    $exitCode = Artisan::call('migrate:refresh', [\r\n        '--force' => true,\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"queueing-artisan-commands\"></a>\r\n#### 队列 Artisan 命令\r\n\r\n使用 `Artisan` 门面的 `queue` 方法，您甚至可以对 Artisan 命令进行排队，以便您的 [队列工作者](/docs/laravel/9.x/queues) 在后台处理它们。 在使用此方法之前，请确保您已配置队列并正在运行队列侦听器：\r\n\r\n    use Illuminate\\Support\\Facades\\Artisan;\r\n\r\n    Route::post('/user/{user}/mail', function ($user) {\r\n        Artisan::queue('mail:send', [\r\n            'user' => $user, '--queue' => 'default'\r\n        ]);\r\n\r\n        //\r\n    });\r\n\r\n使用 `onConnection` 和 `onQueue` 方法，您可以指定 Artisan 命令应分派到的连接或队列：\r\n\r\n    Artisan::queue('mail:send', [\r\n        'user' => 1, '--queue' => 'default'\r\n    ])->onConnection('redis')->onQueue('commands');\r\n\r\n<a name=\"calling-commands-from-other-commands\"></a>\r\n### 从其他命令调用命令\r\n\r\n有时您可能希望从现有的 Artisan 命令调用其他命令。您可以使用 `call` 方法来执行此操作。 这个 `call` 方法接受命令名称和命令参数/选项数组：\r\n\r\n    /**\r\n     * 执行控制台命令。\r\n     *\r\n     * @return mixed\r\n     */\r\n    public function handle()\r\n    {\r\n        $this->call('mail:send', [\r\n            'user' => 1, '--queue' => 'default'\r\n        ]);\r\n\r\n        //\r\n    }\r\n\r\n如果您想调用另一个控制台命令并禁止其所有输出，您可以使用 `callSilently` 方法。 `callSilently` 方法与 `call` 方法具有相同的签名：\r\n\r\n    $this->callSilently('mail:send', [\r\n        'user' => 1, '--queue' => 'default'\r\n    ]);\r\n\r\n<a name=\"signal-handling\"></a>\r\n## 信号处理\r\n\r\n为 Artisan 控制台提供动力的 Symfony 控制台组件允许您指示您的命令处理哪些进程信号（如果有）。 例如，您可以指示您的命令处理「SIGINT」和「SIGTERM」信号。\r\n\r\n首先，你应该在你的 Artisan 命令类上实现 `Symfony\\Component\\Console\\Command\\SignalableCommandInterface` 接口。 这个接口需要你定义两个方法：`getSubscribedSignals`和`handleSignal`：\r\n\r\n```php\r\n<?php\r\n\r\nuse Symfony\\Component\\Console\\Command\\SignalableCommandInterface;\r\n\r\nclass StartServer extends Command implements SignalableCommandInterface\r\n{\r\n    // ...\r\n\r\n    /**\r\n     * 获取命令处理的信号列表。\r\n     *\r\n     * @return array\r\n     */\r\n    public function getSubscribedSignals(): array\r\n    {\r\n        return [SIGINT, SIGTERM];\r\n    }\r\n\r\n    /**\r\n     * 处理传入信号。\r\n     *\r\n     * @param  int  $signal\r\n     * @return void\r\n     */\r\n    public function handleSignal(int $signal): void\r\n    {\r\n        if ($signal === SIGINT) {\r\n            $this->stopServer();\r\n\r\n            return;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n正如你所料，`getSubscribedSignals` 方法应该返回命令可以处理的信号数组，而 `handleSignal` 方法接收信号并可以做出相应地响应。\r\n\r\n## Stub 定制\r\n\r\nArtisan 控制台的 make 命令用于创建各种类，例如控制器、作业、迁移和测试。这些类是使用「stub」文件生成的，这些文件中会根据你的输入填充值。但是，你可能需要对 Artisan 生成的文件进行少量更改。为此，你可以使用以下 stub:publish 命令将最常见的 Stub 命令发布到你的应用程序中，以便可以自定义它们：\r\n\r\n```shell\r\nphp artisan stub:publish\r\n```\r\n\r\n已发布的 stub 将存放于你的应用根目录下的 `stubs` 目录中。对这些 stub 进行任何改动都将在你使用 Artisan `make` 命令生成相应的类的时候反映出来。\r\n\r\n## 事件\r\n\r\nArtisan 在运行命令时会调度三个事件： `Illuminate\\Console\\Events\\ArtisanStarting`，`Illuminate\\Console\\Events\\CommandStarting` 和  `Illuminate\\Console\\Events\\CommandFinished`。 当 Artisan 开始运行时，会立即调度 `ArtisanStarting` 事件。接下来，在命令运行之前立即调度  `CommandStarting` 事件。最后，一旦命令执行完毕，就会调度  `CommandFinished` 事件。\r\n\r\n","p":"docs/artisan.html"},{"t":"broadcasting (广播系统)","d":"# 广播系统\r\n\r\n- [简介](#introduction)\r\n- [服务端配置](#server-side-installation)\r\n    - [配置](#configuration)\r\n    - [Pusher Channels](#pusher-channels)\r\n    - [Ably](#ably)\r\n    - [开源替代品](#open-source-alternatives)\r\n- [客户端配置](#client-side-installation)\r\n    - [Pusher Channels](#client-pusher-channels)\r\n    - [Ably](#client-ably)\r\n- [概念综述](#concept-overview)\r\n    - [使用示例程序](#using-example-application)\r\n- [定义广播事件](#defining-broadcast-events)\r\n    - [广播名称](#broadcast-name)\r\n    - [广播数据](#broadcast-data)\r\n    - [广播队列](#broadcast-queue)\r\n    - [广播条件](#broadcast-conditions)\r\n    - [广播 & 数据库事务](#broadcasting-and-database-transactions)\r\n- [授权频道](#authorizing-channels)\r\n    - [定义授权路由](#defining-authorization-routes)\r\n    - [定义授权回调](#defining-authorization-callbacks)\r\n    - [定义频道类](#defining-channel-classes)\r\n- [广播事件](#broadcasting-events)\r\n    - [只广播给他人](#only-to-others)\r\n    - [自定义连接](#customizing-the-connection)\r\n- [接收广播](#receiving-broadcasts)\r\n    - [对事件进行监听](#listening-for-events)\r\n    - [退出频道](#leaving-a-channel)\r\n    - [命名空间](#namespaces)\r\n- [Presence 频道](#presence-channels)\r\n    - [授权 Presence 频道](#authorizing-presence-channels)\r\n    - [加入 Presence 频道](#joining-presence-channels)\r\n    - [广播到 Presence 频道](#broadcasting-to-presence-channels)\r\n- [广播模型](#model-broadcasting)\r\n    - [广播约定模型](#model-broadcasting-conventions)\r\n    - [监听广播模型](#listening-for-model-broadcasts)\r\n- [客户端事件](#client-events)\r\n- [消息通知](#notifications)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在现代的 web 应用程序中，WebSockets 被用来实现实时、即时更新用户接口。当服务器上的数据更新后，更新信息会通过 WebSocket 连接发送到客户端等待处理。为了在 UI 中展示出这些数据的变化相比于不停地轮询应用程序，WebSockets 是一种更加可靠和高效的选择。\r\n\r\n举一个例子，假设在应用程序中能够导出用户的 CSV 数据并且发送给他们。可是创建 CSV 文件要花费很长时间，因此你选择使用 [队列任务](/docs/laravel/9.x/queues)去创建文件和发送邮件。当创建了 CSV 文件并将其发送给用户后，我们能够创建使用一个广播事件比如 `App\\Events\\UserDataExported` ，然后在应用中利用 JavaScript 来接收这个事件。一旦接收到事件，我们就可以向用户显示一条消息，表明他们的 CSV 已经通过电子邮件发送给他们，而不需要他们刷新页面。\r\n\r\n\r\n\r\n为了帮助您构建这些类型的功能，Laravel 通过 WebSocket 连接使它很容易的去「广播」您的服务端 Laravel [事件](/docs/laravel/9.x/events)。广播 Laravel 事件允许您在服务器端 Laravel 应用程序和客户端 JavaScript 应用程序之间共享相同的事件名称和数据。\r\n\r\n广播背后的核心概念很简单：客户端连接到前端的命名频道，而您的 Laravel 应用程序将事件广播到后端的这些频道。这些事件可以包含您希望提供给前端的任何其他数据。\r\n\r\n<a name=\"supported-drivers\"></a>\r\n#### 支持的驱动程序\r\n\r\n默认情况下，Laravel 包含两个服务器端广播驱动程序供您选择：[Pusher Channels](https://pusher.com/channels) 和 [Ably](https://ably.io)。 但是，社区驱动的软件包，例如 [laravel-websockets](https://beyondco.de/docs/laravel-websockets/getting-started/introduction) 和 [soketi](https://docs.soketi.app/) 提供 不需要商业广播提供商的其他广播驱动程序。\r\n\r\n> 技巧：在深入了解事件广播之前，请确保您已阅读 Laravel 关于 [事件和监听](/docs/laravel/9.x/events \"事件和监听\") 的文档。\r\n\r\n<a name=\"server-side-installation\"></a>\r\n## 服务器端安装\r\n\r\n要开始使用 Laravel 的事件广播，我们需要在 Laravel 应用程序中进行一些配置以及安装一些包。\r\n\r\n事件广播由服务器端广播驱动程序完成，该驱动程序广播您的 Laravel 事件，以便 Laravel Echo（一个 JavaScript 库）可以在浏览器客户端中接收它们。 不用担心 - 我们将逐步完成安装过程的每个部分。\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\n您应用程序的所有事件广播配置都存储在 config/broadcasting.php 配置文件中。 Laravel 支持几个开箱即用的广播驱动程序：[Pusher Channels](https://pusher.com/channels)、[Redis](/docs/laravel/9.x/redis) 和一个用于本地的 `log` 驱动程序 开发和调试。 此外，还包含一个 `null` 驱动程序，允许您在测试期间完全禁用广播。 `config/broadcasting.php` 配置文件中包含每个驱动程序的配置示例。\r\n\r\n\r\n\r\n<a name=\"broadcast-service-provider\"></a>\r\n#### 广播服务提供商\r\n\r\n在广播任何事件之前，您首先需要注册 `App\\Providers\\BroadcastServiceProvider`。在新的 Laravel 应用程序中，您只需在 `config/app.php` 配置文件的 `providers` 数组中取消注释此提供程序。这个 `BroadcastServiceProvider` 包含注册广播授权路由和回调所需的代码。\r\n\r\n<a name=\"queue-configuration\"></a>\r\n#### 队列配置\r\n\r\n您还需要配置和运行 [queue worker](/docs/laravel/9.x/queues)。所有事件广播都是通过排队作业完成的，因此您的应用程序的响应时间不会受到广播事件的严重影响。\r\n\r\n<a name=\"pusher-channels\"></a>\r\n### Pusher Channels\r\n\r\n如果您计划使用 [Pusher Channels](https://pusher.com/channels) 广播您的事件，您应该使用 Composer 包管理器安装 Pusher Channels PHP SDK：\r\n\r\n```shell\r\ncomposer require pusher/pusher-php-server\r\n```\r\n\r\n接下来，您应该在 config/broadcasting.php 配置文件中配置您的 Pusher Channels 凭据。 此文件中已包含一个 Pusher Channels 配置示例，允许您快速指定您的密钥、秘密和应用程序 ID。 通常，这些值应通过 `PUSHER_APP_KEY`、`PUSHER_APP_SECRET` 和 `PUSHER_APP_ID` [环境变量](/docs/laravel/9.x/configuration#environment-configuration) 设置：\r\n\r\n```ini\r\nPUSHER_APP_ID=your-pusher-app-id\r\nPUSHER_APP_KEY=your-pusher-key\r\nPUSHER_APP_SECRET=your-pusher-secret\r\nPUSHER_APP_CLUSTER=mt1\r\n```\r\n\r\n`config/broadcasting.php` 文件的 `pusher` 配置还允许您指定 Channels 支持的其他 `options`，例如集群。\r\n\r\n接下来，您需要在 `.env` 文件中将广播驱动程序更改为 `pusher`：\r\n\r\n```ini\r\nBROADCAST_DRIVER=pusher\r\n```\r\n\r\n\r\n\r\n最后，您可以安装和配置 [Laravel Echo](#client-side-installation)，它将在客户端接收广播事件。\r\n\r\n<a name=\"pusher-compatible-open-source-alternatives\"></a>\r\n#### 开源 Pusher 替代方案\r\n\r\n[laravel-websockets](https://github.com/beyondcode/laravel-websockets) 和 [soketi](https://docs.soketi.app/) 包为 Laravel 提供了与 Pusher 兼容的 WebSocket 服务器。 这些包允许您在没有商业 WebSocket 提供程序的情况下利用 Laravel 广播的全部功能。 有关安装和使用这些软件包的更多信息，请参阅我们关于 [开源替代品](#open-source-alternatives) 的文档。\r\n\r\n<a name=\"ably\"></a>\r\n### Ably\r\n\r\n如果您计划使用 [Ably](https://ably.io) 广播您的活动，您应该使用 Composer 包管理器安装 Ably PHP SDK：\r\n\r\n```shell\r\ncomposer require ably/ably-php\r\n```\r\n\r\n接下来，您应该在 config/broadcasting.php 配置文件中配置您的 Ably 凭据。此文件中已包含一个示例 Ably 配置，允许您快速指定密钥。通常，此值应通过 `ABLY_KEY` [环境变量](/docs/laravel/9.x/configuration#environment-configuration) 设置：\r\n\r\n```ini\r\nABLY_KEY=your-ably-key\r\n```\r\n\r\n接下来，您需要在 `.env` 文件中将广播驱动程序更改为 `ably`：\r\n\r\n```ini\r\nBROADCAST_DRIVER=ably\r\n```\r\n\r\n最后，您可以安装和配置 [Laravel Echo](#client-side-installation)，它将在客户端接收广播事件。\r\n\r\n<a name=\"open-source-alternatives\"></a>\r\n### 开源替代方案\r\n\r\n<a name=\"open-source-alternatives-php\"></a>\r\n#### PHP\r\n\r\n[laravel-websockets](https://github.com/beyondcode/laravel-websockets) 包是一个纯 PHP、Pusher 兼容的 Laravel WebSocket 包。 这个包允许你在没有商业 WebSocket 提供者的情况下利用 Laravel 广播的全部功能。 有关安装和使用此软件包的更多信息，请参阅其 [官方文档](https://beyondco.de/docs/laravel-websockets)。\r\n\r\n\r\n\r\n<a name=\"open-source-alternatives-node\"></a>\r\n#### Node\r\n\r\n[Soketi](https://github.com/soketi/soketi) 是一个基于 Node 的、Pusher 兼容的 Laravel WebSocket 服务器。在底层，Soketi 利用 µWebSockets.js 实现了极高的可扩展性和速度。这个包允许你在没有商业 WebSocket 提供者的情况下利用 Laravel 广播的全部功能。有关安装和使用此软件包的更多信息，请参阅其[官方文档](https://docs.soketi.app/)。\r\n\r\n<a name=\"client-side-installation\"></a>\r\n## 客户端安装\r\n\r\n<a name=\"client-pusher-channels\"></a>\r\n### Pusher Channels\r\n\r\n[Laravel Echo](https://github.com/laravel/echo) 是一个 JavaScript 库，可以轻松订阅频道和收听服务器端广播驱动程序广播的事件。 你可以通过 NPM 包管理器安装 Echo。在此示例中，我们还将安装 `pusher-js` 包，因为我们将使用 Pusher Channels 广播器：\r\n\r\n```shell\r\nnpm install --save-dev laravel-echo pusher-js\r\n```\r\n\r\n安装 Echo 后，您就可以在应用程序的 JavaScript 中创建一个新的 Echo 实例了。一个很好的地方是在 Laravel 框架中包含的 `resources/js/bootstrap.js` 文件的底部。默认情况下，此文件中已包含一个示例 Echo 配置 - 您只需取消注释即可：\r\n\r\n```js\r\nimport Echo from 'laravel-echo';\r\n\r\nwindow.Pusher = require('pusher-js');\r\n\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    key: process.env.MIX_PUSHER_APP_KEY,\r\n    cluster: process.env.MIX_PUSHER_APP_CLUSTER,\r\n    forceTLS: true\r\n});\r\n```\r\n\r\n根据您的需要取消注释并调整 Echo 配置后，您可以编译应用程序的资产：\r\n\r\n```shell\r\nnpm run dev\r\n```\r\n\r\n> 技巧：要了解有关编译应用程序的 JavaScript 资产的更多信息，请参阅 [Laravel Mix](/docs/laravel/9.x/mix \"Laravel Mix\") 上的文档。\r\n\r\n\r\n\r\n<a name=\"using-an-existing-client-instance\"></a>\r\n#### 使用现有的客户端实例\r\n\r\n如果您已经有一个您希望 Echo 使用的预配置 Pusher Channels 客户端实例，您可以通过 `client` 配置选项将其传递给 Echo：\r\n\r\n```js\r\nimport Echo from 'laravel-echo';\r\n\r\nconst client = require('pusher-js');\r\n\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    key: 'your-pusher-channels-key',\r\n    client: client\r\n});\r\n```\r\n\r\n<a name=\"client-ably\"></a>\r\n### Ably\r\n\r\n[Laravel Echo](https://github.com/laravel/echo) 是一个 JavaScript 库，可以轻松订阅频道和收听服务器端广播驱动程序广播的事件。你可以通过 NPM 包管理器安装 Echo。 在本例中，我们还将安装 `pusher-js` 包。\r\n\r\n你可能想知道为什么我们要安装 `pusher-js` JavaScript 库，即使我们使用 Ably 来广播我们的事件。值得庆幸的是，Ably 包含一个 Pusher 兼容模式，它允许我们在客户端应用程序中侦听事件时使用 Pusher 协议：\r\n\r\n```shell\r\nnpm install --save-dev laravel-echo pusher-js\r\n```\r\n\r\n**在继续之前，您应该在 Ably 应用程序设置中启用 Pusher 协议支持。您可以在 Ably 应用程序设置仪表板的“协议适配器设置”部分启用此功能。**\r\n\r\n安装 Echo 后，您就可以在应用程序的 JavaScript 中创建一个新的 Echo 实例了。 一个很好的地方是在 Laravel 框架中包含的 `resources/js/bootstrap.js` 文件的底部。默认情况下，此文件中已包含示例 Echo 配置；然而，`bootstrap.js` 文件中的默认配置是为 Pusher 设计的。 您可以复制以下配置以将您的配置转换为 Ably：\r\n\r\n```js\r\nimport Echo from 'laravel-echo';\r\n\r\nwindow.Pusher = require('pusher-js');\r\n\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    key: process.env.MIX_ABLY_PUBLIC_KEY,\r\n    wsHost: 'realtime-pusher.ably.io',\r\n    wsPort: 443,\r\n    disableStats: true,\r\n    encrypted: true,\r\n});\r\n```\r\n\r\n\r\n\r\n请注意，我们的 Ably Echo 配置引用了一个 `MIX_ABLY_PUBLIC_KEY` 环境变量。这个变量的值应该是你的 Ably 公钥。您的公钥是出现在 `:` 字符之前的 Ably 密钥部分。\r\n\r\n根据您的需要取消注释并调整 Echo 配置后，您可以编译应用程序的资产：\r\n\r\n```shell\r\nnpm run dev\r\n```\r\n\r\n> 技巧：要了解有关编译应用程序的 JavaScript 资产的更多信息，请参阅 [Laravel Mix](/docs/laravel/9.x/mix/ \"Laravel Mix\") 上的文档。\r\n\r\n<a name=\"concept-overview\"></a>\r\n## 概念概述\r\n\r\nLaravel 的事件广播允许您使用基于驱动程序的 WebSockets 方法将服务器端 Laravel 事件广播到客户端 JavaScript 应用程序。 目前，Laravel 附带 [Pusher Channels](https://pusher.com/channels) 和 [Ably](https://ably.io) 驱动程序。 使用 [Laravel Echo](#client-side-installation) JavaScript 包可以在客户端轻松使用这些事件。\r\n\r\n事件通过「频道」广播，可以指定为公共或私人。您的应用程序的任何访问者都可以订阅公共频道而无需任何身份验证或授权；但是，为了订阅私人频道，用户必须经过身份验证并获得授权才能在该频道上收听。\r\n\r\n> 技巧：如果您想探索 Pusher 的开源替代品，请查看 [开源替代品](#open-source-alternatives)。\r\n\r\n<a name=\"using-example-application\"></a>\r\n### 使用示例应用程序\r\n\r\n在深入了解事件广播的每个组件之前，让我们以电子商务商店为例进行高级概述。\r\n\r\n在我们的应用程序中，假设我们有一个页面允许用户查看其订单的运输状态。我们还假设在应用程序处理运输状态更新时触发了一个 `OrderShipmentStatusUpdated` 事件：\r\n\r\n    use App\\Events\\OrderShipmentStatusUpdated;\r\n\r\n    OrderShipmentStatusUpdated::dispatch($order);\r\n\r\n\r\n\r\n<a name=\"the-shouldbroadcast-interface\"></a>\r\n#### `ShouldBroadcast` 接口\r\n\r\n当用户查看他们的一个订单时，我们不希望他们必须刷新页面才能查看状态更新。相反，我们希望在创建应用程序时将更新广播到应用程序。所以，我们需要用 `ShouldBroadcast` 接口标记 `OrderShipmentStatusUpdated` 事件。这将指示 Laravel 在事件被触发时广播它：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use App\\Order;\r\n    use Illuminate\\Broadcasting\\Channel;\r\n    use Illuminate\\Broadcasting\\InteractsWithSockets;\r\n    use Illuminate\\Broadcasting\\PresenceChannel;\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipmentStatusUpdated implements ShouldBroadcast\r\n    {\r\n        /**\r\n         * 订单实例。\r\n         *\r\n         * @var \\App\\Order\r\n         */\r\n        public $order;\r\n    }\r\n\r\n`ShouldBroadcast` 接口要求我们的事件定义一个 `broadcastOn` 方法。此方法负责返回事件应在其上广播的频道。此方法的空存根已在生成的事件类上定义，因此我们只需填写其详细信息。我们只希望订单的创建者能够查看状态更新，因此我们将在与订单绑定的私人频道上广播该事件：\r\n\r\n    /**\r\n     * 获取事件应广播的频道.\r\n     *\r\n     * @return \\Illuminate\\Broadcasting\\PrivateChannel\r\n     */\r\n    public function broadcastOn()\r\n    {\r\n        return new PrivateChannel('orders.'.$this->order->id);\r\n    }\r\n\r\n<a name=\"example-application-authorizing-channels\"></a>\r\n#### 授权频道\r\n\r\n请记住，用户必须获得授权才能在私人频道上收听。我们可以在应用程序的 `routes/channels.php` 文件中定义我们的频道授权规则。在此示例中，我们需要验证任何尝试在私有 `orders.1` 频道上收听的用户实际上是订单的创建者：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    Broadcast::channel('orders.{orderId}', function ($user, $orderId) {\r\n        return $user->id === Order::findOrNew($orderId)->user_id;\r\n    });\r\n\r\n\r\n\r\n`channel` 方法接受两个参数：频道名称和返回 `true` 或 `false` 指示用户是否有权收听频道的回调。\r\n\r\n所有授权回调都接收当前经过身份验证的用户作为其第一个参数，并将任何其他通配符参数作为其后续参数。在此示例中，我们使用 `{orderId}` 占位符来指示频道名称的「ID」部分是通配符。\r\n\r\n<a name=\"listening-for-event-broadcasts\"></a>\r\n#### 监听事件广播\r\n\r\n接下来，剩下的就是在我们的 JavaScript 应用程序中监听事件。我们可以使用 [Laravel Echo](#client-side-installation) 来做到这一点。首先，我们将使用 `private` 方法订阅私人频道。然后，我们可以使用 `listen` 方法来监听 `OrderShipmentStatusUpdated` 事件。默认情况下，所有事件的公共属性都将包含在广播事件中：\r\n\r\n```js\r\nEcho.private(`orders.${orderId}`)\r\n    .listen('OrderShipmentStatusUpdated', (e) => {\r\n        console.log(e.order);\r\n    });\r\n```\r\n\r\n<a name=\"defining-broadcast-events\"></a>\r\n## 定义广播事件\r\n\r\n为了通知 Laravel 一个给定的事件应该被广播，你必须在事件类上实现 `Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast` 接口。该接口已经导入到框架生成的所有事件类中，因此您可以轻松地将其添加到您的任何事件中。\r\n\r\n`ShouldBroadcast` 接口要求你实现一个方法：`broadcastOn`。 `broadcastOn` 方法应返回事件应在其上广播的频道或频道数组。 频道应该是`Channel`、`PrivateChannel`或`PresenceChannel`的实例。 `Channel` 的实例代表任何用户都可以订阅的公共频道，而 `PrivateChannels` 和 `PresenceChannels` 代表需要 [频道授权](#authorizing-channels) 的私人频道：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Broadcasting\\Channel;\r\n    use Illuminate\\Broadcasting\\InteractsWithSockets;\r\n    use Illuminate\\Broadcasting\\PresenceChannel;\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ServerCreated implements ShouldBroadcast\r\n    {\r\n        use SerializesModels;\r\n\r\n        /**\r\n         * 创建服务器的用户。\r\n         *\r\n         * @var \\App\\Models\\User\r\n         */\r\n        public $user;\r\n\r\n        /**\r\n         * 创建一个新的事件实例。\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @return void\r\n         */\r\n        public function __construct(User $user)\r\n        {\r\n            $this->user = $user;\r\n        }\r\n\r\n        /**\r\n         * 获取事件应该广播的频道。\r\n         *\r\n         * @return Channel|array\r\n         */\r\n        public function broadcastOn()\r\n        {\r\n            return new PrivateChannel('user.'.$this->user->id);\r\n        }\r\n    }\r\n\r\n\r\n\r\n在实现了 `ShouldBroadcast` 接口之后，你只需要像往常一样[触发事件](/docs/laravel/9.x/events)。触发事件后，[排队作业](/docs/laravel/9.x/queues) 将使用您指定的广播驱动程序自动广播事件。\r\n\r\n<a name=\"broadcast-name\"></a>\r\n### 广播名称\r\n\r\n默认情况下，Laravel 将使用事件的类名广播事件。但是，您可以通过在事件上定义一个 `broadcastAs` 方法来自定义广播名称：\r\n\r\n    /**\r\n     * 事件的广播名称。\r\n     *\r\n     * @return string\r\n     */\r\n    public function broadcastAs()\r\n    {\r\n        return 'server.created';\r\n    }\r\n\r\n如果您使用 `broadcastAs` 方法自定义广播名称，则应确保使用前导 `.` 字符注册您的侦听器。 这将指示 Echo 不要将应用程序的命名空间添加到事件中：\r\n\r\n    .listen('.server.created', function (e) {\r\n        ....\r\n    });\r\n\r\n<a name=\"broadcast-data\"></a>\r\n### 广播数据\r\n\r\n当一个事件被广播时，它的所有 `public` 属性都会自动序列化并作为事件的有效负载广播，允许您从 JavaScript 应用程序访问它的任何公共数据。因此，例如，如果您的事件有一个包含 Eloquent 模型的公共 `$user` 属性，则事件的广播负载将是：\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"id\": 1,\r\n        \"name\": \"Patrick Stewart\"\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\n但是，如果您希望对广播负载进行更细粒度的控制，您可以在事件中添加一个 `broadcastWith` 方法。此方法应返回您希望作为事件有效负载广播的数据数组：\r\n\r\n    /**\r\n     * 获取要广播的数据。\r\n     *\r\n     * @return array\r\n     */\r\n    public function broadcastWith()\r\n    {\r\n        return ['id' => $this->user->id];\r\n    }\r\n\r\n<a name=\"broadcast-queue\"></a>\r\n\r\n\r\n### 广播队列\r\n\r\n默认情况下，每个广播事件都放置在 `queue.php` 配置文件中指定的默认队列连接的默认队列中。 您可以通过在事件类上定义 `connection` 和 `queue` 属性来自定义广播者使用的队列连接和名称：\r\n\r\n    /**\r\n     * 广播事件时使用的队列连接的名称。\r\n     *\r\n     * @var string\r\n     */\r\n    public $connection = 'redis';\r\n\r\n    /**\r\n     * 放置广播作业的队列的名称。\r\n     *\r\n     * @var string\r\n     */\r\n    public $queue = 'default';\r\n\r\n或者，您可以通过在您的事件上定义一个 `broadcastQueue` 方法来自定义队列名称：\r\n\r\n    /**\r\n     * 放置广播作业的队列的名称。\r\n     *\r\n     * @return string\r\n     */\r\n    public function broadcastQueue()\r\n    {\r\n        return 'default';\r\n    }\r\n\r\n如果您想使用 `sync` 队列而不是默认队列驱动程序广播您的事件，您可以实现 `ShouldBroadcastNow` 接口而不是 `ShouldBroadcast`：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow;\r\n\r\n    class OrderShipmentStatusUpdated implements ShouldBroadcastNow\r\n    {\r\n        //\r\n    }\r\n\r\n<a name=\"broadcast-conditions\"></a>\r\n### 广播条件\r\n\r\n有时您只想在给定条件为真时才广播您的事件。您可以通过向您的事件类添加一个 `broadcastWhen` 方法来定义这些条件：\r\n\r\n    /**\r\n     * 确定是否应广播此事件。\r\n     *\r\n     * @return bool\r\n     */\r\n    public function broadcastWhen()\r\n    {\r\n        return $this->order->value > 100;\r\n    }\r\n\r\n<a name=\"broadcasting-and-database-transactions\"></a>\r\n#### 广播和数据库事务\r\n\r\n当广播事件在数据库事务中被分派时，它们可能在数据库事务提交之前由队列处理。发生这种情况时，您在数据库事务期间对模型或数据库记录所做的任何更新可能尚未反映在数据库中。此外，在事务中创建的任何模型或数据库记录可能不存在于数据库中。如果您的事件依赖于这些模型，则在处理广播事件的作业时可能会出现意外错误。\r\n\r\n\r\n\r\n如果您的队列连接的 `after_commit` 配置选项设置为 `false`，您仍然可以通过在事件类上定义 `$afterCommit` 属性来指示应在提交所有打开的数据库事务后调度特定的广播事件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ServerCreated implements ShouldBroadcast\r\n    {\r\n        use SerializesModels;\r\n\r\n        public $afterCommit = true;\r\n    }\r\n\r\n> 技巧：要了解有关解决这些问题的更多信息，请查看有关 [队列任务和数据库事务](/docs/laravel/9.x/queues#jobs-and-database-transactions \"队列任务和数据库事务\") 的文档。\r\n\r\n<a name=\"authorizing-channels\"></a>\r\n## 授权频道\r\n\r\n私人频道要求您授权当前经过身份验证的用户可以实际收听频道。这是通过使用频道名称向您的 Laravel 应用程序发出 HTTP 请求并允许您的应用程序确定用户是否可以在该频道上收听来实现的。 使用 [Laravel Echo](#client-side-installation) 时，会自动发出授权订阅私人频道的 HTTP 请求；但是，您确实需要定义正确的路由来响应这些请求。\r\n\r\n<a name=\"defining-authorization-routes\"></a>\r\n### 定义授权路由\r\n\r\n值得庆幸的是，Laravel 可以轻松定义响应通道授权请求的路由。在 Laravel 应用程序包含的 `App\\Providers\\BroadcastServiceProvider` 中，您将看到对 `Broadcast::routes` 方法的调用。此方法将注册 `/broadcasting/auth` 路由来处理授权请求：\r\n\r\n    Broadcast::routes();\r\n\r\n`Broadcast::routes` 方法会自动将其路由放置在 `web` 中间件组中；但是，如果您想自定义分配的属性，可以将路由属性数组传递给方法：\r\n\r\n    Broadcast::routes($attributes);\r\n\r\n\r\n\r\n<a name=\"customizing-the-authorization-endpoint\"></a>\r\n#### 自定义授权端点\r\n\r\n默认情况下，Echo 将使用 `/broadcasting/auth` 端点来授权频道访问。但是，您可以通过将 `authEndpoint` 配置选项传递给 Echo 实例来指定自己的授权端点：\r\n\r\n```js\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    // ...\r\n    authEndpoint: '/custom/endpoint/auth'\r\n});\r\n```\r\n\r\n<a name=\"customizing-the-authorization-request\"></a>\r\n#### 自定义授权请求\r\n\r\n您可以通过在初始化 Echo 时提供自定义授权器来自定义 Laravel Echo 如何执行授权请求：\r\n\r\n```js\r\nwindow.Echo = new Echo({\r\n    // ...\r\n    authorizer: (channel, options) => {\r\n        return {\r\n            authorize: (socketId, callback) => {\r\n                axios.post('/api/broadcasting/auth', {\r\n                    socket_id: socketId,\r\n                    channel_name: channel.name\r\n                })\r\n                .then(response => {\r\n                    callback(false, response.data);\r\n                })\r\n                .catch(error => {\r\n                    callback(true, error);\r\n                });\r\n            }\r\n        };\r\n    },\r\n})\r\n```\r\n\r\n<a name=\"defining-authorization-callbacks\"></a>\r\n### 定义授权回调\r\n\r\n接下来，我们需要定义实际确定当前经过身份验证的用户是否可以收听给定频道的逻辑。这是在应用程序中包含的 `routes/channels.php` 文件中完成的。在这个文件中，你可以使用 `Broadcast::channel` 方法注册频道授权回调：\r\n\r\n    Broadcast::channel('orders.{orderId}', function ($user, $orderId) {\r\n        return $user->id === Order::findOrNew($orderId)->user_id;\r\n    });\r\n\r\n`channel` 方法接受两个参数：频道名称和返回 `true` 或 `false` 指示用户是否有权收听频道的回调。\r\n\r\n所有授权回调都接收当前经过身份验证的用户作为其第一个参数，并将任何其他通配符参数作为其后续参数。在此示例中，我们使用 `{orderId}` 占位符来指示频道名称的「ID」部分是通配符。\r\n\r\n\r\n\r\n<a name=\"authorization-callback-model-binding\"></a>\r\n#### 授权回调模型绑定\r\n\r\n就像 HTTP 路由一样，通道路由也可以利用隐式和显式 [路由模型绑定](/docs/laravel/9.x/routing#route-model-binding)。例如，您可以请求一个实际的 `Order` 模型实例，而不是接收字符串或数字订单 ID：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    Broadcast::channel('orders.{order}', function ($user, Order $order) {\r\n        return $user->id === $order->user_id;\r\n    });\r\n\r\n> 注意：与 HTTP 路由模型绑定不同，通道模型绑定不支持自动 [隐式模型绑定范围](/docs/laravel/9.x/routing#implicit-model-binding-scoping)。但是，这很少会成为问题，因为大多数通道都可以基于单个模型的唯一主键来确定范围。\r\n\r\n<a name=\"authorization-callback-authentication\"></a>\r\n#### 授权回调认证\r\n\r\n私有和在线广播频道通过您应用程序的默认身份验证保护对当前用户进行身份验证。如果用户未通过身份验证，则通道授权将自动被拒绝，并且永远不会执行授权回调。但是，您可以分配多个自定义保护，以在必要时对传入请求进行身份验证：\r\n\r\n    Broadcast::channel('channel', function () {\r\n        // ...\r\n    }, ['guards' => ['web', 'admin']]);\r\n\r\n<a name=\"defining-channel-classes\"></a>\r\n### 定义频道类\r\n\r\n如果您的应用程序使用许多不同的频道，您的 `routes/channels.php` 文件可能会变得庞大。因此，您可以使用通道类，而不是使用闭包来授权通道。要生成通道类，请使用 `make:channel` Artisan 命令。此命令将在 `App/Broadcasting` 目录中放置一个新的频道类。\r\n\r\n```shell\r\nphp artisan make:channel OrderChannel\r\n```\r\n\r\n接下来，在 `routes/channels.php` 文件中注册您的频道：\r\n\r\n    use App\\Broadcasting\\OrderChannel;\r\n\r\n    Broadcast::channel('orders.{order}', OrderChannel::class);\r\n\r\n\r\n\r\n最后，您可以将频道的授权逻辑放在频道类的 `join` 方法中。这个 `join` 方法将包含您通常放置在通道授权闭包中的相同逻辑。您还可以利用通道模型绑定：\r\n\r\n    <?php\r\n\r\n    namespace App\\Broadcasting;\r\n\r\n    use App\\Models\\Order;\r\n    use App\\Models\\User;\r\n\r\n    class OrderChannel\r\n    {\r\n        /**\r\n         * 创建一个新的通道实例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 验证用户对频道的访问权限。\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @param  \\App\\Models\\Order  $order\r\n         * @return array|bool\r\n         */\r\n        public function join(User $user, Order $order)\r\n        {\r\n            return $user->id === $order->user_id;\r\n        }\r\n    }\r\n\r\n> 技巧：像 Laravel 中的许多其他类一样，通道类将由 [服务容器](/docs/laravel/9.x/container) 自动解析。因此，您可以在其构造函数中键入提示您的通道所需的任何依赖项。\r\n\r\n<a name=\"broadcasting-events\"></a>\r\n## 广播事件\r\n\r\n一旦你定义了一个事件并用 `ShouldBroadcast` 接口标记了它，你只需要使用事件的 dispatch 方法来触发事件。事件调度器会注意到该事件被标记为 `ShouldBroadcast` 接口，并将该事件排队以进行广播：\r\n\r\n    use App\\Events\\OrderShipmentStatusUpdated;\r\n\r\n    OrderShipmentStatusUpdated::dispatch($order);\r\n\r\n<a name=\"only-to-others\"></a>\r\n### 只广播给其他人\r\n\r\n在构建使用事件广播的应用程序时，您可能偶尔需要将事件广播给给定频道的所有订阅者，但当前用户除外。 您可以使用 `broadcast` 帮助程序和 `toOthers` 方法来完成此操作：\r\n\r\n    use App\\Events\\OrderShipmentStatusUpdated;\r\n\r\n    broadcast(new OrderShipmentStatusUpdated($update))->toOthers();\r\n\r\n为了更好地理解何时需要使用 `toOthers` 方法，让我们想象一个任务列表应用程序，其中用户可以通过输入任务名称来创建新任务。要创建任务，您的应用程序可能会向 `/task` URL 发出请求，该 URL 会广播任务的创建并返回新任务的 JSON 表示。当您的 JavaScript 应用程序接收到来自端点的响应时，它可能会直接将新任务插入到其任务列表中，如下所示：\r\n\r\n```js\r\naxios.post('/task', task)\r\n    .then((response) => {\r\n        this.tasks.push(response.data);\r\n    });\r\n```\r\n\r\n\r\n\r\n但是，请记住，我们还广播了任务的创建。如果您的 JavaScript 应用程序也在侦听此事件以将任务添加到任务列表中，那么您的列表中将有重复的任务：一个来自端点，一个来自广播。您可以通过使用 `toOthers` 方法来指示广播者不要将事件广播给当前用户来解决此问题。\r\n\r\n> 注意：您的事件必须使用 `Illuminate\\Broadcasting\\InteractsWithSockets` 特征才能调用 `toOthers` 方法。\r\n\r\n<a name=\"only-to-others-configuration\"></a>\r\n#### 配置\r\n\r\n当您初始化 Laravel Echo 实例时，会为连接分配一个套接字 ID。如果您使用全局 [Axios](https://github.com/mzabriskie/axios) 实例从 JavaScript 应用程序发出 HTTP 请求，则套接字 ID 将自动附加到每个传出请求作为 `X-Socket- ID`标头。然后，当你调用 `toOthers` 方法时，Laravel 将从头中提取套接字 ID 并指示广播器不要广播到具有该套接字 ID 的任何连接。\r\n\r\n如果您没有使用全局 Axios 实例，您将需要手动配置 JavaScript 应用程序以发送带有所有传出请求的“X-Socket-ID”标头。您可以使用 `Echo.socketId` 方法检索套接字 ID：\r\n\r\n```js\r\nvar socketId = Echo.socketId();\r\n```\r\n\r\n<a name=\"customizing-the-connection\"></a>\r\n### 自定义连接\r\n\r\n如果您的应用程序与多个广播连接交互，并且您想使用默认广播器以外的广播器广播事件，您可以使用 `via` 方法指定将事件推送到哪个连接：\r\n\r\n    use App\\Events\\OrderShipmentStatusUpdated;\r\n\r\n    broadcast(new OrderShipmentStatusUpdated($update))->via('pusher');\r\n\r\n\r\n\r\n或者，您可以通过在事件的构造函数中调用 `broadcastVia` 方法来指定事件的广播连接。但是，在这样做之前，您应该确保事件类使用 `InteractsWithBroadcasting` 特征：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use Illuminate\\Broadcasting\\Channel;\r\n    use Illuminate\\Broadcasting\\InteractsWithBroadcasting;\r\n    use Illuminate\\Broadcasting\\InteractsWithSockets;\r\n    use Illuminate\\Broadcasting\\PresenceChannel;\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipmentStatusUpdated implements ShouldBroadcast\r\n    {\r\n        use InteractsWithBroadcasting;\r\n\r\n        /**\r\n         * 创建一个新的事件实例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->broadcastVia('pusher');\r\n        }\r\n    }\r\n\r\n<a name=\"receiving-broadcasts\"></a>\r\n## 接收广播\r\n\r\n<a name=\"listening-for-events\"></a>\r\n### 监听事件\r\n\r\n一旦你[安装并实例化了 Laravel Echo](#client-side-installation)，你就可以开始监听从你的 Laravel 应用程序广播的事件了。首先，使用 `channel` 方法获取通道实例，然后调用 `listen` 方法监听指定事件：\r\n\r\n```js\r\nEcho.channel(`orders.${this.order.id}`)\r\n    .listen('OrderShipmentStatusUpdated', (e) => {\r\n        console.log(e.order.name);\r\n    });\r\n```\r\n\r\n如果您想在私人频道上监听事件，请改用 `private` 方法。 您可以继续调用 `listen` 方法以在单个通道上侦听多个事件：\r\n\r\n```js\r\nEcho.private(`orders.${this.order.id}`)\r\n    .listen(...)\r\n    .listen(...)\r\n    .listen(...);\r\n```\r\n\r\n<a name=\"stop-listening-for-events\"></a>\r\n#### 停止监听事件\r\n\r\n如果您想在不 [离开频道](#leaving-a-channel) 的情况下停止收听给定事件，您可以使用 `stopListening` 方法：\r\n\r\n```js\r\nEcho.private(`orders.${this.order.id}`)\r\n    .stopListening('OrderShipmentStatusUpdated')\r\n```\r\n\r\n<a name=\"leaving-a-channel\"></a>\r\n### 离开频道\r\n\r\n\r\n\r\n要离开频道，您可以在 Echo 实例上调用 `leaveChannel` 方法：\r\n\r\n```js\r\nEcho.leaveChannel(`orders.${this.order.id}`);\r\n```\r\n\r\n如果你想离开一个频道及其相关的私人和在线频道，你可以调用 `leave` 方法：\r\n\r\n```js\r\nEcho.leave(`orders.${this.order.id}`);\r\n```\r\n<a name=\"namespaces\"></a>\r\n### 命名空间\r\n\r\n您可能已经注意到，在上面的示例中，我们没有为事件类指定完整的 `App\\Events` 命名空间。这是因为 Echo 会自动假定事件位于 `App\\Events` 命名空间中。但是，您可以在实例化 Echo 时通过传递 `namespace` 配置选项来配置根命名空间：\r\n\r\n```js\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    // ...\r\n    namespace: 'App.Other.Namespace'\r\n});\r\n```\r\n\r\n或者，您可以在使用 Echo 订阅事件类时使用 `.` 作为事件类的前缀。这将允许您始终指定完全限定的类名：\r\n\r\n```js\r\nEcho.channel('orders')\r\n    .listen('.Namespace\\\\Event\\\\Class', (e) => {\r\n        //\r\n    });\r\n```\r\n\r\n<a name=\"presence-channels\"></a>\r\n## 存在频道\r\n\r\n在线状态频道建立在私人频道的安全性之上，同时公开了知道谁订阅了频道的附加功能。这使得构建强大的协作应用程序功能变得容易，例如在另一个用户查看同一页面时通知用户或列出聊天室的居民。\r\n\r\n<a name=\"authorizing-presence-channels\"></a>\r\n### 授权存在频道\r\n\r\n所有出席频道也是私人频道；因此，用户必须[授权访问他们](#authorizing-channels)。但是，在为出席频道定义授权回调时，如果用户被授权加入频道，则不会返回 `true`。相反，您应该返回有关用户的数据数组。\r\n\r\n\r\n\r\n授权回调返回的数据将提供给 JavaScript 应用程序中的存在通道事件侦听器。如果用户未被授权加入出席频道，则应返回 `false` 或 `null`：\r\n\r\n    Broadcast::channel('chat.{roomId}', function ($user, $roomId) {\r\n        if ($user->canJoinRoom($roomId)) {\r\n            return ['id' => $user->id, 'name' => $user->name];\r\n        }\r\n    });\r\n\r\n<a name=\"joining-presence-channels\"></a>\r\n### 加入存在频道\r\n\r\n要加入在线状态频道，您可以使用 Echo 的 `join` 方法。 `join` 方法将返回 `PresenceChannel` 实现，连同公开 `listen` 方法，允许您订阅 `here`、`joining` 和 `leaving` 事件。\r\n\r\n```js\r\nEcho.join(`chat.${roomId}`)\r\n    .here((users) => {\r\n        //\r\n    })\r\n    .joining((user) => {\r\n        console.log(user.name);\r\n    })\r\n    .leaving((user) => {\r\n        console.log(user.name);\r\n    })\r\n    .error((error) => {\r\n        console.error(error);\r\n    });\r\n```\r\n\r\n加入频道成功后，`here` 回调将立即执行，并会收到一个数组，其中包含当前订阅频道的所有其他用户的用户信息。 `joining` 方法会在新用户加入频道时执行，而 `leaving` 方法会在用户离开频道时执行。 当身份验证端点返回 200 以外的 HTTP 状态码或解析返回的 JSON 出现问题时，将执行 `error` 方法。\r\n\r\n<a name=\"broadcasting-to-presence-channels\"></a>\r\n### 广播到存在频道\r\n\r\n状态频道可以像公共或私人频道一样接收事件。以聊天室为例，我们可能希望将「NewMessage」事件广播到房间的出席频道。 为此，我们将从事件的 `broadcastOn` 方法返回一个 `PresenceChannel` 的实例：\r\n\r\n    /**\r\n     * 获取事件应该广播的频道。\r\n     *\r\n     * @return Channel|array\r\n     */\r\n    public function broadcastOn()\r\n    {\r\n        return new PresenceChannel('room.'.$this->message->room_id);\r\n    }\r\n\r\n\r\n\r\n与其他事件一样，您可以使用 `broadcast` 助手和 `toOthers` 方法来排除当前用户接收广播：\r\n\r\n    broadcast(new NewMessage($message));\r\n\r\n    broadcast(new NewMessage($message))->toOthers();\r\n\r\n作为典型的其他类型事件，您可以使用 Echo 的 `listen` 方法监听发送到存在通道的事件：\r\n\r\n```js\r\nEcho.join(`chat.${roomId}`)\r\n    .here(...)\r\n    .joining(...)\r\n    .leaving(...)\r\n    .listen('NewMessage', (e) => {\r\n        //\r\n    });\r\n```\r\n\r\n<a name=\"model-broadcasting\"></a>\r\n## 模型广播\r\n\r\n> 注意：在阅读以下有关模型广播的文档之前，我们建议您熟悉 Laravel 模型广播服务的一般概念以及如何手动创建和收听广播事件。\r\n\r\n在创建、更新或删除应用程序的 [Eloquent 模型](/docs/laravel/9.x/eloquent) 时广播事件是很常见的。 当然，这可以通过手动[为 Eloquent 模型状态更改定义自定义事件](/docs/laravel/9.x/eloquent#events) 并使用 `ShouldBroadcast` 接口标记这些事件来轻松完成。\r\n\r\n但是，如果您在应用程序中没有将这些事件用于任何其他目的，则仅出于广播它们的目的而创建事件类可能会很麻烦。为了解决这个问题，Laravel 允许您指示 Eloquent 模型应该自动广播其状态更改。\r\n\r\n首先，您的 Eloquent 模型应该使用 `Illuminate\\Database\\Eloquent\\BroadcastsEvents` 特征。此外，模型应该定义一个 `broadcastsOn` 方法，该方法将返回模型事件应该在其上广播的频道数组：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Broadcasting\\PrivateChannel;\r\nuse Illuminate\\Database\\Eloquent\\BroadcastsEvents;\r\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Post extends Model\r\n{\r\n    use BroadcastsEvents, HasFactory;\r\n\r\n    /**\r\n     * 获取帖子所属的用户。\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class);\r\n    }\r\n\r\n    /**\r\n     * 获取模型事件应该广播的频道。\r\n     *\r\n     * @param  string  $event\r\n     * @return \\Illuminate\\Broadcasting\\Channel|array\r\n     */\r\n    public function broadcastOn($event)\r\n    {\r\n        return [$this, $this->user];\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n一旦您的模型包含此特征并定义其广播通道，它将在模型实例被创建、更新、删除、删除或恢复时自动开始广播事件。\r\n\r\n此外，您可能已经注意到 `broadcastOn` 方法接收字符串 `$event` 参数。该参数包含模型上发生的事件类型，其值为`created`、`updated`、`deleted`、`trashed`或`restored`。通过检查此变量的值，您可以确定模型应该为特定事件广播到哪些频道（如果有）：\r\n\r\n```php\r\n/**\r\n * 获取模型事件应该广播的频道。\r\n *\r\n * @param  string  $event\r\n * @return \\Illuminate\\Broadcasting\\Channel|array\r\n */\r\npublic function broadcastOn($event)\r\n{\r\n    return match ($event) {\r\n        'deleted' => [],\r\n        default => [$this, $this->user],\r\n    };\r\n}\r\n```\r\n\r\n<a name=\"customizing-model-broadcasting-event-creation\"></a>\r\n#### 自定义模型广播事件创建\r\n\r\n有时，您可能希望自定义 Laravel 如何创建底层模型广播事件。您可以通过在 Eloquent 模型上定义一个 `newBroadcastableEvent` 方法来完成此操作。这个方法应该返回一个 `Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred` 实例：\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred;\r\n\r\n/**\r\n * 为模型创建一个新的可广播模型事件。\r\n *\r\n * @param  string  $event\r\n * @return \\Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred\r\n */\r\nprotected function newBroadcastableEvent($event)\r\n{\r\n    return (new BroadcastableModelEventOccurred(\r\n        $this, $event\r\n    ))->dontBroadcastToCurrentUser();\r\n}\r\n```\r\n\r\n<a name=\"model-broadcasting-conventions\"></a>\r\n### 广播约定模型\r\n\r\n<a name=\"model-broadcasting-channel-conventions\"></a>\r\n#### 广播约定\r\n\r\n您可能已经注意到，上面模型示例中的 `broadcastOn` 方法没有返回 `Channel` 实例。相反，直接返回了 Eloquent 模型。如果模型的 `broadcastOn` 方法返回 Eloquent 模型实例（或包含在该方法返回的数组中），Laravel 将使用模型的类名和主键标识符作为通道自动为模型实例化一个私有通道实例 姓名。\r\n\r\n\r\n\r\n因此，`id`为`1`的`App\\Models\\User`模型将被转换为名称为`App.Models.User.1`的`Illuminate\\Broadcasting\\PrivateChannel`实例。当然，除了从模型的 `broadcastOn` 方法返回 Eloquent 模型实例之外，您还可以返回完整的 `Channel` 实例，以便完全控制模型的通道名称：\r\n\r\n```php\r\nuse Illuminate\\Broadcasting\\PrivateChannel;\r\n\r\n/**\r\n * 获取模型事件应该广播的频道。\r\n *\r\n * @param  string  $event\r\n * @return \\Illuminate\\Broadcasting\\Channel|array\r\n */\r\npublic function broadcastOn($event)\r\n{\r\n    return [new PrivateChannel('user.'.$this->id)];\r\n}\r\n```\r\n\r\n如果您打算从模型的 `broadcastOn` 方法显式返回一个通道实例，则可以将 Eloquent 模型实例传递给通道的构造函数。这样做时，Laravel 将使用上面讨论的模型通道约定将 Eloquent 模型转换为通道名称字符串：\r\n\r\n```php\r\nreturn [new Channel($this->user)];\r\n```\r\n\r\n如果需要确定模型的频道名称，可以在任何模型实例上调用 `broadcastChannel` 方法。例如，此方法为 `App\\Models\\User` 模型返回字符串 `App.Models.User.1`，其 `id` 为 `1`：\r\n\r\n```php\r\n$user->broadcastChannel()\r\n```\r\n\r\n<a name=\"model-broadcasting-event-conventions\"></a>\r\n#### 事件约定\r\n\r\n由于模型广播事件不与应用程序的`App\\Events`目录中的「实际」事件相关联，因此根据约定为它们分配名称和有效负载。Laravel 的约定是使用模型的类名（不包括命名空间）和触发广播的模型事件的名称来广播事件。\r\n\r\n因此，例如，对 `App\\Models\\Post` 模型的更新会将事件作为 `PostUpdated` 广播到您的客户端应用程序，并带有以下有效负载：\r\n\r\n```json\r\n{\r\n    \"model\": {\r\n        \"id\": 1,\r\n        \"title\": \"My first post\"\r\n        ...\r\n    },\r\n    ...\r\n    \"socket\": \"someSocketId\",\r\n}\r\n```\r\n\r\n\r\n\r\n删除 `App\\Models\\User` 模型会广播一个名为 `UserDeleted` 的事件。\r\n\r\n如果您愿意，您可以通过向模型添加 `broadcastAs` 和 `broadcastWith` 方法来定义自定义广播名称和有效负载。这些方法接收正在发生的模型事件/操作的名称，允许您为每个模型操作自定义事件的名称和有效负载。如果从 `broadcastAs` 方法返回 `null`，Laravel 将在广播事件时使用上面讨论的模型广播事件名称约定：\r\n\r\n```php\r\n/**\r\n * 模型事件的广播名称。\r\n *\r\n * @param  string  $event\r\n * @return string|null\r\n */\r\npublic function broadcastAs($event)\r\n{\r\n    return match ($event) {\r\n        'created' => 'post.created',\r\n        default => null,\r\n    };\r\n}\r\n\r\n/**\r\n * 获取要为模型广播的数据。\r\n *\r\n * @param  string  $event\r\n * @return array\r\n */\r\npublic function broadcastWith($event)\r\n{\r\n    return match ($event) {\r\n        'created' => ['title' => $this->title],\r\n        default => ['model' => $this],\r\n    };\r\n}\r\n```\r\n\r\n<a name=\"listening-for-model-broadcasts\"></a>\r\n### 监听模型广播\r\n\r\n一旦你为你的模型添加了 `BroadcastsEvents` 特征并定义了模型的 `broadcastOn` 方法，你就可以开始在客户端应用程序中监听广播的模型事件了。在开始之前，您可能希望查阅有关 [listening for events](#listening-for-events) 的完整文档。\r\n\r\n首先，使用 `private` 方法获取通道的实例，然后调用 `listen` 方法来监听指定事件。通常，赋予 `private` 方法的频道名称应对应于 Laravel 的 [模型广播约定](#model-broadcasting-conventions)。\r\n\r\n一旦你获得了一个通道实例，你可以使用 `listen` 方法来监听一个特定的事件。由于模型广播事件不与应用程序的`App\\Events`目录中的「实际」事件相关联，因此 [事件名称](#model-broadcasting-event-conventions) 必须以 `.` 为前缀以表明它确实如此不属于特定的命名空间。每个模型广播事件都有一个“模型”属性，其中包含模型的所有可广播属性：\r\n\r\n```js\r\nEcho.private(`App.Models.User.${this.user.id}`)\r\n    .listen('.PostUpdated', (e) => {\r\n        console.log(e.model);\r\n    });\r\n```\r\n\r\n\r\n\r\n<a name=\"client-events\"></a>\r\n## 客户端事件\r\n\r\n> 技巧：使用 [Pusher Channels](https://pusher.com/channels) 时，您必须在 [应用程序仪表板](https://dashboard.pusher.com) 的“应用程序设置”部分中启用“客户端事件”选项 /) 以发送客户端事件。\r\n\r\n有时您可能希望将事件广播给其他连接的客户端，而根本不影响您的 Laravel 应用程序。这对于诸如「键入」通知之类的事情特别有用，您希望提醒应用程序的用户另一个用户正在给定屏幕上键入消息。\r\n\r\n要广播客户端事件，您可以使用 Echo 的 `whisper` 方法：\r\n\r\n```js\r\nEcho.private(`chat.${roomId}`)\r\n    .whisper('typing', {\r\n        name: this.user.name\r\n    });\r\n```\r\n\r\n要监听客户端事件，您可以使用 `listenForWhisper` 方法：\r\n\r\n```js\r\nEcho.private(`chat.${roomId}`)\r\n    .listenForWhisper('typing', (e) => {\r\n        console.log(e.name);\r\n    });\r\n```\r\n\r\n<a name=\"notifications\"></a>\r\n## 通知\r\n\r\n通过将事件广播与 [notifications](/docs/laravel/9.x/notifications) 配对，您的 JavaScript 应用程序可以在新通知发生时接收它们，而无需刷新页面。在开始之前，请务必阅读有关使用 [广播通知频道] 的文档（/docs/laravel/9.x/notifications#broadcast-notifications）。\r\n\r\n一旦你配置了一个使用广播频道的通知，你就可以使用 Echo 的 `notification` 方法来监听广播事件。请记住，通道名称应与接收通知的实体的类名称匹配：\r\n\r\n```js\r\nEcho.private(`App.Models.User.${userId}`)\r\n    .notification((notification) => {\r\n        console.log(notification.type);\r\n    });\r\n```\r\n\r\n在这个例子中，所有通过 `broadcast` 通道发送到 `App\\Models\\User` 实例的通知都会被回调接收。 `App.Models.User.{id}` 频道的频道授权回调包含在 Laravel 框架附带的默认 `BroadcastServiceProvider` 中。\r\n\r\n","p":"docs/broadcasting.html"},{"t":"cache (缓存系统)","d":"# 缓存系统\r\n\r\n- [简介](#introduction)\r\n- [配置](#configuration)\r\n    - [驱动的前提条件](#driver-prerequisites)\r\n- [缓存使用](#cache-usage)\r\n    - [获取缓存实例](#obtaining-a-cache-instance)\r\n    - [从缓存获取数据](#retrieving-items-from-the-cache)\r\n    - [向缓存存储数据](#storing-items-in-the-cache)\r\n    - [从缓存删除数据](#removing-items-from-the-cache)\r\n    - [Cache 辅助函数](#the-cache-helper)\r\n- [缓存标记](#cache-tags)\r\n    - [存储被标记的缓存数据](#storing-tagged-cache-items)\r\n    - [访问被标记的缓存数据](#accessing-tagged-cache-items)\r\n    - [删除被标记的缓存数据](#removing-tagged-cache-items)\r\n- [原子锁](#atomic-locks)\r\n    - [驱动的前提条件](#lock-driver-prerequisites)\r\n    - [管理锁](#managing-locks)\r\n    - [跨进程管理锁](#managing-locks-across-processes)\r\n- [添加自定义缓存驱动](#adding-custom-cache-drivers)\r\n    - [编写驱动](#writing-the-driver)\r\n    - [注册驱动](#registering-the-driver)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在某些应用中，一些查询数据或处理任务的操作会在某段时间里短时间内大量进行，或是一个操作花费好几秒钟。当出现这种情况时，通常会将检索到的数据缓存起来，从而为后面请求同一数据的请求迅速返回结果。这些缓存数据通常会储存在极快的存储系统中，例如 [Memcached](https://memcached.org) 和 [Redis](https://redis.io)。\r\n\r\nLaravel 为各种缓存后端提供了富有表现力且统一的 API，以便你利用它们极快的查询数据来加快你的应用。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n缓存配置文件位于 `config/cache.php`。在这个文件中，你可以指定应用默认使用哪个缓存驱动。Laravel 支持的缓存后端包括 [Memcached](https://memcached.org)、[Redis](https://redis.io)、[DynamoDB](https://aws.amazon.com/dynamodb)，以及现成的关系型数据库。此外，还支持基于文件的缓存驱动，以及方便自动化测试的缓存驱动 `array` 和 `null` 。\r\n\r\n\r\n\r\n缓存配置文件还包含文件中记录的各种其他选项，因此请务必阅读这些选项。默认情况下，Laravel 配置为使用 `file` 缓存驱动程序，它将序列化的缓存对象存储在服务器的文件系统上。对于较大的应用程序，建议您使用更健壮的驱动程序，例如 Memcached 或 Redis。您甚至可以为同一个驱动程序配置多个缓存配置。\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动程序必备条件\r\n\r\n<a name=\"prerequisites-database\"></a>\r\n#### 数据库\r\n\r\n当使用 `database` 缓存驱动程序时，您需要设置一个表来包含缓存项。您将在下表中找到一个示例 `Schema` 声明：\r\n\r\n    Schema::create('cache', function ($table) {\r\n        $table->string('key')->unique();\r\n        $table->text('value');\r\n        $table->integer('expiration');\r\n    });\r\n\r\n> 技巧：您还可以使用 `php artisan cache:table` Artisan 命令生成具有正确模式的迁移。\r\n\r\n<a name=\"memcached\"></a>\r\n#### Memcached\r\n\r\n使用 Memcached 驱动需要安装【Memcached PECL 包】(https://pecl.php.net/package/memcached)。您可以在 `config/cache.php` 配置文件中列出所有 Memcached 服务器。 该文件已经包含一个 `memcached.servers` 条目以帮助您入门：\r\n\r\n    'memcached' => [\r\n        'servers' => [\r\n            [\r\n                'host' => env('MEMCACHED_HOST', '127.0.0.1'),\r\n                'port' => env('MEMCACHED_PORT', 11211),\r\n                'weight' => 100,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n如果需要，您可以将 `host` 选项设置为 UNIX 套接字路径。如果你这样做，`port` 选项应该设置为 `0`：\r\n\r\n    'memcached' => [\r\n        [\r\n            'host' => '/var/run/memcached/memcached.sock',\r\n            'port' => 0,\r\n            'weight' => 100\r\n        ],\r\n    ],\r\n\r\n<a name=\"redis\"></a>\r\n#### Redis\r\n\r\n在将 Redis 缓存与 Laravel 一起使用之前，您需要通过 PECL 安装 PhpRedis PHP 扩展或通过 Composer 安装 `predis/predis` 包（~1.0）。[Laravel Sail](/docs/laravel/9.x/sail) 已经包含了这个扩展。另外，Laravel 官方部署平台如 [Laravel Forge](https://forge.laravel.com) 和 [Laravel Vapor](https://vapor.laravel.com) 默认安装了 PhpRedis 扩展。\r\n\r\n\r\n\r\n有关配置 Redis 的更多信息，请参阅其 [Laravel 文档页面](/docs/laravel/9.x/redis#configuration)。\r\n\r\n<a name=\"dynamodb\"></a>\r\n#### DynamoDB\r\n\r\n在使用 [DynamoDB](https://aws.amazon.com/dynamodb) 缓存驱动程序之前，您必须创建一个 DynamoDB 表来存储所有缓存的数据。通常，此表应命名为「缓存」。但是，您应该根据应用程序的 `cache` 配置文件中的 `stores.dynamodb.table` 配置值来命名表。\r\n\r\n该表还应该有一个字符串分区键，其名称对应于应用程序的 `cache` 配置文件中的 `stores.dynamodb.attributes.key` 配置项的值。 默认情况下，分区键应命名为 `key`。\r\n\r\n<a name=\"cache-usage\"></a>\r\n## 缓存使用\r\n\r\n<a name=\"obtaining-a-cache-instance\"></a>\r\n### 获取缓存实例\r\n\r\n要获取缓存存储实例，您可以使用 `Cache` Facade，我们将在本文档中使用它。`Cache` Facade 提供了对 Laravel 缓存合约底层实现的方便、简洁的访问：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示应用程序的所有用户的列表。\r\n         *\r\n         * @return Response\r\n         */\r\n        public function index()\r\n        {\r\n            $value = Cache::get('key');\r\n\r\n            //\r\n        }\r\n    }\r\n\r\n<a name=\"accessing-multiple-cache-stores\"></a>\r\n#### 访问多个缓存存储\r\n\r\n使用 `Cache` Facade，您可以通过 `store` 方法访问各种缓存存储。传递给 `store` 方法的键应该对应于 `cache` 配置文件中的 `stores` 配置数组中列出的存储之一：\r\n\r\n    $value = Cache::store('file')->get('foo');\r\n\r\n    Cache::store('redis')->put('bar', 'baz', 600); // 10 Minutes\r\n\r\n\r\n\r\n<a name=\"retrieving-items-from-the-cache\"></a>\r\n### 从缓存中检索项目\r\n\r\n`Cache` 门面的 `get` 方法用于从缓存中检索项目。如果缓存中不存在该项目，则将返回 `null`。如果您愿意，您可以将第二个参数传递给 `get` 方法，指定您希望在项目不存在时返回的默认值：\r\n\r\n    $value = Cache::get('key');\r\n\r\n    $value = Cache::get('key', 'default');\r\n\r\n您甚至可以将闭包作为默认值传递。如果指定的项在缓存中不存在，则返回闭包的结果。传递闭包允许您推迟从数据库或其他外部服务中检索默认值：\r\n\r\n    $value = Cache::get('key', function () {\r\n        return DB::table(...)->get();\r\n    });\r\n\r\n<a name=\"checking-for-item-existence\"></a>\r\n#### 检查项目是否存在\r\n\r\n`has` 方法可用于确定缓存中是否存在项目。如果项目存在但其值为 `null`，此方法也将返回 `false`：\r\n\r\n    if (Cache::has('key')) {\r\n        //\r\n    }\r\n\r\n<a name=\"incrementing-decrementing-values\"></a>\r\n#### 递增/递减值\r\n\r\n`increment` 和 `decrement` 方法可用于调整缓存中整数项的值。这两种方法都接受一个可选的第二个参数，指示增加或减少项目值的数量：\r\n\r\n    Cache::increment('key');\r\n    Cache::increment('key', $amount);\r\n    Cache::decrement('key');\r\n    Cache::decrement('key', $amount);\r\n\r\n<a name=\"retrieve-store\"></a>\r\n#### 检索和存储\r\n\r\n有时您可能希望从缓存中检索一个项目，但如果请求的项目不存在，也存储一个默认值。例如，您可能希望从缓存中检索所有用户，或者，如果它们不存在，则从数据库中检索它们并将它们添加到缓存中。您可以使用 `Cache::remember` 方法执行此操作：\r\n\r\n    $value = Cache::remember('users', $seconds, function () {\r\n        return DB::table('users')->get();\r\n    });\r\n\r\n\r\n\r\n如果缓存中不存在该项，则传递给 `remember` 方法的闭包将被执行，并将其结果放入缓存中。\r\n\r\n您可以使用 `rememberForever` 方法从缓存中检索一个项目，或者如果它不存在则永久存储它：\r\n\r\n    $value = Cache::rememberForever('users', function () {\r\n        return DB::table('users')->get();\r\n    });\r\n\r\n<a name=\"retrieve-delete\"></a>\r\n#### 检索和删除\r\n\r\n如果您需要从缓存中检索一个项目然后删除该项目，您可以使用 `pull` 方法。 与 `get` 方法一样，如果缓存中不存在该项，则将返回 `null`：\r\n\r\n    $value = Cache::pull('key');\r\n\r\n<a name=\"storing-items-in-the-cache\"></a>\r\n### 在缓存中存储项目\r\n\r\n您可以使用 `Cache` Facade 上的 `put` 方法将项目存储在缓存中：\r\n\r\n    Cache::put('key', 'value', $seconds = 10);\r\n\r\n如果存储时间没有传递给 `put` 方法，该项目将被无限期存储：\r\n\r\n    Cache::put('key', 'value');\r\n\r\n除了将秒数作为整数传递之外，您还可以传递一个表示缓存项所需过期时间的 `DateTime` 实例：\r\n\r\n    Cache::put('key', 'value', now()->addMinutes(10));\r\n\r\n<a name=\"store-if-not-present\"></a>\r\n#### 如果不存在则存储\r\n\r\n`add` 方法只会将缓存存储中不存在的项目添加到缓存中。如果项目实际添加到缓存中，该方法将返回 `true`。 否则，该方法将返回 `false`。 `add` 方法是一个原子操作：\r\n\r\n    Cache::add('key', 'value', $seconds);\r\n\r\n\r\n\r\n<a name=\"storing-items-forever\"></a>\r\n#### 永久存储\r\n\r\n`forever` 方法可用于将项目永久存储在缓存中。由于这些项目不会过期，因此必须使用 `forget` 方法手动将它们从缓存中删除：\r\n\r\n    Cache::forever('key', 'value');\r\n\r\n> 技巧：如果您使用的是 Memcached 驱动程序，则当缓存达到其大小限制时，可能会删除「永久」存储的项目。\r\n\r\n<a name=\"removing-items-from-the-cache\"></a>\r\n### 从缓存中删除项目\r\n\r\n您可以使用 `forget` 方法从缓存中删除项目：\r\n\r\n    Cache::forget('key');\r\n\r\n您还可以通过提供零或负数的过期秒数来删除项目：\r\n\r\n    Cache::put('key', 'value', 0);\r\n\r\n    Cache::put('key', 'value', -5);\r\n\r\n您可以使用 `flush` 方法清除整个缓存：\r\n\r\n    Cache::flush();\r\n\r\n> 注意：刷新缓存不会考虑您配置的缓存「前缀」，并且会从缓存中删除所有条目。\r\n在清除由其他应用程序共享的缓存时，请仔细考虑这一点。\r\n\r\n<a name=\"the-cache-helper\"></a>\r\n### 缓存助手函数\r\n\r\n除了使用 `Cache` 门面之外，您还可以使用全局 `cache` 函数通过缓存检索和存储数据。当使用单个字符串参数调用 `cache` 函数时，它将返回给定键的值：\r\n\r\n    $value = cache('key');\r\n\r\n如果您向函数提供键/值对数组和过期时间，它将在指定的持续时间内将值存储在缓存中：\r\n\r\n    cache(['key' => 'value'], $seconds);\r\n\r\n    cache(['key' => 'value'], now()->addMinutes(10));\r\n\r\n当不带任何参数调用 `cache` 函数时，它会返回 `Illuminate\\Contracts\\Cache\\Factory` 实现的实例，允许您调用其他缓存方法：\r\n\r\n    cache()->remember('users', $seconds, function () {\r\n        return DB::table('users')->get();\r\n    });\r\n\r\n> 技巧：在测试对全局 `cache` 函数的调用时，您可以使用 `Cache::shouldReceive` 方法，就像 [testing the facade](/docs/laravel/9.x/mocking#mocking-facades)。\r\n\r\n\r\n\r\n<a name=\"cache-tags\"></a>\r\n## 缓存标签\r\n\r\n> 注意：使用 `file`、`dynamodb` 或 `database` 缓存驱动程序时不支持缓存标记。 此外，当使用带有“永久”存储的缓存的多个标签时，使用诸如“memcached”之类的驱动程序会获得最佳性能，它会自动清除陈旧的记录。\r\n\r\n<a name=\"storing-tagged-cache-items\"></a>\r\n### 存储缓存标签\r\n\r\n缓存标签允许您在缓存中标记相关项目，然后刷新所有已分配给定标签的缓存值。您可以通过传入标记名称的有序数组来访问标记缓存。例如，让我们访问一个标记的缓存并将一个值「put」缓存中：\r\n\r\n    Cache::tags(['people', 'artists'])->put('John', $john, $seconds);\r\n\r\n    Cache::tags(['people', 'authors'])->put('Anne', $anne, $seconds);\r\n\r\n<a name=\"accessing-tagged-cache-items\"></a>\r\n### 访问缓存标签\r\n\r\n要检索标记的缓存项，请将相同的有序标签列表传递给 `tags` 方法，然后使用您要检索的键调用 `get` 方法：\r\n\r\n    $john = Cache::tags(['people', 'artists'])->get('John');\r\n\r\n    $anne = Cache::tags(['people', 'authors'])->get('Anne');\r\n\r\n<a name=\"removing-tagged-cache-items\"></a>\r\n### 删除缓存标签\r\n\r\n您可以刷新所有分配了标签或标签列表的项目。例如，此语句将删除所有标记为「people」、「authors」或两者的缓存。 因此，`Anne` 和 `John` 都将从缓存中删除：\r\n\r\n    Cache::tags(['people', 'authors'])->flush();\r\n\r\n相反，此语句将仅删除带有 `authors` 标记的缓存值，因此将删除 `Anne`，但不会删除 `John`：\r\n\r\n    Cache::tags('authors')->flush();\r\n\r\n\r\n\r\n<a name=\"atomic-locks\"></a>\r\n## 原子锁\r\n\r\n> 注意：要使用此功能，您的应用程序必须使用`memcached`、`redis`、`dynamicodb`、`database`、`file`或`array`缓存驱动程序作为应用程序的默认缓存驱动程序。\r\n此外，所有服务器都必须与同一中央缓存服务器通信。\r\n\r\n<a name=\"lock-driver-prerequisites\"></a>\r\n### 驱动程序先决条件\r\n\r\n<a name=\"atomic-locks-prerequisites-database\"></a>\r\n#### 数据库\r\n\r\n使用“数据库”缓存驱动程序时，您需要设置一个表来包含应用程序的缓存锁。您将在下表中找到一个示例 `Schema` 声明：\r\n\r\n    Schema::create('cache_locks', function ($table) {\r\n        $table->string('key')->primary();\r\n        $table->string('owner');\r\n        $table->integer('expiration');\r\n    });\r\n\r\n<a name=\"managing-locks\"></a>\r\n### 管理锁\r\n\r\n原子锁允许操作分布式锁而不用担心竞争条件。例如，[Laravel Forge](https://forge.laravel.com) 使用原子锁来确保服务器上一次只执行一个远程任务。您可以使用 `Cache::lock` 方法创建和管理锁：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    $lock = Cache::lock('foo', 10);\r\n\r\n    if ($lock->get()) {\r\n        // 锁定 10 秒...\r\n\r\n        $lock->release();\r\n    }\r\n\r\n`get` 方法也接受一个闭包。闭包执行后，Laravel 会自动释放锁：\r\n\r\n    Cache::lock('foo')->get(function () {\r\n        // 锁定无限期获得并自动释放...\r\n    });\r\n\r\n如果在您请求时锁不可用，您可以指示 Laravel 等待指定的秒数。如果在指定的时间限制内无法获取锁，则会抛出 `Illuminate\\Contracts\\Cache\\LockTimeoutException`：\r\n\r\n    use Illuminate\\Contracts\\Cache\\LockTimeoutException;\r\n\r\n    $lock = Cache::lock('foo', 10);\r\n\r\n    try {\r\n        $lock->block(5);\r\n\r\n        // 等待最多 5 秒后获得锁定...\r\n    } catch (LockTimeoutException $e) {\r\n        // 无法获取锁...\r\n    } finally {\r\n        optional($lock)->release();\r\n    }\r\n\r\n\r\n\r\n上面的例子可以通过将闭包传递给 `block` 方法来简化。当一个闭包被传递给这个方法时，Laravel 将尝试在指定的秒数内获取锁，并在闭包执行后自动释放锁：\r\n\r\n    Cache::lock('foo', 10)->block(5, function () {\r\n        // 等待最多 5 秒后获得锁定...\r\n    });\r\n\r\n<a name=\"managing-locks-across-processes\"></a>\r\n### 跨进程管理锁\r\n\r\n有时，您可能希望在一个进程中获取锁并在另一个进程中释放它。例如，您可能在 Web 请求期间获取锁，并希望在由该请求触发的排队作业结束时释放锁。在这种情况下，您应该将锁的作用域「owner 令牌」传递给排队的作业，以便作业可以使用给定的令牌重新实例化锁。\r\n\r\n在下面的示例中，如果成功获取锁，我们将调度一个排队的作业。 此外，我们将通过锁的 `owner` 方法将锁的所有者令牌传递给排队的作业：\r\n\r\n    $podcast = Podcast::find($id);\r\n\r\n    $lock = Cache::lock('processing', 120);\r\n\r\n    if ($lock->get()) {\r\n        ProcessPodcast::dispatch($podcast, $lock->owner());\r\n    }\r\n\r\n在我们应用程序的 `ProcessPodcast` 作业中，我们可以使用所有者令牌恢复和释放锁：\r\n\r\n    Cache::restoreLock('processing', $this->owner)->release();\r\n\r\n如果你想释放一个锁而不考虑它的当前所有者，你可以使用 `forceRelease` 方法：\r\n\r\n    Cache::lock('processing')->forceRelease();\r\n\r\n<a name=\"adding-custom-cache-drivers\"></a>\r\n## 添加自定义缓存驱动程序\r\n\r\n<a name=\"writing-the-driver\"></a>\r\n\r\n\r\n### 编写驱动程序\r\n\r\n要创建我们的自定义缓存驱动程序，我们首先需要实现 `Illuminate\\Contracts\\Cache\\Store` [contract](/docs/laravel/9.x/contracts)。 因此，MongoDB 缓存实现可能如下所示：\r\n\r\n    <?php\r\n\r\n    namespace App\\Extensions;\r\n\r\n    use Illuminate\\Contracts\\Cache\\Store;\r\n\r\n    class MongoStore implements Store\r\n    {\r\n        public function get($key) {}\r\n        public function many(array $keys) {}\r\n        public function put($key, $value, $seconds) {}\r\n        public function putMany(array $values, $seconds) {}\r\n        public function increment($key, $value = 1) {}\r\n        public function decrement($key, $value = 1) {}\r\n        public function forever($key, $value) {}\r\n        public function forget($key) {}\r\n        public function flush() {}\r\n        public function getPrefix() {}\r\n    }\r\n\r\n我们只需要使用 MongoDB 连接来实现这些方法中的每一个。有关如何实现这些方法的示例，请查看 [Laravel 框架源代码](https://github.com/laravel/framework) 中的 `Illuminate\\Cache\\MemcachedStore`。 一旦我们的实现完成，我们可以通过调用 `Cache` 门面的 `extend` 方法来完成我们的自定义驱动程序注册：\r\n\r\n    Cache::extend('mongo', function ($app) {\r\n        return Cache::repository(new MongoStore);\r\n    });\r\n\r\n> 技巧：如果您想知道将自定义缓存驱动程序代码放在哪里，您可以在您的 `app` 目录中创建一个 `Extensions` 命名空间。 但是请记住，Laravel 没有严格的应用程序结构，您可以根据自己的喜好自由组织应用程序。\r\n\r\n<a name=\"registering-the-driver\"></a>\r\n### 注册驱动程序\r\n\r\n要向 Laravel 注册自定义缓存驱动程序，我们将使用 `Cache` 门面的 `extend` 方法。 由于其他服务提供者可能会尝试在他们的 `boot` 方法中读取缓存值，我们将在 `booting` 回调中注册我们的自定义驱动程序。 通过使用 `booting` 回调，我们可以确保在应用程序的服务提供者调用 `boot` 方法之前但在所有服务提供者调用 `register` 方法之后注册自定义驱动程序。 我们将在应用程序的 `App\\Providers\\AppServiceProvider` 类的 `register` 方法中注册我们的 `booting` 回调：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Extensions\\MongoStore;\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class CacheServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            $this->app->booting(function () {\r\n                 Cache::extend('mongo', function ($app) {\r\n                     return Cache::repository(new MongoStore);\r\n                 });\r\n             });\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n\r\n\r\n传递给 `extend` 方法的第一个参数是驱动程序的名称。这将对应于 `config/cache.php` 配置文件中的 `driver` 选项。 第二个参数是一个闭包，它应该返回一个 `Illuminate\\Cache\\Repository` 实例。闭包将传递一个 `$app` 实例，它是 [服务容器](/docs/laravel/9.x/container) 的一个实例。\r\n\r\n注册扩展程序后，将 `config/cache.php` 配置文件的 `driver` 选项更新为扩展程序的名称。\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\n要在每个缓存操作上执行代码，您可以侦听缓存触发的 [events](/docs/laravel/9.x/events)。 通常，您应该将这些事件侦听器放在应用程序的 `App\\Providers\\EventServiceProvider` 类中：\r\n\r\n    /**\r\n     * The event listener mappings for the application.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Cache\\Events\\CacheHit' => [\r\n            'App\\Listeners\\LogCacheHit',\r\n        ],\r\n\r\n        'Illuminate\\Cache\\Events\\CacheMissed' => [\r\n            'App\\Listeners\\LogCacheMissed',\r\n        ],\r\n\r\n        'Illuminate\\Cache\\Events\\KeyForgotten' => [\r\n            'App\\Listeners\\LogKeyForgotten',\r\n        ],\r\n\r\n        'Illuminate\\Cache\\Events\\KeyWritten' => [\r\n            'App\\Listeners\\LogKeyWritten',\r\n        ],\r\n    ];\r\n\r\n","p":"docs/cache.html"},{"t":"collections (集合)","d":"# 集合\r\n\r\n- [介绍](#introduction)\r\n     - [创建集合](#creating-collections)\r\n     - [扩展集合](#extending-collections)\r\n- [可用方法](#available-methods)\r\n- [高阶消息](#higher-order-messages)\r\n- [惰性集合](#lazy-collections)\r\n     - [介绍](#lazy-collection-introduction)\r\n     - [创建惰性集合](#creating-lazy-collections)\r\n     - [枚举契约](#the-enumerable-contract)\r\n     - [惰性集合方法](#lazy-collection-methods)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n`Illuminate\\Support\\Collection` 类为处理数据数组提供了一个流畅、方便的包装器。 例如，查看以下代码。 我们将使用 `collect` 助手从数组中创建一个新的集合实例，对每个元素运行 `strtoupper` 函数，然后删除所有空元素：\r\n\r\n    $collection = collect(['taylor', 'abigail', null])->map(function ($name) {\r\n        return strtoupper($name);\r\n    })->reject(function ($name) {\r\n        return empty($name);\r\n    });\r\n\r\n如您所见，`Collection` 类允许您链接其方法以执行流畅的映射和减少底层数组。 一般来说，集合是不可变的，这意味着每个 `Collection` 方法都会返回一个全新的 `Collection` 实例。\r\n\r\n<a name=\"creating-collections\"></a>\r\n### 创建集合\r\n\r\n如上所述，`collect` 帮助器为给定数组返回一个新的 `Illuminate\\Support\\Collection` 实例。 因此，创建一个集合非常简单：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n> 技巧：[Eloquent](/docs/laravel/9.x/eloquent) 查询的结果总是作为 `Collection` 实例返回。\r\n\r\n<a name=\"extending-collections\"></a>\r\n### 扩展集合\r\n\r\n集合是“可宏化的”，它允许您在运行时向 `Collection` 类添加其他方法。 `Illuminate\\Support\\Collection` 类的 `macro` 方法接受一个闭包，该闭包将在调用宏时执行。 宏闭包可以通过 `$this` 访问集合的其他方法，就像它是集合类的真实方法一样。 例如，以下代码在 `Collection` 类中添加了 `toUpper` 方法：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    Collection::macro('toUpper', function () {\r\n        return $this->map(function ($value) {\r\n            return Str::upper($value);\r\n        });\r\n    });\r\n\r\n    $collection = collect(['first', 'second']);\r\n\r\n    $upper = $collection->toUpper();\r\n\r\n    // ['FIRST', 'SECOND']\r\n\r\n\r\n\r\n通常，您应该在[service provider](/docs/laravel/9.x/providers)的 `boot` 方法中声明集合宏。\r\n\r\n<a name=\"macro-arguments\"></a>\r\n#### 宏参数\r\n\r\n如有必要，可以定义接受其他参数的宏：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n    use Illuminate\\Support\\Facades\\Lang;\r\n\r\n    Collection::macro('toLocale', function ($locale) {\r\n        return $this->map(function ($value) use ($locale) {\r\n            return Lang::get($value, [], $locale);\r\n        });\r\n    });\r\n\r\n    $collection = collect(['first', 'second']);\r\n\r\n    $translated = $collection->toLocale('es');\r\n\r\n<a name=\"available-methods\"></a>\r\n## 可用的方法\r\n\r\n对于剩余的大部分集合文档，我们将讨论 `Collection` 类中可用的每个方法。请记住，所有这些方法都可以链式调用，以便流畅地操作底层数组。此外，几乎每个方法都会返回一个新的 `Collection` 实例，允许你在必要时保留集合的原始副本：\r\n\r\n<style>\r\n    #collection-method-list > p {\r\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\r\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\r\n    }\r\n\r\n    #collection-method-list a {\r\n        display: block;\r\n    }\r\n</style>\r\n\r\n<div id=\"collection-method-list\" markdown=\"1\">\r\n\r\n[all](#method-all)\r\n[average](#method-average)\r\n[avg](#method-avg)\r\n[chunk](#method-chunk)\r\n[chunkWhile](#method-chunkwhile)\r\n[collapse](#method-collapse)\r\n[collect](#method-collect)\r\n[combine](#method-combine)\r\n[concat](#method-concat)\r\n[contains](#method-contains)\r\n[containsStrict](#method-containsstrict)\r\n[count](#method-count)\r\n[countBy](#method-countBy)\r\n[crossJoin](#method-crossjoin)\r\n[dd](#method-dd)\r\n[diff](#method-diff)\r\n[diffAssoc](#method-diffassoc)\r\n[diffKeys](#method-diffkeys)\r\n[doesntContain](#method-doesntcontain)\r\n[dump](#method-dump)\r\n[duplicates](#method-duplicates)\r\n[duplicatesStrict](#method-duplicatesstrict)\r\n[each](#method-each)\r\n[eachSpread](#method-eachspread)\r\n[every](#method-every)\r\n[except](#method-except)\r\n[filter](#method-filter)\r\n[first](#method-first)\r\n[firstWhere](#method-first-where)\r\n[flatMap](#method-flatmap)\r\n[flatten](#method-flatten)\r\n[flip](#method-flip)\r\n[forget](#method-forget)\r\n[forPage](#method-forpage)\r\n[get](#method-get)\r\n[groupBy](#method-groupby)\r\n[has](#method-has)\r\n[implode](#method-implode)\r\n[intersect](#method-intersect)\r\n[intersectByKeys](#method-intersectbykeys)\r\n[isEmpty](#method-isempty)\r\n[isNotEmpty](#method-isnotempty)\r\n[join](#method-join)\r\n[keyBy](#method-keyby)\r\n[keys](#method-keys)\r\n[last](#method-last)\r\n[macro](#method-macro)\r\n[make](#method-make)\r\n[map](#method-map)\r\n[mapInto](#method-mapinto)\r\n[mapSpread](#method-mapspread)\r\n[mapToGroups](#method-maptogroups)\r\n[mapWithKeys](#method-mapwithkeys)\r\n[max](#method-max)\r\n[median](#method-median)\r\n[merge](#method-merge)\r\n[mergeRecursive](#method-mergerecursive)\r\n[min](#method-min)\r\n[mode](#method-mode)\r\n[nth](#method-nth)\r\n[only](#method-only)\r\n[pad](#method-pad)\r\n[partition](#method-partition)\r\n[pipe](#method-pipe)\r\n[pipeInto](#method-pipeinto)\r\n[pipeThrough](#method-pipethrough)\r\n[pluck](#method-pluck)\r\n[pop](#method-pop)\r\n[prepend](#method-prepend)\r\n[pull](#method-pull)\r\n[push](#method-push)\r\n[put](#method-put)\r\n[random](#method-random)\r\n[range](#method-range)\r\n[reduce](#method-reduce)\r\n[reduceMany](#method-reduce-many)\r\n[reduceSpread](#method-reduce-spread)\r\n[reject](#method-reject)\r\n[replace](#method-replace)\r\n[replaceRecursive](#method-replacerecursive)\r\n[reverse](#method-reverse)\r\n[search](#method-search)\r\n[shift](#method-shift)\r\n[shuffle](#method-shuffle)\r\n[sliding](#method-sliding)\r\n[skip](#method-skip)\r\n[skipUntil](#method-skipuntil)\r\n[skipWhile](#method-skipwhile)\r\n[slice](#method-slice)\r\n[sole](#method-sole)\r\n[some](#method-some)\r\n[sort](#method-sort)\r\n[sortBy](#method-sortby)\r\n[sortByDesc](#method-sortbydesc)\r\n[sortDesc](#method-sortdesc)\r\n[sortKeys](#method-sortkeys)\r\n[sortKeysDesc](#method-sortkeysdesc)\r\n[sortKeysUsing](#method-sortkeysusing)\r\n[splice](#method-splice)\r\n[split](#method-split)\r\n[splitIn](#method-splitin)\r\n[sum](#method-sum)\r\n[take](#method-take)\r\n[takeUntil](#method-takeuntil)\r\n[takeWhile](#method-takewhile)\r\n[tap](#method-tap)\r\n[times](#method-times)\r\n[toArray](#method-toarray)\r\n[toJson](#method-tojson)\r\n[transform](#method-transform)\r\n[undot](#method-undot)\r\n[union](#method-union)\r\n[unique](#method-unique)\r\n[uniqueStrict](#method-uniquestrict)\r\n[unless](#method-unless)\r\n[unlessEmpty](#method-unlessempty)\r\n[unlessNotEmpty](#method-unlessnotempty)\r\n[unwrap](#method-unwrap)\r\n[values](#method-values)\r\n[when](#method-when)\r\n[whenEmpty](#method-whenempty)\r\n[whenNotEmpty](#method-whennotempty)\r\n[where](#method-where)\r\n[whereStrict](#method-wherestrict)\r\n[whereBetween](#method-wherebetween)\r\n[whereIn](#method-wherein)\r\n[whereInStrict](#method-whereinstrict)\r\n[whereInstanceOf](#method-whereinstanceof)\r\n[whereNotBetween](#method-wherenotbetween)\r\n[whereNotIn](#method-wherenotin)\r\n[whereNotInStrict](#method-wherenotinstrict)\r\n[whereNotNull](#method-wherenotnull)\r\n[whereNull](#method-wherenull)\r\n[wrap](#method-wrap)\r\n[zip](#method-zip)\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"method-listing\"></a>\r\n## 方法列表\r\n\r\n<style>\r\n    .collection-method code {\r\n        font-size: 14px;\r\n    }\r\n\r\n    .collection-method:not(.first-collection-method) {\r\n        margin-top: 50px;\r\n    }\r\n</style>\r\n\r\n<a name=\"method-all\"></a>\r\n#### `all()`\r\n\r\n`all` 方法返回由集合表示的底层数组：\r\n\r\n    collect([1, 2, 3])->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n<a name=\"method-average\"></a>\r\n#### `average()` \r\n\r\n[`avg`](#method-avg) 方法的别名。\r\n\r\n<a name=\"method-avg\"></a>\r\n#### `avg()` \r\n\r\n`avg` 方法返回给定键的 [平均值](https://en.wikipedia.org/wiki/Average)：\r\n\r\n    $average = collect([\r\n        ['foo' => 10],\r\n        ['foo' => 10],\r\n        ['foo' => 20],\r\n        ['foo' => 40]\r\n    ])->avg('foo');\r\n\r\n    // 20\r\n\r\n    $average = collect([1, 1, 2, 4])->avg();\r\n\r\n    // 2\r\n\r\n<a name=\"method-chunk\"></a>\r\n#### `chunk()`\r\n\r\n`chunk` 方法将集合分成多个给定大小的较小集合：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7]);\r\n\r\n    $chunks = $collection->chunk(4);\r\n\r\n    $chunks->all();\r\n\r\n    // [[1, 2, 3, 4], [5, 6, 7]]\r\n\r\n当使用诸如 [Bootstrap](https://getbootstrap.com/docs/4.1/layout/grid/) 之类的网格系统时，此方法在 [views](/docs/laravel/9.x/views) 中特别有用 . 例如，假设您有一组 [Eloquent](/docs/laravel/9.x/eloquent) 模型要在网格中显示：\r\n\r\n```blade\r\n@foreach ($products->chunk(3) as $chunk)\r\n    <div class=\"row\">\r\n        @foreach ($chunk as $product)\r\n            <div class=\"col-xs-4\">{{ $product->name }}</div>\r\n        @endforeach\r\n    </div>\r\n@endforeach\r\n```\r\n\r\n<a name=\"method-chunkwhile\"></a>\r\n#### `chunkWhile()` \r\n\r\n`chunkWhile` 方法根据给定回调的评估将集合分成多个更小的集合。 传递给闭包的 `$chunk` 变量可用于检查前一个元素：\r\n\r\n    $collection = collect(str_split('AABBCCCD'));\r\n\r\n    $chunks = $collection->chunkWhile(function ($value, $key, $chunk) {\r\n        return $value === $chunk->last();\r\n    });\r\n\r\n    $chunks->all();\r\n\r\n    // [['A', 'A'], ['B', 'B'], ['C', 'C', 'C'], ['D']]\r\n\r\n<a name=\"method-collapse\"></a>\r\n#### `collapse()` {.collection-method}\r\n\r\n\r\n\r\n`collapse` 方法将数组集合折叠成一个单一的平面集合：\r\n\r\n    $collection = collect([\r\n        [1, 2, 3],\r\n        [4, 5, 6],\r\n        [7, 8, 9],\r\n    ]);\r\n\r\n    $collapsed = $collection->collapse();\r\n\r\n    $collapsed->all();\r\n\r\n    // [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\r\n<a name=\"method-collect\"></a>\r\n#### `collect()` {.collection-method}\r\n\r\n`collect` 方法返回一个新的 `Collection` 实例，其中包含当前集合中的项目：\r\n\r\n    $collectionA = collect([1, 2, 3]);\r\n\r\n    $collectionB = $collectionA->collect();\r\n\r\n    $collectionB->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n`collect` 方法主要用于将 [惰性集合](#lazy-collections) 转换为标准的 `Collection` 实例：\r\n\r\n    $lazyCollection = LazyCollection::make(function () {\r\n        yield 1;\r\n        yield 2;\r\n        yield 3;\r\n    });\r\n\r\n    $collection = $lazyCollection->collect();\r\n\r\n    get_class($collection);\r\n\r\n    // 'Illuminate\\Support\\Collection'\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n> 技巧：当你有一个 `Enumerable` 的实例并且需要一个非惰性集合实例时，`collect` 方法特别有用。 由于 `collect()` 是 `Enumerable` 合约的一部分，您可以安全地使用它来获取 `Collection` 实例。\r\n\r\n<a name=\"method-combine\"></a>\r\n#### `combine()` {.collection-method}\r\n\r\n`combine` 方法将集合的值作为键与另一个数组或集合的值组合：\r\n\r\n    $collection = collect(['name', 'age']);\r\n\r\n    $combined = $collection->combine(['George', 29]);\r\n\r\n    $combined->all();\r\n\r\n    // ['name' => 'George', 'age' => 29]\r\n\r\n<a name=\"method-concat\"></a>\r\n#### `concat()` {.collection-method}\r\n\r\n`concat` 方法将给定的 `array` 或集合的值附加到另一个集合的末尾：\r\n\r\n    $collection = collect(['John Doe']);\r\n\r\n    $concatenated = $collection->concat(['Jane Doe'])->concat(['name' => 'Johnny Doe']);\r\n\r\n    $concatenated->all();\r\n\r\n    // ['John Doe', 'Jane Doe', 'Johnny Doe']\r\n\r\n`concat` 方法在数字上重新索引连接到原始集合上的项目的键。 要维护关联集合中的键，请参阅 [merge](#method-merge) 方法。\r\n\r\n<a name=\"method-contains\"></a>\r\n#### `contains()` {.collection-method}\r\n\r\n`contains` 方法确定集合是否包含给定项目。 您可以将闭包传递给 `contains` 方法，以确定集合中是否存在与给定真值测试匹配的元素：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->contains(function ($value, $key) {\r\n        return $value > 5;\r\n    });\r\n\r\n    // false\r\n\r\n\r\n\r\n或者，您可以将字符串传递给 `contains` 方法，以确定集合是否包含给定的项目值：\r\n\r\n    $collection = collect(['name' => 'Desk', 'price' => 100]);\r\n\r\n    $collection->contains('Desk');\r\n\r\n    // true\r\n\r\n    $collection->contains('New York');\r\n\r\n    // false\r\n\r\n您还可以将键/值对传递给 `contains` 方法，该方法将确定给定对是否存在于集合中：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n    ]);\r\n\r\n    $collection->contains('product', 'Bookcase');\r\n\r\n    // false\r\n\r\n`contains` 方法在检查项目值时使用“松散”比较，这意味着具有整数值的字符串将被视为等于具有相同值的整数。 使用 [`containsStrict`](#method-containsstrict) 方法使用“严格”比较进行过滤。\r\n\r\n对于 `contains` 的逆操作，请参见 [doesntContain](#method-doesntcontain) 方法。\r\n\r\n<a name=\"method-containsstrict\"></a>\r\n#### `containsStrict()` {.collection-method}\r\n\r\n此方法与 [`contains`](#method-contains) 方法具有相同的签名； 但是，所有值都使用“严格”比较进行比较。\r\n\r\n> 技巧：使用 [Eloquent Collections](/docs/laravel/9.x/eloquent-collections#method-contains) 时会修改此方法的行为。\r\n\r\n<a name=\"method-count\"></a>\r\n#### `count()` {.collection-method}\r\n\r\n`count` 方法返回集合中的项目总数：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $collection->count();\r\n\r\n    // 4\r\n\r\n<a name=\"method-countBy\"></a>\r\n#### `countBy()` {.collection-method}\r\n\r\n`countBy` 方法计算集合中值的出现次数。 默认情况下，该方法计算每个元素的出现次数，允许您计算集合中元素的某些“类型”：\r\n\r\n    $collection = collect([1, 2, 2, 2, 3]);\r\n\r\n    $counted = $collection->countBy();\r\n\r\n    $counted->all();\r\n\r\n    // [1 => 1, 2 => 3, 3 => 1]\r\n\r\n您将闭包传递给 `countBy` 方法以按自定义值计算所有项目：\r\n\r\n    $collection = collect(['alice@gmail.com', 'bob@yahoo.com', 'carlos@gmail.com']);\r\n\r\n    $counted = $collection->countBy(function ($email) {\r\n        return substr(strrchr($email, \"@\"), 1);\r\n    });\r\n\r\n    $counted->all();\r\n\r\n    // ['gmail.com' => 2, 'yahoo.com' => 1]\r\n\r\n\r\n\r\n<a name=\"method-crossjoin\"></a>\r\n#### `crossJoin()` {.collection-method}\r\n\r\n`crossJoin` 方法在给定的数组或集合中交叉连接集合的值，返回具有所有可能排列的笛卡尔积：\r\n\r\n    $collection = collect([1, 2]);\r\n\r\n    $matrix = $collection->crossJoin(['a', 'b']);\r\n\r\n    $matrix->all();\r\n\r\n    /*\r\n        [\r\n            [1, 'a'],\r\n            [1, 'b'],\r\n            [2, 'a'],\r\n            [2, 'b'],\r\n        ]\r\n    */\r\n\r\n    $collection = collect([1, 2]);\r\n\r\n    $matrix = $collection->crossJoin(['a', 'b'], ['I', 'II']);\r\n\r\n    $matrix->all();\r\n\r\n    /*\r\n        [\r\n            [1, 'a', 'I'],\r\n            [1, 'a', 'II'],\r\n            [1, 'b', 'I'],\r\n            [1, 'b', 'II'],\r\n            [2, 'a', 'I'],\r\n            [2, 'a', 'II'],\r\n            [2, 'b', 'I'],\r\n            [2, 'b', 'II'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-dd\"></a>\r\n#### `dd()` {.collection-method}\r\n\r\n`dd` 方法转储集合的项目并结束脚本的执行：\r\n\r\n    $collection = collect(['John Doe', 'Jane Doe']);\r\n\r\n    $collection->dd();\r\n\r\n    /*\r\n        Collection {\r\n            #items: array:2 [\r\n                0 => \"John Doe\"\r\n                1 => \"Jane Doe\"\r\n            ]\r\n        }\r\n    */\r\n\r\n如果您不想停止执行脚本，请改用 [`dump`](#method-dump) 方法。\r\n\r\n<a name=\"method-diff\"></a>\r\n#### `diff()` {.collection-method}\r\n\r\n`diff` 方法根据集合的值将集合与另一个集合或普通 PHP `array` 进行比较。 此方法将返回给定集合中不存在的原始集合中的值：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $diff = $collection->diff([2, 4, 6, 8]);\r\n\r\n    $diff->all();\r\n\r\n    // [1, 3, 5]\r\n\r\n> 技巧：此方法的行为在使用 [Eloquent Collections](/docs/laravel/9.x/eloquent-collections#method-diff) 时被修改。\r\n\r\n<a name=\"method-diffassoc\"></a>\r\n#### `diffAssoc()` {.collection-method}\r\n\r\n`diffAssoc` 方法根据其键和值将集合与另一个集合或普通 PHP `array` 进行比较。 此方法将返回给定集合中不存在的原始集合中的键/值对：\r\n\r\n    $collection = collect([\r\n        'color' => 'orange',\r\n        'type' => 'fruit',\r\n        'remain' => 6,\r\n    ]);\r\n\r\n    $diff = $collection->diffAssoc([\r\n        'color' => 'yellow',\r\n        'type' => 'fruit',\r\n        'remain' => 3,\r\n        'used' => 6,\r\n    ]);\r\n\r\n    $diff->all();\r\n\r\n    // ['color' => 'orange', 'remain' => 6]\r\n\r\n<a name=\"method-diffkeys\"></a>\r\n\r\n\r\n#### `diffKeys()` {.collection-method}\r\n\r\n`diffKeys` 方法将集合与另一个集合或基于其键的普通 PHP `array` 进行比较。 此方法将返回给定集合中不存在的原始集合中的键/值对：\r\n\r\n    $collection = collect([\r\n        'one' => 10,\r\n        'two' => 20,\r\n        'three' => 30,\r\n        'four' => 40,\r\n        'five' => 50,\r\n    ]);\r\n\r\n    $diff = $collection->diffKeys([\r\n        'two' => 2,\r\n        'four' => 4,\r\n        'six' => 6,\r\n        'eight' => 8,\r\n    ]);\r\n\r\n    $diff->all();\r\n\r\n    // ['one' => 10, 'three' => 30, 'five' => 50]\r\n\r\n<a name=\"method-doesntcontain\"></a>\r\n#### `doesntContain()` {.collection-method}\r\n\r\n`doesntContain` 方法确定集合是否不包含给定项目。 您可以将闭包传递给 `doesntContain` 方法，以确定集合中是否不存在与给定真值测试匹配的元素：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->doesntContain(function ($value, $key) {\r\n        return $value < 5;\r\n    });\r\n\r\n    // false\r\n\r\n或者，您可以将字符串传递给 `doesntContain` 方法，以确定集合是否不包含给定的项目值：\r\n\r\n    $collection = collect(['name' => 'Desk', 'price' => 100]);\r\n\r\n    $collection->doesntContain('Table');\r\n\r\n    // true\r\n\r\n    $collection->doesntContain('Desk');\r\n\r\n    // false\r\n\r\n您还可以将键/值对传递给 `doesntContain` 方法，该方法将确定给定对是否不存在于集合中：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n    ]);\r\n\r\n    $collection->doesntContain('product', 'Bookcase');\r\n\r\n    // true\r\n\r\n`doesntContain` 方法在检查项目值时使用“松散”比较，这意味着具有整数值的字符串将被视为等于具有相同值的整数。\r\n\r\n<a name=\"method-dump\"></a>\r\n#### `dump()` {.collection-method}\r\n\r\n`dump` 方法转储集合的项目：\r\n\r\n    $collection = collect(['John Doe', 'Jane Doe']);\r\n\r\n    $collection->dump();\r\n\r\n    /*\r\n        Collection {\r\n            #items: array:2 [\r\n                0 => \"John Doe\"\r\n                1 => \"Jane Doe\"\r\n            ]\r\n        }\r\n    */\r\n\r\n如果要在转储集合后停止执行脚本，请改用 [`dd`](#method-dd) 方法。\r\n\r\n\r\n\r\n<a name=\"method-duplicates\"></a>\r\n#### `duplicates()` {.collection-method}\r\n\r\n`duplicates` 方法从集合中检索并返回重复值：\r\n\r\n    $collection = collect(['a', 'b', 'a', 'c', 'b']);\r\n\r\n    $collection->duplicates();\r\n\r\n    // [2 => 'a', 4 => 'b']\r\n\r\n如果集合包含数组或对象，您可以传递要检查重复值的属性的键：\r\n\r\n    $employees = collect([\r\n        ['email' => 'abigail@example.com', 'position' => 'Developer'],\r\n        ['email' => 'james@example.com', 'position' => 'Designer'],\r\n        ['email' => 'victoria@example.com', 'position' => 'Developer'],\r\n    ]);\r\n\r\n    $employees->duplicates('position');\r\n\r\n    // [2 => 'Developer']\r\n\r\n<a name=\"method-duplicatesstrict\"></a>\r\n#### `duplicatesStrict()` {.collection-method}\r\n\r\n此方法与 [`duplicates`](#method-duplicates) 方法具有相同的签名； 但是，所有值都使用“严格”比较进行比较。\r\n\r\n<a name=\"method-each\"></a>\r\n#### `each()` {.collection-method}\r\n\r\n`each` 方法遍历集合中的项目并将每个项目传递给闭包：\r\n\r\n    $collection->each(function ($item, $key) {\r\n        //\r\n    });\r\n\r\n如果你想停止遍历这些项目，你可以从你的闭包中返回 `false`：\r\n\r\n    $collection->each(function ($item, $key) {\r\n        if (/* condition */) {\r\n            return false;\r\n        }\r\n    });\r\n\r\n<a name=\"method-eachspread\"></a>\r\n#### `eachSpread()` {.collection-method}\r\n\r\n`eachSpread` 方法迭代集合的项目，将每个嵌套项目值传递给给定的回调：\r\n\r\n    $collection = collect([['John Doe', 35], ['Jane Doe', 33]]);\r\n\r\n    $collection->eachSpread(function ($name, $age) {\r\n        //\r\n    });\r\n\r\n您可以通过从回调中返回 `false` 来停止遍历项目：\r\n\r\n    $collection->eachSpread(function ($name, $age) {\r\n        return false;\r\n    });\r\n\r\n<a name=\"method-every\"></a>\r\n#### `every()` {.collection-method}\r\n\r\n`every` 方法可用于验证集合的所有元素是否通过给定的真值测试：\r\n\r\n    collect([1, 2, 3, 4])->every(function ($value, $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    // false\r\n\r\n如果集合为空，`every` 方法将返回 true：\r\n\r\n    $collection = collect([]);\r\n\r\n    $collection->every(function ($value, $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    // true\r\n\r\n\r\n\r\n<a name=\"method-except\"></a>\r\n#### `except()` {.collection-method}\r\n\r\n`except` 方法返回集合中的所有项目，除了具有指定键的项目：\r\n\r\n    $collection = collect(['product_id' => 1, 'price' => 100, 'discount' => false]);\r\n\r\n    $filtered = $collection->except(['price', 'discount']);\r\n\r\n    $filtered->all();\r\n\r\n    // ['product_id' => 1]\r\n\r\n对于 `except` 的反义词，请参见 [only](#method-only) 方法。\r\n\r\n> 技巧：此方法的行为在使用 [Eloquent Collections](/docs/laravel/9.x/eloquent-collections#method-except) 时被修改。\r\n\r\n<a name=\"method-filter\"></a>\r\n#### `filter()` {.collection-method}\r\n\r\n`filter` 方法使用给定的回调过滤集合，只保留那些通过给定真值测试的项目：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $filtered = $collection->filter(function ($value, $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    $filtered->all();\r\n\r\n    // [3, 4]\r\n\r\n如果没有提供回调，则集合中所有相当于 `false` 的条目都将被删除：\r\n\r\n    $collection = collect([1, 2, 3, null, false, '', 0, []]);\r\n\r\n    $collection->filter()->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n对于 `filter` 的逆操作，请参见 [reject](#method-reject) 方法。\r\n\r\n<a name=\"method-first\"></a>\r\n#### `first()` {.collection-method}\r\n\r\n`first` 方法返回集合中通过给定真值测试的第一个元素：\r\n\r\n    collect([1, 2, 3, 4])->first(function ($value, $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    // 3\r\n\r\n你也可以调用不带参数的 `first` 方法来获取集合中的第一个元素。 如果集合为空，则返回 `null`：\r\n\r\n    collect([1, 2, 3, 4])->first();\r\n\r\n    // 1\r\n\r\n<a name=\"method-first-where\"></a>\r\n#### `firstWhere()` {.collection-method}\r\n\r\n`firstWhere` 方法返回集合中具有给定键/值对的第一个元素：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Regena', 'age' => null],\r\n        ['name' => 'Linda', 'age' => 14],\r\n        ['name' => 'Diego', 'age' => 23],\r\n        ['name' => 'Linda', 'age' => 84],\r\n    ]);\r\n\r\n    $collection->firstWhere('name', 'Linda');\r\n\r\n    // ['name' => 'Linda', 'age' => 14]\r\n\r\n您还可以使用比较运算符调用 `firstWhere` 方法：\r\n\r\n    $collection->firstWhere('age', '>=', 18);\r\n\r\n    // ['name' => 'Diego', 'age' => 23]\r\n\r\n\r\n\r\n与 [where](#method-where) 方法一样，您可以将一个参数传递给 `firstWhere` 方法。 在这种情况下，`firstWhere` 方法将返回给定项目键值为“真”的第一个项目：\r\n\r\n    $collection->firstWhere('age');\r\n\r\n    // ['name' => 'Linda', 'age' => 14]\r\n\r\n<a name=\"method-flatmap\"></a>\r\n#### `flatMap()` {.collection-method}\r\n\r\n`flatMap` 方法遍历集合并将每个值传递给给定的闭包。 闭包可以自由修改项目并将其返回，从而形成一个新的修改项目集合。 然后，数组被展平一层：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Sally'],\r\n        ['school' => 'Arkansas'],\r\n        ['age' => 28]\r\n    ]);\r\n\r\n    $flattened = $collection->flatMap(function ($values) {\r\n        return array_map('strtoupper', $values);\r\n    });\r\n\r\n    $flattened->all();\r\n\r\n    // ['name' => 'SALLY', 'school' => 'ARKANSAS', 'age' => '28'];\r\n\r\n<a name=\"method-flatten\"></a>\r\n#### `flatten()` {.collection-method}\r\n\r\n`flatten` 方法将多维集合展平为一维：\r\n\r\n    $collection = collect([\r\n        'name' => 'taylor',\r\n        'languages' => [\r\n            'php', 'javascript'\r\n        ]\r\n    ]);\r\n\r\n    $flattened = $collection->flatten();\r\n\r\n    $flattened->all();\r\n\r\n    // ['taylor', 'php', 'javascript'];\r\n\r\n如有必要，您可以向 `flatten` 方法传递一个“深度”参数：\r\n\r\n    $collection = collect([\r\n        'Apple' => [\r\n            [\r\n                'name' => 'iPhone 6S',\r\n                'brand' => 'Apple'\r\n            ],\r\n        ],\r\n        'Samsung' => [\r\n            [\r\n                'name' => 'Galaxy S7',\r\n                'brand' => 'Samsung'\r\n            ],\r\n        ],\r\n    ]);\r\n\r\n    $products = $collection->flatten(1);\r\n\r\n    $products->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'iPhone 6S', 'brand' => 'Apple'],\r\n            ['name' => 'Galaxy S7', 'brand' => 'Samsung'],\r\n        ]\r\n    */\r\n\r\n在此示例中，调用 `flatten` 而不提供深度也会使嵌套数组变平，从而导致 `['iPhone 6S', 'Apple', 'Galaxy S7', 'Samsung']`。 提供深度允许您指定嵌套数组将被展平的级别数。\r\n\r\n<a name=\"method-flip\"></a>\r\n#### `flip()` {.collection-method}\r\n\r\n`flip` 方法将集合的键与其对应的值交换：\r\n\r\n    $collection = collect(['name' => 'taylor', 'framework' => 'laravel']);\r\n\r\n    $flipped = $collection->flip();\r\n\r\n    $flipped->all();\r\n\r\n    // ['taylor' => 'name', 'laravel' => 'framework']\r\n\r\n\r\n\r\n<a name=\"method-forget\"></a>\r\n#### `forget()` \r\n\r\n该 `forget` 方法将通过指定的键来移除集合中对应的元素：\r\n\r\n    $collection = collect(['name' => 'taylor', 'framework' => 'laravel']);\r\n\r\n    $collection->forget('name');\r\n\r\n    $collection->all();\r\n\r\n    // ['framework' => 'laravel']\r\n\r\n> 注意：与大多数集合的方法不同的是， `forget` 不会返回修改后的新集合；它会直接修改原集合。\r\n\r\n<a name=\"method-forpage\"></a>\r\n#### `forPage()`\r\n\r\n该 `forPage` 方法返回一个含有指定页码数集合项的新集合。这个方法接受页码数作为其第一个参数，每页显示的项数作为其第二个参数：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n\r\n    $chunk = $collection->forPage(2, 3);\r\n\r\n    $chunk->all();\r\n\r\n    // [4, 5, 6]\r\n\r\n<a name=\"method-get\"></a>\r\n#### `get()`\r\n\r\n该 `get` 方法返回指定键的集合项，如果该键在集合中不存在，则返回 null：\r\n\r\n    $collection = collect(['name' => 'taylor', 'framework' => 'laravel']);\r\n\r\n    $value = $collection->get('name');\r\n\r\n    // taylor\r\n\r\n你可以任选一个默认值作为第二个参数传递：\r\n\r\n    $collection = collect(['name' => 'taylor', 'framework' => 'laravel']);\r\n\r\n    $value = $collection->get('age', 34);\r\n\r\n    // 34\r\n\r\n你甚至可以将一个回调函数作为默认值传递。如果指定的键不存在，就会返回回调函数的结果：\r\n\r\n    $collection->get('email', function () {\r\n        return 'taylor@example.com';\r\n    });\r\n\r\n    // taylor@example.com\r\n\r\n<a name=\"method-groupby\"></a>\r\n#### `groupBy()`\r\n\r\n该 `groupBy` 方法根据指定键对集合项进行分组：\r\n\r\n    $collection = collect([\r\n        ['account_id' => 'account-x10', 'product' => 'Chair'],\r\n        ['account_id' => 'account-x10', 'product' => 'Bookcase'],\r\n        ['account_id' => 'account-x11', 'product' => 'Desk'],\r\n    ]);\r\n\r\n    $grouped = $collection->groupBy('account_id');\r\n\r\n    $grouped->all();\r\n\r\n    /*\r\n        [\r\n            'account-x10' => [\r\n                ['account_id' => 'account-x10', 'product' => 'Chair'],\r\n                ['account_id' => 'account-x10', 'product' => 'Bookcase'],\r\n            ],\r\n            'account-x11' => [\r\n                ['account_id' => 'account-x11', 'product' => 'Desk'],\r\n            ],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n您可以传递回调，而不是传递字符串 `key`。 回调应返回您希望通过以下方式键入组的值：\r\n\r\n    $grouped = $collection->groupBy(function ($item, $key) {\r\n        return substr($item['account_id'], -3);\r\n    });\r\n\r\n    $grouped->all();\r\n\r\n    /*\r\n        [\r\n            'x10' => [\r\n                ['account_id' => 'account-x10', 'product' => 'Chair'],\r\n                ['account_id' => 'account-x10', 'product' => 'Bookcase'],\r\n            ],\r\n            'x11' => [\r\n                ['account_id' => 'account-x11', 'product' => 'Desk'],\r\n            ],\r\n        ]\r\n    */\r\n\r\n多个分组标准可以作为数组传递。 每个数组元素将应用于多维数组中的相应级别：\r\n\r\n    $data = new Collection([\r\n        10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],\r\n        20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],\r\n        30 => ['user' => 3, 'skill' => 2, 'roles' => ['Role_1']],\r\n        40 => ['user' => 4, 'skill' => 2, 'roles' => ['Role_2']],\r\n    ]);\r\n\r\n    $result = $data->groupBy(['skill', function ($item) {\r\n        return $item['roles'];\r\n    }], $preserveKeys = true);\r\n\r\n    /*\r\n    [\r\n        1 => [\r\n            'Role_1' => [\r\n                10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],\r\n                20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],\r\n            ],\r\n            'Role_2' => [\r\n                20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],\r\n            ],\r\n            'Role_3' => [\r\n                10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],\r\n            ],\r\n        ],\r\n        2 => [\r\n            'Role_1' => [\r\n                30 => ['user' => 3, 'skill' => 2, 'roles' => ['Role_1']],\r\n            ],\r\n            'Role_2' => [\r\n                40 => ['user' => 4, 'skill' => 2, 'roles' => ['Role_2']],\r\n            ],\r\n        ],\r\n    ];\r\n    */\r\n\r\n<a name=\"method-has\"></a>\r\n#### `has()` {.collection-method}\r\n\r\n`has` 方法确定集合中是否存在给定键：\r\n\r\n    $collection = collect(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]);\r\n\r\n    $collection->has('product');\r\n\r\n    // true\r\n\r\n    $collection->has(['product', 'amount']);\r\n\r\n    // true\r\n\r\n    $collection->has(['amount', 'price']);\r\n\r\n    // false\r\n\r\n<a name=\"method-implode\"></a>\r\n#### `implode()` {.collection-method}\r\n\r\n`implode` 方法连接集合中的项目。 它的参数取决于集合中项目的类型。 如果集合包含数组或对象，您应该传递您希望加入的属性的键，以及您希望放置在值之间的“胶水”字符串：\r\n\r\n    $collection = collect([\r\n        ['account_id' => 1, 'product' => 'Desk'],\r\n        ['account_id' => 2, 'product' => 'Chair'],\r\n    ]);\r\n\r\n    $collection->implode('product', ', ');\r\n\r\n    // Desk, Chair\r\n\r\n\r\n\r\n如果集合包含简单的字符串或数值，则应将“胶水”作为唯一参数传递给该方法：\r\n\r\n    collect([1, 2, 3, 4, 5])->implode('-');\r\n\r\n    // '1-2-3-4-5'\r\n\r\n<a name=\"method-intersect\"></a>\r\n#### `intersect()` {.collection-method}\r\n\r\n`intersect` 方法从原始集合中删除任何不存在于给定 `array` 或集合中的值。 生成的集合将保留原始集合的键：\r\n\r\n    $collection = collect(['Desk', 'Sofa', 'Chair']);\r\n\r\n    $intersect = $collection->intersect(['Desk', 'Chair', 'Bookcase']);\r\n\r\n    $intersect->all();\r\n\r\n    // [0 => 'Desk', 2 => 'Chair']\r\n\r\n> 技巧：使用 [Eloquent Collections](/docs/laravel/9.x/eloquent-collections#method-intersect) 时会修改此方法的行为。\r\n\r\n<a name=\"method-intersectbykeys\"></a>\r\n#### `intersectByKeys()` {.collection-method}\r\n\r\n`intersectByKeys` 方法从原始集合中删除给定 `array` 或集合中不存在的任何键及其对应值：\r\n\r\n    $collection = collect([\r\n        'serial' => 'UX301', 'type' => 'screen', 'year' => 2009,\r\n    ]);\r\n\r\n    $intersect = $collection->intersectByKeys([\r\n        'reference' => 'UX404', 'type' => 'tab', 'year' => 2011,\r\n    ]);\r\n\r\n    $intersect->all();\r\n\r\n    // ['type' => 'screen', 'year' => 2009]\r\n\r\n<a name=\"method-isempty\"></a>\r\n#### `isEmpty()` {.collection-method}\r\n\r\n如果集合为空，`isEmpty` 方法返回 `true`； 否则，返回 `false`：\r\n\r\n    collect([])->isEmpty();\r\n\r\n    // true\r\n\r\n<a name=\"method-isnotempty\"></a>\r\n#### `isNotEmpty()` {.collection-method}\r\n\r\n如果集合不为空，`isNotEmpty` 方法返回 `true`； 否则，返回 `false`：\r\n\r\n    collect([])->isNotEmpty();\r\n\r\n    // false\r\n\r\n<a name=\"method-join\"></a>\r\n#### `join()` {.collection-method}\r\n\r\n`join` 方法将集合的值与字符串连接起来。 使用此方法的第二个参数，您还可以指定最终元素应如何附加到字符串：\r\n\r\n    collect(['a', 'b', 'c'])->join(', '); // 'a, b, c'\r\n    collect(['a', 'b', 'c'])->join(', ', ', and '); // 'a, b, and c'\r\n    collect(['a', 'b'])->join(', ', ' and '); // 'a and b'\r\n    collect(['a'])->join(', ', ' and '); // 'a'\r\n    collect([])->join(', ', ' and '); // ''\r\n\r\n\r\n\r\n<a name=\"method-keyby\"></a>\r\n#### `keyBy()` {.collection-method}\r\n\r\n`keyBy` 方法通过给定键对集合进行键控。 如果多个项目具有相同的键，则只有最后一个会出现在新集合中：\r\n\r\n    $collection = collect([\r\n        ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n        ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n    ]);\r\n\r\n    $keyed = $collection->keyBy('product_id');\r\n\r\n    $keyed->all();\r\n\r\n    /*\r\n        [\r\n            'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n            'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n        ]\r\n    */\r\n\r\n您也可以将回调传递给该方法。 回调应通过以下方式返回值以作为集合的键：\r\n\r\n    $keyed = $collection->keyBy(function ($item) {\r\n        return strtoupper($item['product_id']);\r\n    });\r\n\r\n    $keyed->all();\r\n\r\n    /*\r\n        [\r\n            'PROD-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n            'PROD-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-keys\"></a>\r\n#### `keys()` {.collection-method}\r\n\r\n`keys` 方法返回集合的所有键：\r\n\r\n    $collection = collect([\r\n        'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n        'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n    ]);\r\n\r\n    $keys = $collection->keys();\r\n\r\n    $keys->all();\r\n\r\n    // ['prod-100', 'prod-200']\r\n\r\n<a name=\"method-last\"></a>\r\n#### `last()` {.collection-method}\r\n\r\n`last` 方法返回集合中通过给定真值测试的最后一个元素：\r\n\r\n    collect([1, 2, 3, 4])->last(function ($value, $key) {\r\n        return $value < 3;\r\n    });\r\n\r\n    // 2\r\n\r\n你也可以调用不带参数的`last`方法来获取集合中的最后一个元素。 如果集合为空，则返回 `null`：\r\n\r\n    collect([1, 2, 3, 4])->last();\r\n\r\n    // 4\r\n\r\n<a name=\"method-macro\"></a>\r\n#### `macro()` {.collection-method}\r\n\r\n静态`macro()`方法允许您在运行时向“集合”类添加方法。 有关详细信息，请参阅有关 [扩展集合](#extending-collections) 的文档。\r\n\r\n\r\n\r\n<a name=\"method-make\"></a>\r\n#### `make()`\r\n\r\n静态 `make` 方法可以创建一个新的集合实例。请参照 [创建集合](#creating-collections) 部分。\r\n\r\n<a name=\"method-map\"></a>\r\n#### `map()`\r\n\r\n该 `map` 方法遍历集合并将每一个值传入给定的回调函数。该回调函数可以任意修改集合项并返回，从而生成被修改过集合项的新集合：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $multiplied = $collection->map(function ($item, $key) {\r\n        return $item * 2;\r\n    });\r\n\r\n    $multiplied->all();\r\n\r\n    // [2, 4, 6, 8, 10]\r\n\r\n> 注意：与其他大多数集合方法一样， `map` 会返回一个新的集合实例；它不会修改原集合。如果你想修改原集合，请使用 [`transform`](#method-transform) 方法。\r\n\r\n<a name=\"method-mapinto\"></a>\r\n#### `mapInto()`\r\n\r\n该 `mapInto()` 方法可以迭代集合，通过将值传递给构造函数来创建给定类的新实例：\r\n\r\n    class Currency\r\n    {\r\n        /**\r\n         * Create a new currency instance.\r\n         *\r\n         * @param  string  $code\r\n         * @return void\r\n         */\r\n        function __construct(string $code)\r\n        {\r\n            $this->code = $code;\r\n        }\r\n    }\r\n\r\n    $collection = collect(['USD', 'EUR', 'GBP']);\r\n\r\n    $currencies = $collection->mapInto(Currency::class);\r\n\r\n    $currencies->all();\r\n\r\n    // [Currency('USD'), Currency('EUR'), Currency('GBP')]\r\n\r\n<a name=\"method-mapspread\"></a>\r\n#### `mapSpread()`\r\n\r\n该 `mapSpread` 方法可以迭代集合，将每个嵌套项值给指定的回调函数。该回调函数可以自由修改该集合项并返回，从而生成被修改过集合项的新集合：\r\n\r\n    $collection = collect([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n\r\n    $chunks = $collection->chunk(2);\r\n\r\n    $sequence = $chunks->mapSpread(function ($even, $odd) {\r\n        return $even + $odd;\r\n    });\r\n\r\n    $sequence->all();\r\n\r\n    // [1, 5, 9, 13, 17]\r\n\r\n<a name=\"method-maptogroups\"></a>\r\n#### `mapToGroups()`\r\n\r\n该 `mapToGroups` 方法通过给定的回调函数对集合项进行分组。该回调函数应该返回一个包含单个键 / 值对的关联数组，从而生成一个分组值的新集合：\r\n\r\n    $collection = collect([\r\n        [\r\n            'name' => 'John Doe',\r\n            'department' => 'Sales',\r\n        ],\r\n        [\r\n            'name' => 'Jane Doe',\r\n            'department' => 'Sales',\r\n        ],\r\n        [\r\n            'name' => 'Johnny Doe',\r\n            'department' => 'Marketing',\r\n        ]\r\n    ]);\r\n\r\n    $grouped = $collection->mapToGroups(function ($item, $key) {\r\n        return [$item['department'] => $item['name']];\r\n    });\r\n\r\n    $grouped->all();\r\n\r\n    /*\r\n        [\r\n            'Sales' => ['John Doe', 'Jane Doe'],\r\n            'Marketing' => ['Johnny Doe'],\r\n        ]\r\n    */\r\n\r\n    $grouped->get('Sales')->all();\r\n\r\n    // ['John Doe', 'Jane Doe']\r\n\r\n\r\n\r\n<a name=\"method-mapwithkeys\"></a>\r\n#### `mapWithKeys()` {.collection-method}\r\n\r\n`mapWithKeys` 方法遍历集合并将每个值传递给给定的回调。 回调应返回包含单个键/值对的关联数组：\r\n\r\n    $collection = collect([\r\n        [\r\n            'name' => 'John',\r\n            'department' => 'Sales',\r\n            'email' => 'john@example.com',\r\n        ],\r\n        [\r\n            'name' => 'Jane',\r\n            'department' => 'Marketing',\r\n            'email' => 'jane@example.com',\r\n        ]\r\n    ]);\r\n\r\n    $keyed = $collection->mapWithKeys(function ($item, $key) {\r\n        return [$item['email'] => $item['name']];\r\n    });\r\n\r\n    $keyed->all();\r\n\r\n    /*\r\n        [\r\n            'john@example.com' => 'John',\r\n            'jane@example.com' => 'Jane',\r\n        ]\r\n    */\r\n\r\n<a name=\"method-max\"></a>\r\n#### `max()` {.collection-method}\r\n\r\n`max` 方法返回给定键的最大值：\r\n\r\n    $max = collect([\r\n        ['foo' => 10],\r\n        ['foo' => 20]\r\n    ])->max('foo');\r\n\r\n    // 20\r\n\r\n    $max = collect([1, 2, 3, 4, 5])->max();\r\n\r\n    // 5\r\n\r\n<a name=\"method-median\"></a>\r\n#### `median()` {.collection-method}\r\n\r\n`median` 方法返回给定键的 [中值](https://en.wikipedia.org/wiki/Median)：\r\n\r\n    $median = collect([\r\n        ['foo' => 10],\r\n        ['foo' => 10],\r\n        ['foo' => 20],\r\n        ['foo' => 40]\r\n    ])->median('foo');\r\n\r\n    // 15\r\n\r\n    $median = collect([1, 1, 2, 4])->median();\r\n\r\n    // 1.5\r\n\r\n<a name=\"method-merge\"></a>\r\n#### `merge()` {.collection-method}\r\n\r\n`merge` 方法将给定的数组或集合与原始集合合并。 如果给定项目中的字符串键与原始集合中的字符串键匹配，则给定项目的值将覆盖原始集合中的值：\r\n\r\n    $collection = collect(['product_id' => 1, 'price' => 100]);\r\n\r\n    $merged = $collection->merge(['price' => 200, 'discount' => false]);\r\n\r\n    $merged->all();\r\n\r\n    // ['product_id' => 1, 'price' => 200, 'discount' => false]\r\n\r\n如果给定项目的键是数字，则值将附加到集合的末尾：\r\n\r\n    $collection = collect(['Desk', 'Chair']);\r\n\r\n    $merged = $collection->merge(['Bookcase', 'Door']);\r\n\r\n    $merged->all();\r\n\r\n    // ['Desk', 'Chair', 'Bookcase', 'Door']\r\n\r\n<a name=\"method-mergerecursive\"></a>\r\n#### `mergeRecursive()` {.collection-method}\r\n\r\n`mergeRecursive` 方法将给定的数组或集合递归地与原始集合合并。 如果给定项目中的字符串键与原始集合中的字符串键匹配，则这些键的值将合并到一个数组中，这是递归完成的：\r\n\r\n    $collection = collect(['product_id' => 1, 'price' => 100]);\r\n\r\n    $merged = $collection->mergeRecursive([\r\n        'product_id' => 2,\r\n        'price' => 200,\r\n        'discount' => false\r\n    ]);\r\n\r\n    $merged->all();\r\n\r\n    // ['product_id' => [1, 2], 'price' => [100, 200], 'discount' => false]\r\n\r\n\r\n\r\n<a name=\"method-min\"></a>\r\n#### `min()` {.collection-method}\r\n\r\n`min` 方法返回给定键的最小值：\r\n\r\n    $min = collect([['foo' => 10], ['foo' => 20]])->min('foo');\r\n\r\n    // 10\r\n\r\n    $min = collect([1, 2, 3, 4, 5])->min();\r\n\r\n    // 1\r\n\r\n<a name=\"method-mode\"></a>\r\n#### `mode()` {.collection-method}\r\n\r\n`mode` 方法返回给定键的 [mode 值](https://en.wikipedia.org/wiki/Mode_(statistics))：\r\n\r\n    $mode = collect([\r\n        ['foo' => 10],\r\n        ['foo' => 10],\r\n        ['foo' => 20],\r\n        ['foo' => 40]\r\n    ])->mode('foo');\r\n\r\n    // [10]\r\n\r\n    $mode = collect([1, 1, 2, 4])->mode();\r\n\r\n    // [1]\r\n\r\n    $mode = collect([1, 1, 2, 2])->mode();\r\n\r\n    // [1, 2]\r\n\r\n<a name=\"method-nth\"></a>\r\n#### `nth()` {.collection-method}\r\n\r\n`nth` 方法创建一个由每个第 n 个元素组成的新集合：\r\n\r\n    $collection = collect(['a', 'b', 'c', 'd', 'e', 'f']);\r\n\r\n    $collection->nth(4);\r\n\r\n    // ['a', 'e']\r\n\r\n您可以选择将起始偏移量作为第二个参数传递：\r\n\r\n    $collection->nth(4, 1);\r\n\r\n    // ['b', 'f']\r\n\r\n<a name=\"method-only\"></a>\r\n#### `only()` {.collection-method}\r\n\r\n`only` 方法返回集合中具有指定键的项目：\r\n\r\n    $collection = collect([\r\n        'product_id' => 1,\r\n        'name' => 'Desk',\r\n        'price' => 100,\r\n        'discount' => false\r\n    ]);\r\n\r\n    $filtered = $collection->only(['product_id', 'name']);\r\n\r\n    $filtered->all();\r\n\r\n    // ['product_id' => 1, 'name' => 'Desk']\r\n\r\nFor the inverse of `only`, see the [except](#method-except) method.\r\n\r\n> 技巧：使用 [Eloquent Collections](/docs/laravel/9.x/eloquent-collections#method-only) 时会修改此方法的行为。\r\n\r\n<a name=\"method-pad\"></a>\r\n#### `pad()` {.collection-method}\r\n\r\n`pad` 方法将用给定的值填充数组，直到数组达到指定的大小。 此方法的行为类似于 [array_pad](https://secure.php.net/manual/en/function.array-pad.php) PHP 函数。\r\n\r\n要向左填充，您应该指定一个负尺寸。 如果给定大小的绝对值小于或等于数组的长度，则不会发生填充：\r\n\r\n    $collection = collect(['A', 'B', 'C']);\r\n\r\n    $filtered = $collection->pad(5, 0);\r\n\r\n    $filtered->all();\r\n\r\n    // ['A', 'B', 'C', 0, 0]\r\n\r\n    $filtered = $collection->pad(-5, 0);\r\n\r\n    $filtered->all();\r\n\r\n    // [0, 0, 'A', 'B', 'C']\r\n\r\n\r\n\r\n<a name=\"method-partition\"></a>\r\n#### `partition()`\r\n\r\n该 `partition` 方法可以与 PHP 数组解构相结合，以将通过给定真值测试的元素与未通过的元素分开：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6]);\r\n\r\n    [$underThree, $equalOrAboveThree] = $collection->partition(function ($i) {\r\n        return $i < 3;\r\n    });\r\n\r\n    $underThree->all();\r\n\r\n    // [1, 2]\r\n\r\n    $equalOrAboveThree->all();\r\n\r\n    // [3, 4, 5, 6]\r\n\r\n<a name=\"method-pipe\"></a>\r\n#### `pipe()`\r\n\r\n该 `pipe` 可以把集合放到回调参数中并返回回调的结果：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $piped = $collection->pipe(function ($collection) {\r\n        return $collection->sum();\r\n    });\r\n\r\n    // 6\r\n\r\n<a name=\"method-pipeinto\"></a>\r\n#### `pipeInto()`\r\n\r\n该 `pipeInto` 方法创建一个给定类的新实例，并将集合传递给构造函数：\r\n\r\n    class ResourceCollection\r\n    {\r\n        /**\r\n         * The Collection instance.\r\n         */\r\n        public $collection;\r\n\r\n        /**\r\n         * Create a new ResourceCollection instance.\r\n         *\r\n         * @param  Collection  $collection\r\n         * @return void\r\n         */\r\n        public function __construct(Collection $collection)\r\n        {\r\n            $this->collection = $collection;\r\n        }\r\n    }\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $resource = $collection->pipeInto(ResourceCollection::class);\r\n\r\n    $resource->collection->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n<a name=\"method-pipethrough\"></a>\r\n#### `pipeThrough()`\r\n\r\n该 `pipeThrough` 方法将集合传递给给定的闭包数组并返回执行的闭包的结果：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $result = $collection->pipeThrough([\r\n        function ($collection) {\r\n            return $collection->merge([4, 5]);\r\n        },\r\n        function ($collection) {\r\n            return $collection->sum();\r\n        },\r\n    ]);\r\n\r\n    // 15\r\n\r\n<a name=\"method-pluck\"></a>\r\n#### `pluck()`\r\n\r\n该 `pluck` 可以获取集合中指定键对应的所有值：\r\n\r\n    $collection = collect([\r\n        ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n        ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n    ]);\r\n\r\n    $plucked = $collection->pluck('name');\r\n\r\n    $plucked->all();\r\n\r\n    // ['Desk', 'Chair']\r\n\r\n你也可以通过传入第二个参数来指定生成集合的 key（键）：\r\n\r\n    $plucked = $collection->pluck('name', 'product_id');\r\n\r\n    $plucked->all();\r\n\r\n    // ['prod-100' => 'Desk', 'prod-200' => 'Chair']\r\n\r\n该 `pluck` 也支持利用「.」标记的方法取出多维数组的键值：\r\n\r\n    $collection = collect([\r\n        [\r\n            'speakers' => [\r\n                'first_day' => ['Rosa', 'Judith'],\r\n                'second_day' => ['Angela', 'Kathleen'],\r\n            ],\r\n        ],\r\n    ]);\r\n\r\n    $plucked = $collection->pluck('speakers.first_day');\r\n\r\n    $plucked->all();\r\n\r\n    // ['Rosa', 'Judith']\r\n\r\n\r\n\r\n如果存在重复键，则将最后一个匹配元素插入到 plucked 集合中：\r\n\r\n    $collection = collect([\r\n        ['brand' => 'Tesla',  'color' => 'red'],\r\n        ['brand' => 'Pagani', 'color' => 'white'],\r\n        ['brand' => 'Tesla',  'color' => 'black'],\r\n        ['brand' => 'Pagani', 'color' => 'orange'],\r\n    ]);\r\n\r\n    $plucked = $collection->pluck('color', 'brand');\r\n\r\n    $plucked->all();\r\n\r\n    // ['Tesla' => 'black', 'Pagani' => 'orange']\r\n\r\n<a name=\"method-pop\"></a>\r\n#### `pop()` {.collection-method}\r\n\r\n`pop` 方法删除并返回集合中的最后一项：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->pop();\r\n\r\n    // 5\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 4]\r\n\r\n您可以将整数传递给 `pop` 方法以从集合末尾删除并返回多个项目：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->pop(3);\r\n\r\n    // collect([5, 4, 3])\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2]\r\n\r\n<a name=\"method-prepend\"></a>\r\n#### `prepend()` {.collection-method}\r\n\r\n`prepend` 方法将一个项目添加到集合的开头：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->prepend(0);\r\n\r\n    $collection->all();\r\n\r\n    // [0, 1, 2, 3, 4, 5]\r\n\r\n您还可以传递第二个参数来指定前置项的键：\r\n\r\n    $collection = collect(['one' => 1, 'two' => 2]);\r\n\r\n    $collection->prepend(0, 'zero');\r\n\r\n    $collection->all();\r\n\r\n    // ['zero' => 0, 'one' => 1, 'two' => 2]\r\n\r\n<a name=\"method-pull\"></a>\r\n#### `pull()` {.collection-method}\r\n\r\n`pull` 方法通过它的键从集合中移除并返回一个项目：\r\n\r\n    $collection = collect(['product_id' => 'prod-100', 'name' => 'Desk']);\r\n\r\n    $collection->pull('name');\r\n\r\n    // 'Desk'\r\n\r\n    $collection->all();\r\n\r\n    // ['product_id' => 'prod-100']\r\n\r\n<a name=\"method-push\"></a>\r\n#### `push()` {.collection-method}\r\n\r\n`push` 方法将一个项目附加到集合的末尾：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $collection->push(5);\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 4, 5]\r\n\r\n<a name=\"method-put\"></a>\r\n#### `put()` {.collection-method}\r\n\r\n`put` 方法在集合中设置给定的键和值：\r\n\r\n    $collection = collect(['product_id' => 1, 'name' => 'Desk']);\r\n\r\n    $collection->put('price', 100);\r\n\r\n    $collection->all();\r\n\r\n    // ['product_id' => 1, 'name' => 'Desk', 'price' => 100]\r\n\r\n<a name=\"method-random\"></a>\r\n#### `random()` {.collection-method}\r\n\r\n`random` 方法从集合中返回一个随机项：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->random();\r\n\r\n    // 4 - (retrieved randomly)\r\n\r\n\r\n\r\n您可以将一个整数传递给“random”，以指定要随机检索的项目数。 当明确传递您希望接收的项目数时，始终返回项目集合：\r\n\r\n    $random = $collection->random(3);\r\n\r\n    $random->all();\r\n\r\n    // [2, 4, 5] - (retrieved randomly)\r\n\r\n如果集合实例的项目少于请求的项目，则 `random` 方法将抛出 `InvalidArgumentException`。\r\n\r\n<a name=\"method-range\"></a>\r\n#### `range()` {.collection-method}\r\n\r\n`range` 方法返回一个包含指定范围之间整数的集合：\r\n\r\n    $collection = collect()->range(3, 6);\r\n\r\n    $collection->all();\r\n\r\n    // [3, 4, 5, 6]\r\n\r\n<a name=\"method-reduce\"></a>\r\n#### `reduce()` {.collection-method}\r\n\r\n`reduce` 方法将集合减少为单个值，将每次迭代的结果传递给后续迭代：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $total = $collection->reduce(function ($carry, $item) {\r\n        return $carry + $item;\r\n    });\r\n\r\n    // 6\r\n\r\n`$carry` 在第一次迭代时的值为 `null`； 但是，您可以通过将第二个参数传递给 `reduce` 来指定其初始值：\r\n\r\n    $collection->reduce(function ($carry, $item) {\r\n        return $carry + $item;\r\n    }, 4);\r\n\r\n    // 10\r\n\r\n`reduce` 方法还将关联集合中的数组键传递给给定的回调：\r\n\r\n    $collection = collect([\r\n        'usd' => 1400,\r\n        'gbp' => 1200,\r\n        'eur' => 1000,\r\n    ]);\r\n\r\n    $ratio = [\r\n        'usd' => 1,\r\n        'gbp' => 1.37,\r\n        'eur' => 1.22,\r\n    ];\r\n\r\n    $collection->reduce(function ($carry, $value, $key) use ($ratio) {\r\n        return $carry + ($value * $ratio[$key]);\r\n    });\r\n\r\n    // 4264\r\n\r\n\r\n\r\n<a name=\"method-reduce-spread\"></a>\r\n#### `reduceSpread()` {.collection-method}\r\n\r\n`reduceSpread` 方法将集合缩减为一个值数组，将每次迭代的结果传递给后续迭代。 此方法类似于 `reduce` 方法； 但是，它可以接受多个初始值：\r\n\r\n    [$creditsRemaining, $batch] = Image::where('status', 'unprocessed')\r\n        ->get()\r\n        ->reduceSpread(function ($creditsRemaining, $batch, $image) {\r\n            if ($creditsRemaining >= $image->creditsRequired()) {\r\n                $batch->push($image);\r\n\r\n                $creditsRemaining -= $image->creditsRequired();\r\n            }\r\n\r\n            return [$creditsRemaining, $batch];\r\n        }, $creditsAvailable, collect());\r\n\r\n<a name=\"method-reject\"></a>\r\n#### `reject()` {.collection-method}\r\n\r\n`reject` 方法使用给定的闭包过滤集合。 如果应从结果集合中删除项目，则闭包应返回 `true`：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $filtered = $collection->reject(function ($value, $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    $filtered->all();\r\n\r\n    // [1, 2]\r\n\r\n对于 `reject` 方法的逆操作，请参见 [`filter`](#method-filter) 方法。\r\n\r\n<a name=\"method-replace\"></a>\r\n#### `replace()` {.collection-method}\r\n\r\n`replace` 方法的行为类似于 `merge`； 但是，除了覆盖具有字符串键的匹配项之外，`replace` 方法还将覆盖集合中具有匹配数字键的项：\r\n\r\n    $collection = collect(['Taylor', 'Abigail', 'James']);\r\n\r\n    $replaced = $collection->replace([1 => 'Victoria', 3 => 'Finn']);\r\n\r\n    $replaced->all();\r\n\r\n    // ['Taylor', 'Victoria', 'James', 'Finn']\r\n\r\n<a name=\"method-replacerecursive\"></a>\r\n#### `replaceRecursive()` {.collection-method}\r\n\r\n此方法的工作方式类似于 `replace`，但它会重复出现在数组中并对内部值应用相同的替换过程：\r\n\r\n    $collection = collect([\r\n        'Taylor',\r\n        'Abigail',\r\n        [\r\n            'James',\r\n            'Victoria',\r\n            'Finn'\r\n        ]\r\n    ]);\r\n\r\n    $replaced = $collection->replaceRecursive([\r\n        'Charlie',\r\n        2 => [1 => 'King']\r\n    ]);\r\n\r\n    $replaced->all();\r\n\r\n    // ['Charlie', 'Abigail', ['James', 'King', 'Finn']]\r\n\r\n<a name=\"method-reverse\"></a>\r\n#### `reverse()` {.collection-method}\r\n\r\n`reverse` 方法反转集合项的顺序，保留原始键：\r\n\r\n    $collection = collect(['a', 'b', 'c', 'd', 'e']);\r\n\r\n    $reversed = $collection->reverse();\r\n\r\n    $reversed->all();\r\n\r\n    /*\r\n        [\r\n            4 => 'e',\r\n            3 => 'd',\r\n            2 => 'c',\r\n            1 => 'b',\r\n            0 => 'a',\r\n        ]\r\n    */\r\n\r\n\r\n\r\n<a name=\"method-search\"></a>\r\n#### `search()` {.collection-method}\r\n\r\n`search` 方法在集合中搜索给定值，如果找到则返回其键。 如果未找到该项目，则返回 `false`：\r\n\r\n    $collection = collect([2, 4, 6, 8]);\r\n\r\n    $collection->search(4);\r\n\r\n    // 1\r\n\r\n搜索是使用“松散”比较完成的，这意味着具有整数值的字符串将被视为等于具有相同值的整数。 要使用“严格”比较，请将 `true` 作为第二个参数传递给方法：\r\n\r\n    collect([2, 4, 6, 8])->search('4', $strict = true);\r\n\r\n    // false\r\n\r\n或者，您可以提供自己的闭包来搜索通过给定真值测试的第一个项目：\r\n\r\n    collect([2, 4, 6, 8])->search(function ($item, $key) {\r\n        return $item > 5;\r\n    });\r\n\r\n    // 2\r\n\r\n<a name=\"method-shift\"></a>\r\n#### `shift()` {.collection-method}\r\n\r\n`shift` 方法从集合中移除并返回第一项：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->shift();\r\n\r\n    // 1\r\n\r\n    $collection->all();\r\n\r\n    // [2, 3, 4, 5]\r\n\r\n您可以将整数传递给 `shift` 方法以从集合的开头删除并返回多个项目：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->shift(3);\r\n\r\n    // collect([1, 2, 3])\r\n\r\n    $collection->all();\r\n\r\n    // [4, 5]\r\n\r\n<a name=\"method-shuffle\"></a>\r\n#### `shuffle()` {.collection-method}\r\n\r\n`shuffle` 方法随机打乱集合中的项目：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $shuffled = $collection->shuffle();\r\n\r\n    $shuffled->all();\r\n\r\n    // [3, 2, 5, 1, 4] - (generated randomly)\r\n\r\n<a name=\"method-sliding\"></a>\r\n#### `sliding()` {.collection-method}\r\n\r\n`sliding` 方法返回一个新的块集合，表示集合中项目的“滑动窗口”视图：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunks = $collection->sliding(2);\r\n\r\n    $chunks->toArray();\r\n\r\n    // [[1, 2], [2, 3], [3, 4], [4, 5]]\r\n\r\n这与 [`eachSpread`](#method-eachspread) 方法结合使用特别有用：\r\n\r\n    $transactions->sliding(2)->eachSpread(function ($previous, $current) {\r\n        $current->total = $previous->total + $current->amount;\r\n    });\r\n\r\n您可以选择传递第二个“步长”值，该值确定每个块的第一项之间的距离：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunks = $collection->sliding(3, step: 2);\r\n\r\n    $chunks->toArray();\r\n\r\n    // [[1, 2, 3], [3, 4, 5]]\r\n\r\n\r\n\r\n<a name=\"method-skip\"></a>\r\n#### `skip()` {.collection-method}\r\n\r\n`skip` 方法返回一个新集合，从集合的开头删除给定数量的元素：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n\r\n    $collection = $collection->skip(4);\r\n\r\n    $collection->all();\r\n\r\n    // [5, 6, 7, 8, 9, 10]\r\n\r\n<a name=\"method-skipuntil\"></a>\r\n#### `skipUntil()` {.collection-method}\r\n\r\n`skipUntil` 方法跳过集合中的项目，直到给定的回调返回 `true`，然后将集合中的剩余项目作为新的集合实例返回：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->skipUntil(function ($item) {\r\n        return $item >= 3;\r\n    });\r\n\r\n    $subset->all();\r\n\r\n    // [3, 4]\r\n\r\n您还可以将一个简单的值传递给 `skipUntil` 方法以跳过所有项目，直到找到给定值：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->skipUntil(3);\r\n\r\n    $subset->all();\r\n\r\n    // [3, 4]\r\n\r\n> 注意：如果未找到给定值或回调从不返回 `true`，则 `skipUntil` 方法将返回一个空集合。\r\n\r\n<a name=\"method-skipwhile\"></a>\r\n#### `skipWhile()` {.collection-method}\r\n\r\n`skipWhile` 方法在给定回调返回 `true` 时跳过集合中的项目，然后将集合中的剩余项目作为新集合返回：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->skipWhile(function ($item) {\r\n        return $item <= 3;\r\n    });\r\n\r\n    $subset->all();\r\n\r\n    // [4]\r\n\r\n> 注意：如果回调从不返回 `false`，则 `skipWhile` 方法将返回一个空集合。\r\n\r\n<a name=\"method-slice\"></a>\r\n#### `slice()` {.collection-method}\r\n\r\n`slice` 方法返回从给定索引开始的集合切片：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n\r\n    $slice = $collection->slice(4);\r\n\r\n    $slice->all();\r\n\r\n    // [5, 6, 7, 8, 9, 10]\r\n\r\n如果您想限制返回切片的大小，请将所需大小作为第二个参数传递给该方法：\r\n\r\n    $slice = $collection->slice(4, 2);\r\n\r\n    $slice->all();\r\n\r\n    // [5, 6]\r\n\r\n默认情况下，返回的切片将保留键。 如果您不希望保留原始键，可以使用 [`values`](#method-values) 方法重新索引它们。\r\n\r\n\r\n\r\n<a name=\"method-sole\"></a>\r\n#### `sole()` {.collection-method}\r\n\r\n`sole` 方法返回集合中通过给定真值测试的第一个元素，但前提是真值测试与一个元素完全匹配：\r\n\r\n    collect([1, 2, 3, 4])->sole(function ($value, $key) {\r\n        return $value === 2;\r\n    });\r\n\r\n    // 2\r\n\r\n您还可以将键/值对传递给 `sole` 方法，该方法将返回集合中与给定对匹配的第一个元素，但前提是它恰好有一个元素匹配：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n    ]);\r\n\r\n    $collection->sole('product', 'Chair');\r\n\r\n    // ['product' => 'Chair', 'price' => 100]\r\n\r\n或者，如果只有一个元素，您也可以调用不带参数的 `sole` 方法来获取集合中的第一个元素：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n    ]);\r\n\r\n    $collection->sole();\r\n\r\n    // ['product' => 'Desk', 'price' => 200]\r\n\r\n如果集合中没有应该由 `sole` 方法返回的元素，则会抛出 `\\Illuminate\\Collections\\ItemNotFoundException` 异常。 如果应该返回多个元素，则会抛出 `\\Illuminate\\Collections\\MultipleItemsFoundException`。\r\n\r\n<a name=\"method-some\"></a>\r\n#### `some()` {.collection-method}\r\n\r\n[`contains`](#method-contains) 方法的别名。\r\n\r\n<a name=\"method-sort\"></a>\r\n#### `sort()` {.collection-method}\r\n\r\n`sort` 方法对集合进行排序。 排序后的集合保留了原始数组键，因此在下面的示例中，我们将使用 [`values`](#method-values) 方法将键重置为连续编号的索引：\r\n\r\n    $collection = collect([5, 3, 1, 2, 4]);\r\n\r\n    $sorted = $collection->sort();\r\n\r\n    $sorted->values()->all();\r\n\r\n    // [1, 2, 3, 4, 5]\r\n\r\n如果您的排序需求更高级，您可以使用自己的算法将回调传递给“排序”。 参考PHP文档[`uasort`](https://secure.php.net/manual/en/function.uasort.php#refsect1-function.uasort-parameters)，就是集合的`sort`方法 调用内部使用。\r\n\r\n> 技巧：如果您需要对嵌套数组或对象的集合进行排序，请参阅 [`sortBy`](#method-sortby) 和 [`sortByDesc`](#method-sortbydesc) 方法。\r\n\r\n\r\n\r\n<a name=\"method-sortby\"></a>\r\n#### `sortBy()` {.collection-method}\r\n\r\n`sortBy` 方法按给定键对集合进行排序。 排序后的集合保留了原始数组键，因此在下面的示例中，我们将使用 [`values`](#method-values) 方法将键重置为连续编号的索引：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Desk', 'price' => 200],\r\n        ['name' => 'Chair', 'price' => 100],\r\n        ['name' => 'Bookcase', 'price' => 150],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy('price');\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Chair', 'price' => 100],\r\n            ['name' => 'Bookcase', 'price' => 150],\r\n            ['name' => 'Desk', 'price' => 200],\r\n        ]\r\n    */\r\n\r\n`sortBy` 方法接受 [sort flags](https://www.php.net/manual/en/function.sort.php) 作为其第二个参数：\r\n\r\n    $collection = collect([\r\n        ['title' => 'Item 1'],\r\n        ['title' => 'Item 12'],\r\n        ['title' => 'Item 3'],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy('title', SORT_NATURAL);\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['title' => 'Item 1'],\r\n            ['title' => 'Item 3'],\r\n            ['title' => 'Item 12'],\r\n        ]\r\n    */\r\n\r\n或者，您可以传递自己的闭包来确定如何对集合的值进行排序：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],\r\n        ['name' => 'Chair', 'colors' => ['Black']],\r\n        ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy(function ($product, $key) {\r\n        return count($product['colors']);\r\n    });\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Chair', 'colors' => ['Black']],\r\n            ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],\r\n            ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],\r\n        ]\r\n    */\r\n\r\n如果您想按多个属性对集合进行排序，可以将排序操作数组传递给 `sortBy` 方法。 每个排序操作都应该是一个数组，由您希望排序的属性和所需排序的方向组成：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Taylor Otwell', 'age' => 34],\r\n        ['name' => 'Abigail Otwell', 'age' => 30],\r\n        ['name' => 'Taylor Otwell', 'age' => 36],\r\n        ['name' => 'Abigail Otwell', 'age' => 32],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy([\r\n        ['name', 'asc'],\r\n        ['age', 'desc'],\r\n    ]);\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Abigail Otwell', 'age' => 32],\r\n            ['name' => 'Abigail Otwell', 'age' => 30],\r\n            ['name' => 'Taylor Otwell', 'age' => 36],\r\n            ['name' => 'Taylor Otwell', 'age' => 34],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n当按多个属性对集合进行排序时，您还可以提供定义每个排序操作的闭包：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Taylor Otwell', 'age' => 34],\r\n        ['name' => 'Abigail Otwell', 'age' => 30],\r\n        ['name' => 'Taylor Otwell', 'age' => 36],\r\n        ['name' => 'Abigail Otwell', 'age' => 32],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy([\r\n        fn ($a, $b) => $a['name'] <=> $b['name'],\r\n        fn ($a, $b) => $b['age'] <=> $a['age'],\r\n    ]);\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Abigail Otwell', 'age' => 32],\r\n            ['name' => 'Abigail Otwell', 'age' => 30],\r\n            ['name' => 'Taylor Otwell', 'age' => 36],\r\n            ['name' => 'Taylor Otwell', 'age' => 34],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-sortbydesc\"></a>\r\n#### `sortByDesc()` {.collection-method}\r\n\r\n此方法与 [`sortBy`](#method-sortby) 方法具有相同的签名，但将以相反的顺序对集合进行排序。\r\n\r\n<a name=\"method-sortdesc\"></a>\r\n#### `sortDesc()` {.collection-method}\r\n\r\n此方法将按照与 [`sort`](#method-sort) 方法相反的顺序对集合进行排序：\r\n\r\n    $collection = collect([5, 3, 1, 2, 4]);\r\n\r\n    $sorted = $collection->sortDesc();\r\n\r\n    $sorted->values()->all();\r\n\r\n    // [5, 4, 3, 2, 1]\r\n\r\n与 `sort` 不同，您不能将闭包传递给 `sortDesc`。 相反，您应该使用 [`sort`](#method-sort) 方法并反转比较。\r\n\r\n<a name=\"method-sortkeys\"></a>\r\n#### `sortKeys()` {.collection-method}\r\n\r\n`sortKeys` 方法通过底层关联数组的键对集合进行排序：\r\n\r\n    $collection = collect([\r\n        'id' => 22345,\r\n        'first' => 'John',\r\n        'last' => 'Doe',\r\n    ]);\r\n\r\n    $sorted = $collection->sortKeys();\r\n\r\n    $sorted->all();\r\n\r\n    /*\r\n        [\r\n            'first' => 'John',\r\n            'id' => 22345,\r\n            'last' => 'Doe',\r\n        ]\r\n    */\r\n\r\n<a name=\"method-sortkeysdesc\"></a>\r\n#### `sortKeysDesc()` {.collection-method}\r\n\r\n此方法与 [`sortKeys`](#method-sortkeys) 方法具有相同的签名，但将以相反的顺序对集合进行排序。\r\n\r\n<a name=\"method-sortkeysusing\"></a>\r\n#### `sortKeysUsing()` {.collection-method}\r\n\r\n`sortKeysUsing` 方法使用回调通过底层关联数组的键对集合进行排序：\r\n\r\n    $collection = collect([\r\n        'ID' => 22345,\r\n        'first' => 'John',\r\n        'last' => 'Doe',\r\n    ]);\r\n\r\n    $sorted = $collection->sortKeysUsing('strnatcasecmp');\r\n\r\n    $sorted->all();\r\n\r\n    /*\r\n        [\r\n            'first' => 'John',\r\n            'ID' => 22345,\r\n            'last' => 'Doe',\r\n        ]\r\n    */\r\n\r\n\r\n\r\n回调必须是返回小于、等于或大于零的整数的比较函数。 有关更多信息，请参阅 [`uksort`](https://www.php.net/manual/en/function.uksort.php#refsect1-function.uksort-parameters) 上的 PHP 文档，这是 PHP 函数 `sortKeysUsing` 方法在内部使用。\r\n\r\n<a name=\"method-splice\"></a>\r\n#### `splice()` {.collection-method}\r\n\r\n`splice` 方法删除并返回从指定索引开始的项目切片：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->splice(2);\r\n\r\n    $chunk->all();\r\n\r\n    // [3, 4, 5]\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2]\r\n\r\n您可以传递第二个参数来限制结果集合的大小：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->splice(2, 1);\r\n\r\n    $chunk->all();\r\n\r\n    // [3]\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 4, 5]\r\n\r\n此外，您可以传递包含新项目的第三个参数来替换从集合中删除的项目：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->splice(2, 1, [10, 11]);\r\n\r\n    $chunk->all();\r\n\r\n    // [3]\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 10, 11, 4, 5]\r\n\r\n<a name=\"method-split\"></a>\r\n#### `split()` {.collection-method}\r\n\r\n`split` 方法将集合分成给定数量的组：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $groups = $collection->split(3);\r\n\r\n    $groups->all();\r\n\r\n    // [[1, 2], [3, 4], [5]]\r\n\r\n<a name=\"method-splitin\"></a>\r\n#### `splitIn()` {.collection-method}\r\n\r\n`splitIn` 方法将集合分成给定数量的组，在将剩余部分分配给最终组之前完全填充非终端组：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n\r\n    $groups = $collection->splitIn(3);\r\n\r\n    $groups->all();\r\n\r\n    // [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]\r\n\r\n<a name=\"method-sum\"></a>\r\n#### `sum()` {.collection-method}\r\n\r\n`sum` 方法返回集合中所有项目的总和：\r\n\r\n    collect([1, 2, 3, 4, 5])->sum();\r\n\r\n    // 15\r\n\r\n如果集合包含嵌套数组或对象，则应传递一个键，用于确定要对哪些值求和：\r\n\r\n    $collection = collect([\r\n        ['name' => 'JavaScript: The Good Parts', 'pages' => 176],\r\n        ['name' => 'JavaScript: The Definitive Guide', 'pages' => 1096],\r\n    ]);\r\n\r\n    $collection->sum('pages');\r\n\r\n    // 1272\r\n\r\n\r\n\r\n此外，您可以传递自己的闭包来确定要对集合的哪些值求和：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Chair', 'colors' => ['Black']],\r\n        ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],\r\n        ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],\r\n    ]);\r\n\r\n    $collection->sum(function ($product) {\r\n        return count($product['colors']);\r\n    });\r\n\r\n    // 6\r\n\r\n<a name=\"method-take\"></a>\r\n#### `take()` {.collection-method}\r\n\r\n`take` 方法返回一个具有指定数量项目的新集合：\r\n\r\n    $collection = collect([0, 1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->take(3);\r\n\r\n    $chunk->all();\r\n\r\n    // [0, 1, 2]\r\n\r\n您还可以传递一个负整数以从集合末尾获取指定数量的项目：\r\n\r\n    $collection = collect([0, 1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->take(-2);\r\n\r\n    $chunk->all();\r\n\r\n    // [4, 5]\r\n\r\n<a name=\"method-takeuntil\"></a>\r\n#### `takeUntil()` {.collection-method}\r\n\r\n`takeUntil` 方法返回集合中的项目，直到给定的回调返回 `true`：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->takeUntil(function ($item) {\r\n        return $item >= 3;\r\n    });\r\n\r\n    $subset->all();\r\n\r\n    // [1, 2]\r\n\r\n您还可以将一个简单的值传递给 `takeUntil` 方法以获取项目，直到找到给定值：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->takeUntil(3);\r\n\r\n    $subset->all();\r\n\r\n    // [1, 2]\r\n\r\n> 注意：如果未找到给定值或回调从未返回 `true`，则 `takeUntil` 方法将返回集合中的所有项目。\r\n\r\n<a name=\"method-takewhile\"></a>\r\n#### `takeWhile()` {.collection-method}\r\n\r\n`takeWhile` 方法返回集合中的项目，直到给定的回调返回 `false`：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->takeWhile(function ($item) {\r\n        return $item < 3;\r\n    });\r\n\r\n    $subset->all();\r\n\r\n    // [1, 2]\r\n\r\n> 注意：如果回调从不返回 `false`，则 `takeWhile` 方法将返回集合中的所有项目。\r\n\r\n<a name=\"method-tap\"></a>\r\n#### `tap()` {.collection-method}\r\n\r\n`tap` 方法将集合传递给给定的回调，允许您在特定点“点击”到集合中并在不影响集合本身的情况下对项目执行某些操作。 然后集合由 `tap` 方法返回：\r\n\r\n    collect([2, 4, 3, 1, 5])\r\n        ->sort()\r\n        ->tap(function ($collection) {\r\n            Log::debug('Values after sorting', $collection->values()->all());\r\n        })\r\n        ->shift();\r\n\r\n    // 1\r\n\r\n\r\n\r\n<a name=\"method-times\"></a>\r\n#### `times()`\r\n\r\n静态 `times` 方法通过调用给定次数的回调函数来创建新集合：\r\n\r\n    $collection = Collection::times(10, function ($number) {\r\n        return $number * 9;\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]\r\n\r\n<a name=\"method-toarray\"></a>\r\n#### `toArray()`\r\n\r\n该 `toArray` 方法将集合转换成 PHP `array`。如果集合的值是 [Eloquent](/docs/laravel/9.x/eloquent) 模型，那也会被转换成数组：\r\n\r\n    $collection = collect(['name' => 'Desk', 'price' => 200]);\r\n\r\n    $collection->toArray();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Desk', 'price' => 200],\r\n        ]\r\n    */\r\n\r\n> 注意：`toArray` 也会将 `Arrayable` 的实例、所有集合的嵌套对象转换为数组。如果你想获取原数组，可以使用 [`all`](#method-all) 方法。\r\n\r\n<a name=\"method-tojson\"></a>\r\n#### `toJson()`\r\n\r\n该 `toJson` 方法将集合转换成 JSON 字符串：\r\n\r\n    $collection = collect(['name' => 'Desk', 'price' => 200]);\r\n\r\n    $collection->toJson();\r\n\r\n    // '{\"name\":\"Desk\", \"price\":200}'\r\n\r\n<a name=\"method-transform\"></a>\r\n#### `transform()`\r\n\r\n该 `transform` 方法会遍历整个集合，并对集合中的每个元素都会调用其回调函数。集合中的元素将被替换为回调函数返回的值：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->transform(function ($item, $key) {\r\n        return $item * 2;\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [2, 4, 6, 8, 10]\r\n\r\n> 注意：与大多数集合方法不同，`transform` 会修改集合本身。如果你想创建新集合，可以使用 [`map`](#method-map) 方法。\r\n\r\n<a name=\"method-undot\"></a>\r\n#### `undot()`\r\n\r\n该 `undot` 方法将给定数组添加到集合中。如果给定的数组含有与原集合一样的键，则首选原始集合的值：\r\n\r\n    $person = collect([\r\n        'name.first_name' => 'Marie',\r\n        'name.last_name' => 'Valentine',\r\n        'address.line_1' => '2992 Eagle Drive',\r\n        'address.line_2' => '',\r\n        'address.suburb' => 'Detroit',\r\n        'address.state' => 'MI',\r\n        'address.postcode' => '48219'\r\n    ])\r\n\r\n    $person = $person->undot();\r\n\r\n    $person->toArray();\r\n\r\n    /*\r\n        [\r\n            \"name\" => [\r\n                \"first_name\" => \"Marie\",\r\n                \"last_name\" => \"Valentine\",\r\n            ],\r\n            \"address\" => [\r\n                \"line_1\" => \"2992 Eagle Drive\",\r\n                \"line_2\" => \"\",\r\n                \"suburb\" => \"Detroit\",\r\n                \"state\" => \"MI\",\r\n                \"postcode\" => \"48219\",\r\n            ],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n<a name=\"method-union\"></a>\r\n#### `union()`\r\n\r\n该 `union` 方法将给定数组添加到集合中。如果给定的数组含有与原集合一样的键，则首选原始集合的值：\r\n\r\n    $collection = collect([1 => ['a'], 2 => ['b']]);\r\n\r\n    $union = $collection->union([3 => ['c'], 1 => ['d']]);\r\n\r\n    $union->all();\r\n\r\n    // [1 => ['a'], 2 => ['b'], 3 => ['c']]\r\n\r\n<a name=\"method-unique\"></a>\r\n#### `unique()`\r\n\r\n该 `unique` 方法返回集合中所有唯一项。返回的集合保留着原数组的键，所以在这个例子中，我们使用 [`values`](#method-values) 方法把键重置为连续编号的索引：\r\n\r\n    $collection = collect([1, 1, 2, 2, 3, 4, 2]);\r\n\r\n    $unique = $collection->unique();\r\n\r\n    $unique->values()->all();\r\n\r\n    // [1, 2, 3, 4]\r\n\r\n当处理嵌套数组或对象时，你可以指定用于确定唯一性的键：\r\n\r\n    $collection = collect([\r\n        ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],\r\n        ['name' => 'iPhone 5', 'brand' => 'Apple', 'type' => 'phone'],\r\n        ['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'],\r\n        ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],\r\n        ['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'],\r\n    ]);\r\n\r\n    $unique = $collection->unique('brand');\r\n\r\n    $unique->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],\r\n            ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],\r\n        ]\r\n    */\r\n\r\n最后，您还可以将自己的闭包传递给该 `unique` 方法，以指定哪个值应确定项目的唯一性：\r\n\r\n    $unique = $collection->unique(function ($item) {\r\n        return $item['brand'].$item['type'];\r\n    });\r\n\r\n    $unique->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],\r\n            ['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'],\r\n            ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],\r\n            ['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'],\r\n        ]\r\n    */\r\n\r\n该 `unique` 方法在检查项目值时使用「宽松」模式比较，意味着具有整数值的字符串将被视为等于相同值的整数。你可以使用  [`uniqueStrict`](#method-uniquestrict)  方法做「严格」模式比较。\r\n\r\n> 技巧：这个方法的行为在使用 [Eloquent 集合](/docs/laravel/9.x/eloquent-collections#method-unique) 时被修改。\r\n\r\n\r\n\r\n<a name=\"method-uniquestrict\"></a>\r\n#### `uniqueStrict()`\r\n\r\n这个方法与 [`unique`](#method-unique) 方法一样，然而，所有的值是用 「严格」模式来比较的。\r\n\r\n<a name=\"method-unless\"></a>\r\n#### `unless()`\r\n\r\n该 `unless` 法当传入的第一个参数不为 `true` 的时候，将执行给定的回调函数：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $collection->unless(true, function ($collection) {\r\n        return $collection->push(4);\r\n    });\r\n\r\n    $collection->unless(false, function ($collection) {\r\n        return $collection->push(5);\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 5]\r\n\r\n可以将第二个回调传递给该 `unless` 方法。 `unless` 当给方法的第一个参数计算结果为时，将执行第二个回调 `true`:\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $collection->unless(true, function ($collection) {\r\n        return $collection->push(4);\r\n    }, function ($collection) {\r\n        return $collection->push(5);\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 5]\r\n\r\n与 `unless` 相反的，请参见 [`when`](#method-when) 方法。\r\n\r\n<a name=\"method-unlessempty\"></a>\r\n#### `unlessEmpty()`\r\n\r\n[`whenNotEmpty`](#method-whennotempty) 的别名方法。\r\n\r\n<a name=\"method-unlessnotempty\"></a>\r\n#### `unlessNotEmpty()`\r\n\r\n[`whenEmpty`](#method-whenempty) 的别名方法。\r\n\r\n<a name=\"method-unwrap\"></a>\r\n#### `unwrap()\r\n\r\n静态 `unwrap` 方法返回集合内部的可用元素：\r\n\r\n    Collection::unwrap(collect('John Doe'));\r\n\r\n    // ['John Doe']\r\n\r\n    Collection::unwrap(['John Doe']);\r\n\r\n    // ['John Doe']\r\n\r\n    Collection::unwrap('John Doe');\r\n\r\n    // 'John Doe'\r\n\r\n<a name=\"method-values\"></a>\r\n#### `values()`\r\n\r\n该 `values` 方法返回键被重置为连续编号的新集合：\r\n\r\n    $collection = collect([\r\n        10 => ['product' => 'Desk', 'price' => 200],\r\n        11 => ['product' => 'Desk', 'price' => 200],\r\n    ]);\r\n\r\n    $values = $collection->values();\r\n\r\n    $values->all();\r\n\r\n    /*\r\n        [\r\n            0 => ['product' => 'Desk', 'price' => 200],\r\n            1 => ['product' => 'Desk', 'price' => 200],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-when\"></a>\r\n#### `when()`\r\n\r\n当 `when` 方法的第一个参数传入为 `true` 时，将执行给定的回调函数：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $collection->when(true, function ($collection) {\r\n        return $collection->push(4);\r\n    });\r\n\r\n    $collection->when(false, function ($collection) {\r\n        return $collection->push(5);\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 4]\r\n\r\n\r\n\r\n可以将第二个回调传递给该 `when` 方法。`when` 当给方法的第一个参数计算结果为时，将执行第二个回调 `false`:\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $collection->when(false, function ($collection) {\r\n        return $collection->push(4);\r\n    }, function ($collection) {\r\n        return $collection->push(5);\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 5]\r\n\r\n与 `when` 相反的方法，请查看 [`unless`](#method-unless) 方法。\r\n\r\n<a name=\"method-whenempty\"></a>\r\n#### `whenEmpty()`\r\n\r\n该 `whenEmpty` 方法是当集合为空时，将执行给定的回调函数：\r\n\r\n    $collection = collect(['Michael', 'Tom']);\r\n\r\n    $collection->whenEmpty(function ($collection) {\r\n        return $collection->push('Adam');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['Michael', 'Tom']\r\n\r\n\r\n    $collection = collect();\r\n\r\n    $collection->whenEmpty(function ($collection) {\r\n        return $collection->push('Adam');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['Adam']\r\n\r\n当集合不为空时，可以将第二个闭包传递给 `whenEmpty` 将要执行的方法：\r\n\r\n    $collection = collect(['Michael', 'Tom']);\r\n\r\n    $collection->whenEmpty(function ($collection) {\r\n        return $collection->push('Adam');\r\n    }, function ($collection) {\r\n        return $collection->push('Taylor');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['Michael', 'Tom', 'Taylor']\r\n\r\n与 `whenEmpty` 相反的方法，请查看 [`whenNotEmpty`](#method-whennotempty) 方法。\r\n\r\n<a name=\"method-whennotempty\"></a>\r\n#### `whenNotEmpty()`\r\n\r\n该 `whenNotEmpty` 方法当集合不为空时，将执行给定的回调函数：\r\n\r\n    $collection = collect(['michael', 'tom']);\r\n\r\n    $collection->whenNotEmpty(function ($collection) {\r\n        return $collection->push('adam');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['michael', 'tom', 'adam']\r\n\r\n\r\n    $collection = collect();\r\n\r\n    $collection->whenNotEmpty(function ($collection) {\r\n        return $collection->push('adam');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // []\r\n\r\n可以将第二个闭包传递给 `whenNotEmpty` 将在集合为空时执行的方法：\r\n\r\n    $collection = collect();\r\n\r\n    $collection->whenNotEmpty(function ($collection) {\r\n        return $collection->push('adam');\r\n    }, function ($collection) {\r\n        return $collection->push('taylor');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['taylor']\r\n\r\n与 `whenNotEmpty` 相反的方法，请查看 [`whenEmpty`](#method-whenempty) 方法。\r\n\r\n\r\n\r\n<a name=\"method-where\"></a>\r\n#### `where()`\r\n\r\n该 `where` 方法通过给定的键 / 值对查询过滤集合的结果：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->where('price', 100);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Chair', 'price' => 100],\r\n            ['product' => 'Door', 'price' => 100],\r\n        ]\r\n    */\r\n\r\n该 `where` 方法在检查集合项值时使用「宽松」模式比较，这意味着具有整数值的字符串会被认为等于相同值的整数。你可以使用 [`whereStrict`](#method-wherestrict) 方法进行「严格」模式比较。\r\n\r\n而且，你还可以将一个比较运算符作为第二个参数传递。\r\n\r\n    $collection = collect([\r\n        ['name' => 'Jim', 'deleted_at' => '2019-01-01 00:00:00'],\r\n        ['name' => 'Sally', 'deleted_at' => '2019-01-02 00:00:00'],\r\n        ['name' => 'Sue', 'deleted_at' => null],\r\n    ]);\r\n\r\n    $filtered = $collection->where('deleted_at', '!=', null);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Jim', 'deleted_at' => '2019-01-01 00:00:00'],\r\n            ['name' => 'Sally', 'deleted_at' => '2019-01-02 00:00:00'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-wherestrict\"></a>\r\n#### `whereStrict()`\r\n\r\n此方法和 [`where`](#method-where) 方法使用相似；但是它是「严格」模式去匹配值和类型。\r\n\r\n<a name=\"method-wherebetween\"></a>\r\n#### `whereBetween()`\r\n\r\n该 `whereBetween` 方法会筛选给定范围的集合：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 80],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Pencil', 'price' => 30],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->whereBetween('price', [100, 200]);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Desk', 'price' => 200],\r\n            ['product' => 'Bookcase', 'price' => 150],\r\n            ['product' => 'Door', 'price' => 100],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-wherein\"></a>\r\n#### `whereIn()`\r\n\r\n该 `whereIn` 方法会根据包含给定数组的键 / 值对来过滤集合：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->whereIn('price', [150, 200]);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Desk', 'price' => 200],\r\n            ['product' => 'Bookcase', 'price' => 150],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n`whereIn` 方法在检查项目值时使用 \"loose\" 比较，这意味着具有整数值的字符串将被视为等于相同值的整数。 使用 [`whereInStrict`](#method-whereinstrict) 方法使用“strict”比较进行过滤。\r\n\r\n<a name=\"method-whereinstrict\"></a>\r\n#### `whereInStrict()` {.collection-method}\r\n\r\n此方法与 [`whereIn`](#method-wherein) 方法具有相同的签名； 但是，所有值都使用“strict”比较进行比较。\r\n\r\n<a name=\"method-whereinstanceof\"></a>\r\n#### `whereInstanceOf()` {.collection-method}\r\n\r\n`whereInstanceOf` 方法按给定的类类型过滤集合：\r\n\r\n    use App\\Models\\User;\r\n    use App\\Models\\Post;\r\n\r\n    $collection = collect([\r\n        new User,\r\n        new User,\r\n        new Post,\r\n    ]);\r\n\r\n    $filtered = $collection->whereInstanceOf(User::class);\r\n\r\n    $filtered->all();\r\n\r\n    // [App\\Models\\User, App\\Models\\User]\r\n\r\n<a name=\"method-wherenotbetween\"></a>\r\n#### `whereNotBetween()` {.collection-method}\r\n\r\n`whereNotBetween` 方法通过确定指定项的值是否超出给定范围来过滤集合：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 80],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Pencil', 'price' => 30],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->whereNotBetween('price', [100, 200]);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Chair', 'price' => 80],\r\n            ['product' => 'Pencil', 'price' => 30],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-wherenotin\"></a>\r\n#### `whereNotIn()` {.collection-method}\r\n\r\n`whereNotIn` 方法从集合中删除具有给定数组中包含的指定项值的元素：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->whereNotIn('price', [150, 200]);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Chair', 'price' => 100],\r\n            ['product' => 'Door', 'price' => 100],\r\n        ]\r\n    */\r\n\r\n`whereNotIn` 方法在检查项目值时使用“loose”比较，这意味着具有整数值的字符串将被视为等于具有相同值的整数。 使用 [`whereNotInStrict`](#method-wherenotinstrict) 方法使用“strict”比较进行过滤。\r\n\r\n\r\n\r\n<a name=\"method-wherenotinstrict\"></a>\r\n#### `whereNotInStrict()`\r\n\r\n这个方法与 [`whereNotIn`](#method-wherenotin) 方法类似；不同的是会使用「严格」模式比较。\r\n\r\n<a name=\"method-wherenotnull\"></a>\r\n#### `whereNotNull()`\r\n\r\n该 `whereNotNull` 方法筛选给定键不为 `null`的项：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Desk'],\r\n        ['name' => null],\r\n        ['name' => 'Bookcase'],\r\n    ]);\r\n\r\n    $filtered = $collection->whereNotNull('name');\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Desk'],\r\n            ['name' => 'Bookcase'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-wherenull\"></a>\r\n#### `whereNull()`\r\n\r\n该 `whereNull` 方法筛选给定键为 `null`的项：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Desk'],\r\n        ['name' => null],\r\n        ['name' => 'Bookcase'],\r\n    ]);\r\n\r\n    $filtered = $collection->whereNull('name');\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => null],\r\n        ]\r\n    */\r\n\r\n\r\n<a name=\"method-wrap\"></a>\r\n#### `wrap()`\r\n\r\n静态 `wrap` 方法会将给定值封装到集合中：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n\r\n    $collection = Collection::wrap('John Doe');\r\n\r\n    $collection->all();\r\n\r\n    // ['John Doe']\r\n\r\n    $collection = Collection::wrap(['John Doe']);\r\n\r\n    $collection->all();\r\n\r\n    // ['John Doe']\r\n\r\n    $collection = Collection::wrap(collect('John Doe'));\r\n\r\n    $collection->all();\r\n\r\n    // ['John Doe']\r\n\r\n<a name=\"method-zip\"></a>\r\n#### `zip()`\r\n\r\n该 `zip` 方法在与集合的值对应的索引处合并给定数组的值：\r\n\r\n    $collection = collect(['Chair', 'Desk']);\r\n\r\n    $zipped = $collection->zip([100, 200]);\r\n\r\n    $zipped->all();\r\n\r\n    // [['Chair', 100], ['Desk', 200]]\r\n\r\n<a name=\"higher-order-messages\"></a>\r\n## 高阶消息传递\r\n\r\n集合也提供对「高阶消息传递」的支持，即集合常见操作的快捷方式。支持高阶消息传递的集合方法有： [`average`](#method-average)，[`avg`](#method-avg)，[`contains`](#method-contains)， [`each`](#method-each)，[`every`](#method-every)，[`filter`](#method-filter)， [`first`](#method-first)，[`flatMap`](#method-flatmap)，[`groupBy`](#method-groupby)，[`keyBy`](#method-keyby)，[`map`](#method-map)，[`max`](#method-max)， [`min`](#method-min)，[`partition`](#method-partition)，[`reject`](#method-reject)， [`skipUntil`](#method-skipuntil)，[`skipWhile`](#method-skipwhile)，[`some`](#method-some)，[`sortBy`](#method-sortby)，[`sortByDesc`](#method-sortbydesc)， [`sum`](#method-sum)，[`takeUntil`](#method-takeuntil)，[`takeWhile`](#method-takewhile) 和 [`unique`](#method-unique)。\r\n\r\n\r\n\r\n每个高阶消息都可以作为集合实例上的动态属性进行访问。 例如，让我们使用 `each` 高阶消息来调用集合中每个对象的方法：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where('votes', '>', 500)->get();\r\n\r\n    $users->each->markAsVip();\r\n\r\n同样，我们可以使用 `sum` 高阶消息来收集用户集合的“votes”总数：\r\n\r\n    $users = User::where('group', 'Development')->get();\r\n\r\n    return $users->sum->votes;\r\n\r\n<a name=\"lazy-collections\"></a>\r\n## 惰性集合\r\n\r\n<a name=\"lazy-collection-introduction\"></a>\r\n### 介绍\r\n\r\n> 注意：在进一步了解 Laravel 的惰性集合之前，花点时间熟悉一下 [PHP 生成器](https://www.php.net/manual/en/language.generators.overview.php).\r\n\r\n为了补充已经强大的 `Collection` 类，`LazyCollection` 类利用 PHP 的 [generators](https://www.php.net/manual/en/language.generators.overview.php) 允许您使用非常 大型数据集，同时保持较低的内存使用率。\r\n\r\n例如，假设您的应用程序需要处理数 GB 的日志文件，同时利用 Laravel 的集合方法来解析日志。 可以使用惰性集合在给定时间仅将文件的一小部分保留在内存中，而不是一次将整个文件读入内存：\r\n\r\n    use App\\Models\\LogEntry;\r\n    use Illuminate\\Support\\LazyCollection;\r\n\r\n    LazyCollection::make(function () {\r\n        $handle = fopen('log.txt', 'r');\r\n\r\n        while (($line = fgets($handle)) !== false) {\r\n            yield $line;\r\n        }\r\n    })->chunk(4)->map(function ($lines) {\r\n        return LogEntry::fromLines($lines);\r\n    })->each(function (LogEntry $logEntry) {\r\n        // Process the log entry...\r\n    });\r\n\r\n\r\n\r\n或者，假设您需要遍历 10,000 个 Eloquent 模型。 使用传统 Laravel 集合时，所有 10,000 个 Eloquent 模型必须同时加载到内存中：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::all()->filter(function ($user) {\r\n        return $user->id > 500;\r\n    });\r\n\r\n但是，查询构建器的 `cursor` 方法返回一个 `LazyCollection` 实例。 这允许您仍然只对数据库运行一个查询，而且一次只在内存中加载一个 Eloquent 模型。 在这个例子中，`filter` 回调在我们实际单独遍历每个用户之前不会执行，从而可以大幅减少内存使用量：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::cursor()->filter(function ($user) {\r\n        return $user->id > 500;\r\n    });\r\n\r\n    foreach ($users as $user) {\r\n        echo $user->id;\r\n    }\r\n\r\n<a name=\"creating-lazy-collections\"></a>\r\n### 创建惰性集合\r\n\r\n要创建惰性集合实例，您应该将 PHP 生成器函数传递给集合的 `make` 方法：\r\n\r\n    use Illuminate\\Support\\LazyCollection;\r\n\r\n    LazyCollection::make(function () {\r\n        $handle = fopen('log.txt', 'r');\r\n\r\n        while (($line = fgets($handle)) !== false) {\r\n            yield $line;\r\n        }\r\n    });\r\n\r\n<a name=\"the-enumerable-contract\"></a>\r\n### 枚举契约\r\n\r\n`Collection` 类上几乎所有可用的方法也可以在 `LazyCollection` 类上使用。 这两个类都实现了 `Illuminate\\Support\\Enumerable` 契约，它定义了以下方法：\r\n\r\n<div id=\"collection-method-list\" markdown=\"1\">\r\n\r\n[all](#method-all)\r\n[average](#method-average)\r\n[avg](#method-avg)\r\n[chunk](#method-chunk)\r\n[chunkWhile](#method-chunkwhile)\r\n[collapse](#method-collapse)\r\n[collect](#method-collect)\r\n[combine](#method-combine)\r\n[concat](#method-concat)\r\n[contains](#method-contains)\r\n[containsStrict](#method-containsstrict)\r\n[count](#method-count)\r\n[countBy](#method-countBy)\r\n[crossJoin](#method-crossjoin)\r\n[dd](#method-dd)\r\n[diff](#method-diff)\r\n[diffAssoc](#method-diffassoc)\r\n[diffKeys](#method-diffkeys)\r\n[dump](#method-dump)\r\n[duplicates](#method-duplicates)\r\n[duplicatesStrict](#method-duplicatesstrict)\r\n[each](#method-each)\r\n[eachSpread](#method-eachspread)\r\n[every](#method-every)\r\n[except](#method-except)\r\n[filter](#method-filter)\r\n[first](#method-first)\r\n[firstWhere](#method-first-where)\r\n[flatMap](#method-flatmap)\r\n[flatten](#method-flatten)\r\n[flip](#method-flip)\r\n[forPage](#method-forpage)\r\n[get](#method-get)\r\n[groupBy](#method-groupby)\r\n[has](#method-has)\r\n[implode](#method-implode)\r\n[intersect](#method-intersect)\r\n[intersectByKeys](#method-intersectbykeys)\r\n[isEmpty](#method-isempty)\r\n[isNotEmpty](#method-isnotempty)\r\n[join](#method-join)\r\n[keyBy](#method-keyby)\r\n[keys](#method-keys)\r\n[last](#method-last)\r\n[macro](#method-macro)\r\n[make](#method-make)\r\n[map](#method-map)\r\n[mapInto](#method-mapinto)\r\n[mapSpread](#method-mapspread)\r\n[mapToGroups](#method-maptogroups)\r\n[mapWithKeys](#method-mapwithkeys)\r\n[max](#method-max)\r\n[median](#method-median)\r\n[merge](#method-merge)\r\n[mergeRecursive](#method-mergerecursive)\r\n[min](#method-min)\r\n[mode](#method-mode)\r\n[nth](#method-nth)\r\n[only](#method-only)\r\n[pad](#method-pad)\r\n[partition](#method-partition)\r\n[pipe](#method-pipe)\r\n[pluck](#method-pluck)\r\n[random](#method-random)\r\n[reduce](#method-reduce)\r\n[reject](#method-reject)\r\n[replace](#method-replace)\r\n[replaceRecursive](#method-replacerecursive)\r\n[reverse](#method-reverse)\r\n[search](#method-search)\r\n[shuffle](#method-shuffle)\r\n[skip](#method-skip)\r\n[slice](#method-slice)\r\n[some](#method-some)\r\n[sort](#method-sort)\r\n[sortBy](#method-sortby)\r\n[sortByDesc](#method-sortbydesc)\r\n[sortKeys](#method-sortkeys)\r\n[sortKeysDesc](#method-sortkeysdesc)\r\n[split](#method-split)\r\n[sum](#method-sum)\r\n[take](#method-take)\r\n[tap](#method-tap)\r\n[times](#method-times)\r\n[toArray](#method-toarray)\r\n[toJson](#method-tojson)\r\n[union](#method-union)\r\n[unique](#method-unique)\r\n[uniqueStrict](#method-uniquestrict)\r\n[unless](#method-unless)\r\n[unlessEmpty](#method-unlessempty)\r\n[unlessNotEmpty](#method-unlessnotempty)\r\n[unwrap](#method-unwrap)\r\n[values](#method-values)\r\n[when](#method-when)\r\n[whenEmpty](#method-whenempty)\r\n[whenNotEmpty](#method-whennotempty)\r\n[where](#method-where)\r\n[whereStrict](#method-wherestrict)\r\n[whereBetween](#method-wherebetween)\r\n[whereIn](#method-wherein)\r\n[whereInStrict](#method-whereinstrict)\r\n[whereInstanceOf](#method-whereinstanceof)\r\n[whereNotBetween](#method-wherenotbetween)\r\n[whereNotIn](#method-wherenotin)\r\n[whereNotInStrict](#method-wherenotinstrict)\r\n[wrap](#method-wrap)\r\n[zip](#method-zip)\r\n\r\n</div>\r\n\r\n> 注意：改变集合的方法（例如 `shift`、`pop`、`prepend` 等）在 `LazyCollection` 类中**不**可用。\r\n\r\n\r\n\r\n<a name=\"lazy-collection-methods\"></a>\r\n### 惰性集合方法\r\n\r\n除了在 `Enumerable` 契约中定义的方法外， `LazyCollection` 类还包含以下方法：\r\n\r\n<a name=\"method-takeUntilTimeout\"></a>\r\n#### `takeUntilTimeout()` {.collection-method}\r\n\r\n`takeUntilTimeout` 方法返回新的惰性集合，它会在给定时间前去枚举集合值，之后集合将停止枚举：\r\n\r\n```php\r\n    $lazyCollection = LazyCollection::times(INF)\r\n        ->takeUntilTimeout(now()->addMinute());\r\n\r\n    $lazyCollection->each(function ($number) {\r\n        dump($number);\r\n\r\n        sleep(1);\r\n    });\r\n\r\n    // 1\r\n    // 2\r\n    // ...\r\n    // 58\r\n    // 59\r\n```\r\n\r\n为了具体阐述此方法，请设想一个使用游标从数据库提交发票的例子。你可以定义一个 [计划任务 ](/docs/laravel/9.x/scheduling)，它每十五分钟执行一次，并且只执行发票提交操作的最大时间是 14 分钟：\r\n\r\n```php\r\n    use App\\Models\\Invoice;\r\n    use Illuminate\\Support\\Carbon;\r\n\r\n    Invoice::pending()->cursor()\r\n        ->takeUntilTimeout(\r\n            Carbon::createFromTimestamp(LARAVEL_START)->add(14, 'minutes')\r\n        )\r\n        ->each(fn ($invoice) => $invoice->submit());\r\n```\r\n\r\n<a name=\"method-tapEach\"></a>\r\n#### `tapEach()` {.collection-method}\r\n\r\n\r\n当 `each` 方法为集合中每一个元素调用给定回调时， `tapEach` 方法仅调用给定回调，因为这些元素正在逐个从列表中拉出：\r\n\r\n```php\r\n    // 没有任何输出\r\n    $lazyCollection = LazyCollection::times(INF)->tapEach(function ($value) {\r\n        dump($value);\r\n    });\r\n\r\n    // 打印出三条数据\r\n    $array = $lazyCollection->take(3)->all();\r\n\r\n    // 1\r\n    // 2\r\n    // 3\r\n```\r\n\r\n<a name=\"method-remember\"></a>\r\n#### `remember()` {.collection-method}\r\n\r\n`remember` 方法返回一个新的惰性集合，这个集合已经记住（缓存）已枚举的所有值，当再次枚举该集合时不会获取它们：\r\n\r\n```php\r\n    // 没执行任何查询\r\n    $users = User::cursor()->remember();\r\n\r\n    //  执行了查询操作\r\n    // 并且前 5 个用户数据已经在数据库中查询完成\r\n    $users->take(5)->all();\r\n\r\n    // 前 5 个用户数据从缓存中获取\r\n    // 剩余的（15个）用户数据从数据库中查询\r\n    $users->take(20)->all();\r\n```\r\n","p":"docs/collections.html"},{"t":"mix (编译前端资源（Mix）)","d":"# 编译前端资源（Mix）\r\n\r\n- [简介](#introduction)\r\n- [安装 & 设置](#installation)\r\n- [运行 Mix](#running-mix)\r\n- [使用样式表](#working-with-stylesheets)\r\n    - [Tailwind CSS](#tailwindcss)\r\n    - [PostCSS](#postcss)\r\n    - [Sass](#sass)\r\n    - [URL 处理](#url-processing)\r\n    - [资源映射](#css-source-maps)\r\n- [使用 JavaScript](#working-with-scripts)\r\n    - [Vue](#vue)\r\n    - [React](#react)\r\n    - [Vendor 提取](#vendor-extraction)\r\n    - [自定义 Webpack 配置](#custom-webpack-configuration)\r\n- [版本控制 / 缓存清除](#versioning-and-cache-busting)\r\n- [Browsersync 重新加载](#browsersync-reloading)\r\n- [环境变量](#environment-variables)\r\n- [通知](#notifications)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Mix](https://github.com/laravel-mix/laravel-mix) 是一个由 [Laracasts](https://laracasts.com) 所开发的拓展包，作者 Jeffrey Way 。其使用了常见的 CSS 和 JavaScript 预处理器，为定义 [webpack](https://webpack.js.org) 构建步骤提供了流畅的 API。\r\n\r\n换句话说，Mix 使您可以轻松地编译和压缩应用程序中的 CSS 和 JavaScript 文件。通过链式调用这些简洁方法，可以流畅地定义资源管道。例如：\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js')\r\n    .postCss('resources/css/app.css', 'public/css');\r\n```\r\n\r\n如果您曾经对使用 Webpack 和资源编译感到困惑和不知所措，那么你一定会喜欢 Laravel Mix。但你不一定非要使用它来开发应用，你可以使用你喜欢的任何资源管道工具，甚至干脆不用。\r\n\r\n> 技巧：如果您需要先开始使用 Laravel 和 [Tailwind CSS](https://tailwindcss.com) 构建应用程序，请查看我们的 [应用程序入门工具包](/docs/laravel/9.x/starter-kits)。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装 & 配置\r\n\r\n<a name=\"installing-node\"></a>\r\n\r\n\r\n#### 安装 Node\r\n\r\n在运行 Mix 之前，要先确保您的机器上已经安装了 Node.js 和 NPM：\r\n\r\n```shell\r\nnode -v\r\nnpm -v\r\n```\r\n\r\n您可以从 [Node 官网](https://nodejs.org/en/download/) 使用图形化安装器轻松安装最新版本的  Node 和 NPM。或者，如果您使用的是 [Laravel Sail](/docs/laravel/9.x/sail) 则可以通过  Sail 调用 Node 和 NPM：\r\n\r\n```shell\r\n./sail node -v\r\n./sail npm -v\r\n```\r\n\r\n<a name=\"installing-laravel-mix\"></a>\r\n#### 安装 Laravel Mix\r\n\r\n剩下的事就是安装 Laravel Mix。在全新安装的 Laravel 中，您会在应用目录结构的根目录中找到 `package.json` 文件。 默认的 `package.json` 包含了使用 Laravel Mix 所需要的所有东西。 您可以把它想象成为 `composer.json` 文件，只是它定义的是 Node 依赖而不是 PHP 依赖。您可以像这样来安装依赖：\r\n\r\n```shell\r\nnpm install\r\n```\r\n\r\n<a name=\"running-mix\"></a>\r\n## 运行 Mix\r\n\r\nMix 是 [webpack](https://webpack.js.org) 的顶层配置，因此如果您要执行 Mix 任务，您只需要执行一条被包含于 Laravel 默认的 `package.json` 文件中的 NPM 脚本。当您运行 `dev` 或 `production` 脚本时， 应用程序的所有 CSS 和 JavaScript 资源文件都将被编译并放置在应用程序的 `public` 目录中：\r\n\r\n```shell\r\n// 运行所有的 Mix 任务…\r\nnpm run dev\r\n\r\n// 运行所有的 Mix 任务并最小化输出…\r\nnpm run prod\r\n```\r\n\r\n<a name=\"watching-assets-for-changes\"></a>\r\n#### 监听静态资源的变化\r\n\r\n\r\n\r\n`npm run watch` 命令将会在您的终端中持续运行，并监听所有相关的 CSS 和 JavaScript 文件的修改。当发现文件有任何改动时， Webpack 将会自动重新编译它们：\r\n\r\n```shell\r\nnpm run watch\r\n```\r\n\r\n您会发现在特定的环境下， 文件的修改并不会触发 Webpack 的更新。如果在您的系统中发生了这样的事，您可以考虑使用 `watch-poll` 命令:\r\n\r\n```shell\r\nnpm run watch-poll\r\n```\r\n\r\n<a name=\"working-with-stylesheets\"></a>\r\n## 使用样式表\r\n\r\n`webpack.mix.js` 是所有静态资源编译的入口。 您可以将其看成是 [webpack](https://webpack.js.org) 的轻量配置封装。Mix 任务能够与定义了静态资源的编译方式的配置一起被链式调用。\r\n\r\n<a name=\"tailwindcss\"></a>\r\n### Tailwind CSS\r\n\r\n[Tailwind CSS](https://tailwindcss.com) 是一种实用程序优先的现代框架，可在不离开 HTML 的情况下构建出色的网站。让我们研究一下如何在 Laravel Mix 的 Laravel 项目中开始使用它。首先，我们应该使用 NPM 安装 Tailwind 并生成我们的 Tailwind 配置文件：\r\n\r\n```shell\r\nnpm install\r\n\r\nnpm install -D tailwindcss\r\n\r\nnpx tailwindcss init\r\n```\r\n\r\n `init` 命令将生成一个 `tailwind.config.js` 文件。该文件的 `content` 部分允许您配置所有 HTML 模板、JavaScript 组件和任何其他包含 Tailwind 类名称的源文件的路径，以便 Tailwind 在优化生产环境中的 CSS 时，可以削减未使用的样式：\r\n\r\n```js\r\ncontent: [\r\n    './storage/framework/views/*.php',\r\n    './resources/**/*.blade.php',\r\n    './resources/**/*.js',\r\n    './resources/**/*.vue',\r\n],\r\n```\r\n\r\n\r\n\r\n接下来，您应该将 Tailwind 的每个「层」添加到应用中的 `resources/css/app.css` 文件：\r\n\r\n```css\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n```\r\n\r\n配置 Tailwind 的层后，请更新应用中的 `webpack.mix.js` 文件，如此便可编译 Tailwind 支持的 CSS：\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js')\r\n    .postCss('resources/css/app.css', 'public/css', [\r\n        require('tailwindcss'),\r\n    ]);\r\n```\r\n\r\n最后，您应当在应用的主布局模板中引用您的样式表。很多应用都将该模板存储于 `resources/views/layouts/app.blade.php` 中。此外，如果它还未正常显示，请确保您已经添加了 `meta` 标签：\r\n\r\n```blade\r\n<head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <link href=\"/css/app.css\" rel=\"stylesheet\">\r\n</head>\r\n```\r\n\r\n<a name=\"postcss\"></a>\r\n### PostCSS\r\n\r\n[PostCSS](https://postcss.org/) 是一个强大的工具，它可以转换您的 CSS ，它已经包含在 Laravel Mix 中，并可开箱即用。默认情况下，Mix 利用流行的 [Autoprefixer](https://github.com/postcss/autoprefixer) 插件来自动附加所有必要的 CSS3 前缀。当然，您亦可自由地添加任何应用所需的附加组件。\r\n\r\n首先，通过 NPM 安装所需的插件。然后，在调用 Mix 的 `postCss` 方法的时候，将其添加到您的插件数组中。 `postCss` 方法的第一个参数为 CSS 文件的路径，第二个参数为编译后的文件的位置路径：\r\n\r\n```js\r\nmix.postCss('resources/css/app.css', 'public/css', [\r\n    require('postcss-custom-properties')\r\n]);\r\n```\r\n\r\n或者，为了实现简单的 CSS 的编译和压缩，您可以在不使用其他插件的情况下执行 `postCss` :\r\n\r\n```js\r\nmix.postCss('resources/css/app.css', 'public/css');\r\n```\r\n\r\n\r\n\r\n<a name=\"sass\"></a>\r\n### Sass\r\n\r\n`sass` 方法允许您将 [Sass](https://sass-lang.com/) 编译成 Web 浏览器可以理解的 CSS 文件。`sass` 方法的第一个参数是您的 Sass 文件的路径，第二个参数是编译后的文件的存储路径：\r\n\r\n```js\r\nmix.sass('resources/sass/app.scss', 'public/css');\r\n```\r\n\r\n您可以将多个 Sass 文件编译成各自的 CSS 文件，甚至可以通过多次调用 `sass` 方法来自定义生成的 CSS 的输出目录：\r\n\r\n```js\r\nmix.sass('resources/sass/app.sass', 'public/css')\r\n    .sass('resources/sass/admin.sass', 'public/css/admin');\r\n```\r\n\r\n<a name=\"url-processing\"></a>\r\n### URL 处理\r\n\r\n因为 Laravel Mix 是基于 Webpack 之上构建的，所以了解几个 webpack 的概念就很重要了。对于 CSS 编译，webpack 将会重写和优化在样式表中的任何 `url()` 调用。虽然初听起来很奇怪，但这确实是一个很强大的功能。想象一下我们想要编译包含图片相对 URL 的 Sass：\r\n\r\n```css\r\n.example {\r\n    background: url('../images/example.png');\r\n}\r\n```\r\n\r\n> 注意：任何给定 `url()` 的绝对路径将被排除在 URL 重写之外。例如， `url('/images/thing.png')` 或 `url('http://example.com/images/thing.png')` 将不会作任何修改。\r\n\r\n默认情况下，Laravel Mix 和 Webpack 将会寻找到 `example.png`，并将其复制到您的 `public/images` 文件夹中，然后重写生成的样式表中的 `url()` 。如此一来，编译后的 CSS 将变为：\r\n\r\n```css\r\n.example {\r\n    background: url(/images/example.png?d41d8cd98f00b204e9800998ecf8427e);\r\n}\r\n```\r\n\r\n<a name=\"css-source-maps\"></a>\r\n### 源码映射\r\n\r\nSource map 默认是关闭的，你可以在 `webpack.mix.js` 文件中调用 `mix.sourceMaps()` 方法来打开 Source map 功能。尽管这会给前端编译带来一些性能负担，但是在使用浏览器调试时就会很方便找到对应的代码:\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js')\r\n    .sourceMaps();\r\n```\r\n\r\n<a name=\"style-of-source-mapping\"></a>\r\n#### 源码映射样式\r\n\r\nWebpack 提供了多种 [源码映射样式](https://webpack.js.org/configuration/devtool/#devtool)。在默认情况下 Mix 的源码映射使用 `eval-source-map`模式，它快速构建非常快。 如果你想更改映射样式可以使用 `sourceMaps` 方法:\r\n\r\n```js\r\nlet productionSourceMaps = false;\r\n\r\nmix.js('resources/js/app.js', 'public/js')\r\n    .sourceMaps(productionSourceMaps, 'source-map');\r\n```\r\n\r\n<a name=\"working-with-scripts\"></a>\r\n## 使用 JavaScript\r\n\r\nMix 提供了多种功能来帮助您处理 JavaScript 文件，例如编译最新的 ECMAScript 语法，模块化，代码压缩和合并 JavaScript 文件。更棒的是，所有这些都可以无缝运行，而无需大量的自定义配置:\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js');\r\n```\r\n\r\n\r\n\r\n通过这一行代码，你现在就可以实现：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- 支持最新的 EcmaScript 语法\r\n- 支持模块化开发\r\n- 在生产环境的代码压缩最小化\r\n\r\n</div>\r\n\r\n<a name=\"vue\"></a>\r\n### Vue\r\n\r\n当使用 `vue` 方法时，Mix 会自动安装编译 Vue 组件所需要的 Babel 插件。 不需要其他任何配置。\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js')\r\n   .vue();\r\n```\r\n\r\n编译 JavaScript 后，您可以在应用程序中引用它:\r\n\r\n```blade\r\n<head>\r\n    <!-- ... -->\r\n\r\n    <script src=\"/js/app.js\"></script>\r\n</head>\r\n```\r\n\r\n<a name=\"react\"></a>\r\n### React\r\n\r\nMix 可以自动安装 React 支持所需的 Babel 插件。 首先，请添加一个对 `react` 方法的调用：\r\n\r\n```js\r\nmix.js('resources/js/app.jsx', 'public/js')\r\n   .react();\r\n```\r\n\r\nMix 将在后台下载并包含相应的 `babel-preset-react` Babel  插件。编译 JavaScript 后，您可以在应用程序中引用它：\r\n\r\n```blade\r\n<head>\r\n    <!-- ... -->\r\n\r\n    <script src=\"/js/app.js\"></script>\r\n</head>\r\n```\r\n\r\n<a name=\"vendor-extraction\"></a>\r\n### 提取 Vendor\r\n\r\n将应用程序本身所有的 JavaScript 与 vendor 库（例如 React 和 Vue ）捆绑在一起的潜在缺点是：这会使长期缓存变得更加困难。 例如，对应用程序代码进行一次更新将迫使浏览器重新下载所有 vendor 库，即使它们没有更改。\r\n\r\n如果打算频繁更新应用程序的 JavaScript，则应考虑将所有 vender 库提取到它们自己的文件中。 这样，对应用程序代码的更改将不会影响大型 `vendor.js` 文件的缓存。 Mix 的  `extract` 方法使这变得轻而易举：\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js')\r\n    .extract(['vue'])\r\n```\r\n\r\n\r\n\r\n`extract` 方法接受你希望提取到 `vendor.js` 文件中的所有库或模块的数组。 以上面的代码段为例，Mix 将生成以下文件：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `public/js/manifest.js`: *Webpack 运行时清单*\r\n- `public/js/vendor.js`: *vendor 库*\r\n- `public/js/app.js`: *你的应用程序代码*\r\n\r\n</div>\r\n\r\n为避免 JavaScript 错误，请确保以正确的顺序加载这些文件:\r\n\r\n```html\r\n<script src=\"/js/manifest.js\"></script>\r\n<script src=\"/js/vendor.js\"></script>\r\n<script src=\"/js/app.js\"></script>\r\n```\r\n\r\n<a name=\"custom-webpack-configuration\"></a>\r\n### 自定义 Webpack 配置\r\n\r\n有时候你可能需要手动修改 Webpack 配置，例如，你可能需要引入特殊的 `loader` 或者插件。\r\n\r\nMix 提供非常有用的 `webpackConfig` 方法可以让你覆盖 Webpack 的配置。这非常吸引人，因为它不需要你复制和维护自己的 `webpack.config.js` 文件。 `webpackConfig` 方法接收一个对象你可以传入你希望的 [Webpack 特定配置](https://webpack.js.org/configuration/) 。\r\n\r\n```js\r\nmix.webpackConfig({\r\n    resolve: {\r\n        modules: [\r\n            path.resolve(__dirname, 'vendor/laravel/spark/resources/assets/js')\r\n        ]\r\n    }\r\n});\r\n```\r\n\r\n<a name=\"versioning-and-cache-busting\"></a>\r\n## 版本管理 / 缓存销毁\r\n\r\n许多开发者在他们编译后的资源添加时间戳或唯一令牌作后缀，强制浏览器加载新的资源，以替换旧的代码副本。Mix 可以使用 `version` 方法替你处理它们。\r\n\r\n`version` 方法自动在所有编译后的文件名后追加唯一的哈希值，从而实现更方便的缓存销毁：\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js')\r\n    .version();\r\n```\r\n\r\n\r\n\r\n在生成版本化文件后，你不会知道确切的文件名。因此，你需要在 [视图](/docs/laravel/9.x/views) 中使用Laravel 的全局 `mix` 函数载入相应的哈希资源。 `mix` 函数自动判断哈希文件的当前文件名：\r\n\r\n```blade\r\n<script src=\"{{ mix('/js/app.js') }}\"></script>\r\n```\r\n\r\n通常在开发阶段不需要版本化文件，你可以仅在运行 `npm run prod` 时执行版本化处理：\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js');\r\n\r\nif (mix.inProduction()) {\r\n    mix.version();\r\n}\r\n```\r\n\r\n<a name=\"custom-mix-base-urls\"></a>\r\n#### 自定义 Mix Base URLs\r\n\r\n如果你的 Mix 编译资产被部署到独立于应用程序的 CDN 上，则需要更改 `mix` 函数生成的基本 URL 。 你可以通过在 `config/app.php` 中添加一个 `mix_url` 配置选项来做到这一点。php 的配置文件:\r\n\r\n    'mix_url' => env('MIX_ASSET_URL', null)\r\n\r\n在配置了 Mix URL 之后，`mix` 函数将在生成资产 URL 时为所配置的 URL 添加前缀:\r\n\r\n```shell\r\nhttps://cdn.example.com/js/app.js?id=1964becbdd96414518cd\r\n```\r\n\r\n<a name=\"browsersync-reloading\"></a>\r\n## Browsersync 重加载\r\n\r\n[BrowserSync](https://browsersync.io/) 能够自动监测文件变化，并且无需手动刷新就将变化注入到浏览器。可以调用 `mix.browserSync()` 方法开启此项支持：\r\n\r\n```js\r\nmix.browserSync('laravel.test');\r\n```\r\n\r\n可以将 [BrowserSync 选项](https://browsersync.io/docs/options) 通过 Javascript 对象传递给 `browserSync` 方法来指定:\r\n\r\n```js\r\nmix.browserSync({\r\n    proxy: 'laravel.test'\r\n});\r\n```\r\n\r\n然后使用 `npm run watch` 命令启动 Webpack 的开发服务器。再编辑脚本或者 PHP 文件，就会看到浏览器立即刷新以响应你的修改。\r\n\r\n\r\n\r\n<a name=\"environment-variables\"></a>\r\n## 环境变量\r\n\r\n你可以通过在 `.env` 文件中添加 `MIX_` 前缀，将环境变量注入到 Mix：\r\n\r\n```ini\r\nMIX_SENTRY_DSN_PUBLIC=http://example.com\r\n```\r\n\r\n如果你在 `.env` 文件中定义了变量的话，你可以通过  `process.env` 对象来访问它。 但如果你在任务运行的时候修改了变量的值，你就需要重新启动任务了:\r\n\r\n```js\r\nprocess.env.MIX_SENTRY_DSN_PUBLIC\r\n```\r\n\r\n<a name=\"notifications\"></a>\r\n## 通知\r\n\r\n如果系统支持 Mix ， 将在编译时自动显示操作系统通知，为您提供有关编译是否成功的及时反馈。但是在某些情况下，您可能希望禁用这些通知。 比如在生产服务器上。禁用通知可以使用 `disableNotifications` 方法:\r\n\r\n```js\r\nmix.disableNotifications();\r\n```\r\n\r\n","p":"docs/mix.html"},{"t":"contracts (契约（Contract）)","d":"# 契约（Contract）\r\n\r\n- [简介](#introduction)\r\n    - [Contract 对比 Facade](#contracts-vs-facades)\r\n- [何时使用 Contract](#when-to-use-contracts)\r\n- [如何使用 Contract](#how-to-use-contracts)\r\n- [Contract 参考](#contract-reference)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 的 Contract 是一组接口，它们定义由框架提供的核心服务。例如，`illuste\\Contracts\\Queue\\Queue` Contract 定义了队列所需的方法，而 `illuste\\Contracts\\Mail\\Mailer` Contract 定义了发送邮件所需的方法。\r\n\r\n每个契约都有由框架提供的相应实现。例如，Laravel 提供了一个支持各种驱动的队列实现，还有一个由 [SwiftMailer](https://swiftmailer.symfony.com/) 提供支持的邮件程序实现等等。\r\n\r\n所有的 Laravel Contract 都存在于它们各自的 [GitHub 仓库](https://github.com/illuminate/contracts)。这为所有可用的契约提供了一个快速的参考点，以及一个可以被包开发人员使用的独立的包。\r\n\r\n<a name=\"contracts-vs-facades\"></a>\r\n### Contract 对比 Facade\r\n\r\nLaravel 的 [Facade](/docs/laravel/8.x/facades) 和辅助函数提供了一种利用 Laravel 服务的简单方法，无需类型提示并可以从服务容器中解析 Contract。在大多数情况下，每个 Facade 都有一个等效的 Contract。\r\n\r\n和 Facade（不需要在构造函数中引入）不同，Contract 允许你为类定义显式依赖关系。一些开发者更喜欢以这种方式显式定义其依赖项，所以更喜欢使用 Contract，而其他开发者则享受 Facade 带来的便利。**通常，大多数应用都可以在开发过程中使用 Facade。**\r\n\r\n<a name=\"when-to-use-contracts\"></a>\r\n## 何时使用 Contract\r\n\r\n使用 Contract 或 Facades 取决于个人喜好和开发团队的喜好。Contract 和 Facade 均可用于创建功能强大且经过良好测试的 Laravel 应用。Contract 和 Facade 并不是一道单选题，你可以在同一个应用内同时使用 Contract 和 Facade。只要聚焦在类的职责应该单一上，您会发现 Contract 和 Facade 的实际差异其实很小。\r\n\r\n通常情况下，大部分使用 Facade 的应用都不会在开发中遇到问题。但如果你在建立一个可以由多个 PHP 框架使用的扩展包，你可能会希望使用 `illuminate/contracts` 扩展包来定义该包和 Laravel 集成，而不需要引入完整的 Laravel 实现。\r\n\r\n<a name=\"how-to-use-contracts\"></a>\r\n## 如何使用 Contract\r\n\r\n那么，如何实现契约呢？它其实很简单。\r\n\r\nLaravel 中的许多类都是通过 [服务容器](https://learnku.com/docs/Laravel/8.x/container) 解析的，包括控制器、事件侦听器、中间件、队列任务，甚至路由闭包。因此，要实现契约，你只需要在被解析的类的构造函数中「类型提示」接口。\r\n\r\n例如，看看下面的这个事件监听器：\r\n\r\n\t<?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderWasPlaced;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Contracts\\Redis\\Factory;\r\n\r\n    class CacheOrderInformation\r\n    {\r\n        /**\r\n         * Redis Factory 实现\r\n         *\r\n         * @var \\Illuminate\\Contracts\\Redis\\Factory\r\n         */\r\n        protected $redis;\r\n\r\n        /**\r\n         * 创建一个新的事件监听器实例\r\n         *\r\n         * @param  \\Illuminate\\Contracts\\Redis\\Factory  $redis\r\n         * @return void\r\n         */\r\n        public function __construct(Factory $redis)\r\n        {\r\n            $this->redis = $redis;\r\n        }\r\n\r\n        /**\r\n         * 处理事件\r\n         *\r\n         * @param  \\App\\Events\\OrderWasPlaced  $event\r\n         * @return void\r\n         */\r\n        public function handle(OrderWasPlaced $event)\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n当解析事件监听器时，服务容器将读取构造函数上的类型提示，并注入适当的值。 要了解更多有关在服务容器中注册内容的信息，请查看 [其文档](/docs/laravel/8.x/container)。\r\n\r\n<a name=\"contract-reference\"></a>\r\n## Contract 参考\r\n\r\n下表提供了所有 Laravel Contract 及对应的 Facade 的快速参考：\r\n\r\nContract  |  对应的 Facade\r\n------------- | -------------\r\n[Illuminate\\Contracts\\Auth\\Access\\Authorizable](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/Access/Authorizable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Auth\\Access\\Gate](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/Access/Gate.php) | `Gate`\r\n[Illuminate\\Contracts\\Auth\\Authenticatable](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/Authenticatable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Auth\\CanResetPassword](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/CanResetPassword.php) | &nbsp;\r\n[Illuminate\\Contracts\\Auth\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/Factory.php) | `Auth`\r\n[Illuminate\\Contracts\\Auth\\Guard](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/Guard.php) | `Auth::guard()`\r\n[Illuminate\\Contracts\\Auth\\PasswordBroker](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/PasswordBroker.php) | `Password::broker()`\r\n[Illuminate\\Contracts\\Auth\\PasswordBrokerFactory](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/PasswordBrokerFactory.php) | `Password`\r\n[Illuminate\\Contracts\\Auth\\StatefulGuard](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/StatefulGuard.php) | &nbsp;\r\n[Illuminate\\Contracts\\Auth\\SupportsBasicAuth](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/SupportsBasicAuth.php) | &nbsp;\r\n[Illuminate\\Contracts\\Auth\\UserProvider](https://github.com/illuminate/contracts/blob/laravel/9.x/Auth/UserProvider.php) | &nbsp;\r\n[Illuminate\\Contracts\\Bus\\Dispatcher](https://github.com/illuminate/contracts/blob/laravel/9.x/Bus/Dispatcher.php) | `Bus`\r\n[Illuminate\\Contracts\\Bus\\QueueingDispatcher](https://github.com/illuminate/contracts/blob/laravel/9.x/Bus/QueueingDispatcher.php) | `Bus::dispatchToQueue()`\r\n[Illuminate\\Contracts\\Broadcasting\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Broadcasting/Factory.php) | `Broadcast`\r\n[Illuminate\\Contracts\\Broadcasting\\Broadcaster](https://github.com/illuminate/contracts/blob/laravel/9.x/Broadcasting/Broadcaster.php)  | `Broadcast::connection()`\r\n[Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast](https://github.com/illuminate/contracts/blob/laravel/9.x/Broadcasting/ShouldBroadcast.php) | &nbsp;\r\n[Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow](https://github.com/illuminate/contracts/blob/laravel/9.x/Broadcasting/ShouldBroadcastNow.php) | &nbsp;\r\n[Illuminate\\Contracts\\Cache\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Cache/Factory.php) | `Cache`\r\n[Illuminate\\Contracts\\Cache\\Lock](https://github.com/illuminate/contracts/blob/laravel/9.x/Cache/Lock.php) | &nbsp;\r\n[Illuminate\\Contracts\\Cache\\LockProvider](https://github.com/illuminate/contracts/blob/laravel/9.x/Cache/LockProvider.php) | &nbsp;\r\n[Illuminate\\Contracts\\Cache\\Repository](https://github.com/illuminate/contracts/blob/laravel/9.x/Cache/Repository.php) | `Cache::driver()`\r\n[Illuminate\\Contracts\\Cache\\Store](https://github.com/illuminate/contracts/blob/laravel/9.x/Cache/Store.php) | &nbsp;\r\n[Illuminate\\Contracts\\Config\\Repository](https://github.com/illuminate/contracts/blob/laravel/9.x/Config/Repository.php) | `Config`\r\n[Illuminate\\Contracts\\Console\\Application](https://github.com/illuminate/contracts/blob/laravel/9.x/Console/Application.php) | &nbsp;\r\n[Illuminate\\Contracts\\Console\\Kernel](https://github.com/illuminate/contracts/blob/laravel/9.x/Console/Kernel.php) | `Artisan`\r\n[Illuminate\\Contracts\\Container\\Container](https://github.com/illuminate/contracts/blob/laravel/9.x/Container/Container.php) | `App`\r\n[Illuminate\\Contracts\\Cookie\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Cookie/Factory.php) | `Cookie`\r\n[Illuminate\\Contracts\\Cookie\\QueueingFactory](https://github.com/illuminate/contracts/blob/laravel/9.x/Cookie/QueueingFactory.php) | `Cookie::queue()`\r\n[Illuminate\\Contracts\\Database\\ModelIdentifier](https://github.com/illuminate/contracts/blob/laravel/9.x/Database/ModelIdentifier.php) | &nbsp;\r\n[Illuminate\\Contracts\\Debug\\ExceptionHandler](https://github.com/illuminate/contracts/blob/laravel/9.x/Debug/ExceptionHandler.php) | &nbsp;\r\n[Illuminate\\Contracts\\Encryption\\Encrypter](https://github.com/illuminate/contracts/blob/laravel/9.x/Encryption/Encrypter.php) | `Crypt`\r\n[Illuminate\\Contracts\\Events\\Dispatcher](https://github.com/illuminate/contracts/blob/laravel/9.x/Events/Dispatcher.php) | `Event`\r\n[Illuminate\\Contracts\\Filesystem\\Cloud](https://github.com/illuminate/contracts/blob/laravel/9.x/Filesystem/Cloud.php) | `Storage::cloud()`\r\n[Illuminate\\Contracts\\Filesystem\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Filesystem/Factory.php) | `Storage`\r\n[Illuminate\\Contracts\\Filesystem\\Filesystem](https://github.com/illuminate/contracts/blob/laravel/9.x/Filesystem/Filesystem.php) | `Storage::disk()`\r\n[Illuminate\\Contracts\\Foundation\\Application](https://github.com/illuminate/contracts/blob/laravel/9.x/Foundation/Application.php) | `App`\r\n[Illuminate\\Contracts\\Hashing\\Hasher](https://github.com/illuminate/contracts/blob/laravel/9.x/Hashing/Hasher.php) | `Hash`\r\n[Illuminate\\Contracts\\Http\\Kernel](https://github.com/illuminate/contracts/blob/laravel/9.x/Http/Kernel.php) | &nbsp;\r\n[Illuminate\\Contracts\\Mail\\MailQueue](https://github.com/illuminate/contracts/blob/laravel/9.x/Mail/MailQueue.php) | `Mail::queue()`\r\n[Illuminate\\Contracts\\Mail\\Mailable](https://github.com/illuminate/contracts/blob/laravel/9.x/Mail/Mailable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Mail\\Mailer](https://github.com/illuminate/contracts/blob/laravel/9.x/Mail/Mailer.php) | `Mail`\r\n[Illuminate\\Contracts\\Notifications\\Dispatcher](https://github.com/illuminate/contracts/blob/laravel/9.x/Notifications/Dispatcher.php) | `Notification`\r\n[Illuminate\\Contracts\\Notifications\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Notifications/Factory.php) | `Notification`\r\n[Illuminate\\Contracts\\Pagination\\LengthAwarePaginator](https://github.com/illuminate/contracts/blob/laravel/9.x/Pagination/LengthAwarePaginator.php) | &nbsp;\r\n[Illuminate\\Contracts\\Pagination\\Paginator](https://github.com/illuminate/contracts/blob/laravel/9.x/Pagination/Paginator.php) | &nbsp;\r\n[Illuminate\\Contracts\\Pipeline\\Hub](https://github.com/illuminate/contracts/blob/laravel/9.x/Pipeline/Hub.php) | &nbsp;\r\n[Illuminate\\Contracts\\Pipeline\\Pipeline](https://github.com/illuminate/contracts/blob/laravel/9.x/Pipeline/Pipeline.php) | &nbsp;\r\n[Illuminate\\Contracts\\Queue\\EntityResolver](https://github.com/illuminate/contracts/blob/laravel/9.x/Queue/EntityResolver.php) | &nbsp;\r\n[Illuminate\\Contracts\\Queue\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Queue/Factory.php) | `Queue`\r\n[Illuminate\\Contracts\\Queue\\Job](https://github.com/illuminate/contracts/blob/laravel/9.x/Queue/Job.php) | &nbsp;\r\n[Illuminate\\Contracts\\Queue\\Monitor](https://github.com/illuminate/contracts/blob/laravel/9.x/Queue/Monitor.php) | `Queue`\r\n[Illuminate\\Contracts\\Queue\\Queue](https://github.com/illuminate/contracts/blob/laravel/9.x/Queue/Queue.php) | `Queue::connection()`\r\n[Illuminate\\Contracts\\Queue\\QueueableCollection](https://github.com/illuminate/contracts/blob/laravel/9.x/Queue/QueueableCollection.php) | &nbsp;\r\n[Illuminate\\Contracts\\Queue\\QueueableEntity](https://github.com/illuminate/contracts/blob/laravel/9.x/Queue/QueueableEntity.php) | &nbsp;\r\n[Illuminate\\Contracts\\Queue\\ShouldQueue](https://github.com/illuminate/contracts/blob/laravel/9.x/Queue/ShouldQueue.php) | &nbsp;\r\n[Illuminate\\Contracts\\Redis\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Redis/Factory.php) | `Redis`\r\n[Illuminate\\Contracts\\Routing\\BindingRegistrar](https://github.com/illuminate/contracts/blob/laravel/9.x/Routing/BindingRegistrar.php) | `Route`\r\n[Illuminate\\Contracts\\Routing\\Registrar](https://github.com/illuminate/contracts/blob/laravel/9.x/Routing/Registrar.php) | `Route`\r\n[Illuminate\\Contracts\\Routing\\ResponseFactory](https://github.com/illuminate/contracts/blob/laravel/9.x/Routing/ResponseFactory.php) | `Response`\r\n[Illuminate\\Contracts\\Routing\\UrlGenerator](https://github.com/illuminate/contracts/blob/laravel/9.x/Routing/UrlGenerator.php) | `URL`\r\n[Illuminate\\Contracts\\Routing\\UrlRoutable](https://github.com/illuminate/contracts/blob/laravel/9.x/Routing/UrlRoutable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Session\\Session](https://github.com/illuminate/contracts/blob/laravel/9.x/Session/Session.php) | `Session::driver()`\r\n[Illuminate\\Contracts\\Support\\Arrayable](https://github.com/illuminate/contracts/blob/laravel/9.x/Support/Arrayable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Support\\Htmlable](https://github.com/illuminate/contracts/blob/laravel/9.x/Support/Htmlable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Support\\Jsonable](https://github.com/illuminate/contracts/blob/laravel/9.x/Support/Jsonable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Support\\MessageBag](https://github.com/illuminate/contracts/blob/laravel/9.x/Support/MessageBag.php) | &nbsp;\r\n[Illuminate\\Contracts\\Support\\MessageProvider](https://github.com/illuminate/contracts/blob/laravel/9.x/Support/MessageProvider.php) | &nbsp;\r\n[Illuminate\\Contracts\\Support\\Renderable](https://github.com/illuminate/contracts/blob/laravel/9.x/Support/Renderable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Support\\Responsable](https://github.com/illuminate/contracts/blob/laravel/9.x/Support/Responsable.php) | &nbsp;\r\n[Illuminate\\Contracts\\Translation\\Loader](https://github.com/illuminate/contracts/blob/laravel/9.x/Translation/Loader.php) | &nbsp;\r\n[Illuminate\\Contracts\\Translation\\Translator](https://github.com/illuminate/contracts/blob/laravel/9.x/Translation/Translator.php) | `Lang`\r\n[Illuminate\\Contracts\\Validation\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/Validation/Factory.php) | `Validator`\r\n[Illuminate\\Contracts\\Validation\\ImplicitRule](https://github.com/illuminate/contracts/blob/laravel/9.x/Validation/ImplicitRule.php) | &nbsp;\r\n[Illuminate\\Contracts\\Validation\\Rule](https://github.com/illuminate/contracts/blob/laravel/9.x/Validation/Rule.php) | &nbsp;\r\n[Illuminate\\Contracts\\Validation\\ValidatesWhenResolved](https://github.com/illuminate/contracts/blob/laravel/9.x/Validation/ValidatesWhenResolved.php) | &nbsp;\r\n[Illuminate\\Contracts\\Validation\\Validator](https://github.com/illuminate/contracts/blob/laravel/9.x/Validation/Validator.php) | `Validator::make()`\r\n[Illuminate\\Contracts\\View\\Engine](https://github.com/illuminate/contracts/blob/laravel/9.x/View/Engine.php) | &nbsp;\r\n[Illuminate\\Contracts\\View\\Factory](https://github.com/illuminate/contracts/blob/laravel/9.x/View/Factory.php) | `View`\r\n[Illuminate\\Contracts\\View\\View](https://github.com/illuminate/contracts/blob/laravel/9.x/View/View.php) | `View::make()`\r\n\r\n","p":"docs/contracts.html"},{"t":"events (# 介绍)","d":"> # 事件系统\r\n\r\n- [介绍](#introduction)\r\n- [注册事件和监听器](#registering-events-and-listeners)\r\n    - [生成事件和监听器](#generating-events-and-listeners)\r\n    - [手动注册事件](#manually-registering-events)\r\n    - [发现事件](#event-discovery)\r\n- [定义事件](#defining-events)\r\n- [定义监听器](#defining-listeners)\r\n- [队列中的事件和监听器](#queued-event-listeners)\r\n    - [手动与队列交互](#manually-interacting-with-the-queue)\r\n    - [队列中的事件和监听器以及数据库交互](#queued-event-listeners-and-database-transactions)\r\n    - [处理失败队列](#handling-failed-jobs)\r\n- [调度事件](#dispatching-events)\r\n- [事件订阅者](#event-subscribers)\r\n    - [编写事件订阅者](#writing-event-subscribers)\r\n    - [注册事件订阅者](#registering-event-subscribers)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 的事件系统提供了一个简单的观察者模式的实现，允许你能够订阅和监听在你的应用中的发生的各种事件。事件类一般来说存储在 `app/Events` 目录，监听者的类存储在 `app/Listeners` 目录。不要担心在你的应用中没有看到这两个目录，因为通过 Artisan 命令行来创建事件和监听者的时候目录会同时被创建。\r\n\r\n事件系统可以作为一个非常棒的方式来解耦你的系统的方方面面，因为一个事件可以有多个完全不相关的监听者。例如，你希望每当有订单发出的时候都给你发送一个 Slack 通知。你大可不必将你的处理订单的代码和发送 slack 消息的代码放在一起，你只需要触发一个 `App\\Events\\OrderShipped` 事件，然后事件监听者可以收到这个事件然后发送 slack 通知\r\n\r\n<a name=\"registering-events-and-listeners\"></a>\r\n## 注册事件和监听器\r\n\r\n在系统的服务提供者 `App\\Providers\\EventServiceProvider` 中提供了一个简单的方式来注册你所有的事件监听者。属性 `listen` 包含所有的事件 (作为键) 和对应的监听器 (值)。你可以添加任意多系统需要的监听器在这个数组中，让我们添加一个 `OrderShipped` 事件：\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use App\\Listeners\\SendShipmentNotification;\r\n\r\n    /**\r\n     * 系统中的事件和监听器的对应关系。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        OrderShipped::class => [\r\n            SendShipmentNotification::class,\r\n        ],\r\n    ];\r\n\r\n> 技巧：可以用 Artisan 命令行 `event:list` 来显示系统注册的事件和监听器的列表。\r\n\r\n\r\n\r\n<a name=\"generating-events-and-listeners\"></a>\r\n### 生成事件和监听器\r\n\r\n当然，为每个事件和监听器手动创建文件是很麻烦的。相反，将监听器和事件添加到 `EventServiceProvider` 并使用 `event:generate` Artisan 命令。此命令将生成 `EventServiceProvider` 中列出的、尚不存在的任何事件或侦听器：\r\n\r\n```shell\r\nphp artisan event:generate\r\n```\r\n或者，你可以使用 `make:event` 以及 `make:listener` 用于生成单个事件和监听器的 Artisan 命令：\r\n\r\n```shell\r\nphp artisan make:event PodcastProcessed\r\n\r\nphp artisan make:listener SendPodcastNotification --event=PodcastProcessed\r\n```\r\n\r\n<a name=\"manually-registering-events\"></a>\r\n### 手动注册事件\r\n\r\n通常，事件应该通过 `EventServiceProvider` `$listen` 数组注册；但是，你也可以在 `EventServiceProvider` 的 `boot` 方法中手动注册基于类或闭包的事件监听器：\r\n\r\n    use App\\Events\\PodcastProcessed;\r\n    use App\\Listeners\\SendPodcastNotification;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n\r\n    /**\r\n     * 注册任意的其他事件和监听器。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Event::listen(\r\n            PodcastProcessed::class,\r\n            [SendPodcastNotification::class, 'handle']\r\n        );\r\n\r\n        Event::listen(function (PodcastProcessed $event) {\r\n            //\r\n        });\r\n    }\r\n\r\n<a name=\"queuable-anonymous-event-listeners\"></a>\r\n#### 可排队匿名事件监听器\r\n\r\n手动注册基于闭包的事件监听器时，可以将监听器闭包包装在 `Illuminate\\Events\\queueable` 函数中，以指示 Laravel 使用 [队列](/docs/laravel/9.x/queues) 执行侦听器：\r\n\r\n    use App\\Events\\PodcastProcessed;\r\n    use function Illuminate\\Events\\queueable;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n\r\n    /**\r\n     * 注册任意的其他事件和监听器。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Event::listen(queueable(function (PodcastProcessed $event) {\r\n            //\r\n        }));\r\n    }\r\n\r\n与队列任务一样，可以使用 `onConnection`、`onQueue` 和 `delay` 方法自定义队列监听器的执行：\r\n\r\n    Event::listen(queueable(function (PodcastProcessed $event) {\r\n        //\r\n    })->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));\r\n\r\n\r\n\r\n如果你想处理匿名队列监听器失败，你可以在定义 `queueable` 监听器时为 `catch` 方法提供一个闭包。这个闭包将接收导致监听器失败的事件实例和 `Throwable` 实例：\r\n\r\n    use App\\Events\\PodcastProcessed;\r\n    use function Illuminate\\Events\\queueable;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n    use Throwable;\r\n\r\n    Event::listen(queueable(function (PodcastProcessed $event) {\r\n        //\r\n    })->catch(function (PodcastProcessed $event, Throwable $e) {\r\n        // 队列监听器\r\n    }));\r\n\r\n<a name=\"wildcard-event-listeners\"></a>\r\n#### 通配符事件监听器\r\n\r\n您甚至可以使用 `*` 作为通配符参数注册监听器，允许您在同一个监听器上捕获多个事件。通配符监听器接收事件名作为其第一个参数，整个事件数据数组作为其第二个参数：\r\n\r\n    Event::listen('event.*', function ($eventName, array $data) {\r\n        //\r\n    });\r\n\r\n<a name=\"event-discovery\"></a>\r\n### 事件的发现\r\n\r\n您可以启用自动事件发现，而不是在 `EventServiceProvider` 的 `$listen` 数组中手动注册事件和侦听器。当事件发现启用，Laravel 将自动发现和注册你的事件和监听器扫描你的应用程序的 `Listeners` 目录。此外，在 `EventServiceProvider` 中列出的任何显式定义的事件仍将被注册。\r\n\r\nLaravel 通过使用 PHP 的反射服务扫描监听器类来查找事件监听器。当 Laravel 发现任何以 `handle` 或 `__invoke` 开头的监听器类方法时，Laravel 会将这些方法注册为该方法签名中类型暗示的事件的事件监听器：\r\n\r\n    use App\\Events\\PodcastProcessed;\r\n\r\n    class SendPodcastNotification\r\n    {\r\n        /**\r\n         * 处理给定的事件\r\n         *\r\n         * @param  \\App\\Events\\PodcastProcessed  $event\r\n         * @return void\r\n         */\r\n        public function handle(PodcastProcessed $event)\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n\r\n\r\n事件发现在默认情况下是禁用的，但您可以通过重写应用程序的 `EventServiceProvider` 的 `shouldDiscoverEvents` 方法来启用它：\r\n\r\n    /**\r\n     * 确定是否应用自动发现事件和监听器。\r\n     *\r\n     * @return bool\r\n     */\r\n    public function shouldDiscoverEvents()\r\n    {\r\n        return true;\r\n    }\r\n\r\n默认情况下，应用程序 `app/listeners` 目录中的所有监听器都将被扫描。如果你想要定义更多的目录来扫描，你可以重写 `EventServiceProvider` 中的 `discoverEventsWithin` 方法：\r\n\r\n    /**\r\n     * 获取应用于发现事件的监听器目录。\r\n     *\r\n     * @return array\r\n     */\r\n    protected function discoverEventsWithin()\r\n    {\r\n        return [\r\n            $this->app->path('Listeners'),\r\n        ];\r\n    }\r\n\r\n<a name=\"event-discovery-in-production\"></a>\r\n#### 生产中的事件发现\r\n\r\n在生产环境中，框架在每个请求上扫描所有监听器的效率并不高。因此，在你的部署过程中，你应该运行 `event:cache` Artisan 命令来缓存你的应用程序的所有事件和监听器清单。框架将使用该清单来加速事件注册过程。`event:clear` 命令可以用来销毁缓存。\r\n\r\n<a name=\"defining-events\"></a>\r\n## 定义事件\r\n\r\n事件类本质上是一个数据容器，它保存与事件相关的信息。例如，让我们假设一个 `App\\Events\\OrderShipped` 事件接收到一个 [Eloquent ORM](/docs/laravel/9.x/eloquent) 对象：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Broadcasting\\InteractsWithSockets;\r\n    use Illuminate\\Foundation\\Events\\Dispatchable;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipped\r\n    {\r\n        use Dispatchable, InteractsWithSockets, SerializesModels;\r\n\r\n        /**\r\n         * 订单实例。\r\n         *\r\n         * @var \\App\\Models\\Order\r\n         */\r\n        public $order;\r\n\r\n        /**\r\n         * 创建一个新的事件实例。\r\n         *\r\n         * @param  \\App\\Models\\Order  $order\r\n         * @return void\r\n         */\r\n        public function __construct(Order $order)\r\n        {\r\n            $this->order = $order;\r\n        }\r\n    }\r\n\r\n\r\n\r\n如您所见，这个事件类不包含逻辑。它是一个被购买的 `App\\Models\\Order` 实例容器。 如果事件对象是使用 PHP 的 `SerializesModels` 函数序列化的，事件使用的 `SerializesModels` trait 将会优雅地序列化任何 Eloquent 模型，比如在使用 [队列侦听器](#queued-event-listeners)。\r\n\r\n<a name=\"defining-listeners\"></a>\r\n## 定义监听器\r\n\r\n接下来，让我们看一下示例事件的侦听器。事件监听器在其 `handle` 方法中接收事件实例。 `artisan` 命令 `event:generate` 和 `make:listener` 会自动导入正确的事件类，并在 handle 方法中注入提示事件。 在 `handle` 方法中，你可以执行任何必要的操作来响应事件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n\r\n    class SendShipmentNotification\r\n    {\r\n        /**\r\n         * 创建事件监听器\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 处理事件\r\n         *\r\n         * @param  \\App\\Events\\OrderShipped  $event\r\n         * @return void\r\n         */\r\n        public function handle(OrderShipped $event)\r\n        {\r\n            // 使用 $event->order 来访问订单 ...\r\n        }\r\n    }\r\n\r\n> 技巧：事件监听器还可以在构造函数中加入任何依赖关系的类型提示。所有的事件监听器都是通过 Laravel 的 [服务器容器](/docs/laravel/9.x/container) 解析的，因此所有的依赖都将会被自动注入。\r\n\r\n<a name=\"stopping-the-propagation-of-an-event\"></a>\r\n#### 停止事件传播\r\n\r\n有时，您可能希望停止将事件传播到其他侦听器。你可以通过从监听器的 `handle` 方法返回 `false` 来做到这一点。\r\n\r\n<a name=\"queued-event-listeners\"></a>\r\n## 事件监听器队列\r\n\r\n如果侦听器执行缓慢的任务如发送电子邮件或发出 HTTP 请求，你可以将任务丢给队列处理。在开始使用队列监听器之前，请确保在你的服务器或者本地开发环境中能够 [配置队列](/docs/laravel/9.x/queues) 并启动一个队列监听器。\r\n\r\n\r\n\r\n要指定监听器启动队列，请将 `ShouldQueue` 接口添加到监听器类。 由 Artisan 命令 `event:generate` 和 `make:listener` 生成的监听器已经将此接口导入当前命名空间，因此您可以直接使用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        //\r\n    }\r\n\r\n就是这样！现在，当这个监听器被事件调用时，事件调度器会自动使用 Laravel 的 [队列系统](/docs/laravel/9.x/queues) 自动排队。如果在队列中执行监听器时没有抛出异常，任务会在执行完成后自动从队列中删除。\r\n\r\n<a name=\"customizing-the-queue-connection-queue-name\"></a>\r\n#### 自定义队列连接 & 队列名称\r\n\r\n如果你想自定义事件监听器的队列连接、队列名称或延迟队列时间，你可以在监听器类上定义 `$connection`、`$queue` 或 `$delay` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        /**\r\n         * 任务将被发送到的连接的名称。\r\n         *\r\n         * @var string|null\r\n         */\r\n        public $connection = 'sqs';\r\n\r\n        /**\r\n         * 任务将被发送到的队列的名称。\r\n         *\r\n         * @var string|null\r\n         */\r\n        public $queue = 'listeners';\r\n\r\n        /**\r\n         * 任务被处理的延迟时间（秒）。\r\n         *\r\n         * @var int\r\n         */\r\n        public $delay = 60;\r\n    }\r\n\r\n如果您想在运行时定义监听器的队列连接或队列名称，您可以在监听器上定义 `viaConnection` 或 `viaQueue` 方法：\r\n\r\n    /**\r\n     * 获取监听器的队列连接名称。\r\n     *\r\n     * @return string\r\n     */\r\n    public function viaConnection()\r\n    {\r\n        return 'sqs';\r\n    }\r\n\r\n    /**\r\n     * 获取监听器队列的名称。\r\n     *\r\n     * @return string\r\n     */\r\n    public function viaQueue()\r\n    {\r\n        return 'listeners';\r\n    }\r\n\r\n\r\n\r\n<a name=\"conditionally-queueing-listeners\"></a>\r\n#### 条件监听队列\r\n\r\n有时，您可能需要根据一些仅在运行时可用的数据来确定监听器是否应该排队。为此，可以将 `shouldQueue` 方法添加到监听器中，以确定监听器是否应该排队。如果 `shouldQueue` 方法返回 `false`，则监听器将不会执行：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderCreated;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\n    class RewardGiftCard implements ShouldQueue\r\n    {\r\n        /**\r\n         * 给客户奖励礼品卡。\r\n         *\r\n         * @param  \\App\\Events\\OrderCreated  $event\r\n         * @return void\r\n         */\r\n        public function handle(OrderCreated $event)\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 确定监听器是否应加入队列。\r\n         *\r\n         * @param  \\App\\Events\\OrderCreated  $event\r\n         * @return bool\r\n         */\r\n        public function shouldQueue(OrderCreated $event)\r\n        {\r\n            return $event->order->subtotal >= 5000;\r\n        }\r\n    }\r\n\r\n<a name=\"manually-interacting-with-the-queue\"></a>\r\n### 手动访问队列\r\n\r\n如果你需要手动访问监听器下面队列任务的 `delete` 和 `release` 方法，可以使用 `Illuminate\\Queue\\InteractsWithQueue`trait 进行访问。默认情况下，此 trait 在生成的监听器上导入，并提供对以下方法的访问：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue;\r\n\r\n        /**\r\n         * 事件处理。\r\n         *\r\n         * @param  \\App\\Events\\OrderShipped  $event\r\n         * @return void\r\n         */\r\n        public function handle(OrderShipped $event)\r\n        {\r\n            if (true) {\r\n                $this->release(30);\r\n            }\r\n        }\r\n    }\r\n\r\n<a name=\"queued-event-listeners-and-database-transactions\"></a>\r\n### 排队事件监听器和数据库事务\r\n\r\n当在数据库事务中调度排队的监听器时，它们可能会在提交数据库事务之前由队列进行处理。发生这种情况时，您在数据库事务期间对模型或数据库记录所做的任何更新可能尚未反映在数据库中。此外，在事务中创建的任何模型或数据库记录可能不存在于数据库中。如果监听器依赖于这些模型，则在处理分派排队监听器的作业时，可能会发生意外错误。\r\n\r\n\r\n\r\n如果队列连接的 `after_commit` 配置选项设置为 `false`，则仍然可以通过在监听器类上定义 `$afterCommit` 属性来指示在提交所有打开的数据库事务之后应调度特定的队列监听器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue;\r\n\r\n        public $afterCommit = true;\r\n    }\r\n\r\n> 技巧：要了解有关解决这些问题的更多信息，请查看有关 [队列任务和数据库事务](/docs/laravel/9.x/queues#jobs-and-database-transactions).\r\n\r\n<a name=\"handling-failed-jobs\"></a>\r\n### 处理失败的队列\r\n\r\n有时队列的事件监听器可能会失败。如果排队的监听器超过了队列工作者定义的最大尝试次数，则将对监听器调用 `failed` 方法。`failed` 方法接收导致失败的事件实例和 `Throwable`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue;\r\n\r\n        /**\r\n         * 事件处理。\r\n         *\r\n         * @param  \\App\\Events\\OrderShipped  $event\r\n         * @return void\r\n         */\r\n        public function handle(OrderShipped $event)\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 处理失败任务。\r\n         *\r\n         * @param  \\App\\Events\\OrderShipped  $event\r\n         * @param  \\Throwable  $exception\r\n         * @return void\r\n         */\r\n        public function failed(OrderShipped $event, $exception)\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n<a name=\"specifying-queued-listener-maximum-attempts\"></a>\r\n#### 指定队列监听器的最大尝试次数\r\n\r\n如果队列中的某个监听器遇到错误，您可能不希望它无限期地重试。因此，Laravel 提供了各种方法来指定监听器的尝试次数或尝试时间。\r\n\r\n您可以在监听器类上定义 `$tries` 属性，以指定监听器在被认为失败之前可能尝试了多少次：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue;\r\n\r\n        /**\r\n         * 尝试队列监听器的次数\r\n         *\r\n         * @var int\r\n         */\r\n        public $tries = 5;\r\n    }\r\n\r\n\r\n\r\n作为定义侦听器在失败之前可以尝试多少次的替代方法，您可以定义不再尝试侦听器的时间。这允许在给定的时间范围内尝试多次监听。若要定义不再尝试监听器的时间，请在您的监听器类中添加 `retryUntil` 方法。此方法应返回一个 `DateTime` 实例：\r\n\r\n    /**\r\n     * 确定监听器应该超时的时间。\r\n     *\r\n     * @return \\DateTime\r\n     */\r\n    public function retryUntil()\r\n    {\r\n        return now()->addMinutes(5);\r\n    }\r\n\r\n<a name=\"dispatching-events\"></a>\r\n## 调度事件\r\n\r\n要分派一个事件，你可以在事件上调用静态的 `dispatch` 方法。这个方法是通过 ` Illuminate\\Foundation\\Events\\Dispatchable` 特性提供给事件的。 传递给 `dispatch` 方法的任何参数都将被传递给事件的构造函数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class OrderShipmentController extends Controller\r\n    {\r\n        /**\r\n         * 运送给定的订单。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $order = Order::findOrFail($request->order_id);\r\n\r\n            // 订单出货逻辑...\r\n\r\n            OrderShipped::dispatch($order);\r\n        }\r\n    }\r\n\r\n> 技巧：在测试时，断言某些事件是在没有实际触发其侦听器的情况下进行的会很有帮助。  Laravel 的 [内置助手](/docs/laravel/9.x/mocking#event-fake) 让他变得很简单。\r\n\r\n<a name=\"event-subscribers\"></a>\r\n## 事件订阅者\r\n\r\n<a name=\"writing-event-subscribers\"></a>\r\n### 构建事件订阅者\r\n\r\n事件订阅者是可以从订阅者类本身中订阅多个事件的类，允许你在单个类中定义多个事件处理程序。订阅者应该定义一个 `subscribe` 方法，它将被传递一个事件分派器实例。你可以在给定的分派器上调用 `listen` 方法来注册事件监听器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Illuminate\\Auth\\Events\\Login;\r\n    use Illuminate\\Auth\\Events\\Logout;\r\n\r\n    class UserEventSubscriber\r\n    {\r\n        /**\r\n         * 处理用户登录事件。\r\n         */\r\n        public function handleUserLogin($event) {}\r\n\r\n        /**\r\n         * 处理用户退出事件。\r\n         */\r\n        public function handleUserLogout($event) {}\r\n\r\n        /**\r\n         * 为订阅者注册侦听器。\r\n         *\r\n         * @param  \\Illuminate\\Events\\Dispatcher  $events\r\n         * @return void\r\n         */\r\n        public function subscribe($events)\r\n        {\r\n            $events->listen(\r\n                Login::class,\r\n                [UserEventSubscriber::class, 'handleUserLogin']\r\n            );\r\n\r\n            $events->listen(\r\n                Logout::class,\r\n                [UserEventSubscriber::class, 'handleUserLogout']\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n\r\n如果你的事件监听器方法是在订阅者本身中定义的，你可能会发现从订阅者的 `subscribe` 方法返回一组事件和方法名称更方便。 Laravel 在注册事件监听器时会自动判断订阅者的类名：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Illuminate\\Auth\\Events\\Login;\r\n    use Illuminate\\Auth\\Events\\Logout;\r\n\r\n    class UserEventSubscriber\r\n    {\r\n        /**\r\n         * 处理用户登录事件。\r\n         */\r\n        public function handleUserLogin($event) {}\r\n\r\n        /**\r\n         * 处理用户退出事件。\r\n         */\r\n        public function handleUserLogout($event) {}\r\n\r\n        /**\r\n         * 为订阅者注册侦听器。\r\n         *\r\n         * @param  \\Illuminate\\Events\\Dispatcher  $events\r\n         * @return array\r\n         */\r\n        public function subscribe($events)\r\n        {\r\n            return [\r\n                Login::class => 'handleUserLogin',\r\n                Logout::class => 'handleUserLogout',\r\n            ];\r\n        }\r\n    }\r\n\r\n<a name=\"registering-event-subscribers\"></a>\r\n### 注册事件订阅者\r\n\r\n当编写完订阅者后，你已经准备好为事件分发器注册它们了。你可以使用 `EventServiceProvider` 上的 `$subscribe` 属性来注册订阅者。例如，让我们将 `UserEventSubscriber` 添加到列表中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Listeners\\UserEventSubscriber;\r\n    use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\n\r\n    class EventServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 应用的事件监听器映射\r\n         *\r\n         * @var array\r\n         */\r\n        protected $listen = [\r\n            //\r\n        ];\r\n\r\n        /**\r\n         * 被注册的订阅者类\r\n         *\r\n         * @var array\r\n         */\r\n        protected $subscribe = [\r\n            UserEventSubscriber::class,\r\n        ];\r\n    }\r\n\r\n","p":"docs/events.html"},{"t":"filesystem (文件存储)","d":"# 文件存储\r\n\r\n- [简介](#introduction)\r\n- [配置](#configuration)\r\n    - [本地驱动](#the-local-driver)\r\n    - [公共磁盘](#the-public-disk)\r\n    - [驱动要求](#driver-prerequisites)\r\n    - [Amazon S3 兼容文件系统](#amazon-s3-compatible-filesystems)\r\n- [获取磁盘实例](#obtaining-disk-instances)\r\n    - [按需配置磁盘](#on-demand-disks)\r\n- [检索文件](#retrieving-files)\r\n    - [下载文件](#downloading-files)\r\n    - [文件 URL](#file-urls)\r\n    - [文件元数据](#file-metadata)\r\n- [保存文件](#storing-files)\r\n    - [文件上传](#file-uploads)\r\n    - [文件可见性](#file-visibility)\r\n- [删除文件](#deleting-files)\r\n- [目录](#directories)\r\n- [自定义文件系统](#custom-filesystems)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 提供了一个强大的文件系统抽象概念，这得益于 Frank de Jonge 强大的 [Flysystem](https://github.com/thephpleague/flysystem) 扩展包。Laravel 文件系统集成为使用本地文件系统、SFTP 和 Amazon S3 提供了简单易用的驱动程序。 更棒的是，由于每个系统的 API 保持不变，所以在这些存储选项之间切换是非常简单的。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\nLaravel 文件系统的配置文件位于 `config/filesystems.php`。在这个文件中你可以配置所有的「磁盘」。每个磁盘代表特定的存储驱动及存储位置。每种支持的驱动程序的示例配置都包含在配置文件中。因此，只需要修改配置即可应用你的存储偏好和凭据。\r\n\r\n`local` 驱动用于操作本地服务器的文件，而 `s3` 驱动用于操作在 Amazon S3 云存储服务上的文件。\r\n\r\n> 技巧：你可以配置任意数量的磁盘，甚至可以添加多个使用相同驱动的磁盘。\r\n\r\n\r\n\r\n<a name=\"the-local-driver\"></a>\r\n### 本地驱动\r\n\r\n使用 `local` 驱动时，所有文件操作都与 `filesystems` 配置文件中定义的 `root` 目录相关。 默认情况下，此值设置为 `storage/app` 目录。因此，以下方法会把文件存储在 `storage/app/example.txt` 中：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::disk('local')->put('example.txt', 'Contents');\r\n\r\n<a name=\"the-public-disk\"></a>\r\n### 公共磁盘\r\n\r\n在 `filesystems` 配置文件中定义的 `public` 磁盘适用于要公开访问的文件。默认情况下， `public` 磁盘使用 `local` 驱动，并且将这些文件存储在 `storage/app/public` 目录下。\r\n\r\n为了让它们能通过网络访问，你需要创建从 `public/storage` 到 `storage/app/public` 的符号链接。这种方式能把可公开访问文件都保留在同一个目录下，以便在使用零停机时间部署系统如 [Envoyer](https://envoyer.io) 的时候，就可以轻松地在不同的部署之间共享这些文件。\r\n\r\n你可以使用 Artisan 命令 `storage:link` 来创建符号链接：\r\n\r\n```shell\r\nphp artisan storage:link\r\n```\r\n\r\n一旦一个文件被存储并且已经创建了符号链接，你就可以使用辅助函数 `asset` 来创建文件的 URL：\r\n\r\n    echo asset('storage/file.txt');\r\n\r\n你可以在 `filesystems` 配置文件中配置额外的符号链接。这些链接将会在运行 `storage:link` 命令时自动创建：\r\n\r\n    'links' => [\r\n        public_path('storage') => storage_path('app/public'),\r\n        public_path('images') => storage_path('app/images'),\r\n    ],\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n\r\n\r\n### 驱动要求\r\n\r\n<a name=\"s3-driver-configuration\"></a>\r\n#### S3 驱动配置\r\n\r\n在使用 S3 驱动之前，你需要通过 Composer 安装相应的软件包：\r\n\r\n```shell\r\ncomposer require -W league/flysystem-aws-s3-v3 \"^3.0\"\r\n```\r\n\r\nS3 驱动配置信息位于 `config/filesystems.php` 配置文件中。该文件包含 S3 驱动程序的示例配置数组。你可以自由使用你自己的 S3 配置和凭证修改此配置数组。为了方便起见，这些环境变量与 AWS CLI 使用的命名约定一致。\r\n\r\n<a name=\"ftp-driver-configuration\"></a>\r\n#### FTP 驱动配置\r\n\r\n在使用 FTP 驱动之前，你需要通过 Composer 安装相应的软件包：\r\n\r\n```shell\r\ncomposer require league/flysystem-ftp \"^3.0\"\r\n```\r\n\r\nLaravel 的文件系统能很好的适配 FTP，不过 FTP 的配置示例并没有被包含在框架默认的 `filesystems.php` 配置文件中。如果你需要配置 FTP 文件系统，你可以参考下方的例子：\r\n\r\n    'ftp' => [\r\n        'driver' => 'ftp',\r\n        'host' => env('FTP_HOST'),\r\n        'username' => env('FTP_USERNAME'),\r\n        'password' => env('FTP_PASSWORD'),\r\n\r\n        // 可选的 FTP 设置\r\n        // 'port' => env('FTP_PORT', 21),\r\n        // 'root' => env('FTP_ROOT'),\r\n        // 'passive' => true,\r\n        // 'ssl' => true,\r\n        // 'timeout' => 30,\r\n    ],\r\n\r\n<a name=\"sftp-driver-configuration\"></a>\r\n#### SFTP 驱动配置\r\n\r\n在使用 SFTP 驱动之前，你需要通过 Composer 安装相应的软件包：\r\n\r\n```shell\r\ncomposer require league/flysystem-sftp-v3 \"^3.0\"\r\n```\r\n\r\nLaravel 的文件系统能很好的适配 SFTP，不过 SFTP 的配置示例并没有被包含在框架默认的 `filesystems.php` 配置文件中。如果你需要配置 SFTP 文件系统，你可以参考下方的例子：\r\n\r\n    'sftp' => [\r\n        'driver' => 'sftp',\r\n        'host' => env('SFTP_HOST'),\r\n\r\n        // 基于基础的身份验证设置...\r\n        'username' => env('SFTP_USERNAME'),\r\n        'password' => env('SFTP_PASSWORD'),\r\n\r\n        // 使用加密密码进行基于 SSH 密钥的身份验证的设置...\r\n        'privateKey' => env('SFTP_PRIVATE_KEY'),\r\n        'password' => env('SFTP_PASSWORD'),\r\n\r\n        // 可选的 SFTP 设置\r\n        // 'port' => env('SFTP_PORT', 22),\r\n        // 'root' => env('SFTP_ROOT', ''),\r\n        // 'timeout' => 30,\r\n    ],\r\n\r\n\r\n\r\n<a name=\"amazon-s3-compatible-filesystems\"></a>\r\n### Amazon S3 兼容文件系统\r\n\r\n默认情况下，应用程序的 `filesystems` 配置文件包含 `s3` 磁盘的磁盘配置。除了使用此磁盘与 Amazon S3 交互外，你还可以使用它与任何 S3 兼容的文件存储服务进行交互，例如 [MinIO](https://github.com/minio/minio) 或 [DigitalOcean Spaces](https://www.digitalocean.com/products/spaces/)。\r\n\r\n通常，在更新磁盘的凭据以匹配你计划使用的服务的凭据后，你只需要更新 `url` 配置选项的值。此选项的值通常通过 `AWS_ENDPOINT` 环境变量定义：\r\n\r\n    'endpoint' => env('AWS_ENDPOINT', 'https://minio:9000'),\r\n\r\n<a name=\"obtaining-disk-instances\"></a>\r\n## 获取磁盘实例\r\n\r\n`Storage` Facade 可用于与所有已配置的磁盘进行交互。例如，你可以使用 Facade 中的 `put` 方法将头像存储到默认磁盘。如果你使用 `Storage` Facade 时并没有使用 `disk` 方法，那么所有的方法调用将会自动传递给默认的磁盘：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::put('avatars/1', $content);\r\n\r\n如果应用要与多个磁盘进行交互，可使用 `Storage` Facade 中的 `disk` 方法对特定磁盘上的文件进行操作：\r\n\r\n    Storage::disk('s3')->put('avatars/1', $content);\r\n\r\n<a name=\"on-demand-disks\"></a>\r\n### 按需配置磁盘\r\n\r\n有时你可能希望在运行时使用给定配置创建磁盘，而该配置实际上不存在于应用程序的「文件系统」配置文件中。为此，你可以将配置数组传递给 `Storage` 门面的 `build` 方法：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Storage;\r\n\r\n$disk = Storage::build([\r\n    'driver' => 'local',\r\n    'root' => '/path/to/root',\r\n]);\r\n\r\n$disk->put('image.jpg', $content);\r\n```\r\n\r\n\r\n\r\n<a name=\"retrieving-files\"></a>\r\n## 检索文件\r\n\r\n`get` 方法可以用于获取文件的内容，此方法返回该文件的原始字符串内容。切记，所有文件路径的指定都应该相对于该磁盘所配置的「root」目录：\r\n\r\n    $contents = Storage::get('file.jpg');\r\n\r\n`exists` 方法可以用来判断磁盘上是否存在指定的文件：\r\n\r\n    if (Storage::disk('s3')->exists('file.jpg')) {\r\n        // ...\r\n    }\r\n\r\n`missing` 方法可以用来判断磁盘上是否缺少指定的文件：\r\n\r\n    if (Storage::disk('s3')->missing('file.jpg')) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"downloading-files\"></a>\r\n### 下载文件\r\n\r\n`download` 方法可用于生成响应，该响应强制用户的浏览器在给定路径下下载文件。`download` 方法接受文件名作为该方法的第二个参数，它将确定下载文件的用户看到的文件名。最后，你可以将 HTTP 标头数组作为该方法的第三个参数传递：\r\n\r\n    return Storage::download('file.jpg');\r\n\r\n    return Storage::download('file.jpg', $name, $headers);\r\n\r\n<a name=\"file-urls\"></a>\r\n### 文件地址\r\n\r\n你可以使用 `url` 方法来获取给定文件的 url。如果你使用的是 `local` 驱动程序，这通常会将 `/storage` 添加到给定的路径，并返回文件的相对 URL。如果你使用的是 `s3` 驱动程序，则会返回完全限定的远程URL：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $url = Storage::url('file.jpg');\r\n\r\n\r\n\r\n当使用 `local` 驱动程序时，所有应该公开访问的文件应该放在 `storage/app/public` 目录下。此外，你应该在 `public/storage` 处[创建一个符号链接](#the-public-disk)，它指向 `storage/app/public` 目录。\r\n\r\n> 注意：当使用 `local` 驱动时， `url` 的返回值不是 url 编码的。因此，我们建议总是使用可以创建有效 url 的名称来存储文件。\r\n\r\n<a name=\"temporary-urls\"></a>\r\n#### 临时地址\r\n\r\n使用 `temporaryUrl` 方法，你可以为使用 `s3` 驱动程序存储的文件创建临时 URL 。此方法接受一个路径和一个 `DateTime` 实例，指定 URL 何时应过期：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $url = Storage::temporaryUrl(\r\n        'file.jpg', now()->addMinutes(5)\r\n    );\r\n\r\n如果需要指定其他 [S3 请求参数](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html#RESTObjectGET-requests) ,你可以将请求参数数组作为第三个参数传递给 `temporaryUrl` 方法：\r\n\r\n    $url = Storage::temporaryUrl(\r\n        'file.jpg',\r\n        now()->addMinutes(5),\r\n        [\r\n            'ResponseContentType' => 'application/octet-stream',\r\n            'ResponseContentDisposition' => 'attachment; filename=file2.jpg',\r\n        ]\r\n    );\r\n\r\n如果你需要自定义如何为特定存储磁盘创建临时 URL，可以使用 `buildTemporaryUrlsUsing` 方法。例如，如果你有一个控制器允许你下载通过通常不支持临时 URL 的磁盘存储的文件，这可能会很有用。通常，应该从服务提供者的 `boot` 方法调用此方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n    use Illuminate\\Support\\Facades\\URL;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * Bootstrap any application services.\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Storage::disk('local')->buildTemporaryUrlsUsing(function ($path, $expiration, $options) {\r\n                return URL::temporarySignedRoute(\r\n                    'files.download',\r\n                    $expiration,\r\n                    array_merge($options, ['path' => $path])\r\n                );\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"url-host-customization\"></a>\r\n#### 定制路径的 Host\r\n\r\n如果要为使用 `Storage` Facade 生成的 url 预定义 Host，可以向磁盘的配置数组中添加 `url` 选项：\r\n\r\n    'public' => [\r\n        'driver' => 'local',\r\n        'root' => storage_path('app/public'),\r\n        'url' => env('APP_URL').'/storage',\r\n        'visibility' => 'public',\r\n    ],\r\n\r\n<a name=\"file-metadata\"></a>\r\n### 文件 Metadata 信息\r\n\r\n除了读写文件，Laravel 还可以提供有关文件自身的信息。例如，`size` 方法可用于获取文件的大小(以字节为单位)：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $size = Storage::size('file.jpg');\r\n\r\n`lastModified` 方法返回上次修改文件时的时间戳：\r\n\r\n    $time = Storage::lastModified('file.jpg');\r\n\r\n<a name=\"file-paths\"></a>\r\n#### 文件路径\r\n\r\n可以使用 `path` 方法获取给定文件的路径。如果你使用的是 `local` 驱动程序，这将返回文件的绝对路径。如果你使用的是 `s3` 驱动程序，此方法将返回 s3 bucket 中文件的相对路径：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $path = Storage::path('file.jpg');\r\n\r\n<a name=\"storing-files\"></a>\r\n## 储存文件\r\n\r\n可以使用 `put` 方法将文件内容存储在磁盘上。你还可以将 PHP `resource` 传递给 `put` 方法，该方法将使用 Flysystem 的底层流支持。请记住，应相对于为磁盘配置的根目录指定所有文件路径：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::put('file.jpg', $contents);\r\n\r\n    Storage::put('file.jpg', $resource);\r\n\r\n\r\n\r\n<a name=\"automatic-streaming\"></a>\r\n#### 自动流存储\r\n\r\n将文件流式传输到存储可显著减少内存使用。如果希望 Laravel 自动管理将给定文件流式传输到存储位置，可以使用 `putFile` 或 `putFileAs` 方法。此方法接受 `Illuminate\\Http\\File` 或 `Illuminate\\Http\\UploadedFile` 实例，并自动将文件流式传输到所需位置：\r\n\r\n    use Illuminate\\Http\\File;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    // 自动生成一个唯一文件名 ...\r\n    $path = Storage::putFile('photos', new File('/path/to/photo'));\r\n\r\n    // 手动指定文件名 ...\r\n    $path = Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg');\r\n\r\n关于 `putFile` 方法，有一些重要的事情需要注意。那就是，我们只指定了一个目录名，而没有指定文件名。默认情况下，`putFile` 方法将生成一个唯一的 ID 作为文件名。文件的扩展名将通过检查文件的 MIME 类型来确定。`putFile` 方法将返回文件的路径，以便你可以将路径（包括生成的文件名）存储在数据库中。\r\n\r\n`putFile` 和 `putFileAs` 方法还接受一个参数来指定存储文件的 「可见性」。如果你将文件存储在云磁盘（如 Amazon S3）上，并且希望通过生成的 URL 公开访问该文件，则这一点特别有用：\r\n\r\n    Storage::putFile('photos', new File('/path/to/photo'), 'public');\r\n\r\n<a name=\"prepending-appending-to-files\"></a>\r\n#### 追加内容到文件开头或结尾\r\n\r\n `prepend` 和 `append` 方法允许你将内容写入文件的开头或结尾：\r\n\r\n    Storage::prepend('file.log', 'Prepended Text');\r\n\r\n    Storage::append('file.log', 'Appended Text');\r\n\r\n\r\n\r\n<a name=\"copying-moving-files\"></a>\r\n#### 复制 / 移动文件\r\n\r\n`copy` 方法可用于将现有文件复制到磁盘上的新位置，而 `move` 方法可用于重命名现有文件或将其移动到新位置：\r\n\r\n    Storage::copy('old/file.jpg', 'new/file.jpg');\r\n\r\n    Storage::move('old/file.jpg', 'new/file.jpg');\r\n\r\n<a name=\"file-uploads\"></a>\r\n### 文件上传\r\n\r\n在 web 应用程序中，存储文件最常见的用例之一是存储用户上传的文件，如照片和文档。Laravel 使得在上传的文件实例上使用 `store` 方法存储上传的文件变得非常容易。可以在要存储的上传文件上调用 `store` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserAvatarController extends Controller\r\n    {\r\n        /**\r\n         * 更新用户头像\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function update(Request $request)\r\n        {\r\n            $path = $request->file('avatar')->store('avatars');\r\n\r\n            return $path;\r\n        }\r\n    }\r\n\r\n关于这个例子，有一些重要的事情需要注意。那就是，我们只指定了一个目录名，而不是文件名。默认情况下，`store` 方法将生成一个唯一的 ID 作为文件名。文件的扩展名将通过检查文件的 MIME 类型来确定。文件的路径将由 `store` 方法返回，因此你可以将路径（包括生成的文件名）存储在数据库中。\r\n\r\n你还可以调用 `Storage` facade上的 `putFile` 方法来执行与上述示例相同的文件存储操作：\r\n\r\n    $path = Storage::putFile('avatars', $request->file('avatar'));\r\n\r\n\r\n\r\n<a name=\"specifying-a-file-name\"></a>\r\n#### 指定一个文件名\r\n\r\n如果不希望文件名自动分配给存储的文件，可以使用 `storeAs` 方法，该方法接收路径、文件名和（可选）磁盘作为参数：\r\n\r\n    $path = $request->file('avatar')->storeAs(\r\n        'avatars', $request->user()->id\r\n    );\r\n\r\n你还可以在 `Storage` facade 上使用 `putFileAs` 方法，该方法将执行与上述示例相同的文件存储操作：\r\n\r\n    $path = Storage::putFileAs(\r\n        'avatars', $request->file('avatar'), $request->user()->id\r\n    );\r\n\r\n> 注意：无法打印和无效的 unicode 字符将自动从文件路径中删除。因此，您可能希望在将文件路径传递给Laravel的文件存储方法之前对其进行清理。使用'League\\Flysystem\\Util:：normalizePath'方法规范化文件路径。\r\n\r\n<a name=\"specifying-a-disk\"></a>\r\n#### 指定一个磁盘\r\n\r\n默认情况下，此上载文件的 `store` 方法将使用默认磁盘。如果要指定另一个磁盘，请将磁盘名作为第二个参数传递给 `store` 方法：\r\n\r\n    $path = $request->file('avatar')->store(\r\n        'avatars/'.$request->user()->id, 's3'\r\n    );\r\n\r\n如果使用的是 `storeAs` 方法，则可以将磁盘名作为第三个参数传递给该方法：\r\n\r\n    $path = $request->file('avatar')->storeAs(\r\n        'avatars',\r\n        $request->user()->id,\r\n        's3'\r\n    );\r\n\r\n<a name=\"other-uploaded-file-information\"></a>\r\n#### 其他上传文件信息\r\n\r\n如果你想获取上传文件的原始名称和扩展名，可以使用 `getClientOriginalName` 和 `getClientOriginalExtension` 方法：\r\n\r\n    $file = $request->file('avatar');\r\n\r\n    $name = $file->getClientOriginalName();\r\n    $extension = $file->getClientOriginalExtension();\r\n\r\n\r\n\r\n但是，请记住，`getClientOriginalName` 和 `getClientOriginalExtension` 方法被认为是不安全的，因为文件名和扩展名可能被恶意用户篡改。出于这个原因，你应该更喜欢 `hashName` 和 `extension` 方法来获取给定文件上传的名称和扩展名：\r\n\r\n    $file = $request->file('avatar');\r\n\r\n    $name = $file->hashName(); // 生成一个唯一的随机名称...\r\n    $extension = $file->extension(); // 根据文件的 MIME 类型确定文件的扩展名...\r\n\r\n<a name=\"file-visibility\"></a>\r\n### 文件的可见性\r\n\r\n在 Laravel 继承的文件系统中，「可见性」是一个针对多平台的权限的抽象概念。文件可以定义为 `public` 或 `private` 。当文件被定义为 `public` 时，意味着其他人可以访问之。例如，当您使用 S3 驱动的时候，你可以检索声明为 `public` 的文件的 URL 。\r\n\r\n在使用 `put` 方法的时候，你可以设置文件的可见性：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::put('file.jpg', $contents, 'public');\r\n\r\n你可以使用 `getVisibility` 和 `setVisibility` 方法对现有文件的可见性进行检索和设置：\r\n\r\n    $visibility = Storage::getVisibility('file.jpg');\r\n\r\n    Storage::setVisibility('file.jpg', 'public');\r\n\r\n当和上传文件交互的时候，你可以使用 `storePublicly` 和 `storePubliclyAs` 方法来将文件的可见性设置为 `public` 并存储之：\r\n\r\n    $path = $request->file('avatar')->storePublicly('avatars', 's3');\r\n\r\n    $path = $request->file('avatar')->storePubliclyAs(\r\n        'avatars',\r\n        $request->user()->id,\r\n        's3'\r\n    );\r\n\r\n<a name=\"local-files-and-visibility\"></a>\r\n#### 本地文件 & 可见性\r\n\r\n当使用 `local` 驱动程序时，`public` [文件的可见性](#file-visibility) 转换文件和目录的权限 为 `0755` 的 `0644` 权限。 你可以在应用程序的 `filesystems` 配置文件中修改权限配置：\r\n\r\n    'local' => [\r\n        'driver' => 'local',\r\n        'root' => storage_path('app'),\r\n        'permissions' => [\r\n            'file' => [\r\n                'public' => 0644,\r\n                'private' => 0600,\r\n            ],\r\n            'dir' => [\r\n                'public' => 0755,\r\n                'private' => 0700,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n\r\n\r\n<a name=\"deleting-files\"></a>\r\n## 删除文件\r\n\r\n`delete` 方法接收一个文件名或一个文件名数组来将其从磁盘中删除：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::delete('file.jpg');\r\n\r\n    Storage::delete(['file.jpg', 'file2.jpg']);\r\n\r\n如果有必要，你可以指定删除的文件的磁盘：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::disk('s3')->delete('path/file.jpg');\r\n\r\n<a name=\"directories\"></a>\r\n## 目录\r\n\r\n<a name=\"get-all-files-within-a-directory\"></a>\r\n#### 获取目录下所有的文件\r\n\r\n`files` 将以数组的形式返回给定目录下所有的文件。如果你想要检索给定目录的所有文件及其子目录的所有文件，你可以使用 `allFiles` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $files = Storage::files($directory);\r\n\r\n    $files = Storage::allFiles($directory);\r\n\r\n<a name=\"get-all-directories-within-a-directory\"></a>\r\n#### 获取特定目录下的子目录\r\n\r\n`directories` 方法以数组的形式返回给定目录中的所有目录。此外，你还可以使用 `allDirectories` 方法递归地获取给定目录中的所有目录及其子目录中的目录：\r\n\r\n    $directories = Storage::directories($directory);\r\n\r\n    $directories = Storage::allDirectories($directory);\r\n\r\n<a name=\"create-a-directory\"></a>\r\n#### 创建一个目录\r\n\r\n`makeDirectory` 方法可递归的创建指定的目录：\r\n\r\n    Storage::makeDirectory($directory);\r\n\r\n<a name=\"delete-a-directory\"></a>\r\n#### 删除一个目录\r\n\r\n最后，`deleteDirectory` 方法可用于删除一个目录及其下所有的文件：\r\n\r\n    Storage::deleteDirectory($directory);\r\n\r\n<a name=\"custom-filesystems\"></a>\r\n## 自定义文件系统\r\n\r\nLaravel 内置的文件系统提供了一些开箱即用的驱动；当然，它不仅仅是这些，它还提供了与其他存储系统的适配器。通过这些适配器，你可以在你的 Laravel 应用中创建自定义驱动。\r\n\r\n\r\n\r\n要安装自定义文件系统，你可能需要一个文件系统适配器。让我们将社区维护的 Dropbox 适配器添加到项目中：\r\n\r\n```shell\r\ncomposer require spatie/flysystem-dropbox\r\n```\r\n\r\n接下来，你可以创建一个诸如 `DropboxServiceProvider` 这样的 [服务提供者](/docs/laravel/9.x/providers) 。在提供者的 `boot` 方法中，你可以使用 `Storage` 门面的 `extend` 方法来定义一个自定义驱动：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Filesystem\\FilesystemAdapter;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use League\\Flysystem\\Filesystem;\r\n    use Spatie\\Dropbox\\Client as DropboxClient;\r\n    use Spatie\\FlysystemDropbox\\DropboxAdapter;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Storage::extend('dropbox', function ($app, $config) {\r\n                $adapter = new DropboxAdapter(new DropboxClient(\r\n                    $config['authorization_token']\r\n                ));\r\n\r\n                return new FilesystemAdapter(\r\n                    new Filesystem($adapter, $config),\r\n                    $adapter,\r\n                    $config\r\n                );\r\n            });\r\n        }\r\n    }\r\n\r\n`extend` 方法的第一个参数是驱动程序的名称，第二个参数是接收 `$app` 和 `$config` 变量的闭包。闭包必须返回的实例 `League\\Flysystem\\Filesystem`。`$config` 变量包含 `config/filesystems.php` 为指定磁盘定义的值。\r\n\r\n一旦创建并注册了扩展的服务提供商，就可以 `dropbox` 在 `config/filesystems.php` 配置文件中使用该驱动程序。\r\n\r\n","p":"docs/filesystem.html"},{"t":"helpers (辅助函数)","d":"# 辅助函数\r\n\r\n- [简介](#introduction)\r\n- [可用方法](#available-methods)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 包含各种各样的全局 PHP 「辅助」函数，框架本身也大量的使用了这些功能函数；如果你觉的方便，你可以在你的应用中任意使用这些函数。\r\n\r\n<a name=\"available-methods\"></a>\r\n## 可用方法\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\r\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n    }\r\n</style>\r\n\r\n<a name=\"arrays-and-objects-method-list\"></a>\r\n### 数组 & 对象\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[Arr::accessible](#method-array-accessible)\r\n[Arr::add](#method-array-add)\r\n[Arr::collapse](#method-array-collapse)\r\n[Arr::crossJoin](#method-array-crossjoin)\r\n[Arr::divide](#method-array-divide)\r\n[Arr::dot](#method-array-dot)\r\n[Arr::except](#method-array-except)\r\n[Arr::exists](#method-array-exists)\r\n[Arr::first](#method-array-first)\r\n[Arr::flatten](#method-array-flatten)\r\n[Arr::forget](#method-array-forget)\r\n[Arr::get](#method-array-get)\r\n[Arr::has](#method-array-has)\r\n[Arr::hasAny](#method-array-hasany)\r\n[Arr::isAssoc](#method-array-isassoc)\r\n[Arr::isList](#method-array-islist)\r\n[Arr::keyBy](#method-array-keyby)\r\n[Arr::last](#method-array-last)\r\n[Arr::only](#method-array-only)\r\n[Arr::pluck](#method-array-pluck)\r\n[Arr::prepend](#method-array-prepend)\r\n[Arr::pull](#method-array-pull)\r\n[Arr::query](#method-array-query)\r\n[Arr::random](#method-array-random)\r\n[Arr::set](#method-array-set)\r\n[Arr::shuffle](#method-array-shuffle)\r\n[Arr::sort](#method-array-sort)\r\n[Arr::sortRecursive](#method-array-sort-recursive)\r\n[Arr::toCssClasses](#method-array-to-css-classes)\r\n[Arr::undot](#method-array-undot)\r\n[Arr::where](#method-array-where)\r\n[Arr::whereNotNull](#method-array-where-not-null)\r\n[Arr::wrap](#method-array-wrap)\r\n[data_fill](#method-data-fill)\r\n[data_get](#method-data-get)\r\n[data_set](#method-data-set)\r\n[head](#method-head)\r\n[last](#method-last)\r\n\r\n</div>\r\n\r\n<a name=\"paths-method-list\"></a>\r\n### 路径\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[app_path](#method-app-path)\r\n[base_path](#method-base-path)\r\n[config_path](#method-config-path)\r\n[database_path](#method-database-path)\r\n[mix](#method-mix)\r\n[public_path](#method-public-path)\r\n[resource_path](#method-resource-path)\r\n[storage_path](#method-storage-path)\r\n\r\n</div>\r\n\r\n<a name=\"strings-method-list\"></a>\r\n### 字符串\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[\\__](#method-__)\r\n[class_basename](#method-class-basename)\r\n[e](#method-e)\r\n[preg_replace_array](#method-preg-replace-array)\r\n[Str::after](#method-str-after)\r\n[Str::afterLast](#method-str-after-last)\r\n[Str::ascii](#method-str-ascii)\r\n[Str::before](#method-str-before)\r\n[Str::beforeLast](#method-str-before-last)\r\n[Str::between](#method-str-between)\r\n[Str::camel](#method-camel-case)\r\n[Str::contains](#method-str-contains)\r\n[Str::containsAll](#method-str-contains-all)\r\n[Str::endsWith](#method-ends-with)\r\n[Str::excerpt](#method-excerpt)\r\n[Str::finish](#method-str-finish)\r\n[Str::headline](#method-str-headline)\r\n[Str::is](#method-str-is)\r\n[Str::isAscii](#method-str-is-ascii)\r\n[Str::isUuid](#method-str-is-uuid)\r\n[Str::kebab](#method-kebab-case)\r\n[Str::length](#method-str-length)\r\n[Str::limit](#method-str-limit)\r\n[Str::lower](#method-str-lower)\r\n[Str::markdown](#method-str-markdown)\r\n[Str::mask](#method-str-mask)\r\n[Str::orderedUuid](#method-str-ordered-uuid)\r\n[Str::padBoth](#method-str-padboth)\r\n[Str::padLeft](#method-str-padleft)\r\n[Str::padRight](#method-str-padright)\r\n[Str::plural](#method-str-plural)\r\n[Str::pluralStudly](#method-str-plural-studly)\r\n[Str::random](#method-str-random)\r\n[Str::remove](#method-str-remove)\r\n[Str::replace](#method-str-replace)\r\n[Str::replaceArray](#method-str-replace-array)\r\n[Str::replaceFirst](#method-str-replace-first)\r\n[Str::replaceLast](#method-str-replace-last)\r\n[Str::reverse](#method-str-reverse)\r\n[Str::singular](#method-str-singular)\r\n[Str::slug](#method-str-slug)\r\n[Str::snake](#method-snake-case)\r\n[Str::start](#method-str-start)\r\n[Str::startsWith](#method-starts-with)\r\n[Str::studly](#method-studly-case)\r\n[Str::substr](#method-str-substr)\r\n[Str::substrCount](#method-str-substrcount)\r\n[Str::substrReplace](#method-str-substrreplace)\r\n[Str::swap](#method-str-swap)\r\n[Str::title](#method-title-case)\r\n[Str::toHtmlString](#method-str-to-html-string)\r\n[Str::ucfirst](#method-str-ucfirst)\r\n[Str::upper](#method-str-upper)\r\n[Str::uuid](#method-str-uuid)\r\n[Str::wordCount](#method-str-word-count)\r\n[Str::words](#method-str-words)\r\n[str](#method-str)\r\n[trans](#method-trans)\r\n[trans_choice](#method-trans-choice)\r\n\r\n</div>\r\n\r\n<a name=\"fluent-strings-method-list\"></a>\r\n### 字符流处理\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[after](#method-fluent-str-after)\r\n[afterLast](#method-fluent-str-after-last)\r\n[append](#method-fluent-str-append)\r\n[ascii](#method-fluent-str-ascii)\r\n[basename](#method-fluent-str-basename)\r\n[before](#method-fluent-str-before)\r\n[beforeLast](#method-fluent-str-before-last)\r\n[between](#method-fluent-str-between)\r\n[camel](#method-fluent-str-camel)\r\n[contains](#method-fluent-str-contains)\r\n[containsAll](#method-fluent-str-contains-all)\r\n[dirname](#method-fluent-str-dirname)\r\n[endsWith](#method-fluent-str-ends-with)\r\n[excerpt](#method-fluent-str-excerpt)\r\n[exactly](#method-fluent-str-exactly)\r\n[explode](#method-fluent-str-explode)\r\n[finish](#method-fluent-str-finish)\r\n[is](#method-fluent-str-is)\r\n[isAscii](#method-fluent-str-is-ascii)\r\n[isEmpty](#method-fluent-str-is-empty)\r\n[isNotEmpty](#method-fluent-str-is-not-empty)\r\n[isUuid](#method-fluent-str-is-uuid)\r\n[kebab](#method-fluent-str-kebab)\r\n[length](#method-fluent-str-length)\r\n[limit](#method-fluent-str-limit)\r\n[lower](#method-fluent-str-lower)\r\n[ltrim](#method-fluent-str-ltrim)\r\n[markdown](#method-fluent-str-markdown)\r\n[mask](#method-fluent-str-mask)\r\n[match](#method-fluent-str-match)\r\n[matchAll](#method-fluent-str-match-all)\r\n[padBoth](#method-fluent-str-padboth)\r\n[padLeft](#method-fluent-str-padleft)\r\n[padRight](#method-fluent-str-padright)\r\n[pipe](#method-fluent-str-pipe)\r\n[plural](#method-fluent-str-plural)\r\n[prepend](#method-fluent-str-prepend)\r\n[remove](#method-fluent-str-remove)\r\n[replace](#method-fluent-str-replace)\r\n[replaceArray](#method-fluent-str-replace-array)\r\n[replaceFirst](#method-fluent-str-replace-first)\r\n[replaceLast](#method-fluent-str-replace-last)\r\n[replaceMatches](#method-fluent-str-replace-matches)\r\n[rtrim](#method-fluent-str-rtrim)\r\n[scan](#method-fluent-str-scan)\r\n[singular](#method-fluent-str-singular)\r\n[slug](#method-fluent-str-slug)\r\n[snake](#method-fluent-str-snake)\r\n[split](#method-fluent-str-split)\r\n[start](#method-fluent-str-start)\r\n[startsWith](#method-fluent-str-starts-with)\r\n[studly](#method-fluent-str-studly)\r\n[substr](#method-fluent-str-substr)\r\n[substrReplace](#method-fluent-str-substrreplace)\r\n[swap](#method-fluent-str-swap)\r\n[tap](#method-fluent-str-tap)\r\n[test](#method-fluent-str-test)\r\n[title](#method-fluent-str-title)\r\n[trim](#method-fluent-str-trim)\r\n[ucfirst](#method-fluent-str-ucfirst)\r\n[upper](#method-fluent-str-upper)\r\n[when](#method-fluent-str-when)\r\n[whenContains](#method-fluent-str-when-contains)\r\n[whenContainsAll](#method-fluent-str-when-contains-all)\r\n[whenEmpty](#method-fluent-str-when-empty)\r\n[whenNotEmpty](#method-fluent-str-when-not-empty)\r\n[whenStartsWith](#method-fluent-str-when-starts-with)\r\n[whenEndsWith](#method-fluent-str-when-ends-with)\r\n[whenExactly](#method-fluent-str-when-exactly)\r\n[whenIs](#method-fluent-str-when-is)\r\n[whenIsAscii](#method-fluent-str-when-is-ascii)\r\n[whenIsUuid](#method-fluent-str-when-is-uuid)\r\n[whenTest](#method-fluent-str-when-test)\r\n[wordCount](#method-fluent-str-word-count)\r\n[words](#method-fluent-str-words)\r\n\r\n</div>\r\n\r\n<a name=\"urls-method-list\"></a>\r\n### URLs\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[action](#method-action)\r\n[asset](#method-asset)\r\n[route](#method-route)\r\n[secure_asset](#method-secure-asset)\r\n[secure_url](#method-secure-url)\r\n[to_route](#method-to-route)\r\n[url](#method-url)\r\n\r\n</div>\r\n\r\n<a name=\"miscellaneous-method-list\"></a>\r\n### 其他\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[abort](#method-abort)\r\n[abort_if](#method-abort-if)\r\n[abort_unless](#method-abort-unless)\r\n[app](#method-app)\r\n[auth](#method-auth)\r\n[back](#method-back)\r\n[bcrypt](#method-bcrypt)\r\n[blank](#method-blank)\r\n[broadcast](#method-broadcast)\r\n[cache](#method-cache)\r\n[class_uses_recursive](#method-class-uses-recursive)\r\n[collect](#method-collect)\r\n[config](#method-config)\r\n[cookie](#method-cookie)\r\n[csrf_field](#method-csrf-field)\r\n[csrf_token](#method-csrf-token)\r\n[decrypt](#method-decrypt)\r\n[dd](#method-dd)\r\n[dispatch](#method-dispatch)\r\n[dump](#method-dump)\r\n[encrypt](#method-encrypt)\r\n[env](#method-env)\r\n[event](#method-event)\r\n[filled](#method-filled)\r\n[info](#method-info)\r\n[logger](#method-logger)\r\n[method_field](#method-method-field)\r\n[now](#method-now)\r\n[old](#method-old)\r\n[optional](#method-optional)\r\n[policy](#method-policy)\r\n[redirect](#method-redirect)\r\n[report](#method-report)\r\n[request](#method-request)\r\n[rescue](#method-rescue)\r\n[resolve](#method-resolve)\r\n[response](#method-response)\r\n[retry](#method-retry)\r\n[session](#method-session)\r\n[tap](#method-tap)\r\n[throw_if](#method-throw-if)\r\n[throw_unless](#method-throw-unless)\r\n[today](#method-today)\r\n[trait_uses_recursive](#method-trait-uses-recursive)\r\n[transform](#method-transform)\r\n[validator](#method-validator)\r\n[value](#method-value)\r\n[view](#method-view)\r\n[with](#method-with)\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"method-listing\"></a>\r\n## 方法列表\r\n\r\n<style>\r\n    .collection-method code {\r\n        font-size: 14px;\r\n    }\r\n\r\n    .collection-method:not(.first-collection-method) {\r\n        margin-top: 50px;\r\n    }\r\n</style>\r\n\r\n<a name=\"arrays\"></a>\r\n## 数组 & 对象\r\n\r\n<a name=\"method-array-accessible\"></a>\r\n#### `Arr::accessible()` {.collection-method .first-collection-method}\r\n\r\n`Arr::accessible` 函数检查给定的值是否可数组式访问：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    use Illuminate\\Support\\Collection;\r\n\r\n    $isAccessible = Arr::accessible(['a' => 1, 'b' => 2]);\r\n\r\n    // true\r\n\r\n    $isAccessible = Arr::accessible(new Collection);\r\n\r\n    // true\r\n\r\n    $isAccessible = Arr::accessible('abc');\r\n\r\n    // false\r\n\r\n    $isAccessible = Arr::accessible(new stdClass);\r\n\r\n    // false\r\n\r\n<a name=\"method-array-add\"></a>\r\n#### `Arr::add()` {.collection-method}\r\n\r\n如果给定的键在数组中不存在或给定的键的值被设置为 `null` ，那么 `Arr::add` 函数将会把给定的键值对添加到数组中：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = Arr::add(['name' => 'Desk'], 'price', 100);\r\n\r\n    // ['name' => 'Desk', 'price' => 100]\r\n\r\n    $array = Arr::add(['name' => 'Desk', 'price' => null], 'price', 100);\r\n\r\n    // ['name' => 'Desk', 'price' => 100]\r\n\r\n\r\n<a name=\"method-array-collapse\"></a>\r\n#### `Arr::collapse()` {.collection-method}\r\n\r\n`Arr::collapse` 函数将多个数组合并为一个数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\r\n\r\n    // [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\r\n<a name=\"method-array-crossjoin\"></a>\r\n#### `Arr::crossJoin()` {.collection-method}\r\n\r\n`Arr::crossJoin` 函数交叉连接给定的数组，返回具有所有可能排列的笛卡尔乘积：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $matrix = Arr::crossJoin([1, 2], ['a', 'b']);\r\n\r\n    /*\r\n        [\r\n            [1, 'a'],\r\n            [1, 'b'],\r\n            [2, 'a'],\r\n            [2, 'b'],\r\n        ]\r\n    */\r\n\r\n    $matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);\r\n\r\n    /*\r\n        [\r\n            [1, 'a', 'I'],\r\n            [1, 'a', 'II'],\r\n            [1, 'b', 'I'],\r\n            [1, 'b', 'II'],\r\n            [2, 'a', 'I'],\r\n            [2, 'a', 'II'],\r\n            [2, 'b', 'I'],\r\n            [2, 'b', 'II'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-array-divide\"></a>\r\n#### `Arr::divide()` {.collection-method}\r\n\r\n`Arr::divide` 函数返回一个二维数组，一个值包含原数组的键，另一个值包含原数组的值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    [$keys, $values] = Arr::divide(['name' => 'Desk']);\r\n\r\n    // $keys: ['name']\r\n\r\n    // $values: ['Desk']\r\n\r\n\r\n\r\n<a name=\"method-array-dot\"></a>\r\n#### `Arr::dot()` {.collection-method}\r\n\r\n`Arr::dot` 函数将多维数组中所有的键平铺到一维数组中，新数组使用「.」符号表示层级包含关系：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['products' => ['desk' => ['price' => 100]]];\r\n\r\n    $flattened = Arr::dot($array);\r\n\r\n    // ['products.desk.price' => 100]\r\n\r\n<a name=\"method-array-except\"></a>\r\n#### `Arr::except()` {.collection-method}\r\n\r\n`Arr::except` 函数从数组中删除指定的键值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['name' => 'Desk', 'price' => 100];\r\n\r\n    $filtered = Arr::except($array, ['price']);\r\n\r\n    // ['name' => 'Desk']\r\n\r\n<a name=\"method-array-exists\"></a>\r\n#### `Arr::exists()` {.collection-method}\r\n\r\n`Arr::exists` 检查给定的键是否存在提供的数组中：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['name' => 'John Doe', 'age' => 17];\r\n\r\n    $exists = Arr::exists($array, 'name');\r\n\r\n    // true\r\n\r\n    $exists = Arr::exists($array, 'salary');\r\n\r\n    // false\r\n\r\n<a name=\"method-array-first\"></a>\r\n#### `Arr::first()` {.collection-method}\r\n\r\n`Arr::first` 函数返回数组中满足指定条件的第一个元素：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [100, 200, 300];\r\n\r\n    $first = Arr::first($array, function ($value, $key) {\r\n        return $value >= 150;\r\n    });\r\n\r\n    // 200\r\n\r\n将默认值作为第三个参数传递给该方法，如果没有值满足条件，则返回该默认值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $first = Arr::first($array, $callback, $default);\r\n\r\n<a name=\"method-array-flatten\"></a>\r\n#### `Arr::flatten()` {.collection-method}\r\n\r\n `Arr::flatten` 函数将多维数组中数组的值取出平铺为一维数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['name' => 'Joe', 'languages' => ['PHP', 'Ruby']];\r\n\r\n    $flattened = Arr::flatten($array);\r\n\r\n    // ['Joe', 'PHP', 'Ruby']\r\n\r\n<a name=\"method-array-forget\"></a>\r\n#### `Arr::forget()` {.collection-method}\r\n\r\n`Arr::forget` 函数使用「.」符号从深度嵌套的数组中删除给定的键值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['products' => ['desk' => ['price' => 100]]];\r\n\r\n    Arr::forget($array, 'products.desk');\r\n\r\n    // ['products' => []]\r\n\r\n\r\n\r\n<a name=\"method-array-get\"></a>\r\n#### `Arr::get()` {.collection-method}\r\n\r\n`Arr::get` 函数使用「.」符号从深度嵌套的数组根据指定键检索值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['products' => ['desk' => ['price' => 100]]];\r\n\r\n    $price = Arr::get($array, 'products.desk.price');\r\n\r\n    // 100\r\n\r\n`Arr::get` 函数也可以接受一个默认值，如果没有找到特定的键，将返回默认值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $discount = Arr::get($array, 'products.desk.discount', 0);\r\n\r\n    // 0\r\n\r\n<a name=\"method-array-has\"></a>\r\n#### `Arr::has()` {.collection-method}\r\n\r\n`Arr::has` 函数使用「.」符号判断数组中是否存在指定的一个或多个键：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['product' => ['name' => 'Desk', 'price' => 100]];\r\n\r\n    $contains = Arr::has($array, 'product.name');\r\n\r\n    // true\r\n\r\n    $contains = Arr::has($array, ['product.price', 'product.discount']);\r\n\r\n    // false\r\n\r\n<a name=\"method-array-hasany\"></a>\r\n#### `Arr::hasAny()` {.collection-method}\r\n\r\n`Arr::hasAny` 函数使用「.」符号判断数组中是否存在给定集合中的任一值作为键：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['product' => ['name' => 'Desk', 'price' => 100]];\r\n\r\n    $contains = Arr::hasAny($array, 'product.name');\r\n\r\n    // true\r\n\r\n    $contains = Arr::hasAny($array, ['product.name', 'product.discount']);\r\n\r\n    // true\r\n\r\n    $contains = Arr::hasAny($array, ['category', 'product.discount']);\r\n\r\n    // false\r\n\r\n<a name=\"method-array-isassoc\"></a>\r\n#### `Arr::isAssoc()` {.collection-method}\r\n\r\n如果给定数组是关联数组，则 `Arr::isAssoc` 函数返回 `true`，如果数组没有以零开头的连续数字键，则将其视为「关联」：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $isAssoc = Arr::isAssoc(['product' => ['name' => 'Desk', 'price' => 100]]);\r\n\r\n    // true\r\n\r\n    $isAssoc = Arr::isAssoc([1, 2, 3]);\r\n\r\n    // false\r\n\r\n<a name=\"method-array-islist\"></a>\r\n#### `Arr::isList()` {.collection-method}\r\n\r\n如果给定数组的键是从零开始的连续整数，则 `Arr::isList` 方法返回 `true`：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $isAssoc = Arr::isList(['foo', 'bar', 'baz']);\r\n\r\n    // true\r\n\r\n    $isAssoc = Arr::isList(['product' => ['name' => 'Desk', 'price' => 100]]);\r\n\r\n    // false\r\n\r\n<a name=\"method-array-keyby\"></a>\r\n\r\n#### `Arr::keyBy()` {.collection-method}\r\n\r\n> 注意：自 Laravel 9.2 引入\r\n\r\nThe `Arr::keyBy` method keys the array by the given key. If multiple items have the same key, only the last one will appear in the new array:\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [\r\n\r\n        ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n\r\n        ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n\r\n    ];\r\n\r\n    $keyed = Arr::keyBy($array, 'product_id');\r\n\r\n    /*\r\n\r\n        [\r\n\r\n            'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n\r\n            'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n\r\n        ]\r\n\r\n    */\r\n\r\n<a name=\"method-array-last\"></a>\r\n#### `Arr::last()` {.collection-method}\r\n\r\n`Arr::last` 函数返回数组中满足指定条件的最后一个元素：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [100, 200, 300, 110];\r\n\r\n    $last = Arr::last($array, function ($value, $key) {\r\n        return $value >= 150;\r\n    });\r\n\r\n    // 300\r\n\r\n将默认值作为第三个参数传递给该方法，如果没有值满足条件，则返回该默认值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $last = Arr::last($array, $callback, $default);\r\n\r\n<a name=\"method-array-only\"></a>\r\n#### `Arr::only()` {.collection-method}\r\n\r\n`Arr::only` 函数只返回给定数组中指定的键值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['name' => 'Desk', 'price' => 100, 'orders' => 10];\r\n\r\n    $slice = Arr::only($array, ['name', 'price']);\r\n\r\n    // ['name' => 'Desk', 'price' => 100]\r\n\r\n<a name=\"method-array-pluck\"></a>\r\n#### `Arr::pluck()` {.collection-method}\r\n\r\n`Arr::pluck` 函数从数组中检索给定键的所有值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [\r\n        ['developer' => ['id' => 1, 'name' => 'Taylor']],\r\n        ['developer' => ['id' => 2, 'name' => 'Abigail']],\r\n    ];\r\n\r\n    $names = Arr::pluck($array, 'developer.name');\r\n\r\n    // ['Taylor', 'Abigail']\r\n\r\n你也可以指定结果的键：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $names = Arr::pluck($array, 'developer.name', 'developer.id');\r\n\r\n    // [1 => 'Taylor', 2 => 'Abigail']\r\n\r\n<a name=\"method-array-prepend\"></a>\r\n#### `Arr::prepend()` {.collection-method}\r\n\r\n`Arr::prepend` 函数将一个值插入到数组的开始位置：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['one', 'two', 'three', 'four'];\r\n\r\n    $array = Arr::prepend($array, 'zero');\r\n\r\n    // ['zero', 'one', 'two', 'three', 'four']\r\n\r\n你也可以指定插入值的键：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['price' => 100];\r\n\r\n    $array = Arr::prepend($array, 'Desk', 'name');\r\n\r\n    // ['name' => 'Desk', 'price' => 100]\r\n\r\n\r\n\r\n<a name=\"method-array-pull\"></a>\r\n#### `Arr::pull()` {.collection-method}\r\n\r\n`Arr::pull` 函数从数组中返回指定键的值并删除此键值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['name' => 'Desk', 'price' => 100];\r\n\r\n    $name = Arr::pull($array, 'name');\r\n\r\n    // $name: Desk\r\n\r\n    // $array: ['price' => 100]\r\n\r\n默认值可以作为第三个参数传递给该方法，如果键不存在，则返回该值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $value = Arr::pull($array, $key, $default);\r\n\r\n<a name=\"method-array-query\"></a>\r\n#### `Arr::query()` {.collection-method}\r\n\r\n`Arr::query` 函数将数组转换为查询字符串：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [\r\n        'name' => 'Taylor',\r\n        'order' => [\r\n            'column' => 'created_at',\r\n            'direction' => 'desc'\r\n        ]\r\n    ];\r\n\r\n    Arr::query($array);\r\n\r\n    // name=Taylor&order[column]=created_at&order[direction]=desc\r\n\r\n<a name=\"method-array-random\"></a>\r\n#### `Arr::random()` {.collection-method}\r\n\r\n`Arr::random`  函数从数组中随机返回一个值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [1, 2, 3, 4, 5];\r\n\r\n    $random = Arr::random($array);\r\n\r\n    // 4 - (retrieved randomly)\r\n\r\n你也可以将返回值的数量作为可选的第二个参数传递给该方法，请注意，提供这个参数会返回一个数组，即使是你只需要一项：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $items = Arr::random($array, 2);\r\n\r\n    // [2, 5] - (retrieved randomly)\r\n\r\n<a name=\"method-array-set\"></a>\r\n#### `Arr::set()` {.collection-method}\r\n\r\n`Arr::set` 函数使用「.」符号在多维数组中设置指定键的值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['products' => ['desk' => ['price' => 100]]];\r\n\r\n    Arr::set($array, 'products.desk.price', 200);\r\n\r\n    // ['products' => ['desk' => ['price' => 200]]]\r\n\r\n<a name=\"method-array-shuffle\"></a>\r\n#### `Arr::shuffle()` {.collection-method}\r\n\r\n`Arr::shuffle` 函数将数组中值进行随机排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = Arr::shuffle([1, 2, 3, 4, 5]);\r\n\r\n    // [3, 2, 5, 1, 4] - (generated randomly)\r\n\r\n\r\n\r\n<a name=\"method-array-sort\"></a>\r\n#### `Arr::sort()` {.collection-method}\r\n\r\n`Arr::sort`  函数根据数组的值大小进行排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = ['Desk', 'Table', 'Chair'];\r\n\r\n    $sorted = Arr::sort($array);\r\n\r\n    // ['Chair', 'Desk', 'Table']\r\n\r\n你也可以根据给定回调函数返回的结果对数组进行排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [\r\n        ['name' => 'Desk'],\r\n        ['name' => 'Table'],\r\n        ['name' => 'Chair'],\r\n    ];\r\n\r\n    $sorted = array_values(Arr::sort($array, function ($value) {\r\n        return $value['name'];\r\n    }));\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Chair'],\r\n            ['name' => 'Desk'],\r\n            ['name' => 'Table'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-array-sort-recursive\"></a>\r\n#### `Arr::sortRecursive()` {.collection-method}\r\n\r\n`Arr::sortRecursive` 函数使用 `sort` 函数对数值子数组进行递归排序，使用 `ksort` 函数对关联子数组进行递归排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [\r\n        ['Roman', 'Taylor', 'Li'],\r\n        ['PHP', 'Ruby', 'JavaScript'],\r\n        ['one' => 1, 'two' => 2, 'three' => 3],\r\n    ];\r\n\r\n    $sorted = Arr::sortRecursive($array);\r\n\r\n    /*\r\n        [\r\n            ['JavaScript', 'PHP', 'Ruby'],\r\n            ['one' => 1, 'three' => 3, 'two' => 2],\r\n            ['Li', 'Roman', 'Taylor'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-array-to-css-classes\"></a>\r\n#### `Arr::toCssClasses()` {.collection-method}\r\n\r\n`Arr::toCssClasses` 函数根据给定的条件编译并返回 CSS 类字符串。该方法接受一个类数组，其中数组键包含你希望添加的一个或多个 CSS Class，而值是一个布尔表达式。如果数组元素有一个数字键，它将始终包含在呈现的类列表中：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $isActive = false;\r\n    $hasError = true;\r\n\r\n    $array = ['p-4', 'font-bold' => $isActive, 'bg-red' => $hasError];\r\n\r\n    $classes = Arr::toCssClasses($array);\r\n\r\n    /*\r\n        'p-4 bg-red'\r\n    */\r\n\r\nLaravel 基于该函数实现[条件类](/docs/laravel/9.x/blade#conditionally-merge-classes) 以及 `@class` [Blade 指令](/docs/laravel/9.x/blade#conditional-classes)。\r\n\r\n<a name=\"method-array-undot\"></a>\r\n#### `Arr::undot()` {.collection-method}\r\n\r\n`Arr::undot` 函数将使用「点表示法」的一维数组扩展为多维数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [\r\n        'user.name' => 'Kevin Malone',\r\n        'user.occupation' => 'Accountant',\r\n    ];\r\n\r\n    $array = Arr::undot($array);\r\n\r\n    // ['user' => ['name' => 'Kevin Malone', 'occupation' => 'Accountant']]\r\n\r\n\r\n\r\n<a name=\"method-array-where\"></a>\r\n#### `Arr::where()` {.collection-method}\r\n\r\n`Arr::where` 函数使用给定的回调函数返回的结果过滤数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [100, '200', 300, '400', 500];\r\n\r\n    $filtered = Arr::where($array, function ($value, $key) {\r\n        return is_string($value);\r\n    });\r\n\r\n    // [1 => '200', 3 => '400']\r\n\r\n<a name=\"method-array-where-not-null\"></a>\r\n#### `Arr::whereNotNull()` {.collection-method}\r\n\r\n`Arr::whereNotNull` 函数将从给定数组中删除所有 `null` 值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = [0, null];\r\n\r\n    $filtered = Arr::whereNotNull($array);\r\n\r\n    // [0 => 0]\r\n\r\n<a name=\"method-array-wrap\"></a>\r\n#### `Arr::wrap()` {.collection-method}\r\n\r\n`Arr::wrap` 函数可以将给定值转换为一个数组，如果给定的值已经是一个数组，它将原样返回：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $string = 'Laravel';\r\n\r\n    $array = Arr::wrap($string);\r\n\r\n    // ['Laravel']\r\n\r\n如果给定值是 `null`，将返回一个空数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n\r\n    $array = Arr::wrap(null);\r\n\r\n    // []\r\n\r\n<a name=\"method-data-fill\"></a>\r\n#### `data_fill()` {.collection-method}\r\n\r\n`data_fill` 函数使用「.」符号给多维数组或对象设置缺少的值：\r\n\r\n    $data = ['products' => ['desk' => ['price' => 100]]];\r\n\r\n    data_fill($data, 'products.desk.price', 200);\r\n\r\n    // ['products' => ['desk' => ['price' => 100]]]\r\n\r\n    data_fill($data, 'products.desk.discount', 10);\r\n\r\n    // ['products' => ['desk' => ['price' => 100, 'discount' => 10]]]\r\n\r\n此函数也可以接收「*」作为通配符，设置相应缺少的值：\r\n\r\n    $data = [\r\n        'products' => [\r\n            ['name' => 'Desk 1', 'price' => 100],\r\n            ['name' => 'Desk 2'],\r\n        ],\r\n    ];\r\n\r\n    data_fill($data, 'products.*.price', 200);\r\n\r\n    /*\r\n        [\r\n            'products' => [\r\n                ['name' => 'Desk 1', 'price' => 100],\r\n                ['name' => 'Desk 2', 'price' => 200],\r\n            ],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-data-get\"></a>\r\n#### `data_get()` {.collection-method}\r\n\r\n`data_get`  函数使用「.」符号从多维数组或对象中根据指定键检索值：\r\n\r\n    $data = ['products' => ['desk' => ['price' => 100]]];\r\n\r\n    $price = data_get($data, 'products.desk.price');\r\n\r\n    // 100\r\n\r\n\r\n\r\n该函数也接受一个默认值，如果没有找到指定的键，将返回默认值：\r\n\r\n    $discount = data_get($data, 'products.desk.discount', 0);\r\n\r\n    // 0\r\n\r\n该函数还接受「*」为通配符,来指向数组或对象的任何键：\r\n\r\n    $data = [\r\n        'product-one' => ['name' => 'Desk 1', 'price' => 100],\r\n        'product-two' => ['name' => 'Desk 2', 'price' => 150],\r\n    ];\r\n\r\n    data_get($data, '*.name');\r\n\r\n    // ['Desk 1', 'Desk 2'];\r\n\r\n<a name=\"method-data-set\"></a>\r\n#### `data_set()` {.collection-method}\r\n\r\n`data_set` 函数使用「.」符号从多维数组或对象中根据指定键设置值：\r\n\r\n    $data = ['products' => ['desk' => ['price' => 100]]];\r\n\r\n    data_set($data, 'products.desk.price', 200);\r\n\r\n    // ['products' => ['desk' => ['price' => 200]]]\r\n\r\n同 `data_get`一样, 函数也支持使用「*」作为通配符给相应键名赋值：\r\n\r\n    $data = [\r\n        'products' => [\r\n            ['name' => 'Desk 1', 'price' => 100],\r\n            ['name' => 'Desk 2', 'price' => 150],\r\n        ],\r\n    ];\r\n\r\n    data_set($data, 'products.*.price', 200);\r\n\r\n    /*\r\n        [\r\n            'products' => [\r\n                ['name' => 'Desk 1', 'price' => 200],\r\n                ['name' => 'Desk 2', 'price' => 200],\r\n            ],\r\n        ]\r\n    */\r\n\r\n通常情况下，已存在的值将会被覆盖。如果只是希望设置一个目前不存在的值，你可以增加一个 `false` 作为函数的第四个参数：\r\n\r\n    $data = ['products' => ['desk' => ['price' => 100]]];\r\n\r\n    data_set($data, 'products.desk.price', 200, $overwrite = false);\r\n\r\n    // ['products' => ['desk' => ['price' => 100]]]\r\n\r\n<a name=\"method-head\"></a>\r\n#### `head()` {.collection-method}\r\n\r\n`head` 函数将返回数组中的第一个值：\r\n\r\n    $array = [100, 200, 300];\r\n\r\n    $first = head($array);\r\n\r\n    // 100\r\n\r\n<a name=\"method-last\"></a>\r\n#### `last()` {.collection-method}\r\n\r\n`last` 函数将返回数组中的最后一个值：\r\n\r\n    $array = [100, 200, 300];\r\n\r\n    $last = last($array);\r\n\r\n    // 300\r\n\r\n<a name=\"paths\"></a>\r\n## 路径\r\n\r\n<a name=\"method-app-path\"></a>\r\n#### `app_path()` {.collection-method}\r\n\r\n`app_path` 函数返回 app 目录的完整路径。你也可以使用 app_path 函数来生成应用目录下特定文件的完整路径：\r\n\r\n    $path = app_path();\r\n\r\n    $path = app_path('Http/Controllers/Controller.php');\r\n\r\n\r\n\r\n<a name=\"method-base-path\"></a>\r\n#### `base_path()` {.collection-method}\r\n\r\n`base_path` 函数返回项目根目录的完整路径。你也可以使用 `base_path` 函数生成项目根目录下特定文件的完整路径：\r\n\r\n    $path = base_path();\r\n\r\n    $path = base_path('vendor/bin');\r\n\r\n<a name=\"method-config-path\"></a>\r\n#### `config_path()` {.collection-method}\r\n\r\n`config_path`  函数返回 项目配置目录(config)的完整路径。你也可以使用 `config_path` 函数来生成应用配置目录中的特定文件的完整路径：\r\n\r\n    $path = config_path();\r\n\r\n    $path = config_path('app.php');\r\n\r\n<a name=\"method-database-path\"></a>\r\n#### `database_path()` {.collection-method}\r\n\r\n`database_path`函数返回 `database` 目录的完整路径。你也可以使用 `database_path` 函数来生成数据库目录下特定文件的完整路径：\r\n\r\n    $path = database_path();\r\n\r\n    $path = database_path('factories/UserFactory.php');\r\n\r\n<a name=\"method-mix\"></a>\r\n#### `mix()` {.collection-method}\r\n\r\n`mix`函数返回 [编译前端资源（Mix）](/docs/laravel/9.x/mix)的路径,便于加载 css，js 等静态文件：\r\n\r\n    $path = mix('css/app.css');\r\n\r\n<a name=\"method-public-path\"></a>\r\n#### `public_path()` {.collection-method}\r\n\r\n`public_path` 函数返回 `public` 目录的完整路径。你可以使用 `public_path` 函数来生成 `public` 目录下特定文件的完整路径：\r\n\r\n    $path = public_path();\r\n\r\n    $path = public_path('css/app.css');\r\n\r\n<a name=\"method-resource-path\"></a>\r\n#### `resource_path()` {.collection-method}\r\n\r\n `resource_path` 函数返回 `resources` 目录的完整路径。你也可以用`resource_path` 函数来生成位于资源路径中的特定文件路径：\r\n\r\n    $path = resource_path();\r\n\r\n    $path = resource_path('sass/app.scss');\r\n\r\n\r\n\r\n<a name=\"method-storage-path\"></a>\r\n#### `storage_path()` {.collection-method}\r\n\r\n`storage_path` 函数返回 `storage` 目录的完整路径。 你也可以用`storage_path` 函数来生成位于资源路径中的特定文件路径：\r\n\r\n    $path = storage_path();\r\n\r\n    $path = storage_path('app/file.txt');\r\n\r\n<a name=\"strings\"></a>\r\n## 字符串函数\r\n\r\n<a name=\"method-__\"></a>\r\n#### `__()` {.collection-method}\r\n\r\n `__` 函数可使用 [本地化文件](/docs/laravel/9.x/localization/9378) 来翻译指定的字符串或特定的key：\r\n\r\n    echo __('Welcome to our application');\r\n\r\n    echo __('messages.welcome');\r\n\r\n如果给定翻译的字符串或者key不存在， 则 `__` 会返回你指定的值. 所以上述例子中， 如果给定翻译的字符串或者key不存在，则 `__` 函数会返回`messages.welcome`。\r\n\r\n<a name=\"method-class-basename\"></a>\r\n#### `class_basename()` {.collection-method}\r\n\r\n `class_basename` 函数返回不带命名空间的特定类的类名：\r\n\r\n    $class = class_basename('Foo\\Bar\\Baz');\r\n\r\n    // Baz\r\n\r\n<a name=\"method-e\"></a>\r\n#### `e()` {.collection-method}\r\n\r\n`e` 函数运行PHP的`htmlspecialchars` 函数，且 `double_encode` 默认设定为 `true`：\r\n\r\n    echo e('<html>foo</html>');\r\n\r\n    // &lt;html&gt;foo&lt;/html&gt;\r\n\r\n<a name=\"method-preg-replace-array\"></a>\r\n#### `preg_replace_array()` {.collection-method}\r\n\r\n`preg_replace_array` 函数替换给定顺序模式下字符串中的一个数组：\r\n\r\n    $string = 'The event will take place between :start and :end';\r\n\r\n    $replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);\r\n\r\n    // The event will take place between 8:30 and 9:00\r\n\r\n<a name=\"method-str-after\"></a>\r\n#### `Str::after()` {.collection-method}\r\n\r\n`Str::after` 方法返回字符串中指定值之后的所有内容。如果字符串中不存在这个值，它将返回整个字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::after('This is my name', 'This is');\r\n\r\n    // ' my name'\r\n\r\n\r\n\r\n<a name=\"method-str-after-last\"></a>\r\n#### `Str::afterLast()` {.collection-method}\r\n\r\n`Str::afterLast` 方法返回字符串中指定值最后一次出现后的所有内容。如果字符串中不存在这个值，它将返回整个字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::afterLast('App\\Http\\Controllers\\Controller', '\\\\');\r\n\r\n    // 'Controller'\r\n\r\n<a name=\"method-str-ascii\"></a>\r\n#### `Str::ascii()` {.collection-method}\r\n\r\n`Str::ascii` 方法尝试将字符串转换为 ASCII 值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::ascii('û');\r\n\r\n    // 'u'\r\n\r\n<a name=\"method-str-before\"></a>\r\n#### `Str::before()` {.collection-method}\r\n\r\n`Str::before` 方法返回字符串中指定值之前的所有内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::before('This is my name', 'my name');\r\n\r\n    // 'This is '\r\n\r\n<a name=\"method-str-before-last\"></a>\r\n#### `Str::beforeLast()` {.collection-method}\r\n\r\n`Str::beforeLast` 方法返回字符串中指定值最后一次出现前的所有内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::beforeLast('This is my name', 'is');\r\n\r\n    // 'This '\r\n\r\n<a name=\"method-str-between\"></a>\r\n#### `Str::between()` {.collection-method}\r\n\r\n`Str::between`  方法返回字符串在指定两个值之间的内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::between('This is my name', 'This', 'name');\r\n\r\n    // ' is my '\r\n\r\n<a name=\"method-camel-case\"></a>\r\n#### `Str::camel()` {.collection-method}\r\n\r\n`Str::camel` 方法将指定字符串转换为 `驼峰式` 表示方法：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::camel('foo_bar');\r\n\r\n    // fooBar\r\n\r\n<a name=\"method-str-contains\"></a>\r\n#### `Str::contains()` {.collection-method}\r\n\r\n`Str::contains` 方法判断指定字符串中是否包含另一指定字符串（区分大小写）：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $contains = Str::contains('This is my name', 'my');\r\n\r\n    // true\r\n\r\n\r\n\r\n你也可以传递数组的值的形式来判断指定字符串是否包含数组中的任一值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $contains = Str::contains('This is my name', ['my', 'foo']);\r\n\r\n    // true\r\n\r\n<a name=\"method-str-contains-all\"></a>\r\n#### `Str::containsAll()` {.collection-method}\r\n\r\n`Str::containsAll` 方法用于判断指定字符串是否包含指定数组中的所有值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $containsAll = Str::containsAll('This is my name', ['my', 'name']);\r\n\r\n    // true\r\n\r\n<a name=\"method-ends-with\"></a>\r\n#### `Str::endsWith()` {.collection-method}\r\n\r\n`Str::endsWith` 方法用于判断指定字符串是否以另一指定字符串结尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::endsWith('This is my name', 'name');\r\n\r\n    // true\r\n\r\n你也可以传递数组的值的形式来判断指定字符串是否包含指定数组中的任一值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::endsWith('This is my name', ['name', 'foo']);\r\n\r\n    // true\r\n\r\n    $result = Str::endsWith('This is my name', ['this', 'foo']);\r\n\r\n    // false\r\n\r\n<a name=\"method-excerpt\"></a>\r\n#### `Str::excerpt()` {.collection-method}\r\n\r\n`Str::excerpt` 方法用于从给定字符串中提取与该字符串中短语的第一个实例匹配的片段：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $excerpt = Str::excerpt('This is my name', 'my', [\r\n        'radius' => 3\r\n    ]);\r\n\r\n    // '...is my na...'\r\n\r\n`radius` 选项默认为 `100`，允许你定义应出现在截断字符串前后的字符数。\r\n\r\n此外，你可以使用 `omission` 选项来定义将附加到截断字符串的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $excerpt = Str::excerpt('This is my name', 'name', [\r\n        'radius' => 3,\r\n        'omission' => '(...) '\r\n    ]);\r\n\r\n    // '(...) my name'\r\n\r\n\r\n\r\n<a name=\"method-str-finish\"></a>\r\n#### `Str::finish()` {.collection-method}\r\n\r\n`Str::finish` 方法将指定的字符串修改为以指定的值结尾的形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $adjusted = Str::finish('this/string', '/');\r\n\r\n    // this/string/\r\n\r\n    $adjusted = Str::finish('this/string/', '/');\r\n\r\n    // this/string/\r\n\r\n<a name=\"method-str-headline\"></a>\r\n#### `Str::headline()` {.collection-method}\r\n\r\n`Str::headline` 方法会将由大小写、连字符或下划线分隔的字符串转换为空格分隔的字符串，同时保证每个单词的首字母大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $headline = Str::headline('steve_jobs');\r\n\r\n    // Steve Jobs\r\n\r\n    $headline = Str::headline('EmailNotificationSent');\r\n\r\n    // Email Notification Sent\r\n\r\n<a name=\"method-str-is\"></a>\r\n#### `Str::is()` {.collection-method}\r\n\r\n`Str::is` 方法用来判断字符串是否与指定模式匹配。星号 `*` 可用于表示通配符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $matches = Str::is('foo*', 'foobar');\r\n\r\n    // true\r\n\r\n    $matches = Str::is('baz*', 'foobar');\r\n\r\n    // false\r\n\r\n<a name=\"method-str-is-ascii\"></a>\r\n#### `Str::isAscii()` {.collection-method}\r\n\r\n`Str::isAscii` 方法用于判断字符串是否是 7 位 ASCII：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $isAscii = Str::isAscii('Taylor');\r\n\r\n    // true\r\n\r\n    $isAscii = Str::isAscii('ü');\r\n\r\n    // false\r\n\r\n<a name=\"method-str-is-uuid\"></a>\r\n#### `Str::isUuid()` {.collection-method}\r\n\r\n`Str::isUuid` 方法用于判断指定字符串是否是有效的 UUID ：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');\r\n\r\n    // true\r\n\r\n    $isUuid = Str::isUuid('laravel');\r\n\r\n    // false\r\n\r\n<a name=\"method-kebab-case\"></a>\r\n#### `Str::kebab()` {.collection-method}\r\n\r\n`Str::kebab` 方法将字符串转换为 `烤串式（ kebab-case ）` 表示方法：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::kebab('fooBar');\r\n\r\n    // foo-bar\r\n\r\n\r\n\r\n<a name=\"method-str-length\"></a>\r\n#### `Str::length()` {.collection-method}\r\n\r\n`Str::length` 方法返回指定字符串的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $length = Str::length('Laravel');\r\n\r\n    // 7\r\n\r\n<a name=\"method-str-limit\"></a>\r\n#### `Str::limit()` {.collection-method}\r\n\r\n`Str::limit` 方法将字符串以指定长度进行截断：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20);\r\n\r\n    // The quick brown fox...\r\n\r\n你也可通过第三个参数来改变追加到末尾的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20, ' (...)');\r\n\r\n    // The quick brown fox (...)\r\n\r\n<a name=\"method-str-lower\"></a>\r\n#### `Str::lower()` {.collection-method}\r\n\r\n`Str::lower` 方法用于将字符串转换为小写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::lower('LARAVEL');\r\n\r\n    // laravel\r\n\r\n<a name=\"method-str-markdown\"></a>\r\n#### `Str::markdown()` {.collection-method}\r\n\r\n`Str::markdown` 方法可以将 `GitHub` 风格的 `Markdown` 转换为 `HTML`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $html = Str::markdown('# Laravel');\r\n\r\n    // <h1>Laravel</h1>\r\n\r\n    $html = Str::markdown('# Taylor <b>Otwell</b>', [\r\n        'html_input' => 'strip',\r\n    ]);\r\n\r\n    // <h1>Taylor Otwell</h1>\r\n\r\n<a name=\"method-str-mask\"></a>\r\n#### `Str::mask()` {.collection-method}\r\n\r\n`Str::mask` 方法会使用重复的字符掩盖字符串的一部分，并可用于混淆字符串段，例如电子邮件地址和电话号码：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::mask('taylor@example.com', '*', 3);\r\n\r\n    // tay***************\r\n\r\n你可以提供一个负数作为 `mask` 方法的第三个参数，这将指示该方法在距字符串末尾的给定距离处开始屏蔽：\r\n\r\n    $string = Str::mask('taylor@example.com', '*', -15, 3);\r\n\r\n    // tay***@example.com\r\n\r\n\r\n\r\n<a name=\"method-str-ordered-uuid\"></a>\r\n#### `Str::orderedUuid()` {.collection-method}\r\n\r\n`Str::orderedUuid` 方法用于生成一个「时间戳优先」的 UUID ，它可作为数据库索引列的有效值。使用此方法生成的每个 UUID 将排在之前使用该方法生成的 UUID 后面：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    return (string) Str::orderedUuid();\r\n\r\n<a name=\"method-str-padboth\"></a>\r\n#### `Str::padBoth()` {.collection-method}\r\n\r\n`Str::padBoth` 方法包装了 PHP 的 `str_pad 函数`，在指定字符串的两侧填充上另一字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $padded = Str::padBoth('James', 10, '_');\r\n\r\n    // '__James___'\r\n\r\n    $padded = Str::padBoth('James', 10);\r\n\r\n    // '  James   '\r\n\r\n<a name=\"method-str-padleft\"></a>\r\n#### `Str::padLeft()` {.collection-method}\r\n\r\n`Str::padLeft` 方法包装了 PHP 的 `str_pad` 函数，在指定字符串的左侧填充上另一字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $padded = Str::padLeft('James', 10, '-=');\r\n\r\n    // '-=-=-James'\r\n\r\n    $padded = Str::padLeft('James', 10);\r\n\r\n    // '     James'\r\n\r\n<a name=\"method-str-padright\"></a>\r\n#### `Str::padRight()` {.collection-method}\r\n\r\n`Str::padRight` 方法包装了 PHP 的 str_pad 函数，在指定字符串的右侧填充上另一字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $padded = Str::padRight('James', 10, '-');\r\n\r\n    // 'James-----'\r\n\r\n    $padded = Str::padRight('James', 10);\r\n\r\n    // 'James     '\r\n\r\n<a name=\"method-str-plural\"></a>\r\n#### `Str::plural()` {.collection-method}\r\n\r\n`Str::plural` 方法将单数形式的字符串转换为复数形式。目前该函数仅支持英语：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $plural = Str::plural('car');\r\n\r\n    // cars\r\n\r\n    $plural = Str::plural('child');\r\n\r\n    // children\r\n\r\n你可以提供一个整数作为函数的第二个参数来检索字符串的单数或复数形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $plural = Str::plural('child', 2);\r\n\r\n    // children\r\n\r\n    $singular = Str::plural('child', 1);\r\n\r\n    // child\r\n\r\n\r\n\r\n<a name=\"method-str-plural-studly\"></a>\r\n#### `Str::pluralStudly()` {.collection-method}\r\n\r\n`Str::pluralStudly` 方法将以驼峰格式的单数字符串转化为其复数形式。目前该函数仅支持英语：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $plural = Str::pluralStudly('VerifiedHuman');\r\n\r\n    // VerifiedHumans\r\n\r\n    $plural = Str::pluralStudly('UserFeedback');\r\n\r\n    // UserFeedback\r\n\r\n你可以提供一个整数作为函数的第二个参数来检索字符串的单数或复数形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $plural = Str::pluralStudly('VerifiedHuman', 2);\r\n\r\n    // VerifiedHumans\r\n\r\n    $singular = Str::pluralStudly('VerifiedHuman', 1);\r\n\r\n    // VerifiedHuman\r\n\r\n<a name=\"method-str-random\"></a>\r\n#### `Str::random()` {.collection-method}\r\n\r\n`Str::random` 方法用于生成指定长度的随机字符串。这个函数使用了PHP的 `random_bytes` 函数：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $random = Str::random(40);\r\n\r\n<a name=\"method-str-remove\"></a>\r\n#### `Str::remove()` {.collection-method}\r\n\r\n`Str::remove` 方法从字符串中删除给定值或给定数组内的所有值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = 'Peter Piper picked a peck of pickled peppers.';\r\n\r\n    $removed = Str::remove('e', $string);\r\n\r\n    // Ptr Pipr pickd a pck of pickld ppprs.\r\n\r\n你还可以将 `false` 作为第三个参数传递给 `remove` 方法以在删除字符串时忽略大小写。\r\n\r\n<a name=\"method-str-replace\"></a>\r\n#### `Str::replace()` {.collection-method}\r\n\r\n`Str::replace` 方法用于替换字符串中的给定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = 'Laravel 8.x';\r\n\r\n    $replaced = Str::replace('8.x', '9.x', $string);\r\n\r\n    // Laravel 9.x\r\n\r\n<a name=\"method-str-replace-array\"></a>\r\n#### `Str::replaceArray()` {.collection-method}\r\n\r\n`Str::replaceArray` 方法使用数组有序的替换字符串中的特定字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = 'The event will take place between ? and ?';\r\n\r\n    $replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);\r\n\r\n    // The event will take place between 8:30 and 9:00\r\n\r\n\r\n\r\n<a name=\"method-str-replace-first\"></a>\r\n#### `Str::replaceFirst()` {.collection-method}\r\n\r\n`Str::replaceFirst` 函数替换字符串中给定值的第一个匹配项 ：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');\r\n\r\n    // a quick brown fox jumps over the lazy dog\r\n\r\n<a name=\"method-str-replace-last\"></a>\r\n#### `Str::replaceLast()` {.collection-method}\r\n\r\n`Str::replaceLast`  函数替换字符串中最后一次出现的给定值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');\r\n\r\n    // the quick brown fox jumps over a lazy dog\r\n\r\n\r\n<a name=\"method-str-reverse\"></a>\r\n#### `Str::reverse()` {.collection-method}\r\n\r\n`Str::reverse` 方法用于反转给定的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $reversed = Str::reverse('Hello World');\r\n\r\n    // dlroW olleH\r\n\r\n<a name=\"method-str-singular\"></a>\r\n#### `Str::singular()` {.collection-method}\r\n\r\n`Str::singular` 方法将字符串转换为单数形式。该函数目前仅支持英文：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $singular = Str::singular('cars');\r\n\r\n    // car\r\n\r\n    $singular = Str::singular('children');\r\n\r\n    // child\r\n\r\n<a name=\"method-str-slug\"></a>\r\n#### `Str::slug()` {.collection-method}\r\n\r\n`Str::slug` 方法将给定的字符串生成一个 URL 友好的「slug」：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slug = Str::slug('Laravel 5 Framework', '-');\r\n\r\n    // laravel-5-framework\r\n\r\n<a name=\"method-snake-case\"></a>\r\n#### `Str::snake()` {.collection-method}\r\n\r\n`Str::snake` 方法是将驼峰的函数名或者字符串转换成 `_` 命名的函数或者字符串，例如 `snakeCase` 转换成 `snake_case`\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::snake('fooBar');\r\n\r\n    // foo_bar\r\n\r\n    $converted = Str::snake('fooBar', '-');\r\n\r\n    // foo-bar\r\n\r\n<a name=\"method-str-start\"></a>\r\n#### `Str::start()` {.collection-method}\r\n\r\n`Str::start` 方法是将给定的值添加到字符串的开始位置，例如：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $adjusted = Str::start('this/string', '/');\r\n\r\n    // /this/string\r\n\r\n    $adjusted = Str::start('/this/string', '/');\r\n\r\n    // /this/string\r\n\r\n\r\n\r\n<a name=\"method-starts-with\"></a>\r\n#### `Str::startsWith()` {.collection-method}\r\n\r\n`Str::startsWith` 方法用来判断给定的字符串是否为给定值的开头：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::startsWith('This is my name', 'This');\r\n\r\n    // true\r\n\r\n如果传递了一个可能值的数组且字符串以任何给定值开头，则 `startsWith` 方法将返回 `true`：\r\n\r\n    $result = Str::startsWith('This is my name', ['This', 'That', 'There']);\r\n\r\n    // true\r\n\r\n<a name=\"method-studly-case\"></a>\r\n#### `Str::studly()` {.collection-method}\r\n\r\n`Str::studly` 方法将给定的字符串转换为 `驼峰命名` 的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::studly('foo_bar');\r\n\r\n    // FooBar\r\n\r\n<a name=\"method-str-substr\"></a>\r\n#### `Str::substr()` {.collection-method}\r\n\r\n`Str::substr` 方法与 php 自带的字符串 `substr` 截取函数相同：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::substr('The Laravel Framework', 4, 7);\r\n\r\n    // Laravel\r\n\r\n<a name=\"method-str-substrcount\"></a>\r\n#### `Str::substrCount()` {.collection-method}\r\n\r\n`Str::substrCount` 方法返回给定字符串中给定值出现的次数：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $count = Str::substrCount('If you like ice cream, you will like snow cones.', 'like');\r\n\r\n    // 2\r\n\r\n<a name=\"method-str-substrreplace\"></a>\r\n#### `Str::substrReplace()` {.collection-method}\r\n\r\n`Str::substrReplace` 方法在字符串的一部分中替换文本，从第三个参数指定的位置开始替换第四个参数指定的字符数。将 `0` 传递给方法的第四个参数将在指定位置插入字符串，而不替换字符串中的任何现有字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::substrReplace('1300', ':', 2); \r\n    // 13:\r\n\r\n    $result = Str::substrReplace('1300', ':', 2, 0); \r\n    // 13:00\r\n\r\n\r\n\r\n<a name=\"method-str-swap\"></a>\r\n#### `Str::swap()` {.collection-method}\r\n\r\n`Str::swap` 方法使用 PHP 的 `strtr` 函数替换给定字符串中的多个值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::swap([\r\n        'Tacos' => 'Burritos',\r\n        'great' => 'fantastic',\r\n    ], 'Tacos are great!');\r\n\r\n    // Burritos are fantastic!\r\n\r\n<a name=\"method-title-case\"></a>\r\n#### `Str::title()` {.collection-method}\r\n\r\n`Str::title` 方法是把指定的字符串，每个单词首字母大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::title('a nice title uses the correct case');\r\n\r\n    // A Nice Title Uses The Correct Case\r\n\r\n<a name=\"method-str-to-html-string\"></a>\r\n#### `Str::toHtmlString()` {.collection-method}\r\n\r\n`Str::toHtmlString` 方法将字符串实例转换为 `Illuminate\\Support\\HtmlString` 的实例，它可以显示在 Blade 模板中：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $htmlString = Str::of('Nuno Maduro')->toHtmlString();\r\n\r\n<a name=\"method-str-ucfirst\"></a>\r\n#### `Str::ucfirst()` {.collection-method}\r\n\r\n`Str::ucfirst` 方法是把指定的字符串首字母大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::ucfirst('foo bar');\r\n\r\n    // Foo bar\r\n\r\n<a name=\"method-str-upper\"></a>\r\n#### `Str::upper()` {.collection-method}\r\n\r\n`Str::upper` 函数用于将指定字符串转换为大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::upper('laravel');\r\n\r\n    // LARAVEL\r\n\r\n<a name=\"method-str-uuid\"></a>\r\n#### `Str::uuid()` {.collection-method}\r\n\r\n`Str::uuid` 方法用于生成一个 UUID （第 4 版）：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    return (string) Str::uuid();\r\n\r\n<a name=\"method-str-word-count\"></a>\r\n#### `Str::wordCount()` {.collection-method}\r\n\r\n`Str::wordCount` 方法返回字符串包含的单词数：\r\n\r\n```php\r\nuse Illuminate\\Support\\Str;\r\n\r\nStr::wordCount('Hello, world!'); // 2\r\n```\r\n\r\n<a name=\"method-str-words\"></a>\r\n#### `Str::words()` {.collection-method}\r\n\r\n`Str::words` 方法用于限制字符串中的单词数。 可以通过它的第三个参数将另一个字符串传递给此方法，以指定应将哪个字符串附加到截断的字符串的末尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    return Str::words('Perfectly balanced, as all things should be.', 3, ' >>>');\r\n\r\n    // Perfectly balanced, as >>>\r\n\r\n\r\n\r\n<a name=\"method-str\"></a>\r\n#### `str()` {.collection-method}\r\n\r\n`str` 函数返回给定字符串的新 `Illuminate\\Support\\Stringable` 实例。这个函数等价于 `Str::of` 方法：\r\n\r\n    $string = str('Taylor')->append(' Otwell');\r\n\r\n    // 'Taylor Otwell'\r\n\r\n如果没有为 `str` 函数提供参数，则该函数返回 `Illuminate\\Support\\Str` 的实例：\r\n\r\n    $snake = str()->snake('FooBar');\r\n\r\n    // 'foo_bar'\r\n\r\n<a name=\"method-trans\"></a>\r\n#### `trans()` {.collection-method}\r\n\r\nThe `trans` 函数使用你的 [本地化文件](/docs/laravel/9.x/localization) 翻译给定键：\r\n\r\n    echo trans('messages.welcome');\r\n\r\n如果指定的翻译键不存在，`trans` 函数将返回给定的键. 因此在上方的例子中，如果翻译键不存在，`trans` 函数将返回 `messages.welcome`。\r\n\r\n<a name=\"method-trans-choice\"></a>\r\n#### `trans_choice()` {.collection-method}\r\n\r\n`trans_choice` 函数将根据词形变化来翻译给定的翻译键：\r\n\r\n    echo trans_choice('messages.notifications', $unreadCount);\r\n\r\n如果给定的翻译键不存在，`trans_choice` 函数将返回给定键。因此在上方的例子中，若翻译键不存在，`trans_choice` 函数将返回 `messages.notifications`。\r\n\r\n<a name=\"fluent-strings\"></a>\r\n## 字符流处理\r\n\r\n字符流处理（Fluent strings）提供了一种更流畅的、拥有面向对象接口形式的字符串处理方式，它允许使用比传统字符串操作更具可读性的语法来进行多字符串的链式操作。\r\n\r\n<a name=\"method-fluent-str-after\"></a>\r\n#### `after` {.collection-method}\r\n\r\n`after` 方法将返回字符串中指定值后的所有内容。如果字符串中不存在这个值，它将返回整个字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::of('This is my name')->after('This is');\r\n\r\n    // ' my name'\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-after-last\"></a>\r\n#### `afterLast` {.collection-method}\r\n\r\n`afterLast`方法返回字符串中指定值最后一次出现后的所有内容。如果字符串中不存在这个值，它将返回整个字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::of('App\\Http\\Controllers\\Controller')->afterLast('\\\\');\r\n\r\n    // 'Controller'\r\n\r\n<a name=\"method-fluent-str-append\"></a>\r\n#### `append` {.collection-method}\r\n\r\n`append` 方法为字符串附加上指定的值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Taylor')->append(' Otwell');\r\n\r\n    // 'Taylor Otwell'\r\n\r\n<a name=\"method-fluent-str-ascii\"></a>\r\n#### `ascii` {.collection-method}\r\n\r\n`ascii` 方法尝试将字符串转换为 ASCII 值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('ü')->ascii();\r\n\r\n    // 'u'\r\n\r\n<a name=\"method-fluent-str-basename\"></a>\r\n#### `basename` {.collection-method}\r\n\r\n`basename`方法将返回指定字符串的结尾部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('/foo/bar/baz')->basename();\r\n\r\n    // 'baz'\r\n\r\n如果有必要，你也可以提供提供一个「扩展名」，将从尾部的组件中移除它。\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('/foo/bar/baz.jpg')->basename('.jpg');\r\n\r\n    // 'baz'\r\n\r\n<a name=\"method-fluent-str-before\"></a>\r\n#### `before` {.collection-method}\r\n\r\n`before`方法返回字符串中指定值之前的所有内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::of('This is my name')->before('my name');\r\n\r\n    // 'This is '\r\n\r\n<a name=\"method-fluent-str-before-last\"></a>\r\n#### `beforeLast` {.collection-method}\r\n\r\n`beforeLast` 方法返回字符串中指定值最后一次出现前的所有内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slice = Str::of('This is my name')->beforeLast('is');\r\n\r\n    // 'This '\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-between\"></a>\r\n#### `between` {.collection-method}\r\n\r\n`between` 方法返回两个值之间的字符串部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::of('This is my name')->between('This', 'name');\r\n\r\n    // ' is my '\r\n\r\n<a name=\"method-fluent-str-camel\"></a>\r\n#### `camel` {.collection-method}\r\n\r\n`camel` 方法将指定字符串转换为 `驼峰式` 表示方法：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::of('foo_bar')->camel();\r\n\r\n    // fooBar\r\n\r\n<a name=\"method-fluent-str-contains\"></a>\r\n#### `contains` {.collection-method}\r\n\r\n`contains` 方法判断指定字符串中是否包含另一指定字符串（区分大小写）：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $contains = Str::of('This is my name')->contains('my');\r\n\r\n    // true\r\n\r\n你也可以传递数组的值的形式来判断指定字符串是否包含数组中的任一值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $contains = Str::of('This is my name')->contains(['my', 'foo']);\r\n\r\n    // true\r\n\r\n<a name=\"method-fluent-str-contains-all\"></a>\r\n#### `containsAll` {.collection-method}\r\n\r\n`containsAll` 方法用于判断指定字符串是否包含指定数组中的所有值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $containsAll = Str::of('This is my name')->containsAll(['my', 'name']);\r\n\r\n    // true\r\n\r\n<a name=\"method-fluent-str-dirname\"></a>\r\n#### `dirname` {.collection-method}\r\n\r\n`dirname` 方法用于返回指定字符串的父级目录部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('/foo/bar/baz')->dirname();\r\n\r\n    // '/foo/bar'\r\n\r\n你也可以指定你想要从字符串中删除多少个目录级别，该参数是可选的：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('/foo/bar/baz')->dirname(2);\r\n\r\n    // '/foo'\r\n\r\n<a name=\"method-fluent-str-excerpt\"></a>\r\n#### `excerpt` {.collection-method}\r\n\r\n`excerpt` 方法从字符串中提取与该字符串中短语的第一个实例匹配的片段：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $excerpt = Str::of('This is my name')->excerpt('my', [\r\n        'radius' => 3\r\n    ]);\r\n\r\n    // '...is my na...'\r\n\r\n\r\n\r\n`radius` 选项默认为 `100`，允许你定义应出现在截断字符串两侧的字符数。\r\n\r\n此外，你也可以使用 `omission` 选项来更改将附加到截断字符串的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $excerpt = Str::of('This is my name')->excerpt('name', [\r\n        'radius' => 3,\r\n        'omission' => '(...) '\r\n    ]);\r\n\r\n    // '(...) my name'\r\n\r\n<a name=\"method-fluent-str-ends-with\"></a>\r\n#### `endsWith` {.collection-method}\r\n\r\n`endsWith` 方法用于判断指定字符串是否以另一指定字符串结尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('This is my name')->endsWith('name');\r\n\r\n    // true\r\n\r\n你也可以传递数组的值的形式来判断指定字符串是否包含指定数组中的任一值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('This is my name')->endsWith(['name', 'foo']);\r\n\r\n    // true\r\n\r\n    $result = Str::of('This is my name')->endsWith(['this', 'foo']);\r\n\r\n    // false\r\n\r\n<a name=\"method-fluent-str-exactly\"></a>\r\n#### `exactly` {.collection-method}\r\n\r\n`exactly` 方法用于判断指定字符串是否与另一字符串完全匹配：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('Laravel')->exactly('Laravel');\r\n\r\n    // true\r\n\r\n<a name=\"method-fluent-str-explode\"></a>\r\n#### `explode` {.collection-method}\r\n\r\n`explode` 方法使用指定的分割符分割字符串，并返回包含字符串每个部分的集合：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $collection = Str::of('foo bar baz')->explode(' ');\r\n\r\n    // collect(['foo', 'bar', 'baz'])\r\n\r\n<a name=\"method-fluent-str-finish\"></a>\r\n#### `finish` {.collection-method}\r\n\r\n`finish` 方法用于判断指定字符串末尾是否有特定字符，若没有，则将其添加到字符串末尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $adjusted = Str::of('this/string')->finish('/');\r\n\r\n    // this/string/\r\n\r\n    $adjusted = Str::of('this/string/')->finish('/');\r\n\r\n    // this/string/\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-is\"></a>\r\n#### `is` {.collection-method}\r\n\r\n`is` 方法用于判断字符串是否与指定模式匹配。星号 `*` 用于表示通配符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $matches = Str::of('foobar')->is('foo*');\r\n\r\n    // true\r\n\r\n    $matches = Str::of('foobar')->is('baz*');\r\n\r\n    // false\r\n\r\n<a name=\"method-fluent-str-is-ascii\"></a>\r\n#### `isAscii` {.collection-method}\r\n\r\n`isAscii` 方法用于判断指定字符串是否是 ASCII 字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('Taylor')->isAscii();\r\n\r\n    // true\r\n\r\n    $result = Str::of('ü')->isAscii();\r\n\r\n    // false\r\n\r\n<a name=\"method-fluent-str-is-empty\"></a>\r\n#### `isEmpty` {.collection-method}\r\n\r\n`isEmpty` 方法用于判断指定字符串是否为空：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('  ')->trim()->isEmpty();\r\n\r\n    // true\r\n\r\n    $result = Str::of('Laravel')->trim()->isEmpty();\r\n\r\n    // false\r\n\r\n<a name=\"method-fluent-str-is-not-empty\"></a>\r\n#### `isNotEmpty` {.collection-method}\r\n\r\n`isNotEmpty` 方法用于判断指定字符串是否不为空：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('  ')->trim()->isNotEmpty();\r\n\r\n    // false\r\n\r\n    $result = Str::of('Laravel')->trim()->isNotEmpty();\r\n\r\n    // true\r\n\r\n<a name=\"method-fluent-str-is-uuid\"></a>\r\n#### `isUuid` {.collection-method}\r\n\r\n`isUuid` 方法确定给定字符串是否为 UUID：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('5ace9ab9-e9cf-4ec6-a19d-5881212a452c')->isUuid();\r\n\r\n    // true\r\n\r\n    $result = Str::of('Taylor')->isUuid();\r\n\r\n    // false\r\n\r\n<a name=\"method-fluent-str-kebab\"></a>\r\n#### `kebab` {.collection-method}\r\n\r\n`kebab` 方法将指定字符串转换为 `烤串式( kebab-case )` 表示形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::of('fooBar')->kebab();\r\n\r\n    // foo-bar\r\n\r\n<a name=\"method-fluent-str-length\"></a>\r\n#### `length` {.collection-method}\r\n\r\n`length` 方法返回指定字符串的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $length = Str::of('Laravel')->length();\r\n\r\n    // 7\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-limit\"></a>\r\n#### `limit` {.collection-method}\r\n\r\n`limit` 方法用于将指定字符串切割为指定长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $truncated = Str::of('The quick brown fox jumps over the lazy dog')->limit(20);\r\n\r\n    // The quick brown fox...\r\n\r\n你也可以通过第二个参数来改变追加到末尾的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $truncated = Str::of('The quick brown fox jumps over the lazy dog')->limit(20, ' (...)');\r\n\r\n    // The quick brown fox (...)\r\n\r\n<a name=\"method-fluent-str-lower\"></a>\r\n#### `lower` {.collection-method}\r\n\r\n`lower` 方法将指定字符串转换为小写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('LARAVEL')->lower();\r\n\r\n    // 'laravel'\r\n\r\n<a name=\"method-fluent-str-ltrim\"></a>\r\n#### `ltrim` {.collection-method}\r\n\r\n`ltrim` 方法移除字符串左端指定的字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('  Laravel  ')->ltrim();\r\n\r\n    // 'Laravel  '\r\n\r\n    $string = Str::of('/Laravel/')->ltrim('/');\r\n\r\n    // 'Laravel/'\r\n\r\n<a name=\"method-fluent-str-markdown\"></a>\r\n#### `markdown` {.collection-method}\r\n\r\n`markdown` 方法将 Github 风格的 Markdown 转换为 HTML：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $html = Str::of('# Laravel')->markdown();\r\n\r\n    // <h1>Laravel</h1>\r\n\r\n    $html = Str::of('# Taylor <b>Otwell</b>')->markdown([\r\n        'html_input' => 'strip',\r\n    ]);\r\n\r\n    // <h1>Taylor Otwell</h1>\r\n\r\n<a name=\"method-fluent-str-mask\"></a>\r\n#### `mask` {.collection-method}\r\n\r\n`mask` 方法用重复字符掩盖字符串的一部分，并可用于混淆字符串段，例如电子邮件地址和电话号码：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('taylor@example.com')->mask('*', 3);\r\n\r\n    // tay***************\r\n\r\n如果需要，你可以提供一个负数作为 `mask` 方法的第三个参数，这将指示该方法在距字符串末尾的给定距离处开始屏蔽：\r\n\r\n    $string = Str::of('taylor@example.com')->mask('*', -15, 3);\r\n\r\n    // tay***@example.com\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-match\"></a>\r\n#### `match` {.collection-method}\r\n\r\n`match` 方法将会返回字符串和指定正则表达式匹配的部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('foo bar')->match('/bar/');\r\n\r\n    // 'bar'\r\n\r\n    $result = Str::of('foo bar')->match('/foo (.*)/');\r\n\r\n    // 'bar'\r\n\r\n<a name=\"method-fluent-str-match-all\"></a>\r\n#### `matchAll` {.collection-method}\r\n\r\n`matchAll` 方法将会返回一个集合，该集合包含了指定字符串中与指定正则表达式匹配的部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('bar foo bar')->matchAll('/bar/');\r\n\r\n    // collect(['bar', 'bar'])\r\n\r\n如果你在正则表达式中指定了一个匹配组， Laravel 将会返回与该组匹配的集合：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('bar fun bar fly')->matchAll('/f(\\w*)/');\r\n\r\n    // collect(['un', 'ly']);\r\n\r\n如果没有找到任何匹配项，则返回空集合。\r\n\r\n<a name=\"method-fluent-str-padboth\"></a>\r\n#### `padBoth` {.collection-method}\r\n\r\n`padBoth` 方法包装了 PHP 的 `str_pad` 函数，在指定字符串的两侧填充上另一字符串，直至该字符串到达指定的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $padded = Str::of('James')->padBoth(10, '_');\r\n\r\n    // '__James___'\r\n\r\n    $padded = Str::of('James')->padBoth(10);\r\n\r\n    // '  James   '\r\n\r\n<a name=\"method-fluent-str-padleft\"></a>\r\n#### `padLeft` {.collection-method}\r\n\r\nThe `padLeft` 方法包装了 PHP 的 `str_pad` 函数，在指定字符串的左侧填充上另一字符串，直至该字符串到达指定的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $padded = Str::of('James')->padLeft(10, '-=');\r\n\r\n    // '-=-=-James'\r\n\r\n    $padded = Str::of('James')->padLeft(10);\r\n\r\n    // '     James'\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-padright\"></a>\r\n#### `padRight` {.collection-method}\r\n\r\n`padRight` 方法包装了 PHP 的 str_pad 函数，在指定字符串的右侧填充上另一字符串，直至该字符串到达指定的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $padded = Str::of('James')->padRight(10, '-');\r\n\r\n    // 'James-----'\r\n\r\n    $padded = Str::of('James')->padRight(10);\r\n\r\n    // 'James     '\r\n\r\n<a name=\"method-fluent-str-pipe\"></a>\r\n#### `pipe` {.collection-method}\r\n\r\n`pipe` 方法通过将字符串的当前值传递给给定的匿名函数来转换字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $hash = Str::of('Laravel')->pipe('md5')->prepend('Checksum: ');\r\n\r\n    // 'Checksum: a5c95b86291ea299fcbe64458ed12702'\r\n\r\n    $closure = Str::of('foo')->pipe(function ($str) {\r\n        return 'bar';\r\n    });\r\n\r\n    // 'bar'\r\n\r\n<a name=\"method-fluent-str-plural\"></a>\r\n#### `plural` {.collection-method}\r\n\r\n`plural` 方法将单数形式的字符串转换为复数形式。目前该函数仅支持英语：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $plural = Str::of('car')->plural();\r\n\r\n    // cars\r\n\r\n    $plural = Str::of('child')->plural();\r\n\r\n    // children\r\n\r\n你也可以给该函数提供一个整数作为第二个参数用于检索单数或复数形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $plural = Str::of('child')->plural(2);\r\n\r\n    // children\r\n\r\n    $plural = Str::of('child')->plural(1);\r\n\r\n    // child\r\n\r\n<a name=\"method-fluent-str-prepend\"></a>\r\n#### `prepend` {.collection-method}\r\n\r\n`prepend` 方法用于在指定字符串的开头插入另一指定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Framework')->prepend('Laravel ');\r\n\r\n    // Laravel Framework\r\n\r\n<a name=\"method-fluent-str-remove\"></a>\r\n#### `remove` {.collection-method}\r\n\r\n`remove` 方法从字符串中删除给定的值或值数组：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Arkansas is quite beautiful!')->remove('quite');\r\n\r\n    // Arkansas is beautiful!\r\n\r\n\r\n\r\n你还可以传递 `false` 作为第二个参数以在删除字符串时忽略大小写。\r\n\r\n<a name=\"method-fluent-str-replace\"></a>\r\n#### `replace` {.collection-method}\r\n\r\n`replace` 方法用于将字符串中的指定字符串替换为另一指定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $replaced = Str::of('Laravel 6.x')->replace('6.x', '7.x');\r\n\r\n    // Laravel 7.x\r\n\r\n<a name=\"method-fluent-str-replace-array\"></a>\r\n#### `replaceArray` {.collection-method}\r\n\r\n`replaceArray` 方法使用数组顺序替换字符串中的给定值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = 'The event will take place between ? and ?';\r\n\r\n    $replaced = Str::of($string)->replaceArray('?', ['8:30', '9:00']);\r\n\r\n    // The event will take place between 8:30 and 9:00\r\n\r\n<a name=\"method-fluent-str-replace-first\"></a>\r\n#### `replaceFirst` {.collection-method}\r\n\r\n`replaceFirst`方法替换字符串中给定值的第一个匹配项：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $replaced = Str::of('the quick brown fox jumps over the lazy dog')->replaceFirst('the', 'a');\r\n\r\n    // a quick brown fox jumps over the lazy dog\r\n\r\n<a name=\"method-fluent-str-replace-last\"></a>\r\n#### `replaceLast` {.collection-method}\r\n\r\n`replaceLast`方法替换字符串中给定值的最后一次出现：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $replaced = Str::of('the quick brown fox jumps over the lazy dog')->replaceLast('the', 'a');\r\n\r\n    // the quick brown fox jumps over a lazy dog\r\n\r\n<a name=\"method-fluent-str-replace-matches\"></a>\r\n#### `replaceMatches` {.collection-method}\r\n\r\n`replaceMatches`方法用给定的替换字符串替换与模式匹配的字符串的所有部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $replaced = Str::of('(+1) 501-555-1000')->replaceMatches('/[^A-Za-z0-9]++/', '')\r\n\r\n    // '15015551000'\r\n\r\n`replaceMatches`方法还接受一个闭包，该闭包将被与给定模式匹配的字符串的每个部分调用，从而允许你在闭包中执行替换逻辑并返回替换的值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $replaced = Str::of('123')->replaceMatches('/\\d/', function ($match) {\r\n        return '['.$match[0].']';\r\n    });\r\n\r\n    // '[1][2][3]'\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-rtrim\"></a>\r\n#### `rtrim` {.collection-method}\r\n\r\n`rtrim`方法修剪给定字符串的右侧：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('  Laravel  ')->rtrim();\r\n\r\n    // '  Laravel'\r\n\r\n    $string = Str::of('/Laravel/')->rtrim('/');\r\n\r\n    // '/Laravel'\r\n\r\n<a name=\"method-fluent-str-scan\"></a>\r\n#### `scan` {.collection-method}\r\n\r\n`scan` 方法根据 [`sscanf` PHP function](https://www.php.net/manual/en/function.sscanf.php) 支持的格式将字符串中的输入解析为集合：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $collection = Str::of('filename.jpg')->scan('%[^.].%s');\r\n\r\n    // collect(['filename', 'jpg'])\r\n\r\n<a name=\"method-fluent-str-singular\"></a>\r\n#### `singular` {.collection-method}\r\n\r\n`singular` 方法将字符串转换为其单数形式。此函数当前仅支持英语：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $singular = Str::of('cars')->singular();\r\n\r\n    // car\r\n\r\n    $singular = Str::of('children')->singular();\r\n\r\n    // child\r\n\r\n<a name=\"method-fluent-str-slug\"></a>\r\n#### `slug` {.collection-method}\r\n\r\n`slug` 方法从给定字符串生成URL友好的 `slug`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $slug = Str::of('Laravel Framework')->slug('-');\r\n\r\n    // laravel-framework\r\n\r\n<a name=\"method-fluent-str-snake\"></a>\r\n#### `snake` {.collection-method}\r\n\r\n`snake`方法将给定字符串转换为`snake_case`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::of('fooBar')->snake();\r\n\r\n    // foo_bar\r\n\r\n<a name=\"method-fluent-str-split\"></a>\r\n#### `split` {.collection-method}\r\n\r\n`split` 方法使用正则表达式将字符串拆分为集合：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $segments = Str::of('one, two, three')->split('/[\\s,]+/');\r\n\r\n    // collect([\"one\", \"two\", \"three\"])\r\n\r\n<a name=\"method-fluent-str-start\"></a>\r\n#### `start` {.collection-method}\r\n\r\n`start` 方法将给定值的单个实例添加到字符串中，前提是该字符串尚未以该值开头：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $adjusted = Str::of('this/string')->start('/');\r\n\r\n    // /this/string\r\n\r\n    $adjusted = Str::of('/this/string')->start('/');\r\n\r\n    // /this/string\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-starts-with\"></a>\r\n#### `startsWith` {.collection-method}\r\n\r\n`startsWith`方法确定给定字符串是否以给定值开头：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('This is my name')->startsWith('This');\r\n\r\n    // true\r\n\r\n<a name=\"method-fluent-str-studly\"></a>\r\n#### `studly` {.collection-method}\r\n\r\n`studly`方法将给定字符串转换为`StudlyCase`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::of('foo_bar')->studly();\r\n\r\n    // FooBar\r\n\r\n<a name=\"method-fluent-str-substr\"></a>\r\n#### `substr` {.collection-method}\r\n\r\n`substr`方法返回由给定的起始参数和长度参数指定的字符串部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Laravel Framework')->substr(8);\r\n\r\n    // Framework\r\n\r\n    $string = Str::of('Laravel Framework')->substr(8, 5);\r\n\r\n    // Frame\r\n\r\n<a name=\"method-fluent-str-substrreplace\"></a>\r\n#### `substrReplace` {.collection-method}\r\n\r\n`substrReplace` 方法在字符串的一部分中替换文本，从第二个参数指定的位置开始替换第三个参数指定的字符数。将 `0` 传递给方法的第三个参数将在指定位置插入字符串，而不替换字符串中的任何现有字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('1300')->substrReplace(':', 2);\r\n\r\n    // 13:\r\n\r\n    $string = Str::of('The Framework')->substrReplace(' Laravel', 3, 0);\r\n\r\n    // The Laravel Framework\r\n\r\n<a name=\"method-fluent-str-swap\"></a>\r\n#### `swap` {.collection-method}\r\n\r\n`swap` 方法使用 PHP 的 `strtr` 函数替换字符串中的多个值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Tacos are great!')\r\n        ->swap([\r\n            'Tacos' => 'Burritos',\r\n            'great' => 'fantastic',\r\n        ]);\r\n\r\n    // Burritos are fantastic!\r\n\r\n<a name=\"method-fluent-str-tap\"></a>\r\n#### `tap` {.collection-method}\r\n\r\n`tap`方法将字符串传递给给定的闭包，允许你在不影响字符串本身的情况下检查字符串并与之交互。`tap`方法返回原始字符串，而不管闭包返回什么：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Laravel')\r\n        ->append(' Framework')\r\n        ->tap(function ($string) {\r\n            dump('String after append: ' . $string);\r\n        })\r\n        ->upper();\r\n\r\n    // LARAVEL FRAMEWORK\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-test\"></a>\r\n#### `test` {.collection-method}\r\n\r\n`test` 方法确定字符串是否与给定的正则表达式模式匹配：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $result = Str::of('Laravel Framework')->test('/Laravel/');\r\n\r\n    // true\r\n\r\n<a name=\"method-fluent-str-title\"></a>\r\n#### `title` {.collection-method}\r\n\r\n`title`方法将给定字符串转换为`title Case`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $converted = Str::of('a nice title uses the correct case')->title();\r\n\r\n    // A Nice Title Uses The Correct Case\r\n\r\n<a name=\"method-fluent-str-trim\"></a>\r\n#### `trim` {.collection-method}\r\n\r\n`trim`方法修剪给定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('  Laravel  ')->trim();\r\n\r\n    // 'Laravel'\r\n\r\n    $string = Str::of('/Laravel/')->trim('/');\r\n\r\n    // 'Laravel'\r\n\r\n<a name=\"method-fluent-str-ucfirst\"></a>\r\n#### `ucfirst` {.collection-method}\r\n\r\n`ucfirst`方法返回第一个字符大写的给定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('foo bar')->ucfirst();\r\n\r\n    // Foo bar\r\n\r\n<a name=\"method-fluent-str-upper\"></a>\r\n#### `upper` {.collection-method}\r\n\r\n`upper`方法将给定字符串转换为大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $adjusted = Str::of('laravel')->upper();\r\n\r\n    // LARAVEL\r\n\r\n<a name=\"method-fluent-str-when\"></a>\r\n#### `when` {.collection-method}\r\n\r\n如果给定的条件为`true`，则`when`方法调用给定的闭包。闭包将接收一个流畅字符串实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Taylor')\r\n                    ->when(true, function ($string) {\r\n                        return $string->append(' Otwell');\r\n                    });\r\n\r\n    // 'Taylor Otwell'\r\n\r\n如果需要，可以将另一个闭包作为第三个参数传递给`when`方法。如果条件参数的计算结果为`false`，则将执行此闭包。\r\n\r\n<a name=\"method-fluent-str-when-contains\"></a>\r\n#### `whenContains` {.collection-method}\r\n\r\n`whenContains` 方法会在字符串包含给定的值的前提下，调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('tony stark')\r\n                ->whenContains('tony', function ($string) {\r\n                    return $string->title();\r\n                });\r\n\r\n    // 'Tony Stark'\r\n\r\n如有必要，你可以将另一个闭包作为第三个参数传递给 `when` 方法。如果字符串不包含给定值，则此闭包将执行。\r\n\r\n\r\n你还可以传递一个值数组来确定给定的字符串是否包含数组中的任何值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('tony stark')\r\n                ->whenContains(['tony', 'hulk'], function ($string) {\r\n                    return $string->title();\r\n                });\r\n\r\n    // Tony Stark\r\n\r\n<a name=\"method-fluent-str-when-contains-all\"></a>\r\n#### `whenContainsAll` {.collection-method}\r\n\r\n`whenContainsAll` 方法会在字符串包含所有给定的子字符串时，调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('tony stark')\r\n                    ->whenContainsAll(['tony', 'stark'], function ($string) {\r\n                        return $string->title();\r\n                    });\r\n\r\n    // 'Tony Stark'\r\n\r\n如有必要，你可以将另一个闭包作为第三个参数传递给 `when` 方法。如果条件参数评估为 `false`，则此闭包将执行。\r\n\r\n<a name=\"method-fluent-str-when-empty\"></a>\r\n#### `whenEmpty` {.collection-method}\r\n\r\n如果字符串为空，`whenEmpty`方法将调用给定的闭包。如果闭包返回一个值，`whenEmpty`方法也将返回该值。如果闭包不返回值，则将返回字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('  ')->whenEmpty(function ($string) {\r\n        return $string->trim()->prepend('Laravel');\r\n    });\r\n\r\n    // 'Laravel'\r\n\r\n<a name=\"method-fluent-str-when-not-empty\"></a>\r\n#### `whenNotEmpty` {.collection-method}\r\n\r\n如果字符串不为空，`whenNotEmpty` 方法会调用给定的闭包。如果闭包返回一个值，那么 `whenNotEmpty` 方法也将返回该值。如果闭包没有返回值，则返回字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Framework')->whenNotEmpty(function ($string) {\r\n        return $string->prepend('Laravel ');\r\n    });\r\n\r\n    // 'Laravel Framework'\r\n\r\n\r\n\r\n<a name=\"method-fluent-str-when-starts-with\"></a>\r\n#### `whenStartsWith` {.collection-method}\r\n\r\n如果字符串以给定的子字符串开头，`whenStartsWith` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('disney world')->whenStartsWith('disney', function ($string) {\r\n        return $string->title();\r\n    });\r\n\r\n    // 'Disney World'\r\n\r\n<a name=\"method-fluent-str-when-ends-with\"></a>\r\n#### `whenEndsWith` {.collection-method}\r\n\r\n如果字符串以给定的子字符串结尾，`whenEndsWith` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('disney world')->whenEndsWith('world', function ($string) {\r\n        return $string->title();\r\n    });\r\n\r\n    // 'Disney World'\r\n\r\n<a name=\"method-fluent-str-when-exactly\"></a>\r\n#### `whenExactly` {.collection-method}\r\n\r\n如果字符串与给定字符串完全匹配，`whenExactly` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('laravel')->whenExactly('laravel', function ($string) {\r\n        return $string->title();\r\n    });\r\n\r\n    // 'Laravel'\r\n\r\n<a name=\"method-fluent-str-when-is\"></a>\r\n#### `whenIs` {.collection-method}\r\n\r\n如果字符串匹配给定的模式，`whenIs` 方法会调用给定的闭包。星号可用作通配符值。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('foo/bar')->whenIs('foo/*', function ($string) {\r\n        return $string->append('/baz');\r\n    });\r\n\r\n    // 'foo/bar/baz'\r\n\r\n<a name=\"method-fluent-str-when-is-ascii\"></a>\r\n#### `whenIsAscii` {.collection-method}\r\n\r\n如果字符串是 7 位 ASCII，`whenIsAscii` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('foo/bar')->whenIsAscii('laravel', function ($string) {\r\n        return $string->title();\r\n    });\r\n\r\n    // 'Laravel'\r\n\r\n<a name=\"method-fluent-str-when-is-uuid\"></a>\r\n#### `whenIsUuid` {.collection-method}\r\n\r\n\r\n\r\n如果字符串是有效的 UUID，`whenIsUuid` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('foo/bar')->whenIsUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de', function ($string) {\r\n        return $string->substr(0, 8);\r\n    });\r\n\r\n    // 'a0a2a2d2'\r\n\r\n<a name=\"method-fluent-str-when-test\"></a>\r\n#### `whenTest` {.collection-method}\r\n\r\n如果字符串匹配给定的正则表达式，`whenTest` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('laravel framework')->whenTest('/laravel/', function ($string) {\r\n        return $string->title();\r\n    });\r\n\r\n    // 'Laravel Framework'\r\n\r\n<a name=\"method-fluent-str-word-count\"></a>\r\n#### `wordCount` {.collection-method}\r\n\r\n`wordCount` 方法返回字符串包含的单词数：\r\n\r\n```php\r\nuse Illuminate\\Support\\Str;\r\n\r\nStr::of('Hello, world!')->wordCount(); // 2\r\n```\r\n\r\n<a name=\"method-fluent-str-words\"></a>\r\n#### `words` {.collection-method}\r\n\r\n`words`方法限制字符串中的字数。如有必要，可以指定附加到截断字符串的附加字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $string = Str::of('Perfectly balanced, as all things should be.')->words(3, ' >>>');\r\n\r\n    // Perfectly balanced, as >>>\r\n\r\n<a name=\"urls\"></a>\r\n## URLs\r\n\r\n<a name=\"method-action\"></a>\r\n#### `action()` {.collection-method}\r\n\r\n`action`函数为给定的控制器操作生成URL：\r\n\r\n    use App\\Http\\Controllers\\HomeController;\r\n\r\n    $url = action([HomeController::class, 'index']);\r\n\r\n如果该方法接受路由参数，则可以将它们作为第二个参数传递给该方法：\r\n\r\n    $url = action([UserController::class, 'profile'], ['id' => 1]);\r\n\r\n<a name=\"method-asset\"></a>\r\n#### `asset()` {.collection-method}\r\n\r\n\r\n\r\n`asset`函数使用请求的当前方案（HTTP或HTTPS）为资产生成URL：\r\n\r\n    $url = asset('img/photo.jpg');\r\n\r\n你可以通过在`.env`文件中设置`ASSET_URL`变量来配置资产URL主机。如果你将资产托管在外部服务（如 Amazon S3 或其他 CDN）上，这将非常有用：\r\n\r\n    // ASSET_URL=http://example.com/assets\r\n\r\n    $url = asset('img/photo.jpg'); // http://example.com/assets/img/photo.jpg\r\n\r\n<a name=\"method-route\"></a>\r\n#### `route()` {.collection-method}\r\n\r\n`route`函数为给定的 [命名路由](/docs/laravel/9.x/routing#named-routes)：\r\n\r\n    $url = route('route.name');\r\n\r\n如果路由接受参数，则可以将其作为第二个参数传递给函数：\r\n\r\n    $url = route('route.name', ['id' => 1]);\r\n\r\n默认情况下，`route`函数生成一个绝对URL。如果要生成相对URL，可以将`false`作为第三个参数传递给函数：\r\n\r\n    $url = route('route.name', ['id' => 1], false);\r\n\r\n<a name=\"method-secure-asset\"></a>\r\n#### `secure_asset()` {.collection-method}\r\n\r\nThe `secure_asset` function generates a URL for an asset using HTTPS:\r\n\r\n    $url = secure_asset('img/photo.jpg');\r\n\r\n<a name=\"method-secure-url\"></a>\r\n#### `secure_url()` {.collection-method}\r\n\r\n`secure_url` 函数为给定路径生成一个完全限定的 HTTPS URL。额外的 URL 段可以在函数的第二个参数中传递：\r\n\r\n    $url = secure_url('user/profile');\r\n\r\n    $url = secure_url('user/profile', [1]);\r\n\r\n<a name=\"method-to-route\"></a>\r\n#### `to_route()` {.collection-method}\r\n\r\n`to_route` 函数为给定的 [命名路由](/docs/laravel/9.x/routing#named-routes) 生成 [重定向 HTTP 响应](/docs/laravel/9.x/responses#redirects)：\r\n\r\n    return to_route('users.show', ['user' => 1]);\r\n\r\n\r\n\r\n如有必要，你可以将应分配给重定向的 HTTP 状态代码和任何其他响应头作为第三和第四个参数传递给 `to_route` 方法：\r\n\r\n    return to_route('users.show', ['user' => 1], 302, ['X-Framework' => 'Laravel']);\r\n\r\n<a name=\"method-url\"></a>\r\n#### `url()` {.collection-method}\r\n\r\n使用 `url` 辅助方法生成指定路径的全路径 URL：\r\n\r\n    $url = url('user/profile');\r\n\r\n    $url = url('user/profile', [1]);\r\n\r\n如果没有指定路径，则返回 `Illuminate\\Routing\\UrlGenerator` 实例：\r\n\r\n    $current = url()->current();\r\n\r\n    $full = url()->full();\r\n\r\n    $previous = url()->previous();\r\n\r\n<a name=\"miscellaneous\"></a>\r\n## 杂项\r\n\r\n<a name=\"method-abort\"></a>\r\n#### `abort()` {.collection-method}\r\n\r\n使用 `abort` 方法抛出[一个 HTTP 异常](/docs/laravel/9.x/errors#http-exceptions)交给[异常处理](/docs/laravel/9.x/errors#the-exception-handler)：\r\n\r\n    abort(403);\r\n\r\n你还可以提供应发送到浏览器的异常消息和自定义 HTTP 响应标头：\r\n\r\n    abort(403, 'Unauthorized.', $headers);\r\n\r\n<a name=\"method-abort-if\"></a>\r\n#### `abort_if()` {.collection-method}\r\n\r\n如果给定的布尔表达式评估为`true`，`abort_if`函数将引发HTTP异常：\r\n\r\n    abort_if(! Auth::user()->isAdmin(), 403);\r\n\r\n像`abort`方法一样，你也可以将异常的响应文本作为第三个参数，并将自定义响应标头的数组作为该函数的第四个参数。\r\n\r\n<a name=\"method-abort-unless\"></a>\r\n#### `abort_unless()` {.collection-method}\r\n\r\n如果给定的布尔表达式评估为` false`，则`abort_unless`函数将引发 HTTP 异常：\r\n\r\n    abort_unless(Auth::user()->isAdmin(), 403);\r\n\r\n像`abort`方法一样，你也可以将异常的响应文本作为第三个参数，并将自定义响应标头的数组作为该函数的第四个参数。\r\n\r\n\r\n\r\n<a name=\"method-app\"></a>\r\n#### `app()` \r\n\r\n`app` 方法返回 [服务容器](/docs/laravel/9.x/container) 实例：\r\n\r\n    $container = app();\r\n\r\n你可以传递类或接口名称来从容器中解析它：\r\n\r\n    $api = app('HelpSpot\\API');\r\n\r\n<a name=\"method-auth\"></a>\r\n#### `auth()` {.collection-method}\r\n\r\n`auth` 函数返回一个 [认证器](/docs/laravel/9.x/authentication) 实例. 你可以使用它来替代 `Auth` 门面：\r\n\r\n    $user = auth()->user();\r\n\r\n如果需要，你可以指定你想要访问的认证实例：\r\n\r\n    $user = auth('admin')->user();\r\n\r\n<a name=\"method-back\"></a>\r\n#### `back()` {.collection-method}\r\n\r\n`back` 函数生成一个 [重定向 HTTP 响应](/docs/laravel/9.x/responses#redirects) 到用户之前的位置\r\n\r\n    return back($status = 302, $headers = [], $fallback = '/');\r\n\r\n    return back();\r\n\r\n<a name=\"method-bcrypt\"></a>\r\n#### `bcrypt()` {.collection-method}\r\n\r\nThe `bcrypt` 函数 [哈希](/docs/laravel/9.x/hashing) 使用 Bcrypt 对给定的值进行散列。 你可以使用它替代 `Hash` 门面：\r\n\r\n    $password = bcrypt('my-secret-password');\r\n\r\n<a name=\"method-blank\"></a>\r\n#### `blank()` {.collection-method}\r\n\r\n`blank` 函数判断给定的值是否为空：\r\n\r\n    blank('');\r\n    blank('   ');\r\n    blank(null);\r\n    blank(collect());\r\n\r\n    // true\r\n\r\n    blank(0);\r\n    blank(true);\r\n    blank(false);\r\n\r\n    // false\r\n\r\n如果想使用与 `blank`, 函数相反的方法，请看 [`filled`](#method-filled) 函数.\r\n\r\n<a name=\"method-broadcast\"></a>\r\n#### `broadcast()` {.collection-method}\r\n\r\n`broadcast` 函数将 [广播](/docs/laravel/9.x/broadcasting) 给定的 [事件](/docs/laravel/9.x/events) 到它的监听器：\r\n\r\n    broadcast(new UserRegistered($user));\r\n\r\n    broadcast(new UserRegistered($user))->toOthers();\r\n\r\n<a name=\"method-cache\"></a>\r\n#### `cache()` {.collection-method}\r\n\r\n`cache` 函数可以从 [缓存](/docs/laravel/9.x/cache) 中获取值, 如果缓存中给定的键不存在，将返回一个可选的默认值：\r\n\r\n    $value = cache('key');\r\n\r\n    $value = cache('key', 'default');\r\n\r\n\r\n\r\n你可以通过向函数添加键值对数组来设置缓存项。与此同时，你还应该传递有效的秒数或者缓存的持续时间来设置缓存过期时间 ：\r\n\r\n    cache(['key' => 'value'], 300);\r\n\r\n    cache(['key' => 'value'], now()->addSeconds(10));\r\n\r\n<a name=\"method-class-uses-recursive\"></a>\r\n#### `class_uses_recursive()` {.collection-method}\r\n\r\n`class_uses_recursive` 函数返回一个类使用的所有 traits, 包括它所有父类使用的 traits ：\r\n\r\n    $traits = class_uses_recursive(App\\Models\\User::class);\r\n\r\n<a name=\"method-collect\"></a>\r\n#### `collect()` {.collection-method}\r\n\r\n`collect` 函数根据给定的值创建一个 [collection](/docs/laravel/9.x/collections) 实例：\r\n\r\n    $collection = collect(['taylor', 'abigail']);\r\n\r\n<a name=\"method-config\"></a>\r\n#### `config()` {.collection-method}\r\n\r\n`config` 函数获取 [configuration](/docs/laravel/9.x/configuration) 变量的值。 可以使用「点」语法访问配置的值，其中包括文件的名称和访问的选项，如果访问的配置选项不存在，你可以指定一个默认值并且返回这个默认值：\r\n\r\n    $value = config('app.timezone');\r\n\r\n    $value = config('app.timezone', $default);\r\n\r\n你也可以在运行时通过传递一个键／值对数组来设置配置变量, 但是，请注意，此函数仅影响当前请求的配置值，不会更新实际的配置值：\r\n\r\n    config(['app.debug' => true]);\r\n\r\n<a name=\"method-cookie\"></a>\r\n#### `cookie()` {.collection-method}\r\n\r\n`cookie`  函数创建一个新的 [cookie](/docs/laravel/9.x/requests#cookies) 实例 ：\r\n\r\n    $cookie = cookie('name', 'value', $minutes);\r\n\r\n<a name=\"method-csrf-field\"></a>\r\n#### `csrf_field()` {.collection-method}\r\n\r\n`csrf_field` 函数生成一个包含 CSRF 令牌值的 HTML 输入表单字段 `hidden` 。例如，使用 [Blade](/docs/laravel/9.x/blade)语法：\r\n\r\n    {{ csrf_field() }}\r\n\r\n\r\n\r\n<a name=\"method-csrf-token\"></a>\r\n#### `csrf_token()` {.collection-method}\r\n\r\n`csrf_token` 函数获取当前 CSRF 令牌的值：\r\n\r\n    $token = csrf_token();\r\n\r\n<a name=\"method-decrypt\"></a>\r\n#### `decrypt()` {.collection-method}\r\n\r\n`decrypt` 函数 [解密](/docs/laravel/9.x/encryption) 给定的值。你可以使用这个函数作为 `Crypt` 门面的替代：\r\n\r\n    $password = decrypt($value);\r\n\r\n<a name=\"method-dd\"></a>\r\n#### `dd()` {.collection-method}\r\n\r\n`dd` 函数打印输出给定的变量并且结束脚本运行：\r\n\r\n    dd($value);\r\n\r\n    dd($value1, $value2, $value3, ...);\r\n\r\n如果你不停止执行脚本，那么可以使用 [`dump`](#method-dump) 函数。\r\n\r\n<a name=\"method-dispatch\"></a>\r\n#### `dispatch()` {.collection-method}\r\n\r\n`dispatch` 函数将给定的 [任务](/docs/laravel/9.x/queues#creating-jobs) 推送到 Laravel [任务队列](/docs/laravel/9.x/queues)：\r\n\r\n    dispatch(new App\\Jobs\\SendEmails);\r\n\r\n<a name=\"method-dump\"></a>\r\n#### `dump()` {.collection-method}\r\n\r\n`dump` 打印给定的变量：\r\n\r\n    dump($value);\r\n\r\n    dump($value1, $value2, $value3, ...);\r\n\r\n如果你想要在打印后停止执行脚本，可以使用 [`dd`](#method-dd) 函数。\r\n\r\n<a name=\"method-encrypt\"></a>\r\n#### `encrypt()` {.collection-method}\r\n\r\n`encrypt` 函数 [加密](/docs/laravel/9.x/encryption) 给定的值。你可以使用这个函数作为 `Crypt`  门面的替代：\r\n\r\n    $secret = encrypt('my-secret-value');\r\n\r\n<a name=\"method-env\"></a>\r\n#### `env()` {.collection-method}\r\n\r\n`env` 函数可以获取 [环境变量](/docs/laravel/9.x/configuration#environment-configuration) 配置的值或者返回默认值：\r\n\r\n    $env = env('APP_ENV');\r\n\r\n    $env = env('APP_ENV', 'production');\r\n\r\n> 注意：如果你在部署过程中执行了 `config:cache` 命令 , 那么你应该确保只从配置文件中调用 `env` 函数. 一旦配置被缓存， `.env` 文件将不再次加载，所有对 `env` 函数的调用将返回 `null`。\r\n\r\n\r\n\r\n<a name=\"method-event\"></a>\r\n#### `event()` {.collection-method}\r\n\r\n`event`函数向监听器派发给定 [事件](/docs/laravel/9.x/events) ：\r\n\r\n    event(new UserRegistered($user));\r\n\r\n<a name=\"method-filled\"></a>\r\n#### `filled()` {.collection-method}\r\n\r\n`filled` 函数返回是否不为「空」：\r\n\r\n    filled(0);\r\n    filled(true);\r\n    filled(false);\r\n\r\n    // true\r\n\r\n    filled('');\r\n    filled('   ');\r\n    filled(null);\r\n    filled(collect());\r\n\r\n    // false\r\n\r\n对于作用与 `filled`, 相反的方法，可以查看 [`blank`](#method-blank) 方法。\r\n\r\n<a name=\"method-info\"></a>\r\n#### `info()` {.collection-method}\r\n\r\n`info` 函数将信息写入 [log](/docs/laravel/9.x/logging)：\r\n\r\n    info('Some helpful information!');\r\n\r\n可以将上下文数据数组传递给此函数：\r\n\r\n    info('User login attempt failed.', ['id' => $user->id]);\r\n\r\n<a name=\"method-logger\"></a>\r\n#### `logger()` {.collection-method}\r\n\r\n`logger` 函数可以被用于将 `debug` 级别的消息写入 [log](/docs/laravel/9.x/logging)：\r\n\r\n    logger('Debug message');\r\n\r\n上下文数据数组也可以传递给函数：\r\n\r\n    logger('User has logged in.', ['id' => $user->id]);\r\n\r\n如果不带参数调用此函数，它将返回 [logger](/docs/laravel/9.x/errors#logging) 实例：\r\n\r\n    logger()->error('You are not allowed here.');\r\n\r\n<a name=\"method-method-field\"></a>\r\n#### `method_field()` {.collection-method}\r\n\r\n`method_field` 函数生成包含模仿表单 HTTP 动作的 HTML `hidden` 域。下面的例子使用了 [Blade 语法](/docs/laravel/9.x/blade)：\r\n\r\n    <form method=\"POST\">\r\n        {{ method_field('DELETE') }}\r\n    </form>\r\n\r\n<a name=\"method-now\"></a>\r\n#### `now()` {.collection-method}\r\n\r\n`now` 函数为当前时间创建一个新的 `Illuminate\\Support\\Carbon` 实例：\r\n\r\n    $now = now();\r\n\r\n<a name=\"method-old\"></a>\r\n\r\n\r\n#### `old()` {.collection-method}\r\n\r\n`old` 函数 [获取](/docs/laravel/9.x/requests#retrieving-input) 写入 `session` 的 [旧的输入值](/docs/laravel/9.x/requests#old-input) ：\r\n\r\n    $value = old('value');\r\n\r\n    $value = old('value', 'default');\r\n\r\n<a name=\"method-optional\"></a>\r\n#### `optional()` {.collection-method}\r\n\r\n`optional` 函数接受任何参数，并允许你访问该对象的属性或调用方法。如果给定的对象为 null，属性和方法将返回 null 而不是导致错误：\r\n\r\n    return optional($user->address)->street;\r\n\r\n    {!! old('name', optional($user)->name) !!}\r\n\r\n`optional` 函数也接受闭包作为第二个参数。如果第一个参数提供的值不为空，闭包将被调用：\r\n\r\n    return optional(User::find($id), function ($user) {\r\n        return $user->name;\r\n    });\r\n\r\n<a name=\"method-policy\"></a>\r\n#### `policy()` {.collection-method}\r\n\r\n`policy` 方法为给定的类获取 [policy](/docs/laravel/9.x/authorization#creating-policies) 实例\r\n\r\n    $policy = policy(App\\Models\\User::class);\r\n\r\n<a name=\"method-redirect\"></a>\r\n#### `redirect()` {.collection-method}\r\n\r\n`redirect` 函数返回 [重定向 HTTP 响应](/docs/laravel/9.x/responses#redirects)，如果不带参数调用则返回重定向器实例：\r\n\r\n    return redirect($to = null, $status = 302, $headers = [], $https = null);\r\n\r\n    return redirect('/home');\r\n\r\n    return redirect()->route('route.name');\r\n\r\n<a name=\"method-report\"></a>\r\n#### `report()` {.collection-method}\r\n\r\n`report` 函数使用 [异常处理器](/docs/laravel/9.x/errors#the-exception-handler) 的 `report` 方法报告异常：\r\n\r\n    report($e);\r\n\r\n`report` 函数也接受一个字符串作为参数。当给函数一个字符串时，函数将创建一个异常，并将该字符串作为其消息：\r\n\r\n    report('Something went wrong.');\r\n\r\n\r\n\r\n<a name=\"method-request\"></a>\r\n#### `request()` {.collection-method}\r\n\r\n`request` 函数返回当前的 [request](/docs/laravel/9.x/requests)实例或从当前请求中获取输入字段的值：\r\n\r\n    $request = request();\r\n\r\n    $value = request('key', $default);\r\n\r\n<a name=\"method-rescue\"></a>\r\n#### `rescue()` {.collection-method}\r\n\r\n`rescue` 函数执行给定的闭包，并且捕获其执行过程中引发的任何异常。捕获的所有异常都将传递给 [异常处理器](/docs/laravel/9.x/errors#the-exception-handler)；然后继续处理此次请求：\r\n\r\n    return rescue(function () {\r\n        return $this->method();\r\n    });\r\n\r\n还可以为其传递第二个参数。这个参数将作为执行闭包引发异常时的「默认」值：\r\n\r\n    return rescue(function () {\r\n        return $this->method();\r\n    }, false);\r\n\r\n    return rescue(function () {\r\n        return $this->method();\r\n    }, function () {\r\n        return $this->failure();\r\n    });\r\n\r\n<a name=\"method-resolve\"></a>\r\n#### `resolve()` {.collection-method}\r\n\r\n`resolve` 使用 [服务容器](/docs/laravel/9.x/container) 解析给定名称的类或接口的实例：\r\n\r\n    $api = resolve('HelpSpot\\API');\r\n\r\n<a name=\"method-response\"></a>\r\n#### `response()` {.collection-method}\r\n\r\n`response` 函数创建 [响应](/docs/laravel/9.x/responses) 实例，或者获取响应工厂的实例：\r\n\r\n    return response('Hello World', 200, $headers);\r\n\r\n    return response()->json(['foo' => 'bar'], 200, $headers);\r\n\r\n<a name=\"method-retry\"></a>\r\n#### `retry()` {.collection-method}\r\n\r\n`retry` 函数尝试执行给定的回调，直到达到给定的最大尝试阈值。如果回调没有抛出异常，回调返回值将被返回。如果回调抛出异常，将自动重试。达到最大尝试次数，将抛出异常：\r\n\r\n    return retry(5, function () {\r\n        // Attempt 5 times while resting 100ms between attempts...\r\n    }, 100);\r\n\r\n\r\n\r\n如果你想手动计算两次尝试之间休眠的毫秒数，您可以将闭包作为第三个参数传递给 `retry` 函数：\r\n\r\n    return retry(5, function () {\r\n        // ...\r\n    }, function ($attempt) {\r\n        return $attempt * 100;\r\n    });\r\n\r\n方便起见，你可以提供一个数组作为 `retry` 函数的第一个参数。该数组将用于确定后续尝试之间要休眠的毫秒数：\r\n\r\n    return retry([100, 200] function () {\r\n        // Sleep for 100ms on first retry, 200ms on second retry...\r\n    });\r\n\r\n要仅在特定条件下重试，你可以将闭包作为第四个参数传递给 `retry` 函数：\r\n\r\n    return retry(5, function () {\r\n        // ...\r\n    }, 100, function ($exception) {\r\n        return $exception instanceof RetryException;\r\n    });\r\n\r\n<a name=\"method-session\"></a>\r\n#### `session()` {.collection-method}\r\n\r\n`session` 函数用于获取或设置 [session](/docs/laravel/9.x/session) 值：\r\n\r\n    $value = session('key');\r\n\r\n可以向该函数传递键值对数组来设置 session 值：\r\n\r\n    session(['chairs' => 7, 'instruments' => 3]);\r\n\r\n不带参数调用此函数，则返回 session 实例：\r\n\r\n    $value = session()->get('key');\r\n\r\n    session()->put('key', $value);\r\n\r\n<a name=\"method-tap\"></a>\r\n#### `tap()` {.collection-method}\r\n\r\n`tap` 函数接受两个参数： 任意 `$value` 和闭包。 `$value` 将被传递给闭包，并被 `tap` 函数返回。与闭包的返回值无关：\r\n\r\n    $user = tap(User::first(), function ($user) {\r\n        $user->name = 'taylor';\r\n\r\n        $user->save();\r\n    });\r\n\r\n如果没有向 `tap` 函数传递闭包，可以调用给定 `$value` 的任意方法。调用此方法的返回值永远是 `$value` ，无论方法在其定义中返回什么。例如，Eloquent 的 `update` 方法指定返回一个整数。但是，我们可以通过 `tap` 函数链式调用 `update` 方法强制其返回模型自身：\r\n\r\n    $user = tap($user)->update([\r\n        'name' => $name,\r\n        'email' => $email,\r\n    ]);\r\n\r\n\r\n\r\n要向类中添加 `tap` 方法，可以将 `Illuminate\\Support\\Traits\\Tappable` 特征添加到类中。 此特征的 `tap` 方法接受闭包作为其唯一参数。 对象实例本身将传递给闭包，然后由 `tap` 方法返回：\r\n\r\n    return $user->tap(function ($user) {\r\n        //\r\n    });\r\n\r\n<a name=\"method-throw-if\"></a>\r\n#### `throw_if()` {.collection-method}\r\n\r\n在给定的布尔表达式结果为 `true` 时，`throw_if` 函数抛出给定的异常：\r\n\r\n    throw_if(! Auth::user()->isAdmin(), AuthorizationException::class);\r\n\r\n    throw_if(\r\n        ! Auth::user()->isAdmin(),\r\n        AuthorizationException::class,\r\n        'You are not allowed to access this page.'\r\n    );\r\n\r\n<a name=\"method-throw-unless\"></a>\r\n#### `throw_unless()` {.collection-method}\r\n\r\n在给定的布尔表达式结果为 `false` 时，`throw_unless` 函数抛出给定的异常：\r\n\r\n    throw_unless(Auth::user()->isAdmin(), AuthorizationException::class);\r\n\r\n    throw_unless(\r\n        Auth::user()->isAdmin(),\r\n        AuthorizationException::class,\r\n        'You are not allowed to access this page.'\r\n    );\r\n\r\n<a name=\"method-today\"></a>\r\n#### `today()` {.collection-method}\r\n\r\n`today` 函数根据当前日期创建新的 `Illuminate\\Support\\Carbon` 实例：\r\n\r\n    $today = today();\r\n\r\n<a name=\"method-trait-uses-recursive\"></a>\r\n#### `trait_uses_recursive()` {.collection-method}\r\n\r\n`trait_uses_recursive` 返回被 `trait` 使用的全部 `trait`：\r\n\r\n    $traits = trait_uses_recursive(\\Illuminate\\Notifications\\Notifiable::class);\r\n\r\n<a name=\"method-transform\"></a>\r\n#### `transform()` {.collection-method}\r\n\r\n`transform` 函数执行基于（非[空](#method-blank)）给定值的 闭包，并返回闭包的结果：\r\n\r\n    $callback = function ($value) {\r\n        return $value * 2;\r\n    };\r\n\r\n    $result = transform(5, $callback);\r\n\r\n    // 10\r\n\r\n还可以传递一个默认值或闭包作为该函数的第三个参数。如果给定的值为空时，返回该值：\r\n\r\n    $result = transform(null, $callback, 'The value is blank');\r\n\r\n    // The value is blank\r\n\r\n\r\n\r\n<a name=\"method-validator\"></a>\r\n#### `validator()` {.collection-method}\r\n\r\n`validator` 函数根据指定的参数创建一个新的 [验证器](/docs/laravel/9.x/validation) 实例。方便起见可以用它来代替 `Validator` facade：\r\n\r\n    $validator = validator($data, $rules, $messages);\r\n\r\n<a name=\"method-value\"></a>\r\n#### `value()` {.collection-method}\r\n\r\n`value` 函数返回给定值。如果传递闭包给此函数，将执行闭包并返回闭包调用的结果：\r\n\r\n    $result = value(true);\r\n\r\n    // true\r\n\r\n    $result = value(function () {\r\n        return false;\r\n    });\r\n\r\n    // false\r\n\r\n<a name=\"method-view\"></a>\r\n#### `view()` {.collection-method}\r\n\r\n`view` 函数获取一个 [视图](/docs/laravel/9.x/views) 实例：\r\n\r\n    return view('auth.login');\r\n\r\n<a name=\"method-with\"></a>\r\n#### `with()` {.collection-method}\r\n\r\n`with` 函数返回给定的值。如果传递了一个 `闭包` 给第二个参数，那么会返回 `闭包` 执行的结果：\r\n\r\n    $callback = function ($value) {\r\n        return is_numeric($value) ? $value * 2 : 0;\r\n    };\r\n\r\n    $result = with(5, $callback);\r\n\r\n    // 10\r\n\r\n    $result = with(null, $callback);\r\n\r\n    // 0\r\n\r\n    $result = with(5, null);\r\n\r\n    // 5\r\n\r\n","p":"docs/helpers.html"},{"t":"http-client (HTTP 客户端)","d":"# HTTP 客户端\r\n\r\n- [简介](#introduction)\r\n- [创建请求](#making-requests)\r\n    - [请求数据](#request-data)\r\n    - [请求头](#headers)\r\n    - [认证](#authentication)\r\n    - [超时](#timeout)\r\n    - [重试](#retries)\r\n    - [错误处理](#error-handling)\r\n    - [Guzzle 选项](#guzzle-options)\r\n- [并发请求](#concurrent-requests)\r\n- [宏](#macros)\r\n- [测试](#testing)\r\n    - [模拟响应](#faking-responses)\r\n    - [注入请求](#inspecting-requests)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 为 [Guzzle HTTP 客户端](http://docs.guzzlephp.org/en/stable/) 提供了一套语义化且轻量的 API，让你可用快速地使用 HTTP 请求与其他 Web 应用进行通信。该 API 专注于其在常见用例中的快速实现以及良好的开发者体验。\r\n\r\n在开始之前，你需要确保你的项目已经安装了 Guzzle 包作为依赖项。默认情况下，Laravel 已经包含了 Guzzle 包。但如果你此前手动移除了它，你也可以通过 Composer 重新安装它：\r\n\r\n```shell\r\ncomposer require guzzlehttp/guzzle\r\n```\r\n\r\n<a name=\"making-requests\"></a>\r\n## 创建请求\r\n\r\n你可以使用 `Http` Facade 提供的 `head`, `get`, `post`, `put`, `patch`，以及 `delete` 方法来创建请求。首先，让我们先看一下如何发出一个基础的 `GET` 请求：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::get('http://example.com');\r\n\r\n`get` 方法返回一个 `Illuminate\\Http\\Client\\Response`的实例，该实例提供了大量的方法来检查请求的响应：\r\n\r\n    $response->body() : string;\r\n    $response->json($key = null) : array|mixed;\r\n    $response->object() : object;\r\n    $response->collect($key = null) : Illuminate\\Support\\Collection;\r\n    $response->status() : int;\r\n    $response->ok() : bool;\r\n    $response->successful() : bool;\r\n    $response->redirect(): bool;\r\n    $response->failed() : bool;\r\n    $response->serverError() : bool;\r\n    $response->clientError() : bool;\r\n    $response->header($header) : string;\r\n    $response->headers() : array;\r\n\r\n\r\n\r\n`Illuminate\\Http\\Client\\Response` 对象同样实现了 PHP 的 `ArrayAccess` 接口，这代表着你可以直接访问响应的 JSON 数据：\r\n\r\n    return Http::get('http://example.com/users/1')['name'];\r\n\r\n<a name=\"dumping-requests\"></a>\r\n#### 打印请求信息\r\n\r\n如果要在发送请求之前打印输出请求信息并且结束脚本运行，你应该在创建请求前调用 `dd` 方法：\r\n\r\n    return Http::dd()->get('http://example.com');\r\n\r\n<a name=\"request-data\"></a>\r\n### 请求数据\r\n\r\n大多数情况下，`POST`、 `PUT` 和 `PATCH` 携带着额外的请求数据是相当常见的。所以，这些方法的第二个参数接受一个包含着请求数据的数组。默认情况下，这些数据会使用 `application/json` 类型随请求发送：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::post('http://example.com/users', [\r\n        'name' => 'Steve',\r\n        'role' => 'Network Administrator',\r\n    ]);\r\n\r\n<a name=\"get-request-query-parameters\"></a>\r\n#### GET 请求查询参数\r\n\r\n在创建 `GET` 请求时，你可以通过直接向 URL 添加查询字符串 或是 将键值对作为第二个参数传递给 `get` 方法：\r\n\r\n    $response = Http::get('http://example.com/users', [\r\n        'name' => 'Taylor',\r\n        'page' => 1,\r\n    ]);\r\n\r\n<a name=\"sending-form-url-encoded-requests\"></a>\r\n#### 发送 URL 编码请求\r\n\r\n如果你希望使用 `application/x-www-form-urlencoded` 作为请求的数据类型，你应该在创建请求前调用 `asForm` 方法：\r\n\r\n    $response = Http::asForm()->post('http://example.com/users', [\r\n        'name' => 'Sara',\r\n        'role' => 'Privacy Consultant',\r\n    ]);\r\n\r\n<a name=\"sending-a-raw-request-body\"></a>\r\n#### 发送原始数据（Raw）请求\r\n\r\n如果你想使用一个原始请求体发送请求，你可以在创建请求前调用 `withBody` 方法。你还可以将数据类型作为第二个参数传递给 `withBody` 方法：\r\n\r\n    $response = Http::withBody(\r\n        base64_encode($photo), 'image/jpeg'\r\n    )->post('http://example.com/photo');\r\n\r\n\r\n\r\n<a name=\"multi-part-requests\"></a>\r\n#### Multi-Part 请求\r\n\r\n如果你希望将文件作为 Multipart 请求发送，你应该在创建请求前调用 `attach` 方法。该方法接受文件的名字（相当于 HTML Input 的 name 属性）以及它对应的内容。你也可以在第三个参数传入自定义的文件名称，这不是必须的。如果有需要，你也可以通过第三个参数来指定文件的文件名：\r\n\r\n    $response = Http::attach(\r\n        'attachment', file_get_contents('photo.jpg'), 'photo.jpg'\r\n    )->post('http://example.com/attachments');\r\n\r\n除了传递文件的原始内容，你也可以传递 Stream 流数据：\r\n\r\n    $photo = fopen('photo.jpg', 'r');\r\n\r\n    $response = Http::attach(\r\n        'attachment', $photo, 'photo.jpg'\r\n    )->post('http://example.com/attachments');\r\n\r\n<a name=\"headers\"></a>\r\n### 请求头\r\n\r\n你可以通过 `withHeaders` 方法添加请求头。该 `withHeaders` 方法接受一个数组格式的键 / 值对：\r\n\r\n    $response = Http::withHeaders([\r\n        'X-First' => 'foo',\r\n        'X-Second' => 'bar'\r\n    ])->post('http://example.com/users', [\r\n        'name' => 'Taylor',\r\n    ]);\r\n\r\n您可以使用 `accept` 方法指定应用程序响应您的请求所需的内容类型：\r\n\r\n    $response = Http::accept('application/json')->get('http://example.com/users');\r\n\r\n为方便起见，您可以使用 `acceptJson` 方法快速指定应用程序需要 `application/json` 内容类型来响应您的请求：\r\n\r\n    $response = Http::acceptJson()->get('http://example.com/users');\r\n\r\n<a name=\"authentication\"></a>\r\n### 认证\r\n\r\n你可以使用 `withBasicAuth` 和 `withDigestAuth` 方法来分别指定使用 Basic 或是 Digest 认证方式：\r\n\r\n    // Basic 认证方式...\r\n    $response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(...);\r\n\r\n    // Digest 认证方式...\r\n    $response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(...);\r\n\r\n<a name=\"bearer-tokens\"></a>\r\n\r\n\r\n#### Bearer 令牌\r\n\r\n如果你想要为你的请求快速添加 `Authorization` Token 令牌请求头，你可以使用 `withToken`  方法：\r\n\r\n    $response = Http::withToken('token')->post(...);\r\n\r\n<a name=\"timeout\"></a>\r\n### 超时\r\n\r\n该 `timeout` 方法用于指定响应的最大等待秒数：\r\n\r\n    $response = Http::timeout(3)->get(...);\r\n\r\n如果响应时间超过了指定的超时时间，将会抛出 `Illuminate\\Http\\Client\\ConnectionException` 异常。\r\n\r\n您可以尝试使用 `connectTimeout` 方法指定连接到服务器时等待的最大秒数：\r\n\r\n    $response = Http::connectTimeout(3)->get(...);\r\n\r\n<a name=\"retries\"></a>\r\n### 重试\r\n\r\n如果你希望 HTTP 客户端在发生客户端或服务端错误时自动进行重试，你可以使用 `retry` 方法。该`retry` 方法接受两个参数：重新尝试次数以及重试间隔（毫秒）：\r\n\r\n    $response = Http::retry(3, 100)->post(...);\r\n\r\n如果需要，您可以将第三个参数传递给该 `retry` 方法。第三个参数应该是一个可调用的，用于确定是否应该实际尝试重试。例如，您可能希望仅在初始请求遇到以下情况时重试请求 `ConnectionException`：\r\n\r\n    $response = Http::retry(3, 100, function ($exception) {\r\n        return $exception instanceof ConnectionException;\r\n    })->post(...);\r\n\r\n如果所有的请求都失败了， `Illuminate\\Http\\Client\\RequestException` 异常将会被抛出。如果您想禁用此行为，您可以提供 `throw` 一个值为 `false` 的参数。禁用时，客户端收到的最后一个响应将在尝试所有重试后返回：\r\n\r\n    $response = Http::retry(3, 100, throw: false)->post(...);\r\n\r\n\r\n\r\n<a name=\"error-handling\"></a>\r\n### 错误处理\r\n\r\n跟 Guzzle 的默认行为不同，Laravel HTTP 客户端并不会在客户端或服务端错误时抛出异常（`400` 及 `500` 状态码）。你可以通过 `successful`、 `clientError` 或是 `serverError` 方法来判断是否发生错误：\r\n\r\n    // 如果状态码在 200 - 300之间\r\n    $response->successful();\r\n\r\n    // 如果状态码 大于 400...\r\n    $response->failed();\r\n\r\n    // 如果状态码是 400 级别的错误...\r\n    $response->clientError();\r\n\r\n    // 如果状态码是 500 级别的错误...\r\n    $response->serverError();\r\n\r\n    // 如果出现客户端或服务器错误，请立即执行给定的回调...\r\n    $response->onError(callable $callback);\r\n\r\n<a name=\"throwing-exceptions\"></a>\r\n#### 抛出异常\r\n\r\n如果你希望请求在发生客户端或服务端错误时抛出 `Illuminate\\Http\\Client\\RequestException` 异常，你可以在请求实例上调用 `throw` 或 `throwIf` 方法：\r\n\r\n    $response = Http::post(...);\r\n\r\n    // 在客户端或服务端错误发生时抛出异常...\r\n    $response->throw();\r\n\r\n    // 如果发生错误且给定条件为true，则引发异常...\r\n    $response->throwIf($condition);\r\n\r\n    return $response['user']['id'];\r\n\r\n该 `Illuminate\\Http\\Client\\RequestException` 实例拥有一个 `$response` 公共属性，该属性允许你检查返回的响应。\r\n\r\n如果没有发生错误， `throw` 该方法返回响应实例，允许您将其他操作链接到该 `throw` 方法：\r\n\r\n    return Http::post(...)->throw()->json();\r\n\r\n如果你希望在抛出异常前进行一些操作，你可以向 `throw` 方法传递一个闭包。异常将会在闭包执行完成后自动抛出，你不必在闭包内手动抛出异常：\r\n\r\n    return Http::post(...)->throw(function ($response, $e) {\r\n        //\r\n    })->json();\r\n\r\n\r\n\r\n<a name=\"guzzle-options\"></a>\r\n### Guzzle 选项\r\n\r\n你可以使用 `withOptions` 方法来指定额外的 [Guzzle 请求配置](http://docs.guzzlephp.org/en/stable/request-options.html) 。该 `withOptions` 方法接受数组形式的键 / 值对：\r\n\r\n    $response = Http::withOptions([\r\n        'debug' => true,\r\n    ])->get('http://example.com/users');\r\n\r\n<a name=\"concurrent-requests\"></a>\r\n## 并发请求\r\n\r\n有时，您可能希望同时发出多个 HTTP 请求。换句话说，您希望同时分派多个请求，而不是按顺序发出请求。当与慢速 HTTP API 交互时，这可以显着提高性能。\r\n\r\n值得庆幸的是，您可以使用该 `pool` 方法完成此操作。该 `pool` 方法接受一个接收 `Illuminate\\Http\\Client\\Pool` 实例的闭包，允许您轻松地将请求添加到请求池以进行调度：\r\n\r\n    use Illuminate\\Http\\Client\\Pool;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $responses = Http::pool(fn (Pool $pool) => [\r\n        $pool->get('http://localhost/first'),\r\n        $pool->get('http://localhost/second'),\r\n        $pool->get('http://localhost/third'),\r\n    ]);\r\n\r\n    return $responses[0]->ok() &&\r\n           $responses[1]->ok() &&\r\n           $responses[2]->ok();\r\n\r\n如您所见，可以根据添加到池中的顺序访问每个响应实例。如果您愿意，您可以使用该 `as` 方法命名请求，该方法允许您按名称访问相应的响应：\r\n\r\n    use Illuminate\\Http\\Client\\Pool;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $responses = Http::pool(fn (Pool $pool) => [\r\n        $pool->as('first')->get('http://localhost/first'),\r\n        $pool->as('second')->get('http://localhost/second'),\r\n        $pool->as('third')->get('http://localhost/third'),\r\n    ]);\r\n\r\n    return $responses['first']->ok();\r\n\r\n\r\n\r\n<a name=\"macros\"></a>\r\n## Macros\r\n\r\nLaravel HTTP 客户端允许您定义「macros」，它可以作为一种流畅的、富有表现力的机制，在与整个应用程序中的服务交互时配置常见的请求路径和标头。首先，您可以在应用程序的 `App\\Providers\\AppServiceProvider` 类的 `boot` 方法中定义 `macro` ：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Http;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Http::macro('github', function () {\r\n        return Http::withHeaders([\r\n            'X-Example' => 'example',\r\n        ])->baseUrl('https://github.com');\r\n    });\r\n}\r\n```\r\n\r\n配置好宏后，您可以从应用程序中的任何位置调用它，以创建具有指定配置的待处理请求：\r\n\r\n```php\r\n$response = Http::github()->get('/');\r\n```\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n许多 Laravel 服务都提供了帮助您轻松且富有表现力地编写测试的功能，Laravel 的 HTTP 包装器也不例外。 `Http` 门面的 `fake` 方法允许您指示 HTTP 客户端在发出请求时返回存根/虚拟响应。\r\n\r\n<a name=\"faking-responses\"></a>\r\n### 伪造响应\r\n\r\n例如，要指示HTTP客户端为每个请求返回空的`200`状态码响应，您可以调用不带参数的`fake`方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Http::fake();\r\n\r\n    $response = Http::post(...);\r\n\r\n<a name=\"faking-specific-urls\"></a>\r\n#### 伪造特定URL\r\n\r\n或者，您也可以将数组传递给`fake`方法。\r\n数组的键应该表示您希望伪造的URL模式及其相关响应。\r\n字符`*‘可以用作通配符。\r\n对未被伪造的URL发出的任何请求都将实际执行。\r\n您可以使用`Http`外观的`response`方法为这些端点构造存根/假响应：\r\n\r\n    Http::fake([\r\n        // 为 GitHub 端点存根 JSON 响应...\r\n        'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),\r\n\r\n        // 为 Google 端点存根字符串响应...\r\n        'google.com/*' => Http::response('Hello World', 200, $headers),\r\n    ]);\r\n\r\n\r\n\r\n如果你想指定一个后备 URL 模式来存根所有不匹配的 URL，你可以使用单个 `*` 字符：\r\n\r\n    Http::fake([\r\n        // 为 GitHub 端点存根 JSON 响应...\r\n        'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),\r\n\r\n        // 为所有其他端点存根字符串响应...\r\n        '*' => Http::response('Hello World', 200, ['Headers']),\r\n    ]);\r\n\r\n<a name=\"faking-response-sequences\"></a>\r\n#### 伪造响应序列\r\n\r\n有时您可能需要指定单个 URL 应按特定顺序返回一系列虚假响应。您可以使用 `Http::sequence` 方法来构建响应来完成此操作：\r\n\r\n    Http::fake([\r\n        // 为 GitHub 端点存根一系列响应...\r\n        'github.com/*' => Http::sequence()\r\n                                ->push('Hello World', 200)\r\n                                ->push(['foo' => 'bar'], 200)\r\n                                ->pushStatus(404),\r\n    ]);\r\n\r\n当一个响应序列中的所有响应都被消费完后，任何进一步的请求都会导致响应序列抛出异常。如果您想指定在序列为空时应返回的默认响应，您可以使用 `whenEmpty` 方法：\r\n\r\n    Http::fake([\r\n        // 为 GitHub 端点存根一系列响应...\r\n        'github.com/*' => Http::sequence()\r\n                                ->push('Hello World', 200)\r\n                                ->push(['foo' => 'bar'], 200)\r\n                                ->whenEmpty(Http::response()),\r\n    ]);\r\n\r\n如果您想伪造一系列响应，但不需要指定应该伪造的特定 URL 模式，您可以使用 `Http::fakeSequence` 方法：\r\n\r\n    Http::fakeSequence()\r\n            ->push('Hello World', 200)\r\n            ->whenEmpty(Http::response());\r\n\r\n<a name=\"fake-callback\"></a>\r\n#### Fake 回调\r\n\r\n如果您需要更复杂的逻辑来确定为某些端点返回什么响应，您可以将闭包传递给 `fake` 方法。 这个闭包将接收一个 `Illuminate\\Http\\Client\\Request` 的实例并且应该返回一个响应实例。 在您的闭包中，您可以执行任何必要的逻辑来确定要返回的响应类型：\r\n\r\n    Http::fake(function ($request) {\r\n        return Http::response('Hello World', 200);\r\n    });\r\n\r\n\r\n\r\n<a name=\"inspecting-requests\"></a>\r\n### 检查请求\r\n\r\n在伪造响应时，您可能偶尔希望检查客户端收到的请求，以确保您的应用程序正在发送正确的数据或标头。您可以在调用 `Http::fake` 后调用 `Http::assertSent` 方法来完成此操作。\r\n\r\n`assertSent` 方法接受一个闭包，该闭包将接收一个 `Illuminate\\Http\\Client\\Request` 实例，并应返回一个布尔值，指示请求是否符合您的期望。为了使测试通过，必须至少发出一个符合给定期望的请求：\r\n\r\n    use Illuminate\\Http\\Client\\Request;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Http::fake();\r\n\r\n    Http::withHeaders([\r\n        'X-First' => 'foo',\r\n    ])->post('http://example.com/users', [\r\n        'name' => 'Taylor',\r\n        'role' => 'Developer',\r\n    ]);\r\n\r\n    Http::assertSent(function (Request $request) {\r\n        return $request->hasHeader('X-First', 'foo') &&\r\n               $request->url() == 'http://example.com/users' &&\r\n               $request['name'] == 'Taylor' &&\r\n               $request['role'] == 'Developer';\r\n    });\r\n\r\n如果需要，您可以使用 `assertNotSent` 方法断言未发送特定请求：\r\n\r\n    use Illuminate\\Http\\Client\\Request;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Http::fake();\r\n\r\n    Http::post('http://example.com/users', [\r\n        'name' => 'Taylor',\r\n        'role' => 'Developer',\r\n    ]);\r\n\r\n    Http::assertNotSent(function (Request $request) {\r\n        return $request->url() === 'http://example.com/posts';\r\n    });\r\n\r\n您可以使用 `assertSentCount` 方法来断言在测试期间“发送”了多少请求：\r\n\r\n    Http::fake();\r\n\r\n    Http::assertSentCount(5);\r\n\r\n或者，您可以使用 `assertNothingSent` 方法断言在测试期间没有发送任何请求：\r\n\r\n    Http::fake();\r\n\r\n    Http::assertNothingSent();\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\nLaravel 在发送 HTTP 请求的过程中会触发三个事件。 `RequestSending` 事件在发送请求之前触发，而 `ResponseReceived` 事件在收到给定请求的响应后触发。 如果没有收到给定请求的响应，则会触发 `ConnectionFailed` 事件。\r\n\r\n\r\n\r\n`RequestSending` 和 `ConnectionFailed` 事件都包含一个公共的 `$request` 属性，您可以使用它来检查 `Illuminate\\Http\\Client\\Request` 实例。 同样，`ResponseReceived`事件包含一个`$request`属性以及一个`$response`属性，可用于检查`Illuminate\\Http\\Client\\Response`实例。 你可以在你的 App\\Providers\\EventServiceProvider 服务提供者中为这个事件注册事件监听器：\r\n\r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Http\\Client\\Events\\RequestSending' => [\r\n            'App\\Listeners\\LogRequestSending',\r\n        ],\r\n        'Illuminate\\Http\\Client\\Events\\ResponseReceived' => [\r\n            'App\\Listeners\\LogResponseReceived',\r\n        ],\r\n        'Illuminate\\Http\\Client\\Events\\ConnectionFailed' => [\r\n            'App\\Listeners\\LogConnectionFailed',\r\n        ],\r\n    ];\r\n\r\n","p":"docs/http-client.html"},{"t":"localization (本地化)","d":"# 本地化\r\n\r\n- [简介](#introduction)\r\n    - [配置语言环境](#configuring-the-locale)\r\n- [定义翻译字符串](#defining-translation-strings)\r\n    - [使用短键](#using-short-keys)\r\n    - [使用翻译字符串作为键](#using-translation-strings-as-keys)\r\n- [检索翻译字符串](#retrieving-translation-strings)\r\n    - [替换翻译字符串中的参数](#replacing-parameters-in-translation-strings)\r\n    - [复数化](#pluralization)\r\n- [覆盖扩展包的语言文件](#overriding-package-language-files)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 的本地化功能提供了一种方便的方法来检索各种语言的字符串，从而使你可以轻松地在应用程序中支持多种语言。\r\n\r\nLaravel 提供了两种管理翻译字符串的方法。首先，语言字符串可以存储在`lang`目录里的文件中。在此目录中，可能存在应用程序支持的每种语言的子目录。这是 Laravel 用于管理内置 Laravel 功能（例如验证错误消息）的翻译字符串的方法：\r\n\r\n    /lang\r\n        /en\r\n            messages.php\r\n        /es\r\n            messages.php\r\n\r\n或者，可以在 `lang` 目录中放置的 JSON 文件中定义翻译字符串。采用这种方法时，应用程序支持的每种语言在此目录中都会有一个对应的 JSON 文件。对于具有大量可翻译字符串的应用，建议使用此方法：\r\n\r\n    /lang\r\n        en.json\r\n        es.json\r\n\r\n我们将在本文档中讨论每种管理翻译字符串的方法。\r\n\r\n<a name=\"configuring-the-locale\"></a>\r\n### 配置语言环境\r\n\r\n应用程序的默认语言存储在 `config/app.php` 配置文件的 `locale` 配置选项中。你可以随意修改此值以适合你的应用程序的需求。\r\n\r\n你可以使用 `App` Facade 提供的 `setLocale` 方法,在运行时通过单个 HTTP 请求修改默认语言：\r\n\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    Route::get('/greeting/{locale}', function ($locale) {\r\n        if (! in_array($locale, ['en', 'es', 'fr'])) {\r\n            abort(400);\r\n        }\r\n\r\n        App::setLocale($locale);\r\n\r\n        //\r\n    });\r\n\r\n\r\n\r\n你可以配置一个 “备用语言”，当当前语言不包含给定的翻译字符串时，将使用该语言。和默认语言一样，备用语言也是在`config/app.php`配置文件中配置的。\r\n\r\n    'fallback_locale' => 'en',\r\n\r\n<a name=\"determining-the-current-locale\"></a>\r\n#### 确定当前的语言环境\r\n\r\n你可以使用`currentLocale`和`isLocale`方法来确定当前的`locale`或检查`locale`是否是一个给定值。\r\n\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $locale = App::currentLocale();\r\n\r\n    if (App::isLocale('en')) {\r\n        //\r\n    }\r\n\r\n<a name=\"defining-translation-strings\"></a>\r\n## 定义翻译字符串\r\n\r\n<a name=\"using-short-keys\"></a>\r\n### 使用短键\r\n\r\n通常，翻译字符串存储在 `lang` 目录中的文件中。在这个目录中，应用程序支持的每种语言都应该有一个子目录。这是Laravel用于管理内置 Laravel 功能（如验证错误消息）的翻译字符串的方法：\r\n\r\n    /lang\r\n        /en\r\n            messages.php\r\n        /es\r\n            messages.php\r\n\r\n所有的语言文件都会返回一个键值对数组。比如下方这个例子：\r\n\r\n    <?php\r\n\r\n    // lang/en/messages.php\r\n\r\n    return [\r\n        'welcome' => 'Welcome to our application!',\r\n    ];\r\n\r\n> 注意：对于不同地区的语言，应根据 ISO 15897 命名语言目录。例如，英式英语应使用「en_GB」而不是 「en_gb」。\r\n\r\n<a name=\"using-translation-strings-as-keys\"></a>\r\n### 使用翻译字符串作为键\r\n\r\n对于具有大量可翻译字符串的应用程序，在视图中引用键时，使用「短键」定义每个字符串可能会令人困惑，并且为应用程序支持的每个翻译字符串不断发明键会很麻烦。\r\n\r\n出于这个原因，Laravel 还支持使用字符串的「默认」翻译作为键来定义翻译字符串。使用翻译字符串作为键的翻译文件作为JSON文件存储在 `lang` 目录中。例如，如果你的应用程序有西班牙语翻译，你应该创建一个 `lang/es.json` 文件：\r\n\r\n```json\r\n{\r\n    \"I love programming.\": \"Me encanta programar.\"\r\n}\r\n```\r\n\r\n#### 键 / 文件冲突\r\n\r\n你不应该定义和其他翻译文件的文件名存在冲突的键。例如，在 `nl/action.php` 文件存在，但 `nl.json` 文件不存在时，对 `NL` 语言翻译 `__('Action')` 会导致翻译器返回 `nl/action.php` 文件的全部内容。\r\n\r\n## 检索翻译字符串\r\n\r\n您可以使用 `__` 辅助函数从语言文件中检索翻译字符串。 如果您使用“短键”来定义翻译字符串，您应该使用“点”语法将包含键的文件和键本身传递给`__`函数。 例如，让我们从 `lang/en/messages.php` 语言文件中检索 `welcome` 翻译字符串：\r\n\r\n    echo __('messages.welcome');\r\n\r\n如果指定的翻译字符串不存在，`__` 函数将返回翻译字符串键。 因此，使用上面的示例，如果翻译字符串不存在，`__` 函数将返回 `messages.welcome`。\r\n\r\n  如果您使用 [默认翻译字符串作为翻译键](#using-translation-strings-as-keys)，则应将字符串的默认翻译传递给 `__` 函数；\r\n\r\n    echo __('I love programming.');\r\n\r\n同样，如果翻译字符串不存在，`__` 函数将返回给定的翻译字符串键。\r\n\r\n\r\n\r\n如果您使用的是 [Blade 模板引擎](/docs/laravel/9.x/blade)，则可以使用 `{{ }}` 语法来显示翻译字符串：\r\n\r\n    {{ __('messages.welcome') }}\r\n\r\n<a name=\"replacing-parameters-in-translation-strings\"></a>\r\n### 替换翻译字符串中的参数\r\n\r\n如果愿意，可以在翻译字符串中定义占位符。所有占位符的前缀都是 `:`。例如，可以使用占位符名称定义欢迎消息：\r\n\r\n    'welcome' => 'Welcome, :name',\r\n\r\n在要检索翻译字符串时替换占位符，可以将替换数组作为第二个参数传递给 `__` 函数：\r\n\r\n    echo __('messages.welcome', ['name' => 'dayle']);\r\n\r\n如果占位符包含所有大写字母，或仅首字母大写，则转换后的值将相应地转换成大写：\r\n\r\n    'welcome' => 'Welcome, :NAME', // Welcome, DAYLE\r\n    'goodbye' => 'Goodbye, :Name', // Goodbye, Dayle\r\n\r\n<a name=\"pluralization\"></a>\r\n### 复数化\r\n\r\n因为不同的语言有着各种复杂的复数化规则,所以复数化是个复杂的问题;不过Laravel 可以根据你定义的复数化规则帮助你翻译字符串。使用 `|` 字符，可以区分字符串的单数形式和复数形式：\r\n\r\n    'apples' => 'There is one apple|There are many apples',\r\n\r\n当然，使用 [翻译字符串作为键](#using-translation-strings-as-keys) 时也支持复数化：\r\n\r\n```json\r\n{\r\n    \"There is one apple|There are many apples\": \"Hay una manzana|Hay muchas manzanas\"\r\n}\r\n```\r\n\r\n你甚至可以创建更复杂的复数化规则，为多个值范围指定转换字符串：\r\n\r\n    'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many',\r\n\r\n定义具有复数选项的翻译字符串后，可以使用 `trans_choice`  函数检索给定「count」的行。在本例中，由于计数大于 1 ，因此返回翻译字符串的复数形式：\r\n\r\n    echo trans_choice('messages.apples', 10);\r\n\r\n\r\n\r\n也可以在复数化字符串中定义占位符属性。通过将数组作为第三个参数传递给 `trans_choice` 函数，可以替换这些占位符：\r\n\r\n    'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago',\r\n\r\n    echo trans_choice('time.minutes_ago', 5, ['value' => 5]);\r\n\r\n如果要显示传递给 `trans_choice` 函数的整数值，可以使用内置的 `:count` 占位符：\r\n\r\n    'apples' => '{0} There are none|{1} There is one|[2,*] There are :count',\r\n\r\n<a name=\"overriding-package-language-files\"></a>\r\n## 覆盖扩展包的语言文件\r\n\r\n有些包可能随自己的语言文件一起装运。你可以将文件放置在 `lang/vendor/{package}/{locale}` 目录中，而不是更改扩展包的核心文件来调整这些行。\r\n\r\n例如，如果需要重写位于名为 `skyrim/hearthfire` 的包的 `messages.php` 文件内容，应将语言文件放在： `lang/vendor/hearthfire/en/messages.php` 在这个文件中，你应该只定义要覆盖的翻译字符串。任何未重写的翻译字符串仍将从包的原始语言文件中加载。\r\n\r\n","p":"docs/localization.html"},{"t":"mail (邮件)","d":"# 邮件\r\n\r\n- [简介](#introduction)\r\n    - [配置](#configuration)\r\n    - [驱动前提](#driver-prerequisites)\r\n    - [故障转移配置](#failover-configuration)\r\n- [生成 Mailables](#generating-mailables)\r\n- [编写 Mailables](#writing-mailables)\r\n    - [配置发送者](#configuring-the-sender)\r\n    - [配置视图](#configuring-the-view)\r\n    - [视图数据](#view-data)\r\n    - [附件](#attachments)\r\n    - [内部附件](#inline-attachments)\r\n    - [自定义Symfony消息](#customizing-the-symfony-message)\r\n- [Markdown格式邮件](#markdown-mailables)\r\n    - [生成Markdown格式邮件](#generating-markdown-mailables)\r\n    - [编写Markdown格式邮件](#writing-markdown-messages)\r\n    - [自定义组件](#customizing-the-components)\r\n- [发送邮件](#sending-mail)\r\n    - [邮件队列](#queueing-mail)\r\n- [渲染邮件](#rendering-mailables)\r\n    - [浏览器中预览邮件](#previewing-mailables-in-the-browser)\r\n- [邮件本土化](#localizing-mailables)\r\n- [测试邮件](#testing-mailables)\r\n- [邮件与本地开发](#mail-and-local-development)\r\n- [事件](#events)\r\n- [自定义传输方式](#custom-transports)\r\n    - [附-Symfony传输方式](#additional-symfony-transports)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n发送邮件并不复杂。Laravel基于 [Symfony Mailer](https://symfony.com/doc/6.0/mailer.html) 组件提供了一个简洁、简单的邮件API。Laravel和Symfony 为  Mailer SMTP 、Mailgun 、Postmark 、 Amazon SES 、 及` sendmail ` （发送邮件的方式）提供驱动，允许你通过本地或者云服务来快速发送邮件。\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\nLaravel的邮件服务可以通过`config/mail.php`配置文件进行配置。\r\n邮件中的每一项都在配置文件中有单独的配置项，甚至是独有的「传输方式」，允许你的应用使用不同的邮件服务发送邮件。例如，你的应用程序在使用 Amazon SES 发送批量邮件时，也可以使用 Postmark 发送事务性邮件。\r\n在你的` mail `配置文件中，你将找到` mailers `配置数组。 该数组包含 Laravel 支持的每个邮件 驱动程序 / 传输方式 配置，而 `default `配置值确定当您的应用程序需要发送电子邮件时，默认情况下将使用哪个邮件驱动。\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动/传输的前提\r\n基于 API 的驱动，如 Mailgun 和 Postmark ，通常比 SMTP 服务器更简单快速。如果可以的话， 我们建议您使用下面这些驱动。\r\n\r\n<a name=\"mailgun-driver\"></a>\r\n#### Mailgun驱动\r\n要使用Mailgun驱动，可以先通过`composer`来安装`Mailgun`函数库 ：\r\n\r\n```shell\r\ncomposer require symfony/mailgun-mailer symfony/http-client\r\n```\r\n接着，在应用的`config/mail.php`配置文件中，将默认项设置成`mailgun`。配置好之后，确认`config/services.php`配置文件中包含以下选项：\r\n\r\n    'mailgun' => [\r\n        'domain' => env('MAILGUN_DOMAIN'),\r\n        'secret' => env('MAILGUN_SECRET'),\r\n    ],\r\n\r\n如果不使用 US [Mailgun region](https://documentation.mailgun.com/en/latest/api-intro.html#mailgun-regions)区域终端 ，您需要在`service`文件中配置区域终端：\r\n\r\n    'mailgun' => [\r\n        'domain' => env('MAILGUN_DOMAIN'),\r\n        'secret' => env('MAILGUN_SECRET'),\r\n        'endpoint' => env('MAILGUN_ENDPOINT', 'api.eu.mailgun.net'),\r\n    ],\r\n\r\n<a name=\"postmark-driver\"></a>\r\n#### Postmark 驱动\r\n要使用`Postmark`驱动，先通过`composer`来安装`Postmark`函数库：\r\n\r\n```shell\r\ncomposer require symfony/postmark-mailer symfony/http-client\r\n```\r\n\r\n接着，在应用的`config/mail.php`配置文件中，将默认项设置成`postmark`。配置好之后，确认`config/services.php`配置文件中包含如下选项：\r\n\r\n    'postmark' => [\r\n        'token' => env('POSTMARK_TOKEN'),\r\n    ],\r\n\r\n如果你要给指定邮件程序使用的 Postmark message stream，可以在配置数组中添加 `message_stream_id` 配置选项。 这个配置数组在应用程序的 `config/mail.php `配置文件中：\r\n\r\n    'postmark' => [\r\n        'transport' => 'postmark',\r\n        'message_stream_id' => env('POSTMARK_MESSAGE_STREAM_ID'),\r\n    ],\r\n\r\n\r\n\r\n这样，你还可以使用不同的 message stream 来设置多个 Postmark 邮件驱动。\r\n\r\n<a name=\"ses-driver\"></a>\r\n#### SES 驱动\r\n要使用 `Amazon SES` 驱动，你必须先安装 `PHP` 的 `Amazon AWS SDK` 。你可以可以通过 Composer 软件包管理器安装此库：\r\n\r\n```shell\r\ncomposer require aws/aws-sdk-php\r\n```\r\n然后，将 `config/mail.php` 配置文件的 `default` 选项设置成 `ses` 并确认你的 `config/services.php` 配置文件包含以下选项：\r\n\r\n    'ses' => [\r\n        'key' => env('AWS_ACCESS_KEY_ID'),\r\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n    ],\r\n\r\n为了通过session token来使用AWS [temporary credentials](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html) ，您需要向应用的SES配置中添加一个 `token` 键：\r\n\r\n    'ses' => [\r\n        'key' => env('AWS_ACCESS_KEY_ID'),\r\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n        'token' => env('AWS_SESSION_TOKEN'),\r\n    ],\r\n\r\n发送邮件，如果你想传递一些 [额外的选项](https://docs.aws.amazon.com/aws-sdk-php/v3/api/api-sesv2-2019-09-27.html#sendemail) 给AWS SDK的 `SendEmail`方法，你可以在`ses` 配置中定义一个`options`数组：\r\n\r\n    'ses' => [\r\n        'key' => env('AWS_ACCESS_KEY_ID'),\r\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n        'options' => [\r\n            'ConfigurationSetName' => 'MyConfigurationSet',\r\n            'EmailTags' => [\r\n                ['Name' => 'foo', 'Value' => 'bar'],\r\n            ],\r\n        ],\r\n    ],\r\n\r\n<a name=\"failover-configuration\"></a>\r\n### 备用配置\r\n有时候，已经配置好的，用来发送邮件的服务可能会失败/失效，这种情况下，定义一个或多个备用邮件配置项会非常有用，当你的主配置失效时，其它的将会起作用。\r\n\r\n\r\n为此，您应该在应用程序的 `mail` 配置文件中定义一个使用 `failover` 传输的邮件程序。 应用程序的 `failover` 邮件程序的配置数组应该包含一个 `mailers` 数组，这些邮件程序引用应该选择邮件驱动程序进行传递的顺序：\r\n\r\n    'mailers' => [\r\n        'failover' => [\r\n            'transport' => 'failover',\r\n            'mailers' => [\r\n                'postmark',\r\n                'mailgun',\r\n                'sendmail',\r\n            ],\r\n        ],\r\n\r\n        // ...\r\n    ],\r\n\r\n一旦定义了故障转移邮件程序，您应该将此邮件程序设置为应用程序使用的默认邮件程序，方法是将其名称指定为应用程序 `mail` 配置文件中的 `default` 配置键的值：\r\n\r\n    'default' => env('MAIL_MAILER', 'failover'),\r\n\r\n<a name=\"generating-mailables\"></a>\r\n## 生成 Mailables\r\n\r\n在构建 Laravel 应用程序时，应用程序发送的每种类型的电子邮件都表示为一个 `mailable` 类。 这些类存储在 `app/Mail` 目录中。 如果您在应用程序中看不到此目录，请不要担心，因为它会在您使用 `make:mail` Artisan 命令创建第一个可邮寄类时为您生成：\r\n\r\n```shell\r\nphp artisan make:mail OrderShipped\r\n```\r\n\r\n<a name=\"writing-mailables\"></a>\r\n## 编写 Mailables\r\n\r\n一旦你生成了一个 mailable 的类，打开它，这样我们就可以探索它的内容了。 首先，请注意所有可邮寄类的配置都是在 `build` 方法中完成的。 在此方法中，您可以调用各种方法，例如 `from`、`subject`、`view` 和 `attach` 来配置电子邮件的呈现和传递。\r\n\r\n> 技巧：您可以键入提示依赖于可邮寄的 `build` 方法。 Laravel [服务容器](/docs/laravel/9.x/container) 会自动注入这些依赖项。\r\n\r\n<a name=\"configuring-the-sender\"></a>\r\n\r\n\r\n### 配置发件人\r\n\r\n<a name=\"using-the-from-method\"></a>\r\n#### 使用 `from` 方法\r\n\r\n首先，让我们浏览一下邮件的发件人的配置。或者，换句话说，邮件来自谁。有两种方法配置发件人。第一种，你可以在 mailable 类的 `from` 方法中使用 `build` 方法：\r\n\r\n    /**\r\n     * 构建消息\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->from('example@example.com', 'Example')\r\n                    ->view('emails.orders.shipped');\r\n    }\r\n\r\n<a name=\"using-a-global-from-address\"></a>\r\n#### 使用全局 `from` 地址\r\n\r\n当然，如果你的应用在任何邮件中使用的「发件人」地址都一致的话，在你生成的每一个 mailable 类中调用 `from` 方法可能会很麻烦。因此，你可以在 `config/mail.php` 文件中指定一个全局的「发件人」地址。当某个 mailable 类没有指定「发件人」时，它将使用该全局「发件人」：\r\n\r\n    'from' => ['address' => 'example@example.com', 'name' => 'App Name'],\r\n\r\n此外，你可以在 `config/mail.php` 配置文件中定义一个全局的「回复」地址：\r\n\r\n    'reply_to' => ['address' => 'example@example.com', 'name' => 'App Name'],\r\n\r\n<a name=\"configuring-the-view\"></a>\r\n### 配置视图\r\n\r\n你可以在 mailable 类的 `build` 方法中使用 `view` 方法来指定在渲染邮件内容时要使用的模板。由于每封邮件通常使用 [Blade 模板](/docs/laravel/9.x/blade) 来渲染其内容，因此在构建邮件 HTML 内容时你可以使用 Blade 模板引擎提供的所有功能及享受其带来的便利性：\r\n\r\n    /**\r\n     * Build the message.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->view('emails.orders.shipped');\r\n    }\r\n\r\n> 技巧：你可以创建一个 `resources/views/emails` 目录来存放你的所有邮件模板；当然，你也可以将其置于 `resources/views` 目录下的任何位置。\r\n\r\n\r\n\r\n<a name=\"plain-text-emails\"></a>\r\n#### 纯文本邮件\r\n\r\n你可以使用 `text` 方法来定义一个纯文本格式的邮件。和 `view` 方法一样， 该 `text` 方法接受一个模板名，模板名指定了在渲染邮件内容时你想使用的模板。你既可以定义纯文本格式亦可定义 HTML 格式：\r\n\r\n    /**\r\n     * 构建消息.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->view('emails.orders.shipped')\r\n                    ->text('emails.orders.shipped_plain');\r\n    }\r\n\r\n<a name=\"view-data\"></a>\r\n### 视图数据\r\n\r\n<a name=\"via-public-properties\"></a>\r\n#### 通过 Public 属性\r\n\r\n通常情况下，你可能想要在渲染邮件的 HTML 内容时传递一些数据到视图中。有两种方法传递数据到视图中。第一种，你在 mailable 类中定义的所有 public 的属性都将自动传递到视图中。因此，举个例子，你可以将数据传递到你的 mailable 类的构造函数中，并将其设置为类的 public 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Mail;\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Mail\\Mailable;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipped extends Mailable\r\n    {\r\n        use Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 订单实例.\r\n         *\r\n         * @var \\App\\Models\\Order\r\n         */\r\n        public $order;\r\n\r\n        /**\r\n         * 创建一个消息实例.\r\n         *\r\n         * @param  \\App\\Models\\Order  $order\r\n         * @return void\r\n         */\r\n        public function __construct(Order $order)\r\n        {\r\n            $this->order = $order;\r\n        }\r\n\r\n        /**\r\n         * 构建消息.\r\n         *\r\n         * @return $this\r\n         */\r\n        public function build()\r\n        {\r\n            return $this->view('emails.orders.shipped');\r\n        }\r\n    }\r\n\r\n当数据被设置成为 public 属性之后，它将被自动传递到你的视图中，因此你可以像您在 Blade 模板中那样访问它们：\r\n\r\n    <div>\r\n        Price: {{ $order->price }}\r\n    </div>\r\n\r\n\r\n\r\n<a name=\"via-the-with-method\"></a>\r\n#### 通过  `with` 方法：\r\n\r\n如果你想要在邮件数据发送到模板前自定义它们的格式，你可以使用 `with` 方法来手动传递数据到视图中。一般情况下，你还是需要通过 mailable 类的构造函数来传递数据；不过，你应该将它们定义为  `protected` 或 `private` 以防止它们被自动传递到视图中。然后，在您调用 `with` 方法的时候，你可以以数组的形式传递你想要传递给模板的数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Mail;\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Mail\\Mailable;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipped extends Mailable\r\n    {\r\n        use Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 订单实例.\r\n         *\r\n         * @var \\App\\Models\\Order\r\n         */\r\n        protected $order;\r\n\r\n        /**\r\n         * 创建消息实例.\r\n         *\r\n         * @param  \\App\\Models\\Order  $order\r\n         * @return void\r\n         */\r\n        public function __construct(Order $order)\r\n        {\r\n            $this->order = $order;\r\n        }\r\n\r\n        /**\r\n         * 构建消息.\r\n         *\r\n         * @return $this\r\n         */\r\n        public function build()\r\n        {\r\n            return $this->view('emails.orders.shipped')\r\n                        ->with([\r\n                            'orderName' => $this->order->name,\r\n                            'orderPrice' => $this->order->price,\r\n                        ]);\r\n        }\r\n    }\r\n\r\n当数据使用 `with` 法传递后，你便可以在视图中使用它们，此时，便可以像 Blade 模板的方式来访问它们：\r\n\r\n    <div>\r\n        Price: {{ $orderPrice }}\r\n    </div>\r\n\r\n<a name=\"attachments\"></a>\r\n### 附件\r\n\r\n要在邮件中加入附件，在 `build` 方法中使用 `attach` 方法。 该 `attach` 方法接受文件的绝对路径作为它的第一个参数：\r\n\r\n    /**\r\n     * Build the message.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->view('emails.orders.shipped')\r\n                    ->attach('/path/to/file');\r\n    }\r\n\r\n\r\n\r\n当附加文件到消息时，你也可以传递一个 `array` 给 `attach` 方法作为第二个参数，以指定显示名称和 / 或是 MIME 类型：\r\n\r\n    /**\r\n     * 构建消息.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->view('emails.orders.shipped')\r\n                    ->attach('/path/to/file', [\r\n                        'as' => 'name.pdf',\r\n                        'mime' => 'application/pdf',\r\n                    ]);\r\n    }\r\n\r\n<a name=\"attaching-files-from-disk\"></a>\r\n#### 从磁盘中添加附件\r\n\r\n如果你已经在 [文件存储](/docs/laravel/9.x/filesystem) 上存储了一个文件，则可以使用 `attachFromStorage` 方法将其附加到邮件中：\r\n\r\n    /**\r\n     * 构建消息.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n       return $this->view('emails.orders.shipped')\r\n                   ->attachFromStorage('/path/to/file');\r\n    }\r\n\r\n如有必要，你可以使用 `attachFromStorage` 方法的第二个和第三个参数指定文件的附件名称和其他选项：\r\n\r\n    /**\r\n     * 构建消息.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n       return $this->view('emails.orders.shipped')\r\n                   ->attachFromStorage('/path/to/file', 'name.pdf', [\r\n                       'mime' => 'application/pdf'\r\n                   ]);\r\n    }\r\n\r\n如果需要指定默认磁盘以外的存储磁盘，可以使用 `attachFromStorageDisk` 方法：\r\n\r\n    /**\r\n     * 构建消息.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n       return $this->view('emails.orders.shipped')\r\n                   ->attachFromStorageDisk('s3', '/path/to/file');\r\n    }\r\n\r\n<a name=\"raw-data-attachments\"></a>\r\n#### 原始数据附件\r\n\r\n该 `attachData` 可以使用字节数据作为附件。例如，你可以使用这个方法将内存中生成而没有保存到磁盘中的 PDF 附加到邮件中。 `attachData` 方法第一个参数接收原始字节数据，第二个参数为文件名，第三个参数接受一个数组以指定其他参数：\r\n\r\n    /**\r\n     * 构建消息.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->view('emails.orders.shipped')\r\n                    ->attachData($this->pdf, 'name.pdf', [\r\n                        'mime' => 'application/pdf',\r\n                    ]);\r\n    }\r\n\r\n\r\n\r\n<a name=\"inline-attachments\"></a>\r\n### 内联附件\r\n\r\n在邮件中嵌入内联图片通常很麻烦；不过，Laravel 提供了一种将图像附加到邮件的便捷方法。可以使用邮件模板中 `$message` 变量的 `embed` 方法来嵌入内联图片。Laravel 自动使 `$message` 变量在全部邮件模板中可用，不需要担心手动传递它：\r\n\r\n```blade\r\n<body>\r\n    Here is an image:\r\n\r\n    <img src=\"{{ $message->embed($pathToImage) }}\">\r\n</body>\r\n```\r\n\r\n> 注意：该 `$message` 在文本消息中不可用，因为文本消息不能使用内联附件。\r\n\r\n<a name=\"embedding-raw-data-attachments\"></a>\r\n#### 嵌入原始数据附件\r\n\r\n如果你已经有了可以嵌入邮件模板的原始图像数据字符串，可以使用 `$message` 变量的  `embedData` 方法，当调用 `embedData` 方法时，需要传递一个文件名：\r\n\r\n```blade\r\n<body>\r\n    Here is an image from raw data:\r\n\r\n    <img src=\"{{ $message->embedData($data, 'example-image.jpg') }}\">\r\n</body>\r\n```\r\n\r\n<a name=\"customizing-the-symfony-message\"></a>\r\n### 自定义 Symfony 消息\r\n\r\n该 `Mailable` 基类的 `withSymfonyMessage` 方法允许您注册一个闭包，在发送消息之前将使用 Symfony 消息实例调用该闭包。这使您有机会在消息传递之前对其进行深度自定义：\r\n\r\n    use Symfony\\Component\\Mime\\Email;\r\n    \r\n    /**\r\n     * 构建消息.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        $this->view('emails.orders.shipped');\r\n\r\n        $this->withSymfonyMessage(function (Email $message) {\r\n            $message->getHeaders()->addTextHeader(\r\n                'Custom-Header', 'Header Value'\r\n            );\r\n        });\r\n\r\n        return $this;\r\n    }\r\n\r\n\r\n\r\n<a name=\"markdown-mailables\"></a>\r\n## Markdown 格式邮件\r\n\r\nMarkdown 格式邮件允许你可以使用 mailable 中的预构建模板和 [邮件通知](/docs/laravel/9.x/notifications#mail-notifications) 组件。由于消息是用 Markdown 编写，Laravel 能够渲染出美观的、响应式的 HTML 模板消息，同时还能自动生成纯文本副本。\r\n\r\n<a name=\"generating-markdown-mailables\"></a>\r\n### 生成 Markdown 邮件\r\n\r\n你可以在执行 `make:mail`  的 Artisan 命令时使用 `--markdown` 选项来生成一个 Markdown 格式模板的 mailable 类：\r\n\r\n```shell\r\nphp artisan make:mail OrderShipped --markdown=emails.orders.shipped\r\n```\r\n\r\n然后，在它的 `build` 方法中配置 mailable 类时，请使用 `markdown` 方法来代替 `view` 方法。 该 `markdown` 方法接受 Markdown 模板的名称和想要传递给模板的可选的数组形式的数据：\r\n\r\n    /**\r\n     * 构建消息.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->from('example@example.com')\r\n                    ->markdown('emails.orders.shipped', [\r\n                        'url' => $this->orderUrl,\r\n                    ]);\r\n    }\r\n\r\n<a name=\"writing-markdown-messages\"></a>\r\n### 编写 Markdown 邮件\r\n\r\nMarkdown mailable 类整合了 Markdown 语法和 Blade 组件，让你能够非常方便的使用 Laravel 预置的 UI 组件来构建邮件消息：\r\n\r\n```blade\r\n@component('mail::message')\r\n# Order Shipped\r\n\r\nYour order has been shipped!\r\n\r\n@component('mail::button', ['url' => $url])\r\nView Order\r\n@endcomponent\r\n\r\nThanks,<br>\r\n{{ config('app.name') }}\r\n@endcomponent\r\n```\r\n\r\n> 技巧：在编写 Markdown 邮件的时候，请勿使用额外的缩进。Markdown 解析器会把缩进渲染成代码块。\r\n\r\n<a name=\"button-component\"></a>\r\n#### 按钮组件\r\n\r\n按钮组件用于渲染居中的按钮链接。该组件接收两个参数，一个是 `url` 一个是可选的 `color`。  支持的颜色包括 `primary` ，`success` 和 `error`。你可以在邮件中添加任意数量的按钮组件：\r\n\r\n```blade\r\n@component('mail::button', ['url' => $url, 'color' => 'success'])\r\nView Order\r\n@endcomponent\r\n```\r\n\r\n\r\n\r\n<a name=\"panel-component\"></a>\r\n#### 面板组件\r\n\r\n面板组件在面板内渲染指定的文本块，面板与其他消息的背景色略有不同。它允许你绘制一个警示文本块：\r\n\r\n```blade\r\n@component('mail::panel')\r\nThis is the panel content.\r\n@endcomponent\r\n```\r\n\r\n<a name=\"table-component\"></a>\r\n#### 表格组件\r\n\r\n表格组件允许你将 Markdown 表格转换成 HTML 表格。该组件接受 Markdown 表格作为其内容。列对齐支持默认的 Markdown 表格对齐语法：\r\n\r\n```blade\r\n@component('mail::table')\r\n| Laravel       | Table         | Example  |\r\n| ------------- |:-------------:| --------:|\r\n| Col 2 is      | Centered      | $10      |\r\n| Col 3 is      | Right-Aligned | $20      |\r\n@endcomponent\r\n```\r\n\r\n<a name=\"customizing-the-components\"></a>\r\n### 自定义组件\r\n\r\n可以将所有 Markdown 邮件组件导出到自己的应用，用作自定义组件的模板。若要导出组件，使用 `laravel-mail` 资产标签的 `vendor:publish` Artisan 命令：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-mail\r\n```\r\n\r\n此命令会将 Markdown 邮件组件导出到 `resources/views/vendor/mail` 目录。 该 `mail` 目录包含 `html` 和 `text` 子目录， 分别包含各自对应的可用组件描述。可以按照自己的意愿自定义这些组件。\r\n\r\n<a name=\"customizing-the-css\"></a>\r\n#### 自定义 CSS\r\n\r\n组件导出后，`resources/views/vendor/mail/html/themes` 目录有一个 `default.css` 文件。可以在此文件中自定义 CSS，这些样式将自动内联到 Markdown 邮件消息的 HTML 表示中。\r\n\r\n\r\n\r\n如果想为 Laravel 的 Markdown 组件构建一个全新的主题，你可以在 `html/themes` 目录中新建一个 CSS 文件。 命名并保存 CSS 文件后，并更新应用程序 `config/mail.php` 配置文件的 `theme` 选项以匹配新主题的名称。\r\n\r\n要为单个邮件自定义主题，可以将 mailable 类的 `$theme` 属性设置为发送 mailable 时应使用的主题名称。\r\n\r\n<a name=\"sending-mail\"></a>\r\n## 发送邮件\r\n\r\n若要发送邮件，使用 `Mail` [门面](/docs/laravel/9.x/facades) 的方法。该 `to` 方法接受 邮件地址、用户实例或用户集合。如果传递一个对象或者对象集合，mailer 在设置收件人时将自动使用它们的 `email` 和 `name` 属性，因此请确保对象的这些属性可用。一旦指定了收件人，就可以将 mailable 类实例传递给 `send` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Mail\\OrderShipped;\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n\r\n    class OrderShipmentController extends Controller\r\n    {\r\n        /**\r\n         * 发送给定的订单.\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $order = Order::findOrFail($request->order_id);\r\n\r\n            // Ship the order...\r\n\r\n            Mail::to($request->user())->send(new OrderShipped($order));\r\n        }\r\n    }\r\n\r\n在发送消息时不止可以指定收件人。还可以通过链式调用「to」、「cc」、「bcc」一次性指定抄送和密送收件人：\r\n\r\n    Mail::to($request->user())\r\n        ->cc($moreUsers)\r\n        ->bcc($evenMoreUsers)\r\n        ->send(new OrderShipped($order));\r\n\r\n\r\n\r\n<a name=\"looping-over-recipients\"></a>\r\n#### 遍历收件人列表\r\n\r\n有时，你需要通过遍历一个收件人 / 邮件地址数组的方式，给一系列收件人发送邮件。但是，由于 `to` 方法会给 mailable 列表中的收件人追加邮件地址，因此，你应该为每个收件人重建 mailable 实例。\r\n\r\n    foreach (['taylor@example.com', 'dries@example.com'] as $recipient) {\r\n        Mail::to($recipient)->send(new OrderShipped($order));\r\n    }\r\n\r\n<a name=\"sending-mail-via-a-specific-mailer\"></a>\r\n#### 通过特定的 Mailer 发送邮件\r\n\r\n默认情况下，Laravel 将使用 `mail` 你的配置文件中配置为 `default` 邮件程序。 但是，你可以使用 `mailer` 方法通过特定的邮件程序配置发送：\r\n\r\n    Mail::mailer('postmark')\r\n            ->to($request->user())\r\n            ->send(new OrderShipped($order));\r\n\r\n<a name=\"queueing-mail\"></a>\r\n### 邮件队列\r\n\r\n<a name=\"queueing-a-mail-message\"></a>\r\n#### 将邮件消息加入队列\r\n\r\n由于发送邮件消息可能大幅度延长应用的响应时间，许多开发者选择将邮件消息加入队列放在后台发送。Laravel 使用内置的 [统一队列 API](/docs/laravel/9.x/queues)简化了这一工作。若要将邮件消息加入队列，可以在指定消息的接收者后，使用 `Mail` 门面的 `queue` 方法：\r\n\r\n    Mail::to($request->user())\r\n        ->cc($moreUsers)\r\n        ->bcc($evenMoreUsers)\r\n        ->queue(new OrderShipped($order));\r\n\r\n此方法自动将作业推送到队列中以便消息在后台发送。使用此特性之前，需要 [配置队列](/docs/laravel/9.x/queues) 。\r\n\r\n\r\n\r\n<a name=\"delayed-message-queueing\"></a>\r\n#### 延迟消息队列\r\n\r\n想要延迟发送队列化的邮件消息，可以使用 `later` 方法。该 `later` 方法的第一个参数的第一个参数是标示消息何时发送的 `DateTime` 实例：\r\n\r\n    Mail::to($request->user())\r\n        ->cc($moreUsers)\r\n        ->bcc($evenMoreUsers)\r\n        ->later(now()->addMinutes(10), new OrderShipped($order));\r\n\r\n<a name=\"pushing-to-specific-queues\"></a>\r\n#### 推送到指定队列\r\n\r\n由于所有使用 `make:mail` 命令生成的 mailable 类都是用了 `Illuminate\\Bus\\Queueable` trait，因此你可以在任何 mailable 类实例上调用 `onQueue` 和 `onConnection` 方法来指定消息的连接和队列名：\r\n\r\n    $message = (new OrderShipped($order))\r\n                    ->onConnection('sqs')\r\n                    ->onQueue('emails');\r\n\r\n    Mail::to($request->user())\r\n        ->cc($moreUsers)\r\n        ->bcc($evenMoreUsers)\r\n        ->queue($message);\r\n\r\n<a name=\"queueing-by-default\"></a>\r\n#### 默认队列\r\n\r\n如果你希望你的邮件类始终使用队列，你可以给邮件类实现 `ShouldQueue` 契约，现在即使你调用了 `send` 方法，邮件依旧使用队列的方式发送\r\n\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\n    class OrderShipped extends Mailable implements ShouldQueue\r\n    {\r\n        //\r\n    }\r\n\r\n<a name=\"queued-mailables-and-database-transactions\"></a>\r\n#### 队列的邮件和数据库事务\r\n\r\n当在数据库事务中分发邮件队列时，队列可能在数据库事务提交之前处理邮件。 发生这种情况时，您在数据库事务期间对模型或数据库记录所做的任何更新可能都不会反映在数据库中。 另外，在事务中创建的任何模型或数据库记录都可能不存在于数据库中。 如果您的邮件基于这些模型数据，则在处理邮件发生时，可能会发生意外错误。\r\n\r\n\r\n\r\n如果队列连接的 `after_commit` 配置选项设置为 `false`，则仍然可以通过在 mailable 类上定义 `afterCommit` 属性来设置提交所有打开的数据库事务之后再调度特定的邮件队列：\r\n\r\n    Mail::to($request->user())->send(\r\n        (new OrderShipped($order))->afterCommit()\r\n    );\r\n\r\n或者，您可以 `afterCommit` 从 mailable 的构造函数中调用该方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Mail;\r\n\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Mail\\Mailable;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipped extends Mailable implements ShouldQueue\r\n    {\r\n        use Queueable, SerializesModels;\r\n\r\n        /**\r\n         * Create a new message instance.\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->afterCommit();\r\n        }\r\n    }\r\n\r\n> 技巧：要了解有关解决这些问题的更多信息，请查看有关 [队列和数据库事物](/docs/laravel/9.x/queues#jobs-and-database-transactions)。\r\n\r\n<a name=\"rendering-mailables\"></a>\r\n## 渲染邮件\r\n\r\n有时您可能希望捕获邮件的 HTML 内容而不发送它。为此，可以调用邮件类的 `render` 方法。此方法将以字符串形式返回邮件类的渲染内容:\r\n\r\n    use App\\Mail\\InvoicePaid;\r\n    use App\\Models\\Invoice;\r\n\r\n    $invoice = Invoice::find(1);\r\n\r\n    return (new InvoicePaid($invoice))->render();\r\n\r\n<a name=\"previewing-mailables-in-the-browser\"></a>\r\n### 在浏览器中预览邮件\r\n\r\n设计邮件模板时，可以方便地在浏览器中预览邮件，就像典型的 `Blade` 模板一样。因此， Laravel 允许您直接从路由闭包或控制器返回任何邮件类。当邮件返回时，它将渲染并显示在浏览器中，允许您快速预览其设计，而无需将其发送到实际的电子邮件地址：\r\n\r\n    Route::get('/mailable', function () {\r\n        $invoice = App\\Models\\Invoice::find(1);\r\n\r\n        return new App\\Mail\\InvoicePaid($invoice);\r\n    });\r\n\r\n> 注意：在浏览器中预览邮件时，不会呈现[内联附件](#inline-attachments) 要预览这些邮件，您应该将它们发送到电子邮件测试应用程序，例如 [MailHog](https://github.com/mailhog/MailHog) 或 [HELO](https://usehelo.com)。\r\n\r\n\r\n\r\n<a name=\"localizing-mailables\"></a>\r\n## 本地化邮件\r\n\r\nLaravel 允许您在请求的当前语言环境之外的语言环境中发送邮件，如果邮件在排队，它甚至会记住这个语言环境。\r\n\r\n为此，“Mail”门面提供了一个“locale”方法来设置所需的语言。 评估可邮寄的模板时，应用程序将更改为此语言环境，然后在评估完成后恢复为先前的语言环境：\r\n\r\n    Mail::to($request->user())->locale('es')->send(\r\n        new OrderShipped($order)\r\n    );\r\n\r\n<a name=\"user-preferred-locales\"></a>\r\n### 用户首选语言环境\r\n\r\n有时，应用程序存储每个用户的首选语言环境。 通过在一个或多个模型上实现 `HasLocalePreference` 契约，你可以指示 Laravel 在发送邮件时使用这个存储的语言环境：\r\n\r\n    use Illuminate\\Contracts\\Translation\\HasLocalePreference;\r\n\r\n    class User extends Model implements HasLocalePreference\r\n    {\r\n        /**\r\n         * 获取用户的首选语言环境。\r\n         *\r\n         * @return string\r\n         */\r\n        public function preferredLocale()\r\n        {\r\n            return $this->locale;\r\n        }\r\n    }\r\n\r\n一旦你实现了接口，Laravel 将在向模型发送邮件和通知时自动使用首选语言环境。 因此，使用该接口时无需调用 `locale` 方法：\r\n\r\n    Mail::to($request->user())->send(new OrderShipped($order));\r\n\r\n<a name=\"testing-mailables\"></a>\r\n## 测试邮件\r\n\r\nLaravel 提供了几种方便的方法来测试你的邮件是否包含你期望的内容。 这些方法是：`assertSeeInHtml`、`assertDontSeeInHtml`、`assertSeeInOrderInHtml`、`assertSeeInText`、`assertDontSeeInText`和`assertSeeInOrderInText`。\r\n\r\n如您所料，「HTML」断言您的可邮寄邮件的 HTML 版本包含给定字符串，而「Text」断言您的可邮寄邮件的纯文本版本包含给定字符串：\r\n\r\n    use App\\Mail\\InvoicePaid;\r\n    use App\\Models\\User;\r\n\r\n    public function test_mailable_content()\r\n    {\r\n        $user = User::factory()->create();\r\n\r\n        $mailable = new InvoicePaid($user);\r\n\r\n        $mailable->assertSeeInHtml($user->email);\r\n        $mailable->assertSeeInHtml('Invoice Paid');\r\n        $mailable->assertSeeInOrderInHtml(['Invoice Paid', 'Thanks']);\r\n\r\n        $mailable->assertSeeInText($user->email);\r\n        $mailable->assertSeeInOrderInText(['Invoice Paid', 'Thanks']);\r\n    }\r\n\r\n\r\n\r\n<a name=\"testing-mailable-sending\"></a>\r\n#### 测试可邮寄的发送\r\n\r\n我们建议将您的邮件内容与断言给定邮件已“发送”给特定用户的测试分开测试。 要了解如何测试邮件是否已发送，请查看我们在 [Mail fake](/docs/laravel/9.x/mocking#mail-fake) 上的文档。\r\n\r\n<a name=\"mail-and-local-development\"></a>\r\n## 邮件和本地发展\r\n\r\n在开发发送电子邮件的应用程序时，您可能不希望实际将电子邮件发送到实时电子邮件地址。 Laravel 提供了几种在本地开发期间「禁用」实际发送电子邮件的方法。\r\n\r\n<a name=\"log-driver\"></a>\r\n#### 日志驱动程序\r\n\r\n`log` 邮件驱动程序不会发送您的电子邮件，而是将所有电子邮件信息写入您的日志文件以供检查。 通常，此驱动程序仅在本地开发期间使用。有关按环境配置应用程序的更多信息，请查看 [配置文档](/docs/laravel/9.x/configuration#environment-configuration)。\r\n\r\n<a name=\"mailtrap\"></a>\r\n#### HELO / Mailtrap / MailHog\r\n\r\n或者，您可以使用 [HELO](https://usehelo.com) 或 [Mailtrap](https://mailtrap.io) 之类的服务和 `smtp` 驱动程序将您的电子邮件信息发送到「虚拟」邮箱 您可以在真正的电子邮件客户端中查看它们。这种方法的好处是允许您在 Mailtrap 的消息查看器中实际检查最终电子邮件。\r\n\r\n如果你使用 [Laravel Sail](/docs/laravel/9.x/sail)，你可以使用 [MailHog](https://github.com/mailhog/MailHog) 预览你的消息。当 Sail 运行时，您可以访问 MailHog 界面：`http://localhost:8025`。\r\n\r\n<a name=\"using-a-global-to-address\"></a>\r\n#### 使用全局 `to` 地址\r\n\r\n\r\n\r\n最后，您可以通过调用 `Mail` 门面提供的 `alwaysTo` 方法来指定一个全局「收件人」地址。 通常，应该从应用程序的服务提供者之一的 `boot` 方法调用此方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n\r\n    /**\r\n     * Bootstrap 应用程序服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        if ($this->app->environment('local')) {\r\n            Mail::alwaysTo('taylor@example.com');\r\n        }\r\n    }\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\nLaravel 在发送邮件消息的过程中会触发两个事件。 `MessageSending` 事件在消息发送之前触发，而 `MessageSent` 事件在消息发送后触发。请记住，这些事件是在邮件*发送*时触发的，而不是在排队时触发的。你可以在你的 App\\Providers\\EventServiceProvider 服务提供者中为这个事件注册事件监听器：\r\n\r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Mail\\Events\\MessageSending' => [\r\n            'App\\Listeners\\LogSendingMessage',\r\n        ],\r\n        'Illuminate\\Mail\\Events\\MessageSent' => [\r\n            'App\\Listeners\\LogSentMessage',\r\n        ],\r\n    ];\r\n\r\n<a name=\"custom-transports\"></a>\r\n## 自定义传输\r\n\r\nLaravel 包含多种邮件传输；但是，您可能希望编写自己的传输以通过 Laravel 开箱即用不支持的其他服务发送电子邮件。首先，定义一个扩展 `Symfony\\Component\\Mailer\\Transport\\AbstractTransport` 类的类。然后，在你的传输上实现 `doSend` 和 `__toString()` 方法：\r\n\r\n    use MailchimpTransactional\\ApiClient;\r\n    use Symfony\\Component\\Mailer\\SentMessage;\r\n    use Symfony\\Component\\Mailer\\Transport\\AbstractTransport;\r\n    use Symfony\\Component\\Mime\\MessageConverter;\r\n\r\n    class MailchimpTransport extends AbstractTransport\r\n    {\r\n        /**\r\n         * Mailchimp API 客户端。\r\n         *\r\n         * @var \\MailchimpTransactional\\ApiClient\r\n         */\r\n        protected $client;\r\n\r\n        /**\r\n         * 创建一个新的 Mailchimp 传输实例。\r\n         *\r\n         * @param  \\MailchimpTransactional\\ApiClient  $client\r\n         * @return void\r\n         */\r\n        public function __construct(ApiClient $client)\r\n        {\r\n            $this->client = $client\r\n        }\r\n\r\n        /**\r\n         * {@inheritDoc}\r\n         */\r\n        protected function doSend(SentMessage $message): void\r\n        {\r\n            $email = MessageConverter::toEmail($message->getOriginalMessage());\r\n\r\n            $this->client->messages->send(['message' => [\r\n                'from_email' => $email->getFrom(),\r\n                'to' => collect($email->getTo())->map(function ($email) {\r\n                    return ['email' => $email->getAddress(), 'type' => 'to'];\r\n                })->all(),\r\n                'subject' => $email->getSubject(),\r\n                'text' => $email->getTextBody(),\r\n            ]]);\r\n        }\r\n\r\n        /**\r\n         * 获取传输的字符串表示形式。\r\n         *\r\n         * @return string\r\n         */\r\n        public function __toString(): string\r\n        {\r\n            return 'mailchimp';\r\n        }\r\n    }\r\n\r\n\r\n\r\n一旦你定义了你的自定义传输，你可以通过 `Mail` 门面提供的 `extend` 方法注册它。通常，这应该在应用程序的 `AppServiceProvider` 服务提供者的 `boot` 方法中完成。 `$config` 参数将被传递给提供给`extend` 方法的闭包。此参数将包含在应用程序的 `config/mail.php` 配置文件中为邮件程序定义的配置数组：\r\n\r\n    use App\\Mail\\MailchimpTransport;\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Mail::extend('mailchimp', function (array $config = []) {\r\n            return new MailchimpTransport(...);\r\n        })\r\n    }\r\n\r\n一旦定义并注册了自定义传输，您就可以在应用程序的 `config/mail.php` 配置文件中创建一个使用新传输的邮件定义：\r\n\r\n    'mailchimp' => [\r\n        'transport' => 'mailchimp',\r\n        // ...\r\n    ],\r\n\r\n<a name=\"additional-symfony-transports\"></a>\r\n### 额外的 Symfony 传输\r\n\r\nLaravel 支持一些现有的 Symfony 维护的邮件传输，比如 Mailgun 和 Postmark。但是，您可能希望扩展 Laravel 以支持额外的 Symfony 维护的传输。您可以通过 Composer 要求必要的 Symfony 邮件程序并使用 Laravel 注册传输来做到这一点。例如，您可以安装并注册“Sendinblue”Symfony 邮件程序：\r\n\r\n```none\r\ncomposer require symfony/sendinblue-mailer\r\n```\r\n\r\n安装 Sendinblue 邮件程序包后，您可以将 Sendinblue API 凭据的条目添加到应用程序的「服务」配置文件中：\r\n\r\n    'sendinblue' => [\r\n        'key' => 'your-api-key',\r\n    ],\r\n\r\n最后，你可以使用 `Mail` 门面的 `extend` 方法向 Laravel 注册传输。通常，这应该在服务提供者的 `boot` 方法中完成：\r\n\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n    use Symfony\\Component\\Mailer\\Bridge\\Sendinblue\\Transport\\SendinblueTransportFactory;\r\n    use Symfony\\Component\\Mailer\\Transport\\Dsn;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Mail::extend('sendinblue', function () {\r\n            return (new SendinblueTransportFactory)->create(\r\n                new Dsn(\r\n                    'sendinblue+api',\r\n                    'default',\r\n                    config('services.sendinblue.key')\r\n                )\r\n            );\r\n        });\r\n    }\r\n\r\n","p":"docs/mail.html"},{"t":"notifications (Notifications)","d":"# Notifications\r\n\r\n- [简介](#introduction)\r\n- [创建通知](#generating-notifications)\r\n- [发送通知](#sending-notifications)\r\n    - [使用 Notifiable Trait](#using-the-notifiable-trait)\r\n    - [使用 Notification Facade](#using-the-notification-facade)\r\n    - [指定发送频道](#specifying-delivery-channels)\r\n    - [通知队列化](#queueing-notifications)\r\n    - [按需通知](#on-demand-notifications)\r\n- [邮件通知](#mail-notifications)\r\n    - [格式化邮件信息](#formatting-mail-messages)\r\n    - [自定义发送者](#customizing-the-sender)\r\n    - [自定义接收者](#customizing-the-recipient)\r\n    - [自定义主题](#customizing-the-subject)\r\n    - [自定义邮件驱动](#customizing-the-mailer)\r\n    - [自定义模板](#customizing-the-templates)\r\n    - [附件](#mail-attachments)\r\n    - [使用Mailables](#using-mailables)\r\n    - [预览邮件通知](#previewing-mail-notifications)\r\n- [Markdown 邮件通知](#markdown-mail-notifications)\r\n    - [生成消息](#generating-the-message)\r\n    - [写消息](#writing-the-message)\r\n    - [自定义组件](#customizing-the-components)\r\n- [数据库通知](#database-notifications)\r\n    - [必要条件](#database-prerequisites)\r\n    - [格式化数据库通知](#formatting-database-notifications)\r\n    - [访问通知](#accessing-the-notifications)\r\n    - [标记已读通知](#marking-notifications-as-read)\r\n- [广播通知](#broadcast-notifications)\r\n    - [必要条件](#broadcast-prerequisites)\r\n    - [格式化广播通知](#formatting-broadcast-notifications)\r\n    - [监听广播通知](#listening-for-notifications)\r\n- [短信通知](#sms-notifications)\r\n    - [必要条件](#sms-prerequisites)\r\n    - [格式化短信通知](#formatting-sms-notifications)\r\n    - [格式化简码通知](#formatting-shortcode-notifications)\r\n    - [自定义「From」号码](#customizing-the-from-number)\r\n    - [添加客户端引用](#adding-a-client-reference)\r\n    - [短信通知路由](#routing-sms-notifications)\r\n- [Slack 通知](#slack-notifications)\r\n    - [必要条件](#slack-prerequisites)\r\n    - [格式化 Slack 通知](#formatting-slack-notifications)\r\n    - [Slack 附件](#slack-attachments)\r\n    - [Slack 路由](#routing-slack-notifications)\r\n- [本地化通知](#localizing-notifications)\r\n- [通知事件](#notification-events)\r\n- [自定义频道](#custom-channels)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n除了支持 [发送邮件](/docs/laravel/9.x/mail) 之外，Laravel 还支持通过多种频道发送通知，包括邮件、短信（通过  [Vonage](https://www.vonage.com/communications-apis/)，原来叫 Nexmo），以及  [Slack](https://slack.com)。此外，已经创建了各种各样的 [社区通知频道](https://laravel-notification-channels.com/about/#suggesting-a-new-channel)，来在十几个不同的频道中发送通知！通知还能存储到数据库以便后续在 Web 页面中显示。\r\n\r\n通常，通知应该是简短的信息性消息，用于通知用户应用中发生的事情。例如，如果你正在编写一个账单应用，则可以通过邮件和短信频道向用户发送一个「支付凭证」通知。\r\n\r\n<a name=\"generating-notifications\"></a>\r\n## 创建通知\r\n\r\nLaravel 中，通常每个通知都由一个存储在 `app/Notifications` 目录下的一个类表示。如果在你的应用中没有看到这个目录，不要担心，当运行 `make:notification` 命令时它将为您创建：\r\n\r\n```shell\r\nphp artisan make:notification InvoicePaid\r\n```\r\n\r\n这个命令会在 `app/Notifications` 目录下生成一个新的通知类。每个通知类都包含一个 `via` 方法以及一个或多个消息构建的方法比如 `toMail` 或 `toDatabase`，它们会针对特定的渠道把通知转换为对应的消息。\r\n\r\n<a name=\"sending-notifications\"></a>\r\n## 发送通知\r\n\r\n<a name=\"using-the-notifiable-trait\"></a>\r\n### 使用 Notifiable Trait\r\n\r\n通知可以通过两种方式发送： 使用 `Notifiable` 特性的 `notify` 方法或使用 `Notification` [门面](/docs/laravel/9.x/facades)。 该 `Notifiable` 默认包含在应用程序的 `App\\Models\\User` 模型中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n    }\r\n\r\n此 `notify` 方法需要接收一个通知实例参数：\r\n\r\n    use App\\Notifications\\InvoicePaid;\r\n\r\n    $user->notify(new InvoicePaid($invoice));\r\n\r\n> 技巧：请记住，你可以在任何模型中使用 `Notifiable` trait。而不仅仅是在 `User` 模型中。\r\n\r\n\r\n\r\n<a name=\"using-the-notification-facade\"></a>\r\n### 使用 Notification Facade\r\n\r\n另外，你可以通过 `Notification` [facade](/docs/laravel/9.x/facades) 来发送通知，它主要用在当你需要给多个可接收通知的实体发送的时候，比如给用户集合发送通知。使用 Facade 发送通知的话，要把可接收通知实例和通知实例传递给 `send` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Notification;\r\n\r\n    Notification::send($users, new InvoicePaid($invoice));\r\n\r\n您也可以使用`sendNow`方法立即发送通知。即使通知实现了`ShouldQueue`接口，该方法也会立即发送通知：\r\n\r\n    Notification::sendNow($developers, new DeploymentCompleted($deployment));\r\n\r\n<a name=\"specifying-delivery-channels\"></a>\r\n### 发送指定频道\r\n\r\n每个通知类都有一个`via`方法，用于确定将在哪些通道上传递通知。通知可以在`mail`、`database`、`broadcast`、`vonage`和`slack`频道上发送。\r\n\r\n> 提示：如果你想使用其他的频道，比如 Telegram 或者 Pusher，你可以去看下社区驱动的 [Laravel 通知频道网站](http://laravel-notification-channels.com)。\r\n\r\n`via` 方法接收一个 `$notifiable` 实例，这个实例将是通知实际发送到的类的实例。你可以用 `$notifiable` 来决定这个通知用哪些频道来发送：\r\n\r\n    /**\r\n     * 获取通知发送频道\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return array\r\n     */\r\n    public function via($notifiable)\r\n    {\r\n        return $notifiable->prefers_sms ? ['vonage'] : ['mail', 'database'];\r\n    }\r\n\r\n<a name=\"queueing-notifications\"></a>\r\n### 通知队列化\r\n> 注意：使用通知队列前需要配置队列并 [开启一个队列任务](/docs/laravel/9.x/queues)。\r\n\r\n发送通知可能是耗时的，尤其是通道需要调用额外的 API 来传输通知。为了加速应用的响应时间，可以将通知推送到队列中异步发送，而要实现推送通知到队列，可以让对应通知类实现 `ShouldQueue` 接口并使用 `Queueable` trait。如果通知类是通过 `make:notification`  命令生成的，那么该接口和 trait 已经默认导入，你可以快速将它们添加到通知类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Notifications;\r\n\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class InvoicePaid extends Notification implements ShouldQueue\r\n    {\r\n        use Queueable;\r\n\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n一旦 `ShouldQueue` 接口被添加到您的通知中，您就可以像往常一样发送通知。 Laravel 将检测类上的 `ShouldQueue` 接口并自动将通知的传递排队：\r\n\r\n    $user->notify(new InvoicePaid($invoice));\r\n\r\n如果您想延迟通知的传递，您可以将 `delay` 方法链接到通知实例：\r\n\r\n    $delay = now()->addMinutes(10);\r\n\r\n    $user->notify((new InvoicePaid($invoice))->delay($delay));\r\n\r\n您可以将数组传递给 `delay` 方法来指定特定通道的延迟量：\r\n\r\n    $user->notify((new InvoicePaid($invoice))->delay([\r\n        'mail' => now()->addMinutes(5),\r\n        'sms' => now()->addMinutes(10),\r\n    ]));\r\n\r\n排队通知时，将为每个收件人和频道组合创建一个排队作业。例如，如果您的通知有三个收件人和两个通道，则六个作业将被分派到队列中。\r\n\r\n<a name=\"customizing-the-notification-queue-connection\"></a>\r\n#### 自定义通知队列连接\r\n\r\n默认情况下，排队通知将使用应用程序的默认队列连接进行排队。如果您想为特定通知指定一个不同的连接，您可以在通知类上定义一个 `$connection` 属性：\r\n\r\n    /**\r\n     * 排队通知时要使用的队列连接的名称。\r\n     *\r\n     * @var string\r\n     */\r\n    public $connection = 'redis';\r\n\r\n<a name=\"customizing-notification-channel-queues\"></a>\r\n#### 自定义通知通道队列\r\n\r\n如果你想为通知支持的每个通知通道指定一个特定的队列，你可以在你的通知上定义一个`viaQueues`方法。 此方法应返回通道名称/队列名称对的数组：\r\n\r\n    /**\r\n     * 确定每个通知通道应使用哪些队列。\r\n     *\r\n     * @return array\r\n     */\r\n    public function viaQueues()\r\n    {\r\n        return [\r\n            'mail' => 'mail-queue',\r\n            'slack' => 'slack-queue',\r\n        ];\r\n    }\r\n\r\n\r\n\r\n<a name=\"queued-notifications-and-database-transactions\"></a>\r\n#### 排队通知 & 数据库事务\r\n\r\n当在数据库事务中调度排队通知时，它们可能在数据库事务提交之前由队列处理。 发生这种情况时，您在数据库事务期间对模型或数据库记录所做的任何更新可能尚未反映在数据库中。 此外，在事务中创建的任何模型或数据库记录可能不存在于数据库中。 如果您的通知依赖于这些模型，则在处理发送排队通知的作业时可能会发生意外错误。\r\n\r\n如果您的队列连接的 `after_commit` 配置选项设置为 `false`，您仍然可以通过在发送通知时调用 `afterCommit` 方法来指示应在提交所有打开的数据库事务后发送特定的排队通知：\r\n\r\n    use App\\Notifications\\InvoicePaid;\r\n\r\n    $user->notify((new InvoicePaid($invoice))->afterCommit());\r\n\r\n或者，您可以从通知的构造函数中调用 `afterCommit` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Notifications;\r\n\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class InvoicePaid extends Notification implements ShouldQueue\r\n    {\r\n        use Queueable;\r\n\r\n        /**\r\n         * 创建一个新的通知实例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->afterCommit();\r\n        }\r\n    }\r\n\r\n> 技巧：要了解有关解决这些问题的更多信息，请查看有关 [队列任务和数据库事务](/docs/laravel/9.x/queues#jobs-and-database-transactions) 的文档 。\r\n\r\n<a name=\"determining-if-the-queued-notification-should-be-sent\"></a>\r\n#### 确定是否应发送排队通知\r\n\r\n在为队列分派队列通知以进行后台处理后，它通常会被队列工作人员接受并发送给其预期的接收者。\r\n\r\n\r\n\r\n但是，如果您想在队列工作程序处理队列通知后最终确定是否应该发送它，您可以在通知类上定义一个 `shouldSend` 方法。 如果此方法返回 `false`，则不会发送通知：\r\n\r\n    /**\r\n     * 确定是否应发送通知。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @param  string  $channel\r\n     * @return bool\r\n     */\r\n    public function shouldSend($notifiable, $channel)\r\n    {\r\n        return $this->invoice->isPaid();\r\n    }\r\n\r\n<a name=\"on-demand-notifications\"></a>\r\n### 按需通知\r\n\r\n有时您可能需要向未存储为应用程序“用户”的人发送通知。使用 `Notification` 门面的 `route` 方法，您可以在发送通知之前指定 ad-hoc 通知路由信息：\r\n\r\n    Notification::route('mail', 'taylor@example.com')\r\n                ->route('vonage', '5555555555')\r\n                ->route('slack', 'https://hooks.slack.com/services/...')\r\n                ->notify(new InvoicePaid($invoice));\r\n\r\n如果您想在向“邮件”路由发送按需通知时提供收件人的姓名，您可以提供一个数组，其中包含电子邮件地址作为键，名称作为数组中第一个元素的值：\r\n\r\n    Notification::route('mail', [\r\n        'barrett@example.com' => 'Barrett Blair',\r\n    ])->notify(new InvoicePaid($invoice));\r\n\r\n<a name=\"mail-notifications\"></a>\r\n## 邮件通知\r\n\r\n<a name=\"formatting-mail-messages\"></a>\r\n### 格式化邮件信息\r\n\r\n如果通知支持作为电子邮件发送，您应该在通知类上定义一个 `toMail` 方法。 此方法将接收一个 `$notifiable` 实体并应返回一个 `Illuminate\\Notifications\\Messages\\MailMessage` 实例。\r\n\r\n`MailMessage` 类包含一些简单的方法来帮助您构建事务性电子邮件消息。 邮件消息可能包含文本行以及「动作的调用」。让我们看一个示例 `toMail` 方法：\r\n\r\n    /**\r\n     * 获取通知的邮件描述。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        $url = url('/invoice/'.$this->invoice->id);\r\n\r\n        return (new MailMessage)\r\n                    ->greeting('Hello!')\r\n                    ->line('你的一张发票已经付款了！')\r\n                    ->action('查看发票', $url)\r\n                    ->line('感谢您使用我们的应用程序！');\r\n    }\r\n\r\n> 技巧：请注意，我们在您的 `toMail` 方法中使用了 `$this->invoice->id`。您可以将通知生成其消息所需的任何数据传递给通知构造函数。\r\n\r\n\r\n\r\n在此示例中，我们注册了一个问候语、一行文本、一个号召性用语，然后是另一行文本。 `MailMessage` 对象提供的这些方法使格式化小型交易电子邮件变得简单快捷。 然后，邮件通道会将消息组件翻译成漂亮的响应式 HTML 电子邮件模板，并带有纯文本副本。 以下是 `mail` 频道生成的电子邮件示例：\r\n\r\n<img src=\"https://laravel.com/img/docs/notification-example-2.png\">\r\n\r\n> 技巧：发送邮件通知时，请务必在 `config/app.php` 配置文件中设置 `name` 配置选项。 此值将用于邮件通知消息的页眉和页脚。\r\n\r\n<a name=\"other-mail-notification-formatting-options\"></a>\r\n#### 其他邮件通知格式选项\r\n\r\n除了在通知类中定义多行文本之外，您可以使用 `view` 方法来指定应该用于呈现通知电子邮件的自定义模板：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)->view(\r\n            'emails.name', ['invoice' => $this->invoice]\r\n        );\r\n    }\r\n\r\n您可以通过将视图名称作为数组的第二个元素传递给 `view` 方法来指定邮件消息的纯文本视图：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)->view(\r\n            ['emails.name.html', 'emails.name.plain'],\r\n            ['invoice' => $this->invoice]\r\n        );\r\n    }\r\n\r\n<a name=\"error-messages\"></a>\r\n#### 错误信息\r\n\r\n\r\n\r\n一些通知会通知用户错误，例如发票支付失败。您可以通过在构建消息时调用 `error` 方法来指示邮件消息与错误有关。在邮件消息上使用 `error` 方法时，号召性用语按钮将是红色而不是黑色：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Message\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)\r\n                    ->error()\r\n                    ->subject('Notification Subject')\r\n                    ->line('...');\r\n    }\r\n\r\n<a name=\"customizing-the-sender\"></a>\r\n### 自定义发件人\r\n\r\n默认情况下，电子邮件的发件人/发件人地址在 `config/mail.php` 配置文件中定义。但是，您可以使用 `from` 方法指定特定通知的发件人地址：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)\r\n                    ->from('barrett@example.com', 'Barrett Blair')\r\n                    ->line('...');\r\n    }\r\n\r\n<a name=\"customizing-the-recipient\"></a>\r\n### 自定义收件人\r\n\r\n通过 `mail` 渠道发送通知时，通知系统将自动在您的应通知实体上查找 `email` 属性。您可以通过在通知实体上定义 `routeNotificationForMail` 方法来自定义用于发送通知的电子邮件地址：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * 邮件通道的路由通知。\r\n         *\r\n         * @param  \\Illuminate\\Notifications\\Notification  $notification\r\n         * @return array|string\r\n         */\r\n        public function routeNotificationForMail($notification)\r\n        {\r\n            // 仅返回电子邮件地址...\r\n            return $this->email_address;\r\n\r\n            // 返回电子邮件地址和姓名...\r\n            return [$this->email_address => $this->name];\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"customizing-the-subject\"></a>\r\n### 自定义主题\r\n\r\n默认情况下，电子邮件的主题是格式为「标题风格」的通知的类名。因此，如果您的通知类名为`InvoicePaid`，则电子邮件的主题将是`Invoice Paid`。 如果您想为消息指定不同的主题，您可以在构建消息时调用 `subject` 方法：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)\r\n                    ->subject('Notification Subject')\r\n                    ->line('...');\r\n    }\r\n\r\n<a name=\"customizing-the-mailer\"></a>\r\n### 自定义邮件程序\r\n\r\n默认情况下，将使用 `config/mail.php` 配置文件中定义的默认邮件程序发送电子邮件通知。但是，您可以通过在构建消息时调用 `mailer` 方法在运行时指定不同的邮件程序：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)\r\n                    ->mailer('postmark')\r\n                    ->line('...');\r\n    }\r\n\r\n<a name=\"customizing-the-templates\"></a>\r\n### 自定义模板\r\n\r\n您可以通过发布通知包的资源来修改邮件通知使用的 HTML 和纯文本模板。运行此命令后，邮件通知模板将位于 `resources/views/vendor/notifications` 目录中：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-notifications\r\n```\r\n\r\n<a name=\"mail-attachments\"></a>\r\n### 附件\r\n\r\n要将附件添加到电子邮件通知中，请在构建消息时使用 `attach` 方法。 `attach` 方法接受文件的绝对路径作为其第一个参数：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)\r\n                    ->greeting('Hello!')\r\n                    ->attach('/path/to/file');\r\n    }\r\n\r\n\r\n\r\n将文件附加到消息时，您还可以通过将 `array` 作为第二个参数传递给 `attach` 方法来指定显示名称和 MIME 类型：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)\r\n                    ->greeting('Hello!')\r\n                    ->attach('/path/to/file', [\r\n                        'as' => 'name.pdf',\r\n                        'mime' => 'application/pdf',\r\n                    ]);\r\n    }\r\n\r\n与在可邮寄对象中附加文件不同，您不能使用 `attachFromStorage` 直接从存储磁盘附加文件。 您应该使用带有存储磁盘上文件的绝对路径的 `attach` 方法。 或者，您可以从 `toMail` 方法返回 [mailable](/docs/laravel/9.x/mail#generating-mailables)：\r\n    use App\\Mail\\InvoicePaid as InvoicePaidMailable;\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return Mailable\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new InvoicePaidMailable($this->invoice))\r\n                    ->to($notifiable->email)\r\n                    ->attachFromStorage('/path/to/file');\r\n    }\r\n\r\n<a name=\"raw-data-attachments\"></a>\r\n#### 原始数据附件\r\n\r\n`attachData` 方法可用于附加原始字节字符串作为附件。调用 `attachData` 方法时，应提供应分配给附件的文件名：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)\r\n                    ->greeting('Hello!')\r\n                    ->attachData($this->pdf, 'name.pdf', [\r\n                        'mime' => 'application/pdf',\r\n                    ]);\r\n    }\r\n\r\n<a name=\"using-mailables\"></a>\r\n### 使用 Mailables\r\n\r\n如果需要，您可以从通知的 `toMail` 方法返回一个完整的 [可邮寄对象](/docs/laravel/9.x/mail)。当返回 `Mailable` 而不是 `MailMessage` 时，您需要使用 mailable 对象的 `to` 方法指定消息收件人：\r\n\r\n    use App\\Mail\\InvoicePaid as InvoicePaidMailable;\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return Mailable\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new InvoicePaidMailable($this->invoice))\r\n                    ->to($notifiable->email);\r\n    }\r\n\r\n\r\n\r\n<a name=\"mailables-and-on-demand-notifications\"></a>\r\n#### 可邮寄和按需通知\r\n\r\n如果您正在发送 [on-demand-notifications](#on-demand-notifications)，则为 `toMail` 方法提供的 `$notifiable` 实例将是 `Illuminate\\Notifications\\AnonymousNotifiable` 的一个实例，它提供了一个 ` routeNotificationFor` 方法，可用于检索应将按需通知发送到的电子邮件地址：\r\n\r\n    use App\\Mail\\InvoicePaid as InvoicePaidMailable;\r\n    use Illuminate\\Notifications\\AnonymousNotifiable;\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return Mailable\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        $address = $notifiable instanceof AnonymousNotifiable\r\n                ? $notifiable->routeNotificationFor('mail')\r\n                : $notifiable->email;\r\n\r\n        return (new InvoicePaidMailable($this->invoice))\r\n                    ->to($address);\r\n    }\r\n\r\n<a name=\"previewing-mail-notifications\"></a>\r\n### 预览邮件通知\r\n\r\n在设计邮件通知模板时，可以方便地在浏览器中快速预览呈现的邮件消息，就像典型的 Blade 模板一样。 因此，Laravel 允许您直接从路由闭包或控制器返回由邮件通知生成的任何邮件消息。 当返回一个 `MailMessage` 时，它将被渲染并显示在浏览器中，让您可以快速预览其设计，而无需将其发送到实际的电子邮件地址：\r\n\r\n    use App\\Models\\Invoice;\r\n    use App\\Notifications\\InvoicePaid;\r\n\r\n    Route::get('/notification', function () {\r\n        $invoice = Invoice::find(1);\r\n\r\n        return (new InvoicePaid($invoice))\r\n                    ->toMail($invoice->user);\r\n    });\r\n\r\n<a name=\"markdown-mail-notifications\"></a>\r\n## Markdown 邮件通知\r\n\r\nMarkdown 邮件通知允许您利用预先构建的邮件通知模板，同时让您更自由地编写更长的自定义消息。 由于消息是用 Markdown 编写的，Laravel 能够为消息呈现漂亮的响应式 HTML 模板，同时还可以自动生成纯文本副本。\r\n\r\n\r\n\r\n<a name=\"generating-the-message\"></a>\r\n### 生成消息\r\n\r\n要使用相应的 Markdown 模板生成通知，您可以使用 `make:notification` Artisan 命令的 `--markdown` 选项：\r\n\r\n```shell\r\nphp artisan make:notification InvoicePaid --markdown=mail.invoice.paid\r\n```\r\n\r\n与所有其他邮件通知一样，使用 Markdown 模板的通知应在其通知类上定义一个 `toMail` 方法。 但是，不要使用 `line` 和 `action` 方法来构造通知，而是使用 `markdown` 方法来指定应使用的 Markdown 模板的名称。 您希望提供给模板的数据数组可以作为方法的第二个参数传递：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        $url = url('/invoice/'.$this->invoice->id);\r\n\r\n        return (new MailMessage)\r\n                    ->subject('Invoice Paid')\r\n                    ->markdown('mail.invoice.paid', ['url' => $url]);\r\n    }\r\n\r\n<a name=\"writing-the-message\"></a>\r\n### 写信息\r\n\r\nMarkdown 邮件通知使用 Blade 组件和 Markdown 语法的组合，允许您在利用 Laravel 预先制作的通知组件的同时轻松构建通知：\r\n\r\n```blade\r\n@component('mail::message')\r\n# 已付发票\r\n\r\n您的发票已支付！\r\n\r\n@component('mail::button', ['url' => $url])\r\n查看发票\r\n@endcomponent\r\n\r\n谢谢，<br>\r\n{{ config('app.name') }}\r\n@endcomponent\r\n```\r\n\r\n<a name=\"button-component\"></a>\r\n#### 按钮组件\r\n\r\n按钮组件呈现居中的按钮链接。 该组件接受两个参数，一个 `url` 和一个可选的 `color`。 支持的颜色是`primary`、`green`和`red`。 您可以根据需要向通知中添加任意数量的按钮组件：\r\n\r\n```blade\r\n@component('mail::button', ['url' => $url, 'color' => 'green'])\r\n查看发票\r\n@endcomponent\r\n```\r\n\r\n\r\n\r\n<a name=\"panel-component\"></a>\r\n#### 面板组件\r\n\r\n面板组件在面板中呈现给定的文本块，该面板的背景颜色与通知的其余部分略有不同。这使您可以引起对给定文本块的注意：\r\n\r\n```blade\r\n@component('mail::panel')\r\n这是面板内容。\r\n@endcomponent\r\n```\r\n\r\n<a name=\"table-component\"></a>\r\n#### 表组件\r\n\r\n表格组件允许您将 Markdown 表格转换为 HTML 表格。 该组件接受 Markdown 表作为其内容。 使用默认的 Markdown 表格对齐语法支持表格列对齐：\r\n\r\n```blade\r\n@component('mail::table')\r\n| Laravel       | Table         | Example  |\r\n| ------------- |:-------------:| --------:|\r\n| Col 2 is      | Centered      | $10      |\r\n| Col 3 is      | Right-Aligned | $20      |\r\n@endcomponent\r\n```\r\n\r\n<a name=\"customizing-the-components\"></a>\r\n### 自定义组件\r\n\r\n您可以将所有 Markdown 通知组件导出到您自己的应用程序以进行自定义。要导出组件，请使用 `vendor:publish` Artisan 命令发布 `laravel-mail` 资产标签：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-mail\r\n```\r\n\r\n此命令会将 Markdown 邮件组件发布到 `resources/views/vendor/mail` 目录。 `mail` 目录将包含一个 `html` 和一个 `text` 目录，每个目录都包含它们各自对每个可用组件的表示。 您可以随意自定义这些组件。\r\n\r\n<a name=\"customizing-the-css\"></a>\r\n#### 自定义 CSS\r\n\r\n导出组件后，`resources/views/vendor/mail/html/themes` 目录将包含一个 `default.css` 文件。 您可以自定义此文件中的 CSS，您的样式将自动内联在您的 Markdown 通知的 HTML 表示中。\r\n\r\n如果你想为 Laravel 的 Markdown 组件构建一个全新的主题，你可以在 `html/themes` 目录中放置一个 CSS 文件。命名并保存 CSS 文件后，更新 `mail` 配置文件的 `theme` 选项以匹配新主题的名称。\r\n\r\n\r\n\r\n要为单个通知自定义主题，您可以在构建通知的邮件消息时调用 `theme` 方法。 `theme` 方法接受发送通知时应该使用的主题名称：\r\n\r\n    /**\r\n     * Get the mail representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\r\n     */\r\n    public function toMail($notifiable)\r\n    {\r\n        return (new MailMessage)\r\n                    ->theme('invoice')\r\n                    ->subject('Invoice Paid')\r\n                    ->markdown('mail.invoice.paid', ['url' => $url]);\r\n    }\r\n\r\n<a name=\"database-notifications\"></a>\r\n## 数据库通知\r\n\r\n<a name=\"database-prerequisites\"></a>\r\n### 必要条件\r\n\r\n`database` 通知通道将通知信息存储在数据库表中。此表将包含通知类型等信息以及描述通知的 JSON 数据结构。\r\n\r\n您可以查询该表以在应用程序的用户界面中显示通知。但是，在您这样做之前，您需要创建一个数据库表来保存您的通知。您可以使用 `notifications:table` 命令生成具有正确表模式的 [migration](/docs/laravel/9.x/migrations)：\r\n\r\n```shell\r\nphp artisan notifications:table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"formatting-database-notifications\"></a>\r\n### 格式化数据库通知\r\n\r\n如果通知支持存储在数据库表中，则应在通知类上定义 `toDatabase` 或 `toArray` 方法。这个方法将接收一个 `$notifiable` 实体并且应该返回一个普通的 PHP 数组。 返回的数组将被编码为 JSON 并存储在 `notifications` 表的 `data` 列中。让我们看一个示例 `toArray` 方法：\r\n\r\n    /**\r\n     * Get the array representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return array\r\n     */\r\n    public function toArray($notifiable)\r\n    {\r\n        return [\r\n            'invoice_id' => $this->invoice->id,\r\n            'amount' => $this->invoice->amount,\r\n        ];\r\n    }\r\n\r\n\r\n\r\n<a name=\"todatabase-vs-toarray\"></a>\r\n#### `toDatabase` 对比 `toArray`\r\n\r\n`broadcast` 通道也使用 `toArray` 方法来确定将哪些数据广播到 JavaScript 驱动的前端。如果您想为 `database` 和 `broadcast` 通道提供两种不同的数组表示，您应该定义一个 `toDatabase` 方法而不是 `toArray` 方法。\r\n\r\n<a name=\"accessing-the-notifications\"></a>\r\n### 访问通知\r\n\r\n一旦通知存储在数据库中，您需要一种方便的方式从您的通知实体访问它们。 `Illuminate\\Notifications\\Notifiable` trait 包含在 Laravel 的默认 `App\\Models\\User` 模型中，包括一个 `notifications` [Eloquent 关系](/docs/laravel/9.x/eloquent-relationships)，它返回 实体的通知。要获取通知，您可以像访问任何其他 Eloquent 关系一样访问此方法。默认情况下，通知将按 `created_at` 时间戳排序，最近的通知位于集合的开头：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    foreach ($user->notifications as $notification) {\r\n        echo $notification->type;\r\n    }\r\n\r\n如果您只想检索「未读」通知，可以使用 `unreadNotifications` 关系。同样，这些通知将按`created_at`时间戳排序，最近的通知位于集合的开头：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    foreach ($user->unreadNotifications as $notification) {\r\n        echo $notification->type;\r\n    }\r\n\r\n> 技巧：要从 JavaScript 客户端访问通知，您应该为应用程序定义一个通知控制器，该控制器返回通知实体的通知，例如当前用户。 然后，您可以从 JavaScript 客户端向该控制器的 URL 发出 HTTP 请求。\r\n\r\n\r\n\r\n<a name=\"marking-notifications-as-read\"></a>\r\n### 将通知标记为已读\r\n\r\n通常，您希望在用户查看通知时将其标记为“已读”。 `Illuminate\\Notifications\\Notifiable` trait 提供了 `markAsRead` 方法，它更新通知数据库记录中的 `read_at` 列：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    foreach ($user->unreadNotifications as $notification) {\r\n        $notification->markAsRead();\r\n    }\r\n\r\n但是，您可以直接在通知集合上使用 `markAsRead` 方法，而不是循环遍历每个通知：\r\n\r\n    $user->unreadNotifications->markAsRead();\r\n\r\n您还可以使用批量更新查询将所有通知标记为已读，而无需从数据库中检索它们：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    $user->unreadNotifications()->update(['read_at' => now()]);\r\n\r\n您可以 `delete` 通知以将它们从表中完全删除：\r\n\r\n    $user->notifications()->delete();\r\n\r\n<a name=\"broadcast-notifications\"></a>\r\n## 广播通知\r\n\r\n<a name=\"broadcast-prerequisites\"></a>\r\n### 必要条件\r\n\r\n在广播通知之前，您应该配置并熟悉 Laravel 的 [事件广播](/docs/laravel/9.x/broadcasting) 服务。事件广播提供了一种从 JavaScript 驱动的前端对服务器端 Laravel 事件做出反应的方法。\r\n\r\n<a name=\"formatting-broadcast-notifications\"></a>\r\n### 格式化广播通知\r\n\r\n`broadcast` 频道使用 Laravel 的 [事件广播](/docs/laravel/9.x/broadcasting) 服务广播通知，允许您的 JavaScript 驱动的前端实时捕获通知。如果通知支持广播，您可以在通知类上定义一个 `toBroadcast` 方法。此方法将接收一个 `$notifiable` 实体并应返回一个 `BroadcastMessage` 实例。如果 `toBroadcast` 方法不存在，`toArray` 方法将用于收集应该广播的数据。返回的数据将被编码为 JSON 并广播到您的 JavaScript 驱动的前端。让我们看一个示例 `toBroadcast` 方法：\r\n\r\n    use Illuminate\\Notifications\\Messages\\BroadcastMessage;\r\n\r\n    /**\r\n     * Get the broadcastable representation of the notification.\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return BroadcastMessage\r\n     */\r\n    public function toBroadcast($notifiable)\r\n    {\r\n        return new BroadcastMessage([\r\n            'invoice_id' => $this->invoice->id,\r\n            'amount' => $this->invoice->amount,\r\n        ]);\r\n    }\r\n\r\n\r\n\r\n<a name=\"broadcast-queue-configuration\"></a>\r\n#### 广播队列配置\r\n\r\n所有广播通知都排队等待广播。如果您想配置用于排队广播操作的队列连接或队列名称，您可以使用 `BroadcastMessage` 的 `onConnection` 和 `onQueue` 方法：\r\n\r\n    return (new BroadcastMessage($data))\r\n                    ->onConnection('sqs')\r\n                    ->onQueue('broadcasts');\r\n\r\n<a name=\"customizing-the-notification-type\"></a>\r\n#### 自定义通知类型\r\n\r\n除了您指定的数据外，所有广播通知还有一个 `type` 字段，其中包含通知的完整类名。如果你想自定义通知的 `type`，你可以在通知类上定义一个`broadcastType`方法：\r\n\r\n    use Illuminate\\Notifications\\Messages\\BroadcastMessage;\r\n\r\n    /**\r\n     * 获取正在广播的通知的类型。\r\n     *\r\n     * @return string\r\n     */\r\n    public function broadcastType()\r\n    {\r\n        return 'broadcast.message';\r\n    }\r\n\r\n<a name=\"listening-for-notifications\"></a>\r\n### 监听通知\r\n\r\n通知将在使用 `{notifiable}.{id}` 约定格式化的私人频道上广播。因此，如果您要向 ID 为 1 的 App\\Models\\User 实例发送通知，则通知将在 `App.Models.User.1` 私有频道上广播。使用 [Laravel Echo](/docs/laravel/9.x/broadcasting#client-side-installation) 时，您可以使用 `notification` 方法轻松地监听频道上的通知：\r\n\r\n    Echo.private('App.Models.User.' + userId)\r\n        .notification((notification) => {\r\n            console.log(notification.type);\r\n        });\r\n\r\n<a name=\"customizing-the-notification-channel\"></a>\r\n#### 自定义通知通道\r\n\r\n如果你想自定义一个实体的广播通知在哪个频道上广播，你可以在通知实体上定义一个`receivesBroadcastNotificationsOn`方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * 用户接收通知广播的频道。\r\n         *\r\n         * @return string\r\n         */\r\n        public function receivesBroadcastNotificationsOn()\r\n        {\r\n            return 'users.'.$this->id;\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"sms-notifications\"></a>\r\n## 短信通知\r\n\r\n<a name=\"sms-prerequisites\"></a>\r\n### 必要条件\r\n\r\n在 Laravel 中发送 SMS 通知由 [Vonage](https://www.vonage.com/)（以前称为 Nexmo）提供支持。在通过 Vonage 发送通知之前，您需要安装 `laravel/vonage-notification-channel` 和 `guzzlehttp/guzzle` 包：\r\n\r\n    composer require laravel/vonage-notification-channel guzzlehttp/guzzle\r\n\r\n该软件包包括一个[配置文件]（https://github.com/laravel/vonage-notification-channel/blob/3.x/config/vonage.php）。 但是，您不需要将此配置文件导出到您自己的应用程序。您可以简单地使用 `VONAGE_KEY` 和 `VONAGE_SECRET` 环境变量来定义您的 Vonage 公钥和密钥。\r\n\r\n定义好密钥后，您可以设置一个 `VONAGE_SMS_FROM` 环境变量，该变量定义了您的 SMS 消息默认发送的电话号码。您可以在 Vonage 控制面板中生成此电话号码：\r\n\r\n    VONAGE_SMS_FROM=15556666666\r\n\r\n<a name=\"formatting-sms-notifications\"></a>\r\n### 格式化短信通知\r\n\r\n如果通知支持作为 SMS 发送，您应该在通知类上定义一个 `toVonage` 方法。此方法将接收一个 `$notifiable` 实体并应返回一个 `Illuminate\\Notifications\\Messages\\VonageMessage` 实例：\r\n\r\n    /**\r\n     * 获取通知的 Vonage / SMS 表示。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\VonageMessage\r\n     */\r\n    public function toVonage($notifiable)\r\n    {\r\n        return (new VonageMessage)\r\n                    ->content('Your SMS message content');\r\n    }\r\n\r\n<a name=\"unicode-content\"></a>\r\n#### 统一码内容\r\n\r\n如果您的 SMS 消息将包含 unicode 字符，则应在构造 `VonageMessage` 实例时调用 `unicode` 方法：\r\n\r\n    /**\r\n     * 获取通知的Vonage/SMS表示形式。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\VonageMessage\r\n     */\r\n    public function toVonage($notifiable)\r\n    {\r\n        return (new VonageMessage)\r\n                    ->content('Your unicode message')\r\n                    ->unicode();\r\n    }\r\n\r\n\r\n\r\n<a name=\"customizing-the-from-number\"></a>\r\n### 自定义“发件人”号码\r\n\r\n如果您想从与您的 `VONAGE_SMS_FROM` 环境变量指定的电话号码不同的电话号码发送一些通知，您可以在 `VonageMessage` 实例上调用 `from` 方法：\r\n\r\n    /**\r\n     * 获取通知的 Vonage / SMS 表示。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\VonageMessage\r\n     */\r\n    public function toVonage($notifiable)\r\n    {\r\n        return (new VonageMessage)\r\n                    ->content('您的短信内容')\r\n                    ->from('15554443333');\r\n    }\r\n\r\n<a name=\"adding-a-client-reference\"></a>\r\n### 添加客户参考\r\n\r\n如果您想跟踪每个用户、团队或客户的成本，您可以在通知中添加「客户参考」。 Vonage 将允许您使用此客户端参考生成报告，以便您更好地了解特定客户的 SMS 使用情况。 客户端引用可以是最多 40 个字符的任何字符串：\r\n\r\n    /**\r\n     * 获取通知的Vonage/SMS表示形式。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\VonageMessage\r\n     */\r\n    public function toVonage($notifiable)\r\n    {\r\n        return (new VonageMessage)\r\n                    ->clientReference((string) $notifiable->id)\r\n                    ->content('您的短信内容');\r\n    }\r\n\r\n<a name=\"routing-sms-notifications\"></a>\r\n### 路由短信通知\r\n\r\n要将Vonage通知路由到正确的电话号码，请在您的应报告实体上定义“routeNotificationForVonage”方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * Vonage频道的路由通知。\r\n         *\r\n         * @param  \\Illuminate\\Notifications\\Notification  $notification\r\n         * @return string\r\n         */\r\n        public function routeNotificationForVonage($notification)\r\n        {\r\n            return $this->phone_number;\r\n        }\r\n    }\r\n\r\n<a name=\"slack-notifications\"></a>\r\n## 延迟通知\r\n\r\n<a name=\"slack-prerequisites\"></a>\r\n\r\n\r\n### 必要条件\r\n\r\n在您可以通过 Slack 发送通知之前，您必须通过 Composer 安装 Slack 通知通道：\r\n\r\n```shell\r\ncomposer require laravel/slack-notification-channel\r\n```\r\n\r\n您还需要为您的团队创建一个 [Slack 应用程序](https://api.slack.com/apps?new_app=1)。 创建应用程序后，您应该为工作区配置一个「传入 Webhook」。 然后，Slack 将为您提供一个 webhook URL，您可以在 [路由 Slack 通知](#routing-slack-notifications) 时使用该 URL。\r\n\r\n<a name=\"formatting-slack-notifications\"></a>\r\n### 格式化 Slack 通知\r\n\r\n如果通知支持作为 Slack 消息发送，则应在通知类上定义 `toSlack` 方法。此方法将接收一个 `$notifiable` 实体并应返回一个 `Illuminate\\Notifications\\Messages\\SlackMessage` 实例。 Slack 消息可能包含文本内容以及格式化附加文本或字段数组的“附件”。 让我们看一个基本的 `toSlack` 示例：\r\n\r\n    /**\r\n     * 获取通知的 Slack 表示。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\SlackMessage\r\n     */\r\n    public function toSlack($notifiable)\r\n    {\r\n        return (new SlackMessage)\r\n                    ->content('One of your invoices has been paid!');\r\n    }\r\n\r\n<a name=\"slack-attachments\"></a>\r\n### Slack 附件\r\n\r\n您还可以在邮件中添加「附件」。附件提供了比简单文本消息更丰富的格式选项。在本例中，我们将发送一个有关应用程序中发生的异常的错误通知，其中包括一个链接，用于查看有关该异常的更多详细信息：\r\n\r\n    /**\r\n     * 获取通知的Slake表示形式。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return \\Illuminate\\Notifications\\Messages\\SlackMessage\r\n     */\r\n    public function toSlack($notifiable)\r\n    {\r\n        $url = url('/exceptions/'.$this->exception->id);\r\n\r\n        return (new SlackMessage)\r\n                    ->error()\r\n                    ->content('哎呀！ 有些不对劲。')\r\n                    ->attachment(function ($attachment) use ($url) {\r\n                        $attachment->title('Exception: 找不到文件', $url)\r\n                                   ->content('File [background.jpg] 没有找到。');\r\n                    });\r\n    }\r\n\r\n\r\n\r\n附件还允许您指定应呈现给用户的数据数组。 给定的数据将以表格形式呈现，以便于阅读：\r\n\r\n    /**\r\n     * 获取通知的 Slack 表现形式。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return SlackMessage\r\n     */\r\n    public function toSlack($notifiable)\r\n    {\r\n        $url = url('/invoices/'.$this->invoice->id);\r\n\r\n        return (new SlackMessage)\r\n                    ->success()\r\n                    ->content('One of your invoices has been paid!')\r\n                    ->attachment(function ($attachment) use ($url) {\r\n                        $attachment->title('Invoice 1322', $url)\r\n                                   ->fields([\r\n                                        'Title' => 'Server Expenses',\r\n                                        'Amount' => '$1,234',\r\n                                        'Via' => 'American Express',\r\n                                        'Was Overdue' => ':-1:',\r\n                                    ]);\r\n                    });\r\n    }\r\n\r\n<a name=\"markdown-attachment-content\"></a>\r\n#### Markdown 附件内容\r\n\r\n如果您的某些附件字段包含 Markdown，您可以使用 `markdown` 方法指示 Slack 将给定的附件字段解析并显示为 Markdown 格式的文本。 此方法接受的值是：`pretext`、`text` 和/或`fields`。 有关 Slack 附件格式的更多信息，请查看 [Slack API 文档](https://api.slack.com/docs/message-formatting#message_formatting)：\r\n\r\n    /**\r\n     * 获取通知的 Slack 表示。\r\n     *\r\n     * @param  mixed  $notifiable\r\n     * @return SlackMessage\r\n     */\r\n    public function toSlack($notifiable)\r\n    {\r\n        $url = url('/exceptions/'.$this->exception->id);\r\n\r\n        return (new SlackMessage)\r\n                    ->error()\r\n                    ->content('哎呀！ 有些不对劲。')\r\n                    ->attachment(function ($attachment) use ($url) {\r\n                        $attachment->title('Exception: 文件未找到', $url)\r\n                                   ->content('File [background.jpg] was *not found*.')\r\n                                   ->markdown(['text']);\r\n                    });\r\n    }\r\n\r\n<a name=\"routing-slack-notifications\"></a>\r\n### 路由 Slack 通知\r\n\r\n要将 Slack 通知路由到适当的 Slack 团队和频道，请在您的通知实体上定义一个 `routeNotificationForSlack` 方法。这应该返回通知应该发送到的 webhook URL。可以通过向您的 Slack 团队添加「传入 Webhook」服务来生成 Webhook URL：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * 路由 Slack 频道的通知。\r\n         *\r\n         * @param  \\Illuminate\\Notifications\\Notification  $notification\r\n         * @return string\r\n         */\r\n        public function routeNotificationForSlack($notification)\r\n        {\r\n            return 'https://hooks.slack.com/services/...';\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"localizing-notifications\"></a>\r\n## 本地化通知\r\n\r\nLaravel 允许您在 HTTP 请求的当前语言环境之外的语言环境中发送通知，如果通知在排队，它甚至会记住这个语言环境。\r\n\r\n为此，`Illuminate\\Notifications\\Notification` 类提供了一个 `locale` 方法来设置所需的语言。应用程序将在评估通知时更改为此区域设置，然后在评估完成后恢复为先前的区域设置：\r\n\r\n    $user->notify((new InvoicePaid($invoice))->locale('es'));\r\n\r\n多个通知条目的本地化也可以通过 `Notification` 门面实现：\r\n\r\n    Notification::locale('es')->send(\r\n        $users, new InvoicePaid($invoice)\r\n    );\r\n\r\n<a name=\"user-preferred-locales\"></a>\r\n### 用户首选语言环境\r\n\r\n有时，应用程序存储每个用户的首选语言环境。通过在你的通知模型上实现 `HasLocalePreference` 合约，你可以指示 Laravel 在发送通知时使用这个存储的语言环境：\r\n\r\n    use Illuminate\\Contracts\\Translation\\HasLocalePreference;\r\n\r\n    class User extends Model implements HasLocalePreference\r\n    {\r\n        /**\r\n         * 获取用户的首选语言环境。\r\n         *\r\n         * @return string\r\n         */\r\n        public function preferredLocale()\r\n        {\r\n            return $this->locale;\r\n        }\r\n    }\r\n\r\n一旦你实现了接口，Laravel 将在向模型发送通知和邮件时自动使用首选语言环境。因此，使用该接口时无需调用 `locale` 方法：\r\n\r\n    $user->notify(new InvoicePaid($invoice));\r\n\r\n<a name=\"notification-events\"></a>\r\n## 通知事件\r\n\r\n<a name=\"notification-sending-event\"></a>\r\n#### 通知发送事件\r\n\r\n发送通知时，通知系统会调度 `Illuminate\\Notifications\\Events\\NotificationSending` [event](/docs/laravel/9.x/events)。 这包含“可通知”实体和通知实例本身。您可以在应用程序的 `EventServiceProvider` 中为此事件注册监听器：\r\n\r\n    /**\r\n     * 应用程序的事件监听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Notifications\\Events\\NotificationSending' => [\r\n            'App\\Listeners\\CheckNotificationStatus',\r\n        ],\r\n    ];\r\n\r\n\r\n\r\n如果 `NotificationSending` 事件的事件侦听器从其 `handle` 方法返回 `false`，则不会发送通知：\r\n\r\n    use Illuminate\\Notifications\\Events\\NotificationSending;\r\n\r\n    /**\r\n     * 处理事件。\r\n     *\r\n     * @param  \\Illuminate\\Notifications\\Events\\NotificationSending  $event\r\n     * @return void\r\n     */\r\n    public function handle(NotificationSending $event)\r\n    {\r\n        return false;\r\n    }\r\n\r\n在事件侦听器中，您可以访问事件的 `notifiable`、`notification` 和 `channel` 属性，以了解有关通知接收者或通知本身的更多信息：\r\n\r\n    /**\r\n     * 处理事件。\r\n     *\r\n     * @param  \\Illuminate\\Notifications\\Events\\NotificationSending  $event\r\n     * @return void\r\n     */\r\n    public function handle(NotificationSending $event)\r\n    {\r\n        // $event->channel\r\n        // $event->notifiable\r\n        // $event->notification\r\n    }\r\n\r\n<a name=\"notification-sent-event\"></a>\r\n#### 通知发送事件\r\n\r\n发送通知时，通知系统会调度 `Illuminate\\Notifications\\Events\\NotificationSent` [event](/docs/laravel/9.x/events)。这包含「可通知」实体和通知实例本身。您可以在 `EventServiceProvider` 中为此事件注册监听器：\r\n\r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Notifications\\Events\\NotificationSent' => [\r\n            'App\\Listeners\\LogNotification',\r\n        ],\r\n    ];\r\n\r\n> 技巧：在您的 `EventServiceProvider` 中注册监听器后，使用 `event:generate` Artisan 命令快速生成监听器类。\r\n\r\n在事件侦听器中，您可以访问事件的 `notifiable`、`notification`、`channel` 和 `response` 属性，以了解有关通知接收者或通知本身的更多信息：\r\n\r\n    /**\r\n     * 处理事件。\r\n     *\r\n     * @param  \\Illuminate\\Notifications\\Events\\NotificationSent  $event\r\n     * @return void\r\n     */\r\n    public function handle(NotificationSent $event)\r\n    {\r\n        // $event->channel\r\n        // $event->notifiable\r\n        // $event->notification\r\n        // $event->response\r\n    }\r\n\r\n<a name=\"custom-channels\"></a>\r\n## 自定义频道\r\n\r\nLaravel 附带了一些通知通道，但你可能想编写自己的驱动程序来通过其他通道传递通知。 Laravel 让它变得简单。首先，定义一个包含 `send` 方法的类。该方法应该接收两个参数：一个`$notifiable`和一个`$notification`。\r\n\r\n\r\n\r\n在 `send` 方法中，您可以调用通知上的方法来检索您的频道可以理解的消息对象，然后将通知发送到 `$notifiable` 实例，但是您希望：\r\n\r\n    <?php\r\n\r\n    namespace App\\Notifications;\r\n\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class VoiceChannel\r\n    {\r\n        /**\r\n         * 发送给定的通知。\r\n         *\r\n         * @param  mixed  $notifiable\r\n         * @param  \\Illuminate\\Notifications\\Notification  $notification\r\n         * @return void\r\n         */\r\n        public function send($notifiable, Notification $notification)\r\n        {\r\n            $message = $notification->toVoice($notifiable);\r\n\r\n            // 向 $notifiable 实例发送通知...\r\n        }\r\n    }\r\n\r\n一旦定义了通知通道类，您可以从任何通知的 `via` 方法返回类名。在此示例中，通知的 `toVoice` 方法可以返回您选择表示语音消息的任何对象。例如，您可以定义自己的 `VoiceMessage` 类来表示这些消息：\r\n\r\n    <?php\r\n\r\n    namespace App\\Notifications;\r\n\r\n    use App\\Notifications\\Messages\\VoiceMessage;\r\n    use App\\Notifications\\VoiceChannel;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class InvoicePaid extends Notification\r\n    {\r\n        use Queueable;\r\n\r\n        /**\r\n         * 获取通知频道。\r\n         *\r\n         * @param  mixed  $notifiable\r\n         * @return array|string\r\n         */\r\n        public function via($notifiable)\r\n        {\r\n            return [VoiceChannel::class];\r\n        }\r\n\r\n        /**\r\n         * 获取通知的语音表示。\r\n         *\r\n         * @param  mixed  $notifiable\r\n         * @return VoiceMessage\r\n         */\r\n        public function toVoice($notifiable)\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n","p":"docs/notifications.html"},{"t":"packages (包开发)","d":"# 包开发\r\n\r\n- [介绍](#introduction)\r\n     - [关于 Facades](#a-note-on-facades)\r\n- [包发现](#package-discovery)\r\n- [服务提供商](#service-providers)\r\n- [资源](#resources)\r\n     - [配置](#配置)\r\n     - [迁移](#migrations)\r\n     - [路由](#routes)\r\n     - [翻译](#translations)\r\n     - [视图](#views)\r\n     - [视图组件](#view-components)\r\n- [命令](#commands)\r\n- [公共资源](#public-assets)\r\n- [发布文件组](#publishing-file-groups)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n包是向 Laravel 添加功能的主要方式。 包可能是处理日期的好方法，例如 [Carbon](https://github.com/briannesbitt/Carbon)，也可能是允许您将文件与 Eloquent 模型相关联的包，例如 Spatie 的 [Laravel 媒体库](https://github.com/spatie/laravel-medialibrary)。\r\n\r\n有不同类型的包。 有些包是独立的，这意味着它们可以与任何 PHP 框架一起使用。 Carbon 和 PHPUnit 是独立包的示例。 任何这些包都可以通过在你的 `composer.json` 文件中的要求来与 Laravel 一起使用。\r\n\r\n另一方面，其他软件包专门用于 Laravel。 这些包可能包含专门用于增强 Laravel 应用程序的路由、控制器、视图和配置。 本指南主要涵盖了那些特定于 Laravel 的包的开发。\r\n\r\n<a name=\"a-note-on-facades\"></a>\r\n### 关于 Facades\r\n\r\n在编写 Laravel 应用程序时，通常使用契约还是外观并不重要，因为两者都提供了基本相同的可测试性级别。 但是，在编写包时，您的包通常无法访问 Laravel 的所有测试助手。 如果您希望能够像将包安装在典型的 Laravel 应用程序中一样编写包测试，您可以使用 [Orchestral Testbench](https://github.com/orchestral/testbench) 包。\r\n\r\n\r\n\r\n<a name=\"package-discovery\"></a>\r\n## 包发现\r\n\r\n在 Laravel 应用程序的 `config/app.php` 配置文件中，`providers` 选项定义了 Laravel 应该加载的服务提供者列表。 当有人安装您的软件包时，您通常希望您的服务提供商包含在此列表中。 您可以在包的 `composer.json` 文件的 `extra` 部分中定义提供者，而不是要求用户手动将您的服务提供者添加到列表中。 除了服务提供商之外，您还可以列出您想注册的任何 [facades](/docs/laravel/9.x/facades)：\r\n\r\n```json\r\n\"extra\": {\r\n    \"laravel\": {\r\n        \"providers\": [\r\n            \"Barryvdh\\\\Debugbar\\\\ServiceProvider\"\r\n        ],\r\n        \"aliases\": {\r\n            \"Debugbar\": \"Barryvdh\\\\Debugbar\\\\Facade\"\r\n        }\r\n    }\r\n},\r\n```\r\n\r\n一旦你的包被配置为发现，Laravel 将在安装时自动注册它的服务提供者和门面，为你的包的用户创造一个方便的安装体验。\r\n\r\n<a name=\"opting-out-of-package-discovery\"></a>\r\n### 选择退出包发现\r\n\r\n如果您是一个包的消费者并且想要禁用包的包发现，您可以在应用程序的 `composer.json` 文件的 `extra` 部分列出包名：\r\n\r\n```json\r\n\"extra\": {\r\n    \"laravel\": {\r\n        \"dont-discover\": [\r\n            \"barryvdh/laravel-debugbar\"\r\n        ]\r\n    }\r\n},\r\n```\r\n\r\n您可以使用应用程序的 `dont-discover` 指令中的 `*` 字符禁用所有包的包发现：\r\n\r\n```json\r\n\"extra\": {\r\n    \"laravel\": {\r\n        \"dont-discover\": [\r\n            \"*\"\r\n        ]\r\n    }\r\n},\r\n```\r\n\r\n<a name=\"service-providers\"></a>\r\n## 服务供应商\r\n\r\n[服务提供者](/docs/laravel/9.x/providers) 是你的包和 Laravel 之间的连接点。 服务提供者负责将事物绑定到 Laravel 的 [服务容器](/docs/laravel/9.x/container) 并通知 Laravel 在哪里加载包资源，例如视图、配置和本地化文件。\r\n\r\n\r\n\r\n服务提供者扩展了 `Illuminate\\Support\\ServiceProvider` 类并包含两个方法：`register` 和 `boot`。 基本的 `ServiceProvider` 类位于 `illuminate/support` Composer 包中，您应该将其添加到您自己的包的依赖项中。 要了解有关服务提供者的结构和目的的更多信息，请查看 [他们的文档](/docs/laravel/9.x/providers)。\r\n\r\n<a name=\"resources\"></a>\r\n## 资源\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\n通常，您需要将包的配置文件发布到应用程序的 `config` 目录。 这将允许您的包的用户轻松覆盖您的默认配置选项。 要允许发布配置文件，请从服务提供者的 `boot` 方法中调用 `publishes` 方法：\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->publishes([\r\n            __DIR__.'/../config/courier.php' => config_path('courier.php'),\r\n        ]);\r\n    }\r\n\r\n现在，当你的包的用户执行 Laravel 的 `vendor:publish` 命令时，你的文件将被复制到指定的发布位置。 发布配置后，可以像访问任何其他配置文件一样访问其值：\r\n\r\n    $value = config('courier.option');\r\n\r\n> 注意：您不应该在配置文件中定义闭包。 当用户执行 `config:cache` Artisan 命令时，它们无法正确序列化。\r\n\r\n<a name=\"default-package-configuration\"></a>\r\n#### 默认包配置\r\n\r\n您还可以将自己的包配置文件与应用程序的已发布副本合并。 这将允许您的用户在配置文件的已发布副本中仅定义他们实际想要覆盖的选项。 要合并配置文件值，请在服务提供商的 `register` 方法中使用 `mergeConfigFrom` 方法。\r\n\r\n\r\n\r\n`mergeConfigFrom` 方法接受包配置文件的路径作为其第一个参数，应用程序的配置文件副本的名称作为其第二个参数：\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->mergeConfigFrom(\r\n            __DIR__.'/../config/courier.php', 'courier'\r\n        );\r\n    }\r\n\r\n> 注意：此方法仅合并配置数组的第一级。 如果您的用户部分定义了多维配置数组，则不会合并缺少的选项。\r\n\r\n<a name=\"routes\"></a>\r\n### 路由\r\n\r\n如果你的包包含路由，你可以使用 `loadRoutesFrom` 方法加载它们。 此方法将自动确定应用程序的路由是否被缓存，如果路由已被缓存，则不会加载您的路由文件：\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->loadRoutesFrom(__DIR__.'/../routes/web.php');\r\n    }\r\n\r\n<a name=\"migrations\"></a>\r\n### 迁移\r\n\r\n如果你的包包含 [数据库迁移](/docs/laravel/9.x/migrations)，你可以使用 `loadMigrationsFrom` 方法告诉 Laravel 如何加载它们。 `loadMigrationsFrom` 方法接受包迁移的路径作为其唯一参数：\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->loadMigrationsFrom(__DIR__.'/../database/migrations');\r\n    }\r\n\r\n一旦您的包的迁移被注册，它们将在执行 `php artisan migrate` 命令时自动运行。 您不需要将它们导出到应用程序的 `database/migrations` 目录。\r\n\r\n<a name=\"translations\"></a>\r\n### 翻译\r\n\r\n如果你的包包含 [翻译文件](/docs/laravel/9.x/localization)，你可以使用 `loadTranslationsFrom` 方法告诉 Laravel 如何加载它们。 例如，如果您的包名为 `courier`，则应将以下内容添加到服务提供商的 `boot` 方法中：\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');\r\n    }\r\n\r\n\r\n\r\n使用 `package::file.line` 语法约定引用包翻译。 因此，您可以从 `messages` 文件中加载 `courier` 包的 `welcome` 行，如下所示：\r\n\r\n    echo trans('courier::messages.welcome');\r\n\r\n<a name=\"publishing-translations\"></a>\r\n#### 翻译\r\n\r\n如果您想将包的翻译发布到应用程序的 `lang/vendor` 目录，您可以使用服务提供者的 `publishes` 方法。 `publishes` 方法接受一组包路径及其所需的发布位置。 例如，要发布 `courier` 包的翻译文件，您可以执行以下操作：\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');\r\n\r\n        $this->publishes([\r\n            __DIR__.'/../lang' => $this->app->langPath('vendor/courier'),\r\n        ]);\r\n    }\r\n\r\n现在，当你的包的用户执行 Laravel 的 `vendor:publish` Artisan 命令时，你的包的翻译将被发布到指定的发布位置。\r\n\r\n<a name=\"views\"></a>\r\n### 视图\r\n\r\n要将包的 [views](/docs/laravel/9.x/views) 注册到 Laravel，你需要告诉 Laravel 视图的位置。 您可以使用服务提供者的 `loadViewsFrom` 方法来执行此操作。 `loadViewsFrom` 方法接受两个参数：视图模板的路径和包的名称。 例如，如果您的包的名称是 `courier`，您可以将以下内容添加到服务提供商的 `boot` 方法中：\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');\r\n    }\r\n\r\n使用 `package::view` 语法约定来引用包视图。 因此，一旦您的视图路径在服务提供者中注册，您就可以从 `courier` 包中加载 `dashboard` 视图，如下所示：\r\n\r\n    Route::get('/dashboard', function () {\r\n        return view('courier::dashboard');\r\n    });\r\n\r\n\r\n\r\n<a name=\"overriding-package-views\"></a>\r\n#### 覆盖包视图\r\n\r\n当你使用 `loadViewsFrom` 方法时，Laravel 实际上为你的视图注册了两个位置：应用程序的 `resources/views/vendor` 目录和你指定的目录。 因此，以 `courier` 包为例，Laravel 将首先检查开发人员是否已将自定义版本的视图放置在 `resources/views/vendor/courier` 目录中。 然后，如果视图没有被自定义，Laravel 将搜索你在调用 `loadViewsFrom` 时指定的包视图目录。 这使包用户可以轻松自定义/覆盖您的包的视图。\r\n\r\n<a name=\"publishing-views\"></a>\r\n#### 发布视图\r\n\r\n如果您想让您的视图可用于发布到应用程序的 `resources/views/vendor` 目录，您可以使用服务提供者的 `publishes` 方法。 `publishes` 方法接受一组包视图路径及其所需的发布位置：\r\n\r\n    /**\r\n     * Bootstrap package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');\r\n\r\n        $this->publishes([\r\n            __DIR__.'/../resources/views' => resource_path('views/vendor/courier'),\r\n        ]);\r\n    }\r\n\r\n现在，当你的包的用户执行 Laravel 的 `vendor:publish` Artisan 命令时，你的包的视图将被复制到指定的发布位置。\r\n\r\n<a name=\"view-components\"></a>\r\n### 视图组件\r\n\r\n如果你的包包含 [视图组件](/docs/laravel/9.x/blade#components)，你可以使用 `loadViewComponentsAs` 方法告诉 Laravel 如何加载它们。 `loadViewComponentsAs` 方法接受两个参数：视图组件的标签前缀和视图组件类名称的数组。 例如，如果您的包的前缀是 `courier` 并且您有 `Alert` 和 `Button` 视图组件，您可以将以下内容添加到服务提供者的 `boot` 方法中：\r\n\r\n    use Courier\\Components\\Alert;\r\n    use Courier\\Components\\Button;\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->loadViewComponentsAs('courier', [\r\n            Alert::class,\r\n            Button::class,\r\n        ]);\r\n    }\r\n\r\n\r\n\r\n一旦您的视图组件在服务提供者中注册，您可以在视图中引用它们，如下所示：\r\n\r\n```blade\r\n<x-courier-alert />\r\n\r\n<x-courier-button />\r\n```\r\n\r\n<a name=\"anonymous-components\"></a>\r\n#### 匿名组件\r\n\r\n如果你的包包含匿名组件，它们必须放在你包的 `views` 目录的 `components` 目录中（由`loadViewsFrom` 指定）。 然后，您可以通过在组件名称前加上包的视图命名空间来呈现它们：\r\n\r\n```blade\r\n<x-courier::alert />\r\n```\r\n\r\n<a name=\"commands\"></a>\r\n## 命令\r\n\r\n要在 Laravel 中注册你的包的 Artisan 命令，你可以使用 `commands` 方法。 此方法需要一个命令类名称数组。 注册命令后，您可以使用 [Artisan CLI](/docs/laravel/9.x/artisan) 执行它们：\r\n\r\n    use Courier\\Console\\Commands\\InstallCommand;\r\n    use Courier\\Console\\Commands\\NetworkCommand;\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        if ($this->app->runningInConsole()) {\r\n            $this->commands([\r\n                InstallCommand::class,\r\n                NetworkCommand::class,\r\n            ]);\r\n        }\r\n    }\r\n\r\n<a name=\"public-assets\"></a>\r\n## 公共资源\r\n\r\n您的包可能包含 JavaScript、CSS 和图像等资产。要将这些资产发布到应用程序的 `public` 目录，请使用服务提供者的 `publishes` 方法。在本例中，我们还将添加一个 `public` 资产组标签，可用于轻松发布相关资产组：\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->publishes([\r\n            __DIR__.'/../public' => public_path('vendor/courier'),\r\n        ], 'public');\r\n    }\r\n\r\n现在，当您的包的用户执行 `vendor:publish` 命令时，您的资产将被复制到指定的发布位置。由于用户通常需要在每次更新包时覆盖资产，您可以使用 `--force` 标志：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=public --force\r\n```\r\n\r\n\r\n\r\n<a name=\"publishing-file-groups\"></a>\r\n## 发布文件组\r\n\r\n您可能希望单独发布包资产和资源组。例如，您可能希望允许用户发布包的配置文件，而不是被迫发布包的全部资产。您可以在包的服务提供者中调用 `publishes` 方法时定义「标签」来做到这一点。例如，让我们使用标签在包的服务提供者的 `boot` 方法中为 `courier` 包定义两个发布组（`courier-config` 和 `courier-migrations`）：\r\n\r\n    /**\r\n     * 引导任何包服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->publishes([\r\n            __DIR__.'/../config/package.php' => config_path('package.php')\r\n        ], 'courier-config');\r\n\r\n        $this->publishes([\r\n            __DIR__.'/../database/migrations/' => database_path('migrations')\r\n        ], 'courier-migrations');\r\n    }\r\n\r\n现在，您的用户可以通过在执行 `vendor:publish` 命令时引用他们的标签来分别发布这些组：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=courier-config\r\n```\r\n\r\n","p":"docs/packages.html"},{"t":"queues (队列)","d":"# 队列\r\n\r\n- [简介](#introduction)\r\n    - [连接 Vs. 驱动](#connections-vs-queues)\r\n    - [驱动程序说明 & 先决条件](#driver-prerequisites)\r\n- [创建任务](#creating-jobs)\r\n    - [生成任务类](#generating-job-classes)\r\n    - [任务类结构](#class-structure)\r\n    - [任务唯一](#unique-jobs)\r\n- [任务中间件](#job-middleware)\r\n    - [访问限制](#rate-limiting)\r\n    - [防止重复任务](#preventing-job-overlaps)\r\n    - [限制异常](#throttling-exceptions)\r\n- [分发任务](#dispatching-jobs)\r\n    - [延迟分发](#delayed-dispatching)\r\n    - [同步调度](#synchronous-dispatching)\r\n    - [任务 & 数据库事务](#jobs-and-database-transactions)\r\n    - [任务链](#job-chaining)\r\n    - [自定义队列 & 连接](#customizing-the-queue-and-connection)\r\n    - [指定任务最大尝试次数 / 超时值](#max-job-attempts-and-timeout)\r\n    - [错误处理](#error-handling)\r\n- [任务批处理](#job-batching)\r\n    - [定义批处理任务](#defining-batchable-jobs)\r\n    - [分发批处理](#dispatching-batches)\r\n    - [将任务加入批处理](#adding-jobs-to-batches)\r\n    - [校验批处理](#inspecting-batches)\r\n    - [取消批处理](#cancelling-batches)\r\n    - [批处理失败](#batch-failures)\r\n    - [批量清理](#pruning-batches)\r\n- [队列闭包](#queueing-closures)\r\n- [运行队列处理器](#running-the-queue-worker)\r\n    - [`queue:work` 命令](#the-queue-work-command)\r\n    - [队列优先级](#queue-priorities)\r\n    - [队列处理器 & 部署](#queue-workers-and-deployment)\r\n    - [任务过期 & 超时](#job-expirations-and-timeouts)\r\n- [Supervisor 配置](#supervisor-configuration)\r\n- [处理失败队列](#dealing-with-failed-jobs)\r\n    - [清理失败任务](#cleaning-up-after-failed-jobs)\r\n    - [重试失败任务](#retrying-failed-jobs)\r\n    - [忽略缺失的模型](#ignoring-missing-models)\r\n    - [清理失败的任务](#pruning-failed-jobs)\r\n    - [在 DynamoDB 中存储失败的任务](#storing-failed-jobs-in-dynamodb)\r\n    - [禁用失败的任务存储](#disabling-failed-job-storage)\r\n    - [任务失败事件](#failed-job-events)\r\n- [清理队列任务](#clearing-jobs-from-queues)\r\n- [监控你的队列](#monitoring-your-queues)\r\n- [任务事件](#job-events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在构建 Web 应用程序时，你可能需要执行一些任务（例如解析和存储上传的 CSV 文件），但这些任务在典型的 Web 请求中花费的时间太长。幸运的是，Laravel 允许你轻松地创建可在后台排队处理的任务作业。通过将耗时的任务移到队列中，你的应用程序可以以超快的速度响应 Web 请求，并为客户提供更好的用户体验。\r\n\r\n\r\n\r\nLaravel 队列提供了可以跨各种不同队列后台的统一 API，例如 [Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io) 甚至关系数据库。\r\n\r\n队列配置文件存储在 `config/queue.php` 中。 在这个文件中，你可以找到框架中包含的每个队列驱动程序的连接配置，其中包括数据库，[Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io), 和 [Beanstalkd](https://beanstalkd.github.io/) 驱动，一个同步驱动程序（供本地使用）。还包括一个用于丢弃排队任务的   `null` 队列驱动。\r\n\r\n> 技巧：现在，Laravel 为你的 Redis 队列提供了 Horizon，一个漂亮的仪表盘和配置系统。查看完整的 [Horizon documentation](/docs/laravel/9.x/horizon) 了解更多信息。\r\n\r\n<a name=\"connections-vs-queues\"></a>\r\n### 连接 Vs 队列\r\n\r\n在开始使用 Laravel 队列之前，理解「连接」和「队列」之间的区别非常重要。在 `config/queue.php` 配置文件中，有一个 `connections` 配置选项。此选项定义到后端服务（如 Amazon SQS、Beanstalk 或 Redis）的特定连接。然而，任何给定的队列连接都可能有多个「队列」，这些「队列」可能被认为是不同的堆栈或成堆的排队任务。\r\n\r\n请注意， `queue` 配置文件中的每个连接配置示例都包含一个 `queue` 属性。 这是将任务发送到给定连接时将被分配到的默认队列。换句话说，如果您没有显式地定义任务应该被发送到哪个队列，那么该任务将被放置在连接配置的 `queue`  属性中定义的队列上：\r\n\r\n    use App\\Jobs\\ProcessPodcast;\r\n\r\n    // 这个任务将被推送到默认队列...\r\n    ProcessPodcast::dispatch();\r\n\r\n    // 这个任务将被推送到 \"emails\" 队列...\r\n    ProcessPodcast::dispatch()->onQueue('emails');\r\n\r\n\r\n\r\n有些应用程序可能不需要将任务推到多个队列中，而是倾向于使用一个简单的队列。然而，如果希望对任务的处理方式进行优先级排序或分段时，将任务推送到多个队列就显得特别有用，因为 Laravel 队列工作程序允许您指定哪些队列应该按优先级处理。例如，如果您将任务推送到一个 `high` 队列，你可能会运行一个赋予它们更高处理优先级的 worker：\r\n\r\n```shell\r\nphp artisan queue:work --queue=high,default\r\n```\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动程序说明和先决条件\r\n\r\n<a name=\"database\"></a>\r\n#### 数据库\r\n\r\n要使用  `database` 队列驱动程序，你需要一个数据库表来保存任务。要生成创建此表的迁移，请运行 `queue:table` Artisan 命令。一旦迁移已经创建，你可以使用 `migrate`命令迁移你的数据库：\r\n\r\n```shell\r\nphp artisan queue:table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n最后，请不要忘记通过修改`.env`文件中的`QUEUE_CONNECTION`变量从而将 `database` 作为你的应用队列驱动程序:\r\n\r\n    QUEUE_CONNECTION=database\r\n\r\n<a name=\"redis\"></a>\r\n#### Redis\r\n\r\n要使用 `redis` 队列驱动程序，需要在 `config/database.php`配置文件中配置一个 redis 数据库连接。\r\n\r\n**Redis 集群**\r\n\r\n如果你的Redis队列当中使用了Redis集群, 那么你的队列名称就必须包含一个 [key hash tag](https://redis.io/topics/cluster-spec#keys-hash-tags)。这是为了确保一个给定队列的所有 Redis 键都被放在同一个哈希插槽：\r\n\r\n    'redis' => [\r\n        'driver' => 'redis',\r\n        'connection' => 'default',\r\n        'queue' => '{default}',\r\n        'retry_after' => 90,\r\n    ],\r\n\r\n\r\n\r\n**阻塞**\r\n\r\n在使用 Redis 队列时，您可以使用`block_for` 配置选项来指定在遍历 worker 循环和重新轮询 Redis 数据库之前，驱动程序需要等待多长时间才能使任务变得可用。\r\n\r\n根据您的队列负载调整此值要比连续轮询 Redis 数据库中的新任务更加有效。例如，您可以将值设置为  `5` 以指示驱动程序在等待任务变得可用时应该阻塞 5 秒：\r\n\r\n    'redis' => [\r\n        'driver' => 'redis',\r\n        'connection' => 'default',\r\n        'queue' => 'default',\r\n        'retry_after' => 90,\r\n        'block_for' => 5,\r\n    ],\r\n\r\n> 注意：将 `block_for` 设置为 `0` 将导致队列workers一直阻塞，直到某一个任务变得可用。这还能防止在下一个任务被处理之前处理诸如 `SIGTERM` 之类的信号。\r\n\r\n<a name=\"other-driver-prerequisites\"></a>\r\n#### 其他驱动的先决条件\r\n\r\n列出的队列驱动需要如下的依赖，这些依赖可通过 Composer 包管理器进行安装：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- Amazon SQS: `aws/aws-sdk-php ~3.0`\r\n- Beanstalkd: `pda/pheanstalk ~4.0`\r\n- Redis: `predis/predis ~1.0` or phpredis PHP 扩展\r\n\r\n</div>\r\n\r\n<a name=\"creating-jobs\"></a>\r\n## 创建任务\r\n\r\n<a name=\"generating-job-classes\"></a>\r\n### 生成任务类\r\n\r\n默认情况下，应用程序的所有的可排队任务都被存储在了 `app/Jobs` 目录中。如果 `app/Jobs` 目录不存在，当您运行 `make:job` Artisan 命令时，将会自动创建该目录：\r\n\r\n```shell\r\nphp artisan make:job ProcessPodcast\r\n```\r\n\r\n生成的类将会实现 `Illuminate\\Contracts\\Queue\\ShouldQueue` 接口， 告诉 Laravel ，该任务应该推入队列以异步的方式运行。\r\n\r\n> 技巧：您可以使用 [stub publishing](/docs/laravel/9.x/artisan#stub-customization)来自定义任务 stub 。\r\n\r\n\r\n\r\n<a name=\"class-structure\"></a>\r\n### 类结构\r\n\r\n任务类非常简单，通常只包含一个 `handle` 方法，在队列处理任务时将会调用它。让我们看一个任务类的示例。在这个例子中，我们假设我们管理一个 podcast 服务，并且需要在上传的 podcast 文件发布之前对其进行处理：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use App\\Models\\Podcast;\r\n    use App\\Services\\AudioProcessor;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * podcast 实例\r\n         *\r\n         * @var \\App\\Models\\Podcast\r\n         */\r\n        protected $podcast;\r\n\r\n        /**\r\n         * 创建一个新的任务实例\r\n         *\r\n         * @param  App\\Models\\Podcast  $podcast\r\n         * @return void\r\n         */\r\n        public function __construct(Podcast $podcast)\r\n        {\r\n            $this->podcast = $podcast;\r\n        }\r\n\r\n        /**\r\n         * 运行任务\r\n         *\r\n         * @param  App\\Services\\AudioProcessor  $processor\r\n         * @return void\r\n         */\r\n        public function handle(AudioProcessor $processor)\r\n        {\r\n            // 处理上传的 podcast...\r\n        }\r\n    }\r\n\r\n在本示例中，请注意，我们能够将一个 [Eloquent model](/docs/laravel/9.x/eloquent) 直接传递到已排队任务的构造函数中。由于任务所使用的 `SerializesModels`，在任务处理时，Eloquent 模型及其加载的关系将被优雅地序列化和反序列化。\r\n\r\n如果你的队列任务在其构造函数中接受一个 Eloquent 模型，那么只有模型的标识符才会被序列化到队列中。当实际处理任务时，队列系统将自动重新从数据库中获取完整的模型实例及其加载的关系。这种用于模型序列化的方式允许将更小的作业有效负载发送给你的队列驱动程序。\r\n\r\n\r\n\r\n<a name=\"handle-method-dependency-injection\"></a>\r\n#### `handle` 方法依赖注入\r\n\r\n当任务由队列处理时，将调用 `handle` 方法。注意，我们可以对任务的 `handle` 方法进行类型提示依赖。Laravel [服务容器](/docs/laravel/9.x/container) 会自动注入这些依赖项。\r\n\r\n如果您想完全控制容器如何将依赖注入  `handle` 方法，你可以使用容器的 `bindMethod`  方法。 `bindMethod` 方法接受一个可接收任务和容器的回调。在回调中，你可以在任何你想用的地方随意调用 `handle` 方法。 通常， 你应该从你的 `App\\Providers\\AppServiceProvider` [服务提供者](/docs/laravel/9.x/providers)  中来调用该方法:\r\n\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Services\\AudioProcessor;\r\n\r\n    $this->app->bindMethod([ProcessPodcast::class, 'handle'], function ($job, $app) {\r\n        return $job->handle($app->make(AudioProcessor::class));\r\n    });\r\n\r\n> 注意：二进制数据，例如原始图像内容，应该在传递到队列任务之前通过 `base64_encode` 函数传递。否则，在将任务放入队列时，可能无法正确地序列化为 JSON。\r\n\r\n<a name=\"handling-relationships\"></a>\r\n#### 队列关系\r\n\r\n因为加载的关系也会被序列化，所以处理序列化任务的字符串有时会变得相当大。为了防止该关系被序列化，可以在设置属性值时对模型调用 `withoutRelations` 方法。此方法将返回没有加载关系的模型实例：\r\n\r\n    /**\r\n     * 创建新的任务实例\r\n     *\r\n     * @param  \\App\\Models\\Podcast  $podcast\r\n     * @return void\r\n     */\r\n    public function __construct(Podcast $podcast)\r\n    {\r\n        $this->podcast = $podcast->withoutRelations();\r\n    }\r\n\r\n\r\n\r\n此外，当反序列化任务并从数据库中重新检索模型关系时，它们将被完整检索。反序列化任务时，将不会应用在任务排队过程中序列化模型之前应用的任何先前关系约束。因此，如果您希望使用给定关系的子集，则应在排队任务中重新限制该关系。\r\n\r\n<a name=\"unique-jobs\"></a>\r\n### Unique Jobs\r\n\r\n> 注意：Unique Jobs需要支持 [locks](/docs/laravel/9.x/cache#atomic-locks) 的缓存驱动程序。 目前，`memcached`、`redis`、`dynamodb`、`database`、`file`和`array`缓存驱动支持原子锁。 此外，独特的任务约束不适用于批次内的任务。\r\n\r\n有时，您可能希望确保在任何时间点队列中只有一个特定任务的实例。你可以通过在你的工作类上实现 `ShouldBeUnique` 接口来做到这一点。这个接口不需要你在你的类上定义任何额外的方法：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\r\n\r\n    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\r\n    {\r\n        ...\r\n    }\r\n\r\n在上面的示例中，`UpdateSearchIndex` 任务是唯一的。因此，如果任务的另一个实例已经在队列中并且尚未完成处理，则不会分派该任务。\r\n\r\n在某些情况下，您可能想要定义一个使任务唯一的特定「键」，或者您可能想要指定一个超时，超过该超时任务不再保持唯一。为此，您可以在任务类上定义 `uniqueId` 和 `uniqueFor` 属性或方法：\r\n\r\n    <?php\r\n\r\n    use App\\Product;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\r\n\r\n    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\r\n    {\r\n        /**\r\n         * 产品实例。\r\n         *\r\n         * @var \\App\\Product\r\n         */\r\n        public $product;\r\n\r\n        /**\r\n         * 作业的唯一锁将被释放的秒数。\r\n         *\r\n         * @var int\r\n         */\r\n        public $uniqueFor = 3600;\r\n\r\n        /**\r\n         * 任务的唯一 ID。\r\n         *\r\n         * @return string\r\n         */\r\n        public function uniqueId()\r\n        {\r\n            return $this->product->id;\r\n        }\r\n    }\r\n\r\n\r\n\r\n在上面的示例中， `UpdateSearchIndex` 任务中的 product ID 是唯一的。因此，在现有任务完成处理之前，任何具有相同 product ID 的任务都将被忽略。此外，如果现有任务在一小时内没有得到处理，则释放唯一锁，并将具有相同唯一键的另一个任务分派到该队列。\r\n\r\n<a name=\"keeping-jobs-unique-until-processing-begins\"></a>\r\n#### 在任务处理开始前保证唯一\r\n\r\n默认情况下，在任务完成处理或所有重试尝试均失败后，唯一任务将被「解锁」。但是，在某些情况下，您可能希望任务在处理之前立即解锁。为此，您的任务类可以实现  `ShouldBeUniqueUntilProcessing`  接口，而不是实现 `ShouldBeUnique` 接口：\r\n\r\n    <?php\r\n\r\n    use App\\Product;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Contracts\\Queue\\ShouldBeUniqueUntilProcessing;\r\n\r\n    class UpdateSearchIndex implements ShouldQueue, ShouldBeUniqueUntilProcessing\r\n    {\r\n        // ...\r\n    }\r\n\r\n<a name=\"unique-job-locks\"></a>\r\n#### 唯一任务锁\r\n\r\n在底层实现中，当分发 `ShouldBeUnique` 任务时，Laravel 尝试使用`uniqueId` 键获取一个   [锁](/docs/laravel/9.x/cache#atomic-locks) 。如果未获取到锁，则不会分派任务。当任务完成处理或所有重试尝试失败时，将释放此锁。默认情况下，Laravel 将使用默认的缓存驱动程序来获取此锁。但是，如果您希望使用其他驱动程序来获取锁，则可以定义一个 `uniqueVia` 方法，该方法返回一个缓存驱动对象：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\r\n    {\r\n        ...\r\n\r\n        /**\r\n         * 获取唯一任务锁的缓存驱动程序。\r\n         *\r\n         * @return \\Illuminate\\Contracts\\Cache\\Repository\r\n         */\r\n        public function uniqueVia()\r\n        {\r\n            return Cache::driver('redis');\r\n        }\r\n    }\r\n\r\n> 技巧：如果只需要限制任务的并发处理，请改用 [`WithoutOverlapping`](/docs/laravel/9.x/queues#preventing-job-overlaps) 任务中间件。\r\n\r\n\r\n\r\n<a name=\"job-middleware\"></a>\r\n## 任务中间件\r\n\r\n任务中间件允许你围绕排队任务的执行封装自定义逻辑，从而减少了任务本身的样板代码。例如，看下面的  `handle` 方法，它利用了 Laravel 的 Redis 速率限制特性，允许每 5 秒只处理一个任务：\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    /**\r\n     * 执行任务\r\n     *\r\n     * @return void\r\n     */\r\n    public function handle()\r\n    {\r\n        Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {\r\n            info('取得了锁...');\r\n\r\n            // 处理任务...\r\n        }, function () {\r\n            // 无法获取锁...\r\n\r\n            return $this->release(5);\r\n        });\r\n    }\r\n\r\n虽然这段代码是有效的， 但是 `handle` 方法的结构却变得杂乱，因为它掺杂了 Redis 速率限制逻辑。此外，其他任务需要使用速率限制的时候，只能将限制逻辑复制一次。\r\n\r\n我们可以定义一个处理速率限制的任务中间件，而不是在 handle 方法中定义速率限制。Laravel 没有任务中间件的默认位置，所以你可以将任务中间件放置在你喜欢的任何位置。在本例中，我们将把中间件放在  `app/Jobs/Middleware`  目录：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs\\Middleware;\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    class RateLimited\r\n    {\r\n        /**\r\n         * 处理队列任务\r\n         *\r\n         * @param  mixed  $job\r\n         * @param  callable  $next\r\n         * @return mixed\r\n         */\r\n        public function handle($job, $next)\r\n        {\r\n            Redis::throttle('key')\r\n                    ->block(0)->allow(1)->every(5)\r\n                    ->then(function () use ($job, $next) {\r\n                        // 获得了锁\r\n\r\n                        $next($job);\r\n                    }, function () use ($job) {\r\n                        // 没有获取到锁\r\n\r\n                        $job->release(5);\r\n                    });\r\n        }\r\n    }\r\n\r\n正如你看到的，类似于 [路由中间件](/docs/laravel/9.x/middleware)，任务中间件接收正在处理队列任务以及一个回调来继续处理队列任务。\r\n\r\n\r\n\r\n在任务中间件被创建以后，他们可能被关联到通过从任务的 `middleware`方法返回的任务。这个方法并不存在于 `make:job`  Artisan 命令搭建的任务中，所以你需要将它添加到你自己的任务类的定义中：\r\n\r\n    use App\\Jobs\\Middleware\\RateLimited;\r\n\r\n    /**\r\n     * 获取一个可以被传递通过的中间件任务。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [new RateLimited];\r\n    }\r\n\r\n> 技巧：任务中间件也可以分配其他可队列处理的监听事件当中，比如邮件，通知等。\r\n\r\n<a name=\"rate-limiting\"></a>\r\n### 访问限制\r\n\r\n尽管我们刚刚演示了如何编写自己的访问限制的任务中间件，但 Laravel 实际上内置了一个访问限制中间件，你可以利用它来限制任务。与 [路由限流器](/docs/laravel/9.x/routing#defining-rate-limiters)一样，任务访问限制器是使用 `RateLimiter` facade 的 `for` 方法定义的。\r\n\r\n例如，你可能希望允许用户每小时备份一次数据，但不对高级客户施加此类限制。为此，可以在 `RateLimiter`的 `boot` 方法中定义  `AppServiceProvider`：\r\n\r\n    use Illuminate\\Cache\\RateLimiting\\Limit;\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    /**\r\n     * 注册应用程序服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        RateLimiter::for('backups', function ($job) {\r\n            return $job->user->vipCustomer()\r\n                        ? Limit::none()\r\n                        : Limit::perHour(1)->by($job->user->id);\r\n        });\r\n    }\r\n\r\n在上面的例子中，我们定义了一个小时访问限制；但是，你可以使用 `perMinute` 方法轻松定义基于分钟的访问限制。此外，您可以将任何值传递给访问限制的  `by` 方法，但是，这个值通常用于按客户来区分不同的访问限制：\r\n\r\n    return Limit::perMinute(50)->by($job->user->id);\r\n\r\n\r\n\r\n定义速率限制后，您可以使用 Illuminate\\Queue\\Middleware\\RateLimited 中间件将速率限制器附加到备份任务。 每次任务超过速率限制时，此中间件都会根据速率限制持续时间以适当的延迟将任务 释放回队列。\r\n\r\n    use Illuminate\\Queue\\Middleware\\RateLimited;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [new RateLimited('backups')];\r\n    }\r\n\r\n将速率受限的任务释放回队列仍然会增加任务的“尝试”总数。您可能希望相应地调整您的任务类上的 `tries` 和 `maxExceptions` 属性。或者，您可能希望使用 [`retryUntil` 方法](#time-based-attempts) 来定义不再尝试任务之前的时间量。\r\n\r\n如果您不想在速率限制时重试任务，您可以使用 `dontRelease` 方法：\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [(new RateLimited('backups'))->dontRelease()];\r\n    }\r\n\r\n> 技巧：如果你使用 Redis，你可以使用 Illuminate\\Queue\\Middleware\\RateLimitedWithRedis 中间件，它针对 Redis 进行了微调，比基本的限速中间件更高效。\r\n\r\n<a name=\"preventing-job-overlaps\"></a>\r\n### 防止任务重叠\r\n\r\nLaravel 包含一个 `Illuminate\\Queue\\Middleware\\WithoutOverlapping` 中间件，允许您根据任意键防止任务重叠。当排队的任务正在修改一次只能由一个任务修改的资源时，这会很有帮助。\r\n\r\n例如，假设您有一个更新用户信用评分的排队任务，并且您希望防止同一用户 ID 的信用评分更新任务 重叠。为此，您可以从任务的 `middleware` 方法返回 `WithoutOverlapping` 中间件：\r\n\r\n    use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [new WithoutOverlapping($this->user->id)];\r\n    }\r\n\r\n\r\n\r\n任何重叠的任务都将被释放回队列。您还可以指定再次尝试释放的任务之前必须经过的秒数：\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];\r\n    }\r\n\r\n如果您希望立即删除任何重叠的任务以便它们不会被重试，您可以使用 `dontRelease` 方法：\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [(new WithoutOverlapping($this->order->id))->dontRelease()];\r\n    }\r\n\r\n`WithoutOverlapping` 中间件由 Laravel 的原子锁特性提供支持。有时，您的任务可能会以未释放锁的方式意外失败或超时。因此，您可以使用 `expireAfter` 方法显式定义锁定过期时间。例如，下面的示例将指示 Laravel 在任务开始处理三分钟后释放 `WithoutOverlapping` 锁：\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];\r\n    }\r\n\r\n> 注意：`WithoutOverlapping` 中间件需要支持 [locks](/docs/laravel/9.x/cache#atomic-locks) 的缓存驱动程序。 目前，`memcached`、`redis`、`dynamodb`、`database`、`file`和`array`缓存驱动支持原子锁。\r\n\r\n<a name=\"throttling-exceptions\"></a>\r\n### 限制异常\r\n\r\nLaravel 包含一个 `Illuminate\\Queue\\Middleware\\ThrottlesExceptions` 中间件，允许您限制异常。一旦任务抛出给定数量的异常，所有进一步执行该任务的尝试都会延迟，直到经过指定的时间间隔。该中间件对于与不稳定的第三方服务交互的任务特别有用。\r\n\r\n\r\n\r\n例如，让我们想象一个队列任务与开始抛出异常的第三方 API 交互。要限制异常，您可以从任务的 `middleware` 方法返回 `ThrottlesExceptions` 中间件。通常，此中间件应与实现 [基于时间的尝试](#time-based-attempts) 的任务配对：\r\n\r\n    use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [new ThrottlesExceptions(10, 5)];\r\n    }\r\n\r\n    /**\r\n     * 确定任务应该超时的时间。\r\n     *\r\n     * @return \\DateTime\r\n     */\r\n    public function retryUntil()\r\n    {\r\n        return now()->addMinutes(5);\r\n    }\r\n\r\n中间件接受的第一个构造函数参数是任务在被限制之前可以抛出的异常数，而第二个构造函数参数是在任务被限制后再次尝试之前应该经过的分钟数。在上面的代码示例中，如果任务在 5 分钟内抛出 10 个异常，我们将等待 5 分钟，然后再次尝试该任务。\r\n\r\n当任务抛出异常但尚未达到异常阈值时，通常会立即重试该任务。但是，您可以通过在将中间件附加到任务时调用 `backoff` 方法来指定此类任务应延迟的分钟数：\r\n\r\n    use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [(new ThrottlesExceptions(10, 5))->backoff(5)];\r\n    }\r\n\r\n在内部，这个中间件使用 Laravel 的缓存系统来实现速率限制，并利用任务的类名作为缓存“键”。 在将中间件附加到任务时，您可以通过调用 `by` 方法来覆盖此键。 如果您有多个任务与同一个第三方服务交互并且您希望它们共享一个共同的节流“桶”，这可能会很有用：\r\n\r\n    use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array\r\n     */\r\n    public function middleware()\r\n    {\r\n        return [(new ThrottlesExceptions(10, 10))->by('key')];\r\n    }\r\n\r\n> 技巧：如果你使用 Redis，你可以使用 Illuminate\\Queue\\Middleware\\ThrottlesExceptionsWithRedis 中间件，它针对 Redis 进行了微调，比基本的异常节流中间件更高效。\r\n\r\n\r\n\r\n<a name=\"dispatching-jobs\"></a>\r\n## 调度任务\r\n\r\n一旦你写好了你的任务类，你可以使用任务本身的`dispatch`方法来调度它。传递给 `dispatch` 方法的参数将被提供给任务的构造函数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个新的播客。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $podcast = Podcast::create(...);\r\n\r\n            // ...\r\n\r\n            ProcessPodcast::dispatch($podcast);\r\n        }\r\n    }\r\n\r\n如果您想有条件地分派任务，您可以使用 `dispatchIf` 和 `dispatchUnless` 方法：\r\n\r\n    ProcessPodcast::dispatchIf($accountActive, $podcast);\r\n\r\n    ProcessPodcast::dispatchUnless($accountSuspended, $podcast);\r\n\r\n<a name=\"delayed-dispatching\"></a>\r\n### 延迟调度\r\n\r\n如果您想指定任务不应立即可供队列工作人员处理，您可以在调度任务时使用“延迟”方法。例如，让我们指定一个任务在分派后 10 分钟内不能用于处理：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个新的播客。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $podcast = Podcast::create(...);\r\n\r\n            // ...\r\n\r\n            ProcessPodcast::dispatch($podcast)\r\n                        ->delay(now()->addMinutes(10));\r\n        }\r\n    }\r\n\r\n> 注意：Amazon SQS 队列服务的最大延迟时间为 15 分钟。\r\n\r\n<a name=\"dispatching-after-the-response-is-sent-to-browser\"></a>\r\n#### 响应发送到浏览器后调度\r\n\r\n或者，`dispatchAfterResponse` 方法延迟调度任务，直到 HTTP 响应发送到用户的浏览器之后。 即使排队的任务仍在执行，这仍将允许用户开始使用应用程序。这通常应该只用于需要大约一秒钟的工作，例如发送电子邮件。由于它们是在当前 HTTP 请求中处理的，因此以这种方式分派的任务不需要运行队列工作者来处理它们：\r\n    use App\\Jobs\\SendNotification;\r\n\r\n    SendNotification::dispatchAfterResponse();\r\n\r\n\r\n\r\n你也可以`dispatch`一个闭包并将`afterResponse`方法链接到`dispatch`帮助器以在HTTP响应发送到浏览器后执行一个闭包：\r\n\r\n    use App\\Mail\\WelcomeMessage;\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n\r\n    dispatch(function () {\r\n        Mail::to('taylor@example.com')->send(new WelcomeMessage);\r\n    })->afterResponse();\r\n\r\n<a name=\"synchronous-dispatching\"></a>\r\n### 同步调度\r\n\r\n如果您想立即（同步）调度任务，您可以使用 `dispatchSync` 方法。使用此方法时，任务不会排队，会在当前进程内立即执行：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个新的播客。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $podcast = Podcast::create(...);\r\n\r\n            // Create podcast...\r\n\r\n            ProcessPodcast::dispatchSync($podcast);\r\n        }\r\n    }\r\n\r\n<a name=\"jobs-and-database-transactions\"></a>\r\n### 任务 & 数据库事务\r\n\r\n虽然在数据库事务中分派任务非常好，但您应该特别注意确保您的任务实际上能够成功执行。在事务中调度任务时，任务可能会在父事务提交之前由工作人员处理。发生这种情况时，您在数据库事务期间对模型或数据库记录所做的任何更新可能尚未反映在数据库中。此外，在事务中创建的任何模型或数据库记录可能不存在于数据库中。\r\n\r\n值得庆幸的是，Laravel 提供了几种解决这个问题的方法。首先，您可以在队列连接的配置数组中设置 `after_commit` 连接选项：\r\n\r\n    'redis' => [\r\n        'driver' => 'redis',\r\n        // ...\r\n        'after_commit' => true,\r\n    ],\r\n\r\n\r\n\r\n当 `after_commit` 选项为 `true` 时，你可以在数据库事务中分发任务；Laravel 会等到所有打开的数据库事务都已提交，然后才会开始分发任务。当然，如果当前没有打开的数据库事务，任务将被立即分发。\r\n\r\n如果事务因事务期间发生异常而回滚，则在该事务期间分发的已分发任务将被丢弃。\r\n\r\n> 技巧：将 `after_commit` 配置选项设置为 `true` 还会导致所有排队的事件监听器、邮件、通知和广播事件在所有打开的数据库事务提交后才被调度。\r\n\r\n<a name=\"specifying-commit-dispatch-behavior-inline\"></a>\r\n#### 内联指定提交调度\r\n\r\n如果你没有将 `after_commit` 队列连接配置选项设置为 `true`，你可能需要在所有打开的数据库事务提交后才调度特定的任务。为此，你可以将 `afterCommit` 方法放到你的调度操作上：\r\n\r\n    use App\\Jobs\\ProcessPodcast;\r\n\r\n    ProcessPodcast::dispatch($podcast)->afterCommit();\r\n\r\n同样，如果 `after_commit` 配置选项设置为 `true`，则可以指示应立即调度特定作业，而无需等待任何打开的数据库事务提交：\r\n\r\n    ProcessPodcast::dispatch($podcast)->beforeCommit();\r\n\r\n<a name=\"job-chaining\"></a>\r\n### 任务链\r\n\r\n任务链允许您指定一组应在主任务成功执行后按顺序运行的排队任务。如果序列中的一个任务失败，其余的任务将不会运行。要执行一个排队的任务链，你可以使用 `Bus` facade 提供的 `chain` 方法：\r\n\r\n    use App\\Jobs\\OptimizePodcast;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Jobs\\ReleasePodcast;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n\r\n    Bus::chain([\r\n        new ProcessPodcast,\r\n        new OptimizePodcast,\r\n        new ReleasePodcast,\r\n    ])->dispatch();\r\n\r\n\r\n\r\n除了链接任务类实例之外，您还可以链接闭包：\r\n\r\n    Bus::chain([\r\n        new ProcessPodcast,\r\n        new OptimizePodcast,\r\n        function () {\r\n            Podcast::update(...);\r\n        },\r\n    ])->dispatch();\r\n\r\n> 注意：在任务中使用 `$this->delete()` 方法删除任务不会阻止链式任务的处理。只有当链中的任务失败时，链才会停止执行。\r\n\r\n<a name=\"chain-connection-queue\"></a>\r\n#### 链式连接 & 队列\r\n\r\n如果要指定链接任务应使用的连接和队列，可以使用 `onConnection` 和 `onQueue` 方法。这些方法指定应使用的队列连接和队列名称，除非为排队任务显式分配了不同的连接/队列：\r\n\r\n    Bus::chain([\r\n        new ProcessPodcast,\r\n        new OptimizePodcast,\r\n        new ReleasePodcast,\r\n    ])->onConnection('redis')->onQueue('podcasts')->dispatch();\r\n\r\n<a name=\"chain-failures\"></a>\r\n#### 链故障\r\n\r\n链接任务时，您可以使用 `catch` 方法指定一个闭包，如果链中的任务失败，则应调用该闭包。给定的回调将接收导致任务失败的 `Throwable` 实例：\r\n\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n    use Throwable;\r\n\r\n    Bus::chain([\r\n        new ProcessPodcast,\r\n        new OptimizePodcast,\r\n        new ReleasePodcast,\r\n    ])->catch(function (Throwable $e) {\r\n        // 链中的任务失败了...\r\n    })->dispatch();\r\n\r\n<a name=\"customizing-the-queue-and-connection\"></a>\r\n### 自定义队列 & 连接\r\n\r\n<a name=\"dispatching-to-a-particular-queue\"></a>\r\n#### 分派到特定队列\r\n\r\n通过将任务推送到不同的队列，您可以对排队的任务进行「分类」，甚至可以优先考虑分配给各个队列的工作人员数量。请记住，这不会将任务推送到队列配置文件定义的不同队列「连接」，而只会推送到单个连接中的特定队列。要指定队列，请在调度任务时使用 `onQueue` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个新的播客。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $podcast = Podcast::create(...);\r\n\r\n            // 创建播客...\r\n\r\n            ProcessPodcast::dispatch($podcast)->onQueue('processing');\r\n        }\r\n    }\r\n\r\n\r\n\r\n或者，您可以通过在任务的构造函数中调用 `onQueue` 方法来指定任务的队列：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n     use Illuminate\\Bus\\Queueable;\r\n     use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n     use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n     use Illuminate\\Queue\\InteractsWithQueue;\r\n     use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建一个新的任务实例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->onQueue('processing');\r\n        }\r\n    }\r\n\r\n<a name=\"dispatching-to-a-particular-connection\"></a>\r\n#### 调度到特定连接\r\n\r\n如果您的应用程序与多个队列连接交互，您可以使用 `onConnection` 方法指定将任务推送到哪个连接：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个新的播客。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            $podcast = Podcast::create(...);\r\n\r\n            // 创建播客...\r\n\r\n            ProcessPodcast::dispatch($podcast)->onConnection('sqs');\r\n        }\r\n    }\r\n\r\n您可以将 `onConnection` 和 `onQueue` 方法链接在一起，以指定任务的连接和队列：\r\n\r\n    ProcessPodcast::dispatch($podcast)\r\n                  ->onConnection('sqs')\r\n                  ->onQueue('processing');\r\n\r\n或者，您可以通过在任务的构造函数中调用 `onConnection` 方法来指定任务的连接：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n     use Illuminate\\Bus\\Queueable;\r\n     use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n     use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n     use Illuminate\\Queue\\InteractsWithQueue;\r\n     use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建一个新的任务实例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->onConnection('sqs');\r\n        }\r\n    }\r\n\r\n<a name=\"max-job-attempts-and-timeout\"></a>\r\n### 指定最大任务尝试/超时值\r\n\r\n\r\n\r\n<a name=\"max-attempts\"></a>\r\n#### 最大尝试次数\r\n\r\n如果你的一个队列任务遇到了错误，你可能不希望无限制的重试。因此 Laravel 提供了各种方法来指定一个任务可以尝试多少次或多长时间。\r\n\r\n指定任务可尝试的最大次数的其中一个方法是，通过 Artisan 命令行上的 `--tries` 开关。这将适用于调度作业的所有任务，除非正在处理的任务指定了最大尝试次数。\r\n\r\n```shell\r\nphp artisan queue:work --tries=3\r\n```\r\n\r\n如果一个任务超过其最大尝试次数，将被视为「失败」的任务。有关处理失败任务的更多信息，可以参考 [处理失败队列](#dealing-with-failed-jobs)。\r\n\r\n你可以采取更细化的方法来定义任务类本身的最大尝试次数。如果在任务上指定了最大尝试次数，它将优先于命令行上提供的 `--tries` 开关设定的值：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        /**\r\n         * 任务可尝试次数.\r\n         *\r\n         * @var int\r\n         */\r\n        public $tries = 5;\r\n    }\r\n\r\n<a name=\"time-based-attempts\"></a>\r\n#### 基于时间的尝试\r\n\r\n除了定义任务失败前尝试的次数之外，还可以定义任务应该超时的时间。这允许在给定的时间范围内尝试任意次数的任务。要定义任务超时的时间，请在任务类中添加 `retryUntil` 方法。这个方法应返回一个  `DateTime` 实例：\r\n\r\n    /**\r\n     * Determine the time at which the job should timeout.\r\n     *\r\n     * @return \\DateTime\r\n     */\r\n    public function retryUntil()\r\n    {\r\n        return now()->addMinutes(10);\r\n    }\r\n\r\n> 技巧：你也可以在 [队列事件监听器](/docs/laravel/9.x/events#queued-event-listeners) 上定义一个 `tries` 属性或 `retryUntil` 方法。\r\n\r\n\r\n\r\n<a name=\"max-exceptions\"></a>\r\n#### 最大尝试\r\n\r\n有时您可能希望指定一个任务可能会尝试多次，但如果重试由给定数量的未处理异常触发（而不是直接由 `release` 方法释放），则应该失败。为此，您可以在任务类上定义一个 `maxExceptions` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        /**\r\n         * 可以尝试任务的次数。\r\n         *\r\n         * @var int\r\n         */\r\n        public $tries = 25;\r\n\r\n        /**\r\n         * 失败前允许的最大未处理异常数。\r\n         *\r\n         * @var int\r\n         */\r\n        public $maxExceptions = 3;\r\n\r\n        /**\r\n         * Execute the job.\r\n         *\r\n         * @return void\r\n         */\r\n        public function handle()\r\n        {\r\n            Redis::throttle('key')->allow(10)->every(60)->then(function () {\r\n                // 获得锁，处理播客...\r\n            }, function () {\r\n                // 无法获取锁...\r\n                return $this->release(10);\r\n            });\r\n        }\r\n    }\r\n\r\n在此示例中，如果应用程序无法获得 Redis 锁，则该任务将在 10 秒后被释放，并将继续重试最多 25 次。但是，如果任务抛出三个未处理的异常，则任务将失败。\r\n\r\n<a name=\"timeout\"></a>\r\n#### 超时\r\n\r\n> 注意：必须安装 `pcntl` PHP 扩展以指定任务超时。\r\n\r\n通常，您大致知道您预计排队的任务需要多长时间。出于这个原因，Laravel 允许你指定一个「超时」值。 如果任务的处理时间超过超时值指定的秒数，则处理该任务的任务进程将退出并出现错误。 通常，任务程序将由[在您的服务器上配置的进程管理器](#supervisor-configuration \"在您的服务器上配置的进程管理器\")自动重新启动。\r\n\r\n\r\n\r\n同样，任务可以运行的最大秒数可以使用 Artisan 命令行上的 `--timeout` 开关来指定：\r\n\r\n```shell\r\nphp artisan queue:work --timeout=30\r\n```\r\n\r\n如果任务因不断超时而超过其最大尝试次数，则它将被标记为失败。\r\n\r\n你也可以定义允许任务在任务类本身上运行的最大秒数。如果在任务上指定了超时，它将优先于在命令行上指定的任何超时:\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        /**\r\n         * 在超时之前任务可以运行的秒数.\r\n         *\r\n         * @var int\r\n         */\r\n        public $timeout = 120;\r\n    }\r\n\r\n有些时候，诸如 socket 或在 HTTP 连接之类的 IO 阻止进程可能不会遵守你指定的超时。因此，在使用这些功能时，也应始终尝试使用其 API 指定超时。例如，在使用 Guzzle 时，应始终指定连接并请求的超时时间。\r\n\r\n<a name=\"failing-on-timeout\"></a>\r\n#### 超时失败\r\n\r\n如果您希望在超时时将任务标记为 [failed](#dealing-with-failed-jobs)，可以在任务类上定义 `$failOnTimeout` 属性：\r\n\r\n```php\r\n/**\r\n * 标示是否应在超时时标记为失败.\r\n *\r\n * @var bool\r\n */\r\npublic $failOnTimeout = true;\r\n```\r\n\r\n<a name=\"error-handling\"></a>\r\n### 错误处理\r\n\r\n如果在处理任务时抛出异常，任务将自动释放回队列，以便再次尝试。 任务将继续发布，直到尝试达到你的应用程序允许的最大次数为止。最大尝试次数由 `queue:work` Artisan 命令中使用的 `--tries` 开关定义。或者，可以在任务类本身上定义最大尝试次数。有关运行队列处理器的更多信息 [可以在下面找到](#running-the-queue-worker)。\r\n\r\n\r\n\r\n<a name=\"manually-releasing-a-job\"></a>\r\n#### 手动发布\r\n\r\n有时你可能希望手动将任务发布回队列，以便稍后再次尝试。你可以通过调用 `release` 方法来完成此操作：\r\n\r\n    /**\r\n     * 执行任务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function handle()\r\n    {\r\n        // ...\r\n\r\n        $this->release();\r\n    }\r\n\r\n默认情况下，`release` 方法会将任务发布回队列以供立即处理。但是，通过向 `release` 方法传递一个整数，你可以指示队列在给定的秒数过去之前不使任务可用于处理：\r\n\r\n    $this->release(10);\r\n\r\n<a name=\"manually-failing-a-job\"></a>\r\n#### 手动使任务失败\r\n\r\n有时，你可能需要手动将任务标记为 「failed」。为此，您可以调用 fail 方法：\r\n\r\n    /**\r\n     * 执行任务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function handle()\r\n    {\r\n        // ...\r\n\r\n        $this->fail();\r\n    }\r\n\r\n如果你想将你的任务标记为由于你捕获的异常而失败，你可以将异常传递给 fail 方法：\r\n\r\n    $this->fail($exception);\r\n\r\n> 技巧：有关失败任务的更多信息，请查看 [处理任务失败的文档](#dealing-with-failed-jobs).\r\n\r\n<a name=\"job-batching\"></a>\r\n## 任务批处理\r\n\r\nLaravel 的任务批处理功能允许你轻松地执行一批任务，然后在这批任务执行完毕后执行一些操作。 在开始之前，你应该创建一个数据库迁移来构建一个表来包含有关你的任务批次的元信息，例如它们的完成百分比。这个迁移可以使用 `queue:batches-table` Artisan 命令生成：\r\n\r\n```shell\r\nphp artisan queue:batches-table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n\r\n\r\n<a name=\"defining-batchable-jobs\"></a>\r\n### 定义可批处理任务\r\n\r\n要定义可批处理任务，您应该像往常一样[创建可排队任务](#creating-jobs)；但是，您应该将 `Illuminate\\Bus\\Batchable` 特征添加到任务类中。此 trait 提供了对 `batch` 方法的访问，该方法可用于检索任务正在其中执行的当前批处理：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use Illuminate\\Bus\\Batchable;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ImportCsv implements ShouldQueue\r\n    {\r\n        use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 执行任务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function handle()\r\n        {\r\n            if ($this->batch()->cancelled()) {\r\n                // 确定批次是否已取消...\r\n\r\n                return;\r\n            }\r\n\r\n            // 导入 CSV 文件的一部分...\r\n        }\r\n    }\r\n\r\n<a name=\"dispatching-batches\"></a>\r\n### 调度批次\r\n\r\n要调度一批任务，您应该使用 `Bus` 门面的 `batch` 方法。 当然，与完成回调结合使用时，批处理主要是有用的。因此，您可以使用 `then`、`catch` 和 `finally` 方法来定义批处理的完成回调。这些回调中的每一个在调用时都会收到一个 `Illuminate\\Bus\\Batch` 实例。在此示例中，我们将假设我们正在排队一批任务，每个任务处理 CSV 文件中给定数量的行：\r\n\r\n    use App\\Jobs\\ImportCsv;\r\n    use Illuminate\\Bus\\Batch;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n    use Throwable;\r\n\r\n    $batch = Bus::batch([\r\n        new ImportCsv(1, 100),\r\n        new ImportCsv(101, 200),\r\n        new ImportCsv(201, 300),\r\n        new ImportCsv(301, 400),\r\n        new ImportCsv(401, 500),\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务均已成功完成...\r\n    })->catch(function (Batch $batch, Throwable $e) {\r\n        // 检测到第一批任务失败...\r\n    })->finally(function (Batch $batch) {\r\n        // 批处理已完成执行...\r\n    })->dispatch();\r\n\r\n    return $batch->id;\r\n\r\n\r\n\r\n批次的 ID，可以通过 `$batch->id` 属性访问，可用于 [查询 Laravel 命令总线](#inspecting-batches) 以获取有关批次已分派后的信息。\r\n\r\n> 注意：由于批处理回调是由 Laravel 队列序列化并在稍后执行的，因此您不应在回调中使用 `$this` 变量。\r\n\r\n<a name=\"naming-batches\"></a>\r\n#### 命名批次\r\n\r\nLaravel Horizon 和 Laravel Telescope 等工具如果命名了批次，可能会为批次提供更用户友好的调试信息。要为批处理分配任意名称，您可以在定义批处理时调用 `name` 方法：\r\n\r\n    $batch = Bus::batch([\r\n        // ...\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务均已成功完成...\r\n    })->name('Import CSV')->dispatch();\r\n\r\n<a name=\"batch-connection-queue\"></a>\r\n#### 批量连接 & 队列\r\n\r\n如果您想指定应该用于批处理任务的连接和队列，您可以使用 `onConnection` 和 `onQueue` 方法。所有批处理任务必须在相同的连接和队列中执行：\r\n\r\n    $batch = Bus::batch([\r\n        // ...\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务均已成功完成...\r\n    })->onConnection('redis')->onQueue('imports')->dispatch();\r\n\r\n<a name=\"chains-within-batches\"></a>\r\n#### 批内链接\r\n\r\n您可以通过将链接的任务放置在数组中来在批处理中定义一组 [链接的任务](#job-chaining)。例如，我们可以并行执行两个任务链，并在两个任务链都完成处理后执行回调：\r\n\r\n    use App\\Jobs\\ReleasePodcast;\r\n    use App\\Jobs\\SendPodcastReleaseNotification;\r\n    use Illuminate\\Bus\\Batch;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n\r\n    Bus::batch([\r\n        [\r\n            new ReleasePodcast(1),\r\n            new SendPodcastReleaseNotification(1),\r\n        ],\r\n        [\r\n            new ReleasePodcast(2),\r\n            new SendPodcastReleaseNotification(2),\r\n        ],\r\n    ])->then(function (Batch $batch) {\r\n        // ...\r\n    })->dispatch();\r\n\r\n\r\n\r\n<a name=\"adding-jobs-to-batches\"></a>\r\n### 批量添加任务\r\n\r\n有些时候，批量向批处理中添加任务可能很有用。当你需要批量处理数千个任务时，这种模式非常好用，而这些任务在 Web 请求期间可能需要很长时间才能调度。因此，你可能希望调度初始批次的「加载器」任务，这些任务与更多任务相结合：\r\n\r\n    $batch = Bus::batch([\r\n        new LoadImportBatch,\r\n        new LoadImportBatch,\r\n        new LoadImportBatch,\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务都成功完成... \r\n    })->name('Import Contacts')->dispatch();\r\n\r\n在这个例子中，我们将使用 `LoadImportBatch` 实例为批处理添加其他任务。为了实现这个功能，我们可以对批处理实例使用 `add` 方法，该方法可以通过 `batch` 实例访问：\r\n\r\n    use App\\Jobs\\ImportContacts;\r\n    use Illuminate\\Support\\Collection;\r\n\r\n    /**\r\n     * 执行任务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function handle()\r\n    {\r\n        if ($this->batch()->cancelled()) {\r\n            return;\r\n        }\r\n\r\n        $this->batch()->add(Collection::times(1000, function () {\r\n            return new ImportContacts;\r\n        }));\r\n    }\r\n\r\n> 注意：你只能将任务添加到当前任务所属的批处理中。\r\n\r\n<a name=\"inspecting-batches\"></a>\r\n### 校验批处理\r\n\r\n为批处理完成后提供回调的 `Illuminate\\Bus\\Batch` 实例中具有多种属性和方法，可以帮助您与指定的批处理业务进行交互和检查：\r\n\r\n    // 批处理的UUID...\r\n    $batch->id;\r\n\r\n    // 批处理的名称（如果已经设置的话）...\r\n    $batch->name;\r\n\r\n    // 分配给批处理的任务数量...\r\n    $batch->totalJobs;\r\n\r\n    // 队列还没处理的任务数量...\r\n    $batch->pendingJobs;\r\n\r\n    // 失败的任务数量...\r\n    $batch->failedJobs;\r\n\r\n    // 到目前为止已经处理的任务数量...\r\n    $batch->processedJobs();\r\n\r\n    // 批处理已经完成的百分比（0-100）...\r\n    $batch->progress();\r\n\r\n    // 批处理是否已经完成执行...\r\n    $batch->finished();\r\n\r\n    // 取消批处理的运行...\r\n    $batch->cancel();\r\n\r\n    // 批处理是否已经取消...\r\n    $batch->cancelled();\r\n\r\n\r\n\r\n<a name=\"returning-batches-from-routes\"></a>\r\n#### 从路由返回批次\r\n\r\n所有 Illuminate\\Bus\\Batch 实例都是 JSON 可序列化的，这意味着您可以直接从应用程序的一个路由返回它们，以检索包含有关批处理的信息的 JSON 有效负载，包括其完成进度。这样可以方便地在应用程序的 UI 中显示有关批处理完成进度的信息。\r\n\r\n要通过 ID 检索批次，您可以使用 `Bus` 外观的 `findBatch` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    Route::get('/batch/{batchId}', function (string $batchId) {\r\n        return Bus::findBatch($batchId);\r\n    });\r\n\r\n<a name=\"cancelling-batches\"></a>\r\n### 取消批次\r\n\r\n有时您可能需要取消给定批处理的执行。这可以通过调用 `Illuminate\\Bus\\Batch` 实例的 `cancel` 方法来完成：\r\n\r\n    /**\r\n     * 执行任务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function handle()\r\n    {\r\n        if ($this->user->exceedsImportLimit()) {\r\n            return $this->batch()->cancel();\r\n        }\r\n\r\n        if ($this->batch()->cancelled()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n正如您在前面的示例中可能已经注意到的那样，批处理任务通常应该检查批处理是否在其 `handle` 方法的开头被取消：\r\n\r\n    /**\r\n     * 执行任务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function handle()\r\n    {\r\n        if ($this->batch()->cancelled()) {\r\n            return;\r\n        }\r\n\r\n        // 继续处理...\r\n    }\r\n\r\n<a name=\"batch-failures\"></a>\r\n### 批处理失败\r\n\r\n当批处理任务失败时，将调用 `catch` 回调（如果已分配）。此回调仅针对批处理中失败的第一个任务调用。\r\n\r\n<a name=\"allowing-failures\"></a>\r\n#### 允许失败\r\n\r\n当批处理中的某个任务失败时，Laravel 会自动将该批处理标记为「已取消」。如果您愿意，您可以禁用此行为，以便任务失败不会自动将批处理标记为已取消。这可以通过在调度批处理时调用 `allowFailures` 方法来完成：\r\n\r\n    $batch = Bus::batch([\r\n        // ...\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务均已成功完成...\r\n    })->allowFailures()->dispatch();\r\n\r\n\r\n\r\n<a name=\"retrying-failed-batch-jobs\"></a>\r\n#### 重试失败的批处理任务\r\n\r\n为方便起见，Laravel 提供了一个 `queue:retry-batch` Artisan 命令，允许您轻松重试给定批次的所有失败任务。 `queue:retry-batch` 命令接受应该重试失败任务的批处理的 UUID：\r\n\r\n```shell\r\nphp artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5\r\n```\r\n\r\n<a name=\"pruning-batches\"></a>\r\n### 修剪批次\r\n\r\n如果不进行剪枝，`job_batches` 表可以非常快速地积累记录。为了缓解这种情况，您应该 [schedule](/docs/laravel/9.x/scheduling) `queue:prune-batches` Artisan 命令每天运行：\r\n\r\n    $schedule->command('queue:prune-batches')->daily();\r\n\r\n默认情况下，将修剪所有超过 24 小时的已完成批次。您可以在调用命令时使用 `hours` 选项来确定保留批处理数据的时间。例如，以下命令将删除 48 小时前完成的所有批次：\r\n\r\n    $schedule->command('queue:prune-batches --hours=48')->daily();\r\n\r\n有时，您的 `jobs_batches` 表可能会累积从未成功完成的批次的批次记录，例如任务失败且该任务从未成功重试的批次。 您可以使用 `unfinished` 选项指示 `queue:prune-batches` 命令修剪这些未完成的批处理记录：\r\n\r\n    $schedule->command('queue:prune-batches --hours=48 --unfinished=72')->daily();\r\n\r\n<a name=\"queueing-closures\"></a>\r\n## 队列闭包\r\n\r\n除了将任务类分派到队列之外，您还可以分派一个闭包。这对于需要在当前请求周期之外执行的快速、简单的任务非常有用。当向队列分派闭包时，闭包的代码内容是加密签名的，因此它不能在传输过程中被修改：\r\n\r\n    $podcast = App\\Podcast::find(1);\r\n\r\n    dispatch(function () use ($podcast) {\r\n        $podcast->publish();\r\n    });\r\n\r\n\r\n\r\n使用 `catch` 方法，您可以提供一个闭包，如果队列中的闭包在耗尽所有队列的[配置重试尝试](#max-job-attempts-and-timeout)后未能成功完成，则应执行该闭包：\r\n\r\n    use Throwable;\r\n\r\n    dispatch(function () use ($podcast) {\r\n        $podcast->publish();\r\n    })->catch(function (Throwable $e) {\r\n        // 这份任务失败了……\r\n    });\r\n\r\n<a name=\"running-the-queue-worker\"></a>\r\n## 运行队列工作者\r\n\r\n<a name=\"the-queue-work-command\"></a>\r\n### `queue:work` 命令\r\n\r\nLaravel 包含一个 Artisan 命令，该命令将启动队列进程并在新任务被推送到队列时处理它们。 您可以使用 `queue:work` Artisan 命令运行任务进程。请注意，一旦 `queue:work` 命令启动，它将继续运行，直到手动停止或关闭终端：\r\n\r\n```shell\r\nphp artisan queue:work\r\n```\r\n\r\n> 技巧：要让 `queue:work` 进程在后台永久运行，您应该使用诸如 [Supervisor](#supervisor-configuration) 之类的进程监视器来确保队列进程不会停止运行。\r\n\r\n请记住，队列任务者是长期存在的进程，并将启动的应用程序状态存储在内存中。 因此，它们在启动后不会注意到您的代码库中的更改。 因此，在您的部署过程中，请务必[重新启动您的队列进程](#queue-workers-and-deployment)。 此外，请记住，您的应用进程创建或修改的任何静态状态都不会在任务之间自动重置。\r\n\r\n或者，您可以运行 `queue:listen` 命令。 使用 `queue:listen` 命令时，当您想要重新加载更新的代码或重置应用进程状态时，您不必手动重启 worker； 但是，此命令的效率明显低于 `queue:work` 命令：\r\n\r\n```shell\r\nphp artisan queue:listen\r\n```\r\n\r\n\r\n\r\n<a name=\"running-multiple-queue-workers\"></a>\r\n#### 运行多个队列进程\r\n\r\n要将多个进程分配给一个队列并同时处理任务，您应该简单地启动多个 `queue:work` 进程。这可以通过终端中的多个选项卡在本地完成，也可以使用流程管理器的配置设置在生产中完成。 [使用 Supervisor 时](#supervisor-configuration)，您可以使用 `numprocs` 配置值。\r\n\r\n<a name=\"specifying-the-connection-queue\"></a>\r\n#### 指定连接 & 队列\r\n\r\n您还可以指定进程应该使用哪个队列连接。 传递给 `work` 命令的连接名称应对应于 `config/queue.php` 配置文件中定义的连接之一：\r\n\r\n```shell\r\nphp artisan queue:work redis\r\n```\r\n\r\n默认情况下，`queue:work` 命令仅处理给定连接上默认队列的任务。但是，您可以通过仅处理给定连接的特定队列来进一步自定义队列工作程序。例如，如果您的所有电子邮件都在您的 `redis` 队列连接上的 `emails` 队列中处理，您可以发出以下命令来启动仅处理该队列的进程：\r\n\r\n```shell\r\nphp artisan queue:work redis --queue=emails\r\n```\r\n\r\n<a name=\"processing-a-specified-number-of-jobs\"></a>\r\n#### 处理指定数量的任务\r\n\r\n`--once` 选项可用于指定进程仅处理队列中的单个任务：\r\n\r\n```shell\r\nphp artisan queue:work --once\r\n```\r\n\r\n`--max-jobs` 选项可用于指示进程处理给定数量的作业，然后退出。当与 [Supervisor](#supervisor-configuration) 结合使用时，此选项可能很有用，以便您的进程在处理给定数量的作业后自动重新启动，释放他们可能积累的任何内存：\r\n\r\n```shell\r\nphp artisan queue:work --max-jobs=1000\r\n```\r\n\r\n\r\n\r\n<a name=\"processing-all-queued-jobs-then-exiting\"></a>\r\n#### 处理所有排队的任务然后退出\r\n\r\n`--stop-when-empty` 选项可用于指定进程处理所有作业，然后正常退出。如果您希望在队列为空后关闭容器，则此选项在处理 Docker 容器中的 Laravel 队列时很有用：\r\n\r\n```shell\r\nphp artisan queue:work --stop-when-empty\r\n```\r\n\r\n<a name=\"processing-jobs-for-a-given-number-of-seconds\"></a>\r\n#### 在给定的秒数内处理任务\r\n\r\n`--max-time` 选项可用于指示进程在给定的秒数内处理任务，然后退出。当与 [Supervisor](#supervisor-configuration) 结合使用时，此选项可能很有用，以便您的进程在处理给定时间的作业后自动重新启动，释放他们可能积累的任何内存：\r\n\r\n```shell\r\n# 处理进程一小时，然后退出...\r\nphp artisan queue:work --max-time=3600\r\n```\r\n\r\n<a name=\"worker-sleep-duration\"></a>\r\n#### 进程睡眠时间\r\n\r\n当队列中有任务可用时，进程将继续处理作业，而不会在它们之间产生延迟。但是，`sleep` 选项决定了如果没有可用的新任务，进程将 `sleep` 多少秒。 睡眠时，进程不会处理任何新的作业 - 任务将在进程再次唤醒后处理。\r\n\r\n```shell\r\nphp artisan queue:work --sleep=3\r\n```\r\n\r\n<a name=\"resource-considerations\"></a>\r\n#### 资源注意事项\r\n\r\n守护进程队列在处理每个任务之前不会 `reboot` 框架。因此，您应该在每个任务完成后释放所有繁重的资源。例如，如果您正在使用 GD 库进行图像处理，您应该在处理完图像后使用 `imagedestroy` 释放内存。\r\n\r\n\r\n\r\n<a name=\"queue-priorities\"></a>\r\n### 队列优先级\r\n\r\n有时您可能希望优先处理队列的处理方式。例如，在 `config/queue.php` 配置文件中，您可以将 `redis` 连接的默认 `queue` 设置为 `low`。 但是，有时您可能希望将作业推送到 `high` 优先级队列，如下所示：\r\n\r\n    dispatch((new Job)->onQueue('high'));\r\n\r\n要启动一个进程，在继续处理 `low` 队列上的任何任务之前验证所有 `high` 队列任务是否已处理，请将队列名称的逗号分隔列表传递给 `work` 命令：\r\n\r\n```shell\r\nphp artisan queue:work --queue=high,low\r\n```\r\n\r\n<a name=\"queue-workers-and-deployment\"></a>\r\n### 队列进程 & 部署\r\n\r\n由于队列任务是长期存在的进程，因此如果不重新启动，他们不会注意到代码的更改。因此，使用队列任务部署应用程序的最简单方法是在部署过程中重新启动任务。您可以通过发出 `queue:restart` 命令优雅地重新启动所有进程：\r\n\r\n```shell\r\nphp artisan queue:restart\r\n```\r\n\r\n此命令将指示所有队列进程在处理完当前任务后正常退出，以免丢失现有任务。由于队列任务将在执行 `queue:restart` 命令时退出，您应该运行诸如 [Supervisor](#supervisor-configuration) 之类的进程管理器来自动重新启动队列任务。\r\n\r\n> 技巧：队列使用 [cache](/docs/laravel/9.x/cache) 来存储重启信号，因此您应该在使用此功能之前验证是否为您的应用程序正确配置了缓存驱动程序。\r\n\r\n\r\n\r\n<a name=\"job-expirations-and-timeouts\"></a>\r\n### 任务到期 & 超时\r\n\r\n<a name=\"job-expiration\"></a>\r\n#### 任务到期\r\n\r\n在您的 `config/queue.php` 配置文件中，每个队列连接都定义了一个 `retry_after` 选项。此选项指定队列连接在重试正在处理的任务之前应等待的秒数。例如，如果 `retry_after` 的值设置为 `90`，如果任务已经处理了 90 秒而没有被释放或删除，它将被释放回队列中。 通常，您应该将 `retry_after` 值设置为您的任务应该合理地完成处理所需的最大秒数。\r\n\r\n> 注意：唯一不包含 `retry_after` 值的队列连接是 Amazon SQS。SQS 将根据在 AWS 控制台中管理的 [默认可见性超时](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html) 重试任务。\r\n\r\n<a name=\"worker-timeouts\"></a>\r\n#### 进程超时\r\n\r\n`queue:work` Artisan 命令公开了一个 `--timeout` 选项。 如果任务的处理时间超过超时值指定的秒数，则处理该任务的进程将退出并出现错误。 通常，工作程序将由[在您的服务器上配置的进程管理器](#supervisor-configuration)自动重新启动：\r\n\r\n```shell\r\nphp artisan queue:work --timeout=60\r\n```\r\n\r\n`retry_after` 配置选项和 `--timeout` CLI 选项是不同的，但它们协同工作以确保任务不会丢失并且任务仅成功处理一次。\r\n\r\n> 注意：`--timeout` 值应始终比 `retry_after` 配置值至少短几秒钟。 这将确保处理冻结任务的进程始终在重试任务之前终止。 如果你的 `--timeout` 选项比你的 `retry_after` 配置值长，你的任务可能会被处理两次。\r\n\r\n\r\n\r\n<a name=\"supervisor-configuration\"></a>\r\n## Supervisor 配置\r\n\r\n在生产中，您需要一种方法来保持 `queue:work` 进程运行。 `queue:work` 进程可能会因多种原因停止运行，例如超过 worker 超时或执行 `queue:restart` 命令。\r\n\r\n出于这个原因，您需要配置一个进程监视器，它可以检测您的 `queue:work` 进程何时退出并自动重新启动它们。此外，进程监视器可以让您指定要同时运行多少个 `queue:work` 进程。Supervisor 是 Linux 环境中常用的进程监视器，我们将在下面的文档中讨论如何配置它。\r\n\r\n<a name=\"installing-supervisor\"></a>\r\n#### 安装 Supervisor\r\n\r\nSupervisor 是 Linux 操作系统的进程监视器，如果它们失败，它将自动重新启动您的 `queue:work` 进程。要在 Ubuntu 上安装 Supervisor，您可以使用以下命令：\r\n\r\n```shell\r\nsudo apt-get install supervisor\r\n```\r\n\r\n> 技巧：如果您自己配置和管理 Supervisor 听起来很费力，请考虑使用 [Laravel Forge](https://forge.laravel.com)，它会自动为您的生产 Laravel 项目安装和配置 Supervisor。\r\n\r\n<a name=\"configuring-supervisor\"></a>\r\n#### 配置 Supervisor\r\n\r\nSupervisor 配置文件通常存储在 `/etc/supervisor/conf.d` 目录中。在这个目录中，你可以创建任意数量的配置文件来指示 Supervisor 应该如何监控你的进程。例如，让我们创建一个启动和监控 `queue:work` 进程的 `laravel-worker.conf` 文件：\r\n\r\n```ini\r\n[program:laravel-worker]\r\nprocess_name=%(program_name)s_%(process_num)02d\r\ncommand=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600\r\nautostart=true\r\nautorestart=true\r\nstopasgroup=true\r\nkillasgroup=true\r\nuser=forge\r\nnumprocs=8\r\nredirect_stderr=true\r\nstdout_logfile=/home/forge/app.com/worker.log\r\nstopwaitsecs=3600\r\n```\r\n\r\n\r\n\r\n在这个例子中，`numprocs` 指令将指示 Supervisor 运行 8 个 `queue:work` 进程并监控所有进程，如果它们失败则自动重新启动它们。您应该更改配置的「命令」指令以反映您所需的队列连接和工作选项。\r\n\r\n> 注意：您应该确保 `stopwaitsecs` 的值大于运行时间最长的作业所消耗的秒数。否则，Supervisor 可能会在作业完成处理之前将其终止。\r\n\r\n<a name=\"starting-supervisor\"></a>\r\n#### 开始 Supervisor\r\n\r\n创建配置文件后，您可以使用以下命令更新 Supervisor 配置并启动进程：\r\n\r\n```shell\r\nsudo supervisorctl reread\r\n\r\nsudo supervisorctl update\r\n\r\nsudo supervisorctl start laravel-worker:*\r\n```\r\n\r\n有关 Supervisor 的更多信息，请参阅 [Supervisor 文档](http://supervisord.org/index.html)。\r\n\r\n<a name=\"dealing-with-failed-jobs\"></a>\r\n## 处理失败的工作\r\n\r\n有时，您队列任务会失败。别担心，事情并不总是按计划进行！ Laravel 提供了一种方便的方法来 [指定应尝试任务的最大次数](#max-job-attempts-and-timeout)。在异步任务超过此尝试次数后，它将被插入到 `failed_jobs` 数据库表中。 [同步调度的任务](/docs/laravel/9.x/queues#synchronous-dispatching) 不存储在此表中，其异常由应用程序立即处理。\r\n\r\n创建 `failed_jobs` 表的迁移通常已经存在于新的 Laravel 应用程序中。但是，如果您的应用程序不包含此表的迁移，您可以使用 `queue:failed-table` 命令来创建迁移：\r\n\r\n```shell\r\nphp artisan queue:failed-table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n\r\n\r\n运行 [queue worker](#running-the-queue-worker) 进程时，您可以使用 `queue:work` 命令上的 `--tries` 开关指定任务应尝试的最大次数。如果您没有为 `--tries` 选项指定值，则作业将仅尝试一次或与任务类的 `$tries` 属性指定的次数相同：\r\n\r\n```shell\r\nphp artisan queue:work redis --tries=3\r\n```\r\n\r\n使用 `--backoff` 选项，你可以指定 Laravel 在重试遇到异常的任务之前应该等待多少秒。默认情况下，任务会立即释放回队列，以便可以再次尝试：\r\n\r\n```shell\r\nphp artisan queue:work redis --tries=3 --backoff=3\r\n```\r\n\r\n如果你想配置 Laravel 在重试每个任务遇到异常的任务之前应该等待多少秒，你可以通过在你的任务类上定义一个 `backoff` 属性来实现：\r\n\r\n    /**\r\n     * 重试任务前等待的秒数。\r\n     *\r\n     * @var int\r\n     */\r\n    public $backoff = 3;\r\n\r\n如果您需要更复杂的逻辑来确定任务的退避时间，您可以在您的任务类上定义一个 `backoff` 方法：\r\n\r\n    /**\r\n    * 计算重试任务之前要等待的秒数。\r\n    *\r\n    * @return int\r\n    */\r\n    public function backoff()\r\n    {\r\n        return 3;\r\n    }\r\n\r\n您可以通过从 `backoff` 方法返回一组退避值来轻松配置“exponential”退避。在此示例中，第一次重试的重试延迟为 1 秒，第二次重试为 5 秒，第三次重试为 10 秒：\r\n\r\n    /**\r\n    * 计算重试任务之前要等待的秒数。\r\n    *\r\n    * @return array\r\n    */\r\n    public function backoff()\r\n    {\r\n        return [1, 5, 10];\r\n    }\r\n\r\n\r\n\r\n<a name=\"cleaning-up-after-failed-jobs\"></a>\r\n### 任务失败后清理\r\n\r\n当特定任务失败时，您可能希望向用户发送警报或恢复该任务部分完成的任何操作。为此，您可以在任务类上定义一个 `failed` 方法。导致作业失败的 `Throwable` 实例将被传递给 `failed` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use App\\Models\\Podcast;\r\n    use App\\Services\\AudioProcessor;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n    use Throwable;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 播客实例.\r\n         *\r\n         * @var \\App\\Podcast\r\n         */\r\n        protected $podcast;\r\n\r\n        /**\r\n         *创建新任务实例\r\n         *\r\n         * @param  \\App\\Models\\Podcast  $podcast\r\n         * @return void\r\n         */\r\n        public function __construct(Podcast $podcast)\r\n        {\r\n            $this->podcast = $podcast;\r\n        }\r\n\r\n        /**\r\n         * 执行任务。\r\n         *\r\n         * @param  \\App\\Services\\AudioProcessor  $processor\r\n         * @return void\r\n         */\r\n        public function handle(AudioProcessor $processor)\r\n        {\r\n            // 处理上传的播客...\r\n        }\r\n\r\n        /**\r\n         * Handle a job failure.\r\n         *\r\n         * @param  \\Throwable  $exception\r\n         * @return void\r\n         */\r\n        public function failed(Throwable $exception)\r\n        {\r\n            // 向用户发送失败通知等...\r\n        }\r\n    }\r\n\r\n> 注意：在调用 `failed` 方法之前实例化任务的新实例；因此，在 `handle` 方法中可能发生的任何类属性修改都将丢失。\r\n\r\n<a name=\"retrying-failed-jobs\"></a>\r\n### 重试失败的任务\r\n\r\n要查看已插入到您的 `failed_jobs` 数据库表中的所有失败任务，您可以使用 `queue:failed` Artisan 命令：\r\n\r\n```shell\r\nphp artisan queue:failed\r\n```\r\n\r\n`queue:failed` 命令将列出任务 ID、连接、队列、失败时间和有关任务的其他信息。任务 ID 可用于重试失败的任务。例如，要重试 ID 为 `ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece` 的失败任务，请发出以下命令：\r\n\r\n```shell\r\nphp artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece\r\n```\r\n\r\n\r\n\r\n如有必要，可以向命令传递多个 ID:\r\n\r\n```shell\r\nphp artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c-34f94a33c24d\r\n```\r\n\r\n还可以重试指定队列的所有失败任务:\r\n\r\n```shell\r\nphp artisan queue:retry --queue=name\r\n```\r\n\r\n重试所有失败任务，可以执行 `queue:retry` 命令，并将 `all` 作为ID传递:\r\n\r\n```shell\r\nphp artisan queue:retry all\r\n```\r\n\r\n如果要删除指定的失败任务，可以使用 `queue:forget` 命令:\r\n\r\n```shell\r\nphp artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d\r\n```\r\n\r\n> 技巧：使用 [Horizon](/docs/laravel/9.x/Horizon \"Horizon\") 时，应该使用 `Horizon:forget` 命令来删除失败任务，而不是 `queue:forget` 命令。\r\n\r\n删除 `failed_jobs` 表中所有失败任务，可以使用 `queue:flush` 命令:\r\n\r\n```shell\r\nphp artisan queue:flush\r\n```\r\n\r\n<a name=\"ignoring-missing-models\"></a>\r\n### 忽略缺失的模型\r\n\r\n 向任务中注入 `Eloquent` 模型时，模型会在注入队列之前自动序列化，并在处理任务时从数据库中重新检索。但是，如果在任务等待消费时删除了模型，则任务可能会失败，抛出 `ModelNotFoundException` 异常。\r\n\r\n为方便起见，可以把将任务的 `deleteWhenMissingModels` 属性设置为 `true`，这样会自动删除缺少模型的任务。当此属性设置为 `true` 时，Laravel 会放弃该任务，并且不会引发异常：\r\n\r\n    /**\r\n     * 如果任务的模型不存在，则删除该任务。\r\n     *\r\n     * @var bool\r\n     */\r\n    public $deleteWhenMissingModels = true;\r\n\r\n\r\n\r\n<a name=\"pruning-failed-jobs\"></a>\r\n### 删除失败的任务\r\n\r\n您可以通过调用 `queue:prune-failed` Artisan 命令删除应用程序的 `failed_jobs` 表中的所有记录：\r\n\r\n```shell\r\nphp artisan queue:prune-failed\r\n```\r\n\r\n如果为命令提供 `--hours` 选项，则仅保留在过去 N 小时内插入的失败任务记录。例如，以下命令将删除超过 48 小时前插入的所有失败任务记录：\r\n\r\n```shell\r\nphp artisan queue:prune-failed --hours=48\r\n```\r\n\r\n<a name=\"storing-failed-jobs-in-dynamodb\"></a>\r\n### 在 DynamoDB 中存储失败的任务\r\n\r\nLaravel 还支持将失败的任务记录存储在 [DynamoDB](https://aws.amazon.com/dynamodb) 而不是关系数据库表中。但是，您必须创建一个 DynamoDB 表来存储所有失败的任务记录。通常，此表应命名为 `failed_jobs`，但您应根据应用程序的 `queue` 配置文件中的 `queue.failed.table` 配置值命名该表。\r\n\r\n`failed_jobs` 表应该有一个名为 `application` 的字符串主分区键和一个名为 `uuid` 的字符串主排序键。键的 `application` 部分将包含应用程序的名称，该名称由应用程序的 `app` 配置文件中的 `name` 配置值定义。由于应用程序名称是 DynamoDB 表键的一部分，因此您可以使用同一个表来存储多个 Laravel 应用程序的失败任务。\r\n\r\n此外，请确保您安装了 AWS 开发工具包，以便您的 Laravel 应用程序可以与 Amazon DynamoDB 通信：\r\n\r\n```shell\r\ncomposer require aws/aws-sdk-php\r\n```\r\n\r\n\r\n\r\n接下来，`queue.failed.driver` 配置选项的值设置为 `dynamodb`。此外，您应该在失败的作业配置数组中定义 `key`、`secret` 和 `region` 配置选项。 这些选项将用于向 AWS 进行身份验证。 当使用 `dynamodb` 驱动程序时，`queue.failed.database` 配置选项不是必须的：\r\n\r\n```php\r\n'failed' => [\r\n    'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),\r\n    'key' => env('AWS_ACCESS_KEY_ID'),\r\n    'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n    'table' => 'failed_jobs',\r\n],\r\n```\r\n\r\n<a name=\"disabling-failed-job-storage\"></a>\r\n### 禁用失败的任务存储\r\n\r\n您可以通过将 `queue.failed.driver` 配置选项的值设置为 `null` 来指示 Laravel 丢弃失败的任务而不存储它们。通过 `QUEUE_FAILED_DRIVER` 环境变量来完成：\r\n\r\n```ini\r\nQUEUE_FAILED_DRIVER=null\r\n```\r\n\r\n<a name=\"failed-job-events\"></a>\r\n### 失败的任务事件\r\n\r\n如果你想注册一个在作业失败时调用的事件监听器，你可以使用 `Queue` 门面的 `failing` 方法。例如，我们可以从 Laravel 中包含的 `AppServiceProvider` 的 `boot` 方法为这个事件附加一个闭包：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Illuminate\\Queue\\Events\\JobFailed;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Queue::failing(function (JobFailed $event) {\r\n                // $event->connectionName\r\n                // $event->job\r\n                // $event->exception\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"clearing-jobs-from-queues\"></a>\r\n## 从队列中清除任务\r\n\r\n> 技巧：使用 [Horizon](/docs/laravel/9.x/horizon) 时，应使用 `horizon:clear` 命令从队列中清除作业，而不是使用 `queue:clear` 命令。\r\n\r\n\r\n\r\n如果你想从默认连接的默认队列中删除所有任务，你可以使用 `queue:clear` Artisan 命令来执行此操作：\r\n\r\n```shell\r\nphp artisan queue:clear\r\n```\r\n\r\n你还可以提供 `connection` 参数和 `queue` 选项以从特定连接和队列中删除任务：\r\n\r\n```shell\r\nphp artisan queue:clear redis --queue=emails\r\n```\r\n\r\n> 注意：从队列中清除任务仅适用于 SQS、Redis 和数据库队列驱动程序。 此外，SQS 消息删除过程最多需要 60 秒，因此在你清除队列后 60 秒内发送到 SQS 队列的任务也可能会被删除。\r\n\r\n<a name=\"monitoring-your-queues\"></a>\r\n## 监控你的队列[新特性]\r\n\r\n如果你的队列突然涌入了大量的任务，它会导致队列任务繁重, 从而增加了任务的完成时间，想你所想， Laravel 可以在队列执行超过设定的阈值时候提醒你。\r\n\r\n在开始之前， 你需要通过 `queue:monitor` 命令配置它 [每分钟执行一次](/docs/laravel/9.x/scheduling)。这个命令可以设定任务的名称，以及你想要设定的任务阈值：\r\n\r\n```shell\r\nphp artisan queue:monitor redis:default,redis:deployments --max=100\r\n```\r\n\r\n当你的任务超过设定阈值时候，仅通过这个方法还不足以触发通知，此时会触发一个 `Illuminate\\Queue\\Events\\QueueBusy` 事件。你可以在你的应用 `EventServiceProvider` 来监听这个事件，从而将监听结果通知给你的开发团队：\r\n\r\n```php\r\nuse App\\Notifications\\QueueHasLongWaitTime;\r\nuse Illuminate\\Queue\\Events\\QueueBusy;\r\nuse Illuminate\\Support\\Facades\\Event;\r\nuse Illuminate\\Support\\Facades\\Notification;\r\n\r\n/**\r\n * 为你的应用程序注册其他更多事件\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Event::listen(function (QueueBusy $event) {\r\n        Notification::route('mail', 'dev@example.com')\r\n                ->notify(new QueueHasLongWaitTime(\r\n                    $event->connection,\r\n                    $event->queue,\r\n                    $event->size\r\n                ));\r\n    });\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"job-events\"></a>\r\n## 任务事件\r\n\r\n通过使用 `Queue` [facade](/docs/laravel/9.x/facades) 当中的 `before` 和 `after` 方法 , 你可以指定在处理排队任务之前或之后执行的回调。如果要为控制面板执行附加日志记录或者增量统计，这些回调会是最佳的机会。通常，你应该从 [服务提供者](/docs/laravel/9.x/providers) 的 `boot` 方法中调用，例如，我们可以使用 Laravel 的 `AppServiceProvider`服务:\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Illuminate\\Queue\\Events\\JobProcessed;\r\n    use Illuminate\\Queue\\Events\\JobProcessing;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册全局应用程序服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 启动全局应用程序服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Queue::before(function (JobProcessing $event) {\r\n                // $event->connectionName\r\n                // $event->job\r\n                // $event->job->payload()\r\n            });\r\n\r\n            Queue::after(function (JobProcessed $event) {\r\n                // $event->connectionName\r\n                // $event->job\r\n                // $event->job->payload()\r\n            });\r\n        }\r\n    }\r\n\r\n通过使用 `Queue` [facade](/docs/laravel/9.x/facades) 的  `looping` 方法 ，你可以在 worker 尝试从队列获取任务之前执行指定的回调。例如，你可以注册一个闭包，用以回滚之前失败任务打开的任何事务：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n\r\n    Queue::looping(function () {\r\n        while (DB::transactionLevel() > 0) {\r\n            DB::rollBack();\r\n        }\r\n    });\r\n\r\n","p":"docs/queues.html"},{"t":"rate-limiting (限流)","d":"\n# 限流\r\n\r\n- [介绍](#introduction)\r\n    - [缓存配置](#cache-configuration)\r\n- [基础用法](#basic-usage)\r\n    - [手动增加请求次数](#manually-incrementing-attempts)\r\n    - [清除请求](#clearing-attempts)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 包含了一个开箱即用的，基于缓存实现的限流器，提供了一个简单的方法来限制指定时间内的任何操作。\r\n\r\n> 技巧：了解更多关于如何限制 HTTP 请求，请参考 [请求频率限制中间件](https://learnku.com/docs/laravel/8.5/routing/10368#5c3711).\r\n\r\n<a name=\"cache-configuration\"></a>\r\n### 缓存配置\r\n\r\n通常情况下，限流器使用你默认的缓存驱动，由 `cache` 配置文件中的 `default` 键定义。你也可以通过在你的应用程序的 `cache` 配置文件中定义一个 `limiter` 来指定限流器应该使用哪一个缓存来驱动：\r\n```php\r\n'default' => 'memcached',\r\n'limiter' => 'redis',\r\n```\r\n<a name=\"basic-usage\"></a>\r\n## 基础用法\r\n\r\n可以通过 `Illuminate\\Support\\Facades\\RateLimiter ` 来操作限流器。限流器提供的最简单的方法是 `attempt` 方法，它将一个给定的回调函数执行次数限制在一个给定的秒数内。\r\n\r\n当回调函数执行次数超过限制时， `attempt` 方法返回 `false` ；否则， `attempt` 方法将返回回调的结果或 `true` 。 `attempt` 方法接受的第一个参数是一个速率限制器  `key` ，它可以是你选择的任何字符串，代表被限制速率的动作:\r\n\r\n```php\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    $executed = RateLimiter::attempt(\r\n        'send-message:'.$user->id,\r\n        $perMinute = 5,\r\n        function() {\r\n            // 发送消息...\r\n        }\r\n    );\r\n\r\n    if (! $executed) {\r\n      return 'Too many messages sent!';\r\n    }\r\n```\n\n<a name=\"manually-incrementing-attempts\"></a>\r\n### 手动配置尝试次数\r\n\r\n如果您想手动与限流器交互，可以使用多种方法。例如，您可以调用 `tooManyAttempts` 方法来确定给定的限流器是否超过了每分钟允许的最大尝试次数\r\n\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {\r\n        return 'Too many attempts!';\r\n    }\r\n\r\n或者，您可以使用 `remaining` 方法检索给定密钥的剩余尝试次数。如果给定的密钥还有重试次数，您可以调用 `hit` 方法来增加总尝试次数:\r\n\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    if (RateLimiter::remaining('send-message:'.$user->id, $perMinute = 5)) {\r\n        RateLimiter::hit('send-message:'.$user->id);\r\n\r\n        // 发送消息。。。\r\n    }\r\n\r\n<a name=\"determining-limiter-availability\"></a>\r\n#### 确定限流器可用性\r\n\r\n当一个键没有更多的尝试次数时，`availableIn` 方法返回在更多尝试可用之前剩余的秒数：\r\n\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {\r\n        $seconds = RateLimiter::availableIn('send-message:'.$user->id);\r\n\r\n        return 'You may try again in '.$seconds.' seconds.';\r\n    }\r\n\r\n<a name=\"clearing-attempts\"></a>\r\n### 清除尝试次数\r\n\r\n您可以使用 `clear` 方法重置给定速率限制键的尝试次数。例如，当接收者读取给定消息时，您可以重置尝试次数:\r\n\r\n    use App\\Models\\Message;\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    /**\r\n     * 将邮件标记为已读。\r\n     *\r\n     * @param  \\App\\Models\\Message  $message\r\n     * @return \\App\\Models\\Message\r\n     */\r\n    public function read(Message $message)\r\n    {\r\n        $message->markAsRead();\r\n\r\n        RateLimiter::clear('send-message:'.$message->user_id);\r\n\r\n        return $message;\r\n    }\n","p":"docs/rate-limiting.html"},{"t":"scheduling (任务调度)","d":"# 任务调度\r\n\r\n- [简介](#introduction)\r\n- [定义调度](#defining-schedules)\r\n    - [Artisan 命令调度](#scheduling-artisan-commands)\r\n    - [队列任务调度](#scheduling-queued-jobs)\r\n    - [Shell 命令调度](#scheduling-shell-commands)\r\n    - [调度频率设置](#schedule-frequency-options)\r\n    - [时区](#timezones)\r\n    - [避免任务重复](#preventing-task-overlaps)\r\n    - [单机任务调度](#running-tasks-on-one-server)\r\n    - [后台任务](#background-tasks)\r\n    - [维护模式](#maintenance-mode)\r\n- [运行调度程序](#running-the-scheduler)\r\n    - [本地运行调度程序](#running-the-scheduler-locally)\r\n- [任务输出](#task-output)\r\n- [任务钩子](#task-hooks)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n过去，你可能需要在服务器上为每一个调度任务去创建 Cron 条目。因为这些任务的调度不是通过代码控制的，你要查看或新增任务调度都需要通过 SSH 远程登录到服务器上去操作，所以这种方式很快会让人变得痛苦不堪。\r\nLaravel 的命令行调度器允许你在 Laravel 中清晰明了地定义命令调度。在使用这个任务调度器时，你只需要在你的服务器上创建单个 Cron 入口。你的任务调度在 app/Console/Kernel.php 的 schedule 方法中进行定义。为了帮助你更好的入门，这个方法中有个简单的例子。\r\n\r\n<a name=\"defining-schedules\"></a>\r\n## 定义调度\r\n\r\n你可以在 `App\\Console\\Kernel` 类的 `schedule` 方法中定义所有的调度任务。在开始之前，我们来看一个例子：我们计划每天午夜执行一个 `闭包`，这个 `闭包` 会执行一次数据库语句去清空一张表：\r\n\r\n    <?php\r\n\r\n    namespace App\\Console;\r\n\r\n    use Illuminate\\Console\\Scheduling\\Schedule;\r\n    use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    class Kernel extends ConsoleKernel\r\n    {\r\n        /**\r\n         * 定义应用中的命令调度\r\n         *\r\n         * @param  \\Illuminate\\Console\\Scheduling\\Schedule  $schedule\r\n         * @return void\r\n         */\r\n        protected function schedule(Schedule $schedule)\r\n        {\r\n            $schedule->call(function () {\r\n                DB::table('recent_users')->delete();\r\n            })->daily();\r\n        }\r\n    }\r\n\r\n\r\n\r\n除了调用闭包这种方式来调度外，你还可以调用 [可调用对象](https://secure.php.net/manual/en/language.oop5.magic.php#object.invoke). 可调用对象是简单的 PHP 类，包含一个 `__invoke` 方法：\r\n\r\n    $schedule->call(new DeleteRecentUsers)->daily();\r\n\r\n如果你想查看任务计划的概述及其下次计划运行时间，你可以使用 `schedule:list` Artisan 命令:\r\n\r\n```bash\r\nphp artisan schedule:list\r\n```\r\n\r\n<a name=\"scheduling-artisan-commands\"></a>\r\n### Artisan 命令调度\r\n\r\n调度方式不仅有调用闭包，还有调用 [Artisan commands](/docs/laravel/9.x/artisan) 和操作系统命令。例如，你可以给 `command` 方法传递命令名称或类来调度一个 Artisan 命令：\r\n\r\n当使用命令类名调度 Artisan 命令时，你可以通过一个数组传递附加的命令行参数，且这些参数需要在命令触发时提供：\r\n\r\n    use App\\Console\\Commands\\SendEmailsCommand;\r\n\r\n    $schedule->command('emails:send Taylor --force')->daily();\r\n\r\n    $schedule->command(SendEmailsCommand::class, ['Taylor', '--force'])->daily();\r\n\r\n<a name=\"scheduling-queued-jobs\"></a>\r\n### 队列任务调度\r\n\r\n`job` 方法可以用来调度 [queued job](/docs/laravel/9.x/queues)。此方法提供了一种快捷方式来调度任务，而无需使用 call 方法创建闭包来调度任务：\r\n\r\n    use App\\Jobs\\Heartbeat;\r\n\r\n    $schedule->job(new Heartbeat)->everyFiveMinutes();\r\n\r\n`job` 方法提供了可选的第二，三参数，分别指定任务将被放置的队列名称及连接：\r\n\r\n    use App\\Jobs\\Heartbeat;\r\n\r\n    // 分发任务到「heartbeats」队列及「sqs」连接...\r\n    $schedule->job(new Heartbeat, 'heartbeats', 'sqs')->everyFiveMinutes();\r\n\r\n\r\n\r\n<a name=\"scheduling-shell-commands\"></a>\r\n### Shell 命令调度\r\n\r\n`exec` 方法可发送命令到操作系统：\r\n\r\n    $schedule->exec('node /home/forge/script.js')->daily();\r\n\r\n<a name=\"schedule-frequency-options\"></a>\r\n### 调度频率选项\r\n\r\n我们已经看到了几个如何设置任务在指定时间间隔运行的例子。不仅如此，你还有更多的任务调度频率可选：\r\n\r\n方法  | 描述\r\n------------- | -------------\r\n`->cron('* * * * *');`  |  自定义 Cron 计划执行任务\r\n`->everyMinute();`  |  每分钟执行一次任务\r\n`->everyTwoMinutes();`  |  每两分钟执行一次任务\r\n`->everyThreeMinutes();`  |  每三分钟执行一次任务\r\n`->everyFourMinutes();`  |  每四分钟执行一次任务\r\n`->everyFiveMinutes();`  |  每五分钟执行一次任务\r\n`->everyTenMinutes();`  |  每十分钟执行一次任务\r\n`->everyFifteenMinutes();`  |  每十五分钟执行一次任务\r\n`->everyThirtyMinutes();`  |  每三十分钟执行一次任务\r\n`->hourly();`  |  每小时执行一次任务\r\n`->hourlyAt(17);`  |  每小时第十七分钟时执行一次任务\r\n`->everyTwoHours();`  |  每两小时执行一次任务\r\n`->everyThreeHours();`  |  每三小时执行一次任务\r\n`->everyFourHours();`  |  每四小时执行一次任务\r\n`->everySixHours();`  |  每六小时执行一次任务\r\n`->daily();`  |  每天 00:00 执行一次任务\r\n`->dailyAt('13:00');`  |  每天 13:00 执行一次任务\r\n`->twiceDaily(1, 13);`  |  每天 01:00 和 13:00 各执行一次任务\r\n`->weekly();`  |  每周日 00:00 执行一次任务\r\n`->weeklyOn(1, '8:00');`  |  每周一 08:00 执行一次任务\r\n`->monthly();`  |  每月第一天 00:00 执行一次任务\r\n`->monthlyOn(4, '15:00');`  |  每月第四天 15:00 执行一次任务\r\n`->twiceMonthly(1, 16, '13:00');`  |  每月第一天和第 十六天的 13:00 各执行一次任务\r\n`->lastDayOfMonth('15:00');` | 每月最后一天 15:00 执行一次任务\r\n`->quarterly();` |  每季度第一天 00:00 执行一次任务\r\n`->yearly();`  |  每年第一天 00:00 执行一次任务\r\n`->yearlyOn(6, 1, '17:00');`  |  每年六月第一天 17:00 执行一次任务\r\n`->timezone('America/New_York');` | 设置时区\r\n\r\n\r\n\r\n这些方法与额外的约束条件相结合后，可用于创建在一周的特定时间运行甚至更精细的计划任务。例如，在每周一执行命令：\r\n```\r\n    // 在每周一 13:00 执行...\r\n    $schedule->call(function () {\r\n        //\r\n    })->weekly()->mondays()->at('13:00');\r\n\r\n    // 在每个工作日 8:00 到 17:00 之间的每小时周期执行...\r\n    $schedule->command('foo')\r\n              ->weekdays()\r\n              ->hourly()\r\n              ->timezone('America/Chicago')\r\n              ->between('8:00', '17:00');\r\n```\r\n下方列出了额外的约束条件：\r\n\r\n方法  | 描述\r\n------------- | -------------\r\n`->weekdays();`  |  限制任务在工作日执行\r\n`->weekends();`  |  限制任务在周末执行\r\n`->sundays();`  |  限制任务在周日执行\r\n`->mondays();`  |  限制任务在周一执行\r\n`->tuesdays();`  |  限制任务在周二执行\r\n`->wednesdays();`  |  限制任务在周三执行\r\n`->thursdays();`  |  限制任务在周四执行\r\n`->fridays();`  |  限制任务在周五执行\r\n`->saturdays();`  |  限制任务在周六执行\r\n`->days(array\\|mixed);`  |  限制任务在每周的指定日期执行\r\n`->between($startTime, $endTime);`  |  限制任务在 `$startTime` 和 `$endTime` 区间执行\r\n`->unlessBetween($startTime, $endTime);`  |  限制任务不在 `$startTime` 和 `$endTime` 区间执行\r\n`->when(Closure);`  |  限制任务在闭包返回为真时执行\r\n`->environments($env);`  |  限制任务在特定环境中执行\r\n\r\n<a name=\"day-constraints\"></a>\r\n#### 周几（Day）限制\r\n\r\n`days` 方法可以用于限制任务在每周的指定日期执行。举个例子，您可以在让一个命令每周日和每周三每小时执行一次：\r\n```\r\n    $schedule->command('emails:send')\r\n                    ->hourly()\r\n                    ->days([0, 3]);\r\n```\r\n\r\n\r\n不仅如此，你还可以使用 `Illuminate\\Console\\Scheduling\\Schedule` 类中的常量来设置任务在指定日期运行：\r\n```\r\n    use Illuminate\\Console\\Scheduling\\Schedule;\r\n\r\n    $schedule->command('emails:send')\r\n                    ->hourly()\r\n                    ->days([Schedule::SUNDAY, Schedule::WEDNESDAY]);\r\n```\r\n<a name=\"between-time-constraints\"></a>\r\n#### 时间范围限制\r\n\r\n`between` 方法可用于限制任务在一天中的某个时间段执行：\r\n\r\n    $schedule->command('emails:send')\r\n                        ->hourly()\r\n                        ->between('7:00', '22:00');\r\n\r\n同样， `unlessBetween` 方法也可用于限制任务不在一天中的某个时间段执行：\r\n```\r\n    $schedule->command('emails:send')\r\n                        ->hourly()\r\n                        ->unlessBetween('23:00', '4:00');\r\n```\r\n<a name=\"truth-test-constraints\"></a>\r\n#### 闭包检测限制\r\n\r\n`when` 方法可根据闭包返回结果来执行任务。换言之，若给定的闭包返回 `true`，若无其他限制条件阻止，任务就会一直执行：\r\n```\r\n    $schedule->command('emails:send')->daily()->when(function () {\r\n        return true;\r\n    });\r\n```\r\n`skip` 可看作是 `when` 的逆方法。若 `skip` 方法返回 `true`，任务将不会执行：\r\n```\r\n    $schedule->command('emails:send')->daily()->skip(function () {\r\n        return true;\r\n    });\r\n```\r\n当链式调用 `when` 方法时，仅当所有 `when` 都返回 `true` 时，任务才会执行。\r\n\r\n<a name=\"environment-constraints\"></a>\r\n#### 环境限制\r\n\r\n`environments` 方法可限制任务在指定环境中执行（由 `APP_ENV` [环境变量](/docs/laravel/9.x/configuration#environment-configuration) 定义）：\r\n```\r\n    $schedule->command('emails:send')\r\n                ->daily()\r\n                ->environments(['staging', 'production']);\r\n```\r\n\r\n<a name=\"timezones\"></a>\r\n### 时区\r\n\r\n`timezone` 方法可指定在某一时区的时间执行计划任务：\r\n\r\n    $schedule->command('report:generate')\r\n             ->timezone('America/New_York')\r\n             ->at('2:00')\r\n\r\n若想给所有计划任务分配相同的时区，那么需要在 `app/Console/Kernel.php` 类中定义 `scheduleTimezone` 方法。该方法会返回一个默认时区，最终分配给所有计划任务：\r\n\r\n    /**\r\n     * 获取计划事件默认使用的时区。\r\n     *\r\n     * @return \\DateTimeZone|string|null\r\n     */\r\n    protected function scheduleTimezone()\r\n    {\r\n        return 'America/Chicago';\r\n    }\r\n\r\n> 注意：请记住，有些时区会使用夏令时。当夏令时发生调整时，你的任务可能会执行两次，甚至根本不会执行。因此，我们建议尽可能避免使用时区来安排计划任务。\r\n\r\n<a name=\"preventing-task-overlaps\"></a>\r\n### 避免任务重复\r\n\r\n默认情况下，即使之前的任务实例还在执行，调度内的任务也会执行。为避免这种情况的发生，你可以使用 `withoutOverlapping` 方法：\r\n\r\n    $schedule->command('emails:send')->withoutOverlapping();\r\n\r\n在此例中，若 `emails:send` [Artisan 命令](/docs/laravel/9.x/artisan) 还未运行，那它将会每分钟执行一次。如果你的任务执行时间非常不确定，导致你无法准确预测任务的执行时间，那 `withoutOverlapping` 方法会特别有用。\r\n\r\n如有需要，你可以在 `without overlapping` 锁过期之前，指定它的过期分钟数。默认情况下，这个锁会在 24 小时后过期：\r\n\r\n    $schedule->command('emails:send')->withoutOverlapping(10);\r\n\r\n<a name=\"running-tasks-on-one-server\"></a>\r\n### 任务只运行在一台服务器上\r\n\r\n> 注意：要使用此功能, 你的应用程序必须使用 `database`, `memcached`, `dynamodb`, 或 `redis` 缓存驱动程序作为应用程序的默认缓存驱动程序。此外，所有服务器必须和同一个中央缓存服务器通信。\r\n\r\n如果你的应用运行在多台服务器上，可能需要限制调度任务只在某台服务器上运行。 例如, 假设你有一个每个星期五晚上生成新报告的调度任务，如果任务调度器运行在三台服务器上，调度任务会在三台服务器上运行并且生成三次报告，不够优雅！\r\n\r\n要指示任务应仅在一台服务器上运行, 请在定义计划任务时使用 `onOneServer`方法. 第一台获取到该任务的服务器会给任务上一把原子锁以阻止其他服务器同时运行该任务:\r\n\r\n    $schedule->command('report:generate')\r\n                    ->fridays()\r\n                    ->at('17:00')\r\n                    ->onOneServer();\r\n\r\n<a name=\"background-tasks\"></a>\r\n### 后台任务\r\n\r\n默认情况下, 同时运行多个任务将根据它们在 `schedule` 方法中定义的顺序执行. 如果你有一些长时间运行的任务, 将会导致后续任务比预期时间更晚启动。 如果你想在后台运行任务，以便它们可以同时运行，则可以使用`runInBackground` 方法:\r\n\r\n    $schedule->command('analytics:report')\r\n             ->daily()\r\n             ->runInBackground();\r\n\r\n> 注意：`runInBackground` 方法只有在通过 `command` 和 `exec` 方法调度任务时才可以使用.\r\n\r\n\r\n\r\n<a name=\"maintenance-mode\"></a>\r\n### 维护模式\r\n\r\n当应用处于 [维护模式](/docs/laravel/9.x/configuration#maintenance-mode) 时，Laravel 的队列任务将不会运行。因为我们不想调度任务干扰到服务器上可能还未完成的维护项目。不过，如果你想强制任务在维护模式下运行，你可以使用 `evenInMaintenanceMode` 方法：\r\n\r\n    $schedule->command('emails:send')->evenInMaintenanceMode();\r\n\r\n<a name=\"running-the-scheduler\"></a>\r\n## 运行调度程序\r\n\r\n现在，我们已经学会了如何定义计划任务，接下来让我们讨论如何真正在服务器上运行它们。`schedule:run` Artisan 命令将评估你的所有计划任务，并根据服务器的当前时间决定它们是否运行。\r\n\r\n因此，当使用 `Laravel` 的调度程序时，我们只需要向服务器添加一个 cron 配置项，该项每分钟运行一次 `schedule:run` 命令。如果你不知道如何向服务器添加 cron 配置项，请考虑使用 [Laravel Forge](https://forge.laravel.com) 之类的服务来为你管理 cron 配置项：\r\n\r\n```shell\r\n* * * * * cd /你的项目路径 && php artisan schedule:run >> /dev/null 2>&1\r\n```\r\n\r\n<a name=\"running-the-scheduler-locally\"></a>\r\n## 本地运行调度程序\r\n\r\n通常，你不会直接将 cron 配置项添加到本地开发计算机。你反而可以使用 `schedule:work` Artisan 命令。该命令将在前台运行，并每分钟调用一次调度程序，直到你终止该命令为止：\r\n\r\n```shell\r\nphp artisan schedule:work\r\n```\r\n\r\n<a name=\"task-output\"></a>\r\n\r\n\r\n## 任务输出\r\n\r\nLaravel 调度器提供了一些简便方法来处理调度任务生成的输出。首先，你可以使用 `sendOutputTo` 方法将输出发送到文件中以便后续检查：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->sendOutputTo($filePath);\r\n\r\n如果希望将输出追加到指定文件，可使用 `appendOutputTo` 方法：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->appendOutputTo($filePath);\r\n\r\n使用 `emailOutputTo` 方法，你可以将输出发送到指定邮箱。在发送邮件之前，你需要先配置 Laravel 的 [邮件服务](/docs/laravel/9.x/mail):\r\n\r\n    $schedule->command('report:generate')\r\n             ->daily()\r\n             ->sendOutputTo($filePath)\r\n             ->emailOutputTo('taylor@example.com');\r\n\r\n如果你只想在命令执行失败时将输出发送到邮箱，可使用 `emailOutputOnFailure` 方法：\r\n\r\n    $schedule->command('report:generate')\r\n             ->daily()\r\n             ->emailOutputOnFailure('taylor@example.com');\r\n\r\n> 注意：`emailOutputTo`, `emailOutputOnFailure`, `sendOutputTo` 和 `appendOutputTo` 是 `command` 和 `exec` 独有的方法。\r\n\r\n<a name=\"task-hooks\"></a>\r\n## 任务钩子\r\n\r\n使用 `before` 和 `after` 方法，你可以决定在调度任务执行前或者执行后来运行代码：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->before(function () {\r\n                 // 任务即将执行。。。\r\n             })\r\n             ->after(function () {\r\n                 // 任务已经执行。。。\r\n             });\r\n\r\n使用 `onSuccess` 和 `onFailure` 方法，你可以决定在调度任务成功或者失败运行代码。失败表示 Artisan 或系统命令以非零退出码终止：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->onSuccess(function () {\r\n                 // 任务执行成功。。。\r\n             })\r\n             ->onFailure(function () {\r\n                 // 任务执行失败。。。\r\n             });\r\n\r\n\r\n\r\n如果你的命令有输出，你可以在闭包中将 `Illuminate\\Support\\Stringable` 实例化为 `$output` 通过 `after`, `onSuccess` 或 `onFailure` 钩子对其进行访问：\r\n\r\n    use Illuminate\\Support\\Stringable;\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->onSuccess(function (Stringable $output) {\r\n                 // 任务执行成功。。。\r\n             })\r\n             ->onFailure(function (Stringable $output) {\r\n                 // 任务执行失败。。。\r\n             });\r\n\r\n<a name=\"pinging-urls\"></a>\r\n#### Pinging 网址\r\n\r\n使用 `pingBefore` 和 `thenPing` 方法，你可以在任务完成之前或完成之后来 ping 指定的 URL。当前方法在通知外部服务，如 [Envoyer](https://envoyer.io)，计划任务在将要执行或已完成时会很有用：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->pingBefore($url)\r\n             ->thenPing($url);\r\n\r\n只有当条件为 `true` 时，才可以使用 `pingBeforeIf` 和 `thenPingIf` 方法来 ping 指定 URL ：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->pingBeforeIf($condition, $url)\r\n             ->thenPingIf($condition, $url);\r\n\r\n当任务成功或失败时，可使用 `pingOnSuccess` 和 `pingOnFailure` 方法来 ping 给定 URL。失败表示 Artisan 或系统命令以非零退出码终止：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->pingOnSuccess($successUrl)\r\n             ->pingOnFailure($failureUrl);\r\n\r\n所有 ping 方法都依赖 Guzzle HTTP 库。通常，Guzzle 已在所有新的 Laravel 项目中默认安装，不过，若意外将 Guzzle 删除，则可以使用 Composer 包管理器将 Guzzle 手动安装到项目中：\r\n\r\n\r\n```shell\r\ncomposer require guzzlehttp/guzzle\r\n```\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\n如果需要，您可以监听调度程序调度的 [事件](/docs/laravel/9.x/events)。通常，事件侦听器映射将在您的应用程序的 `App\\Providers\\EventServiceProvider` 类中定义：\r\n\r\n    /**\r\n     * 应用的事件监听器映射\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Console\\Events\\ScheduledTaskStarting' => [\r\n            'App\\Listeners\\LogScheduledTaskStarting',\r\n        ],\r\n\r\n        'Illuminate\\Console\\Events\\ScheduledTaskFinished' => [\r\n            'App\\Listeners\\LogScheduledTaskFinished',\r\n        ],\r\n\r\n        'Illuminate\\Console\\Events\\ScheduledBackgroundTaskFinished' => [\r\n            'App\\Listeners\\LogScheduledBackgroundTaskFinished',\r\n        ],\r\n\r\n        'Illuminate\\Console\\Events\\ScheduledTaskSkipped' => [\r\n            'App\\Listeners\\LogScheduledTaskSkipped',\r\n        ],\r\n\r\n        'Illuminate\\Console\\Events\\ScheduledTaskFailed' => [\r\n            'App\\Listeners\\LogScheduledTaskFailed',\r\n        ],\r\n    ];\r\n\r\n","p":"docs/scheduling.html"},{"t":"authentication (用户认证)","d":"# 用户认证\r\n\r\n- [简介](#introduction)\r\n    - [入门套件](#starter-kits)\r\n    - [数据库注意事项](#introduction-database-considerations)\r\n    - [生态系统概述](#ecosystem-overview)\r\n- [快速开始用户认证](#authentication-quickstart)\r\n    - [安装入门套件](#install-a-starter-kit)\r\n    - [获取已认证的用户信息](#retrieving-the-authenticated-user)\r\n    - [路由保护](#protecting-routes)\r\n    - [登录限流](#login-throttling)\r\n- [手动验证用户](#authenticating-users)\r\n    - [记住密码](#remembering-users)\r\n    - [其他认证方法](#other-authentication-methods)\r\n- [HTTP Basic 认证](#http-basic-authentication)\r\n    - [无状态 HTTP Basic 认证](#stateless-http-basic-authentication)\r\n- [退出登录](#logging-out)\r\n    - [使其他设备上的会话无效](#invalidating-sessions-on-other-devices)\r\n- [密码确认](#password-confirmation)\r\n    - [配置](#password-confirmation-configuration)\r\n    - [路由](#password-confirmation-routing)\r\n    - [路由保护](#password-confirmation-protecting-routes)\r\n- [添加自定义看守器](#adding-custom-guards)\r\n    - [闭包请求看守器](#closure-request-guards)\r\n- [添加自定义用户提供器](#adding-custom-user-providers)\r\n    - [用户提供器契约](#the-user-provider-contract)\r\n    - [用户认证契约](#the-authenticatable-contract)\r\n- [社会化用户认证](/docs/laravel/9.x/socialite)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n许多 web 应用程序为其用户提供了一种通过应用程序进行身份验证和「登录」的方法。在 web 应用程序中实现此功能可能是一项复杂且具有潜在风险的工作。因此，Laravel 努力为你提供了一套快速、安全、轻松地实现身份验证的工具。\r\n\r\n在其核心，Laravel 的用户认证是由「看守器」和「提供器」。看守器定义如何对每个请求的用户进行身份验证。例如，Laravel 附带了一个 `session` 守护程序，它使用 session 存储和 cookie 来维护状态。\r\n\r\n提供器定义如何从持久存储中检索用户。Laravel 支持使用 [Eloquent](/docs/laravel/9.x/eloquent) 和数据库查询生成器检索用户。不仅如此，你甚至可以根据应用程序的需要自由定制其他提供程序。\r\n\r\n\r\n\r\n应用程序的身份验证配置文件位于 `config/auth.php`。这个文件包含几个记载了的选项，用于调整 Laravel 的身份验证服务的行为。\r\n\r\n> 技巧：守卫和提供器不应与「角色」和「权限」混淆。要了解有关通过权限授权用户操作的更多信息，请参阅 [用户授权](/docs/laravel/9.x/authorization) 文档。\r\n\r\n<a name=\"starter-kits\"></a>\r\n### 入门套件\r\n\r\n想快点开始吗？在新的 Laravel 应用程序中安装 [Laravel 入门套件](/docs/laravel/9.x/starter-kits) 。执行迁移数据库后，将浏览器导航到 `/register` 或分配给应用程序的任何其他 URL。初学者工具包将守护好你的整个认证系统！\r\n\r\n**即使你在最终的 Laravel 应用程序中选择不使用初学者工具包，安装 [Laravel Breeze](/docs/laravel/9.x/starter-kits#laravel-breeze) 初学者工具包也是学习如何在实际的 Laravel 项目中实现所有 Laravel 身份验证功能的绝佳机会。** 由于 Laravel Breeze 为你创建身份验证控制器、路由和视图，因此你可以查看这些文件中的源码，进而了解如何实现 Laravel 的身份验证功能。\r\n\r\n<a name=\"introduction-database-considerations\"></a>\r\n### 数据库注意事项\r\n\r\n默认情况下，Laravel 在 `App/Models` 目录中包含一个  `App\\Models\\User` [Eloquent model](/docs/laravel/9.x/eloquent)。此模型可与默认的 Eloquent 身份验证驱动程序一起使用。如果你的应用程序未使用 Eloquent，则可以使用 Laravel 查询生成器的 `database` 身份验证提供程序。\r\n\r\n为 `App\\Models\\User` 模型构建数据库架构时，请确保密码列的长度至少为 60 个字符。当然，新的 Laravel 应用程序中包含的 `users` 表迁移文件已经创建了一个超过此长度的列。\r\n\r\n\r\n\r\n此外，还应验证 `users` (或等效表) 是否包含一个可为空的字符串 `remember_token` ，该列包含 100 个字符。 此列将用于为在登录到应用程序时选择「记住我」选项的用户存储令牌。同样，新的 Laravel 应用程序中包含的默认 `users` 表迁移文件已经包含此列。\r\n\r\n<a name=\"ecosystem-overview\"></a>\r\n### 生态系统概述\r\n\r\nLaravel 提供了几个与身份验证相关的包。在继续之前，我们将回顾 Laravel 中的通用身份验证生态系统，并讨论每个包的预期用途。\r\n\r\n首先，考虑身份验证是如何工作的。使用 web 浏览器时，用户将通过登录表单提供用户名和密码。如果这些凭据正确，应用程序将在用户的 [session](/docs/laravel/9.x/session) 中存储有关已验证用户的信息。发布到浏览器的 cookie 包含 session ID，以便应用程序的后续请求可以将用户与正确的 session 相关联。在接收到 session 的 cookie 之后，应用程序将基于 session ID 检索 session 数据，注意认证信息已经存储在会话中，并且将用户视为「已认证」。\r\n\r\n当远程服务需要通过身份验证才能访问 API 时，我们通常不用 Cookie 进行身份认证，因为没有 web 浏览器。相反，远程服务会在每个请求时向 API 发送一个 token。应用程序可以对照有效 API 令牌表来验证传入 token ，并且「认证」与该 API 令牌相关联的用户正在执行的请求。\r\n\r\n\r\n\r\n<a name=\"laravels-built-in-browser-authentication-services\"></a>\r\n#### Laravel 内置的浏览器认证服务\r\n\r\nLaravel 包括内置的身份验证和 session 服务，这些服务通常通过 `Auth` 和 `Session` facade 使用。 这些特性为从 web 浏览器发起的请求提供基于 cookie 的身份验证。它们提供的方法允许你验证用户的凭据并对用户进行身份验证。此外，这些服务将自动在用户会话中存储正确的身份验证数据，并发出用户会话 cookie 。本文档包含这些服务的使用方式的讨论。\r\n\r\n**应用入门工具包**\r\n\r\n如本文档中所述，你可以手动与这些身份验证服务进行交互，以构建应用程序自己的身份验证层。不过，为了帮助你更快地入门，我们发布了 [免费软件包](/docs/laravel/9.x/starter-kits) ，为整个验证层提供了健壮的、现代化的脚手架。这些包分别是 [Laravel Breeze](/docs/laravel/9.x/starter-kits#laravel-breeze), [Laravel Jetstream](/docs/laravel/9.x/starter-kits#laravel-jetstream) 和 [Laravel Fortify](/docs/laravel/9.x/fortify)。\r\n\r\n_Laravel Breeze_ 是 Laravel 所有身份验证功能的简单、最小实现，包括登录、注册、密码重置、电子邮件验证和密码确认。 Laravel Breeze 的视图层由简单的 [Blade 模板](/docs/laravel/9.x/blade) 组成，样式为 [Tailwind CSS](https://tailwindcss.com)。要开始使用，请查看 Laravel 的 [应用入门工具包](/docs/laravel/9.x/starter-kits) 文档。\r\n\r\n_Laravel Fortify_ 是 Laravel 的无 header 身份验证后端，它实现了本文档中的许多功能，包括基于 cookie 的身份验证以及其他功能，如双因素身份验证和电子邮件验证。Fortify 为 Laravel Jetstream 提供身份验证后端，或者可以单独与 [Laravel Sanctum](/docs/laravel/9.x/sanctum) 结合使用，为需要使用 Laravel 进行身份验证的 SPA 提供身份验证。\r\n\r\n\r\n\r\n_[Laravel Jetstream](https://jetstream.laravel.com)_ 是一个健壮的应用程序启动工具包，它使用并公开了 Laravel Fortify 的身份验证服务，用到了一个漂亮的现代化的 UI 库 [Tailwind CSS](https://tailwindcss.com)， [Livewire](https://laravel-livewire.com)，和 [Inertia.js](https://inertiajs.com)。 Laravel Jetstream 可选的支持包括对双因子身份验证、团队支持、浏览器会话管理、配置文件管理，以及与 [Laravel Sanctum](/docs/laravel/9.x/sanctum) 的内置集成，以提供 API 令牌身份验证。接下来我们将讨论 Laravel 的 API 认证产品。\r\n\r\n<a name=\"laravels-api-authentication-services\"></a>\r\n#### Laravel 的 API 认证服务\r\n\r\nLaravel 提供了两个可选的包来帮助你管理 API 令牌和验证使用 API 令牌发出的请求：[Passport](/docs/laravel/9.x/passport) 和 [Sanctum](/docs/laravel/9.x/sanctum)。请注意，这些库和 Laravel 内置的基于 Cookie 的身份验证库并不是互斥的。这些库主要关注 API 令牌身份验证，而内置的身份验证服务则关注基于 Cookie 的浏览器身份验证。许多应用程序将同时使用 Laravel 内置的基于 Cookie 的身份验证服务和一个 Laravel 的 API 身份验证包。\r\n\r\n**Passport**\r\n\r\nPassport 是一个 OAuth2 身份验证提供程序，提供各种 OAuth2 「授权类型」，允许你发布各种类型的令牌。一般来说，这是一个健壮而复杂的 API 认证包。但是，大多数应用程序不需要 OAuth2 规范提供的复杂特性，因为这可能会让用户和开发人员感到麻烦。此外，对于如何使用 OAuth2 身份验证提供程序（如 Passport）对 SPA 应用程序或移动应用程序进行身份验证，开发人员长期以来一直感到十分棘手。\r\n\r\n**Sanctum**\r\n\r\n为了应对 OAuth2 的复杂性和开发人员的困惑，我们着手构建一个更简单、更精简的身份验证包，它可以处理来自 web 浏览器的第一方 web 请求和通过令牌的 API 请求。 [Laravel Sanctum](/docs/laravel/9.x/sanctum) 发布后，这一目标就实现了。对于除 API 外还提供第一方 web UI 的应用程序，或由单页应用程序（SPA）提供支持的应用程序，或是提供移动客户端的应用程序，Sanctum 是首选推荐的身份验证包。\r\n\r\n\r\n\r\nLaravel Sanctum 是一个混合了 web 和 API 的身份验证包，它让我们管理应用程序的整个身份验证过程成为可能，因为当基于 Sanctum 的应用程序收到请求时，Sanctum 将首先确定请求是否包含引用已验证会话的会话 cookie。Sanctum 通过调用我们前面讨论过的 Laravel 的内置身份验证服务来实现这一点。如果请求没有通过 session cookie 进行身份验证，Sanctum 将检查请求中的 API 令牌。如果存在 API 令牌，Sanctum 将使用该令牌对请求进行身份验证。要了解有关此过程的更多信息，请参阅 Sanctum 的 [它是如何工作的](/docs/laravel/9.x/sanctum#how-it-works) 文档。\r\n\r\nLaravel Sanctum 是我们选择在 [Laravel Jetstream](https://jetstream.laravel.com) 中包含的 API 包应用程序初学者工具包，因为我们认为它最适合大多数 web 应用程序的身份验证需求。\r\n\r\n<a name=\"summary-choosing-your-stack\"></a>\r\n#### 汇总 / 选择你的解决方案\r\n\r\n总之，如果你的应用程序将使用浏览器访问，并且你正在构建一个单页面的 Laravel 应用程序，那么你的应用程序可以使用 Laravel 的内置身份验证服务。\r\n\r\n接下来，如果你的应用程序提供了一个将由第三方使用的 API ，你可以在 [Passport](/docs/laravel/9.x/passport) 或 [Sanctum](/docs/laravel/9.x/sanctum) 之间进行选择，为你的应用程序提供 API 令牌身份验证。一般来说，如果可能的话，应该首选 Sanctum，因为它是 API 认证、SPA 认证和移动认证的简单、完整的解决方案，包括对「scopes」或「abilities」的支持。\r\n\r\n如果您正在构建一个将由 Laravel 后端支持的单页面应用程序（SPA），那么应该使用  [Laravel Sanctum](/docs/laravel/9.x/sanctum)。使用 Sanctum 时，你需要 [手动实现自己的后端验证路由](#authenticating-users) 或 使用 [Laravel Fortify](/docs/laravel/9.x/fortify) 作为无头验证后端服务，为注册、密码重置、电子邮件验证等功能提供路由和控制器。\r\n\r\n\r\n\r\n当应用程序确定必须使用 OAuth2 规范提供的所有特性时，可以选择 Passport。\r\n\r\n如果你想快速入门，我们很高兴向你推荐 [Laravel Jetstream](https://jetstream.laravel.com) 作为一种快速启动新的 Laravel 应用程序的方法，它已经使用了我们首选的 Laravel 内置身份验证服务和 Laravel Sanctum 的身份验证堆栈。\r\n\r\n<a name=\"authentication-quickstart\"></a>\r\n## 身份认证快速入门\r\n\r\n> 注意：这部分文档讨论了如何通过 [Laravel 应用入门工具包](/docs/laravel/9.x/starter-kits) 对用户进行身份验证，其中包括帮助你快速入门的 UI 脚手架。如果你想直接与 Laravel 的身份验证系统集成，请查看 [手动验证用户](#authenticating-users) 上的文档。\r\n\r\n<a name=\"install-a-starter-kit\"></a>\r\n### 安装入门工具包\r\n\r\n首先，你应该 [安装一个Laravel 应用程序启动程序工具包](/docs/laravel/9.x/starter-kits)。我们目前的入门套件，Laravel Breeze 和 Laravel Jetstream，提供了设计精美的起点，可将身份验证纳入你的全新 Laravel 应用程序。\r\n\r\nLaravel Breeze 是 Laravel 所有身份验证功能的最简单的实现，包括登录、注册、密码重置、电子邮件验证和密码确认。 Laravel 的视图层由简单的 [Blade 模板](/docs/laravel/9.x/blade) 和 [Tailwind CSS](https://tailwindcss.com) 组成。Breeze 还使用 Vue 或 React提供了基于 [Inertia](https://inertiajs.com) 的脚手架选项。\r\n\r\n[Laravel Jetstream](https://jetstream.laravel.com) 是一个更强大的应用程序启动工具包，包括对使用 [Livewire](https://laravel-livewire.com) 或 [Inertia.js and Vue](https://inertiajs.com) 构建应用程序的支持。 此外，Jetstream 还提供可选的双因素身份验证支持、团队、配置文件管理、浏览器会话管理、通过 [Laravel Sanctum](/docs/laravel/9.x/sanctum) 的 API 支持、帐户删除等。\r\n\r\n\r\n\r\n<a name=\"retrieving-the-authenticated-user\"></a>\r\n### 获取已认证的用户信息\r\n\r\n在安装身份验证初学者工具包并允许用户注册应用程序并对其进行身份验证之后，你通常需要与当前通过身份验证的用户进行交互。在处理传入请求时，您可以通过 `Auth` facade 的 `user` 方法访问通过身份验证的用户：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    // 获取当前的认证用户信息 ...\r\n    $user = Auth::user();\r\n\r\n    // 获取当前的认证用户id ...\r\n    $id = Auth::id();\r\n\r\n或者，一旦用户通过身份验证，你就可以通过 `Illuminate\\Http\\Request` 实例访问通过身份验证的用户。记住，使用类型提示的类将自动注入到控制器方法中。通过键入 `Illuminate\\Http\\Request` 对象，你可以通过 `Request` 的 `user` 方法从应用程序中的任何控制器方法方便地访问经过身份验证的用户：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class FlightController extends Controller\r\n    {\r\n        /**\r\n         * 更新现有航班的航班信息。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function update(Request $request)\r\n        {\r\n            // $request->user()\r\n        }\r\n    }\r\n\r\n<a name=\"determining-if-the-current-user-is-authenticated\"></a>\r\n#### 确定当前用户是否经过身份验证\r\n\r\n要确定发出传入 HTTP 请求的用户是否经过身份验证，可以在 `Auth` facade 上使用 `check` 方法。如果用户通过身份验证，此方法将返回 `true` ：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    if (Auth::check()) {\r\n        // 用户已登录...\r\n    }\r\n\r\n> 技巧：即使可以确定是否使用 `check` 方法对用户进行了身份验证，但在允许用户访问某些路由 / 控制器之前，通常也会使用中间件验证用户是否经过了身份验证。要了解更多信息，请查看 [路由保护](/docs/laravel/9.x/authentication#protecting-routes) 的文档。\r\n\r\n\r\n\r\n<a name=\"protecting-routes\"></a>\r\n### 路由保护\r\n\r\n[路由中间件](/docs/laravel/9.x/middleware) 只能用于允许经过身份验证的用户访问给定的路由。Laravel 附带了一个 `auth` 中间件，它引用了 `Illuminate\\Auth\\Middleware\\Authenticate` 类。由于此中间件已在应用程序的 HTTP 内核中注册，因此你只需将中间件连接到路由定义即可：\r\n\r\n    Route::get('/flights', function () {\r\n        // 只有经过身份验证的用户才能访问此路由 ...\r\n    })->middleware('auth');\r\n\r\n<a name=\"redirecting-unauthenticated-users\"></a>\r\n#### 给未认证的用户设置重定向\r\n\r\n当 `auth` 中间件检测到未经验证的用户时，它将将用户重定向到 `login` [命名路由](/docs/laravel/9.x/routing#named-routes)。你可以通过更新应用程序的 `app/Http/Middleware/Authenticate.php` 文件的 `redirectTo` 函数来修改此行为：\r\n\r\n    /**\r\n     * 获取用户应重定向到的路径。\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return string\r\n     */\r\n    protected function redirectTo($request)\r\n    {\r\n        return route('login');\r\n    }\r\n\r\n<a name=\"specifying-a-guard\"></a>\r\n#### 指定看守器\r\n\r\n将 `auth` 中间件附加到路由时，还可以指定应该使用哪个「guard」来验证用户。指定的看守器应与你的 `auth.php` 配置文件 `guards` 数组中的一个键相对应：\r\n\r\n    Route::get('/flights', function () {\r\n        // 只有经过身份验证的用户才能访问此路由...\r\n    })->middleware('auth:admin');\r\n\r\n<a name=\"login-throttling\"></a>\r\n### 登录限流\r\n\r\n如果您使用的是 Laravel Breeze 或 Laravel Jetstream [入门套件](/docs/laravel/9.x/starter-kits) ，那么在尝试登录的时候将自动应用速率限制。默认情况下，如果用户在多次尝试后未能提供正确的凭据，一分钟内将无法登录。该限制对与用户的用户名 /email 及其 IP 地址是唯一的。\r\n\r\n> 技巧：如果您想对应用程序中的其他路由进行速率限制，请查看 [速率限制](/docs/laravel/9.x/routing#rate-limiting) 文档。\r\n\r\n\r\n\r\n<a name=\"authenticating-users\"></a>\r\n## 手动验证用户\r\n\r\n你并非一定要使用 Laravel [应用入门套件](/docs/laravel/9.x/starter-kits) 附带的身份验证框架。如果选择不使用此支架，则需要直接使用 Laravel 身份验证类来管理用户身份验证。别担心，这也很容易！\r\n\r\n我们将通过 `Auth` [facade](/docs/laravel/9.x/facades) 访问 Laravel 的身份验证服务，因此我们需要确保导入类顶部的 `Auth` 。接下来，让我们检查一下 `attempt` 方法。`attempt` 方法通常用于处理来自应用程序 `login` 页面的身份验证尝试。如果身份验证成功，则应重新生成用户的 [session](/docs/laravel/9.x/session) 以防止 [session 固定](https://en.wikipedia.org/wiki/Session_fixation)：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    class LoginController extends Controller\r\n    {\r\n        /**\r\n         * 处理身份验证尝试。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function authenticate(Request $request)\r\n        {\r\n            $credentials = $request->validate([\r\n                'email' => ['required', 'email'],\r\n                'password' => ['required'],\r\n            ]);\r\n\r\n            if (Auth::attempt($credentials)) {\r\n                $request->session()->regenerate();\r\n\r\n                return redirect()->intended('dashboard');\r\n            }\r\n\r\n            return back()->withErrors([\r\n                'email' => 'The provided credentials do not match our records.',\r\n            ]);\r\n        }\r\n    }\r\n\r\n`attempt` 方法接受键 / 值对数组作为其第一个参数。数组中的值将用于在数据库表中查找用户。因此，在上面的示例中，将通过 `email` 列的值检索用户。如果找到该用户，则数据库中存储的哈希密码将与通过数组传递给该方法的 `password` 值进行比较。你不应该加密传入请求的 `password` 值，因为框架将在将该值与数据库中的散列密码进行比较之前自动加密该值。如果两个哈希密码匹配，将为用户启动一个经过身份验证的会话。\r\n\r\n\r\n\r\n记住，Laravel 的身份验证服务将根据身份验证看守器的「provider」配置从数据库检索用户。在 `config/auth.php` 配置文件中的默认设置，指定了 Eloquent 的用户提供程序，并指示它在检索用户时使用 `App\\Models\\User` 模型。你可以根据应用程序的需要在配置文件中更改这些值。\r\n\r\n如果身份验证成功，`attempt` 方法将返回 `true` 。否则，将返回 `false` 。\r\n\r\nLaravel 的重定向器提供的 `intended` 方法将用户重定向到他们试图访问的 URL，然后被认证中间件截获。如果预期的目的地不可用，可以为该方法提供回退 URI。\r\n\r\n<a name=\"specifying-additional-conditions\"></a>\r\n#### 指定附加条件\r\n\r\n如果你愿意，除了用户的电子邮件和密码之外，还可以向身份验证查询中添加额外的查询条件。为了实现这一点，我们可以简单地将查询条件添加到传递给 `attempt` 方法的数组中。例如，我们可以验证用户是否标记为「active」：\r\n\r\n    if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {\r\n        // 认证成功 ...\r\n    }\r\n\r\n> 注意：在这些例子中，`email` 不是必需的选项，它只是作为一个例子。你应该使用与数据库表中的「用户名」对应的任何列名。\r\n\r\n<a name=\"accessing-specific-guard-instances\"></a>\r\n#### 访问特定的看守器实例\r\n\r\n通过 `Auth` facade 的 `guard` 方法，可以指定在对用户进行身份验证时要使用哪个 guard 实例。这允许你使用完全不同的可验证模型或用户表来管理应用程序的不同部分的验证。\r\n\r\n\r\n\r\n传递给 `guard` 方法的名称应存在 `auth.php` 配置文件中：\r\n\r\n    if (Auth::guard('admin')->attempt($credentials)) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"remembering-users\"></a>\r\n### 记住用户\r\n\r\n许多 web 应用程序在其登录窗体上提供「记住我」复选框。如果希望在应用程序中提供「记住我」功能，可以将布尔值作为第二个参数传递给 `attempt` 方法。\r\n\r\n当此值为 `true` 时，Laravel 将无限期地对用户进行身份验证，或者直到用户手动注销。`users` 表必须包含字符串 `remember_token` 列，该列将用于存储「记住我」标记。新的 Laravel 应用程序中包含的 `users` 表迁移文件已经包含此列：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {\r\n        // 正在为该用户执行记住我操作 ...\r\n    }\r\n\r\n<a name=\"other-authentication-methods\"></a>\r\n### 其他认证方法\r\n\r\n<a name=\"authenticate-a-user-instance\"></a>\r\n#### 认证一个用户实例\r\n\r\n如果需要将现有用户实例设置为当前经过身份验证的用户，可以将该用户实例传递给 `Auth` facade 的 `login` 方法。 给定的用户实例必须是 `Illuminate\\Contracts\\Auth\\Authenticatable` [contract](/docs/laravel/9.x/contracts) 的实现。 Laravel 中包含的 `App\\Models\\User` 模型已经实现了此接口。当你已经有一个有效的用户实例时（例如用户直接向你的应用程序注册之后），此身份验证方法非常有用：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    Auth::login($user);\r\n\r\n您可以将布尔值作为第二个参数传递给 `login` 方法。此值指示是否需要验证会话的「记住我」功能。请记住，这意味着会话将被无限期地验证，或者直到用户手动注销应用程序：\r\n\r\n    Auth::login($user, $remember = true);\r\n\r\n\r\n\r\n如果需要，你可以在调用 `login` 方法之前指定身份验证看守器：\r\n\r\n    Auth::guard('admin')->login($user);\r\n\r\n<a name=\"authenticate-a-user-by-id\"></a>\r\n#### 使用 ID 验证一个用户\r\n\r\n要使用数据库记录的主键对用户进行身份验证，可以使用 `loginUsingId` 方法。此方法接受要验证的用户的主键：\r\n\r\n    Auth::loginUsingId(1);\r\n\r\n可以将布尔值作为第二个参数传递给 `loginUsingId` 方法。此值指示验证会话是否需要「记住我」功能。请记住，这意味着 session 将被无限期地验证，或者直到用户手动注销应用程序：\r\n\r\n    Auth::loginUsingId(1, $remember = true);\r\n\r\n<a name=\"authenticate-a-user-once\"></a>\r\n#### 只验证一次\r\n\r\n你可以使用 `once` 方法通过应用程序对单个请求对用户进行身份验证。调用此方法时不会使用 session 或 Cookie：\r\n\r\n    if (Auth::once($credentials)) {\r\n        //\r\n    }\r\n\r\n<a name=\"http-basic-authentication\"></a>\r\n## HTTP Basic 用户认证\r\n\r\n[HTTP Basic 用户认证](https://en.wikipedia.org/wiki/Basic_access_authentication) 提供了一种快速验证应用程序用户身份的方法，无需设置专用的「登录」页面。要开始，请附加 `auth.basic` [中间件](/docs/laravel/9.x/middleware) 到路由。 `auth.basic` 中间件包含在 Laravel 框架中，因此您不需要定义它：\r\n\r\n    Route::get('/profile', function () {\r\n        // 只有经过身份验证的用户才能访问此路由 ...\r\n    })->middleware('auth.basic');\r\n\r\n一旦将中间件连接到路由，在浏览器中访问路由时，将自动提示你输入凭据。默认情况下 `auth.basic` 中间件将假定 `users` 数据库表中的 `email` 列是用户的「用户名」。\r\n\r\n\r\n\r\n<a name=\"a-note-on-fastcgi\"></a>\r\n#### 注意 FastCGI\r\n\r\n如果你使用的是 PHP FastCGI 和 Apache 来为 Laravel 应用程序提供服务，那么 HTTP Basic 身份验证可能无法正常工作。要更正这些问题，可以将以下行添加到应用程序的 `.htaccess` 文件中：\r\n\r\n```apache\r\nRewriteCond %{HTTP:Authorization} ^(.+)$\r\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\r\n```\r\n\r\n<a name=\"stateless-http-basic-authentication\"></a>\r\n### 无状态 HTTP Basic 认证\r\n\r\n你也可以使用 HTTP Basic 身份验证，而无需在 session 中设置用户标识符 cookie。如果你选择使用 HTTP 身份验证对应用程序 API 的请求进行身份验证，这将非常有用。为此， [定义一个中间件](/docs/laravel/9.x/middleware) 调用 `onceBasic` 方法。如果 `onceBasic` 方法未返回任何响应，则可以将请求进一步传递到应用程序中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    class AuthenticateOnceWithBasicAuth\r\n    {\r\n        /**\r\n         * 处理传入请求。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Closure  $next\r\n         * @return mixed\r\n         */\r\n        public function handle($request, $next)\r\n        {\r\n            return Auth::onceBasic() ?: $next($request);\r\n        }\r\n\r\n    }\r\n\r\n然后，[注册路由中间件](/docs/laravel/9.x/middleware#registering-middleware) 并把它附加到路由中：\r\n\r\n    Route::get('/api/user', function () {\r\n        // 只有经过身份验证的用户才能访问此路由 ...\r\n    })->middleware('auth.basic.once');\r\n\r\n<a name=\"logging-out\"></a>\r\n## 退出登录\r\n\r\n要在应用程序中手动注销用户，可以使用 `Auth` facade 提供的 `logout` 方法。 这将从用户的 session 中删除身份验证信息，以便后续请求不会得到身份验证。\r\n\r\n除了调用 `logout` 方法外，建议你将用户的 session 置为过期，并重新生成其 [CSRF 令牌](/docs/laravel/9.x/csrf)。注销用户后，通常会将用户重定向到应用程序的根目录：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    /**\r\n     * 将用户退出应用程序。\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return \\Illuminate\\Http\\Response\r\n     */\r\n    public function logout(Request $request)\r\n    {\r\n        Auth::logout();\r\n\r\n        $request->session()->invalidate();\r\n\r\n        $request->session()->regenerateToken();\r\n\r\n        return redirect('/');\r\n    }\r\n\r\n\r\n\r\n<a name=\"invalidating-sessions-on-other-devices\"></a>\r\n### 使其他设备上的 session 失效\r\n\r\nLaravel 还提供了这样一种机制，可以使用户在其他设备上处于活动状态置为失效并「注销」，而不会使其当前设备上的会话失效。当用户正在更改或更新其密码，并且你希望在保持当前设备身份验证的同时使其他设备上的会话无效时，通常会使用此功能。\r\n\r\n在开始之前，你应该确保 `App\\Http\\Kernel` 类的 `web` 中间件组中存在 `Illuminate\\Session\\Middleware\\AuthenticateSession` 中间件，并且没有被注释掉：\r\n\r\n    'web' => [\r\n        // ...\r\n        \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,\r\n        // ...\r\n    ],\r\n\r\n然后，可以使用 `Auth` facade 提供的 `logoutOtherDevices` 方法。此方法要求用户确认其当前密码，应用程序应通过输入窗体接受此密码：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    Auth::logoutOtherDevices($currentPassword);\r\n\r\n当调用 `logoutOtherDevices` 方法时，用户的其他 session 将完全失效，这意味着它们将「注销」以前通过身份验证的所有看守器。\r\n\r\n<a name=\"password-confirmation\"></a>\r\n## 密码确认\r\n\r\n在构建应用程序时，有时可能会有一些地方要求用户在执行某些操作或将用户重定向到应用程序的敏感区域之前确认其密码。Laravel 包括内置的中间件，使这个过程变得轻而易举。实现此功能需要定义两个路由：一个路由显示请求用户确认其密码的视图，另一个路由确认密码有效并将用户重定向到其预期目的地。\r\n\r\n> 技巧：以下文档讨论了如何直接与 Laravel 的密码确认功能集成。但是，如果您想更快地开始使用， [Laravel 应用入门工具箱](/docs/laravel/9.x/starter-kits) 包含对此功能的支持！\r\n\r\n\r\n\r\n<a name=\"password-confirmation-configuration\"></a>\r\n### 配置\r\n\r\n确认密码后，用户在三个小时内不会被要求再次确认密码。但是，你可以通过更改应用程序 `config/auth.php` 中的 `password_timeout` 配置值来配置重新提示用户输入密码之前的时长。\r\n\r\n<a name=\"password-confirmation-routing\"></a>\r\n### 路由\r\n\r\n<a name=\"the-password-confirmation-form\"></a>\r\n#### 密码确认表单\r\n\r\n首先，我们将定义一个路由以显示请求用户确认其密码的视图：\r\n\r\n    Route::get('/confirm-password', function () {\r\n        return view('auth.confirm-password');\r\n    })->middleware('auth')->name('password.confirm');\r\n\r\n如您所料，此路由返回的视图应该有一个包含 `password` 字段的表单。此外，可以随意在视图中包含说明用户正在进入应用程序的受保护区域并且必须确认其密码的文本。\r\n\r\n<a name=\"confirming-the-password\"></a>\r\n#### 确认密码\r\n\r\n接下来，我们将定义一个路由来处理来自「confirm password」视图的表单请求。此路由将负责验证密码并将用户重定向到其预期目的地：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Illuminate\\Support\\Facades\\Redirect;\r\n\r\n    Route::post('/confirm-password', function (Request $request) {\r\n        if (! Hash::check($request->password, $request->user()->password)) {\r\n            return back()->withErrors([\r\n                'password' => ['The provided password does not match our records.']\r\n            ]);\r\n        }\r\n\r\n        $request->session()->passwordConfirmed();\r\n\r\n        return redirect()->intended();\r\n    })->middleware(['auth', 'throttle:6,1']);\r\n\r\n在继续之前，让我们更详细地检查一下这条路由。首先，请求的 `password` 字段被确定为实际匹配经过身份验证的用户的密码。如果密码有效，我们需要通知 Laravel 的 session，用户已经确认了他们的密码。 `passwordConfirmed` 方法将在用户会话中设置一个时间戳，Laravel 可以使用它来确定用户上次确认密码的时间。最后，我们可以将用户重定向到他们想要的目的地。\r\n\r\n\r\n\r\n<a name=\"password-confirmation-protecting-routes\"></a>\r\n### 保护路由\r\n\r\n你应该确保为执行需要最近密码确认的操作的任何路由分配 `password.confirm` 中间件。此中间件包含在 Laravel 的默认安装中，并将自动在 session 中存储用户的预期目的地，以便用户在确认密码后可以重定向到该位置。在 session 中存储用户的预期目的地之后，中间件将用户重定向到 `password.confirm` 的 [命名路由](/docs/laravel/9.x/routing#named-routes):\r\n\r\n    Route::get('/settings', function () {\r\n        // ...\r\n    })->middleware(['password.confirm']);\r\n\r\n    Route::post('/settings', function () {\r\n        // ...\r\n    })->middleware(['password.confirm']);\r\n\r\n<a name=\"adding-custom-guards\"></a>\r\n## 添加自定义的看守器\r\n\r\n你可以使用 `Auth` facade 上的 `extend` 方法定义自己的身份验证看守器。你应该在 [服务提供器](/docs/laravel/9.x/providers) 中调用 `extend` 方法。 由于 Laravel 已经附带了 `AuthServiceProvider`，因此我们可以将代码放置在该提供程序中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Services\\Auth\\JwtGuard;\r\n    use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    class AuthServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意的身份验证和身份授权的服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            $this->registerPolicies();\r\n\r\n            Auth::extend('jwt', function ($app, $name, array $config) {\r\n                // 返回 Illuminate\\Contracts\\Auth\\Guard 的实例 ...\r\n\r\n                return new JwtGuard(Auth::createUserProvider($config['provider']));\r\n            });\r\n        }\r\n    }\r\n\r\n正如你在上面的示例中所看到的，传递给 `extend` 方法的回调应该返回 `Illuminate\\Contracts\\Auth\\Guard` 的实例。此接口包含一些方法，你需要实现这些方法来定义自定义看守器。一旦你的自定义看守器被定义，你就可以在你的应用程序 `auth.php` 配置文件的 `guards` 配置中引用该看守器：\r\n\r\n    'guards' => [\r\n        'api' => [\r\n            'driver' => 'jwt',\r\n            'provider' => 'users',\r\n        ],\r\n    ],\r\n\r\n\r\n\r\n<a name=\"closure-request-guards\"></a>\r\n### 闭包请求看守器\r\n\r\n实现自定义的、基于 HTTP 请求的身份验证系统的最简单方法是使用 `Auth::viaRequest` 方法。此方法允许你使用单个闭包快速定义身份验证过程。\r\n\r\n首先，请在您的 `AuthServiceProvider` 的 `boot` 方法中调用 `Auth::viaRequest` 方法。 `VIASRequest` 方法接受身份验证驱动程序名称作为其第一个参数。此名称可以是描述自定义看守器的任何字符串。传递给方法的第二个参数应该是一个闭包，该闭包接收传入的 HTTP 请求并返回用户实例，或者，如果验证失败返回 `null`:\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    /**\r\n     * 注册任何应用程序验证 / 授权服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n        Auth::viaRequest('custom-token', function (Request $request) {\r\n            return User::where('token', $request->token)->first();\r\n        });\r\n    }\r\n\r\n一旦你定义自定义身份验证驱动程序，就可以将其配置为 `auth.php` 配置文件：\r\n\r\n    'guards' => [\r\n        'api' => [\r\n            'driver' => 'custom-token',\r\n        ],\r\n    ],\r\n\r\n<a name=\"adding-custom-user-providers\"></a>\r\n## 添加自定义的用户提供器\r\n\r\n如果不使用传统的关系数据库来存储用户，则需要使用自己的身份验证用户提供程序来扩展 Laravel 。 我们将使用 `Auth` facade 上的 `provider` 方法来定义自定义用户提供器。提供器解析器应返回 `Illuminate\\Contracts\\Auth\\UserProvider` 的实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Extensions\\MongoUserProvider;\r\n    use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    class AuthServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序验证 / 授权服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            $this->registerPolicies();\r\n\r\n            Auth::provider('mongo', function ($app, array $config) {\r\n                // 返回 illighte\\Contracts\\Auth\\UserProvider 的实例...\r\n\r\n                return new MongoUserProvider($app->make('mongo.connection'));\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n\r\n使用 `provider` 方法注册提供程序后，你可以在  `auth.php` 配置文件中切换到新的提供程序。 首先，定义一个使用新驱动程序的 `provider` :\r\n\r\n    'providers' => [\r\n        'users' => [\r\n            'driver' => 'mongo',\r\n        ],\r\n    ],\r\n\r\n最后，你可以在 `guards` 配置中引用此提供程序：\r\n\r\n    'guards' => [\r\n        'web' => [\r\n            'driver' => 'session',\r\n            'provider' => 'users',\r\n        ],\r\n    ],\r\n\r\n<a name=\"the-user-provider-contract\"></a>\r\n### 用户提供器契约\r\n\r\n`Illuminate\\Contracts\\Auth\\UserProvider` 实现负责从持久性存储系统（如 MySQL、MongoDB 等）中提取 `Illuminate\\Contracts\\Auth\\Authenticatable` 实例。无论用户数据是如何存储的，这两个接口可以保障 Laravel 身份验证机制持续工作，或者可以使用任意类型的类来表示经过身份验证的用户：\r\n\r\n让我们看一下 `Illuminate\\Contracts\\Auth\\UserProvider` 契约：\r\n\r\n    <?php\r\n\r\n    namespace Illuminate\\Contracts\\Auth;\r\n\r\n    interface UserProvider\r\n    {\r\n        public function retrieveById($identifier);\r\n        public function retrieveByToken($identifier, $token);\r\n        public function updateRememberToken(Authenticatable $user, $token);\r\n        public function retrieveByCredentials(array $credentials);\r\n        public function validateCredentials(Authenticatable $user, array $credentials);\r\n    }\r\n\r\n`retrieveById` 函数通常接收表示用户的主键，例如 MySQL 数据库中的自动递增 ID。方法应检索并返回与 ID 匹配的 `Authenticatable` 实现。\r\n\r\n`retrieveByToken` 函数通过用户唯一的 `$identifier` 和 「记住我」 `$token` 检索用户，通常存储在数据库列中，如 `remember_token` 。与前面的方法一样，应该通过此方法返回具有匹配令牌值的 `Authenticatable` 实现。\r\n\r\n`updateMemberToken` 方法使用新的 `$token` 更新 `$user` 实例的 `remember_token`。在成功的「记住我」身份验证尝试或用户注销时，将为用户分配新令牌。\r\n\r\n\r\n\r\n`retrieveByCredentials` 方法在尝试对应用程序进行身份验证时接收传递给 `Auth::attempt` 方法的凭据数组。然后，该方法应该为匹配这些凭证的用户「查询」底层持久存储。通常，此方法将运行一个带有「where」条件的查询，该条件搜索「username」与 `$credentials['username']` 值匹配的用户记录。该方法应返回 `Authenticatable` 的实例。 **此方法不应尝试执行任何密码验证或身份验证。**\r\n\r\n`validateCredentials` 方法应将给定的 `$user` 与 `$credentials` 进行比较，以对用户进行身份验证。例如，此方法通常使用 `Hash::check` 方法将 `$user->getAuthPassword()` 的值与 `$credentials['password']` 的值进行比较。此方法应返回 `true` 或 `false`，指示密码是否有效。\r\n\r\n<a name=\"the-authenticatable-contract\"></a>\r\n### Authenticatable 契约\r\n\r\n我们已经研究了 `UserProvider` 上的每个方法，现在让我们看看 `Authenticatable` 契约。请记住，`UserProvider` 应该从 `retrieveById`、`retrieveByToken` 和 `retrieveByCredentials` 方法返回此接口的实现：\r\n\r\n    <?php\r\n\r\n    namespace Illuminate\\Contracts\\Auth;\r\n\r\n    interface Authenticatable\r\n    {\r\n        public function getAuthIdentifierName();\r\n        public function getAuthIdentifier();\r\n        public function getAuthPassword();\r\n        public function getRememberToken();\r\n        public function setRememberToken($value);\r\n        public function getRememberTokenName();\r\n    }\r\n\r\n这个接口很简单。`getAuthIdentifierName` 方法应返回用户的「主键」字段的名称， `getAuthIdentifier` 方法应返回用户的「主键」。当使用 MySQL 后端时，这可能是分配给用户记录的自动递增主键。`getAuthPassword` 方法应返回用户的进行哈希后的密码。\r\n\r\n\r\n\r\n此接口允许身份验证系统与任何「用户」类一起工作，而不管你使用的是哪个 ORM 或存储抽象层。默认情况下，Laravel 在实现此接口的 `app/Models` 目录中包含一个 `App\\Models\\User` 类。\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\n在身份验证过程中，Laravel 调度各种 [事件](/docs/laravel/9.x/events) 。你可以在 `EventServiceProvider` 中将监听器附加到这些事件上：:\r\n\r\n    /**\r\n     * 应用监听器的对应表\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Auth\\Events\\Registered' => [\r\n            'App\\Listeners\\LogRegisteredUser',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Attempting' => [\r\n            'App\\Listeners\\LogAuthenticationAttempt',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Authenticated' => [\r\n            'App\\Listeners\\LogAuthenticated',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Login' => [\r\n            'App\\Listeners\\LogSuccessfulLogin',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Failed' => [\r\n            'App\\Listeners\\LogFailedLogin',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Validated' => [\r\n            'App\\Listeners\\LogValidated',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Verified' => [\r\n            'App\\Listeners\\LogVerified',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Logout' => [\r\n            'App\\Listeners\\LogSuccessfulLogout',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\CurrentDeviceLogout' => [\r\n            'App\\Listeners\\LogCurrentDeviceLogout',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\OtherDeviceLogout' => [\r\n            'App\\Listeners\\LogOtherDeviceLogout',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Lockout' => [\r\n            'App\\Listeners\\LogLockout',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\PasswordReset' => [\r\n            'App\\Listeners\\LogPasswordReset',\r\n        ],\r\n    ];\r\n\r\n","p":"docs/authentication.html"},{"t":"authorization (用户授权)","d":"# 用户授权\r\n\r\n- [简介](#introduction)\r\n- [拦截器](#gates)\r\n    - [编写拦截器](#writing-gates)\r\n    - [授权动作](#authorizing-actions-via-gates)\r\n    - [拦截器响应](#gate-responses)\r\n    - [拦截器拦截检查](#intercepting-gate-checks)\r\n    - [内联授权](#inline-authorization)\r\n- [创建策略](#creating-policies)\r\n    - [生成策略](#generating-policies)\r\n    - [注册策略](#registering-policies)\r\n- [编辑策略](#writing-policies)\r\n    - [策略的模型](#policy-methods)\r\n    - [策略的返回](#policy-responses)\r\n    - [不使用模型的方法](#methods-without-models)\r\n    - [访客和用户](#guest-users)\r\n    - [策略的过滤器](#policy-filters)\r\n- [使用策略进行授权操作](#authorizing-actions-using-policies)\r\n    - [通过用户模型的方式](#via-the-user-model)\r\n    - [通过控制器辅助函数的方式](#via-controller-helpers)\r\n    - [通过中间件的方式](#via-middleware)\r\n    - [通过前端的方式](#via-blade-templates)\r\n    - [以附加形式提供给上下文调用的方式](#supplying-additional-context)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n除了提供内置的 [authentication](/docs/laravel/9.x/authentication) （身份验证） 服务外，Laravel 还提供了一种可以很简单就进行使用的方法，来对用户与资源的授权关系进行管理。 它很安全，即使用户已经通过了「身份验证（authentication)」, 用户也可能无权对应用程序中重要的模型或数据库记录进行删除或更改。简单、条理化的系统性，是 Laravel 对授权管理的特性。\r\n\r\nLaravel 主要提供了两种授权操作的方法: [拦截器](#gates) 和 [策略](#creating-policies )。可以把拦截器（gates）和策略（policies）想象成路由和控制器。拦截器（Gates）提供了一种轻便的基于闭包函数的授权方法，像是路由。而策略（policies)，就像是一个控制器，对特定模型或资源，进行分组管理的逻辑规则。 在本文档中，我们将首先探讨拦截器（gates），然后研究策略（policies)。\r\n\r\n您在构建应用程序时，不用为是仅仅使用拦截器（gates）或是仅仅使用策略（policies）而担心，并不需要在两者中进行唯一选择。大多数的应用程序都同时包含两个方法，并且同时使用两者，能够更好的进行工作。拦截器（gates），更适用于没有与任何模型或资源有关的授权操作，例如查看管理员仪表盘。与之相反，当您希望为特定的模型或资源进行授权管理时，应该使用策略（policies) 方法。\r\n\r\n\r\n\r\n<a name=\"gates\"></a>\r\n## 拦截器 (Gates)\r\n\r\n<a name=\"writing-gates\"></a>\r\n### 编写拦截器（Gates）\r\n\r\n> 注意：通过理解拦截器（Gates），是一个很好的学习 Laravel 授权特性的基础知识的方法。同时，考虑到 Laravel 应用程序的健壮性，应该结合使用策略 ([policies](#creating-policies)) 来组织授权规则。\r\n\r\n拦截器（Gates）是用来确定用户是否有权执行给定操作的闭包函数。默认条件下，拦截器（Gates）的使用，是在 `App\\Providers\\AuthServiceProvider` 类中的 `boot` 函数里来规定 `Gate` 规则。拦截器（Gates）始终接收用户实例为其第一个参数，并且可以选择性的接收其他参数，例如相关的 Eloquent 模型。\r\n\r\n在下面的例子中，我们将定义一个拦截器（Gates)，并通过调用 `App\\Models\\Post` 类，来实现结合用户的 POST 请求，命中给定的规则。拦截器（Gates）将通过比较用户的 `id` ，和 POST 请求中的 `user_id` 来实现这个目标：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    /**\r\n     * 注册任何需要身份验证、授权服务的行为\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n        Gate::define('update-post', function (User $user, Post $post) {\r\n            return $user->id === $post->user_id;\r\n        });\r\n    }\r\n\r\n像是在控制器中操作一样，也可以直接使用类，进行回调数组，完成拦截器（Gates）的定义：\r\n\r\n    use App\\Policies\\PostPolicy;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    /**\r\n     * 注册任何需要身份验证、授权服务的行为\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n        Gate::define('update-post', [PostPolicy::class, 'update']);\r\n    }\r\n\r\n<a name=\"authorizing-actions-via-gates\"></a>\r\n### 行为授权控制\r\n\r\n如果需要通过拦截器（Gates）来对行为进行授权控制，您可以通过调用 `Gate` 中的 `allows` 或 `denies` 方法。请注意，在使用过程中，您不需要将已经通过身份验证的用户信息传递给这些方法。 Laravel 将会自动把用户信息传递给拦截器（Gates）。以下是一个典型的，在控制器中使用拦截器（Gates）进行行为授权控制的例子：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 更新给定的帖子\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\App\\Models\\Post  $post\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function update(Request $request, Post $post)\r\n        {\r\n            if (! Gate::allows('update-post', $post)) {\r\n                abort(403);\r\n            }\r\n\r\n            // 更新帖子...\r\n        }\r\n    }\r\n\r\n\r\n\r\n如果您需要判断某个用户，是否有权执行某个行为，您可以在 `Gate` 门面中，使用 `forUser` 方法：\r\n\r\n    if (Gate::forUser($user)->allows('update-post', $post)) {\r\n        // 这个用户可以提交update...\r\n    }\r\n\r\n    if (Gate::forUser($user)->denies('update-post', $post)) {\r\n        // 这个用户不可以提交update...\r\n    }\r\n\r\n您还可以通过 `any` 或 `none` 方法来一次性授权多个行为:\r\n\r\n    if (Gate::any(['update-post', 'delete-post'], $post)) {\r\n        // 用户可以提交update和delete...\r\n    }\r\n\r\n    if (Gate::none(['update-post', 'delete-post'], $post)) {\r\n        // 用户不可以提交update和delete...\r\n    }\r\n\r\n<a name=\"authorizing-or-throwing-exceptions\"></a>\r\n#### 未通过授权时的抛出异常\r\n\r\n`Illuminate\\Auth\\Access\\AuthorizationException` 中准备了 HTTP 的 403 响应。您可以使用 `Gate` 门面中的 `authorize` 方法，来规定如果用户进行了未授权的行为时，触发 `AuthorizationException` 实例 ，该实例会自动转换返回为 HTTP 的 403 响应:\r\n\r\n    Gate::authorize('update-post', $post);\r\n\r\n    // 行为已获授权...\r\n\r\n<a name=\"gates-supplying-additional-context\"></a>\r\n#### 上下文的值传递\r\n\r\n能够用于拦截器（Gates）的授权方法，(`allows`，`denies`，`check`，`any`，`none`， `authorize`，`can`，`cannot`) 和在前端进行的授权方法 [Blade 指令](#via-blade-templates) (`@can`，`@cannot`，`@canany`) 在第 2 个参数中，可以接收数组。这些数组元素作为参数传递给拦截器（Gates） ，在做出授权决策时可用于其他上下文:\r\n\r\n    use App\\Models\\Category;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::define('create-post', function (User $user, Category $category, $pinned) {\r\n        if (! $user->canPublishToGroup($category->group)) {\r\n            return false;\r\n        } elseif ($pinned && ! $user->canPinPosts()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    });\r\n\r\n    if (Gate::check('create-post', [$category, $pinned])) {\r\n        // 用户可以请求create...\r\n    }\r\n\r\n\r\n\r\n<a name=\"gate-responses\"></a>\r\n### 拦截器（Gates）返回（Responses）\r\n\r\n到目前为止，我们只学习了拦截器（Gates）中返回布尔值的简单操作。但是，有时您需要的返回可能更复杂，比如错误消息。所以，您可以尝试使用 `Illuminate\\Auth\\Access\\Response` 来构建您的拦截器（Gates）：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Access\\Response;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::define('edit-settings', function (User $user) {\r\n        return $user->isAdmin\r\n                    ? Response::allow()\r\n                    : Response::deny('You must be an administrator.');\r\n    });\r\n\r\n您希望从拦截器（Gates）中返回响应时，使用 `Gate::allows` 方法，将仅返回一个简单的布尔值；同时，您还可以使用 `Gate::inspect` 方法来返回拦截器（Gates）中的所有响应值：\r\n\r\n    $response = Gate::inspect('edit-settings');\r\n\r\n    if ($response->allowed()) {\r\n        // 行为进行授权...\r\n    } else {\r\n        echo $response->message();\r\n    }\r\n\r\n在使用 `Gate::authorize` 方法时，如果操作未被授权，仍然会触发 `AuthorizationException` , 用户验证（authorization）响应提供的错误消息，将传递给 HTTP 响应：\r\n\r\n    Gate::authorize('edit-settings');\r\n\r\n    // 行为进行授权...\r\n\r\n<a name=\"intercepting-gate-checks\"></a>\r\n### 拦截器（Gates）优先级\r\n\r\n有时，您可能希望将所有权限授予特定用户。您可以使用 `before` 方法。该方法将定义该授权拦截规则，优先于所有其他授权拦截规则前执行：\r\n\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::before(function ($user, $ability) {\r\n        if ($user->isAdministrator()) {\r\n            return true;\r\n        }\r\n    });\r\n\r\n如果 `before` 返回的是非 null 结果，则该返回将会被视为最终的检查结果。\r\n\r\n您还可以使用 `after` 方法，来定义在所有授权拦截规则执行后，再次进行授权拦截规则判定：\r\n\r\n    Gate::after(function ($user, $ability, $result, $arguments) {\r\n        if ($user->isAdministrator()) {\r\n            return true;\r\n        }\r\n    });\r\n\r\n\r\n\r\n类似于 `before` 方法，如果 `after` 闭包返回非空结果，则该结果将被视为授权检查的结果。\r\n\r\n<a name=\"inline-authorization\"></a>\r\n### 内联授权\r\n\r\n有时，你可能希望确定当前经过身份验证的用户是否有权执行给定操作，而无需编写与该操作对应的专用拦截器。Laravel 允许你通过 `Gate::allowIf` 和 `Gate::denyIf` 方法执行这些类型的「内联」授权检查：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Auth;\r\n\r\nGate::allowIf(fn ($user) => $user->isAdministrator());\r\n\r\nGate::denyIf(fn ($user) => $user->banned());\r\n```\r\n\r\n如果该操作未授权或当前没有用户经过身份验证，Laravel 将自动抛出 `Illuminate\\Auth\\Access\\AuthorizationException` 异常。 `AuthorizationException` 的实例会被 Laravel 的异常处理程序自动转换为 403 HTTP 响应：\r\n\r\n<a name=\"creating-policies\"></a>\r\n## 新建策略\r\n\r\n<a name=\"generating-policies\"></a>\r\n### 生成策略\r\n\r\n策略是围绕特定模型或资源组织授权逻辑的类。例如，如果你的应用程序是博客，可能有一个 `App\\Models\\Post` 模型和一个相应的 `App\\Policies\\PostPolicy` 来授权用户操作，例如创建或更新帖子。\r\n\r\n你可以使用 `make:policy` Artisan 命令生成策略。生成的策略将放置在 `app/Policies` 目录中。如果应用程序中不存在此目录，Laravel 将自动创建：\r\n\r\n```shell\r\nphp artisan make:policy PostPolicy\r\n```\r\n\r\n`make:policy` 命令将生成一个空的策略类。如果要生成一个包含与查看、创建、更新和删除资源相关的示例策略方法的类，可以在执行命令时提供一个 `--model` 选项：\r\n\r\n```shell\r\nphp artisan make:policy PostPolicy --model=Post\r\n```\r\n\r\n\r\n\r\n<a name=\"registering-policies\"></a>\r\n### 注册策略\r\n\r\n创建了策略类之后，还需要对其进行注册。注册策略是告知 Laravel 在授权针对给定模型类型的操作时使用哪个策略。\r\n\r\n新的 Laravel 应用程序中包含的 `App\\Providers\\AuthServiceProvider` 包含一个 `policies` 属性，它将 Eloquent 模型映射到其相应的策略。 注册策略将指示 Laravel 在授权针对给定 Eloquent 模型的操作时使用哪个策略：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Policies\\PostPolicy;\r\n    use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    class AuthServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 应用程序的策略映射。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $policies = [\r\n            Post::class => PostPolicy::class,\r\n        ];\r\n\r\n        /**\r\n         * 注册任何应用程序身份验证/授权服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            $this->registerPolicies();\r\n\r\n            //\r\n        }\r\n    }\r\n\r\n<a name=\"policy-auto-discovery\"></a>\r\n#### 策略自动发现\r\n\r\n只要模型和策略遵循标准的 Laravel 命名约定，Laravel 就可以自动发现策略，而不是手动注册模型策略。具体来说，策略必须位于包含模型的目录或其上方的「Policies」目录中。 因此，例如，模型可以放置在 `app/Models` 目录中，而策略可以放置在 `app/Policies` 目录中。在这种情况下，Laravel 将检查 `app/Models/Policies` 然后 `app/Policies` 中的策略。此外，策略名称必须与模型名称匹配并具有「策略」后缀。 因此，`User` 模型将对应于`UserPolicy` 策略类。\r\n\r\n如果要自定义策略的发现逻辑，可以使用 `Gate::guessPolicyNamesUsing` 方法注册自定义策略发现回调。通常，应该从应用程序的 `AuthServiceProvider` 的 `boot` 方法调用此方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::guessPolicyNamesUsing(function ($modelClass) {\r\n        // Return the name of the policy class for the given model...\r\n    });\r\n\r\n> 注意：在 `AuthServiceProvider` 中显式映射的任何策略将优先于任何可能自动发现的策略。\r\n\r\n\r\n\r\n<a name=\"writing-policies\"></a>\r\n## 编写策略\r\n\r\n<a name=\"policy-methods\"></a>\r\n### 策略方法\r\n\r\n注册策略类后，可以为其授权的每个操作添加方法。例如，让我们在 `PostPolicy` 上定义一个 `update` 方法，该方法确定给定的 `App\\Models\\User` 是否可以更新给定的 `App\\Models\\Post` 实例。\r\n\r\n该 `update` 方法将接收一个 `User` 和一个 `Post` 实例作为其参数，并应返回 `true` 或 `false` ，指示用户是否有权更新给定的 `Post`。因此，在本例中，我们将验证用户的 `id` 是否与 post 上的 `user_id` 匹配：\r\n\r\n    <?php\r\n\r\n    namespace App\\Policies;\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    class PostPolicy\r\n    {\r\n        /**\r\n         * 确定用户是否可以更新给定的帖子\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @param  \\App\\Models\\Post  $post\r\n         * @return bool\r\n         */\r\n        public function update(User $user, Post $post)\r\n        {\r\n            return $user->id === $post->user_id;\r\n        }\r\n    }\r\n\r\n你可以继续根据需要为策略授权的各种操作定义其他方法。例如，你可以定义 `view` 或 `delete` 方法来授权各种与 `Post` 相关的操作，但请记住，你可以自由地为策略方法命名任何你喜欢的名称。\r\n\r\n如果你在 Artisan 控制台生成策略时使用了 `--model` 选项，它将包含用于 `viewAny`，`view`， `create`，`update`，`delete`，`restore` 和 `forceDelete` 操作。\r\n\r\n> 技巧：所有策略都通过 Laravel [服务容器](/docs/laravel/9.x/container) 解析，允许你在策略的构造函数中键入任何需要的依赖项，以自动注入它们。\r\n\r\n\r\n\r\n<a name=\"policy-responses\"></a>\r\n### 策略响应\r\n\r\n到目前为止，我们只检查了返回简单布尔值的策略方法。但是，有时你可能希望返回更详细的响应，包括错误消息。为此，你可以从你的策略方法返回一个 `Illuminate\\Auth\\Access\\Response` 实例：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Access\\Response;\r\n\r\n    /**\r\n     * Determine if the given post can be updated by the user.\r\n     *\r\n     * @param  \\App\\Models\\User  $user\r\n     * @param  \\App\\Models\\Post  $post\r\n     * @return \\Illuminate\\Auth\\Access\\Response\r\n     */\r\n    public function update(User $user, Post $post)\r\n    {\r\n        return $user->id === $post->user_id\r\n                    ? Response::allow()\r\n                    : Response::deny('You do not own this post.');\r\n    }\r\n\r\n当从你的策略返回授权响应时，`Gate::allows` 方法仍将返回一个简单的布尔值；但是，你可以使用 `Gate::inspect` 方法来获取返回的完整授权响应：\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    $response = Gate::inspect('update', $post);\r\n\r\n    if ($response->allowed()) {\r\n        // The action is authorized...\r\n    } else {\r\n        echo $response->message();\r\n    }\r\n\r\n当使用 `Gate::authorize` 方法时，如果操作未被授权，该方法会抛出 `AuthorizationException`   ，授权响应提供的错误消息将传播到 HTTP 响应：\r\n\r\n    Gate::authorize('update', $post);\r\n\r\n    // 该操作已授权通过...\r\n\r\n<a name=\"methods-without-models\"></a>\r\n### 无需传递模型的方法\r\n\r\n一些策略方法只接收当前经过身份验证的用户实例，最常见的情况是给 `create` 方法做授权。例如，如果你正在创建一个博客，你可能希望确定一个用户是否被授权创建任何文章，在这种情况下，你的策略方法应该只期望接收一个用户实例：\r\n\r\n    /**\r\n     * 确定给定用户是否可以创建文件\r\n     *\r\n     * @param  \\App\\Models\\User  $user\r\n     * @return bool\r\n     */\r\n    public function create(User $user)\r\n    {\r\n        return $user->role == 'writer';\r\n    }\r\n\r\n\r\n\r\n<a name=\"guest-users\"></a>\r\n### Guest 用户\r\n\r\n默认情况下，如果传入的 HTTP 请求不是经过身份验证的用户发起的，那么所有的拦截器（gates）和策略（policies）会自动返回 `false` 。但是，你可以通过声明一个「optional」类型提示或为用户参数定义提供一个 `null` 默认值，从而允许这些授权检查通过你的拦截器（gates）和策略（policies）：\r\n\r\n    <?php\r\n\r\n    namespace App\\Policies;\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    class PostPolicy\r\n    {\r\n        /**\r\n         * 确定用户是否可以更新给定的文章\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @param  \\App\\Models\\Post  $post\r\n         * @return bool\r\n         */\r\n        public function update(?User $user, Post $post)\r\n        {\r\n            return optional($user)->id === $post->user_id;\r\n        }\r\n    }\r\n\r\n<a name=\"policy-filters\"></a>\r\n### 策略过滤器\r\n\r\n对于某些用户，您可能希望给他授权给定策略中的所有操作。为了实现这一点，你可以在策略上定义一个 `before` 方法。该 `before` 方法将在策略上的所有方法之前执行，这样就使您有机会在实际调用预期的策略方法之前就已经授权了操作。该功能常用于授权应用程序管理员来执行任何操作：\r\n\r\n    use App\\Models\\User;\r\n\r\n    /**\r\n     * 执行预先授权检查\r\n     *\r\n     * @param  \\App\\Models\\User  $user\r\n     * @param  string  $ability\r\n     * @return void|bool\r\n     */\r\n    public function before(User $user, $ability)\r\n    {\r\n        if ($user->isAdministrator()) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n如果你想拒绝特定类型用户的所有授权检查，那么你可以从 `before` 方法返回 `false` 。如果返回 `null` ，则授权检查将通过策略方法进行。\r\n\r\n> 注意：如果策略类中不包含名称与被检查能力的名称相匹配的方法，则不会调用策略类的 `before` 方法。\r\n\r\n\r\n<a name=\"authorizing-actions-using-policies\"></a>\r\n## 使用策略授权操作\r\n\r\n<a name=\"via-the-user-model\"></a>\r\n### 通过用户模型\r\n\r\nLaravel 应用程序中的 `App\\Models\\User` 型提供了两个用于授权操作的方法：`can` 和 `cannot`。 `can` 和 `cannot` 方法接收您希望授权的操作名称和相关模型。例如，让我们确定一个用户是否被授权更新给定的 `App\\Models\\Post` 模型，这通常在控制器方法中实现：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * Update the given post.\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\App\\Models\\Post  $post\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function update(Request $request, Post $post)\r\n        {\r\n            if ($request->user()->cannot('update', $post)) {\r\n                abort(403);\r\n            }\r\n\r\n            // Update the post...\r\n        }\r\n    }\r\n\r\n如果为给定模型 [注册了策略](#registering-policies) ，该 `can` 方法将自动调用适当的策略并返回布尔值；如果没有为模型注册策略，该 `can` 方法将尝试调用基于 Gate 的闭包，该闭包将匹配给定的操作名称。\r\n\r\n<a name=\"user-model-actions-that-dont-require-models\"></a>\r\n#### 不需要指定模型的操作\r\n\r\n请记住，某些操作可能对应着「不需要模型实例」的策略方法，比如 `create` 。在这些情况下，你可以将类名传递给 `can` 方法，类名将用于确定在授权操作时使用哪个策略：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * Create a post.\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            if ($request->user()->cannot('create', Post::class)) {\r\n                abort(403);\r\n            }\r\n\r\n            // Create the post...\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"via-controller-helpers\"></a>\r\n### 通过控制器辅助函数\r\n\r\n除了给 `App\\Models\\User` 模型提供了有用方法，Laravel 还给任何控制器提供了一个有用的  `authorize` 方法，这些控制器要继承（`extends`） `App\\Http\\Controllers\\Controller` 基类。\r\n\r\n与`can` 方法一样， `authorize` 方法接收您希望授权的操作名称和相关模型，如果该操作未被授权，该方法将抛出 `Illuminate\\Auth\\Access\\AuthorizationException` 异常，Laravel 的异常处理程序将自动将该异常转换为一个带有 403 状态码的 HTTP 响应：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 更新指定的博客文章\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\App\\Models\\Post  $post\r\n         * @return \\Illuminate\\Http\\Response\r\n         *\r\n         * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\r\n         */\r\n        public function update(Request $request, Post $post)\r\n        {\r\n            $this->authorize('update', $post);\r\n\r\n            // The current user can update the blog post...\r\n        }\r\n    }\r\n\r\n<a name=\"controller-actions-that-dont-require-models\"></a>\r\n#### 不需要指定模型的操作\r\n\r\n如前所述，一些策略方法 如`create` 不需要模型实例，在这些情况下，你应该给 `authorize` 方法传递一个类名，该类名将用来确定在授权操作时使用哪个策略：\r\n\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    /**\r\n     * Create a new blog post.\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return \\Illuminate\\Http\\Response\r\n     *\r\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\r\n     */\r\n    public function create(Request $request)\r\n    {\r\n        $this->authorize('create', Post::class);\r\n\r\n        // The current user can create blog posts...\r\n    }\r\n\r\n\r\n\r\n<a name=\"authorizing-resource-controllers\"></a>\r\n#### 授权资源控制器\r\n\r\n如果你正在使用 [资源控制器](/docs/laravel/9.x/controllers#resource-controllers)，你可以在控制器的构造方法中使用 `authorizeResource` 方法，该方法将把适当的 `can` 中间件定义附加到资源控制器的方法上。\r\n\r\n该 `authorizeResource` 方法的第一个参数是模型的类名，第二个参数是包含模型 ID 的 路由/请求参数的名称。你应该确保你的 [资源控制器](/docs/laravel/9.x/controllers#resource-controllers) 是使用 `--model` 标志创建的，这样它才具有所需的方法签名和类型提示。\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 创建控制器实例\r\n         *\r\n         * @return void\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->authorizeResource(Post::class, 'post');\r\n        }\r\n    }\r\n\r\n以下控制器方法将映射到其相应的策略方法。当请求被路由到给定的控制器方法时，会在控制器方法执行之前自动调用相应的策略方法：\r\n\r\n| 控制器方法 | 策略方法 |\r\n| --- | --- |\r\n| index | viewAny |\r\n| show | view |\r\n| create | create |\r\n| store | create |\r\n| edit | update |\r\n| update | update |\r\n| destroy | delete |\r\n\r\n> 技巧：你可以使用带有 `make:policy` 带有 `--model` 选项的命令，快速的为给定模型生成一个策略类： `php artisan make:policy PostPolicy --model=Post`。\r\n\r\n<a name=\"via-middleware\"></a>\r\n### 通过中间件\r\n\r\nLaravel 包含一个中间件，可以在传入的请求到达路由或控制器之前对操作进行授权。默认情况下， `Illuminate\\Auth\\Middleware\\Authorize` 中间件会在 `App\\Http\\Kernel` 中的 `can` 键中被指定。让我们来看一个使用 `can` 中间件授权用户更新博客文章的例子：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    Route::put('/post/{post}', function (Post $post) {\r\n        // The current user may update the post...\r\n    })->middleware('can:update,post');\r\n\r\n\r\n\r\n在这个例子中，我们给 `can` 中间件传递了两个参数。第一个是我们希望授权操作的名称，第二个是我们希望传递给策略方法的路由参数。在这个例子中，当我们使用了 [隐式模型绑定](/docs/laravel/9.x/routing#implicit-binding) 后，一个 `App\\Models\\Post` 模型就将被传递给对应的策略方法。如果用户没有被授权执行给定操作的权限，那么中间件将会返回一个带有 403 状态码的 HTTP 响应。\r\n\r\n为了方便起见，你也可以使用 `can` 方法将 `can` 中间件绑定到你的路由上：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    Route::put('/post/{post}', function (Post $post) {\r\n        // 当前用户可以更新文章\r\n    })->can('update', 'post');\r\n\r\n<a name=\"middleware-actions-that-dont-require-models\"></a>\r\n#### 不需要指定模型的操作\r\n\r\n同样的，一些策略方法不需要模型实例，比如 `create` 。在这些情况下，你可以给中间件传递一个类名。这个类名将用来确定在授权操作时使用哪个策略：\r\n\r\n    Route::post('/post', function () {\r\n        // 当前用户可以创建文章\r\n    })->middleware('can:create,App\\Models\\Post');\r\n\r\n在一个中间件中定义整个类名会变得难以维护。因此，你也可以选择使用 `can` 方法将 `can` 中间件绑定到你的路由上：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    Route::post('/post', function () {\r\n        // 当前用户可以创建文章\r\n    })->can('create', Post::class);\r\n\r\n<a name=\"via-blade-templates\"></a>\r\n### 通过 Blade 模板\r\n\r\n\r\n\r\n当编写 Blade 模板时，你可能希望只展示给用户有权限操作的数据。例如，你可能希望当用户具有更新文章的权限时才展示更新博客文章的表单。在这种情况下，你可以使用 `@can` 和 `@cannot` 指令：\r\n\r\n```blade\r\n@can('update', $post)\r\n    <!-- 当前用户可更新的文章 -->\r\n@elsecan('create', App\\Models\\Post::class)\r\n    <!-- 当前用户可创建新文章 -->\r\n@else\r\n    <!-- ... -->\r\n@endcan\r\n\r\n@cannot('update', $post)\r\n    <!-- 当前用户不可更新的文章 -->\r\n@elsecannot('create', App\\Models\\Post::class)\r\n    <!--  当前用户不可创建新文章 -->\r\n@endcannot\r\n```\r\n\r\n这些指令是编写 `@if` 和 `@unless` 语句的快捷方式。上面的 `@can` 和 `@cannot` 语句相当于下面的语句：\r\n\r\n```blade\r\n@if (Auth::user()->can('update', $post))\r\n    <!-- 当前用户可更新的文章 -->\r\n@endif\r\n\r\n@unless (Auth::user()->can('update', $post))\r\n    <!-- 当前用户不可更新的文章 -->\r\n@endunless\r\n```\r\n\r\n你还可以确定一个用户是否被授权从给定的操作数组中执行任何操作，要做到这一点，可以使用 `@canany` 指令：\r\n\r\n```blade\r\n@canany(['update', 'view', 'delete'], $post)\r\n    <!--当前用户可以更新、查看、删除文章 -->\r\n@elsecanany(['create'], \\App\\Models\\Post::class)\r\n    <!-- 当前用户可以创建新文章 -->\r\n@endcanany\r\n```\r\n\r\n<a name=\"blade-actions-that-dont-require-models\"></a>\r\n#### 不需要执行模型的操作\r\n\r\n像大多数其他授权方法一样，如果操作不需要模型实例，你可以给 `@can` 和 `@cannot` 指令传递一个类名：\r\n\r\n```blade\r\n@can('create', App\\Models\\Post::class)\r\n    <!--当前用户可以创建文章 -->\r\n@endcan\r\n\r\n@cannot('create', App\\Models\\Post::class)\r\n    <!-- 当前用户不能创建文章 -->\r\n@endcannot\r\n```\r\n\r\n\r\n\r\n<a name=\"supplying-additional-context\"></a>\r\n### 提供额外的上下文\r\n\r\n在使用策略授权操作时，可以将数组作为第二个参数传递给授权函数和辅助函数。数组中的第一个元素用于确定应该调用哪个策略，其余的数组元素作为参数传递给策略方法，并可在作出授权决策时用于额外的上下文中。例如，考虑下面的 `PostPolicy` 方法定义，它包含一个额外的 `$category` 参数：\r\n\r\n    /**\r\n     * 确认用户是否可以更新给定的文章\r\n     *\r\n     * @param  \\App\\Models\\User  $user\r\n     * @param  \\App\\Models\\Post  $post\r\n     * @param  int  $category\r\n     * @return bool\r\n     */\r\n    public function update(User $user, Post $post, int $category)\r\n    {\r\n        return $user->id === $post->user_id &&\r\n               $user->canUpdateCategory($category);\r\n    }\r\n\r\n当尝试确认已验证过的用户是否可以更新给定的文章时，我们可以像这样调用此策略方法：\r\n\r\n    /**\r\n     * 更新给定的博客文章\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @param  \\App\\Models\\Post  $post\r\n     * @return \\Illuminate\\Http\\Response\r\n     *\r\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\r\n     */\r\n    public function update(Request $request, Post $post)\r\n    {\r\n        $this->authorize('update', [$post, $request->category]);\r\n\r\n        // 当前用户可以更新博客文章\r\n    }\r\n\r\n","p":"docs/authorization.html"},{"t":"verification (Email 认证)","d":"# Email 认证\r\n\r\n- [简介](#introduction)\r\n    - [模型准备](#model-preparation)\r\n    - [数据库准备](#database-preparation)\r\n- [路由](#verification-routing)\r\n    - [Email 认证通知](#the-email-verification-notice)\r\n    - [Email 认证处理](#the-email-verification-handler)\r\n    - [重新发送 Email 认证](#resending-the-verification-email)\r\n    - [保护路由](#protecting-routes)\r\n- [自定义](#customization)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n很多 Web 应用会要求用户在使用之前进行 Email 地址验证。Laravel 不会强迫你在每个应用中重复实现它，而是提供了便捷的方法来发送和校验电子邮件的验证请求。\r\n\r\n> 技巧：想快速上手吗？你可以在全新的应用中安装 [Laravel 应用入门套件](/docs/laravel/9.x/starter-kits) 。入门套件将帮助你搭建整个身份验证系统，包括电子邮件验证支持。\r\n\r\n<a name=\"model-preparation\"></a>\r\n### 模型准备\r\n\r\n在开始之前，需要检查你的 `App\\Models\\User` 模型是否实现了 `Illuminate\\Contracts\\Auth\\MustVerifyEmail` 契约：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Contracts\\Auth\\MustVerifyEmail;\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable implements MustVerifyEmail\r\n    {\r\n        use Notifiable;\r\n\r\n        // ...\r\n    }\r\n\r\n一旦这一接口被添加到模型中，新注册的用户将自动收到一封包含电子邮件验证链接的电子邮件。检查你的 `App\\Providers\\EventServiceProvider` 可以看到，Laravel 已经为 `Illuminate\\Auth\\Events\\Registered` 事件附加了一个 `SendEmailVerificationNotification` [监听器](/docs/laravel/9.x/events) 。\r\n\r\n如果在应用中你没有使用 [入门套件](/docs/laravel/9.x/starter-kits) 而是手动实现的注册，你需要确保在用户注册成功后手动分发 `Illuminate\\Auth\\Events\\Registered` 事件：\r\n\r\n    use Illuminate\\Auth\\Events\\Registered;\r\n\r\n    event(new Registered($user));\r\n\r\n\r\n\r\n<a name=\"database-preparation\"></a>\r\n### 数据库准备\r\n\r\n接下来，你的 `user` 表必须包含一个 `email_verified_at` 字段用来存储 Email 地址通过验证的时间。默认情况下，Laravel 框架中 `users` 表的数据迁移已经包含了这个字段。所以，您需要做的就只是执行数据库迁移：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"verification-routing\"></a>\r\n## 路由\r\n\r\n为了实现完整的电子邮件验证流程，你将需要定义三个路由。首先，需要定义一个路由向用户显示通知，告诉他们应该点击 Laravel 注册后向他们发送邮件中的验证链接。\r\n\r\n其次，需要一个路由来处理用户点击邮件中验证链接时发来的请求。\r\n\r\n第三，如果用户没有收到验证邮件，则需要一条路由来重新发送验证邮件。\r\n\r\n<a name=\"the-email-verification-notice\"></a>\r\n### Email 认证通知\r\n\r\n正如上面所说，应该定义一条路由，该路由将返回一个视图，引导用户点击注册后 Laravel 发送给他们邮件中的验证链接。当用户尝试访问网站的其它页面而没有先完成邮箱验证时，将向用户显示此视图。请注意，只要您的 `App\\Models\\User` 模型实现了 `MustVerifyEmail` 接口，就会自动发送电子邮件给用户。\r\n\r\n    Route::get('/email/verify', function () {\r\n        return view('auth.verify-email');\r\n    })->middleware('auth')->name('verification.notice');\r\n\r\n显示邮箱验证通知的路由应该命名为 `verification.notice`。配置这个命名路由很重要，因为如果用户邮箱验证未通过， `verified` 中间件 [包含在 Laravel 中](#protecting-routes) 将会自动重定向到该命名路由上。\r\n\r\n> 技巧：手动实现邮箱验证时，需要您自己定义验证通知视图的内容。如果您希望包含所有必要的身份验证和验证视图，请查看 [Laravel 应用入门套件](/docs/laravel/9.x/starter-kits)。\r\n\r\n\r\n\r\n<a name=\"the-email-verification-handler\"></a>\r\n### Email 认证处理\r\n\r\n接下来，我们需要定义一个路由，该路由将处理当用户点击验证链接时发送的请求。该路由应命名为 `verification.verify` ，并添加了 `auth` 和 `signed` 中间件\r\n\r\n    use Illuminate\\Foundation\\Auth\\EmailVerificationRequest;\r\n\r\n    Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {\r\n        $request->fulfill();\r\n\r\n        return redirect('/home');\r\n    })->middleware(['auth', 'signed'])->name('verification.verify');\r\n\r\n在继续之前，让我们仔细看一下这个路由。首先，您会注意到我们使用的是 `EmailVerificationRequest` 而不是传统的 `Illuminate\\Http\\Request` 实例。`EmailVerificationRequest` 是 Laravel 附带的[表单请求](/docs/laravel/9.x/validation#form-request-validation)。该请求将自动处理验证请求的 id 和 hash 参数。\r\n\r\n接下来，我们可以直接在请求上调用 `fulfill` 方法。该方法将在经过身份验证的用户上调用 `markEmailAsVerified` 方法，并会触发 `Illuminate\\Auth\\Events\\Verified` 事件。通过 `Illuminate\\Foundation\\Auth\\User` 基类，`markEmailAsVerified` 方法可用于默认的 `App\\Models\\User` 模型。验证用户的电子邮件地址后，您可以将其重定向到任意位置。\r\n\r\n<a name=\"resending-the-verification-email\"></a>\r\n### 重新发送 Email 认证邮件\r\n\r\n有时候，用户可能输错了电子邮件地址或者不小心删除了验证邮件。为了解决这种问题，您可能会想定义一个路由实现用户重新发送验证邮件。您可以通过在 [验证通知视图](#the-email-verification-notice) 中放置一个简单的表单来实现此功能。\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/email/verification-notification', function (Request $request) {\r\n        $request->user()->sendEmailVerificationNotification();\r\n\r\n        return back()->with('message', 'Verification link sent!');\r\n    })->middleware(['auth', 'throttle:6,1'])->name('verification.send');\r\n\r\n\r\n\r\n<a name=\"protecting-routes\"></a>\r\n### 保护路由\r\n\r\n[路由中间件](/docs/laravel/9.x/middleware) 可以阻止未通过邮箱验证的用户进行访问。Laravel 附带了 `verified` 中间件，它定义在 `Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified`。由于此中间件已在应用程序的 HTTP 内核中注册，因此您需要做的就是将中间件附加到路由定义：\r\n\r\n    Route::get('/profile', function () {\r\n        // 只有经过验证的用户才能进入...\r\n    })->middleware('verified');\r\n\r\n如果验证未通过的用户尝试访问已加了此中间件的路由，他们会被自动重定向到 `verification.notice` [命名路由](/docs/laravel/9.x/routing#named-routes)。\r\n\r\n<a name=\"customization\"></a>\r\n## 自定义\r\n\r\n<a name=\"verification-email-customization\"></a>\r\n#### 自定义 Email 认证\r\n\r\n尽管默认邮箱验证通知应该满足大多数应用程序的要求，但是 Laravel 允许您自定义邮箱验证邮件的方式\r\n\r\n首先，将闭包传递给 `Illuminate\\Auth\\Notifications\\VerifyEmail` 提供的 `toMailUsing` 方法。闭包将接收可通知模型的实例，以及用户必须访问的包含签名的验证 URL。闭包将返回一个 `Illuminate\\Notifications\\Messages\\MailMessage` 实例 。通常您应该在应用中的 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中调用 `toMailUsing` 方法：\r\n\r\n    use Illuminate\\Auth\\Notifications\\VerifyEmail;\r\n    use Illuminate\\Notifications\\Messages\\MailMessage;\r\n\r\n    /**\r\n     * 注册任何身份验证/授权服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        // ...\r\n\r\n        VerifyEmail::toMailUsing(function ($notifiable, $url) {\r\n            return (new MailMessage)\r\n                ->subject('Verify Email Address')\r\n                ->line('Click the button below to verify your email address.')\r\n                ->action('Verify Email Address', $url);\r\n        });\r\n    }\r\n\r\n> 技巧：如果你想了解关于邮件通知的更多信息，请查阅 [邮件通知文档](/docs/laravel/9.x/notifications#mail-notifications)。\r\n\r\n\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\n如果你是使用 [Laravel 应用入门套件](/docs/laravel/9.x/starter-kits)的话，Laravel 在电子邮件验证通过后会派发 [事件](/docs/laravel/9.x/events) 。如果你想接收到这个事件并进行手动处理的话，你应该在 `EventServiceProvider` 中注册监听者：\r\n\r\n    /**\r\n     * 应用程序的事件监听器\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Auth\\Events\\Verified' => [\r\n            'App\\Listeners\\LogVerifiedUser',\r\n        ],\r\n    ];\r\n\r\n","p":"docs/verification.html"},{"t":"encryption (加密解密)","d":"\n# 加密解密\r\n\r\n- [简介](#introduction)\r\n- [配置](#configuration)\r\n- [基本用法](#using-the-encrypter)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 的加密机制使用的是 OpenSSL 所提供的 AES-256 和 AES-128 加密。强烈建议你使用 Laravel 内建的加密工具，而不是用其它的加密算法。所有 Laravel 加密之后的结果都会使用消息认证码 (MAC) 签名，使其底层值不能在加密后再次修改。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n在使用 Laravel 的加密工具之前，你必须先设置 `config/app.php` 配置文件中的 `key` 配置项。该配置项由环境变量 `APP_KEY` 设定。你应当使用 `php artisan key:generate` 命令来生成该变量的值，`key:generate` 命令将使用 PHP 的安全随机字节生成器为你的应用程序构建加密安全密钥。通常情况下，在 [安装 Laravel](/docs/laravel/9.x/installation) 中会为你生成 `APP_KEY` 环境变量的值。\r\n\r\n<a name=\"using-the-encrypter\"></a>\r\n## 基本用法\r\n\r\n<a name=\"encrypting-a-value\"></a>\r\n#### 加密一个值\r\n\r\n你可以使用 `Crypt` 门面提供的 `encryptString` 来加密一个值。所有加密的值都使用 OpenSSL 的 `AES-256-CBC` 来进行加密。此外，所有加密过的值都会使用消息认证码 (MAC) 来签名，以检测加密字符串是否被篡改过：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Crypt;\r\n\r\n    class DigitalOceanTokenController extends Controller\r\n    {\r\n        /**\r\n         * 为用户存储一个 DigitalOcean API 令牌\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function storeSecret(Request $request)\r\n        {\r\n            $request->user()->fill([\r\n                'token' => Crypt::encryptString($request->token),\r\n            ])->save();\r\n        }\r\n    }\r\n\r\n<a name=\"decrypting-a-value\"></a>\r\n#### 解密一个值\r\n\r\n你可以使用 `Crypt` 门面提供的 `decryptString` 来进行解密。如果该值不能被正确解密，例如消息认证码 (MAC) 无效，会抛出异常 `Illuminate\\Contracts\\Encryption\\DecryptException`：\r\n\r\n    use Illuminate\\Contracts\\Encryption\\DecryptException;\r\n    use Illuminate\\Support\\Facades\\Crypt;\r\n\r\n    try {\r\n        $decrypted = Crypt::decryptString($encryptedValue);\r\n    } catch (DecryptException $e) {\r\n        //\r\n    }\r\n\n","p":"docs/encryption.html"},{"t":"hashing (哈希加密)","d":"# 哈希加密\r\n\r\n- [简介](#introduction)\r\n- [配置](#configuration)\r\n- [基本用法](#basic-usage)\r\n    - [使用哈希算法加密密码](#hashing-passwords)\r\n    - [验证密码是否与哈希匹配](#verifying-that-a-password-matches-a-hash)\r\n    - [检查密码是否需要重新散列/哈希](#determining-if-a-password-needs-to-be-rehashed)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel `Hash` [facade](/docs/laravel/9.x/facades) 为存储用户密码提供了安全的 Bcrypt 和 Argon2 哈希加密方式。如果你正在使用 [Laravel 应用初始脚手架](/docs/laravel/9.x/starter-kits) ，默认情况下，将使用 Bcrypt 进行注册和身份验证。\r\n\r\nBcrypt 是加密密码的一个很好的选择，因为它的「加密系数」是可调的，这意味着生成散列所需的时间可以随着硬件功率的增加而增加。当加密密码时速度慢是相对比较好的。算法对密码进行哈希运算的时间越长，恶意用户生成所有可能用于对应用程序进行暴力攻击的字符串哈希值的「彩虹表」的时间就越长。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n你可以在 `config/hashing.php` 配置文件中配置默认哈希驱动程序。目前支持三种驱动程序： [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) 和 [Argon2](https://en.wikipedia.org/wiki/Argon2) (Argon2i and Argon2id variants)。\r\n\r\n> 注意：Argon2i 驱动程序需要 PHP 7.2.0 或更高版本，而 Argon2id 驱动程序则需要 PHP 7.3.0 或更高版本。\r\n\r\n<a name=\"basic-usage\"></a>\r\n## 基本用法\r\n\r\n<a name=\"hashing-passwords\"></a>\r\n### 哈希密码\r\n\r\n你可以通过调用 `Hash` facade 的 `make` 方法来加密你的密码：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n\r\n    class PasswordController extends Controller\r\n    {\r\n        /**\r\n         * 更新用户密码\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function update(Request $request)\r\n        {\r\n            // 验证新密码长度\r\n\r\n            $request->user()->fill([\r\n                'password' => Hash::make($request->newPassword)\r\n            ])->save();\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"adjusting-the-bcrypt-work-factor\"></a>\r\n#### 调整 Bcrypt 加密系数\r\n\r\n如果使用 Bcrypt 算法，你可以在 `make` 方法中使用 `rounds` 选项来配置该算法的加密系数。然而，对大多数应用程序来说，默认值就足够了：\r\n\r\n    $hashed = Hash::make('password', [\r\n        'rounds' => 12,\r\n    ]);\r\n\r\n<a name=\"adjusting-the-argon2-work-factor\"></a>\r\n#### 调整 Argon2 加密系数\r\n\r\n如果使用 Argon2 算法，你可以在 `make` 方法中使用 `memory`，`time` 和 `threads` 选项来配置该算法的加密系数。然后，对大多数应用程序来说，默认值就足够了：\r\n\r\n    $hashed = Hash::make('password', [\r\n        'memory' => 1024,\r\n        'time' => 2,\r\n        'threads' => 2,\r\n    ]);\r\n\r\n> 技巧：有关这些选项的更多信息，请查阅 [关于 Argon Hash 的 PHP 官方文档](https://secure.php.net/manual/zh/function.password-hash.php)。\r\n\r\n<a name=\"verifying-that-a-password-matches-a-hash\"></a>\r\n### 验证密码是否与哈希匹配\r\n\r\n`check` 方法能为你验证一段给定的未加密字符串与给定的散列/哈希值是否一致：\r\n\r\n    if (Hash::check('plain-text', $hashedPassword)) {\r\n        // 密码匹配...\r\n    }\r\n\r\n<a name=\"determining-if-a-password-needs-to-be-rehashed\"></a>\r\n### 检查密码是否需要重新散列/哈希\r\n\r\n`needsRehash` 方法可以为你检查当散列/哈希的加密系数改变时，你的密码是否被新的加密系数重新加密过。某些应用程序选择在身份验证时执行这一项检查：\r\n\r\n    if (Hash::needsRehash($hashed)) {\r\n        $hashed = Hash::make('plain-text');\r\n    }\r\n\r\n","p":"docs/hashing.html"},{"t":"passwords (重置密码)","d":"# 重置密码\r\n\r\n- [介绍](#introduction)\r\n    - [模型准备](#model-preparation)\r\n    - [数据库准备](#database-preparation)\r\n    - [配置可信主机](#configuring-trusted-hosts)\r\n- [路由](#routing)\r\n    - [请求重置密码链接](#requesting-the-password-reset-link)\r\n    - [重置密码](#resetting-the-password)\r\n- [删除过期令牌](#deleting-expired-tokens)\r\n- [自定义](#password-customization)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n大多数 Web 应用程序都会为用户提供重置密码的功能。 Laravel 已经提供了便捷的服务来发送密码重置链接和安全重置密码，而不需要您为每个应用程序重新实现此功能。\r\n\r\n> 技巧：想快速上手？在新的 Laravel 应用程序中安装 Laravel [入门套件](/docs/laravel/9.x/starter-kits) 。Laravel 入门套件会为您搭建完整的身份验证系统，包括重置密码功能。\r\n\r\n<a name=\"model-preparation\"></a>\r\n### 模型准备\r\n\r\n在使用 Laravel 的重置密码功能之前，确认 `App\\Models\\User` 模型已经使用了 `Illuminate\\Notifications\\Notifiable` trait。通常，在新创建的 Laravel 应用程序的 `App\\Models\\User` 模型中默认引入了该 trait 。\r\n\r\n接下来，验证 `App\\Models\\User` 模型是否继承了 `Illuminate\\Contracts\\Auth\\CanResetPassword` 接口。 框架中包含的 `App\\Models\\User` 模型默认继承了此接口，并使用 `Illuminate\\Auth\\Passwords\\CanResetPassword` trait 来实现了接口中的方法。\r\n\r\n<a name=\"database-preparation\"></a>\r\n### 数据库准备\r\n\r\n必须创建一个表来存储应用程序的密码重置令牌。此表的迁移包含在默认的 Laravel 应用程序中，因此您只需迁移您的数据库即可创建此表：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n\r\n\r\n<a name=\"configuring-trusted-hosts\"></a>\r\n### 配置可信主机\r\n\r\n默认情况下，无论 HTTP 请求的 `Host` 标头的内容如何，Laravel 都会响应它收到的所有请求。 此外，在 Web 请求期间生成应用程序的绝对 URL 时，将使用 `Host` 标头的值。\r\n\r\n通常，您应该将 Web 服务器（例如 Nginx 或 Apache）配置为仅向您的应用程序发送与给定主机名匹配的请求。然而，如果你没有能力直接自定义你的 web 服务器并且需要指示 Laravel 只响应某些主机名，你可以通过为你的应用程序启用 `App\\Http\\Middleware\\TrustHosts` 中间件来实现。当您的应用程序提供密码重置功能时，这一点尤其重要\r\n\r\n要了解有关此中间件的更多信息，请咨询 [`TrustHosts` 中间件文档](/docs/laravel/9.x/requests#configuring-trusted-hosts).\r\n\r\n<a name=\"routing\"></a>\r\n## 路由\r\n\r\n为了正确实现对允许用户重置密码的支持，我们需要定义几个路由。首先，我们需要一对路由来处理允许用户通过他们的电子邮件地址请求密码重置链接。其次，一旦用户访问通过电子邮件发送给他们的密码重置链接并完成密码重置表单，我们将需要一对路由来处理实际重置密码\r\n\r\n<a name=\"requesting-the-password-reset-link\"></a>\r\n### 请求密码重置链接\r\n\r\n<a name=\"the-password-reset-link-request-form\"></a>\r\n#### 密码重置链接申请表\r\n\r\n首先，我们将定义请求密码重置链接所需的路由。首先，我们将定义一个路由，该路由返回一个带有密码重置链接请求表单的视图：\r\n\r\n    Route::get('/forgot-password', function () {\r\n        return view('auth.forgot-password');\r\n    })->middleware('guest')->name('password.request');\r\n\r\n\r\n\r\n此路由返回的视图应该有一个包含 `email` 字段的表单，该字段允许用户请求给定电子邮件地址的密码重置链接。\r\n<a name=\"password-reset-link-handling-the-form-submission\"></a>\r\n#### 处理表单提交\r\n\r\n接下来，我们将定义一个路由，该路由将从「忘记密码」视图处理表单提交请求。此路由将负责验证电子邮件地址并将密码重置请求发送给相应用户：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Password;\r\n\r\n    Route::post('/forgot-password', function (Request $request) {\r\n        $request->validate(['email' => 'required|email']);\r\n\r\n        $status = Password::sendResetLink(\r\n            $request->only('email')\r\n        );\r\n\r\n        return $status === Password::RESET_LINK_SENT\r\n                    ? back()->with(['status' => __($status)])\r\n                    : back()->withErrors(['email' => __($status)]);\r\n    })->middleware('guest')->name('password.email');\r\n\r\n在继续之前，让我们更详细地检查一下这条路由。首先，验证请求的 `email` 属性。接下来，我们将使用 Laravel 内置的 `Password` 门面向用户发送一个密码重置链接。密码代理将负责按给定字段（在本例中是电子邮件地址）检索用户，并通过 Laravel 的内置 [消息通知系统](/docs/laravel/9.x/notifications) 向用户发送密码重置链接。\r\n\r\n该 `sendResetLink` 方法返回一个状态标识。可以使用 Laravel 的 [本地化](/docs/laravel/9.x/localization) 助手来转换此状态，以便向用户显示有关请求状态的用户友好提示。密码重置状态的转换由应用程序的 `lang/{lang}/passwords.php` 语言文件确定。状态 slug 的每个可能值的条目位于 `passwords` 语言文件中。\r\n\r\n\r\n\r\n您可能想知道，Laravel 在调用 `Password` 门面的 `sendResetLink`  方法时，Laravel 怎么知道如何从应用程序数据库中检索用户记录。Laravel 密码代理利用身份验证系统的「用户提供者」来检索数据库记录。密码代理使用的用户提供程序是在 `passwords` 配置文件的 `config/auth.php` 配置数组中配置的。要了解有关编写自定义用户提供程序的更多信息，请参阅 [身份验证文档](/docs/laravel/9.x/authentication#adding-custom-user-providers)。\r\n\r\n> 技巧：当手动实现密码重置时，您需要自己定义视图和路由的内容。如果您想要包含所有必要的身份验证和验证逻辑的脚手架，请查看 [Laravel 应用程序入门工具包](/docs/laravel/9.x/starter-kits)。\r\n\r\n<a name=\"resetting-the-password\"></a>\r\n### 重置密码\r\n\r\n<a name=\"the-password-reset-form\"></a>\r\n#### 重置密码表单\r\n\r\n接下来，我们将定义用户点击重置密码邮件中的链接，进行重置密码所需要的一些路由。第一步，先定义一个获取重置密码表单的路由。这个路由需要一个 `token` 来验证请求：\r\n\r\n    Route::get('/reset-password/{token}', function ($token) {\r\n        return view('auth.reset-password', ['token' => $token]);\r\n    })->middleware('guest')->name('password.reset');\r\n\r\n通过路由返回的视图应该显示一个含有 `email` 字段， `password` 字段，`password_confirmation` 字段和一个隐藏的值通过路由参数获取的 `token` 字段。\r\n\r\n\r\n\r\n<a name=\"password-reset-handling-the-form-submission\"></a>\r\n#### 处理表单提交的数据\r\n\r\n当然，我们需要定义一个路由来接受表单提交的数据。这个路由会检查传过来的参数并更新数据库中用户的密码：\r\n\r\n    use Illuminate\\Auth\\Events\\PasswordReset;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Illuminate\\Support\\Facades\\Password;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    Route::post('/reset-password', function (Request $request) {\r\n        $request->validate([\r\n            'token' => 'required',\r\n            'email' => 'required|email',\r\n            'password' => 'required|min:8|confirmed',\r\n        ]);\r\n\r\n        $status = Password::reset(\r\n            $request->only('email', 'password', 'password_confirmation', 'token'),\r\n            function ($user, $password) {\r\n                $user->forceFill([\r\n                    'password' => Hash::make($password)\r\n                ])->setRememberToken(Str::random(60));\r\n\r\n                $user->save();\r\n\r\n                event(new PasswordReset($user));\r\n            }\r\n        );\r\n\r\n        return $status === Password::PASSWORD_RESET\r\n                    ? redirect()->route('login')->with('status', __($status))\r\n                    : back()->withErrors(['email' => [__($status)]]);\r\n    })->middleware('guest')->name('password.update');\r\n\r\n在继续之前，我们再详细地检查下这条路由。 首先，验证请求的 `token`，`email` 和 `password` 属性。 接下来，我们将使用 Laravel 的内置「密码代理」 (通过 `Password` 门面) 来验证密码重置请求凭据。\r\n\r\n如果提供给密码代理的令牌、电子邮件地址和密码有效，则将调用传递给 `reset` 方法的闭包。 在这个接收用户实例和纯文本密码的闭包中，我们可以更新数据库中用户的密码。\r\n\r\n该 `reset` 方法返回一个「状态」标识。 此状态可以使用 Laravel 的 [本地化](/docs/laravel/9.x/localization) 助手来翻译此状态，以便向用户显示有关其请求状态的用户友好消息。密码重置状态的翻译由应用程序的 `lang/{lang}/passwords.php` 语言文件决定。状态段的每个可能值的条目位于 `passwords` 语言文件中。\r\n\r\n\r\n\r\n在继续之前，您可能想知道 Laravel 如何在调用 `Password` 门面的 `reset` 方法时如何知道如何从应用程序的数据库中检索用户记录。Laravel 密码代理利用您的身份验证系统的「用户提供者」来检索数据库记录。密码代理使用的用户提供程序在配置文件的 `config/auth.php` 配置文件的 `passwords` 配置数组中配置。 要了解有关编写自定义用户提供程序的更多信息，请参阅 [身份验证文档](/docs/laravel/9.x/authentication#adding-custom-user-providers)。\r\n\r\n<a name=\"deleting-expired-tokens\"></a>\r\n## 删除过期令牌\r\n\r\n已过期的密码重置令牌仍将存在于您的数据库中。然而，您可以使用 `auth:clear-resets` Artisan 命令轻松删除这些记录：\r\n\r\n```shell\r\nphp artisan auth:clear-resets\r\n```\r\n\r\n如果您想使该过程自动化，请考虑将命令添加到应用程序的 [调度程序](/docs/laravel/9.x/scheduling)：\r\n\r\n    $schedule->command('auth:clear-resets')->everyFifteenMinutes();\r\n\r\n<a name=\"password-customization\"></a>\r\n## 自定义\r\n\r\n<a name=\"reset-link-customization\"></a>\r\n#### 重置链接自定义\r\n\r\n您可以使用 `ResetPassword` 通知类提供的 `createUrlUsing` 方法自定义密码重置链接 URL。 此方法接受一个闭包，该闭包接收正在接收通知的用户实例以及密码重置链接令牌。 通常，您应该从 `App\\Providers\\AuthServiceProvider` 服务提供者的 `boot` 方法中调用此方法：\r\n\r\n    use Illuminate\\Auth\\Notifications\\ResetPassword;\r\n\r\n    /**\r\n     * Register any authentication / authorization services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n        ResetPassword::createUrlUsing(function ($user, string $token) {\r\n            return 'https://example.com/reset-password?token='.$token;\r\n        });\r\n    }\r\n\r\n<a name=\"reset-email-customization\"></a>\r\n#### 重置邮件自定义\r\n\r\n您可以轻松修改用于向用户发送密码重置链接的通知类。 首先，覆盖您的 `App\\Models\\User` 模型上的 `sendPasswordResetNotification` 方法。 在此方法中，您可以使用您自己创建的任何 [通知类](/docs/laravel/9.x/notifications) 发送通知。 密码重置 `$token` 是该方法收到的第一个参数。 你可以使用这个 `$token` 来构建你选择的密码重置 URL 并将你的通知发送给用户：\r\n\r\n    use App\\Notifications\\ResetPasswordNotification;\r\n\r\n    /**\r\n     * 发送密码重置通知给用户\r\n     *\r\n     * @param  string  $token\r\n     * @return void\r\n     */\r\n    public function sendPasswordResetNotification($token)\r\n    {\r\n        $url = 'https://example.com/reset-password?token='.$token;\r\n\r\n        $this->notify(new ResetPasswordNotification($url));\r\n    }\r\n\r\n","p":"docs/passwords.html"},{"t":"database (数据库：快速入门)","d":"# 数据库：快速入门\r\n\r\n- [简介](#introduction)\r\n    - [配置](#configuration)\r\n    - [读写分离](#read-and-write-connections)\r\n- [运行原生 SQL 查询](#running-queries)\r\n    - [使用多个数据库连接](#using-multiple-database-connections)\r\n    - [监听查询事件](#listening-for-query-events)\r\n- [数据库事务](#database-transactions)\r\n- [连接到数据库 CLI](#connecting-to-the-database-cli)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n几乎所有的应用程序都需要和数据库进行交互。Laravel 为此提供了一套非常简单易用的数据库交互方式。开发者可以使用原生 SQL、[查询构造器](/docs/laravel/9.x/queries)以及 [Eloquent ORM](/docs/laravel/9.x/eloquent) 等方式与数据库交互。目前，Laravel 为以下四种数据库提供了官方支持：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n- MariaDB 10.2+（[版本政策](https://mariadb.org/about/#maintenance-policy)）\r\n- MySQL 5.7+ ([版本策略](https://en.wikipedia.org/wiki/MySQL#Release_history))\r\n- PostgreSQL 10.0+ ([版本策略](https://www.postgresql.org/support/versioning/))\r\n- SQLite 3.8.8+\r\n- SQL Server 2017+ ([版本策略](https://docs.microsoft.com/en-us/lifecycle/products/?products=sql-server))\r\n\r\n</div>\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\n数据库的配置文件在 `config/database.php` 文件中。你可以在这个文件中配置所有的数据库连接，并指定默认的数据库连接。该文件中的大部分配置都基于项目的环境变量，且提供了大部分 Laravel 所支持的数据库配置示例。\r\n\r\n在默认情况下，Laravel 的示例 [环境配置](/docs/laravel/9.x/configuration#environment-configuration) 使用了 [Laravel Sail](/docs/laravel/9.x/sail)，Laravel Sail 是一种用于在本地开发 Laravel 应用的 Docker 配置。但你依然可以根据本地数据库的需要修改数据库配置。\r\n\r\n\r\n\r\n<a name=\"sqlite-configuration\"></a>\r\n#### SQLite 配置\r\n\r\nSQLite 数据库本质上只是一个存在你文件系统上的文件。你可以通过 `touch` 命令来建立一个新的 SQLite 数据库，如： `touch database/database.sqlite`. 建立数据库之后，你就可以很简单地使用数据库的绝对路径来配置 `DB_DATABASE` 环境变量，使其指向这个新创建的数据库：\r\n\r\n```ini\r\nDB_CONNECTION=sqlite\r\nDB_DATABASE=/absolute/path/to/database.sqlite\r\n```\r\n\r\n若要为 SQLite 连接启用外键约束，应将 `DB_FOREIGN_KEYS` 环境变量设置为 `true`：\r\n\r\n```ini\r\nDB_FOREIGN_KEYS=true\r\n```\r\n\r\n<a name=\"mssql-configuration\"></a>\r\n#### Microsoft SQL Server 配置\r\n\r\n在使用 SQL Server 数据库前，你需要先确保你已安装并启用了 `sqlsrv` 和 `pdo_sqlsrv` PHP 扩展以及它们所需要的依赖项，例如 Microsoft SQL ODBC 驱动。\r\n\r\n<a name=\"configuration-using-urls\"></a>\r\n#### URL 形式配置\r\n\r\n通常，数据库连接使用多个配置项进行配置，例如 `host`、 `database`、 `username`、 `password` 等。这些配置项都拥有对应的环境变量。这意味着你需要在生产服务器上管理多个不同的环境变量。\r\n\r\n部分数据库托管平台（如 AWS 和 Heroku）会提供了包含所有连接信息的数据库「URL」。它们通常看起来像这样：\r\n\r\n```html\r\nmysql://root:password@127.0.0.1/forge?charset=UTF-8\r\n```\r\n\r\n这些 URL 通常遵循标准模式约定：\r\n\r\n```html\r\ndriver://username:password@host:port/database?options\r\n```\r\n\r\n\r\n\r\n为了方便起见，Laravel 支持使用这些 URL 替代传统的配置项来配置你的数据库。如果配置项 `url` （或其对应的环境变量 `DATABASE_URL` ）存在，那么 Laravel 将会尝试从 URL 中提取数据库连接以及凭证信息。\r\n\r\n<a name=\"read-and-write-connections\"></a>\r\n### 读写分离\r\n\r\n有时候你可能会希望使用一个数据库连接来执行 `SELECT` 语句，而 `INSERT`、`UPDATE` 和 `DELETE` 语句则由另一个数据库连接来执行。在 Laravel 中，无论你是使用原生 SQL 查询、查询构造器 或是 `Eloquent ORM`，都能轻松实现读写分离。\r\n\r\n为了弄明白如何配置读写分离，我们先来看个例子：\r\n\r\n    'mysql' => [\r\n        'read' => [\r\n            'host' => [\r\n                '192.168.1.1',\r\n                '196.168.1.2',\r\n            ],\r\n        ],\r\n        'write' => [\r\n            'host' => [\r\n                '196.168.1.3',\r\n            ],\r\n        ],\r\n        'sticky' => true,\r\n        'driver' => 'mysql',\r\n        'database' => 'database',\r\n        'username' => 'root',\r\n        'password' => '',\r\n        'charset' => 'utf8mb4',\r\n        'collation' => 'utf8mb4_unicode_ci',\r\n        'prefix' => '',\r\n    ],\r\n\r\n请注意，我们在数据库配置中加入了三个键，分别是： `read`, `write` 以及 `sticky`。`read` 和 `write` 的值是一个只包含 `host` 键的数组。这代表其他的数据库选项将会从主 `mysql` 配置中获取。\r\n\r\n如果你想要覆写主 `mysql` 配置，只需要将需要覆写的值放到 `read` 和 `write` 数组里即可。所以，在这个例子中，`192.168.1.1` 将会被用作「读」连接主机，而 `192.168.1.3` 将作为「写」连接主机。这两个连接将共享 `mysql` 数组中的各项配置，如数据库凭证（用户名、密码）、前缀、字符编码等。如果 `host` 数组中存在多个值，`Laravel` 将会为每个连接随机选取所使用的数据库主机。\r\n\r\n\r\n\r\n<a name=\"the-sticky-option\"></a>\r\n#### `sticky` 选项\r\n\r\n`sticky` 是一个 *可选* 值，它用于允许 Laravel 立即读取在当前请求周期内写入到数据库的记录。若 `sticky` 选项被启用，且在当前请求周期中执行过「写」操作，那么在这之后的所有「读」操作都将使用「写」连接。这样可以确保同一个请求周期中写入的数据库可以被立即读取到，从而避免主从同步延迟导致的数据不一致。不过是否启用它取决于项目的实际需求。\r\n\r\n<a name=\"running-queries\"></a>\r\n## 执行原生 SQL 查询\r\n\r\n一旦配置好数据库连接，你就可以使用 `DB` Facade 来执行查询。`DB` Facade 为每种类型的查询都提供了相应的方法：`select`、`update`、`insert`、`delete` 以及 `statement`。\r\n\r\n<a name=\"running-a-select-query\"></a>\r\n#### 执行 SELECT 查询\r\n\r\n你可以使用 `DB` Facade 的 `select` 方法来执行一个基础的 SELECT 查询：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 展示用户列表\r\n         *\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function index()\r\n        {\r\n            $users = DB::select('SELECT * FROM `users` WHERE `active` = ?', [1]);\r\n\r\n            return view('user.index', ['users' => $users]);\r\n        }\r\n    }\r\n\r\n传递给 `select` 方法的第一个参数是一个原生 SQL 查询语句，而第二个参数则是需要绑定到查询中的参数值。通常，这些值用于约束 `where` 语句。使用参数绑定可以有效防止 SQL 注入。\r\n\r\n`select` 方法将始终返回一个包含查询结果的数组。数组中的每个结果都对应一个数据库记录的 `stdClass` 对象：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::select('select * from users');\r\n\r\n    foreach ($users as $user) {\r\n        echo $user->name;\r\n    }\r\n\r\n#### 使用命名绑定\r\n\r\n除了使用 `?` 表示参数绑定外，你还可以使用命名绑定的形式来执行一个查询：\r\n\r\n    $results = DB::select('select * from users where id = :id', ['id' => 1]);\r\n\r\n#### 执行 Insert 语句\r\n\r\n你可以使用 `DB` Facade 的 `insert` 方法来执行 `insert` 语句。跟 `select` 方法一样，该方法的第一个和第二个参数分别是原生 SQL 语句和绑定的数据：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);\r\n\r\n#### 执行 Update 语句\r\n\r\n`update` 方法用于更新数据库中现有的记录。该方法将会返回受到本次操作影响的记录行数：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $affected = DB::update(\r\n        'update users set votes = 100 where name = ?',\r\n        ['Anita']\r\n    );\r\n\r\n#### 执行 Delete 语句\r\n\r\n`delete` 方法用于从数据库中删除现有的记录。与 `update` 方法一样，将返回受到本次操作影响的记录行数：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $deleted = DB::delete('delete from users');\r\n\r\n#### 执行 General 语句\r\n\r\n部分数据库语句没有返回值。对于这些语句，你可以使用 `DB` Facade 的 `statement` 方法：\r\n\r\n    DB::statement('drop table users');\r\n\r\n\r\n\r\n<a name=\"running-an-unprepared-statement\"></a>\r\n#### 执行未预处理的查询\r\n\r\n有时你可能希望查询语句在不绑定任何参数的情况下执行。对于这些类型的操作，你可以使用 `DB` Facade 的 `unprepared` 方法：\r\n\r\n    DB::unprepared('update users set votes = 100 where name = \"Dries\"');\r\n\r\n> 注意：由于通过以上方式执行的语句不会进行预处理，即不会绑定任何参数值，它们非常容易遭到 SQL 注入攻击。请永远不要让用户输入的值出现在未预处理的语句里。\r\n\r\n<a name=\"implicit-commits-in-transactions\"></a>\r\n#### Implicit Commits\r\n\r\n当在事务中使用 `DB` Facade 的 `statement` 和 `unprepared` 方法时，请务必留意会导致 [隐式提交](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html)的语句。这些语句将会导致数据库引擎间接提交整个事务，从而让 Laravel 不知道数据库的事务级别。其中一个例子是创建数据表：\r\n\r\n    DB::unprepared('create table a (col varchar(1) null)');\r\n\r\n你可以参考 MySQL 手册以获取所有可以触发隐式提交的 [语句列表](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html) \r\n\r\n<a name=\"using-multiple-database-connections\"></a>\r\n### 使用多数据库连接\r\n\r\n如果你在配置文件 `config/database.php` 中定义了多个数据库连接的话，你可以通过 `DB` Facade 的 `connection` 方法来使用它们。传递给 `connection` 方法的连接名称应该是你在 `config/database.php` 里或者通过 `config` 助手函数在运行时配置的连接之一：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::connection('sqlite')->select(...);\r\n\r\n你也可以使用一个连接实例上的 `getPdo` 方法来获取底层的 PDO 实例：\r\n\r\n    $pdo = DB::connection()->getPdo();\r\n\r\n\r\n\r\n<a name=\"listening-for-query-events\"></a>\r\n### 监听查询事件\r\n\r\n如果你想要获取程序执行的每一条 SQL 语句，可以使用 `listen` 方法。该方法对查询日志和调试非常有用，你可以在 [服务提供者](/docs/laravel/9.x/providers) 中注册查询监听器。\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 引导任意应用服务\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            DB::listen(function ($query) {\r\n                // $query->sql;\r\n                // $query->bindings;\r\n                // $query->time;\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"database-transactions\"></a>\r\n## 数据库事务\r\n\r\n想要在数据库事务中运行一系列操作，你可以使用 `DB` 门面的 `transaction` 方法。如果在事务的闭包中出现了异常，事务将会自动回滚。如果闭包执行成功，事务将会自动提交。在使用 `transaction` 方法时不需要手动回滚或提交：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::transaction(function () {\r\n        DB::update('update users set votes = 1');\r\n\r\n        DB::delete('delete from posts');\r\n    });\r\n\r\n<a name=\"handling-deadlocks\"></a>\r\n#### 处理死锁\r\n\r\n `transaction` 方法接受一个可选的第二个参数，该参数定义发生死锁时事务应重试的次数。一旦这些尝试用尽，就会抛出一个异常：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::transaction(function () {\r\n        DB::update('update users set votes = 1');\r\n\r\n        DB::delete('delete from posts');\r\n    }, 5);\r\n\r\n\r\n\r\n<a name=\"manually-using-transactions\"></a>\r\n#### 手动执行事务\r\n\r\n如果你想要手动处理事务并完全控制回滚和提交，可以使用 `DB` 门面提供的 `beginTransaction` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::beginTransaction();\r\n\r\n你可以通过 `rollBack` 方法回滚事务：\r\n\r\n    DB::rollBack();\r\n\r\n最后，你可以通过 `commit` 方法提交事务：\r\n\r\n    DB::commit();\r\n\r\n> 技巧：`DB` 门面的事务方法还可以用于控制 [查询构造器](/docs/laravel/9.x/queries) 和 [Eloquent ORM](/docs/laravel/9.x/eloquent) 的事务。\r\n\r\n<a name=\"connecting-to-the-database-cli\"></a>\r\n## 连接到数据库 CLI\r\n\r\n如果您想连接到数据库的 CLI，则可以使用 `db` Artisan 命令：\r\n\r\n```shell\r\nphp artisan db\r\n```\r\n\r\n如果需要，您可以指定数据库连接名称以连接到不是默认连接的数据库连接：\r\n\r\n```shell\r\nphp artisan db mysql\r\n```\r\n\r\n\r\n","p":"docs/database.html"},{"t":"queries (数据库: 查询构造器)","d":"# 数据库: 查询构造器\r\n\r\n- [简介](#简介)\r\n- [获取结果](#获取结果)\r\n    - [分块结果](#分块结果)\r\n\t- [Lazily 流式传输结果](#streaming-results-lazily)\r\n    - [聚合函数](#聚合函数)\r\n- [Select 语句](#select-statements)\r\n- [原生表达式](#原生表达式)\r\n- [Joins](#joins)\r\n- [Unions](#unions)\r\n- [基础 where 语句](#basic-where-clauses)\r\n    - [条件查询语句](#where-clauses)\r\n    - [Or Where 语句](#or-where-clauses)\r\n    - [JSON Where 语句](#json-where-clauses)\r\n    - [其他 Where 语句](#additional-where-clauses)\r\n    - [逻辑分组](#logical-grouping)\r\n- [高级 Where 语句](#advanced-where-clauses)\r\n    - [Where Exists 语句](#where-exists-clauses)\r\n    - [子查询 Where 语句](#subquery-where-clauses)\r\n    - [全文 Where 子句](#full-text-where-clauses)\r\n- [Ordering, Grouping, Limit & Offset](#ordering-grouping-limit-and-offset)\r\n    - [排序](#ordering)\r\n    - [分组](#grouping)\r\n    - [Limit & Offset](#limit-and-offset)\r\n- [条件语句](#conditional-clauses)\r\n- [插入语句](#插入语句)\r\n    - [自增ID](#auto-incrementing-ids)\r\n- [更新语句](#update-statements)\r\n    - [更新 JSON](#updating-json-columns)\r\n    - [自增 & 自减](#increment-and-decrement)\r\n- [删除语句](#删除语句)\r\n- [悲观锁](#悲观锁)\r\n- [调试](#调试)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel的数据库查询生成器为创建和运行数据库查询提供了方便、流畅的界面。它可以用于执行应用程序中的大多数数据库操作，并与Laravel支持的所有数据库系统完美配合。\r\n\r\nLaravel 9 查询生成器使用PDO参数绑定来保护应用程序免受SQL注入攻击。无需清理或清理作为查询绑定传递给查询生成器的字符串。\r\n\r\n> 注意：PDO不支持绑定列名。因此，永远不要允许用户输入指定查询引用的列名，包括「order by」列。\r\n\r\n<a name=\"running-database-queries\"></a>\r\n## 获取结果\r\n\r\n<a name=\"retrieving-all-rows-from-a-table\"></a>\r\n\r\n\r\n#### 从表中检索所有行\r\n\r\n你可以使用 `DB` facade 提供的 `table` 方法开始查询。`table` 方法为指定的表返回一个链式查询构造器实例，允许在查询上链接更多约束，最后使用 `get` 方法检索查询结果：\r\n\r\n```php\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示所有应用程序用户的列表。\r\n         *\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function index()\r\n        {\r\n            $users = DB::table('users')->get();\r\n\r\n            return view('user.index', ['users' => $users]);\r\n        }\r\n    }\r\n```\r\n\r\n`get` 方法返回包含查询结果的 `Illuminate\\Support\\Collection` 实例，每个结果都是 PHP  `stdClass` 实例。可以将列作为对象的属性来访问每列的值：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::table('users')->get();\r\n\r\n    foreach ($users as $user) {\r\n        echo $user->name;\r\n    }\r\n\r\n> 技巧：Laravel 集合提供了各种及其强大的方法来映射和裁剪数据。有关 Laravel 集合的更多信息，请查看[集合文档](/docs/laravel/9.x/collections)。\r\n\r\n<a name=\"retrieving-a-single-row-column-from-a-table\"></a>\r\n#### 从表中检索单行或单列\r\n\r\n如果只需要从数据表中检索单行，可以使用 `DB` facade 中的 `first` 方法。 此方法将返回单个 `stdClass` 对象\r\n\r\n    $user = DB::table('users')->where('name', 'John')->first();\r\n\r\n    return $user->email;\r\n\r\n如果不想要整行，可以使用 `value` 方法从纪录中提取单个值。此方法将直接返回列的值：\r\n\r\n    $email = DB::table('users')->where('name', 'John')->value('email');\r\n\r\n\r\n\r\n如果要通过 `id` 字段值获取单行数据，可以使用 `find` 方法：\r\n\r\n    $user = DB::table('users')->find(3);\r\n\r\n<a name=\"retrieving-a-list-of-column-values\"></a>\r\n#### 获取某一列的值\r\n\r\n如果您想获取包含单列值的集合，则可以使用 `pluck` 方法。在下面的例子中，我们将获取角色表中标题的集合：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $titles = DB::table('users')->pluck('title');\r\n\r\n    foreach ($titles as $title) {\r\n        echo $title;\r\n    }\r\n\r\n您可以通过向 `pluck` 方法提供第二个参数来指定结果集中要作为键的列：\r\n\r\n    $titles = DB::table('users')->pluck('title', 'name');\r\n\r\n    foreach ($titles as $name => $title) {\r\n        echo $title;\r\n    }\r\n\r\n<a name=\"chunking-results\"></a>\r\n### 分块结果\r\n\r\n如果您需要处理成千上万的数据库记录，请考虑使用 `DB` 提供的 `chunk` 方法。这个方法一次检索一小块结果，并将每个块反馈到闭包函数中进行处理。例如，让我们以一次 100 条记录的块为单位检索整个 `users` 表。\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::table('users')->orderBy('id')->chunk(100, function ($users) {\r\n        foreach ($users as $user) {\r\n            //\r\n        }\r\n    });\r\n\r\n您可以通过从闭包中返回 `false` 来停止处理其余的块:\r\n\r\n    DB::table('users')->orderBy('id')->chunk(100, function ($users) {\r\n        // Process the records...\r\n\r\n        return false;\r\n    });\r\n\r\n如果在对结果进行分块时更新数据库记录，那分块结果可能会以意想不到的方式更改。如果您打算在分块时更新检索到的记录，最好使用 `chunkById` 方法。此方法将根据记录的主键自动对结果进行分页:\r\n\r\n    DB::table('users')->where('active', false)\r\n        ->chunkById(100, function ($users) {\r\n            foreach ($users as $user) {\r\n                DB::table('users')\r\n                    ->where('id', $user->id)\r\n                    ->update(['active' => true]);\r\n            }\r\n        });\r\n\r\n> 注意：当在更新或删除块回调中的记录时，对主键或外键的任何更改都可能影响块查询。这可能会导致记录未包含在分块结果中。\r\n\r\n\r\n\r\n<a name=\"streaming-results-lazily\"></a>\r\n### Lazily 流式传输结果\r\n\r\n`lazy` 方法的工作方式类似于 [`chunk` 方法](#chunking-results)，因为它以块的形式执行查询。但是，`lazy()` 方法不是将每个块传递给回调，而是返回一个 [`LazyCollection`](/docs/laravel/9.x/collections#lazy-collections)，它可以让您与结果进行交互单个流：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\DB;\r\n\r\nDB::table('users')->orderBy('id')->lazy()->each(function ($user) {\r\n    //\r\n});\r\n```\r\n\r\n再一次，如果您打算在迭代它们时更新检索到的记录，最好使用 `lazyById` 或 `lazyByIdDesc` 方法。 这些方法将根据记录的主键自动对结果进行分页：\r\n\r\n```php\r\nDB::table('users')->where('active', false)\r\n    ->lazyById()->each(function ($user) {\r\n        DB::table('users')\r\n            ->where('id', $user->id)\r\n            ->update(['active' => true]);\r\n    });\r\n```\r\n\r\n> 注意：在迭代记录时更新或删除记录时，对主键或外键的任何更改都可能影响块查询。这可能会导致记录不包含在结果中。\r\n\r\n<a name=\"aggregates\"></a>\r\n### 聚合函数\r\n\r\n查询构建器还提供了多种检索聚合值的方法，例如 `count`, `max`, `min`, `avg`,和 `sum`。您可以在构建查询后调用这些方法中的任何一个：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::table('users')->count();\r\n\r\n    $price = DB::table('orders')->max('price');\r\n\r\n当然，您可以将这些方法与其他子句结合使用，以微调您的合计值的计算方式：\r\n\r\n    $price = DB::table('orders')\r\n                    ->where('finalized', 1)\r\n                    ->avg('price');\r\n\r\n\r\n\r\n<a name=\"determining-if-records-exist\"></a>\r\n#### 判断记录是否存在\r\n\r\n除了通过 `count` 方法可以确定查询条件的结果是否存在之外，还可以使用 `exists` 和 `doesntExist` 方法：\r\n\r\n    if (DB::table('orders')->where('finalized', 1)->exists()) {\r\n        // ...\r\n    }\r\n\r\n    if (DB::table('orders')->where('finalized', 1)->doesntExist()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"select-statements\"></a>\r\n## Select 语句\r\n\r\n<a name=\"specifying-a-select-clause\"></a>\r\n#### 指定一个 Select 语句\r\n\r\n当然你可能不是总是希望从数据库表中获取所有列。使用 `select` 方法，你可以自定义一个 「select」 查询语句来查询指定的字段：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::table('users')\r\n                ->select('name', 'email as user_email')\r\n                ->get();\r\n\r\n`distinct` 方法会强制让查询返回的结果不重复：\r\n\r\n    $users = DB::table('users')->distinct()->get();\r\n\r\n如果你已经有了一个查询构造器实例，并且希望在现有的查询语句中加入一个字段，那么你可以使用 `addSelect` 方法\r\n\r\n    $query = DB::table('users')->select('name');\r\n\r\n    $users = $query->addSelect('age')->get();\r\n\r\n<a name=\"raw-expressions\"></a>\r\n## 原生表达式\r\n\r\n有时可能需要在查询中插入任意字符串。要创建原始字符串表达式，可以使用 `DB` facade提供的`raw`方法：\r\n\r\n    $users = DB::table('users')\r\n                 ->select(DB::raw('count(*) as user_count, status'))\r\n                 ->where('status', '<>', 1)\r\n                 ->groupBy('status')\r\n                 ->get();\r\n\r\n> 注意：原生表达式将会被当做字符串注入到查询中，因此你应该极度小心避免创建 SQL 注入的漏洞。\r\n\r\n\r\n\r\n<a name=\"raw-methods\"></a>\r\n### 原生表达式\r\n\r\n可以使用以下方法代替 `DB::raw`，将原生表达式插入查询的各个部分。**注意，Laravel 无法保证所有使用原生表达式的查询都受到防 SQL 注入漏洞保护。**\r\n\r\n<a name=\"selectraw\"></a>\r\n#### `selectRaw`\r\n\r\n`selectRaw` 方法可以代替 `addSelect(DB::raw(...))`。该方法的第二个参数是可选项，值是一个绑定参数的数组：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->selectRaw('price * ? as price_with_tax', [1.0825])\r\n                    ->get();\r\n\r\n<a name=\"whereraw-orwhereraw\"></a>\r\n#### `whereRaw / orWhereRaw`\r\n\r\n`whereRaw` 和 `orWhereRaw` 方法将原生的「where」注入到你的查询中。这两个方法的第二个参数是可选项，值是一个绑定参数的数组：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->whereRaw('price > IF(state = \"TX\", ?, 100)', [200])\r\n                    ->get();\r\n\r\n<a name=\"havingraw-orhavingraw\"></a>\r\n#### `havingRaw / orHavingRaw`\r\n\r\n`havingRaw` 和 `orHavingRaw` 方法可以用于将原生字符串作为「having」语句的值。这两个方法的第二个参数是可选项，值是一个绑定参数的数组：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->select('department', DB::raw('SUM(price) as total_sales'))\r\n                    ->groupBy('department')\r\n                    ->havingRaw('SUM(price) > ?', [2500])\r\n                    ->get();\r\n\r\n<a name=\"orderbyraw\"></a>\r\n#### `orderByRaw`\r\n\r\n`orderByRaw` 方法可用于将原生字符串设置为「order by」语句的值：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->orderByRaw('updated_at - created_at DESC')\r\n                    ->get();\r\n\r\n<a name=\"groupbyraw\"></a>\r\n### `groupByRaw`\r\n\r\n`groupByRaw` 方法可以用于将原生字符串设置为 `group by` 语句的值：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->select('city', 'state')\r\n                    ->groupByRaw('city, state')\r\n                    ->get();\r\n\r\n\r\n\r\n<a name=\"joins\"></a>\r\n## Joins\r\n\r\n<a name=\"inner-join-clause\"></a>\r\n#### Inner Join  语句\r\n\r\n查询构造器也还可用于向查询中添加连接子句。若要执行基本的「内链接」，你可以对查询构造器实例使用 `join` 方法。传递给 `join` 方法的第一个参数是需要连接到的表的名称，而其余参数指定连接的列约束。您甚至还可以在一个查询中连接多个表：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::table('users')\r\n                ->join('contacts', 'users.id', '=', 'contacts.user_id')\r\n                ->join('orders', 'users.id', '=', 'orders.user_id')\r\n                ->select('users.*', 'contacts.phone', 'orders.price')\r\n                ->get();\r\n\r\n<a name=\"left-join-right-join-clause\"></a>\r\n#### Left Join / Right Join  语句\r\n\r\n如果你想使用 `left join`或者 `right join` 代替 `inner join` ，可以使用 `leftJoin` 或者 `rightJoin` 方法。这两个方法与 `join` 方法用法相同：\r\n\r\n    $users = DB::table('users')\r\n                ->leftJoin('posts', 'users.id', '=', 'posts.user_id')\r\n                ->get();\r\n\r\n    $users = DB::table('users')\r\n                ->rightJoin('posts', 'users.id', '=', 'posts.user_id')\r\n                ->get();\r\n\r\n<a name=\"cross-join-clause\"></a>\r\n#### Cross Join  语句\r\n\r\n你可以使用 `crossJoin` 方法执行「交叉连接」。交叉连接在第一个表和被连接的表之间会生成笛卡尔积：\r\n\r\n    $sizes = DB::table('sizes')\r\n                ->crossJoin('colors')\r\n                ->get();\r\n\r\n<a name=\"advanced-join-clauses\"></a>\r\n#### 高级 Join 语句\r\n\r\n您还可以指定更高级的联接子句。首先，将闭包作为第二个参数传递给 `join` 方法。闭包将收到一个`illumb\\Database\\Query\\JoinClause`实例，该实例允许您指定对`join`子句的约束：\r\n\r\n    DB::table('users')\r\n            ->join('contacts', function ($join) {\r\n                $join->on('users.id', '=', 'contacts.user_id')->orOn(...);\r\n            })\r\n            ->get();\r\n\r\n\r\n\r\n如果你想要在连接上使用「where」风格的语句，你可以在连接上使用 <code>JoinClause</code> 实例中的 <code>where</code> 和 <code>orWhere</code> 方法。这些方法会将列和值进行比较，而不是列和列进行比较：\r\n\r\n    DB::table('users')\r\n            ->join('contacts', function ($join) {\r\n                $join->on('users.id', '=', 'contacts.user_id')\r\n                     ->where('contacts.user_id', '>', 5);\r\n            })\r\n            ->get();\r\n\r\n<a name=\"subquery-joins\"></a>\r\n#### 子连接查询\r\n\r\n你可以使用 <code>joinSub</code>，<code>leftJoinSub</code> 和 <code>rightJoinSub</code> 方法关联一个查询作为子查询。他们每一种方法都会接收三个参数：子查询，表别名和定义关联字段的闭包。\r\n如下面这个例子，获取含有用户最近一次发布博客时的 <code>created_at</code> 时间戳的用户集合：\r\n\r\n    $latestPosts = DB::table('posts')\r\n                       ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))\r\n                       ->where('is_published', true)\r\n                       ->groupBy('user_id');\r\n\r\n    $users = DB::table('users')\r\n            ->joinSub($latestPosts, 'latest_posts', function ($join) {\r\n                $join->on('users.id', '=', 'latest_posts.user_id');\r\n            })->get();\r\n\r\n<a name=\"unions\"></a>\r\n## Unions\r\n\r\n查询构造器还提供了一种简洁的方式将两个或者多个查询「联合」在一起。例如，你可以先创建一个查询，然后使用 <code>union</code> 方法来连接更多的查询：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $first = DB::table('users')\r\n                ->whereNull('first_name');\r\n\r\n    $users = DB::table('users')\r\n                ->whereNull('last_name')\r\n                ->union($first)\r\n                ->get();\r\n查询构造器不仅提供了 <code>union</code> 方法，还提供了一个 <code>unionAll</code> 方法。当查询结合 <code>unionAll</code> 方法使用时，将不会删除重复的结果。<code>unionAll</code> 方法的用法和 <code>union</code> 方法一样。\r\n\r\n\r\n\r\n<a name=\"basic-where-clauses\"></a>\r\n## 基础的 Where 语句\r\n\r\n<a name=\"where-clauses\"></a>\r\n### Where 语句\r\n\r\n你可以在 where 语句中使用查询构造器的 <code>where</code> 方法。调用 <code>where</code> 方法需要三个基本参数。第一个参数是字段的名称。第二个参数是一个操作符，它可以是数据库中支持的任意操作符。第三个参数是与字段比较的值。\r\n\r\n例如。在 users 表中查询 <code>votes</code> 字段等于 <code>100</code> 并且 <code>age</code> 字段大于 <code>35</code> 的数据：\r\n\r\n    $users = DB::table('users')\r\n                    ->where('votes', '=', 100)\r\n                    ->where('age', '>', 35)\r\n                    ->get();\r\n\r\n为了方便起见。如果你想要比较一个字段的值是否 <code>等于</code> 给定的值。你可以将这个给定的值作为第二个参数传递给 where 方法。那么，Laravel 会默认使用 <code>=</code> 操作符：\r\n\r\n    $users = DB::table('users')->where('votes', 100)->get();\r\n\r\n如上所述，您可以使用数据库支持的任意操作符：\r\n\r\n    $users = DB::table('users')\r\n                    ->where('votes', '>=', 100)\r\n                    ->get();\r\n\r\n    $users = DB::table('users')\r\n                    ->where('votes', '<>', 100)\r\n                    ->get();\r\n\r\n    $users = DB::table('users')\r\n                    ->where('name', 'like', 'T%')\r\n                    ->get();\r\n\r\n您也可以将一个条件数组传递给 <code>where</code> 方法。通常传递给 <code>where</code> 方法的数组中的每一个元素都应该包含 3 个元素：\r\n\r\n    $users = DB::table('users')->where([\r\n        ['status', '=', '1'],\r\n        ['subscribed', '<>', '1'],\r\n    ])->get();\r\n\r\n> 注意：PDO 不支持绑定字段名。因此，你不应该允许让用户输入字段名进行查询引用，包括结果集「排序」语句。\r\n\r\n\r\n\r\n<a name=\"or-where-clauses\"></a>\r\n### Or Where 语句\r\n\r\n当链式调用多个 `where` 方法的时候，这些「where」语句将会被看成是 `and` 关系。另外，您也可以在查询语句中使用 `orWhere` 方法来表示 `or` 关系。`orWhere` 方法接收的参数和 `where` 方法接收的参数一样：\r\n\r\n    $users = DB::table('users')\r\n                        ->where('votes', '>', 100)\r\n                        ->orWhere('name', 'John')\r\n                        ->get();\r\n\r\n如果您需要在括号内对 `or` 条件进行分组，那么可以传递一个闭包作为 `orWhere` 方法的第一个参数：\r\n\r\n\r\n    $users = DB::table('users')\r\n                ->where('votes', '>', 100)\r\n                ->orWhere(function($query) {\r\n                    $query->where('name', 'Abigail')\r\n                          ->where('votes', '>', 50);\r\n                })\r\n                ->get();\r\n\r\n上面的示例将生成以下SQL：\r\n\r\n```sql\r\nselect * from users where votes > 100 or (name = 'Abigail' and votes > 50)\r\n```\r\n\r\n> 注意：为了避免应用全局作用出现意外，您应该用 orWhere 调用这个分组。\r\n\r\n<a name=\"json-where-clauses\"></a>\r\n### JSON Where 语句\r\n\r\nLaravel 也支持 JSON 类型的字段查询，前提是数据库也支持 JSON 类型。目前，有 MySQL 5.7+、PostgreSQL、SQL Server 2016 和 SQLite 3.9.0 支持 JSON 类型 (with the [JSON1 extension](https://www.sqlite.org/json1.html))。可以使用 `->` 操作符来查询 JSON 字段：\r\n\r\n    $users = DB::table('users')\r\n                    ->where('preferences->dining->meal', 'salad')\r\n                    ->get();\r\n\r\n您可以使用 `whereJsonContains` 方法来查询 JSON 数组。但是 SQLite 数据库不支持该功能：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereJsonContains('options->languages', 'en')\r\n                    ->get();\r\n\r\n如果您的应用使用的是 MySQL 或者 PostgreSQL 数据库，那么您可以向 `whereJsonContains` 方法中传递一个数组类型的值：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereJsonContains('options->languages', ['en', 'de'])\r\n                    ->get();\r\n\r\n\r\n\r\n你可以使用 <code>whereJsonLength</code> 方法来查询 JSON 数组的长度：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereJsonLength('options->languages', 0)\r\n                    ->get();\r\n\r\n    $users = DB::table('users')\r\n                    ->whereJsonLength('options->languages', '>', 1)\r\n                    ->get();\r\n\r\n<a name=\"additional-where-clauses\"></a>\r\n### 其他 Where 语句\r\n\r\n**whereBetween / orWhereBetween**\r\n\r\n<code>whereBetween</code> 方法是用来验证字段的值是否在给定的两个值之间：\r\n\r\n    $users = DB::table('users')\r\n               ->whereBetween('votes', [1, 100])\r\n               ->get();\r\n\r\n**whereNotBetween / orWhereNotBetween**\r\n\r\n<code>whereNotBetween</code> 方法是用来验证字段的值是否不在给定的两个值之间：\r\n\r\n    $users = DB::table('users')\r\n                        ->whereNotBetween('votes', [1, 100])\r\n                        ->get();\r\n\r\n**whereIn / whereNotIn / orWhereIn / orWhereNotIn**\r\n\r\n<code>whereIn</code> 方法是用来验证一个字段的值是否在给定的数组中：\r\n\r\n    $users = DB::table('users')\r\n                        ->whereIn('id', [1, 2, 3])\r\n                        ->get();\r\n\r\n<code>whereNotIn</code> 方法是用来验证一个字段的值是否不在给定的数组中：\r\n\r\n    $users = DB::table('users')\r\n                        ->whereNotIn('id', [1, 2, 3])\r\n                        ->get();\r\n\r\n> 注意：如果您在查询中用到了一个很大的数组，那么可以使用 <code>whereIntegerInRaw</code> 方法或者 <code>whereIntegerNotInRaw</code> 方法来减少内存的使用量。\r\n\r\n**whereNull / whereNotNull / orWhereNull / orWhereNotNull**\r\n\r\n<code>whereNull</code> 方法是用来验证给定字段的值是否为 <code>NULL</code>：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereNull('updated_at')\r\n                    ->get();\r\n\r\n<code>whereNotNull</code> 方法是用来验证给定字段的值是否不为 <code>NULL</code>\r\n\r\n    $users = DB::table('users')\r\n                    ->whereNotNull('updated_at')\r\n                    ->get();\r\n\r\n**whereDate / whereMonth / whereDay / whereYear / whereTime**\r\n\r\n<code>whereDate</code> 方法是用来比较字段的值与给定的日期值是否相等 （年 - 月 - 日）：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereDate('created_at', '2016-12-31')\r\n                    ->get();\r\n\r\n<code>whereMonth</code> 方法是用来比较字段的值与给定的月份是否相等（月）：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereMonth('created_at', '12')\r\n                    ->get();\r\n\r\n\r\n\r\n `whereDay` 方法可用于将列的值与当月的特定日期进行比较：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereDay('created_at', '31')\r\n                    ->get();\r\n\r\n `whereYear`方法可用于将列的值与特定年份进行比较：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereYear('created_at', '2016')\r\n                    ->get();\r\n\r\n`WhereTime`方法可用于将列的值与特定时间进行比较：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereTime('created_at', '=', '11:20:45')\r\n                    ->get();\r\n\r\n**whereColumn / orWhereColumn**\r\n\r\n`whereColumn` 方法是用来比较两个给定的字段的值是否相等：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereColumn('first_name', 'last_name')\r\n                    ->get();\r\n\r\n您也可以将比较运算符传递给`whereColumn`方法：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereColumn('updated_at', '>', 'created_at')\r\n                    ->get();\r\n\r\n您还可以向 `whereColumn` 方法中传递一个数组。这些条件将使用 `and` 运算符联接：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereColumn([\r\n                        ['first_name', '=', 'last_name'],\r\n                        ['updated_at', '>', 'created_at'],\r\n                    ])->get();\r\n\r\n<a name=\"logical-grouping\"></a>\r\n### 逻辑分组\r\n\r\n有时您可能需要将括号内的几个「where」子句分组，以实现查询所需的逻辑分组。实际上应该将 `orWhere` 方法的调用分组到括号中，以避免不可预料的查询逻辑误差。因此可以传递闭包给 `where` 方法：\r\n\r\n    $users = DB::table('users')\r\n               ->where('name', '=', 'John')\r\n               ->where(function ($query) {\r\n                   $query->where('votes', '>', 100)\r\n                         ->orWhere('title', '=', 'Admin');\r\n               })\r\n               ->get();\r\n\r\n\r\n\r\n你可以看到， 通过一个 `闭包` 写入 `where` 方法 构建一个查询构造器来约束一个分组。这个 `闭包` 接收一个查询实例，你可以使用这个实例来设置应该包含的约束。上面的例子将生成以下 SQL：\r\n\r\n```sql\r\nselect * from users where name = 'John' and (votes > 100 or title = 'Admin')\r\n```\r\n\r\n> 提示：你应该用 `orWhere` 调用这个分组，以避免应用全局作用时出现意外。\r\n\r\n<a name=\"advanced-where-clauses\"></a>\r\n### 高级 Where 语句\r\n\r\n<a name=\"where-exists-clauses\"></a>\r\n### Where Exists 语句\r\n\r\n`whereExists` 方法允许你使用 `where exists` SQL 语句。 `whereExists` 方法接收一个 `闭包` 参数，该闭包获取一个查询构建器实例，从而允许你定义放置在 `exists` 子句中查询:\r\n\r\n    $users = DB::table('users')\r\n               ->whereExists(function ($query) {\r\n                   $query->select(DB::raw(1))\r\n                         ->from('orders')\r\n                         ->whereColumn('orders.user_id', 'users.id');\r\n               })\r\n               ->get();\r\n\r\n上面的查询将产生如下的 `SQL` 语句：:\r\n\r\n```sql\r\nselect * from users\r\nwhere exists (\r\n    select 1\r\n    from orders\r\n    where orders.user_id = users.id\r\n)\r\n```\r\n\r\n<a name=\"subquery-where-clauses\"></a>\r\n### 子查询 Where 语句\r\n\r\n有时候，你可能需要构造一个 `where` 子查询，将子查询的结果与给定的值进行比较。你可以通过向 `where` 方法传递闭包和值来实现此操作。例如，下面的查询将检索最后一次「会员」购买记录是「Pro」类型的所有用户；\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where(function ($query) {\r\n        $query->select('type')\r\n            ->from('membership')\r\n            ->whereColumn('membership.user_id', 'users.id')\r\n            ->orderByDesc('membership.start_date')\r\n            ->limit(1);\r\n    }, 'Pro')->get();\r\n\r\n\r\n\r\n或者，您可能需要构建一个 `where` 子句，将列与子查询的结果进行比较。您可以通过将列、运算符和闭包传递给 `where` 方法来完成此操作。例如，以下查询将检索金额小于平均值的所有收入记录；\r\n\r\n    use App\\Models\\Income;\r\n\r\n    $incomes = Income::where('amount', '<', function ($query) {\r\n        $query->selectRaw('avg(i.amount)')->from('incomes as i');\r\n    })->get();\r\n\r\n<a name=\"full-text-where-clauses\"></a>\r\n### 全文 Where 子句\r\n\r\n> 注意：MySQL 和 PostgreSQL 目前支持全文 where 子句。\r\n\r\n可以使用`where FullText`和`orWhere FullText`方法将全文“WHERE”子句添加到具有[Full Text indexes](/docs/laravel/9.x/migrations#available-index-types)的列的查询中。这些方法将由Laravel转换为适用于底层数据库系统的SQL。例如，使用MySQL的应用会生成`Match AGAINST`子句：\r\n\r\n    $users = DB::table('users')\r\n               ->whereFullText('bio', 'web developer')\r\n               ->get();\r\n\r\n<a name=\"ordering-grouping-limit-and-offset\"></a>\r\n## Ordering, Grouping, Limit & Offset\r\n\r\n<a name=\"ordering\"></a>\r\n### 排序\r\n\r\n<a name=\"orderby\"></a>\r\n#### `orderBy` 方法\r\n\r\n`orderBy` 方法允许您按给定列对查询结果进行排序。`orderBy` 方法接受的第一个参数应该是您希望排序的列，而第二个参数确定排序的方向，可以是 `asc` 或 `desc`：\r\n\r\n    $users = DB::table('users')\r\n                    ->orderBy('name', 'desc')\r\n                    ->get();\r\n\r\n要按多列排序，您可以根据需要多次调用 `orderBy`：\r\n\r\n    $users = DB::table('users')\r\n                    ->orderBy('name', 'desc')\r\n                    ->orderBy('email', 'asc')\r\n                    ->get();\r\n\r\n\r\n\r\n<a name=\"latest-oldest\"></a>\r\n#### `latest` 和 `oldest` 方法\r\n\r\n`latest` 和 `oldest` 方法可以方便让你把结果根据日期排序。查询结果默认根据数据表的 `created_at` 字段进行排序 。或者，你可以传一个你想要排序的列名，通过:\r\n\r\n    $user = DB::table('users')\r\n                    ->latest()\r\n                    ->first();\r\n\r\n<a name=\"random-ordering\"></a>\r\n#### 随机排序\r\n\r\n`inRandomOrder` 方法被用来将查询结果随机排序。例如，你可以使用这个方法去获得一个随机用户:\r\n\r\n    $randomUser = DB::table('users')\r\n                    ->inRandomOrder()\r\n                    ->first();\r\n\r\n<a name=\"removing-existing-orderings\"></a>\r\n#### 移除已存在的排序\r\n\r\n`reorder` 方法会移除之前已经被应用到查询里的排序:\r\n\r\n    $query = DB::table('users')->orderBy('name');\r\n\r\n    $unorderedUsers = $query->reorder()->get();\r\n\r\n当你调用 `reorder` 方法去移除所有已经存在的排序的时候，你可以传递一个列名和排序方式去重新排序整个查询:\r\n\r\n    $query = DB::table('users')->orderBy('name');\r\n\r\n    $usersOrderedByEmail = $query->reorder('email', 'desc')->get();\r\n\r\n<a name=\"grouping\"></a>\r\n### 分组\r\n\r\n<a name=\"groupby-having\"></a>\r\n#### `groupBy` 和 `having` 方法\r\n\r\n如你所愿，`groupBy` 和 `having` 方法可以将查询结果分组。`having` 方法的使用方法类似于 `where` 方法:\r\n\r\n    $users = DB::table('users')\r\n                    ->groupBy('account_id')\r\n                    ->having('account_id', '>', 100)\r\n                    ->get();\r\n\r\n你可以使用 `havingBetween` 方法在一个给定的范围内去过滤结果:\r\n\r\n    $report = DB::table('orders')\r\n                    ->selectRaw('count(id) as number_of_orders, customer_id')\r\n                    ->groupBy('customer_id')\r\n                    ->havingBetween('number_of_orders', [5, 15])\r\n                    ->get();\r\n\r\n\r\n\r\n你可以传多个参数给 `groupBy` 方法将多列分组:\r\n\r\n    $users = DB::table('users')\r\n                    ->groupBy('first_name', 'status')\r\n                    ->having('account_id', '>', 100)\r\n                    ->get();\r\n\r\n想要构造更高级的 `having` 语句, 看 [`havingRaw`](#raw-methods) 方法。\r\n\r\n<a name=\"limit-and-offset\"></a>\r\n### Limit 和 Offset\r\n\r\n<a name=\"skip-take\"></a>\r\n####  `skip` 和 `take` 方法\r\n\r\n你可以使用 `skip` 和 `take` 方法去限制查询结果的返回数量或者在查询结果中跳过给定数量:\r\n\r\n    $users = DB::table('users')->skip(10)->take(5)->get();\r\n\r\n或者，你可以使用 `limit` 和 `offset` 方法。这些方法在功能上等同于 `take` 和 `skip` 方法, 如下:\r\n\r\n    $users = DB::table('users')\r\n                    ->offset(10)\r\n                    ->limit(5)\r\n                    ->get();\r\n\r\n<a name=\"conditional-clauses\"></a>\r\n## 条件语句\r\n\r\n有时，您可能希望根据另一个条件将某些查询子句应用于查询。例如，当传入 HTTP 请求有一个给定的值的时候你才需要使用一个`where` 语句。你可以使用 `when` 方法去实现:\r\n\r\n    $role = $request->input('role');\r\n\r\n    $users = DB::table('users')\r\n                    ->when($role, function ($query, $role) {\r\n                        return $query->where('role_id', $role);\r\n                    })\r\n                    ->get();\r\n\r\n `when` 方法只有当第一个参数为 `true` 的时候才执行给定的闭包。如果第一个参数是 `false`，闭包将不会被执行。因此，在上面的例子中，只要在传入的请求中存在 `role` 字段，并且结果为 `true` 的时候， `when` 方法里的闭包才会被调用。\r\n\r\n\r\n\r\n你可以将另一个闭包作为第三个参数传递给 `when` 方法。只有当第一个参数的计算结果为 `false`时，这个闭包才会执行。为了说明如何使用此功能，我们将使用它来配置查询的默认排序：\r\n\r\n    $sortByVotes = $request->input('sort_by_votes');\r\n\r\n    $users = DB::table('users')\r\n                    ->when($sortByVotes, function ($query, $sortByVotes) {\r\n                        return $query->orderBy('votes');\r\n                    }, function ($query) {\r\n                        return $query->orderBy('name');\r\n                    })\r\n                    ->get();\r\n\r\n<a name=\"insert-statements\"></a>\r\n## 插入语句\r\n\r\n查询构建器还提供了一个「插入」方法，可用于将记录插入到数据库表中。 `insert` 方法接受一个列名和值的数组：\r\n\r\n    DB::table('users')->insert([\r\n        'email' => 'kayla@example.com',\r\n        'votes' => 0\r\n    ]);\r\n\r\n你可以通过传递数组数组一次插入多条记录。每个数组代表一个应该插入到表中的记录：\r\n\r\n    DB::table('users')->insert([\r\n        ['email' => 'picard@example.com', 'votes' => 0],\r\n        ['email' => 'janeway@example.com', 'votes' => 0],\r\n    ]);\r\n\r\n`insertOrIgnore` 方法将在将记录插入数据库时忽略错误：\r\n\r\n    DB::table('users')->insertOrIgnore([\r\n        ['id' => 1, 'email' => 'sisko@example.com'],\r\n        ['id' => 2, 'email' => 'archer@example.com'],\r\n    ]);\r\n\r\n> 注意：`insertOrIgnore` 将忽略重复记录，也可能会忽略其他类型的错误，具体取决于数据库引擎。例如，`insertOrIgnore` 将 [绕过 MySQL 的严格模式](https://dev.mysql.com/doc/refman/en/sql-mode.html#ignore-effect-on-execution).\r\n\r\n<a name=\"auto-incrementing-ids\"></a>\r\n#### 自增 IDs\r\n\r\n如果数据表有自增 ID ，使用 insertGetId 方法来插入记录可以返回 ID 值：\r\n\r\n    $id = DB::table('users')->insertGetId(\r\n        ['email' => 'john@example.com', 'votes' => 0]\r\n    );\r\n\r\n> 注意：当使用 PostgreSQL 时，`insertGetId` 方法将默认把 `id` 作为自动递增字段的名称。如果你要从其他「字段」来获取 ID ，则需要将字段名称作为第二个参数传递给 `insertGetId` 方法。\r\n\r\n\r\n\r\n<a name=\"upserts\"></a>\r\n### Upserts\r\n\r\n`upsert` 方法将插入不存在的记录，并使用您可以指定的新值更新已经存在的记录。该方法的第一个参数包含要插入或更新的值，而第二个参数列出了在关联表中唯一标识记录的列。 该方法的第三个也是最后一个参数是一个列数组，如果数据库中已经存在匹配的记录，则应该更新这些列：\r\n\r\n    DB::table('flights')->upsert([\r\n        ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],\r\n        ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]\r\n    ], ['departure', 'destination'], ['price']);\r\n\r\n在上面的例子中，Laravel 会尝试插入两条记录。如果已经存在具有相同 `departure` 和 `destination` 列值的记录，Laravel 将更新该记录的 `price` 列。\r\n\r\n> 注意：除 SQL Server 之外的所有数据库都要求 `upsert` 方法的第二个参数中的列具有“主”或“唯一”索引。 此外，MySQL 数据库驱动程序忽略 `upsert` 方法的第二个参数，并始终使用表的“主”和“唯一”索引来检测现有记录。\r\n\r\n<a name=\"update-statements\"></a>\r\n## Update 语句\r\n\r\n除了将记录插入数据库之外，查询构建器还可以使用 `update` 方法更新现有记录。 `update` 方法与 `insert` 方法一样，接受一个列和值对数组，指示要更新的列。 `update` 方法返回受影响的行数。您可以使用 `where` 子句限制 `update` 查询：\r\n\r\n    $affected = DB::table('users')\r\n                  ->where('id', 1)\r\n                  ->update(['votes' => 1]);\r\n\r\n\r\n\r\n<a name=\"update-or-insert\"></a>\r\n#### 更新或新增\r\n\r\n有时您可能希望更新数据库中的现有记录，或者如果不存在匹配记录则创建它。在这种情况下，可以使用 `updateOrInsert` 方法。`updateOrInsert` 方法接受两个参数：一个用于查找记录的条件数组，以及一个包含要更该记录的键值对数组。\r\n\r\n`updateOrInsert` 方法将尝试使用第一个参数的列和值对来定位匹配的数据库记录。如果记录存在，它将使用第二个参数中的值进行更新。如果找不到记录，将插入一条新记录，其中包含两个参数的合并属性：\r\n\r\n    DB::table('users')\r\n        ->updateOrInsert(\r\n            ['email' => 'john@example.com', 'name' => 'John'],\r\n            ['votes' => '2']\r\n        );\r\n\r\n<a name=\"updating-json-columns\"></a>\r\n### 更新 JSON 字段\r\n\r\n更新 JSON 字段时，你可以使用 `->` 语法访问 JSON 对象中相应的值。注意，此操作只能支持 `MySQL 5.7+` 和 `PostgreSQL 9.5+` ：\r\n\r\n    $affected = DB::table('users')\r\n                  ->where('id', 1)\r\n                  ->update(['options->enabled' => true]);\r\n\r\n<a name=\"increment-and-decrement\"></a>\r\n### 自增与自减\r\n\r\n查询构建器还提供了方便的方法来增加或减少给定列的值。这两种方法都至少接受一个参数：要修改的列。可以提供第二个参数来指定列应该增加或减少的数量：\r\n\r\n    DB::table('users')->increment('votes');\r\n\r\n    DB::table('users')->increment('votes', 5);\r\n\r\n    DB::table('users')->decrement('votes');\r\n\r\n    DB::table('users')->decrement('votes', 5);\r\n\r\n\r\n\r\n您还可以在操作期间指定要更新的其他列：\r\n\r\n    DB::table('users')->increment('votes', 1, ['name' => 'John']);\r\n\r\n<a name=\"delete-statements\"></a>\r\n## 删除语句\r\n\r\n查询构建器的 `delete` 方法可用于从表中删除记录。 `delete` 方法返回受影响的行数。您可以通过在调用 `delete` 方法之前添加“where”子句来限制 `delete` 语句：\r\n\r\n    $deleted = DB::table('users')->delete();\r\n\r\n    $deleted = DB::table('users')->where('votes', '>', 100)->delete();\r\n\r\n如果您希望截断整个表，这将从表中删除所有记录并将自动递增 ID 重置为零，您可以使用 `truncate` 方法：\r\n\r\n    DB::table('users')->truncate();\r\n\r\n<a name=\"table-truncation-and-postgresql\"></a>\r\n#### 截断表 & PostgreSQL\r\n\r\n截断 PostgreSQL 数据库时，将应用 `CASCADE` 行为。这意味着其他表中所有与外键相关的记录也将被删除。\r\n\r\n<a name=\"pessimistic-locking\"></a>\r\n## 悲观锁\r\n\r\n查询构建器还包括一些函数，可帮助您在执行 `select` 语句时实现「悲观锁」。 要使用「共享锁」执行语句，您可以调用 `sharedLock` 方法。共享锁可防止选定的行被修改，直到您的事务被提交：\r\n\r\n    DB::table('users')\r\n            ->where('votes', '>', 100)\r\n            ->sharedLock()\r\n            ->get();\r\n\r\n或者，您可以使用 `lockForUpdate` 方法。「update」锁可防止所选记录被修改或被另一个共享锁选中：\r\n\r\n    DB::table('users')\r\n            ->where('votes', '>', 100)\r\n            ->lockForUpdate()\r\n            ->get();\r\n\r\n<a name=\"debugging\"></a>\r\n## 调试\r\n\r\n您可以在构建查询时使用 `dd` 和 `dump` 方法来转储当前查询绑定和 SQL。 `dd` 方法将显示调试信息，然后停止执行请求。 `dump` 方法将显示调试信息，但允许请求继续执行：\r\n\r\n    DB::table('users')->where('votes', '>', 100)->dd();\r\n\r\n    DB::table('users')->where('votes', '>', 100)->dump();\r\n\r\n","p":"docs/queries.html"},{"t":"pagination (数据库:分页)","d":"# 数据库:分页\r\n\r\n- [介绍](#介绍)\r\n- [基本用法](#基本用法)\r\n    - [对查询构造器结果进行分页](#对查询构造器结果进行分页)\r\n    - [Eloquent ORM 分页](#EloquentORM分页)\r\n    - [游标分页](#游标分页)\r\n    - [手动创建分页](#手动创建分页)\r\n    - [自定义分页的 URL](#自定义分页的URL)\r\n- [显示分页结果](#显示分页结果)\r\n    - [调整分页链接窗口](#调整分页链接窗口)\r\n    - [将结果转换为JSON](#将结果转换为JSON)\r\n- [自定义分页视图](#自定义分页视图)\r\n    - [使用 Bootstrap](#使用Bootstrap)\r\n- [分页器实例方法](#分页器实例方法)\r\n- [游标分页器实例方法](#游标分页器实例方法)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n在其他框架中，分页可能非常痛苦。我们希望Laravel的分页方法能带来一股新鲜空气。Laravel的分页器集成了 [query builder](/docs/laravel/9.x/queries) 和 [Eloquent ORM](/docs/laravel/9.x/eloquent)，并提供了方便、易于使用的数据库记录分页，无需配置。\r\n\r\n默认情况下，由分页器生成的HTML与 [Tailwind CSS 框架](https://tailwindcss.com/) 兼容，然而，引导分页支持也是可用的。\r\n\r\n<a name=\"tailwind-jit\"></a>\r\n#### Tailwind JIT\r\n\r\n如果你使用Laravel的默认 Tailwind 视图和 Tailwind JIT 引擎，你应该确保你的应用程序的 `tailwind.config.js` 文件的 `content` 关键引用Laravel的分页视图，这样它们的 Tailwind 类就不会被清除：\r\n\r\n```js\r\ncontent: [\r\n    './resources/**/*.blade.php',\r\n    './resources/**/*.js',\r\n    './resources/**/*.vue',\r\n    './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php',\r\n],\r\n```\r\n\r\n<a name=\"basic-usage\"></a>\r\n## 基本用法\r\n\r\n<a name=\"对查询构造器结果进行分页\"></a>\r\n### 对查询构造器结果进行分页\r\n\r\n有几种方法可以对结果进行分页，最简单的方法是在 [query builder](/docs/laravel/9.x/queries) 或 [Eloquent query](/docs/laravel/9.x/eloquent)。上使用 `paginate` 方法 ，`paginate` 方法根据用户查看的当前页面自动设置查询的 「limit」 和 「offset」 ， 默认情况下，通过HTTP请求中的 `page` 查询字符串参数的值检测当前页面， Laravel会自动检测这个值，它也会自动插入到分页器生成的链接中。\r\n\r\n\r\n\r\n在下面的例子中，传递给 `paginate` 方法的唯一参数是你想要在一页中显示的记录数。在此例中，我们希望「每页」显示 `15` 条数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示所有用户列表.\r\n         *\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function index()\r\n        {\r\n            return view('user.index', [\r\n                'users' => DB::table('users')->paginate(15)\r\n            ]);\r\n        }\r\n    }\r\n\r\n<a name=\"simple-pagination\"></a>\r\n#### 简单分页\r\n\r\n该 `paginate` 方法会在查询数据库之前先计算与查询匹配的记录总数，从而让分页器知道总共需要有多少个页面来显示所有的记录。不过，如果你不打算在界面上显示总页数的话，那么计算记录总数是没有意义的。\r\n\r\n因此，如果你只需要显示一个简单的「上一页」和「下一页」链接的话， `simplePaginate` 方法是一个更高效的选择：\r\n\r\n    $users = DB::table('users')->simplePaginate(15);\r\n\r\n<a name=\"EloquentORM分页\"></a>\r\n### Eloquent ORM 分页\r\n\r\n你也可以对 [Eloquent](/docs/laravel/9.x/eloquent) 查询结果进行分页。在下面的例子中，我们将 `App\\Models\\User` 模型按每页 `15` 条记录进行分页。如你所见，其语法与查询构造器分页基本相同：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::paginate(15);\r\n\r\n当然，你也可以在调用 `paginate` 方法之前为查询添加其他约束，例如 `where` 子句：\r\n\r\n    $users = User::where('votes', '>', 100)->paginate(15);\r\n\r\n\r\n\r\n你也可以在 Eloquent ORM 分页中使用 `simplePaginate`：\r\n\r\n    $users = User::where('votes', '>', 100)->simplePaginate(15);\r\n\r\n同样，您可以使用 `cursorPaginate` 方法对 Eloquent 模型进行光标分页：\r\n\r\n    $users = User::where('votes', '>', 100)->cursorPaginate(15);\r\n\r\n<a name=\"multiple-paginator-instances-per-page\"></a>\r\n#### 每页有多个 Paginator 实例\r\n\r\n有时您可能需要在应用程序呈现的单个屏幕上呈现两个单独的分页器。 但是，如果两个分页器实例都使用 `page` 查询字符串参数来存储当前页面，则两个分页器会发生冲突。 要解决此冲突，您可以通过提供给 `paginate`、`simplePaginate` 和 `cursorPaginate` 方法的第三个参数传递您希望用于存储分页器当前页面的查询字符串参数的名称：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where('votes', '>', 100)->paginate(\r\n        $perPage = 15, $columns = ['*'], $pageName = 'users'\r\n    );\r\n\r\n<a name=\"cursor-pagination\"></a>\r\n### 游标分页\r\n\r\n虽然 `paginate` 和 `simplePaginate` 使用 SQL「offset」 子句创建查询，但游标分页通过构造「where」子句来工作，这些子句比较查询中包含的有序列的值，提供所有可用的最有效的数据库性能 Laravel 的分页方法。 这种分页方法特别适合大型数据集和「无限」滚动用户界面。\r\n\r\n与基于偏移量的分页在分页器生成的 URL 的查询字符串中包含页码不同，基于游标的分页在查询字符串中放置一个「游标」字符串。游标是一个编码字符串，包含下一个分页查询应该开始分页的位置和它应该分页的方向：\r\n\r\n```nothing\r\nhttp://localhost/users?cursor=eyJpZCI6MTUsIl9wb2ludHNUb05leHRJdGVtcyI6dHJ1ZX0\r\n```\r\n\r\n\r\n\r\n您可以通过查询生成器提供的 `cursorPaginate` 方法创建基于游标的分页器实例。这个方法返回一个 `Illuminate\\Pagination\\CursorPaginator` 的实例：\r\n\r\n    $users = DB::table('users')->orderBy('id')->cursorPaginate(15);\r\n\r\n检索到游标分页器实例后，您可以像使用 `paginate` 和 `simplePaginate` 方法时一样[显示分页结果](#displaying-pagination-results)。更多游标分页器提供的实例方法请参考[游标分页器实例方法文档](#cursor-paginator-instance-methods).\r\n\r\n> 注意：您的查询必须包含「order by」子句才能使用游标分页。\r\n\r\n<a name=\"cursor-vs-offset-pagination\"></a>\r\n#### 游标与偏移分页\r\n\r\n为了说明偏移分页和游标分页之间的区别，让我们检查一些示例 SQL 查询。 以下两个查询都将显示按 `id` 排序的 `users` 表的「第二页」结果：\r\n\r\n```sql\r\n# 偏移分页...\r\nselect * from users order by id asc limit 15 offset 15;\r\n\r\n# 游标分页...\r\nselect * from users where id > 15 order by id asc limit 15;\r\n```\r\n\r\n与偏移分页相比，游标分页查询具有以下优势：\r\n\r\n- 对于大型数据集，如果「order by」列被索引，游标分页将提供更好的性能。 这是因为「offset」子句会扫描所有先前匹配的数据。\r\n- 对于频繁写入的数据集，如果最近在用户当前查看的页面中添加或删除了结果，偏移分页可能会跳过记录或显示重复。\r\n\r\n但是，游标分页有以下限制：\r\n\r\n- 与 `simplePaginate` 一样，游标分页只能用于显示「下一个」和「上一个」链接，不支持生成带页码的链接。\r\n- 它要求排序基于至少一个唯一列或唯一列的组合。 不支持具有 `null` 值的列。\r\n- 「order by」子句中的查询表达式仅在它们被别名并添加到「select」子句时才受支持。\r\n\r\n\r\n\r\n<a name=\"手动创建分页\"></a>\r\n### 手动创建分页\r\n\r\n有时你可能希望手动创建分页，并传递一个包含数据的数组给它。这可以通过手动创建 `Illuminate\\Pagination\\Paginator` 或者 `Illuminate\\Pagination\\LengthAwarePaginator` 实例来实现，这取决于你的需要。\r\n\r\n`Paginator` 不需要知道数据的总数。然而，你也无法通过 `Paginator` 获取最后一页的索引。而 `LengthAwarePaginator` 接受和 `Paginator` 几乎相同的参数，不过，它会计算数据的总数。\r\n\r\n或者说，`Paginator` 相当于查询构造器或者 Eloquent ORM 分页的 `simplePaginate` 方法，而 `LengthAwarePaginator` 相当于 `paginate` 方法。\r\n\r\n> 注意：手动创建分页器实例时，您应该手动「切片」传递给分页器的结果数组。如果您不确定如何执行此操作，请查看 [array_slice](https://secure.php.net/manual/en/function.array-slice.php) PHP 函数。\r\n\r\n<a name=\"自定义分页的URL\"></a>\r\n### 自定义分页的 URL\r\n\r\n默认情况下，分页器生成的链接会匹配当前的请求 URL。不过，分页器的 withPath 方法允许你自定义分页器生成链接时使用的 URL。比如说，你想要分页器生成类似 https://example.com/admin/users?page=N 的链接，你应该给 `withPath` 方法传递 `/admin/users` 参数：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        $users = User::paginate(15);\r\n\r\n        $users->withPath('/admin/users');\r\n\r\n        //\r\n    });\r\n\r\n\r\n\r\n<a name=\"appending-query-string-values\"></a>\r\n#### 附加参数到分页链接\r\n\r\n你可以使用 `appends` 方法向分页链接中添加查询参数。例如，要在每个分页链接中添加 `sort=votes` ，你应该这样调用 `appends`：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        $users = User::paginate(15);\r\n\r\n        $users->appends(['sort' => 'votes']);\r\n\r\n        //\r\n    });\r\n\r\n如果你想要把当前所有的请求查询参数添加到分页链接，你可以使用 `withQueryString` 方法：\r\n\r\n    $users = User::paginate(15)->withQueryString();\r\n\r\n<a name=\"appending-hash-fragments\"></a>\r\n#### 附加 hash 片段\r\n\r\n如果你希望向分页器的 URL 添加「哈希片段」，你可以使用 `fragment` 方法。例如，你可以使用以下方法向分页链接添加 `#foo`：\r\n\r\n    $users = User::paginate(15)->fragment('users');\r\n\r\n<a name=\"displaying-pagination-results\"></a>\r\n## 显示分页结果\r\n\r\n当调用 `paginate` 方法时，你会得到一个 `Illuminate\\Pagination\\LengthAwarePaginator` 实例。而调用 `simplePaginate` 方法时，你会得到 `Illuminate\\Pagination\\Paginator` 的实例。\r\n\r\n这些对象提供了数个方法来获取结果集的信息。除了这些辅助方法外，分页器的实例是迭代器，可以像数组一样遍历。所以，你可以使用 [Blade](https://learnku.com/docs/laravel/9.x/blade) 模板来显示数据、渲染分页链接等：\r\n\r\n```blade\r\n<div class=\"container\">\r\n    @foreach ($users as $user)\r\n        {{ $user->name }}\r\n    @endforeach\r\n</div>\r\n\r\n{{ $users->links() }}\r\n```\r\n\r\nlinks 方法会渲染结果集中剩余页面的链接。每个链接都包含了 page 查询字符串变量。请记住，links 方法生成的 HTML 兼容 [Tailwind CSS 框架](https://tailwindcss.com) 。\r\n\r\n\r\n<a name=\"adjusting-the-pagination-link-window\"></a>\r\n### 调整分页链接窗口\r\n\r\n在使用分页器展示分页链接时，将展示当前页前后各三页的链接。如果有需要，你可以通过 `onEachSide` 方法来控制每侧显示多少个链接：\r\n\r\n```blade\r\n{{ $users->onEachSide(5)->links() }}\r\n```\r\n\r\n<a name=\"converting-results-to-json\"></a>\r\n### 将结果转换为JSON\r\n\r\nLaravel 分页器类实现了 `Illuminate\\Contracts\\Support\\Jsonable` 接口契约，提供了 `toJson` 方法。这意味着你可以很方便地将分页结果转换为 JSON。你也可以通过直接在路由闭包或者控制器方法中返回分页实例来将其转换为 JSON：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return User::paginate();\r\n    });\r\n\r\n分页器生成的 JSON 会包括诸如 `total`，`current_page`，`last_page`等元数据信息。实际结果对象将通过 JSON 数组的 `data` 键提供。以下是通过自路由中分页器实例的方式创建 JSON 的例子：\r\n\r\n    {\r\n       \"total\": 50,\r\n       \"per_page\": 15,\r\n       \"current_page\": 1,\r\n       \"last_page\": 4,\r\n       \"first_page_url\": \"http://laravel.app?page=1\",\r\n       \"last_page_url\": \"http://laravel.app?page=4\",\r\n       \"next_page_url\": \"http://laravel.app?page=2\",\r\n       \"prev_page_url\": null,\r\n       \"path\": \"http://laravel.app\",\r\n       \"from\": 1,\r\n       \"to\": 15,\r\n       \"data\":[\r\n            {\r\n                // Record...\r\n            },\r\n            {\r\n                // Record...\r\n            }\r\n       ]\r\n    }\r\n\r\n<a name=\"customizing-the-pagination-view\"></a>\r\n## 自定义分页视图\r\n\r\n默认情况下，分页器渲染的视图与 [Tailwind CSS](https://tailwindcss.com) 兼容。不过，如果你并非使用 Tailwind，你也可以自由地定义用于渲染这些链接的视图。在调用分页器实例的 `links` 方法时，将视图名称作为第一个参数传递给该方法：\r\n\r\n```blade\r\n{{ $paginator->links('view.name') }}\r\n\r\n<!-- Passing additional data to the view... -->\r\n{{ $paginator->links('view.name', ['foo' => 'bar']) }}\r\n```\r\n\r\n\r\n\r\n不过，最简单的自定义分页视图的方法依然是使用 `vendor:publish` 命令将它们导出到 `resources/views/vendor` 目录：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-pagination\r\n```\r\n\r\n这个命令将会把分页视图导出到 `resources/views/vendor/pagination` 目录。该目录下的 `tailwind.blade.php` 文件就是默认的分页视图。你可以通过编辑这一文件来自定义分页视图。\r\n\r\n如果你想要定义不同的文件作为默认的分页视图，你可以在 `App\\Providers\\AppServiceProvider` 服务提供者中的 `boot` 方法内调用 `defaultView` 和 `defaultSimpleView` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Pagination\\Paginator;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * Bootstrap any application services.\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Paginator::defaultView('view-name');\r\n\r\n            Paginator::defaultSimpleView('view-name');\r\n        }\r\n    }\r\n\r\n<a name=\"使用Bootstrap\"></a>\r\n### 使用 Bootstrap\r\n\r\nLaravel 同样包含使用 [Bootstrap CSS](https://getbootstrap.com/) 构建的分页视图。要使用这些视图来替代默认的 Tailwind 视图，你可以在 `App\\Providers\\AppServiceProvider` 服务提供者中的 `boot` 方法内调用分页器的 `useBootstrapFour` 或 `useBootstrapFive` 方法：\r\n\r\n    use Illuminate\\Pagination\\Paginator;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Paginator::useBootstrapFive();\r\n        Paginator::useBootstrapFour();\r\n    }\r\n\r\n<a name=\"paginator-instance-methods\"></a>\r\n## 分页器实例方法\r\n\r\n每一个分页器实例都提供了下列方法来获取分页信息：\r\n\r\n方法  |  描述\r\n-------  |  -----------\r\n`$paginator->count()`  |  获取当前页的数据总数\r\n`$paginator->currentPage()`  |  获取当前页码\r\n`$paginator->firstItem()`  |  获取结果集中第一个数据的编号\r\n`$paginator->getOptions()`  |  获取分页器选项\r\n`$paginator->getUrlRange($start, $end)`  |  创建指定页数范围的 URL\r\n`$paginator->hasPages()`  |  是否有足够多的数据来创建多个页面\r\n`$paginator->hasMorePages()`  |  是否有更多的页面可供展示\r\n`$paginator->items()`  |  获取当前页的数据项\r\n`$paginator->lastItem()`  |  获取结果集中最后一个数据的编号\r\n`$paginator->lastPage()`  |  获取最后一页的页码（在`simplePaginate`中不可用）\r\n`$paginator->nextPageUrl()`  |  获取下一页的 URL\r\n`$paginator->onFirstPage()`  |  当前页是否为第一页\r\n`$paginator->perPage()`  |  获取每一页显示的数量总数\r\n`$paginator->previousPageUrl()`  |  获取上一页的 URL\r\n`$paginator->total()`  |  获取结果集中的数据总数（在 `simplePaginate`中不可用）\r\n`$paginator->url($page)`  |  获取指定页的 URL\r\n`$paginator->getPageName()`  |  获取用于储存页码的查询参数名\r\n`$paginator->setPageName($name)`  |  设置用于储存页码的查询参数名\r\n\r\n\r\n\r\n<a name=\"cursor-paginator-instance-methods\"></a>\r\n## 游标分页器实例方法\r\n\r\n每一个分页器实例都提供了下列额外方法来获取分页信息:\r\n\r\n方法  |  描述\r\n-------  |  -----------\r\n`$paginator->count()`  |  获取当前页的数据总数\r\n`$paginator->cursor()`  |  获取当前分页实例\r\n`$paginator->getOptions()`  |  获取分页参数选项\r\n`$paginator->hasPages()`  |  判断是否有足够数据用于分页\r\n`$paginator->hasMorePages()`  |  判断数据存储是否还有更多项目\r\n`$paginator->getCursorName()`  |  获取用于查询实例的变量名称\r\n`$paginator->items()`  | 获取当前页面的数据项目\r\n`$paginator->nextCursor()`  |  获取下一页数据实例\r\n`$paginator->nextPageUrl()`  | 获取下一页URL\r\n`$paginator->onFirstPage()`  |  判断页面是否属于第一页\r\n`$paginator->perPage()`  |  每页显示的数据数量\r\n`$paginator->previousCursor()`  |  获取上一页数据实例\r\n`$paginator->previousPageUrl()`  |  获取上一页URL\r\n`$paginator->setCursorName()`  |  设置用于查询实例的变量名称\r\n`$paginator->url($cursor)`  |  获取指定实例的 URL\r\n\r\n","p":"docs/pagination.html"},{"t":"migrations (数据库: 迁移)","d":"# 数据库: 迁移\r\n\r\n- [介绍](#介绍)\r\n- [生成迁移](#生成迁移)\r\n    - [整合迁移](#整合迁移)\r\n- [迁移结构](#迁移结构)\r\n- [执行迁移](#执行迁移)\r\n    - [回滚迁移](#回滚迁移)\r\n- [数据表](#数据表)\r\n    - [创建数据表](#创建数据表)\r\n    - [更新数据表](#更新数据表)\r\n    - [重命名 / 删除表](#重命名-删除表)\r\n- [字段](#字段)\r\n    - [创建字段](#创建字段)\r\n    - [可用的字段类型](#可用的字段类型)\r\n    - [字段修饰符](#字段修饰符)\r\n    - [修改字段](#修改字段)\r\n    - [删除字段](#删除字段)\r\n- [索引](#索引)\r\n    - [创建索引](#创建索引)\r\n    - [重命名索引](#重命名索引)\r\n    - [删除索引](#删除索引)\r\n    - [外键约束](#外键约束)\r\n- [事件](#事件)\r\n\r\n<a name=\"介绍\"></a>\r\n## 介绍\r\n\r\n迁移就像是数据库的版本控制，让你的团队能够轻松地去定义和共享程序的数据库结构。迁移通常配合 Laravel 的结构生成器，可以轻松生成应用程序的数据库结构。如果团队中有成员在他的本地数据库环境中手动的添加了某个字段，那么你将会面对如何解决数据库迁移的问题。\r\n\r\n Laravel 9 `Schema` [facade](/docs/laravel/9.x/facades) 提供了数据库相关的支持，可以在所有Laravel支持的数据库管理系统中创建和操作表。\r\n\r\n<a name=\"生成迁移\"></a>\r\n## 生成迁移\r\n\r\n你可以使用 `make:migration` [Artisan command](/docs/laravel/9.x/artisan) 生成数据库迁移。新的迁移将放在您的 `database/migrations` 目录每个迁移文件名都包含一个时间戳，允许Laravel确定迁移的顺序：\r\n\r\n```shell\r\nphp artisan make:migration create_flights_table\r\n```\r\n\r\nLaravel会根据迁移文件的名称确定表的名称已经是否在前一种创建新的数据表。\r\n\r\n\r\n\r\n如果要为生成的迁移指定自定义路径, 您可以在执行 `make:migration` 命令时使用 `--path` 选项。给定的路径应该相对于应用程序的基本路径。\r\n\r\n> 技巧：可以使用 [stub publishing](/docs/laravel/9.x/artisan#stub-customization) 自定义发布。\r\n\r\n<a name=\"整合迁移\"></a>\r\n### 整合迁移\r\n\r\n在构建应用程序时，可能会随着时间的推移积累越来越多的迁移。这可能会导致您的 `database/migrations` 目录因为数百次迁移而变得臃肿。你如果愿意的话，可以将迁移「压缩」到单个 SQL 文件中。如果你想这样做，请先执行`schema:dump` 命令：\r\n\r\n```shell\r\nphp artisan schema:dump\r\n\r\n# 转储当前数据库架构并删除所有现有迁移...\r\nphp artisan schema:dump --prune\r\n```\r\n\r\n执行此命令时， Laravel 将向应用程序的 `database/schema` 目录写入一个 「schema」 文件。现在，当您尝试迁移数据库而没有执行其他迁移时， Laravel 将首先执行模式文件的 SQL 语句。在执行数据库结构文件的语句之后，Laravel 将执行不属于数据库结构的剩余的所有迁移。\r\n\r\n您应该将数据库模式文件提交给源代码管理，以便团队中的其他新开发人员可以快速创建应用程序的初始数据库结构。\r\n\r\n> 注意：压缩迁移仅适用于 MySQL 、 PostgreSQL 和 SQLite 数据库，并使用数据库命令行的客户端。另外，数据库结构不能还原到内存中的 SQLite 数据库。\r\n\r\n<a name=\"迁移结构\"></a>\r\n## 迁移结构\r\n\r\n迁移类包含两个方法：`up` 和 `down` 。`up` 方法用于向数据库中添加新表、列或索引，而 down 方法用于撤销 `up ` 方法执行的操作。.\r\n\r\n\r\n\r\n在这两种方法中，可以使用 Laravel 模式构建器来富有表现力地创建和修改表。要了解 `Schema` 构建器上可用的所有方法，[查看其文档](#creating-tables)。例如，以下迁移会创建一个 `flights` 表：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Database\\Migrations\\Migration;\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    return new class extends Migration\r\n    {\r\n        /**\r\n         * Run the migrations.\r\n         *\r\n         * @return void\r\n         */\r\n        public function up()\r\n        {\r\n            Schema::create('flights', function (Blueprint $table) {\r\n                $table->id();\r\n                $table->string('name');\r\n                $table->string('airline');\r\n                $table->timestamps();\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reverse the migrations.\r\n         *\r\n         * @return void\r\n         */\r\n        public function down()\r\n        {\r\n            Schema::drop('flights');\r\n        }\r\n    };\r\n\r\n<a name=\"设置迁移连接\"></a>\r\n#### 设置迁移连接\r\n\r\n如果您的迁移将与应用程序默认数据库连接以外的数据库连接进行交互，您应该设置迁移的 `$connection` 属性：\r\n\r\n    /**\r\n     * 迁移应使用的数据库连接。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $connection = 'pgsql';\r\n\r\n    /**\r\n     * 执行迁移。\r\n     *\r\n     * @return void\r\n     */\r\n    public function up()\r\n    {\r\n        //\r\n    }\r\n\r\n<a name=\"执行迁移\"></a>\r\n## 执行迁移\r\n\r\n执行 Artisan 命令 migrate，来运行所有未执行过的迁移：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n\r\n\r\n如果你想查看目前已经执行了哪些迁移，可以使用 `migrate:status` Artisan 命令：\r\n\r\n```shell\r\nphp artisan migrate:status\r\n```\r\n\r\n<a name=\"在生产环境中执行强制迁移\"></a>\r\n#### 在生产环境中执行强制迁移\r\n\r\n有些迁移操作是破坏性的，这意味着它们可能会导致数据丢失。为了防止您对生产数据库运行这些命令，在执行这些命令之前，系统将提示您进行确认。如果要在运行强制命令的时候去掉提示，需要加上 `--force` 标志：\r\n\r\n```shell\r\nphp artisan migrate --force\r\n```\r\n\r\n<a name=\"回滚迁移\"></a>\r\n### 回滚迁移\r\n\r\n如果要回滚最后一次迁移操作，可以使用 Artisan 命令 `rollback`。该命令会回滚最后「一批」的迁移，这可能包含多个迁移文件：\r\n\r\n```shell\r\nphp artisan migrate:rollback\r\n```\r\n\r\n通过向 rollback 命令加上 step 参数，可以回滚指定数量的迁移。例如，以下命令将回滚最后五个迁移：\r\n\r\n```shell\r\nphp artisan migrate:rollback --step=5\r\n```\r\n\r\n命令 `migrate:reset` 会回滚应用已运行过的所有迁移：\r\n\r\n```shell\r\nphp artisan migrate:reset\r\n```\r\n\r\n<a name=\"使用单个命令同时进行回滚和迁移操作\"></a>\r\n#### 使用单个命令同时进行回滚和迁移操作\r\n\r\n命令 `migrate:refresh` 首先会回滚已运行过的所有迁移，随后会执行 migrate。这一命令可以高效地重建你的整个数据库：\r\n\r\n```shell\r\nphp artisan migrate:refresh\r\n\r\n# 重置数据库，并运行所有的 seeds...\r\nphp artisan migrate:refresh --seed\r\n```\r\n\r\n通过在命令 refresh 中使用 step 参数，你可以回滚并重新执行指定数量的迁移操作。例如，下列命令会回滚并重新执行最后五个迁移操作：\r\n\r\n```shell\r\nphp artisan migrate:refresh --step=5\r\n```\r\n\r\n\r\n\r\n<a name=\"删除所有表然后执行迁移\"></a>\r\n#### 删除所有表然后执行迁移\r\n\r\n命令 `migrate:fresh` 会删去数据库中的所有表，随后执行命令 `migrate`：\r\n\r\n```shell\r\nphp artisan migrate:fresh\r\n\r\nphp artisan migrate:fresh --seed\r\n```\r\n\r\n> 注意：该命令 `migrate:fresh` 在删去所有数据表的过程中，会无视它们的前缀。如果数据库涉及到其它应用，使用该命令须十分小心。\r\n\r\n<a name=\"数据表\"></a>\r\n## 数据表\r\n\r\n<a name=\"创建数据表\"></a>\r\n### 创建数据表\r\n\r\n接下来我们将使用 Schema 的 `create` 方法创建一个新的数据表。`create` 接受两个参数：第一个参数是表名，而第二个参数是一个闭包，该闭包接受一个用来定义新数据表的 `Blueprint` 对象：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::create('users', function (Blueprint $table) {\r\n        $table->id();\r\n        $table->string('name');\r\n        $table->string('email');\r\n        $table->timestamps();\r\n    });\r\n\r\n创建表时，可以使用数据库结构构建器的 [列方法](#creating-columns) 来定义表的列。\r\n\r\n<a name=\"检查表-列是否存在\"></a>\r\n#### 检查表 / 列是否存在\r\n\r\n您可以使用 `hasTable` 和 `hasColumn` 方法检查表或列是否存在：\r\n\r\n    if (Schema::hasTable('users')) {\r\n        // \"users\" 表存在...\r\n    }\r\n\r\n    if (Schema::hasColumn('users', 'email')) {\r\n        // \"users\" 表存在，并且有 \"email\" 列...\r\n    }\r\n\r\n<a name=\"数据库连接和表选项\"></a>\r\n#### 数据库连接和表选项\r\n\r\n如果要对不是应用程序默认的数据库连接执行数据库结构的操作，请使用 `connection` 方法：\r\n\r\n    Schema::connection('sqlite')->create('users', function (Blueprint $table) {\r\n        $table->id();\r\n    });\r\n\r\n\r\n\r\n此外，还可以使用其他一些属性和方法来定义表创建的其他地方。使用 MySQL 时，可以使用 engine 属性指定表的存储引擎：\r\n\r\n    Schema::create('users', function (Blueprint $table) {\r\n        $table->engine = 'InnoDB';\r\n\r\n        // ...\r\n    });\r\n\r\n`charset` 和 `collation` 属性可用于在使用 MySQL 时为创建的表指定字符集和排序规则：\r\n\r\n    Schema::create('users', function (Blueprint $table) {\r\n        $table->charset = 'utf8mb4';\r\n        $table->collation = 'utf8mb4_unicode_ci';\r\n\r\n        // ...\r\n    });\r\n\r\n`temporary` 方法可用于将表标识为「临时」状态。临时表仅对当前连接的数据库会话可见，当连接关闭时会自动删除：\r\n\r\n    Schema::create('calculations', function (Blueprint $table) {\r\n        $table->temporary();\r\n\r\n        // ...\r\n    });\r\n\r\n如果你想给数据库表添加「注释」，你可以在表实例上调用`comment`方法。目前只有 MySQL 和 Postgres 支持表注释：\r\n\r\n    Schema::create('calculations', function (Blueprint $table) {\r\n        $table->comment('Business calculations');\r\n\r\n        // ...\r\n    });\r\n\r\n<a name=\"更新数据表\"></a>\r\n### 更新数据表\r\n\r\n`Schema` 门面的 `table` 方法可用于更新现有表。 与 `create` 方法一样，`table` 方法接受两个参数：表的名称和接收可用于向表添加列或索引的 `Blueprint` 实例的闭包：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->integer('votes');\r\n    });\r\n\r\n<a name=\"重命名-删除表\"></a>\r\n### 重命名 / 删除表\r\n\r\n要重命名已存在的数据表，使用 `rename` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::rename($from, $to);\r\n\r\n要删除已存在的表，您可以使用 `drop` 或 `dropIfExists` 方法：\r\n\r\n    Schema::drop('users');\r\n\r\n    Schema::dropIfExists('users');\r\n\r\n<a name=\"使用外键重命名表\"></a>\r\n#### 使用外键重命名表\r\n\r\n\r\n\r\n在重命名表之前，应该确认表的所有外键约束在迁移文件中有一个显式的名称，而不是让 Laravel 去指定。否则，外键约束名称将引用旧表名。\r\n\r\n<a name=\"字段\"></a>\r\n## 字段\r\n\r\n<a name=\"创建字段\"></a>\r\n### 创建字段\r\n\r\n门面 `Schema` 的 `table` 方法可用于更新表。与 `create` 方法一样， `table` 方法接受两个参数：表名和一个闭包，该闭包接收一个 `illumb\\Database\\Schema\\Blueprint` 实例，可以使用该实例向表中添加列:\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->integer('votes');\r\n    });\r\n\r\n<a name=\"可用的字段类型\"></a>\r\n### 可用的字段类型\r\n\r\n`Illuminate\\Database\\Schema\\Blueprint` 提供了多种方法，用来创建表中对应类型的列。下面列出了所有可用的方法:\r\n\r\n[bigIncrements](#column-method-bigIncrements)\r\n[bigInteger](#column-method-bigInteger)\r\n[binary](#column-method-binary)\r\n[boolean](#column-method-boolean)\r\n[char](#column-method-char)\r\n[dateTimeTz](#column-method-dateTimeTz)\r\n[dateTime](#column-method-dateTime)\r\n[date](#column-method-date)\r\n[decimal](#column-method-decimal)\r\n[double](#column-method-double)\r\n[enum](#column-method-enum)\r\n[float](#column-method-float)\r\n[foreignId](#column-method-foreignId)\r\n[foreignIdFor](#column-method-foreignIdFor)\r\n[foreignUuid](#column-method-foreignUuid)\r\n[geometryCollection](#column-method-geometryCollection)\r\n[geometry](#column-method-geometry)\r\n[id](#column-method-id)\r\n[increments](#column-method-increments)\r\n[integer](#column-method-integer)\r\n[ipAddress](https://learnku.com/docs/laravel/9.x/migrations/12248#column-method-ipAddress)\r\n[json](#column-method-json)\r\n[jsonb](#column-method-jsonb)\r\n[lineString](#column-method-lineString)\r\n[longText](#column-method-longText)\r\n[macAddress](#column-method-macAddress)\r\n[mediumIncrements](#column-method-mediumIncrements)\r\n[mediumInteger](#column-method-mediumInteger)\r\n[mediumText](8#column-method-mediumText)\r\n[morphs](#column-method-morphs)\r\n[multiLineString](#column-method-multiLineString)\r\n[multiPoint](#column-method-multiPoint)\r\n[multiPolygon](#column-method-multiPolygon)\r\n[nullableMorphs](#column-method-nullableMorphs)\r\n[nullableTimestamps](#column-method-nullableTimestamps)\r\n[nullableUuidMorphs](#column-method-nullableUuidMorphs)\r\n[point](#column-method-point)\r\n[polygon](#column-method-polygon)\r\n[rememberToken](#column-method-rememberToken)\r\n[set](#column-method-set)\r\n[smallIncrements](#column-method-smallIncrements)\r\n[smallInteger](#column-method-smallInteger)\r\n[softDeletesTz](#column-method-softDeletesTz)\r\n[softDeletes](#column-method-softDeletes)\r\n[string](#column-method-string)\r\n[text](#column-method-text)\r\n[timeTz](#column-method-timeTz)\r\n[time](https://learnku.com/docs/laravel/9.x/migrations/12248#column-method-time)\r\n[timestampTz](#column-method-timestampTz)\r\n[timestamp](#column-method-timestamp)\r\n[timestampsTz](#column-method-timestampsTz)\r\n[timestamps](#column-method-timestamps)\r\n[tinyIncrements](#column-method-tinyIncrements)\r\n[tinyInteger](#column-method-tinyInteger)\r\n[tinyText](#column-method-tinyText)\r\n[unsignedBigInteger](#column-method-unsignedBigInteger)\r\n[unsignedDecimal](#column-method-unsignedDecimal)\r\n[unsignedInteger](#column-method-unsignedInteger)\r\n[unsignedMediumInteger](#column-method-unsignedMediumInteger)\r\n[unsignedSmallInteger](#column-method-unsignedSmallInteger)\r\n[unsignedTinyInteger](#column-method-unsignedTinyInteger)\r\n[uuidMorphs](#column-method-uuidMorphs)\r\n[uuid](#column-method-uuid)\r\n[year](#column-method-year)\r\n\r\n\r\n\r\n<a name=\"column-method-bigIncrements\"></a>\r\n#### `bigIncrements()`\r\n\r\n`bigIncrements` 方法用于在数据表中创建一个自增的 `UNSIGNED BIGINT` 类型（主键）的列：\r\n\r\n    $table->bigIncrements('id');\r\n\r\n<a name=\"column-method-bigInteger\"></a>\r\n#### `bigInteger()`\r\n\r\n`bigInteger` 方法用于在数据表中创建一个 `BIGINT` 类型的列：\r\n\r\n    $table->bigInteger('votes');\r\n\r\n<a name=\"column-method-binary\"></a>\r\n#### `binary()`\r\n\r\n`binary` 方法用于在数据表中创建一个 `BLOB` 类型的列：\r\n\r\n    $table->binary('photo');\r\n\r\n<a name=\"column-method-boolean\"></a>\r\n#### `boolean()`\r\n\r\n`boolean` 方法用于在数据表中创建一个 `BOOLEAN` 类型的列：\r\n\r\n    $table->boolean('confirmed');\r\n\r\n<a name=\"column-method-char\"></a>\r\n#### `char()`\r\n\r\n`char` 方法用于在数据表中创建一个 `CHAR` 类型的列，长度由参数指定：\r\n\r\n    $table->char('name', 100);\r\n\r\n<a name=\"column-method-dateTimeTz\"></a>\r\n#### `dateTimeTz()`\r\n\r\n`dateTimeTz` 方法用于在数据表中创建一个 `DATETIME` 类型（附有 timezone ）的列，可选参数为精度的总位数：\r\n\r\n    $table->dateTimeTz('created_at', $precision = 0);\r\n\r\n<a name=\"column-method-dateTime\"></a>\r\n#### `dateTime()`\r\n\r\n`dateTime` 方法用于在数据表中创建一个 `DATETIME` 类型的列，可选参数为精度的总位数：\r\n\r\n    $table->dateTime('created_at', $precision = 0);\r\n\r\n<a name=\"column-method-date\"></a>\r\n#### `date()`\r\n\r\n`date` 方法用于在数据表中创建一个 `DATE` 类型的列：\r\n\r\n    $table->date('created_at');\r\n\r\n<a name=\"column-method-decimal\"></a>\r\n#### `decimal()`\r\n\r\n`decimal` 方法用于在数据表中创建一个 `DECIMAL` 类型的列，可选参数分别为有效字数总位数、小数部分总位数：\r\n\r\n    $table->decimal('amount', $precision = 8, $scale = 2);\r\n\r\n<a name=\"column-method-double\"></a>\r\n#### `double()`\r\n\r\n`double` 方法用于在数据表中创建一个 `DOUBLE` 类型的列，可选参数分别为有效字数总位数、小数部分总位数：\r\n\r\n    $table->double('amount', 8, 2);\r\n\r\n<a name=\"column-method-enum\"></a>\r\n#### `enum()`\r\n\r\n`enum` 方法用于在数据表中创建一个 `ENUM` 类型的列，合法的值列表由参数指定：\r\n\r\n    $table->enum('difficulty', ['easy', 'hard']);\r\n\r\n<a name=\"column-method-float\"></a>\r\n#### `float()`\r\n\r\n\r\n\r\n `float` 方法用于在数据表中创建一个 `FLOAT` 类型的列，可选参数分别为有效字数总位数、小数部分总位数：\r\n\r\n    $table->float('amount', 8, 2);\r\n\r\n<a name=\"column-method-foreignId\"></a>\r\n#### `foreignId()`\r\n\r\n`foreignId` 方法是 `unsignedBigInteger` 的别名:\r\n\r\n    $table->foreignId('user_id');\r\n\r\n<a name=\"column-method-foreignIdFor\"></a>\r\n#### `foreignIdFor()`\r\n\r\n`foreignIdFor` 方法为给定模型类添加了 `{column}_id UNSIGNED BIGINT` 等效列：\r\n\r\n    $table->foreignIdFor(User::class);\r\n\r\n<a name=\"column-method-foreignUuid\"></a>\r\n#### `foreignUuid()`\r\n\r\n`foreignUuid` 方法创建一个 `UUID` 等效列：\r\n\r\n    $table->foreignUuid('user_id');\r\n\r\n<a name=\"column-method-geometryCollection\"></a>\r\n#### `geometryCollection()`\r\n\r\n`geometryCollection` 方法相当于 `GEOMETRYCOLLECTION` :\r\n\r\n    $table->geometryCollection('positions');\r\n\r\n<a name=\"column-method-geometry\"></a>\r\n#### `geometry()`\r\n\r\n`geometry` 方法相当于 `GEOMETRY` :\r\n\r\n    $table->geometry('positions');\r\n\r\n<a name=\"column-method-id\"></a>\r\n#### `id()`\r\n\r\n `id` 方法是`bigIncrements` 的别名.默认情况下，该方法将创建一个 `id` 列; 但是，如果要为列指定不同的名称，则可以传递列名：\r\n\r\n    $table->id();\r\n\r\n<a name=\"column-method-increments\"></a>\r\n#### `increments()`\r\n\r\n`increments` 方法创建一个自动递增相当于 `UNSIGNED INTEGER` 的列作为主键：\r\n\r\n    $table->increments('id');\r\n\r\n<a name=\"column-method-integer\"></a>\r\n#### `integer()`\r\n\r\n`integer` 方法相当于 `INTEGER` ：\r\n\r\n    $table->integer('votes');\r\n\r\n<a name=\"column-method-ipAddress\"></a>\r\n#### `ipAddress()`\r\n\r\n`ipAddress` 方法相当于 `VARCHAR` ：\r\n\r\n    $table->ipAddress('visitor');\r\n\r\n<a name=\"column-method-json\"></a>\r\n#### `json()`\r\n\r\n`json` 方法相当于 `JSON`：\r\n\r\n    $table->json('options');\r\n\r\n<a name=\"column-method-jsonb\"></a>\r\n#### `jsonb()`\r\n\r\n`jsonb` 方法相当于 `JSONB`：\r\n\r\n    $table->jsonb('options');\r\n\r\n\r\n\r\n<a name=\"column-method-lineString\"></a>\r\n#### `lineString()`\r\n\r\n `lineString` 方法相当于 `LINESTRING`：\r\n\r\n    $table->lineString('positions');\r\n\r\n<a name=\"column-method-longText\"></a>\r\n#### `longText()`\r\n\r\n `longText` 方法相当于 `LONGTEXT`：\r\n\r\n    $table->longText('description');\r\n\r\n<a name=\"column-method-macAddress\"></a>\r\n#### `macAddress()`\r\n\r\n`macAddress` 方法创建一个用于保存 MAC 地址的列。 一些数据库系统（如 PostgreSQL），为这种类型的数据提供了专用的类型。其他数据库系统相当于使用字符串类型：\r\n\r\n    $table->macAddress('device');\r\n\r\n<a name=\"column-method-mediumIncrements\"></a>\r\n#### `mediumIncrements()`\r\n\r\n `mediumIncrements` 方法用于创建一个 `UNSIGNED MEDIUMINT` 类型的自动递增的列作为主键：\r\n\r\n    $table->mediumIncrements('id');\r\n\r\n<a name=\"column-method-mediumInteger\"></a>\r\n#### `mediumInteger()`\r\n\r\n `mediumInteger` 方法用于创建一个 `MEDIUMINT` 类型的列：\r\n\r\n    $table->mediumInteger('votes');\r\n\r\n<a name=\"column-method-mediumText\"></a>\r\n#### `mediumText()`\r\n\r\n`mediumText` 方法用于创建一个 `MEDIUMTEXT` 类型的列：\r\n\r\n    $table->mediumText('description');\r\n\r\n<a name=\"column-method-morphs\"></a>\r\n#### `morphs()`\r\n\r\n `morphs` 方法用于快速创建一个名称为 `{column}_id` ，类型为 `UNSIGNED BIGINT` 的列和一个名称为 `{column}_type` ，类型为 `VARCHAR` 的列。\r\n\r\n这个方法在定义[多态关联](/docs/laravel/9.x/eloquent-relationships)所需的列时使用。在下面的例子中， `taggable_id` 和 `taggable_type` 这两个列会被创建：\r\n\r\n    $table->morphs('taggable');\r\n\r\n<a name=\"column-method-multiLineString\"></a>\r\n#### `multiLineString()`\r\n\r\n `multiLineString` 方法用于创建一个 `MULTILINESTRING` 类型的列：\r\n\r\n    $table->multiLineString('positions');\r\n\r\n<a name=\"column-method-multiPoint\"></a>\r\n#### `multiPoint()`\r\n\r\n `multiPoint` 方法用于创建一个 `MULTIPOINT` 类型的列：\r\n\r\n    $table->multiPoint('positions');\r\n\r\n<a name=\"column-method-multiPolygon\"></a>\r\n#### `multiPolygon()`\r\n\r\n `multiPolygon` 方法用于创建一个 `MULTIPOLYGON` 类型的列：\r\n\r\n    $table->multiPolygon('positions');\r\n\r\n\r\n\r\n<a name=\"column-method-nullableTimestamps\"></a>\r\n#### `nullableTimestamps()`\r\n\r\n这个方法和 [timestamps](#column-method-timestamps) 方法类似；需要注意的是此方法创建的列是 `nullable` 的：\r\n\r\n    $table->nullableTimestamps(0);\r\n\r\n<a name=\"column-method-nullableMorphs\"></a>\r\n#### `nullableMorphs()`\r\n\r\n这个方法和 [morphs](#column-method-morphs) 方法类似；需要注意的是此方法创建的列是 `nullable` 的：\r\n\r\n    $table->nullableMorphs('taggable');\r\n\r\n<a name=\"column-method-nullableUuidMorphs\"></a>\r\n#### `nullableUuidMorphs()`\r\n\r\n这个方法和 [uuidMorphs](#column-method-uuidMorphs) 方法类似；需要注意的是此方法创建的列是 `nullable` 的：\r\n\r\n    $table->nullableUuidMorphs('taggable');\r\n\r\n<a name=\"column-method-point\"></a>\r\n#### `point()`\r\n\r\n`point` 方法相当于 POINT：\r\n\r\n    $table->point('position');\r\n\r\n<a name=\"column-method-polygon\"></a>\r\n#### `polygon()`\r\n\r\n`polygon` 方法相当于 POLYGON：\r\n\r\n    $table->polygon('position');\r\n\r\n<a name=\"column-method-rememberToken\"></a>\r\n#### `rememberToken()`\r\n\r\n添加一个允许空值的 VARCHAR (100) 类型的 `remember_token` 字段，用于存储 [记住用户](/docs/laravel/9.x/authentication#remembering-users)：\r\n\r\n    $table->rememberToken();\r\n\r\n<a name=\"column-method-set\"></a>\r\n#### `set()`\r\n\r\n`set` 方法使用给定的有效值列表创建一个 `SET` 等效列：\r\n\r\n    $table->set('flavors', ['strawberry', 'vanilla']);\r\n\r\n<a name=\"column-method-smallIncrements\"></a>\r\n#### `smallIncrements()`\r\n\r\n`smallIncrements` 方法创建一个自动递增的 `UNSIGNED SMALLINT` 等效列作为主键：\r\n\r\n    $table->smallIncrements('id');\r\n\r\n<a name=\"column-method-smallInteger\"></a>\r\n#### `smallInteger()`\r\n\r\n`smallInteger` 方法创建一个 `SMALLINT` 等效列：\r\n\r\n    $table->smallInteger('votes');\r\n\r\n<a name=\"column-method-softDeletesTz\"></a>\r\n#### `softDeletesTz()`\r\n\r\n`softDeletesTz` 方法添加了一个可为空的 `deleted_at` `TIMESTAMP`（带时区）等效列，具有可选精度（总位数）。此列旨在存储 Eloquent 的“软删除”功能所需的 `deleted_at` 时间戳：\r\n\r\n    $table->softDeletesTz($column = 'deleted_at', $precision = 0);\r\n\r\n\r\n\r\n<a name=\"column-method-softDeletes\"></a>\r\n#### `softDeletes()`\r\n\r\n`softDeletes` 方法添加了一个可为空的 `deleted_at` `TIMESTAMP` 等效列，具有可选精度（总位数）。此列旨在存储 Eloquent 的「软删除」功能所需的 `deleted_at` 时间戳，相当于为软删除添加一个可空的 `deleted_at` 字段：\r\n\r\n    $table->softDeletes($column = 'deleted_at', $precision = 0);\r\n\r\n<a name=\"column-method-string\"></a>\r\n#### `string()`\r\n\r\n`string` 方法创建一个给定长度的 `VARCHAR` 等效列，相当于指定长度的 VARCHAR：\r\n\r\n    $table->string('name', 100);\r\n\r\n<a name=\"column-method-text\"></a>\r\n#### `text()`\r\n\r\n`text` 方法创建一个 `TEXT` 等效列：\r\n\r\n    $table->text('description');\r\n\r\n<a name=\"column-method-timeTz\"></a>\r\n#### `timeTz()`\r\n\r\n`timeTz` 方法创建一个具有可选精度（总位数）的 `TIME`（带时区）等效列：\r\n\r\n    $table->timeTz('sunrise', $precision = 0);\r\n\r\n<a name=\"column-method-time\"></a>\r\n#### `time()`\r\n\r\n`time` 方法创建一个具有可选精度（总位数）的 `TIME` 等效列：\r\n\r\n    $table->time('sunrise', $precision = 0);\r\n\r\n<a name=\"column-method-timestampTz\"></a>\r\n#### `timestampTz()`\r\n\r\n`timestampTz` 方法创建一个具有可选精度（总位数）的 `TIMESTAMP`（带时区）等效列：\r\n\r\n    $table->timestampTz('added_at', $precision = 0);\r\n\r\n<a name=\"column-method-timestamp\"></a>\r\n#### `timestamp()`\r\n\r\n`timestamp` 方法创建一个具有可选精度（总位数）的 `TIMESTAMP` 等效列：\r\n\r\n    $table->timestamp('added_at', $precision = 0);\r\n\r\n<a name=\"column-method-timestampsTz\"></a>\r\n#### `timestampsTz()`\r\n\r\n`timestampsTz` 方法创建 `created_at` 和 `updated_at` `TIMESTAMP`（带时区）等效列，具有可选精度（总位数）：\r\n    $table->timestampsTz($precision = 0);\r\n\r\n<a name=\"column-method-timestamps\"></a>\r\n#### `timestamps()`\r\n\r\n`timestamps` 方法创建具有可选精度（总位数）的 `created_at` 和 `updated_at` `TIMESTAMP` 等效列：\r\n    $table->timestamps($precision = 0);\r\n\r\n<a name=\"column-method-tinyIncrements\"></a>\r\n#### `tinyIncrements()`\r\n\r\n`tinyIncrements` 方法创建一个自动递增的 `UNSIGNED TINYINT` 等效列作为主键：\r\n    $table->tinyIncrements('id');\r\n\r\n\r\n\r\n<a name=\"column-method-tinyInteger\"></a>\r\n#### `tinyInteger()`\r\n\r\n`tinyInteger` 方法用于创建一个 `TINYINT` 等效列：\r\n\r\n    $table->tinyInteger('votes');\r\n\r\n<a name=\"column-method-tinyText\"></a>\r\n#### `tinyText()`\r\n\r\n`tinyText` 方法用于创建一个 `TINYTEXT` 等效列：\r\n\r\n    $table->tinyText('notes');\r\n\r\n<a name=\"column-method-unsignedBigInteger\"></a>\r\n#### `unsignedBigInteger()`\r\n\r\n`unsignedBigInteger` 方法用于创建一个 `UNSIGNED BIGINT` 等效列：\r\n\r\n    $table->unsignedBigInteger('votes');\r\n\r\n<a name=\"column-method-unsignedDecimal\"></a>\r\n#### `unsignedDecimal()`\r\n\r\n`unsignedDecimal` 方法用于创建一个 `UNSIGNED DECIMAL` 等效列，具有可选的精度（总位数）和小数位数（小数位数）：\r\n\r\n    $table->unsignedDecimal('amount', $precision = 8, $scale = 2);\r\n\r\n<a name=\"column-method-unsignedInteger\"></a>\r\n#### `unsignedInteger()`\r\n\r\n`unsignedInteger` 方法用于创建一个 `UNSIGNED INTEGER` 等效列：\r\n\r\n    $table->unsignedInteger('votes');\r\n\r\n<a name=\"column-method-unsignedMediumInteger\"></a>\r\n#### `unsignedMediumInteger()`\r\n\r\n`unsignedMediumInteger` 方法用于创建一个 `UNSIGNED MEDIUMINT` 等效列：\r\n\r\n    $table->unsignedMediumInteger('votes');\r\n\r\n<a name=\"column-method-unsignedSmallInteger\"></a>\r\n#### `unsignedSmallInteger()`\r\n\r\n`unsignedSmallInteger` 方法用于创建一个 `UNSIGNED SMALLINT` 等效列：\r\n\r\n    $table->unsignedSmallInteger('votes');\r\n\r\n<a name=\"column-method-unsignedTinyInteger\"></a>\r\n#### `unsignedTinyInteger()`\r\n\r\n`unsignedTinyInteger` 方法用于创建一个 `UNSIGNED TINYINT` 等效列：\r\n\r\n    $table->unsignedTinyInteger('votes');\r\n\r\n<a name=\"column-method-uuidMorphs\"></a>\r\n#### `uuidMorphs()`\r\n\r\n`uuidMorphs` 方法用于快速创建一个名称为 `{column}_id` ，类型为 `CHAR(36)` 的列和一个名称为 `{column}_type` ，类型为  `VARCHAR` 的列。\r\n\r\n这个方法用于定义使用 UUID 标识符的[多态关联](/docs/laravel/9.x/eloquent-relationships)所需的列时使用。在下面的例子中，`taggable_id` 和 `taggable_type` 这两个列将会被创建:\r\n\r\n    $table->uuidMorphs('taggable');\r\n\r\n<a name=\"column-method-uuid\"></a>\r\n#### `uuid()`\r\n\r\n`uuid` 方法用于创建一个 `UUID` 类型的列:\r\n\r\n    $table->uuid('id');\r\n\r\n<a name=\"column-method-year\"></a>\r\n#### `year()`\r\n\r\n`year` 方法用于创建一个 `YEAR` 类型的列:\r\n\r\n    $table->year('birth_year');\r\n\r\n\r\n\r\n<a name=\"字段修饰符\"></a>\r\n### 字段修饰符\r\n\r\n除了上面列出的列类型外，在向数据库表添加列时还有几个可以使用的「修饰符」。例如，如果要把列设置为要使列为「可空」，你可以使用 `nullable` 方法:\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->string('email')->nullable();\r\n    });\r\n\r\n下表时所有可用的列修饰符。此列表不包括[索引修饰符](#creating-indexes):\r\n\r\n修饰符  |  说明\r\n--------  |  -----------\r\n`->after('column')`  |  将该列放在其它字段「之后」(MySQL)\r\n`->autoIncrement()`  |  设置 INTEGER 类型的列为自动递增 (主键)\r\n`->charset('utf8mb4')`  |  为该列指定字符集 (MySQL)\r\n`->collation('utf8mb4_unicode_ci')`  |  为该列指定排序规则 (MySQL/PostgreSQL/SQL Server)\r\n`->comment('my comment')`  |  为该列添加注释 (MySQL/PostgreSQL)\r\n`->default($value)`  |  为该列指定一个「默认值」\r\n`->first()`  |  将该列放在该表「首位」 (MySQL)\r\n`->from($integer)`  |  设置自动递增字段的起始值 (MySQL / PostgreSQL)\r\n`->invisible()`  |  使列对「SELECT \\*」查询不可见（MySQL）。\r\n`->nullable($value = true)`  |  允许 NULL 值插入到该列\r\n`->storedAs($expression)`  |  创建一个存储生成的列 (MySQL)\r\n`->unsigned()`  |  设置 INTEGER 类型的字段为 UNSIGNED (MySQL)\r\n`->useCurrent()`  |  设置 TIMESTAMP 类型的列使用 CURRENT_TIMESTAMP 作为默认值\r\n`->useCurrentOnUpdate()`  |  将 TIMESTAMP 类型的列设置为在更新时使用 CURRENT_TIMESTAMP 作为新值\r\n`->virtualAs($expression)`  |  创建一个虚拟生成的列 (MySQL)\r\n`->generatedAs($expression)`  |  使用指定的序列选项创建标识列 (PostgreSQL)\r\n`->always()`  |  定义序列值优先于标识列的输入 (PostgreSQL)\r\n`->isGeometry()`  |  将空间列类型设置为 `geometry` - 默认类型为 `geography` (PostgreSQL)。\r\n\r\n\r\n\r\n<a name=\"默认值表达式\"></a>\r\n#### 默认值表达式\r\n\r\n`default` 修饰符接收一个变量或者一个 `\\Illuminate\\Database\\Query\\Expression` 实例。使用 `Expression` 实例可以避免使用包含在引号中的值，并且允许你使用特定数据库函数。这在当你需要给 `JSON` 字段指定默认值的时候特别有用：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Database\\Query\\Expression;\r\n    use Illuminate\\Database\\Migrations\\Migration;\r\n\r\n    return new class extends Migration\r\n    {\r\n        /**\r\n         * 运行迁移\r\n         *\r\n         * @return void\r\n         */\r\n        public function up()\r\n        {\r\n            Schema::create('flights', function (Blueprint $table) {\r\n                $table->id();\r\n                $table->json('movies')->default(new Expression('(JSON_ARRAY())'));\r\n                $table->timestamps();\r\n            });\r\n        }\r\n    };\r\n\r\n> 注意：支持哪些默认值的表示方式取决于你的数据库驱动、数据库版本、还有字段类型。请参考合适的文档使用。还有一点要注意的是，使用数据库特定函数，可能会将你绑牢到特定的数据库驱动上。\r\n\r\n<a name=\"字段顺序\"></a>\r\n#### 字段顺序\r\n\r\n使用 MySQL 数据库时，可以使用 `after` 方法在模式中的现有列后添加列：\r\n\r\n    $table->after('password', function ($table) {\r\n        $table->string('address_line1');\r\n        $table->string('address_line2');\r\n        $table->string('city');\r\n    });\r\n\r\n<a name=\"修改字段\"></a>\r\n### 修改字段\r\n\r\n<a name=\"先决条件\"></a>\r\n#### 先决条件\r\n\r\n在修饰字段之前，请确保你已经通过 Composer 包管理器安装了 `doctrine/dbal` 包。Doctrine DBAL 库用于确定字段的当前状态，并创建对该字段进行指定调整所需的 SQL 查询：\r\n\r\n    composer require doctrine/dbal\r\n\r\n如果你打算修改 `timestamp` 方法来创建列，你还需要将以下配置添加到应用程序的`config/database.php`配置文件中：\r\n\r\n```php\r\nuse Illuminate\\Database\\DBAL\\TimestampType;\r\n\r\n'dbal' => [\r\n    'types' => [\r\n        'timestamp' => TimestampType::class,\r\n    ],\r\n],\r\n```\r\n\r\n> 注意：如果你的应用程序使用 Microsoft SQL 驱动，请确保你已经安装了`doctrine/dbal:^3.0`。\r\n\r\n\r\n\r\n<a name=\"更新字段属性\"></a>\r\n#### 更新字段属性\r\n\r\n`change` 方法可以将现有的字段类型修改为新的类型或修改属性。比如，你可能想增加 `string` 字段的长度，可以使用 `change` 方法把 `name` 字段的长度从 25 增加到 50。所以，我们可以简单的更新字段属性然后调用  `change` 方法：\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->string('name', 50)->change();\r\n    });\r\n\r\n我们同样可以使用 `nullable` 将字段修改为允许为空：\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->string('name', 50)->nullable()->change();\r\n    });\r\n\r\n> 注意：只有以下字段类型能被 「修改」: `bigInteger`, `binary`, `boolean`, `char`, `date`, `dateTime`, `dateTimeTz`, `decimal`, `integer`, `json`, `longText`, `mediumText`, `smallInteger`, `string`, `text`, `time`, `unsignedBigInteger`, `unsignedInteger`, `unsignedSmallInteger`, 和 `uuid`.   要修改 `timestamp` 字段类型 ， [Doctrine 类型必须被注册 ](#prerequisites)。\r\n\r\n<a name=\"重命名字段\"></a>\r\n#### 重命名字段\r\n\r\n可以使用结构生成器上的 `renameColumn` 方法来重命名字段。在重命名字段前，请确保你已经通过 Composer 包管理器安装了 `doctrine/dbal` 包：\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->renameColumn('from', 'to');\r\n    });\r\n\r\n> 注意：当前不支持 `enum` 类型的字段重命名。\r\n\r\n<a name=\"删除字段\"></a>\r\n### 删除字段\r\n\r\n你可以使用结构生成器上的 `dropColumn` 方法来删除字段。如果你的应用程序使用的是 SQLite 数据库，你必须在调用`dropColumn`方法之前通过 Composer 包管理器安装了 `doctrine/dbal` 包：\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->dropColumn('votes');\r\n    });\r\n\r\n\r\n\r\n你可以传递一个字段数组给 `dropColumn` 方法来删除多个字段：\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->dropColumn(['votes', 'avatar', 'location']);\r\n    });\r\n\r\n> 注意：使用 SQLite 数据库时不支持在单个迁移中 **删除** 或 **修改** 多个字段。\r\n\r\n<a name=\"可用的命令别名\"></a>\r\n#### 可用的命令别名\r\n\r\nLaravel 提供了几种常用的删除相关列的便捷方法。 如下表所示：\r\n\r\n命令  |  说明\r\n-------  |  -----------\r\n`$table->dropMorphs('morphable');`  |  删除 `morphable_id` 和 `morphable_type` 字段\r\n`$table->dropRememberToken();`  |  删除 `remember_token` 字段\r\n`$table->dropSoftDeletes();`  |  删除 `deleted_at` 字段\r\n`$table->dropSoftDeletesTz();`  |  `dropSoftDeletes()` 方法的别名\r\n`$table->dropTimestamps();`  |  删除 `created_at` 和 `updated_at` 字段\r\n`$table->dropTimestampsTz();` |  `dropTimestamps()` 方法别名\r\n\r\n<a name=\"索引\"></a>\r\n## 索引\r\n\r\n<a name=\"创建索引\"></a>\r\n### 创建索引\r\n\r\n结构生成器支持多种类型的索引。下面的例子中新建了一个值唯一的 `email` 字段。我们可以将 `unique` 方法链式地添加到字段定义上来创建索引：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->string('email')->unique();\r\n    });\r\n\r\n或者，你也可以在定义完字段之后创建索引。为此，你应该调用结构生成器上的 `unique` 方法，此方法应该传入唯一索引的列名称：\r\n\r\n    $table->unique('email');\r\n\r\n你甚至可以将数组传递给索引方法来创建一个复合（或合成）索引：\r\n\r\n    $table->index(['account_id', 'created_at']);\r\n\r\n\r\n\r\n创建索引时，Laravel 会自动生成一个合理的索引名称，但你也可以传递第二个参数来自定义索引名称：\r\n\r\n    $table->unique('email', 'unique_email');\r\n\r\n<a name=\"可用的索引类型\"></a>\r\n#### 可用的索引类型\r\n\r\nLaravel 的结构生成器提供了 Laravel 支持的所有类型的索引方法。每个索引方法都接受一个可选的第二个参数来指定索引的名称。如果省略，名称将根据表和列的名称生成。下面是所有可用的索引方法：\r\n\r\n命令  |  说明\r\n-------  |  -----------\r\n`$table->primary('id');`  |  添加主键\r\n`$table->primary(['id', 'parent_id']);`  |   添加复合主键\r\n`$table->unique('email');`  |  添加唯一索引\r\n`$table->index('state');`  | 添加普通索引\r\n`$table->fullText('body');`  |  添加全文索引 (MySQL/PostgreSQL)\r\n`$table->fullText('body')->language('english');`  |  添加指定语言 (PostgreSQL) 的全文索引\r\n`$table->spatialIndex('location');`  |  添加空间索引（不支持 SQLite）\r\n\r\n<a name=\"索引长度-mysql-mariadb\"></a>\r\n#### 索引长度 & MySQL / MariaDB\r\n\r\n默认情况下, Laravel 使用`utf8mb4` 编码。如果你是在版本低于 5.7.7 的 MySQL 或者版本低于 10.2.2 的 MariaDB 上创建索引，那你就需要手动配置数据库迁移的默认字符串长度。也就是说，你可以通过在`App\\Providers\\AppServiceProvider`类的`boot`方法中调用`Schema::defaultStringLength`方法来配置默认字符串长度：\r\n\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    /**\r\n     * 引导任何应用程序「全局配置」\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Schema::defaultStringLength(191);\r\n    }\r\n\r\n\r\n\r\n当然，你也可以选择开启数据库的 `innodb_large_prefix` 选项。至于如何正确开启，请自行查阅数据库文档。\r\n\r\n<a name=\"重命名索引\"></a>\r\n### 重命名索引\r\n\r\n若要重命名索引，你需要调用 `renameIndex` 方法。此方法接受当前索引名称作为其第一个参数，并将所需名称作为其第二个参数：\r\n\r\n    $table->renameIndex('from', 'to')\r\n\r\n<a name=\"删除索引\"></a>\r\n### 删除索引\r\n\r\n若要删除索引，则必须指定索引的名称。Laravel 默认会自动将数据表名称、索引的字段名及索引类型简单地连接在一起作为名称。举例如下：\r\n\r\n命令  |  说明\r\n-------  |  -----------\r\n`$table->dropPrimary('users_id_primary');`  |  从 「users」 表中删除主键\r\n`$table->dropUnique('users_email_unique');`  |  从 「users」 表中删除 unique 索引\r\n`$table->dropIndex('geo_state_index');`  |  从 「geo」 表中删除基本索引\r\n`$table->dropSpatialIndex('geo_location_spatialindex');`  | 从 「geo」 表中删除空间索引（不支持 SQLite）\r\n\r\n如果将字段数组传给 `dropIndex` 方法，会删除根据表名、字段和键类型生成的索引名称。\r\n\r\n    Schema::table('geo', function (Blueprint $table) {\r\n        $table->dropIndex(['state']); // 删除 'geo_state_index' 索引\r\n    });\r\n\r\n<a name=\"外键约束\"></a>\r\n### 外键约束\r\n\r\nLaravel 还支持创建用于在数据库层中的强制引用完整性的外键约束。例如，让我们在 `posts` 表上定义一个引用 `users` 表的 `id` 字段的 `user_id` 字段：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('posts', function (Blueprint $table) {\r\n        $table->unsignedBigInteger('user_id');\r\n\r\n        $table->foreign('user_id')->references('id')->on('users');\r\n    });\r\n\r\n\r\n\r\n由于这种外键约束的定义方式过于繁复，Laravel 额外提供了更简洁的方法，基于约定来提供更好的开发人员体验。上面的示例还可以这么写：\r\n\r\n    Schema::table('posts', function (Blueprint $table) {\r\n        $table->foreignId('user_id')->constrained();\r\n    });\r\n\r\n`foreignId` 方法是 `unsignedBigInteger` 的别名，而 `constrained` 方法将使用约定来确定所引用的表名和列名。如果表名与约定不匹配，可以通过将表名作为参数传递给 `constrained` 方法来指定表名：\r\n\r\n    Schema::table('posts', function (Blueprint $table) {\r\n        $table->foreignId('user_id')->constrained('users');\r\n    });\r\n\r\n你可以为约束的「on delete」和「on update」属性指定所需的操作：\r\n\r\n    $table->foreignId('user_id')\r\n          ->constrained()\r\n          ->onUpdate('cascade')\r\n          ->onDelete('cascade');\r\n\r\n还为这些操作提供了另一种表达性语法：\r\n\r\n方法  |  说明\r\n-------  |  -----------\r\n`$table->cascadeOnUpdate();` | 更新应该级联。\r\n`$table->restrictOnUpdate();`| 应该限制更新。\r\n`$table->cascadeOnDelete();` | 删除应该级联\r\n`$table->restrictOnDelete();`| 应该限制删除\r\n`$table->nullOnDelete();`    | 删除应将外键值设置为空\r\n\r\n当使用任意 [字段修饰符](#column-modifiers) 的时候，必须在调用 `constrained` 之前调用：\r\n\r\n    $table->foreignId('user_id')\r\n          ->nullable()\r\n          ->constrained();\r\n\r\n<a name=\"删除外键\"></a>\r\n#### 删除外键\r\n\r\n要删除一个外键，你需要使用 `dropForeign` 方法，将要删除的外键约束作为参数传递。外键约束采用的命名方式与索引相同。即，将数据表名称和约束的字段连接起来，再加上 `_foreign` 后缀：\r\n\r\n    $table->dropForeign('posts_user_id_foreign');\r\n\r\n\r\n\r\n或者，可以给 `dropForeign` 方法传递一个数组，该数组包含要删除的外键的列名。数组将根据  Laravel 的 结构生成器使用的约束名称约定自动转换：\r\n\r\n    $table->dropForeign(['user_id']);\r\n\r\n<a name=\"更改外键约束\"></a>\r\n#### 更改外键约束\r\n\r\n你可以在迁移文件中使用以下方法来开启或关闭外键约束：\r\n\r\n    Schema::enableForeignKeyConstraints();\r\n\r\n    Schema::disableForeignKeyConstraints();\r\n\r\n> 注意：SQLite 默认禁用外键约束。使用 SQLite 时，请确保在数据库配置中[启用外键支持](/docs/laravel/9.x/database#configuration) 然后再尝试在迁移中创建它们。另外, SQLite只在创建表时支持外键，并且[将在修改表时不会支持](https://www.sqlite.org/omitted.html)。\r\n\r\n<a name=\"事件\"></a>\r\n## 事件\r\n\r\n为方便起见，每个迁移操作都会派发一个 [事件](/docs/laravel/9.x/events)。以下所有事件都扩展了基础 `Illuminate\\Database\\Events\\MigrationEvent` 类：\r\n\r\n类 | 描述\r\n-------|-------\r\n`Illuminate\\Database\\Events\\MigrationsStarted` | 即将执行一批迁移。 |\r\n`Illuminate\\Database\\Events\\MigrationsEnded` | 一批迁移已完成执行。 |\r\n`Illuminate\\Database\\Events\\MigrationStarted` | 即将执行单个迁移。 |\r\n`Illuminate\\Database\\Events\\MigrationEnded` | 单个迁移已完成执行。 |\r\n`Illuminate\\Database\\Events\\SchemaDumped` | 数据库结构转储已完成。 |\r\n`Illuminate\\Database\\Events\\SchemaLoaded` | 已加载现有数据库结构转储。 |\r\n\r\n","p":"docs/migrations.html"},{"t":"seeding (数据填充)","d":"# 数据填充\r\n\r\n- [简介](#introduction)\r\n- [编写 Seeders](#writing-seeders)\r\n    - [使用模型工厂](#using-model-factories)\r\n    - [调用其他 Seeders](#calling-additional-seeders)\r\n    - [禁用模型事件](#muting-model-events)\r\n- [运行 Seeders](#running-seeders)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 内置了一个可为你的数据库填充测试数据的填充类。所有的填充类都放在  `database/seeds` 目录下。Laravel 默认定义了一个 `DatabaseSeeder` 类。通过这个类，你可以用 `call` 方法来运行其他的 seed 类，从而控制数据填充的顺序。\r\n\r\n> 技巧：使用数据填充时会自动禁用 [批量赋值保护](/docs/laravel/9.x/eloquent#mass-assignment)。\r\n\r\n<a name=\"writing-seeders\"></a>\r\n## 编写 Seeders\r\n\r\n运行 [Artisan 命令](/docs/laravel/9.x/artisan) `make:seeder` 可以生成 Seeder，框架生成的 seeders 都放在 `database/seeders` 目录下：\r\n\r\n```shell\r\nphp artisan make:seeder UserSeeder\r\n```\r\n\r\nSeeder 类只包含一个默认方法：`run`。这个方法会在执行 `db:seed` 这个 [Artisan command](/docs/laravel/9.x/artisan) 时被调用。在 `run` 方法里，你可以按需在数据库中插入数据。你也可以用 [构造查询器](/docs/laravel/9.x/queries) 或 [Eloquent 模型工厂](/docs/laravel/9.x/database-testing#defining-model-factories) 来手动插入数据。\r\n\r\n如下所示, 在默认的 `DatabaseSeeder` 类中的 `run` 方法中添加一条数据插入语句：\r\n\r\n    <?php\r\n\r\n    namespace Database\\Seeders;\r\n\r\n    use Illuminate\\Database\\Seeder;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    class DatabaseSeeder extends Seeder\r\n    {\r\n        /**\r\n         * 执行数据填充\r\n         *\r\n         * @return void\r\n         */\r\n        public function run()\r\n        {\r\n            DB::table('users')->insert([\r\n                'name' => Str::random(10),\r\n                'email' => Str::random(10).'@gmail.com',\r\n                'password' => Hash::make('password'),\r\n            ]);\r\n        }\r\n    }\r\n\r\n> 技巧：你在 `run` 方法签名中可以用类型来约束你需要的依赖。它们会被 Laravel [服务容器](/docs/laravel/9.x/container) 自动解析。\r\n\r\n\r\n\r\n<a name=\"using-model-factories\"></a>\r\n### 使用模型工厂\r\n\r\n当然，手动为每个模型填充指定属性很麻烦，你可以使用 [模型工厂](/docs/laravel/9.x/database-testing#defining-model-factories) 轻松地生成大量数据库数据。首先，阅读 [模型工厂文档](/docs/laravel/9.x/database-testing#defining-model-factories) 来学习如何定义工厂文件。\r\n\r\n例如，创建 50 个用户并为每个用户创建关联：\r\n\r\n    use App\\Models\\User;\r\n\r\n    /**\r\n     * 执行数据填充\r\n     *\r\n     * @return void\r\n     */\r\n    public function run()\r\n    {\r\n        User::factory()\r\n                ->count(50)\r\n                ->hasPosts(1)\r\n                ->create();\r\n    }\r\n\r\n<a name=\"calling-additional-seeders\"></a>\r\n### 调用其他 Seeders\r\n\r\n在 `DatabaseSeeder` 类中，你可以使用 `call` 方法来运行其他的 seed 类。使用 `call` 方法可以将数据填充拆分成多个文件，这样就不会使单个 seeder 文件变得非常大。 只需向 `call` 方法中传递要运行的 seeder 类名称即可：\r\n\r\n    /**\r\n     * 执行数据填充\r\n     *\r\n     * @return void\r\n     */\r\n    public function run()\r\n    {\r\n        $this->call([\r\n            UserSeeder::class,\r\n            PostSeeder::class,\r\n            CommentSeeder::class,\r\n        ]);\r\n    }\r\n\r\n<a name=\"muting-model-events\"></a>\r\n### 禁用模型事件\r\n\r\n在运行 Seeders 时，你可能希望阻止模型调用事件。你可以使用 `WithoutModelEvents` 特征来实现这一点。使用 `WithoutModelEvents` trait 可确保不调用模型事件，即使通过 `call` 方法执行了额外的 seed 类：\r\n\r\n    <?php\r\n\r\n    namespace Database\\Seeders;\r\n\r\n    use Illuminate\\Database\\Seeder;\r\n    use Illuminate\\Database\\Console\\Seeds\\WithoutModelEvents;\r\n\r\n    class DatabaseSeeder extends Seeder\r\n    {\r\n        use WithoutModelEvents;\r\n\r\n        /**\r\n     * 执行数据填充\r\n         *\r\n         * @return void\r\n         */\r\n        public function run()\r\n        {\r\n            $this->call([\r\n                UserSeeder::class,\r\n            ]);\r\n        }\r\n    }\r\n\r\n<a name=\"running-seeders\"></a>\r\n## 运行 Seeders\r\n\r\n你可以使用 Artisan 命令 `db:seed` 来填充数据库。默认情况下， `db:seed` 命令将运行 `Database\\Seeders\\DatabaseSeeder` 类，这个类又可以调用其他 seed 类。不过，你也可以使用 `--class` 选项来指定一个特定的 seeder 类：\r\n\r\n```shell\r\nphp artisan db:seed\r\n\r\nphp artisan db:seed --class=UserSeeder\r\n```\r\n\r\n\r\n\r\n你还可以使用 `migrate:fresh` 命令结合 `--seed` 选项，这将删除数据库中所有表并重新运行所有迁移。此命令对于完全重建数据库非常有用：\r\n\r\n```shell\r\nphp artisan migrate:fresh --seed\r\n```\r\n\r\n<a name=\"forcing-seeding-production\"></a>\r\n#### 在生产环境中强制运行填充\r\n\r\n一些填充操作可能会导致原有数据的更新或丢失。为了保护生产环境数据库的数据，在 `生产环境` 中运行填充命令前会进行确认。可以添加 `--force` 选项来强制运行填充命令：\r\n\r\n```shell\r\nphp artisan db:seed --force\r\n```\r\n\r\n","p":"docs/seeding.html"},{"t":"redis (Redis)","d":"# Redis\r\n\r\n- [安装](#introduction)\r\n- [配置](#configuration)\r\n    - [集群](#clusters)\r\n    - [Predis](#predis)\r\n    - [phpredis](#phpredis)\r\n- [与 Redis 交互](#interacting-with-redis)\r\n    - [事务](#transactions)\r\n    - [管道命令](#pipelining-commands)\r\n- [发布与订阅](#pubsub)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Redis](https://redis.io) 是一个开源的，高级键值对存储数据库。 包含的数据类型有 [字符串](https://redis.io/topics/data-types#strings), [hash](https://redis.io/topics/data-types#hashes), [列表](https://redis.io/topics/data-types#lists), [集合](https://redis.io/topics/data-types#sets), 和 [有序集合](https://redis.io/topics/data-types#sorted-sets).\r\n\r\n在将 Redis 与 Laravel 一起使用前，我们鼓励你通过 PECL 安装并使用  [PhpRedis](https://github.com/phpredis/phpredis) 尽管扩展安装起来更复杂，但对于大量使用 Redis 的应用程序可能会产生更好的性能。\r\n\r\n如果你正在使用 [Laravel Sail](/docs/laravel/9.x/sail), 这个扩展已经实现安装好在你的 Docker 容器中了。\r\n\r\n如果你不能安装 PHPRedis 扩展，你或许可以使用 composer 安装 `predis/predis` 包。Predis 是一个完全用 PHP 编写的 Redis 客户端，不需要任何额外的扩展：\r\n\r\n```shell\r\ncomposer require predis/predis\r\n```\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n在你的应用中配置 Redis 信息，你要在 `config/database.php` 文件中进行配置。在该文件中，你将看到一个 `Redis` 数组包含了你的 Redis 配置信息。\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'default' => [\r\n            'host' => env('REDIS_HOST', '127.0.0.1'),\r\n            'password' => env('REDIS_PASSWORD'),\r\n            'port' => env('REDIS_PORT', 6379),\r\n            'database' => env('REDIS_DB', 0),\r\n        ],\r\n\r\n        'cache' => [\r\n            'host' => env('REDIS_HOST', '127.0.0.1'),\r\n            'password' => env('REDIS_PASSWORD'),\r\n            'port' => env('REDIS_PORT', 6379),\r\n            'database' => env('REDIS_CACHE_DB', 1),\r\n        ],\r\n\r\n    ],\r\n\r\n\r\n\r\n在你的配置文件里定义的每个 Redis 服务器，除了用 URL 来表示的 Redis 连接，都必需要指定名称  、 host （主机）和 port （端口）字段：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'default' => [\r\n            'url' => 'tcp://127.0.0.1:6379?database=0',\r\n        ],\r\n\r\n        'cache' => [\r\n            'url' => 'tls://user:password@127.0.0.1:6380?database=1',\r\n        ],\r\n\r\n    ],\r\n\r\n<a name=\"configuring-the-connection-scheme\"></a>\r\n#### 配置连接方案\r\n\r\n默认情况下，Redis 客户端使用`tcp`方案连接Redis服务器。另外，你也可以在你的 Redis 服务配置数组中指定一个`scheme`配置项，来使用 TLS/SSL 加密：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'default' => [\r\n            'scheme' => 'tls',\r\n            'host' => env('REDIS_HOST', '127.0.0.1'),\r\n            'password' => env('REDIS_PASSWORD'),\r\n            'port' => env('REDIS_PORT', 6379),\r\n            'database' => env('REDIS_DB', 0),\r\n        ],\r\n\r\n    ],\r\n\r\n<a name=\"clusters\"></a>\r\n### 集群\r\n\r\n如果你的应用使用 Redis 集群，你应该在 Redis 配置文件中用`clusters`键来定义集群。这个配置键默认没有，所以你需要在`config/database.php`配置文件中手动创建：\r\n\r\n    'redis' => [\r\n\r\n    'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n    'clusters' => [\r\n        'default' => [\r\n            [\r\n                'host' => env('REDIS_HOST', 'localhost'),\r\n                'password' => env('REDIS_PASSWORD'),\r\n                'port' => env('REDIS_PORT', 6379),\r\n                'database' => 0,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n默认情况下，集群可以在节点上实现客户端分片，允许你实现节点池以及创建大量可用内存。这里要注意，客户端共享不会处理失败的情况；因此，这个功能主要适用于从另一个主数据库获取的缓存数据。\r\n如果要使用 Redis 原生集群，需要把`config/database.php`配置文件下的`options.cluster`配置项的值设置为`redis`：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'options' => [\r\n            'cluster' => env('REDIS_CLUSTER', 'redis'),\r\n        ],\r\n\r\n        'clusters' => [\r\n            // ...\r\n        ],\r\n\r\n    ],\r\n\r\n<a name=\"predis\"></a>\r\n### Predis\r\n\r\n要使用 Predis 扩展去连接 Redis， 请确保环境变量 `REDIS_CLIENT` 的值为 `predis`：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'predis'),\r\n\r\n        // 重设 Redis 配置项...\r\n    ],\r\n\r\n除默认的 `host`，`port`，`database` 和 `password` 这些服务配置选项外， Predis 还支持为每个 Redis 服务器定义其它的 [连接参数](https://github.com/nrk/predis/wiki/Connection-Parameters)。如果要使用这些额外的配置项，可以在 `config/database.php` 配置文件中将任意选项添加到 Redis 服务器配置内：\r\n\r\n    'default' => [\r\n        'host' => env('REDIS_HOST', 'localhost'),\r\n        'password' => env('REDIS_PASSWORD'),\r\n        'port' => env('REDIS_PORT', 6379),\r\n        'database' => 0,\r\n        'read_write_timeout' => 60,\r\n    ],\r\n\r\n<a name=\"the-redis-facade-alias\"></a>\r\n#### Redis Facade 别名\r\n\r\nLaravel 的 `config/app.php` 配置文件包含了 `aliases` 数组，该数组可用于定义通过框架注册的所有类别名。方便起见，Laravel 提供了一份包含了所有 [facade](/docs/laravel/9.x/facades) 的别名入口；不过，`Redis` 别名不能在这里使用，因为这与 phpredis 扩展提供的 `Redis` 类名冲突。如果正在使用 Predis 客户端并确实想要用这个别名，你可以在 `config/app.php` 配置文件中取消对此别名的注释。\r\n\r\n<a name=\"phpredis\"></a>\r\n### phpredis\r\n\r\nLaravel 默认使用 phpredis 扩展与 Redis 通信。Laravel 用于与 Redis 通信的客户端由 `redis.client` 配置项决定，这个配置通常为环境变量 `REDIS_CLIENT` 的值：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        // 重设 Redis 配置项...\r\n    ],\r\n\r\n\r\n除默认的 `scheme`, `host`, `port`, `database` 和 `password` 的服务器配置选项外，phpredis 还支持以下额外的连接参数：`name`, `persistent`, `persistent_id`, `prefix`, `read_timeout`, `retry_interval`, `timeout` 和 `context`。 您可以在 `config/database.php` 配置文件中将任意选项添加到 Redis 服务器配置内：\r\n\r\n    'default' => [\r\n        'host' => env('REDIS_HOST', 'localhost'),\r\n        'password' => env('REDIS_PASSWORD'),\r\n        'port' => env('REDIS_PORT', 6379),\r\n        'database' => 0,\r\n        'read_timeout' => 60,\r\n        'context' => [\r\n            // 'auth' => ['username', 'secret'],\r\n            // 'stream' => ['verify_peer' => false],\r\n        ],\r\n    ],\r\n\r\n<a name=\"phpredis-serialization\"></a>\r\n#### phpredis 序列化和压缩\r\n\r\nphpredis 扩展可以配置使用各种序列化和压缩算法。可以通过设置 Redis 配置中的 `options` 数组进行配置：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'options' => [\r\n            'serializer' => Redis::SERIALIZER_MSGPACK,\r\n            'compression' => Redis::COMPRESSION_LZ4,\r\n        ],\r\n\r\n        // 重设 Redis 配置项...\r\n    ],\r\n\r\n当前支持的序列化算法包括： `Redis::SERIALIZER_NONE` （默认）,  `Redis::SERIALIZER_PHP`, `Redis::SERIALIZER_JSON`, `Redis::SERIALIZER_IGBINARY` 和 `Redis::SERIALIZER_MSGPACK` 。\r\n\r\n支持的压缩算法包括： `Redis::COMPRESSION_NONE` （默认）,  `Redis::COMPRESSION_LZF`, `Redis::COMPRESSION_ZSTD` 和 `Redis::COMPRESSION_LZ4` 。\r\n\r\n<a name=\"interacting-with-redis\"></a>\r\n## 与 Redis 交互\r\n\r\n你可以通过调用 `Redis` [facade](/docs/laravel/8.5/facades) 上的各种方法来与 Redis 进行交互。 `Redis` facade 支持动态方法，所以你可以在 facade 上调用各种 [Redis 命令](https://redis.io/commands) ，这些命令将直接传递给 Redis 。在本例中，我们将调用 `Redis` facade 的 `get` 方法，来调用 Redis `GET` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示给定用户的配置文件\r\n         *\r\n         * @param  int  $id\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function show($id)\r\n        {\r\n            return view('user.profile', [\r\n                'user' => Redis::get('user:profile:'.$id)\r\n            ]);\r\n        }\r\n    }\r\n\r\n如上所述，你可以在 `Redis` facade 上调用任意 Redis 命令。 Laravel 使用魔术方法将命令传递给 Redis 服务器。如果一个 Redis 命令需要参数，则应将这些参数传递给 `Redis` facade 的相应方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    Redis::set('name', 'Taylor');\r\n\r\n    $values = Redis::lrange('names', 5, 10);\r\n\r\n或者，你也可以使用 `Redis` facade 上的 `command` 方法将命令传递给服务器，它接受命令的名称作为其第一个参数，并将值的数组作为其第二个参数：\r\n\r\n    $values = Redis::command('lrange', ['name', 5, 10]);\r\n\r\n<a name=\"using-multiple-redis-connections\"></a>\r\n#### 使用多个 Redis 连接\r\n\r\n你应用里的 `config/database.php` 配置文件允许你去定义多个 Redis 连接或者服务器。你可以使用 `Redis` facade 上的 `connection` 方法获得指定的 Redis 连接：\r\n\r\n    $redis = Redis::connection('connection-name');\r\n\r\n要获取获取一个默认的 Redis 连接，你可以调用 `connection` 方法时，不带任何参数：\r\n\r\n    $redis = Redis::connection();\r\n\r\n<a name=\"transactions\"></a>\r\n### 事务\r\n\r\n`Redis` facade 上的 `transaction` 方法对 Redis 原生的 `MULTI` 和 `EXEC` 命令进行了封装。 `transaction` 方法接受一个闭包作为其唯一参数。这个闭包将接收一个 Redis 连接实例，并可能向这个实例发出想要的任何命令。闭包中发出的所有Redis命令都将在单个原子性事务中执行：\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    Redis::transaction(function ($redis) {\r\n        $redis->incr('user_visits', 1);\r\n        $redis->incr('total_visits', 1);\r\n    });\r\n\r\n> 注意：定义一个 Redis 事务时，你不能从 Redis 连接中获取任何值。请记住，事务是作为单个原子性操作执行的，在整个闭包执行完其命令之前，不会执行该操作。\r\n\r\n#### Lua 脚本\r\n\r\n`eval` 方法提供了另外一种原子性执行多条 Redis 命令的方式。但是，`eval` 方法的好处是能够在操作期间与 Redis 键值交互并检查它们。 Redis 脚本是用 [Lua 编程语言](https://www.lua.org) 编写的。\r\n`eval` 方法一开始可能有点令人劝退，所以我们将用一个基本示例来明确它的使用方法。 `eval` 方法需要几个参数。第一，在方法中传递一个 Lua 脚本（作为一个字符串）。第二，在方法中传递脚本交互中用到的键的数量（作为一个整数）。第三，在方法中传递所有键名。最后，你可以传递一些脚本中用到的其他参数。\r\n\r\n在本例中，我们要对第一个计数器进行递增，检查它的新值，如果该计数器的值大于5，那么递增第二个计数器。最终，我们将返回第一个计数器的值：\r\n\r\n    $value = Redis::eval(<<<'LUA'\r\n        local counter = redis.call(\"incr\", KEYS[1])\r\n\r\n        if counter > 5 then\r\n            redis.call(\"incr\", KEYS[2])\r\n        end\r\n\r\n        return counter\r\n    LUA, 2, 'first-counter', 'second-counter');\r\n\r\n> 注意：请参考 [Redis 文档](https://redis.io/commands/eval) 更多关于 Redis 脚本的信息。\r\n\r\n<a name=\"pipelining-commands\"></a>\r\n### 管道命令\r\n\r\n当你需要执行很多个 Redis 命令时，你可以使用 `pipeline` 方法一次性提交所有命令，而不需要每条命令都与 Redis 服务器建立一次网络连接。 `pipeline` 方法只接受一个参数：接收一个 Redis 实例的闭包。你可以将所有命令发给这个 Redis 实例，它们将同时发送到 Redis 服务器，以减少到服务器的网络访问。这些命令仍然会按照发出的顺序执行：\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    Redis::pipeline(function ($pipe) {\r\n        for ($i = 0; $i < 1000; $i++) {\r\n            $pipe->set(\"key:$i\", $i);\r\n        }\r\n    });\r\n\r\n\r\n<a name=\"pubsub\"></a>\r\n## 发布 / 订阅\r\n\r\nLaravel 为 Redis 的 `publish` 和 `subscribe` 命令提供了方便的接口。你可以用这些 Redis 命令监听指定「频道」上的消息。你也可以从一个应用程序发消息给另一个应用程序，哪怕它是用其它编程语言开发的，让应用程序和进程之间能够轻松进行通信。\r\n首先，用 `subscribe` 方法设置一个频道监听器。我们将这个方法调用放到一个 [Artisan 命令](/docs/laravel/8.5/artisan) 中，因为调用 `subscribe` 方法会启动一个常驻进程：\r\n\r\n    <?php\r\n\r\n    namespace App\\Console\\Commands;\r\n\r\n    use Illuminate\\Console\\Command;\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    class RedisSubscribe extends Command\r\n    {\r\n        /**\r\n         * 控制台命令的名称和签名\r\n         *\r\n         * @var string\r\n         */\r\n        protected $signature = 'redis:subscribe';\r\n\r\n        /**\r\n         * 控制台命令的描述\r\n         *\r\n         * @var string\r\n         */\r\n        protected $description = 'Subscribe to a Redis channel';\r\n\r\n        /**\r\n         * 执行控制台命令\r\n         *\r\n         * @return mixed\r\n         */\r\n        public function handle()\r\n        {\r\n            Redis::subscribe(['test-channel'], function ($message) {\r\n                echo $message;\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n\r\n现在我们可以使用 `publish` 方法将消息发布到频道：\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    Route::get('/publish', function () {\r\n        // ...\r\n\r\n        Redis::publish('test-channel', json_encode([\r\n            'name' => 'Adam Wathan'\r\n        ]));\r\n    });\r\n\r\n<a name=\"wildcard-subscriptions\"></a>\r\n#### 通配符订阅\r\n\r\n使用 `psubscribe` 方法，你可以订阅一个通配符频道，用来获取所有频道中的所有消息，频道名称将作为第二个参数传递给提供的回调闭包：\r\n\r\n    Redis::psubscribe(['*'], function ($message, $channel) {\r\n        echo $message;\r\n    });\r\n\r\n    Redis::psubscribe(['users.*'], function ($message, $channel) {\r\n        echo $message;\r\n    });\r\n\r\n","p":"docs/redis.html"},{"t":"eloquent (Eloquent: 入门)","d":"# Eloquent: 入门\r\n\r\n- [简介](#introduction)\r\n- [生成模型类](#generating-model-classes)\r\n- [模型约定](#eloquent-model-conventions)\r\n    - [表名](#table-names)\r\n    - [主键](#primary-keys)\r\n    - [时间戳](#timestamps)\r\n    - [数据库链接](#database-connections)\r\n    - [默认属性值](#default-attribute-values)\r\n- [模型检索](#retrieving-models)\r\n    - [集合](#collections)\r\n    - [结果分块](#chunking-results)\r\n    - [用 Lazy Collections 分块](#chunking-using-lazy-collections)\r\n    - [游标](#cursors)\r\n    - [高级子查询](#advanced-subqueries)\r\n- [检索单个模型 / 集合](#retrieving-single-models)\r\n    - [检索或创建模型](#retrieving-or-creating-models)\r\n    - [检索集合](#retrieving-aggregates)\r\n- [插入 & 更新模型](#inserting-and-updating-models)\r\n    - [插入](#inserts)\r\n    - [更新](#updates)\r\n    - [批量赋值](#mass-assignment)\r\n    - [更新或插入](#upserts)\r\n- [删除模型](#deleting-models)\r\n    - [软删除](#soft-deleting)\r\n    - [查询软删除模型](#querying-soft-deleted-models)\r\n- [定期删除模型](#pruning-models)\r\n- [模型复制](#replicating-models)\r\n- [查询作用域](#query-scopes)\r\n    - [全局作用域](#global-scopes)\r\n    - [局部作用域](#local-scopes)\r\n- [模型对比](#comparing-models)\r\n- [事件](#events)\r\n    - [使用闭包](#events-using-closures)\r\n    - [观察器](#observers)\r\n    - [静默事件](#muting-events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 包含了 Eloquent，这是一个对象关系映射器（ORM），使与数据库的交互变得很愉快。使用 Eloquent 时，每个数据库表都有一个对应的「模型」，用于与该表进行交互。除了从数据库表中检索记录外，Eloquent 模型还允许您从表中插入，更新和删除记录。\r\n\r\n> 技巧：在开始之前，请确保在应用的 `config/database.php` 配置文件中配置数据库连接。有关配置数据库的更多信息，请参阅 [数据库配置文档](/docs/laravel/9.x/database#configuration)。\r\n\r\n<a name=\"generating-model-classes\"></a>\r\n## 生成模型类\r\n\r\n\r\n\r\n首先，让我们创建一个 Eloquent 模型。模型通常位于  `app\\Models` 目录中，并继承 `Illuminate\\Database\\Eloquent\\Model` 类。您可以使用 `make:model` [Artisan 命令](/docs/laravel/9.x/artisan) 来生成新模型类：\r\n\r\n```shell\r\nphp artisan make:model Flight\r\n```\r\n\r\n如果你想要在生成模型类的同时生成 [数据库迁移](/docs/laravel/9.x/migrations)，可以使用 `--migration` 或 `-m` 选项：\r\n\r\n```shell\r\nphp artisan make:model Flight --migration\r\n```\r\n\r\n在生成模型的同时，你可能还想要各种其他类型的类，例如模型工厂、数据填充和控制器。这些选项可以组合在一起从而一次创建多个类：\r\n\r\n```shell\r\n# 生成模型和 Flight工厂类...\r\nphp artisan make:model Flight --factory\r\nphp artisan make:model Flight -f\r\n\r\n# 生成模型和 Flight 数据填充类...\r\nphp artisan make:model Flight --seed\r\nphp artisan make:model Flight -s\r\n\r\n# 生成模型和 Flight 控制器类...\r\nphp artisan make:model Flight --controller\r\nphp artisan make:model Flight -c\r\n\r\n# 生成模型，Flight 控制器类，资源类和表单验证类...\r\nphp artisan make:model Flight --controller --resource --requests\r\nphp artisan make:model Flight -crR\r\n\r\n# 生成模型和 Flight 授权策略类...\r\nphp artisan make:model Flight --policy\r\n\r\n# 生成模型和数据库迁移，Filght 工厂类，数据库填充类和 Flight 控制器...\r\nphp artisan make:model Flight -mfsc\r\n\r\n# 快捷生成模型，数据库迁移，Flight 工厂类，数据库填充类，授权策略类，Flight 控制器和表单验证类...\r\nphp artisan make:model Flight --all\r\n\r\n# 生成中间表模型...\r\nphp artisan make:model Member --pivot\r\n```\r\n\r\n\r\n\r\n<a name=\"eloquent-model-conventions\"></a>\r\n## Eloquent 模型约定\r\n\r\n由 `make:model` 命令生成的模型会被放置在 `app/Models` 目录下。让我们检查一个基本的模型类并讨论 `Eloquent` 的一些关键约定：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        //\r\n    }\r\n\r\n<a name=\"table-names\"></a>\r\n### 数据表名称\r\n\r\n看了上面的例子，你可能已经注意到我们没有告诉 Eloquent 哪个数据库表对应我们的 `Flight` 模型。按照约定，除非明确指定另一个名称，类名称的下划线格式的复数形态将被用作表名。因此，在这个例子中, Eloquent 将假定 `Flight` 模型将记录存储在 `flights` 表中，而 `AirTrafficController` 模型将记录存储在 `air_traffic_controllers` 表中。\r\n\r\n如果你的模型对应的数据表不符合这个约定，你可以通过在模型上定义一个 `table` 属性来手动指定模型的表名：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 与模型关联的数据表.\r\n         *\r\n         * @var string\r\n         */\r\n        protected $table = 'my_flights';\r\n    }\r\n\r\n<a name=\"primary-keys\"></a>\r\n### 主键\r\n\r\nEloquent 还会假设每个模型对应的数据表都有一个名为 `id` 的列作为主键。如有必要，你可以在模型上定义一个受保护的 `$primaryKey` 属性，来指定一个不同的列名称用作模型的主键：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 与数据表关联的主键.\r\n         *\r\n         * @var string\r\n         */\r\n        protected $primaryKey = 'flight_id';\r\n    }\r\n\r\n\r\n\r\n此外，Eloquent 默认有一个 integer 值的主键，Eloquent 会自动转换这个主键为一个 integer 类型，如果你的主键不是自增或者不是数字类型，你可以在你的模型上定义一个 public 属性的 `$incrementing` ，并将其设置为 false：\r\n\r\n    <?php\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 指明模型的 ID 不是自增。\r\n         *\r\n         * @var bool\r\n         */\r\n        public $incrementing = false;\r\n    }\r\n\r\n如果你模型主键不是 `integer`，应该定义一个 `protected $keyType` 属性在模型上，其值应为 `string`：\r\n\r\n    <?php\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 自增 ID 的数据类型。\r\n         *\r\n         * @var string\r\n         */\r\n        protected $keyType = 'string';\r\n    }\r\n\r\n<a name=\"composite-primary-keys\"></a>\r\n#### 复合主键\r\n\r\nEloquent 要求每个模型至少有一个可以作为其主键的唯一标识 `ID`。它不支持「复合」主键。但是，除了表的唯一标识主键之外，还可以向数据库表添加额外的多列唯一索引。\r\n\r\n<a name=\"timestamps\"></a>\r\n### 时间戳\r\n\r\n默认情况下，Eloquent 期望 `created_at` 和 `updated_at` 列存在于模型对应的数据库表中。 创建或更新模型时，Eloquent 会自动设置这些列的值。如果您不希望 Eloquent 自动管理这些列，您应该在模型上定义一个 `$timestamps` 属性，其值为 `false`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 指示模型是否主动维护时间戳。\r\n         *\r\n         * @var bool\r\n         */\r\n        public $timestamps = false;\r\n    }\r\n\r\n\r\n\r\n如果需要自定义模型时间戳的格式，请在模型上设置 `$dateFormat` 属性。以此来定义时间戳在数据库中的存储方式以及模型序列化为数组或 JSON 时的格式：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 模型日期字段的存储格式。\r\n         *\r\n         * @var string\r\n         */\r\n        protected $dateFormat = 'U';\r\n    }\r\n\r\n如果需要自定义用于存储时间戳的字段的名称，可以在模型上定义 `CREATED_AT` 和 `UPDATED_AT` 常量：\r\n\r\n    <?php\r\n\r\n    class Flight extends Model\r\n    {\r\n        const CREATED_AT = 'creation_date';\r\n        const UPDATED_AT = 'updated_date';\r\n    }\r\n\r\n<a name=\"database-connections\"></a>\r\n### 数据库连接\r\n\r\n默认情况下，所有 Eloquent 模型使用的是应用程序配置的默认数据库连接。如果想指定在与特定模型交互时应该使用的不同连接，可以在模型上定义`$connection` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 设置当前模型使用的数据库连接名。\r\n         *\r\n         * @var string\r\n         */\r\n        protected $connection = 'sqlite';\r\n    }\r\n\r\n<a name=\"default-attribute-values\"></a>\r\n### 默认属性值\r\n\r\n默认情况下，被实例化的模型不会包含任何属性值。如果想为模型的某些属性定义默认值，可以在模型上定义一个 `$attributes` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 模型的属性默认值。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $attributes = [\r\n            'delayed' => false,\r\n        ];\r\n    }\r\n\r\n\r\n\r\n<a name=\"retrieving-models\"></a>\r\n## 检索模型\r\n\r\n一旦你创建了一个模型和 [其关联的数据库表](/docs/laravel/9.x/migrations#writing-migrations)，就可以开始从数据库中检索数据了。可以将每个 Eloquent 模型视为一个强大的 [查询构建器](/docs/laravel/9.x/queries)，让你能流畅地查询与该模型关联的数据库表。模型中的 `all` 方法将从模型的关联数据库表中检索所有记录：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    foreach (Flight::all() as $flight) {\r\n        echo $flight->name;\r\n    }\r\n\r\n<a name=\"building-queries\"></a>\r\n#### 构建查询\r\n\r\nEloquent 的 `all()` 方法会返回模型中所有的结果。由于每个 Eloquent 模型都可以被视为 `查询构造器`，可以添加额外的查询条件，然后使用 `get()` 方法获取查询结果：\r\n\r\n    $flights = Flight::where('active', 1)\r\n                   ->orderBy('name')\r\n                   ->take(10)\r\n                   ->get();\r\n\r\n> 技巧：由于 Eloquent 模型是查询构建器，因此你应该查看 Laravel 的 [查询构建器](/docs/laravel/9.x/queries) 提供的所有方法。在编写 Eloquent 查询时，这些是通用的。\r\n\r\n<a name=\"refreshing-models\"></a>\r\n#### 刷新模型\r\n\r\n如果已经有一个从数据库中检索到的 Eloquent 模型的实例，你可以使用 `fresh` 和 `refresh` 方法「刷新」模型。 `fresh` 方法将从数据库中重新检索模型。现有模型实例不会受到影响：\r\n\r\n    $flight = Flight::where('number', 'FR 900')->first();\r\n\r\n    $freshFlight = $flight->fresh();\r\n\r\n`refresh` 方法会使用数据库中的新数据重新赋值现有的模型。此外，已经加载的关系也会被重新加载：\r\n\r\n    $flight = Flight::where('number', 'FR 900')->first();\r\n\r\n    $flight->number = 'FR 456';\r\n\r\n    $flight->refresh();\r\n\r\n    $flight->number; // \"FR 900\"\r\n\r\n\r\n\r\n<a name=\"collections\"></a>\r\n### 集合\r\n\r\n正如我们所见，像 `all()` 和 `get()` 这样的 Eloquent 方法从数据库中检索出多条记录。但是，这些方法不会返回一个普通的 PHP 数组。相反，会返回一个 `Illuminate\\Database\\Eloquent\\Collection` 的实例。\r\n\r\nEloquent `Collection` 类扩展了 Laravel 的 `Illuminate\\Support\\Collection` 基类，它提供了 [大量的辅助方法](/docs/laravel/9.x/collections#available-methods) 来与数据集合交互。例如，`reject` 方法可用于根据调用闭包的结果从集合中删除模型：\r\n\r\n```php\r\n$flights = Flight::where('destination', 'Paris')->get();\r\n\r\n$flights = $flights->reject(function ($flight) {\r\n    return $flight->cancelled;\r\n});\r\n```\r\n\r\n除了 Laravel 的基础集合类提供的方法之外，Eloquent 集合类还提供了 [一些额外的方法](/docs/laravel/9.x/eloquent-collections#available-methods) ，专门用于与 Eloquent 的模型。\r\n\r\n由于 Laravel 的所有集合都实现了 PHP 的可迭代接口，因此你可以像数组一样循环遍历集合：\r\n\r\n```php\r\nforeach ($flights as $flight) {\r\n    echo $flight->name;\r\n}\r\n```\r\n\r\n<a name=\"chunking-results\"></a>\r\n### 结果分块\r\n\r\n如果你尝试通过 `all()` 或 `get()` 方法加载数万条 Eloquent 记录，您的应用程序可能会耗尽内存。为了避免出现这种情况，「chunk」方法可以用来更有效地处理这些大量数据。\r\n\r\n`chunk` 方法将传递 Eloquent 模型的子集，将它们交给闭包进行处理。由于一次只检索当前的 Eloquent 模型块的数据，所以当处理大量模型数据时，`chunk` 方法将显着减少内存使用：\r\n\r\n```php\r\nuse App\\Models\\Flight;\r\n\r\nFlight::chunk(200, function ($flights) {\r\n    foreach ($flights as $flight) {\r\n        // TODO\r\n    }\r\n});\r\n```\r\n\r\n\r\n\r\n传递给「chunk」方法的第一个参数是每个分块检索的数据数量。第二个参数传递的闭包将方法将应用到每个分块，以数据库中查询到的分块结果来作为参数。\r\n\r\n如果要根据一个字段来过滤「chunk」方法拿到的数据，同时，这个字段的数据在遍历的时候还需要更新的话，那么可以使用「chunkById」方法。在这种场景下如果使用「chunk」方法的话，得到的结果可能和预想中的不一样。在「chunkById」 方法的内部，默认会查询 id 字段大于前一个分块中最后一个模型的 id。\r\n\r\n```php\r\nFlight::where('departed', true)\r\n    ->chunkById(200, function ($flights) {\r\n        $flights->each->update(['departed' => false]);\r\n    }, $column = 'id');\r\n```\r\n\r\n<a name=\"chunking-using-lazy-collections\"></a>\r\n### 使用惰性集合进行分块\r\n\r\n`lazy` 方法的工作方式类似于 [`chunk` 方法](#chunking-results)，因为它在后台以块的形式执行查询。 然而，`lazy` 方法不是将每个块直接传递到回调中，而是返回 Eloquent 模型的扁平化 [`LazyCollection`](/docs/laravel/9.x/collections#lazy-collections)，它可以让你将结果作为单个流进行交互：\r\n\r\n```php\r\nuse App\\Models\\Flight;\r\n\r\nforeach (Flight::lazy() as $flight) {\r\n    //\r\n}\r\n```\r\n\r\n如果要根据一个字段来过滤「lazy」方法拿到的数据，同时，这个字段的数据在遍历的时候还需要更新的话，那么可以使用「lazyById」方法。在「lazyById」 方法的内部，默认会查询 id 字段大于前一个「chunk」中最后一个模型的 id 。\r\n\r\n```php\r\nFlight::where('departed', true)\r\n    ->lazyById(200, $column = 'id')\r\n    ->each->update(['departed' => false]);\r\n```\r\n\r\n你可以使用 `lazyByIdDesc` 方法根据 `id` 的降序过滤结果。\r\n\r\n<a name=\"cursors\"></a>\r\n### 游标\r\n\r\n与 `lazy` 方法类似，`cursor` 方法可用于在查询数万条 Eloquent 模型记录时减少内存的使用。\r\n\r\n`cursor` 方法只会执行一次数据库查询；但是，各个 Eloquent 模型在实际迭代之前不会被数据填充。因此，在遍历游标时，在任何给定时间，只有一个 Eloquent 模型保留在内存中。\r\n\r\n> 注意：由于 `cursor` 方法一次只能在内存中保存一个 Eloquent 模型，因此它不能预加载关系。如果需要预加载关系，请考虑使用 [`lazy` 方法](#streaming-results-lazily)。\r\n\r\n在内部，`cursor` 方法使用 PHP [generators](https://www.php.net/manual/en/language.generators.overview.php) 来实现此功能：\r\n\r\n```php\r\nuse App\\Models\\Flight;\r\n\r\nforeach (Flight::where('destination', 'Zurich')->cursor() as $flight) {\r\n    //\r\n}\r\n```\r\n\r\n`cursor` 返回一个 `Illuminate\\Support\\LazyCollection` 实例。[惰性集合](/docs/laravel/9.x/collections#lazy-collections) 可以使用 Laravel 集合中的可用方法，同时一次仅将单个模型加载到内存中：\r\n\r\n```php\r\nuse App\\Models\\User;\r\n\r\n$users = User::cursor()->filter(function ($user) {\r\n    return $user->id > 500;\r\n});\r\n\r\nforeach ($users as $user) {\r\n    echo $user->id;\r\n}\r\n```\r\n\r\n尽管 `cursor` 方法使用的内存比常规查询要少得多（一次只在内存中保存一个 Eloquent 模型），但它最终仍会耗尽内存。这是 [由于 PHP 的 PDO 驱动程序内部将所有原始查询结果缓存在其缓冲区中](https://www.php.net/manual/en/mysqlinfo.concepts.buffering.php)。 如果要处理大量 Eloquent 记录，请考虑使用 [`lazy` 方法](#streaming-results-lazily)。\r\n\r\n\r\n\r\n<a name=\"advanced-subqueries\"></a>\r\n## 高级子查询\r\n\r\n<a name=\"subquery-selects\"></a>\r\n#### selects 子查询\r\n\r\nEloquent 还提供高级子查询支持，你可以在单条语句中从相关表中提取信息。 例如，假设我们有一个航班目的地表「destinations」和一个到达这些目的地的航班表「flights」。 `flights` 表包含一个 `arrived_at` 字段，指示航班何时到达目的地。\r\n\r\n使用查询生成器可用的子查询功能 `select` 和 `addSelect` 方法，我们可以用单条语句查询全部目的地 `destinations` 和 抵达各目的地最后一班航班的名称：\r\n\r\n    use App\\Models\\Destination;\r\n    use App\\Models\\Flight;\r\n\r\n    return Destination::addSelect(['last_flight' => Flight::select('name')\r\n        ->whereColumn('destination_id', 'destinations.id')\r\n        ->orderByDesc('arrived_at')\r\n        ->limit(1)\r\n    ])->get();\r\n\r\n<a name=\"subquery-ordering\"></a>\r\n#### 子查询排序\r\n\r\n此外，查询构建器的 `orderBy` 也同样支持子查询。继续使用我们的航班为例，根据最后一次航班到达该目的地的时间对所有目的地进行排序。这同样可以在执行单个数据库查询时完成：\r\n\r\n    return Destination::orderByDesc(\r\n        Flight::select('arrived_at')\r\n            ->whereColumn('destination_id', 'destinations.id')\r\n            ->orderByDesc('arrived_at')\r\n            ->limit(1)\r\n    )->get();\r\n\r\n<a name=\"retrieving-single-models\"></a>\r\n## 检索单个模型/聚合\r\n\r\n除了检索与给定查询匹配的所有记录之外，还可以使用 `find`、`first` 或 `firstWhere` 方法检索单个记录。 这些方法不是返回模型集合，而是返回单个模型实例：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    // 通过主键检索模型...\r\n    $flight = Flight::find(1);\r\n\r\n    // 检索与查询约束匹配的第一个模型...\r\n    $flight = Flight::where('active', 1)->first();\r\n\r\n    // 替代检索与查询约束匹配的第一个模型...\r\n    $flight = Flight::firstWhere('active', 1);\r\n\r\n\r\n\r\n有时你可能希望检索查询的第一个结果或在未找到结果时执行一些其他操作。 `firstOr` 方法将返回匹配查询的第一个结果，或者，如果没有找到结果，则执行给定的闭包。闭包返回的值将被视为 `firstOr` 方法的结果：\r\n\r\n    $model = Flight::where('legs', '>', 3)->firstOr(function () {\r\n        // ...\r\n    });\r\n\r\n<a name=\"not-found-exceptions\"></a>\r\n#### 未找到时抛出异常\r\n\r\n如果找不到模型，你可能希望抛出异常。这在路由或控制器中特别有用。 `findOrFail` 和 `firstOrFail` 方法将检索查询的第一个结果；但是，如果没有找到结果，则会抛出 `Illuminate\\Database\\Eloquent\\ModelNotFoundException`：\r\n\r\n    $flight = Flight::findOrFail(1);\r\n\r\n    $flight = Flight::where('legs', '>', 3)->firstOrFail();\r\n\r\n如果没有捕获到 `ModelNotFoundException`，则会自动将 404 HTTP 响应发送回客户端：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    Route::get('/api/flights/{id}', function ($id) {\r\n        return Flight::findOrFail($id);\r\n    });\r\n\r\n<a name=\"retrieving-or-creating-models\"></a>\r\n### 检索或创建模型\r\n\r\n`firstOrCreate` 方法将尝试使用给定的列/值对来查找数据库记录。如果在数据库中找不到该模型，则将插入一条记录，其中包含将第一个数组参数与可选的第二个数组参数合并后产生的属性：\r\n\r\n`firstOrNew` 方法，类似`firstOrCreate`，会尝试在数据库中找到与给定属性匹配的记录。如果没有找到，则会返回一个新的模型实例。请注意，由 `firstOrNew` 返回的模型尚未持久化到数据库中。需要手动调用 `save` 方法来保存它：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    // 按名称检索航班，如果不存在则创建它...\r\n    $flight = Flight::firstOrCreate([\r\n        'name' => 'London to Paris'\r\n    ]);\r\n\r\n    // 按名称检索航班或使用名称、延迟和到达时间属性创建它...\r\n    $flight = Flight::firstOrCreate(\r\n        ['name' => 'London to Paris'],\r\n        ['delayed' => 1, 'arrival_time' => '11:30']\r\n    );\r\n\r\n    // 按名称检索航班或实例化一个新的航班实例...\r\n    $flight = Flight::firstOrNew([\r\n        'name' => 'London to Paris'\r\n    ]);\r\n\r\n    // 按名称检索航班或使用名称、延迟和到达时间属性实例化...\r\n    $flight = Flight::firstOrNew(\r\n        ['name' => 'Tokyo to Sydney'],\r\n        ['delayed' => 1, 'arrival_time' => '11:30']\r\n    );\r\n\r\n### 检索单条唯一的模型\r\n要检索一条表中唯一的记录，可以使用 `sole()` 方法，相比 `first()` 和 `find()` ，它会返回一条表中仅有的记录，如果查询结果有重复，会抛出一个断言异常。\r\n\r\n**现有以下航班信息表**\r\n\r\n| flight_no | name | time |\r\n| ------------ | ------------ | ------------ |\r\n| 001 | London to Tokyo | 4AM |\r\n| 001 | London to Tokyo | 4AM |\r\n| 002 | Pairs to London | 8PM |\r\n\r\n```\r\nuse  App\\Models\\Flight;  \r\n\r\n// 检索航班号，如果重复，会抛 `MultipleRecordsFoundException` 异常，并断言重复的条数...  \r\n$flight  =  Flight::where(['flight_no'  =>  '001'])->sole();\r\n\r\n// 检索航班号，如果不能存在，会抛 `ModelNotFoundException` 异常...\r\n$flight  =  Flight::where(['flight_no'  =>  '001'])->sole();\r\n\r\n// 只有当查询条件存在与表中且是表中唯一的记录，才会返回 Model...\r\n$flight  =  Flight::where(['flight_no'  =>  '002'])->sole();\r\n```\r\n\r\n\r\n<a name=\"retrieving-aggregates\"></a>\r\n### 检索聚合\r\n\r\n在与 Eloquent 模型交互时，您还可以使用 Laravel [查询构建器] 提供的 `count`、`sum`、`max` 和其他 [聚合方法](/docs/laravel/9.x/queries#aggregates) 。这些方法返回一个标量值而不是 Eloquent 模型实例：\r\n\r\n    $count = Flight::where('active', 1)->count();\r\n\r\n    $max = Flight::where('active', 1)->max('price');\r\n\r\n<a name=\"inserting-and-updating-models\"></a>\r\n## 插入和更新模型\r\n\r\n<a name=\"inserts\"></a>\r\n### 插入\r\n\r\n当然，在使用 Eloquent 时，我们不仅需要从数据库中检索模型。我们还需要插入新记录。Eloquent 让它变得简单。要将新记录插入数据库，只需要实例化一个新模型实例并在模型上设置属性。然后，在模型实例上调用 `save` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Flight;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class FlightController extends Controller\r\n    {\r\n        /**\r\n         * 在数据库中存储一个新航班。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function store(Request $request)\r\n        {\r\n            // 验证请求...\r\n\r\n            $flight = new Flight;\r\n\r\n            $flight->name = $request->name;\r\n\r\n            $flight->save();\r\n        }\r\n    }\r\n\r\n在此示例中，我们将传入 HTTP 请求中的「name」字段分配给 `App\\Models\\Flight` 模型实例的「name」属性。 当我们调用 `save` 方法时，一条记录将被插入到数据库中。模型的 `created_at` 和 `updated_at` 时间戳会在调用 `save` 方法时自动设置，无需手动设置。\r\n\r\n\r\n\r\n或者，可以使用 `create` 方法使用单个 PHP 语句「保存」一个新模型。插入的模型实例将通过 `create` 方法返回：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flight = Flight::create([\r\n        'name' => 'London to Paris',\r\n    ]);\r\n\r\n但是，在使用 `create` 方法之前，您需要在模型类上指定 `fillable` 或 `guarded` 属性。这些属性是必需的，因为默认情况下，所有 Eloquent 模型都受到保护，免受批量赋值漏洞的影响。 要了解有关批量赋值的更多信息，请参阅 [批量赋值文档](#mass-assignment)。\r\n\r\n<a name=\"updates\"></a>\r\n### 更新\r\n\r\n`save` 方法也可以用来更新数据库中已经存在的模型。要更新模型，应该检索它并设置你想更新的任何属性。然后调用模型的 `save` 方法。 同样，`updated_at` 时间戳将自动更新，因此无需手动设置其值：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flight = Flight::find(1);\r\n\r\n    $flight->name = 'Paris to London';\r\n\r\n    $flight->save();\r\n\r\n<a name=\"mass-updates\"></a>\r\n#### 批量更新 \r\n\r\n还可以批量更新与给定条件匹配的所有模型。在此示例中，所有 `active` 且 `destination` 为 `San Diego` 的航班都将被标记为延迟：\r\n\r\n    Flight::where('active', 1)\r\n          ->where('destination', 'San Diego')\r\n          ->update(['delayed' => 1]);\r\n\r\n`update` 方法需要一个表示应该更新的列的列和值对数组。 `update` 方法返回受影响的行数。\r\n\r\n> 注意：通过 Eloquent 批量更新时，不会触发模型的 `saving`、`saved`、`updating` 和 `updated` 模型事件。 这是因为在批量更新时从未真正检索到模型。\r\n\r\n\r\n\r\n<a name=\"examining-attribute-changes\"></a>\r\n#### 检查属性变更\r\n\r\nEloquent 提供了 `isDirty`、`isClean` 和 `wasChanged` 方法来检查模型的内部状态，并确定它的属性与最初检索模型时的变化情况。\r\n\r\n`isDirty` 方法确定模型的任何属性在检索模型后是否已更改。你可以传递特定的属性名称来确定它是否变脏。 `isClean` 方法与 `isDirty` 相反，它也接受可选的属性参数：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::create([\r\n        'first_name' => 'Taylor',\r\n        'last_name' => 'Otwell',\r\n        'title' => 'Developer',\r\n    ]);\r\n\r\n    $user->title = 'Painter';\r\n\r\n    $user->isDirty(); // true\r\n    $user->isDirty('title'); // true\r\n    $user->isDirty('first_name'); // false\r\n\r\n    $user->isClean(); // false\r\n    $user->isClean('title'); // false\r\n    $user->isClean('first_name'); // true\r\n\r\n    $user->save();\r\n\r\n    $user->isDirty(); // false\r\n    $user->isClean(); // true\r\n\r\nwasChanged 方法确定在当前请求周期内最后一次保存模型时是否更改了任何属性。你还可以传递属性名称以查看特定属性是否已更改：\r\n\r\n    $user = User::create([\r\n        'first_name' => 'Taylor',\r\n        'last_name' => 'Otwell',\r\n        'title' => 'Developer',\r\n    ]);\r\n\r\n    $user->title = 'Painter';\r\n\r\n    $user->save();\r\n\r\n    $user->wasChanged(); // true\r\n    $user->wasChanged('title'); // true\r\n    $user->wasChanged('first_name'); // false\r\n\r\n`getOriginal` 方法返回一个包含模型原始属性的数组，忽略加载模型之后进行的任何更改。你也可以传递特定的属性名称来获取特定属性的原始值：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->name; // John\r\n    $user->email; // john@example.com\r\n\r\n    $user->name = \"Jack\";\r\n    $user->name; // Jack\r\n\r\n    $user->getOriginal('name'); // John\r\n    $user->getOriginal(); // 原始属性数组...\r\n\r\n\r\n\r\n<a name=\"mass-assignment\"></a>\r\n### 批量赋值\r\n\r\n你可以使用「create」方法使用单个 PHP 语句「保存」一个新模型。插入的模型实例将通过该方法返回：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flight = Flight::create([\r\n        'name' => 'London to Paris',\r\n    ]);\r\n\r\n但是，在使用 `create` 方法之前，需要在模型类上指定 `fillable` 或 `guarded` 属性。 这些属性是必需的，因为默认情况下，所有 Eloquent 模型都受到保护，免受批量分配漏洞的影响。\r\n\r\n当用户传递一个意外的 HTTP 请求字段并且该字段更改了你的数据库中的一个字段，而你没有预料到时，就会出现批量分配漏洞。 例如，恶意用户可能通过 HTTP 请求发送 `is_admin` 参数，然后将其传递给模型的 `create` 方法，从而允许用户将自己升级为管理员。\r\n\r\n因此，你应该定义要使哪些模型属性可批量分配。可以使用模型上的 `$fillable` 属性来执行此操作。 例如，让 `Flight` 模型的 `name` 属性可以批量赋值：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 可批量赋值的属性。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $fillable = ['name'];\r\n    }\r\n\r\n一旦你指定了哪些属性是可批量分配的，可以使用`create`方法在数据库中插入一条新记录。`create` 方法返回新创建的模型实例：\r\n\r\n    $flight = Flight::create(['name' => 'London to Paris']);\r\n\r\n如果你已经有一个模型实例，你可以使用 `fill` 方法来填充它的属性数组：\r\n\r\n    $flight->fill(['name' => 'Amsterdam to Frankfurt']);\r\n\r\n\r\n\r\n<a name=\"mass-assignment-json-columns\"></a>\r\n#### 批量赋值 & JSON 列\r\n\r\n分配 JSON 列时，必须在模型的 `$fillable` 数组中指定每个列的批量分配键。为了安全起见，Laravel 不支持在使用 `guarded` 属性时更新嵌套的 JSON 属性：\r\n\r\n    /**\r\n     * 可以批量赋值的属性\r\n     *\r\n     * @var array\r\n     */\r\n    protected $fillable = [\r\n        'options->enabled',\r\n    ];\r\n\r\n<a name=\"allowing-mass-assignment\"></a>\r\n#### 允许批量分配\r\n\r\n如果你想让所有属性都可以批量赋值，你可以将 $guarded 定义成一个空数组。如果你选择解除你的模型的保护，你应该时刻特别注意传递给 Eloquent 的 fill、create 和 update 方法的数组：\r\n\r\n    /**\r\n     * 不可以批量赋值的属性\r\n     *\r\n     * @var array\r\n     */\r\n    protected $guarded = [];\r\n\r\n<a name=\"upserts\"></a>\r\n### 新增或更新\r\n\r\n有时，如果不存在匹配的模型，您可能需要更新现有模型或创建新模型。与 `firstOrCreate` 方法一样，`updateOrCreate` 方法会持久化模型，因此无需手动调用 `save` 方法。\r\n\r\n在下面的示例中，如果存在「departure」位置为「Oakland」且「destination」位置为「San Diego」的航班，则其「price」和「discounted」列将被更新。 如果不存在这样的航班，将创建一个新航班，该航班具有将第一个参数数组与第二个参数数组合并后的属性：\r\n\r\n    $flight = Flight::updateOrCreate(\r\n        ['departure' => 'Oakland', 'destination' => 'San Diego'],\r\n        ['price' => 99, 'discounted' => 1]\r\n    );\r\n\r\n如果你想在单个查询中执行多个「新增或更新」，那么应该使用 `upsert` 方法。该方法的第一个参数包含要插入或更新的值，而第二个参数列出了在关联表中唯一标识记录的列。该方法的第三个也是最后一个参数是一个列数组，如果数据库中已经存在匹配的记录，则应该更新这些列。如果在模型上启用了时间戳，`upsert` 方法将自动设置 `created_at` 和 `updated_at` 时间戳：\r\n\r\n    Flight::upsert([\r\n        ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],\r\n        ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]\r\n    ], ['departure', 'destination'], ['price']);\r\n\r\n\r\n\r\n<a name=\"deleting-models\"></a>\r\n## 删除模型\r\n\r\n想删除模型，你可以调用模型实例的 delete 方法:\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flight = Flight::find(1);\r\n\r\n    $flight->delete();\r\n\r\n你可以调用 `truncate` 方法来删除所有模型关联的数据库记录。 `truncate` 操作还将重置模型关联表上的所有自动递增 ID：\r\n\r\n    Flight::truncate();\r\n\r\n<a name=\"deleting-an-existing-model-by-its-primary-key\"></a>\r\n#### 通过其主键删除现有模型\r\n\r\n在上面的示例中，我们在调用「删除」方法之前从数据库中检索模型。但是，如果你知道模型的主键，则可以通过调用 `destroy` 方法删除模型而无需显式检索它。除了接受单个主键之外，`destroy` 方法还将接受多个主键、主键数组或主键 [collection](/docs/laravel/9.x/collections)：\r\n\r\n    Flight::destroy(1);\r\n\r\n    Flight::destroy(1, 2, 3);\r\n\r\n    Flight::destroy([1, 2, 3]);\r\n\r\n    Flight::destroy(collect([1, 2, 3]));\r\n\r\n> 注意：`destroy` 方法单独加载每个模型并调用 `delete` 方法，以便为每个模型正确调度 `deleting` 和 `deleted` 事件。\r\n\r\n<a name=\"deleting-models-using-queries\"></a>\r\n#### 使用查询删除模型\r\n\r\n当然，你可以构建一个 Eloquent 查询来删除所有符合您查询条件的模型。在此示例中，我们将删除所有标记为非活动的航班。与批量更新一样，批量删除不会为已删除的模型调度模型事件：\r\n\r\n    $deleted = Flight::where('active', 0)->delete();\r\n\r\n> 注意：通过 Eloquent 执行批量删除语句时，不会为已删除的模型调度 `deleting` 和 `deleted` 模型事件。这是因为在执行 delete 语句时从未真正检索到模型。\r\n\r\n\r\n\r\n<a name=\"soft-deleting\"></a>\r\n### 软删除\r\n\r\n除了实际从数据库中删除记录之外，Eloquent 还可以「软删除」。软删除不会真的从数据库中删除记录。相反，它在模型上设置了一个 `deleted_at` 属性，记录模型被「删除」的日期和时间。要为模型启用软删除，请将 `Illuminate\\Database\\Eloquent\\SoftDeletes`  trait 添加到模型中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\SoftDeletes;\r\n\r\n    class Flight extends Model\r\n    {\r\n        use SoftDeletes;\r\n    }\r\n\r\n> 技巧：`SoftDeletes` trait 会自动将 `deleted_at` 属性转换为 `DateTime` / `Carbon` 实例。\r\n\r\n当然，你需要把 `deleted_at` 字段添加到数据表中。`Laravel` 的 [数据迁移](/docs/laravel/9.x/migrations) 有创建这个字段的方法： \r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('flights', function (Blueprint $table) {\r\n        $table->softDeletes();\r\n    });\r\n\r\n    Schema::table('flights', function (Blueprint $table) {\r\n        $table->dropSoftDeletes();\r\n    });\r\n\r\n那现在，当你在模型实例上使用 `delete` 方法，当前日期时间会写入 `deleted_at` 字段。同时，查询出来的结果也会自动排除已被软删除的记录。\r\n\r\n判断模型实例是否已被软删除，可以使用 `trashed` 方法：\r\n\r\n    if ($flight->trashed()) {\r\n        //\r\n    }\r\n\r\n<a name=\"restoring-soft-deleted-models\"></a>\r\n#### 恢复软删除的模型\r\n\r\n有时你可能希望「撤销」软删除的模型。要恢复软删除的模型，可以在模型实例上调用「restore」方法。 `restore` 方法会将模型的 `deleted_at` 列设置为 `null`：\r\n\r\n    $flight->restore();\r\n\r\n\r\n\r\n你也可以在查询中使用 `restore` 方法，从而快速恢复多个模型。和其他「批量」操作一样，这个操作不会触发模型的任何事件：\r\n\r\n    Flight::withTrashed()\r\n            ->where('airline_id', 1)\r\n            ->restore();\r\n\r\n`restore` 方法可以在 [关联查询](/docs/laravel/9.x/eloquent-relationships) 中使用：\r\n\r\n    $flight->history()->restore();\r\n\r\n<a name=\"permanently-deleting-models\"></a>\r\n#### 永久删除模型\r\n\r\n有时你可能需要从数据库中真正删除模型。要从数据库中永久删除软删除的模型，请使用 `forceDelete` 方法：\r\n\r\n    $flight->forceDelete();\r\n\r\n`forceDelete` 同样可以用在关联查询上：\r\n\r\n    $flight->history()->forceDelete();\r\n\r\n<a name=\"querying-soft-deleted-models\"></a>\r\n### 查询软删除模型\r\n\r\n<a name=\"including-soft-deleted-models\"></a>\r\n#### 包括已软删除的模型\r\n\r\n如上所述，软删除模型将自动从查询结果中排除。但是，你也可以通过在查询上调用 `withTrashed` 方法来强制将软删除模型包含在查询结果中：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flights = Flight::withTrashed()\r\n                    ->where('account_id', 1)\r\n                    ->get();\r\n\r\n`withTrashed` 方法可以在 [关联查询](/docs/laravel/9.x/eloquent-relationships) 中使用\r\n\r\n    $flight->history()->withTrashed()->get();\r\n\r\n<a name=\"retrieving-only-soft-deleted-models\"></a>\r\n#### 仅检索软删除的模型\r\n\r\n`onlyTrashed` 方法将检索 **只被** 软删除模型：\r\n\r\n    $flights = Flight::onlyTrashed()\r\n                    ->where('airline_id', 1)\r\n                    ->get();\r\n\r\n<a name=\"pruning-models\"></a>\r\n## 修剪模型\r\n\r\n有时你可能希望定期删除不再需要的模型。为此，您可以将 `Illuminate\\Database\\Eloquent\\Prunable` 或 `Illuminate\\Database\\Eloquent\\MassPrunable` trait 添加到要定期修剪的模型中。将其中一个 trait 添加到模型后，实现 `prunable` 方法，该方法返回一个 Eloquent 查询构建器，用于检索不再需要的模型数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Prunable;\r\n\r\n    class Flight extends Model\r\n    {\r\n        use Prunable;\r\n\r\n        /**\r\n         * 获取可修剪模型查询构造器。\r\n         *\r\n         * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n         */\r\n        public function prunable()\r\n        {\r\n            return static::where('created_at', '<=', now()->subMonth());\r\n        }\r\n    }\r\n\r\n\r\n\r\n当将模型标记为 `Prunable` 时，你还可以在模型上定义 `pruning` 方法。该方法将在模型被删除之前被调用。在从数据库中永久删除模型之前，此方法可用于删除与模型关联的任何其他资源，例如存储的文件：\r\n\r\n    /**\r\n     * 准备模型进行修剪。\r\n     *\r\n     * @return void\r\n     */\r\n    protected function pruning()\r\n    {\r\n        //\r\n    }\r\n\r\n配置可修剪模型后，你还应该在应用程序的 `App\\Console\\Kernel` 类中调度 `model:prune` Artisan 命令。你可以自由选择运行此命令的时间间隔：\r\n\r\n    /**\r\n     * 定义应用程序的命令计划。\r\n     *\r\n     * @param  \\Illuminate\\Console\\Scheduling\\Schedule  $schedule\r\n     * @return void\r\n     */\r\n    protected function schedule(Schedule $schedule)\r\n    {\r\n        $schedule->command('model:prune')->daily();\r\n    }\r\n\r\n在后台，`model:prune` 命令会自动检测应用程序的 `app/Models` 目录中的「Prunable」模型。 如果模型位于不同的位置，可以使用 `--model` 选项来指定模型类名称：\r\n\r\n    $schedule->command('model:prune', [\r\n        '--model' => [Address::class, Flight::class],\r\n    ])->daily();\r\n\r\n如果你想在修剪所有其他检测到的模型时排除某些模型被修剪，您可以使用 `--except` 选项：\r\n\r\n    $schedule->command('model:prune', [\r\n        '--except' => [Address::class, Flight::class],\r\n    ])->daily();\r\n\r\n你可以通过执行带有 `--pretend` 选项的 `model:prune` 命令来预测你的 `prunable` 查询。预测时，`model:prune` 命令将报告该命令实际运行将修剪多少记录：\r\n\r\n```shell\r\nphp artisan model:prune --pretend\r\n```\r\n\r\n> 注意：如果软删除模型与可修剪查询匹配，则它们将被永久删除（`forceDelete`）。\r\n\r\n\r\n\r\n<a name=\"mass-pruning\"></a>\r\n#### 批量修剪模型\r\n\r\n当模型被标记为 `Illuminate\\Database\\Eloquent\\MassPrunable` 特征时，模型会使用批量删除查询从数据库中删除。因此，不会调用 `pruning` 方法，也不会触发 `deleting` 和 `deleted` 模型事件。这是因为模型在删除之前从未真正检索过，因此更高效：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\MassPrunable;\r\n\r\n    class Flight extends Model\r\n    {\r\n        use MassPrunable;\r\n\r\n        /**\r\n         * 获取可修剪模型查询。\r\n         *\r\n         * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n         */\r\n        public function prunable()\r\n        {\r\n            return static::where('created_at', '<=', now()->subMonth());\r\n        }\r\n    }\r\n\r\n<a name=\"replicating-models\"></a>\r\n## 复制模型\r\n\r\n可以使用 `replicate` 方法创建现有模型实例的未保存副本。在拥有共享许多相同属性的模型实例时，此方法特别有用：\r\n\r\n    use App\\Models\\Address;\r\n\r\n    $shipping = Address::create([\r\n        'type' => 'shipping',\r\n        'line_1' => '123 Example Street',\r\n        'city' => 'Victorville',\r\n        'state' => 'CA',\r\n        'postcode' => '90001',\r\n    ]);\r\n\r\n    $billing = $shipping->replicate()->fill([\r\n        'type' => 'billing'\r\n    ]);\r\n\r\n    $billing->save();\r\n\r\n要排除一个或多个属性被复制到新模型，可以将数组传递给 `replicate` 方法：\r\n\r\n    $flight = Flight::create([\r\n        'destination' => 'LAX',\r\n        'origin' => 'LHR',\r\n        'last_flown' => '2020-03-04 11:00:00',\r\n        'last_pilot_id' => 747,\r\n    ]);\r\n\r\n    $flight = $flight->replicate([\r\n        'last_flown',\r\n        'last_pilot_id'\r\n    ]);\r\n\r\n<a name=\"query-scopes\"></a>\r\n## 查询作用域\r\n\r\n<a name=\"global-scopes\"></a>\r\n## 全局作用域\r\n\r\n全局范围可以为模型的所有查询添加约束。 Laravel 的 [软删除](#soft-deleting) 功能就是利用全局范围仅从数据库中检索「未删除」模型。编写全局范围查询可以为模型的每个查询都添加约束条件。\r\n\r\n\r\n\r\n<a name=\"writing-global-scopes\"></a>\r\n#### 编写全局作用域\r\n\r\n编写全局范围很简单。 首先，定义一个实现 `Illuminate\\Database\\Eloquent\\Scope` 接口的类。 Laravel 没有放置作用域类的常规位置，因此您可以自由地将此类放置在您希望的任何目录中。\r\n\r\n`Scope` 接口要求实现 `apply` 方法。 `apply` 方法可以根据需要向查询中添加 `where` 约束或其他类型的子句：\r\n\r\n    <?php\r\n\r\n    namespace App\\Scopes;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Scope;\r\n\r\n    class AncientScope implements Scope\r\n    {\r\n        /**\r\n         * 将作用域应用于给定的 Eloquent 查询构建器。\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Builder  $builder\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n         * @return void\r\n         */\r\n        public function apply(Builder $builder, Model $model)\r\n        {\r\n            $builder->where('created_at', '<', now()->subYears(2000));\r\n        }\r\n    }\r\n\r\n> 技巧：如果需要在 select 语句里添加字段，应使用 addSelect 方法，而不是 select 方法。这将有效防止无意中替换现有 select 语句的情况。\r\n\r\n<a name=\"applying-global-scopes\"></a>\r\n#### 应用全局作用域\r\n\r\n要将全局作用域分配给模型，需要重写模型的 `booted` 方法并使用 `addGlobalScope` 方法，`addGlobalScope` 方法接受作用域的一个实例作为它的唯一参数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Scopes\\AncientScope;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 模型的「引导」方法。\r\n         *\r\n         * @return void\r\n         */\r\n        protected static function booted()\r\n        {\r\n            static::addGlobalScope(new AncientScope);\r\n        }\r\n    }\r\n\r\n\r\n\r\n将上例中的作用域添加到 `App\\Models\\User` 模型后，调用 `User::all()` 方法将执行以下 SQL 查询：\r\n\r\n```sql\r\nselect * from `users` where `created_at` < 0021-02-18 00:00:00\r\n```\r\n\r\n<a name=\"anonymous-global-scopes\"></a>\r\n#### 匿名全局作用域\r\n\r\nEloquent 同样允许使用闭包定义全局作用域，这样就不需要为一个简单的作用域而编写一个单独的类。使用闭包定义全局作用域时，你应该指定一个作用域名称作为 `addGlobalScope` 方法的第一个参数： \r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 模型的「引导」方法。\r\n         *\r\n         * @return void\r\n         */\r\n        protected static function booted()\r\n        {\r\n            static::addGlobalScope('ancient', function (Builder $builder) {\r\n                $builder->where('created_at', '<', now()->subYears(2000));\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"removing-global-scopes\"></a>\r\n#### 取消全局作用域\r\n\r\n如果需要对当前查询取消全局作用域，需要使用 `withoutGlobalScope` 方法。该方法仅接受全局作用域类名作为它唯一的参数：\r\n\r\n    User::withoutGlobalScope(AncientScope::class)->get();\r\n\r\n或者，如果你使用闭包定义了全局作用域，则应传递分配给全局作用域的字符串名称：\r\n\r\n    User::withoutGlobalScope('ancient')->get();\r\n\r\n如果需要取消部分或者全部的全局作用域的话，需要使用`withoutGlobalScopes` 方法：\r\n\r\n    // 取消全部全局作用域...\r\n    User::withoutGlobalScopes()->get();\r\n\r\n    // 取消部分作用域...\r\n    User::withoutGlobalScopes([\r\n        FirstScope::class, SecondScope::class\r\n    ])->get();\r\n\r\n\r\n\r\n<a name=\"local-scopes\"></a>\r\n### 局部作用域\r\n\r\n局部作用域允许定义通用的约束集合以便在应用程序中重复使用。例如，你可能经常需要获取所有「流行」的用户。要定义这样一个范围，只需要在对应的 Eloquent 模型方法前添加 `scope` 前缀。\r\n\r\n作用域总是返回一个查询构造器实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 只查询受欢迎的用户的作用域。\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Builder  $query\r\n         * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n         */\r\n        public function scopePopular($query)\r\n        {\r\n            return $query->where('votes', '>', 100);\r\n        }\r\n\r\n        /**\r\n         * 只查询 active 用户的作用域。\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Builder  $query\r\n         * @return void\r\n         */\r\n        public function scopeActive($query)\r\n        {\r\n            $query->where('active', 1);\r\n        }\r\n    }\r\n\r\n<a name=\"utilizing-a-local-scope\"></a>\r\n#### 使用局部作用域\r\n\r\n一旦定义了作用域，就可以在查询该模型时调用作用域方法。不过，在调用这些方法时不必包含 `scope` 前缀。甚至可以链式调用多个作用域，例如：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::popular()->active()->orderBy('created_at')->get();\r\n\r\n通过 `or` 查询运算符组合多个 Eloquent 模型作用域可能需要使用闭包来实现正确的 [逻辑分组](/docs/laravel/9.x/queries#logical-grouping)：\r\n\r\n    $users = User::popular()->orWhere(function (Builder $query) {\r\n        $query->active();\r\n    })->get();\r\n\r\n然而这可能有点麻烦，所以 Laravel 提供了一个更高阶的 orWhere 方法，允许你流畅地将作用域链接在一起，而无需使用闭包：\r\n\r\n    $users = App\\Models\\User::popular()->orWhere->active()->get();\r\n\r\n\r\n\r\n<a name=\"dynamic-scopes\"></a>\r\n#### 动态作用域\r\n\r\n有时可能地希望定义一个可以接受参数的作用域。把额外参数传递给作用域就可以达到此目的。作用域参数要放在 `$query` 参数之后：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 将查询作用域限制为仅包含给定类型的用户。\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Builder  $query\r\n         * @param  mixed  $type\r\n         * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n         */\r\n        public function scopeOfType($query, $type)\r\n        {\r\n            return $query->where('type', $type);\r\n        }\r\n    }\r\n\r\n一旦将预期的参数添加到作用域方法的签名中，您就可以在调用作用域时传递参数：\r\n\r\n    $users = User::ofType('admin')->get();\r\n\r\n<a name=\"comparing-models\"></a>\r\n## 模型比较\r\n\r\n有时可能需要判断两个模型是否「相同」。`is` 和 `isNot` 方法可以用来快速校验两个模型是否拥有相同的主键、表和数据库连接：\r\n\r\n    if ($post->is($anotherPost)) {\r\n        //\r\n    }\r\n\r\n    if ($post->isNot($anotherPost)) {\r\n        //\r\n    }\r\n\r\n当使用 `belongsTo`、`hasOne`、`morphTo` 和 `morphOne` [relationships](/docs/laravel/9.x/eloquent-relationships) 时，`is` 和 `isNot` 方法也可用。当您想比较相关模型而不发出查询来检索该模型时，此方法特别有用：\r\n\r\n    if ($post->author()->is($user)) {\r\n        //\r\n    }\r\n\r\n<a name=\"events\"></a>\r\n## Events\r\n\r\n> 技巧：想要将 Eloquent 事件直接广播到客户端应用程序？ 查看 Laravel 的 [模型事件广播](/docs/laravel/9.x/broadcasting#model-broadcasting)。\r\n\r\nEloquent 模型触发几个事件，允许你挂接到模型生命周期的如下节点： `retrieved`、`creating`、`created`、`updating`、`updated`、`saving`、`saved`、`deleting`、`deleted`、`restoring`、`restored`、`replicating`。事件允许你每当特定模型保存或更新数据库时执行代码。每个事件通过其构造器接受模型实例。\r\n\r\n\r\n\r\n当从数据库中检索到现有模型时，将调度 `retrived` 事件。 当一个新模型第一次被保存时，`creating` 和 `created` 事件将被触发。 `updating` / `updated` 事件将在修改现有模型并调用 `save` 方法时触发。`saving` / `saved` 事件将在创建或更新模型时触发 - 即使模型的属性没有更改。以「-ing」结尾的事件名称在模型的任何更改被持久化之前被调度，而以「-ed」结尾的事件在对模型的更改被持久化之后被调度。\r\n\r\n要开始监听模型事件，请在 Eloquent 模型上定义一个 `$dispatchesEvents` 属性。此属性将 Eloquent 模型生命周期的各个点映射到你定义的 [事件类](/docs/laravel/9.x/events)。 每个模型事件类都应该期望通过其构造函数接收受影响模型的实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Events\\UserDeleted;\r\n    use App\\Events\\UserSaved;\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * 模型的事件映射。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $dispatchesEvents = [\r\n            'saved' => UserSaved::class,\r\n            'deleted' => UserDeleted::class,\r\n        ];\r\n    }\r\n\r\n在定义和映射了 Eloquent 事件之后，可以使用 [event listeners](/docs/laravel/9.x/events#defining-listeners) 来处理事件。\r\n\r\n> 注意：通过 Eloquent 发出批量更新或删除查询时，不会为受影响的模型调度 `saved`、`updated`、`deleting` 和 `deleted` 模型事件。 这是因为在执行批量更新或删除时，模型从未真正被检索到。\r\n\r\n\r\n\r\n<a name=\"events-using-closures\"></a>\r\n### 使用闭包\r\n\r\n你可以注册在触发各种模型事件时执行的闭包，而不使用自定义事件类。通常，你应该在模型的 booted 方法中注册这些闭包：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 模型的“引导”方法。\r\n         *\r\n         * @return void\r\n         */\r\n        protected static function booted()\r\n        {\r\n            static::created(function ($user) {\r\n                //\r\n            });\r\n        }\r\n    }\r\n\r\n如果需要，你可以在注册模型事件时使用 [队列匿名事件侦听器](/docs/laravel/9.x/events#queuable-anonymous-event-listeners)。这将指示 Laravel 使用应用程序的 [queue](/docs/laravel/9.x/queues) 在后台执行模型事件监听器：\r\n\r\n    use function Illuminate\\Events\\queueable;\r\n\r\n    static::created(queueable(function ($user) {\r\n        //\r\n    }));\r\n\r\n<a name=\"observers\"></a>\r\n### 观察者\r\n\r\n<a name=\"defining-observers\"></a>\r\n#### 定义观察者\r\n\r\n如果在一个模型上监听了多个事件，可以使用观察者来将这些监听器组织到一个单独的类中。观察者类的方法名映射到你希望监听的 Eloquent 事件。这些方法都以模型作为其唯一参数。`make:observer` Artisan 命令可以快速建立新的观察者类：\r\n\r\n```shell\r\nphp artisan make:observer UserObserver --model=User\r\n```\r\n\r\n此命令将在 `App/Observers` 文件夹放置新的观察者类。如果这个目录不存在，Artisan 将替你创建。使用如下方式开启观察者：\r\n\r\n    <?php\r\n\r\n    namespace App\\Observers;\r\n\r\n    use App\\Models\\User;\r\n\r\n    class UserObserver\r\n    {\r\n        /**\r\n         * 处理用户「创建」事件。\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @return void\r\n         */\r\n        public function created(User $user)\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 处理用户「更新」事件。\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @return void\r\n         */\r\n        public function updated(User $user)\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 处理用户「删除」事件。\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @return void\r\n         */\r\n        public function deleted(User $user)\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 处理用户「强制删除」事件。\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @return void\r\n         */\r\n        public function forceDeleted(User $user)\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n\r\n\r\n要注册观察者，需要在要观察的模型上调用「Observer」方法。你可以在应用程序的 `boot` 方法中注册观察者\r\n\r\n`App\\Providers\\EventServiceProvider` 服务提供者:\r\n\r\n    use App\\Models\\User;\r\n    use App\\Observers\\UserObserver;\r\n\r\n    /**\r\n     * 为你的应用程序注册任何事件。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        User::observe(UserObserver::class);\r\n    }\r\n\r\n或者，可以在应用程序的「$observers」属性中列出你的观察者\r\n\r\n`App\\Providers\\EventServiceProvider` class:\r\n\r\n    use App\\Models\\User;\r\n    use App\\Observers\\UserObserver;\r\n\r\n    /**\r\n     * 应用程序的模型观察者。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $observers = [\r\n        User::class => [UserObserver::class],\r\n    ];\r\n\r\n> 技巧：观察者可以监听其他事件，例如「saving」和「retrieved」。这些事件在 [events](#events) 文档中进行了描述。\r\n\r\n<a name=\"observers-and-database-transactions\"></a>\r\n#### 观察者和数据库事务\r\n\r\n在数据库事务中创建模型时，你可能希望指示观察者仅在提交数据库事务后执行其事件处理程序。可以通过在观察者上定义一个 `$afterCommit` 属性来完成此操作。如果数据库事务不在进行中，事件处理程序将立即执行：\r\n\r\n    <?php\r\n\r\n    namespace App\\Observers;\r\n\r\n    use App\\Models\\User;\r\n\r\n    class UserObserver\r\n    {\r\n        /**\r\n         * 在提交所有事务后处理事件。\r\n         *\r\n         * @var bool\r\n         */\r\n        public $afterCommit = true;\r\n\r\n        /**\r\n         * 处理用户「创建」事件。\r\n         *\r\n         * @param  \\App\\Models\\User  $user\r\n         * @return void\r\n         */\r\n        public function created(User $user)\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n<a name=\"muting-events\"></a>\r\n### 静默事件\r\n\r\n也许有时候你会需要暂时将所有由模型触发的事件「静默」处理。使用 `withoutEvents` 达到目的。`withoutEvents` 方法接受一个闭包作为唯一参数。任何在闭包中执行的代码都不会被分配模型事件。\r\n举个例子，如下代码将获取并删除一个 `App\\Models\\User` 实例且不会发送任何的模型事件。闭包函数返回的任何值都将被 `withoutEvents` 方法所返回：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::withoutEvents(function () use () {\r\n        User::findOrFail(1)->delete();\r\n\r\n        return User::find(2);\r\n    });\r\n\r\n<a name=\"saving-a-single-model-without-events\"></a>\r\n#### 静默的保存单个模型\r\n\r\n有时候，你也许会想要「保存」一个已有的模型，且不触发任何事件。那么你可用 `saveQuietly` 方法达到目的：\r\n\r\n    $user = User::findOrFail(1);\r\n\r\n    $user->name = 'Victoria Faith';\r\n\r\n    $user->saveQuietly();\r\n\r\n","p":"docs/eloquent.html"},{"t":"eloquent-relationships (Eloquent: 关联)","d":"# Eloquent: 关联\r\n\r\n- [简介](#introduction)\r\n- [定义关联](#defining-relationships)\r\n    - [一对一](#one-to-one)\r\n    - [一对多](#one-to-many)\r\n    - [一对多 (反向) / 属于](#one-to-many-inverse)\r\n    - [一对多检索](#has-one-of-many)\r\n    - [远程一对一](#has-one-through)\r\n    - [远程一对多](#has-many-through)\r\n- [多对多关联](#many-to-many)\r\n    - [获取中间表字段](#retrieving-intermediate-table-columns)\r\n    - [通过中间表字段过滤查询](#filtering-queries-via-intermediate-table-columns)\r\n    - [自定义中间表模型](#defining-custom-intermediate-table-models)\r\n- [多态管理](#polymorphic-relationships)\r\n    - [一对一](#one-to-one-polymorphic-relations)\r\n    - [一对多](#one-to-many-polymorphic-relations)\r\n    - [一对多检索](#one-of-many-polymorphic-relations)\r\n    - [多对多](#many-to-many-polymorphic-relations)\r\n    - [自定义多态模型](#custom-polymorphic-types)\r\n- [动态关联](#dynamic-relationships)\r\n- [查询关联](#querying-relations)\r\n    - [关联方法与动态属性](#relationship-methods-vs-dynamic-properties)\r\n    - [基于存在的关联查询](#querying-relationship-existence)\r\n    - [基于不存在的关联查询](#querying-relationship-absence)\r\n    - [基于多态的关联查询](#querying-morph-to-relationships)\r\n- [统计关联模型](#aggregating-related-models)\r\n    - [关联模型计数](#counting-related-models)\r\n    - [其他统计函数](#other-aggregate-functions)\r\n    - [多态关联数据计数](#counting-related-models-on-morph-to-relationships)\r\n- [预加载](#eager-loading)\r\n    - [约束预加载](#constraining-eager-loads)\r\n    - [延迟预加载](#lazy-eager-loading)\r\n    - [阻止延迟加载](#preventing-lazy-loading)\r\n- [插入及更新关联模型](#inserting-and-updating-related-models)\r\n    - [`save` 方法](#the-save-method)\r\n    - [`create` 方法](#the-create-method)\r\n    - [属于关联](#updating-belongs-to-relationships)\r\n    - [多对多关联](#updating-many-to-many-relationships)\r\n- [更新父级时间戳](#touching-parent-timestamps)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n数据库表通常相互关联。例如，一篇博客文章可能有许多评论，或者一个订单对应一个下单用户。Eloquent 让这些关联的管理和使用变得简单，并支持多种常用的关联类型：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [一对一](#one-to-one)\r\n- [一对多](#one-to-many)\r\n- [多对多](#many-to-many)\r\n- [远程一对一](#has-one-through)\r\n- [远程一对多](#has-many-through)\r\n- [多态一对一](#one-to-one-polymorphic-relations)\r\n- [多态一对多](#one-to-many-polymorphic-relations)\r\n- [多态多对多](#many-to-many-polymorphic-relations)\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"defining-relationships\"></a>\r\n## 定义关联\r\n\r\nEloquent 关联在 Eloquent 模型类中以方法的形式呈现。如同 Eloquent 模型本身，关联也可以作为强大的 [查询语句构造器](/docs/laravel/9.x/queries)，使用，提供了强大的链式调用和查询功能。例如，我们可以在 `posts` 关联的链式调用中附加一个约束条件：\r\n\r\n    $user->posts()->where('active', 1)->get();\r\n\r\n不过在深入使用关联之前，让我们先学习如何定义每种关联类型。\r\n\r\n<a name=\"one-to-one\"></a>\r\n### 一对一\r\n\r\n一对一是最基本的数据库关系。 例如，一个 `User` 模型可能与一个 `Phone` 模型相关联。为了定义这个关联关系，我们要在 `User` 模型中写一个 `phone` 方法， 在 `phone` 方法中调用 `hasOne` 方法并返回其结果。`hasOne` 方法被定义在 `Illuminate\\Database\\Eloquent\\Model` 这个模型基类中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 获取与用户相关的电话记录\r\n         */\r\n        public function phone()\r\n        {\r\n            return $this->hasOne(Phone::class);\r\n        }\r\n    }\r\n\r\n`hasOne` 方法的第一个参数是关联模型的类名。一旦定义了模型关联，我们就可以使用 Eloquent 的动态属性获得相关的记录。动态属性允许你访问该关联方法，就像访问模型中定义的属性一样：\r\n\r\n    $phone = User::find(1)->phone;\r\n\r\nEloquent 基于父模型（`User`）的名称来确定关联模型（`Phone`）的外键名称。在本例中，会自动假定 `Phone` 模型有一个 `user_id` 的外键。如果你想重写这个约定，可以传递第二个参数给 `hasOne` 方法：\r\n\r\n    return $this->hasOne(Phone::class, 'foreign_key');\r\n\r\n\r\n\r\n另外，Eloquent 假设外键的值是与父模型的主键（Primary Key）相同的。换句话说，Eloquent 将会通过 `Phone` 记录的 `user_id` 列中查找与用户表的 `id` 列相匹配的值。如果你希望使用自定义的主键值，而不是使用 `id` 或者模型中的 `$primaryKey` 属性，你可以给 `hasOne` 方法传递第三个参数：\r\n\r\n    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');\r\n\r\n<a name=\"one-to-one-defining-the-inverse-of-the-relationship\"></a>\r\n#### 定义反向关联\r\n\r\n我们已经能从 `User` 模型访问到 `Phone` 模型了。接下来，让我们再在 `Phone` 模型上定义一个关联，它能让我们访问到拥有该电话的用户。我们可以使用 `belongsTo` 方法来定义反向关联， `belongsTo` 方法与 `hasOne` 方法相对应：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Phone extends Model\r\n    {\r\n        /**\r\n         * 获取拥有此电话的用户\r\n         */\r\n        public function user()\r\n        {\r\n            return $this->belongsTo(User::class);\r\n        }\r\n    }\r\n\r\n在调用 `user` 方法时，Eloquent 会尝试查找一个 `User` 模型，该 `User` 模型上的 `id` 字段会与 `Phone` 模型上的 `user_id` 字段相匹配。\r\n\r\nEloquent 通过关联方法（`user`）的名称并使用 `_id` 作为后缀名来确定外键名称。因此，在本例中，Eloquent 会假设 `Phone` 模型有一个 `user_id` 字段。但是，如果 `Phone` 模型的外键不是 `user_id`，这时你可以给 `belongsTo` 方法的第二个参数传递一个自定义键名：\r\n\r\n    /**\r\n     * 获取拥有此电话的用户\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class, 'foreign_key');\r\n    }\r\n\r\n\r\n\r\n如果父模型的主键未使用 `id` 作为字段名，或者您想要使用其他的字段来匹配相关联的模型，那么您可以向 `belongsTo` 方法传递第三个参数，这个参数是在父模型中自己定义的字段名称：\r\n\r\n    /**\r\n     * 获取当前手机号的用户\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');\r\n    }\r\n\r\n<a name=\"one-to-many\"></a>\r\n### 一对多\r\n\r\n当要定义一个模型是其他 （一个或者多个）模型的父模型这种关系时，可以使用一对多关联。例如，一篇博客可以有很多条评论。和其他模型关联一样，一对多关联也是在 Eloquent 模型文件中用一个方法来定义的：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Post extends Model\r\n    {\r\n        /**\r\n         * 获取这篇博客的所有评论\r\n         */\r\n        public function comments()\r\n        {\r\n            return $this->hasMany(Comment::class);\r\n        }\r\n    }\r\n\r\n注意，Eloquent 将会自动为 `Comment` 模型选择一个合适的外键。通常，这个外键是通过使用父模型的「蛇形命名」方式，然后再加上 `_id`. 的方式来命名的。因此，在上面这个例子中，Eloquent 将会默认 `Comment` 模型的外键是 `post_id` 字段。\r\n\r\n如果关联方法被定义，那么我们就可以通过 `comments` 属性来访问相关的评论 [集合](/docs/laravel/9.x/eloquent-collections)。注意，由于 Eloquent 提供了「动态属性」，所以我们就可以像访问模型属性一样来访问关联方法：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $comments = Post::find(1)->comments;\r\n\r\n    foreach ($comments as $comment) {\r\n        //\r\n    }\r\n\r\n\r\n\r\n由于所有的关系都可以看成是查询构造器，所以您也可以通过链式调用的方式，在 `comments` 方法中继续添加条件约束：\r\n\r\n    $comment = Post::find(1)->comments()\r\n                        ->where('title', 'foo')\r\n                        ->first();\r\n\r\n像 `hasOne` 方法一样，`hasMany` 方法中也可以接受额外的参数，从而来覆盖外键和本地键：\r\n\r\n    return $this->hasMany(Comment::class, 'foreign_key');\r\n\r\n    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');\r\n\r\n<a name=\"one-to-many-inverse\"></a>\r\n### 一对多 (反向) / 属于\r\n\r\n目前我们可以访问一篇文章的所有评论，下面我们可以定义一个关联关系，从而让我们可以通过一条评论来获取到它所属的文章。这个关联关系是 `hasMany` 的反向，可以在子模型中通过 `belongsTo` 方法来定义这种关联关系：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Comment extends Model\r\n    {\r\n        /**\r\n         * 获取这条评论所属的文章。\r\n         */\r\n        public function post()\r\n        {\r\n            return $this->belongsTo(Post::class);\r\n        }\r\n    }\r\n\r\n如果定义了这种关联关系，那么我们就可以通过 `Comment` 模型中的 `post` 「动态属性」来获取到这条评论所属的文章：\r\n\r\n    use App\\Models\\Comment;\r\n\r\n    $comment = Comment::find(1);\r\n\r\n    return $comment->post->title;\r\n\r\n在上面这个例子中，Eloquent 将会尝试寻找 `Post` 模型中的 `id` 字段与 `Comment` 模型中的 `post_id` 字段相匹配。\r\n\r\nEloquent 通过检查关联方法的名称，从而在关联方法名称后面加上 `_` ，然后再加上父模型 （Post）的主键名称，以此来作为默认的外键名。因此，在上面这个例子中，Eloquent 将会默认 `Post` 模型在 `comments` 表中的外键是 `post_id`。\r\n\r\n\r\n\r\n但是，如果您的外键不遵循这种约定的话，那么您可以传递一个自定义的外键名来作为 `belongsTo` 方法的第二个参数：\r\n\r\n    /**\r\n     * 获取这条评论所属的博客。\r\n     */\r\n    public function post()\r\n    {\r\n        return $this->belongsTo(Post::class, 'foreign_key');\r\n    }\r\n\r\n如果你的主表（Post 表）不使用 id 来作为它的主键的话，或者你想通过其他列来关联相关模型的话，那么可以传递一个参数来作为 belongsTo 方法的第三个参数，这个参数是主表（Post 表）中想要作为关联关系的字段的名称。\r\n\r\n    /**\r\n     * 获取这条评论所属的博客。\r\n     */\r\n    public function post()\r\n    {\r\n        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');\r\n    }\r\n\r\n<a name=\"default-models\"></a>\r\n#### 默认模型\r\n\r\n当 `belongsTo`，`hasOne`，`hasOneThrough` 和 `morphOne` 这些关联方法返回为 `null` 的时候，你可以定义一个默认的模型来返回。这种模式通常被称为 `空对象模式`，它可以帮你省略代码中的一些条件判断。在下面这个例子中，如果 Post 模型中没有用户，那么 user 关联关系将会返回一个空的 App\\Models\\User 模型：\r\n\r\n    /**\r\n     * 获取这篇博客所属的用户。\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class)->withDefault();\r\n    }\r\n\r\n如果想要这个默认模型中包含一些属性的话，可以向 `withDefault` 方法中传递一个数组或者一个闭包：\r\n\r\n    /**\r\n     * 获取博客的作者。\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class)->withDefault([\r\n            'name' => 'Guest Author',\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * 获取作者发布的博客。\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class)->withDefault(function ($user, $post) {\r\n            $user->name = 'Guest Author';\r\n        });\r\n    }\r\n\r\n\r\n\r\n<a name=\"querying-belongs-to-relationships\"></a>\r\n#### 查询所属关系\r\n\r\n在查询「所属」的子关系时，可以构建 `where` 语句来检索相应的 Eloquent 模型：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::where('user_id', $user->id)->get();\r\n\r\n但使用 `whereBelongsTo` 方法更方便，它会自动确定模型的正确关系和外键：\r\n\r\n    $posts = Post::whereBelongsTo($user)->get();\r\n\r\n默认情况下，Laravel 将根据模型的类名确定与给定模型关联的关系； 你也可以通过将关系名称作为 `whereBelongsTo` 方法的第二个参数来手动指定关系名称：\r\n\r\n    $posts = Post::whereBelongsTo($user, 'author')->get();\r\n\r\n<a name=\"has-one-of-many\"></a>\r\n### 一对多检索\r\n\r\n有时一个模型可能有许多相关模型，如果想检索关系的「最新」或「最旧」相关模型。例如，一个 `User` 模型可能与许多 `Order` 模型相关，但您想定义一种方便的方式来与用户最近下的订单进行交互。 可以使用 `hasOne` 关系类型结合 `ofMany` 方法来完成此操作：\r\n\r\n```php\r\n/**\r\n * 获取用户最新的订单。\r\n */\r\npublic function latestOrder()\r\n{\r\n    return $this->hasOne(Order::class)->latestOfMany();\r\n}\r\n```\r\n\r\n同样，你也可以定义一个方法来检索模型关系最早的或第一个相关模型：\r\n\r\n```php\r\n/**\r\n * 获取用户最早的订单。\r\n */\r\npublic function oldestOrder()\r\n{\r\n    return $this->hasOne(Order::class)->oldestOfMany();\r\n}\r\n```\r\n\r\n`latestOfMany` 和 `oldestOfMany` 默认根据模型的主键检索最新或最旧的相关记录，所以模型主键必须是 **可排序** 的。 但是，有时你可能希望使用不同的排序条件从更大的关系中检索单个模型。\r\n\r\n\r\n\r\n例如，使用 `ofMany` 方法，可以检索用户最昂贵的订单。`ofMany` 方法接受可排序列作为其第一个参数，以及在查询相关模型时应用哪个聚合函数（`min` 或 `max`）：\r\n\r\n```php\r\n/**\r\n * 获取用户最昂贵的订单。\r\n */\r\npublic function largestOrder()\r\n{\r\n    return $this->hasOne(Order::class)->ofMany('price', 'max');\r\n}\r\n```\r\n\r\n> 注意：因为 PostgreSQL 不支持对 UUID 列执行 `MAX` 函数，所以目前不可能将多选之一关系与 PostgreSQL UUID 列结合使用。\r\n\r\n<a name=\"advanced-has-one-of-many-relationships\"></a>\r\n#### 进阶一对多检索\r\n\r\n例如，一个「产品」模型可能有许多关联的「价格」模型，即使在新定价发布后，这些模型也会保留在系统中。此外，产品的新定价数据可能能够通过「published_at」列提前发布，以便在未来日期生效。\r\n\r\n因此我们需要检索最新发布的定价，并且发布日期不能超过当前时间。 如果两个价格的发布日期相同，我们优先选择 ID 更大的价格。 为此，我们必须将一个数组传递给 `ofMany` 方法，其中包含确定最新价格的可排序列。为`ofMany` 方法的第二个参数传递一个闭包。 此闭包将负责为关系查询添加额外的发布日期约束：\r\n\r\n```php\r\n/**\r\n * 获取产品的当前定价。\r\n */\r\npublic function currentPricing()\r\n{\r\n    return $this->hasOne(Price::class)->ofMany([\r\n        'published_at' => 'max',\r\n        'id' => 'max',\r\n    ], function ($query) {\r\n        $query->where('published_at', '<', now());\r\n    });\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"has-one-through\"></a>\r\n### 远程一对一\r\n\r\n「has-one-through」关联定义了一个模型和另外一个模型之间一对一的关系。同时，这种关联关系是需要第三个模型作为中间模型来实现的。\r\n\r\n例如，在一个汽车维修的应用程序中，每一个 `Mechanic` 模型都与一个 `Car` 模型相关联，同时，每一个 `Car` 模型也和一个 `Owner` 模型相关联。虽然 `mechani` 和 `owner` 在数据库中并没有直接的关系，但是 `mechani` 可以通过 `Car` 模型来访问 `owner`。下面是定义这种关联关系所需要的数据表：\r\n\r\n    mechanics\r\n        id - integer\r\n        name - string\r\n\r\n    cars\r\n        id - integer\r\n        model - string\r\n        mechanic_id - integer\r\n\r\n    owners\r\n        id - integer\r\n        name - string\r\n        car_id - integer\r\n\r\n既然我们已经了解了远程一对一的表结构，那么我们就可以在 `Mechanic` 模型中定义这种关系：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Mechanic extends Model\r\n    {\r\n        /**\r\n         * 获取汽车的主人。\r\n         */\r\n        public function carOwner()\r\n        {\r\n            return $this->hasOneThrough(Owner::class, Car::class);\r\n        }\r\n    }\r\n\r\n传递给「hasOneThrough」方法的第一个参数是我们希望访问的最终模型的名称，而第二个参数是中间模型的名称。\r\n\r\n<a name=\"has-one-through-key-conventions\"></a>\r\n#### 键名约定\r\n\r\n当使用远程一对一进行关联查询时，Eloquent 将会使用约定的外键名。如果你想要自定义相关联的键名的话，可以传递两个参数来作为「hasOneThrough」 方法的第三个和第四个参数。第三个参数是中间表的外键名。第四个参数是最终想要访问的模型的外键名。第五个参数是当前模型的本地键名，第六个参数是中间模型的本地键名：\r\n\r\n    class Mechanic extends Model\r\n    {\r\n        /**\r\n         * Get the car's owner.\r\n         */\r\n        public function carOwner()\r\n        {\r\n            return $this->hasOneThrough(\r\n                Owner::class,\r\n                Car::class,\r\n                'mechanic_id', // 机械师表的外键...\r\n                'car_id', // 车主表的外键...\r\n                'id', // 机械师表的本地键...\r\n                'id' // 汽车表的本地键...\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"has-many-through\"></a>\r\n### 远程一对多\r\n\r\n「has-many-through」关联是可以通过中间关系来实现远程一对多的。例如，我们正在构建一个像 [Laravel Vapor](https://vapor.laravel.com) 这样的部署平台。一个 `Project` 模型可以通过一个中间的 `Environment` 模型来访问许多个 `Deployment` 模型。就像上面的这个例子，您可以在给定的 environment 中很方便的获取所有的 deployments。下面是定义这种关联关系所需要的数据表：\r\n\r\n    projects\r\n        id - integer\r\n        name - string\r\n\r\n    environments\r\n        id - integer\r\n        project_id - integer\r\n        name - string\r\n\r\n    deployments\r\n        id - integer\r\n        environment_id - integer\r\n        commit_hash - string\r\n\r\n既然我们已经了解了远程一对多关联的表结构，那么就可以在 `Project` 模型中来定义这种关联关系：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Project extends Model\r\n    {\r\n        /**\r\n         * 获取项目的所有部署。\r\n         */\r\n        public function deployments()\r\n        {\r\n            return $this->hasManyThrough(Deployment::class, Environment::class);\r\n        }\r\n    }\r\n\r\n`hasManyThrough` 方法的第一个参数是我们最终想要访问的模型的名称，第二个参数是中间模型的名称。\r\n\r\n虽然 `Deployment`  模型中没有 `project_id` 字段，但是在 `hasManyThrough` 中可以通过 `$project->deployments`来访问一个 project 的 deployments。如果想要查询上面的模型，Eloquent 将会检查在中间模型（Environment）中是否存在 `project_id` 字段。在找到相关的  `Environment` 的 id 后，就可以查询 `Deployment` 模型的内容了。\r\n\r\n<a name=\"has-many-through-key-conventions\"></a>\r\n#### 约定的键名\r\n\r\n当使用远程一对多进行查询的时候，Eloquent 将会使用约定的外键名。如果您想要自定义相关联的键名的话，那么您可以传递两个参数来分别作为 `hasManyThrough` 方法的第三个和第四个参数。第三个参数是中间表的外键名。第四个参数是最终想要访问的模型的外键名。第五个参数是当前模型的本地键名，第六个参数是中间模型的本地键名：\r\n\r\n    class Project extends Model\r\n    {\r\n        public function deployments()\r\n        {\r\n            return $this->hasManyThrough(\r\n                Deployment::class,\r\n                Environment::class,\r\n                'project_id', // environments 表的外键名\r\n                'environment_id', // deployments 表的外键名\r\n                'id', // projects 表的本地键名\r\n                'id' // environments 表的本地键名\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"many-to-many\"></a>\r\n## 多对多关联\r\n\r\n多对多关联比 `hasOne` 和 `hasMany` 关联稍微复杂些。举个例子，一个用户可以拥有多个角色，同时这些角色也可以分配给其他用户。例如，一个用户可是「作者」和「编辑」；当然，这些角色也可以分配给其他用户。所以，一个用户可以拥有多个角色，一个角色可以分配给多个用户。\r\n\r\n<a name=\"many-to-many-table-structure\"></a>\r\n#### 表结构\r\n\r\n要定义这种关联，需要三个数据库表: `users`, `roles` 和 `role_user`。`role_user` 表的命名是由关联的两个模型按照字母顺序来的，并且包含了 `user_id` 和 `role_id` 字段。该表用作链接 `users` 和 `roles` 的中间表\r\n\r\n特别提醒，由于角色可以属于多个用户，因此我们不能简单地在 `roles` 表上放置 `user_id` 列。如果这样，这意味着角色只能属于一个用户。为了支持将角色分配给多个用户，需要使用 `role_user` 表。我们可以这样定义表结构： \r\n\r\n    users\r\n        id - integer\r\n        name - string\r\n\r\n    roles\r\n        id - integer\r\n        name - string\r\n\r\n    role_user\r\n        user_id - integer\r\n        role_id - integer\r\n\r\n<a name=\"many-to-many-model-structure\"></a>\r\n#### 模型结构\r\n\r\n多对多关联是通过调用 `belongsToMany` 方法结果的方法来定义的。 `belongsToMany` 方法由 `Illuminate\\Database\\Eloquent\\Model` 基类提供，所有应用程序的 Eloquent 模型都使用该基类。 例如，让我们在 `User` 模型上定义一个 `roles` 方法。 传递给此方法的第一个参数是相关模型类的名称：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 用户所拥有的角色\r\n         */\r\n        public function roles()\r\n        {\r\n            return $this->belongsToMany(Role::class);\r\n        }\r\n    }\r\n\r\n\r\n\r\n定义关系后，可以使用 `roles` 动态关系属性访问用户的角色：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    foreach ($user->roles as $role) {\r\n        //\r\n    }\r\n\r\n由于所有的关系也可以作为查询构建器，你可以通过调用 `roles()` 方法查询来为关系添加约束：\r\n\r\n    $roles = User::find(1)->roles()->orderBy('name')->get();\r\n\r\n为了确定关系的中间表的表名，Eloquent 会按字母顺序连接两个相关的模型名。 你也可以随意覆盖此约定。 通过将第二个参数传递给 `belongsToMany` 方法来做到这一点：\r\n\r\n    return $this->belongsToMany(Role::class, 'role_user');\r\n\r\n除了自定义连接表的表名，你还可以通过传递额外的参数到 `belongsToMany` 方法来定义该表中字段的键名。第三个参数是定义此关联的模型在连接表里的外键名，第四个参数是另一个模型在连接表里的外键名:\r\n\r\n    return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');\r\n\r\n<a name=\"many-to-many-defining-the-inverse-of-the-relationship\"></a>\r\n#### 定义反向关联\r\n\r\n要定义多对多的反向关联，只需要在关联模型中调用 `belongsToMany` 方法。我们在 `Role` 模型中定义 `users` 方法:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Role extends Model\r\n    {\r\n        /**\r\n         * 拥有此角色的用户\r\n         */\r\n        public function users()\r\n        {\r\n            return $this->belongsToMany(User::class);\r\n        }\r\n    }\r\n\r\n\r\n\r\n如你所见，除了引用 `App\\Models\\User` 模型之外，该关系的定义与其对应的 `User` 模型完全相同。 由于我们复用了 `belongsToMany` 方法，所以在定义多对多关系的「反向」关系时，所有常用的表和键自定义选项都可用。\r\n\r\n<a name=\"retrieving-intermediate-table-columns\"></a>\r\n### 获取中间表字段\r\n\r\n如上所述，处理多对多关系需要一个中间表。 Eloquent 提供了一些非常有用的方式来与它进行交互。 假设我们的 `User` 对象关联了多个 `Role` 对象。在获得这些关联对象后，可以使用模型的 `pivot` 属性访问中间表的属性：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    foreach ($user->roles as $role) {\r\n        echo $role->pivot->created_at;\r\n    }\r\n\r\n需要注意的是，我们获取的每个 `Role` 模型对象，都会被自动赋予 `pivot` 属性，它代表中间表的一个模型对象，并且可以像其他的 Eloquent 模型一样使用。\r\n\r\n默认情况下，`pivot` 对象只包含两个关联模型的主键，如果你的中间表里还有其他额外字段，你必须在定义关联时明确指出：\r\n\r\n    return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');\r\n\r\n如果你想让中间表自动维护 `created_at` 和 `updated_at` 时间戳，那么在定义关联时附加上 `withTimestamps` 方法即可：\r\n\r\n    return $this->belongsToMany(Role::class)->withTimestamps();\r\n\r\n> 注意：使用 Eloquent 自动维护时间戳的中间表需要同时具有 created_at 和 updated_at 时间戳字段。\r\n\r\n\r\n\r\n<a name=\"customizing-the-pivot-attribute-name\"></a>\r\n#### 自定义 pivot 属性名称\r\n\r\n如前所述，可以通过 `pivot` 属性在模型上访问中间表中的属性。 但是，你可以随意自定义此属性的名称，以更好地反映其在应用程序中的用途。\r\n\r\n例如，如果你的应用程序包含可能订阅播客的用户，则用户和播客之间可能存在多对多关系。 如果是这种情况，你可能希望将中间表属性重命名为 `subscription` 而不是 `pivot`。 这可以在定义关系时使用 `as` 方法来完成： \r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscription')\r\n                    ->withTimestamps();\r\n\r\n一旦定义完成，你可以使用自定义名称访问中间表数据： \r\n\r\n    $users = User::with('podcasts')->get();\r\n\r\n    foreach ($users->flatMap->podcasts as $podcast) {\r\n        echo $podcast->subscription->created_at;\r\n    }\r\n\r\n<a name=\"filtering-queries-via-intermediate-table-columns\"></a>\r\n### 通过中间表过滤查询\r\n\r\n你还可以在定义关系时使用 `wherePivot`、`wherePivotIn`、`wherePivotNotIn`、`wherePivotBetween`、`wherePivotNotBetween`、`wherePivotNull` 和 `wherePivotNotNull` 方法过滤 `belongsToMany` 关系查询返回的结果：\r\n\r\n    return $this->belongsToMany(Role::class)\r\n                    ->wherePivot('approved', 1);\r\n\r\n    return $this->belongsToMany(Role::class)\r\n                    ->wherePivotIn('priority', [1, 2]);\r\n\r\n    return $this->belongsToMany(Role::class)\r\n                    ->wherePivotNotIn('priority', [1, 2]);\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscriptions')\r\n                    ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscriptions')\r\n                    ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscriptions')\r\n                    ->wherePivotNull('expired_at');\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscriptions')\r\n                    ->wherePivotNotNull('expired_at');\r\n\r\n\r\n\r\n<a name=\"defining-custom-intermediate-table-models\"></a>\r\n### 自定义中间表模型\r\n\r\n如果你想定义一个自定义模型来表示多对多关系的中间表，你可以在定义关系时调用 `using` 方法。\r\n\r\n自定义多对多中间表模型都必须继承 `Illuminate\\Database\\Eloquent\\Relations\\Pivot` 类，自定义多对多（多态）中间表模型必须继承 `Illuminate\\Database\\Eloquent\\Relations\\MorphPivot` 类。例如，我们在写 `Role` 模型的关联时，使用自定义中间表模型 `RoleUser`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Role extends Model\r\n    {\r\n        /**\r\n         * 属于该角色的用户。\r\n         */\r\n        public function users()\r\n        {\r\n            return $this->belongsToMany(User::class)->using(RoleUser::class);\r\n        }\r\n    }\r\n当定义 `RoleUser` 模型时，我们要继承 `Illuminate\\Database\\Eloquent\\Relations\\Pivot` 类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\Pivot;\r\n\r\n    class RoleUser extends Pivot\r\n    {\r\n        //\r\n    }\r\n\r\n> 注意：Pivot 模型不可以使用 `SoftDeletes` trait。 如果需要软删除数据关联记录，请考虑将数据关联模型转换为实际的 Eloquent 模型。\r\n\r\n<a name=\"custom-pivot-models-and-incrementing-ids\"></a>\r\n#### 自定义中继模型和递增 ID\r\n\r\n如果你用一个自定义的中继模型定义了多对多的关系，而且这个中继模型拥有一个自增的主键，你应当确保这个自定义中继模型类中定义了一个 `incrementing` 属性且其值为 `true`。\r\n\r\n    /**\r\n     * 标识 ID 是否自增\r\n     *\r\n     * @var bool\r\n     */\r\n    public $incrementing = true;\r\n\r\n<a name=\"polymorphic-relationships\"></a>\r\n## 多态关系\r\n\r\n多态关联允许目标模型借助单个关联从属于多个模型。例如，你正在构建一个允许用户共享博客文章和视频的应用程序，其中 `Comment` 模型可能同时从属于 `Post` 和 `Video` 模型。\r\n\r\n\r\n\r\n<a name=\"one-to-one-polymorphic-relations\"></a>\r\n### 一对一 (多态)\r\n\r\n<a name=\"one-to-one-polymorphic-table-structure\"></a>\r\n#### 表结构\r\n\r\n一对一多态关联与简单的一对一关联类似，不过，目标模型能够在一个关联上从属于多个模型。例如，博客 `Post` 和 `User` 可能共享一个关联到 `Image` 模型的关系。使用一对一多态关联允许使用一个唯一图片列表同时用于博客文章和用户账户。让我们先看看表结构：\r\n\r\n    posts\r\n        id - integer\r\n        name - string\r\n\r\n    users\r\n        id - integer\r\n        name - string\r\n\r\n    images\r\n        id - integer\r\n        url - string\r\n        imageable_id - integer\r\n        imageable_type - string\r\n\r\n要特别留意 `images` 表的 `imageable_id` 和 `imageable_type` 列。 `imageable_id` 列包含文章或用户的 ID 值，而 `imageable_type` 列包含的则是父模型的类名。Eloquent 在访问 `imageable` 时使用 `imageable_type` 列来判断父模型的「类型」。\r\n\r\n<a name=\"one-to-one-polymorphic-model-structure\"></a>\r\n#### 模型结构\r\n\r\n接下来，再看看建立关联的模型定义：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Image extends Model\r\n    {\r\n        /**\r\n         * 获取拥有此图片的模型\r\n         */\r\n        public function imageable()\r\n        {\r\n            return $this->morphTo();\r\n        }\r\n    }\r\n\r\n    class Post extends Model\r\n    {\r\n        /**\r\n         * 获取文章图片\r\n         */\r\n        public function image()\r\n        {\r\n            return $this->morphOne(Image::class, 'imageable');\r\n        }\r\n    }\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 获取文章图片\r\n         */\r\n        public function image()\r\n        {\r\n            return $this->morphOne(Image::class, 'imageable');\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"one-to-one-polymorphic-retrieving-the-relationship\"></a>\r\n#### 获取关联\r\n\r\n一旦定义了表和模型，就可以通过模型访问此关联。比如，要获取文章图片，可以使用 `image` 动态属性：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::find(1);\r\n\r\n    $image = $post->image;\r\n\r\n还可以通过访问执行 `morphTo` 调用的方法名来从多态模型中获知父模型。在这个例子中，就是 `Image` 模型的 `imageable` 方法。所以，我们可以像动态属性那样访问这个方法：\r\n\r\n    use App\\Models\\Image;\r\n\r\n    $image = Image::find(1);\r\n\r\n    $imageable = $image->imageable;\r\n\r\n`Image` 模型上的 `imageable` 关系将返回 `Post` 实例或 `User` 实例，具体取决于模型拥有图像的类型。\r\n\r\n<a name=\"morph-one-to-one-key-conventions\"></a>\r\n#### 自定义列\r\n\r\n如有必要，你可以指定多态子模型使用的 `id` 和 `type` 列的名称。 如果这样做，请确保始终将关系名称作为第一个参数传递给 `morphTo` 方法。 通常，此值应与方法名称匹配，因此你可以使用 PHP 的 `__FUNCTION__` 常量：\r\n\r\n    /**\r\n     * 获取 image 实例所属的模型\r\n     */\r\n    public function imageable()\r\n    {\r\n        return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');\r\n    }\r\n\r\n<a name=\"one-to-many-polymorphic-relations\"></a>\r\n### 一对多（多态）\r\n\r\n<a name=\"one-to-many-polymorphic-table-structure\"></a>\r\n#### 表结构\r\n\r\n一对多多态关联与简单的一对多关联类似，不过，目标模型可以在一个关联中从属于多个模型。假设应用中的用户可以同时「评论」文章和视频。使用多态关联，可以用单个 `comments` 表同时满足这些情况。我们还是先来看看用来构建这种关联的表结构：\r\n\r\n    posts\r\n        id - integer\r\n        title - string\r\n        body - text\r\n\r\n    videos\r\n        id - integer\r\n        title - string\r\n        url - string\r\n\r\n    comments\r\n        id - integer\r\n        body - text\r\n        commentable_id - integer\r\n        commentable_type - string\r\n\r\n\r\n\r\n<a name=\"one-to-many-polymorphic-model-structure\"></a>\r\n#### 模型结构\r\n\r\n接下来，看看构建这种关联的模型定义： \r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Comment extends Model\r\n    {\r\n        /**\r\n         * 获取拥有此评论的模型（Post 或 Video）\r\n         */\r\n        public function commentable()\r\n        {\r\n            return $this->morphTo();\r\n        }\r\n    }\r\n\r\n    class Post extends Model\r\n    {\r\n        /**\r\n         * 获取此文章的所有评论\r\n         */\r\n        public function comments()\r\n        {\r\n            return $this->morphMany(Comment::class, 'commentable');\r\n        }\r\n    }\r\n\r\n    class Video extends Model\r\n    {\r\n        /**\r\n         * 获取此视频的所有评论\r\n         */\r\n        public function comments()\r\n        {\r\n            return $this->morphMany(Comment::class, 'commentable');\r\n        }\r\n    }\r\n\r\n<a name=\"one-to-many-polymorphic-retrieving-the-relationship\"></a>\r\n#### 获取关联\r\n\r\n一旦定义了数据库表和模型，就可以通过模型访问关联。例如，可以使用 `comments` 动态属性访问文章的全部评论：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::find(1);\r\n\r\n    foreach ($post->comments as $comment) {\r\n        //\r\n    }\r\n\r\n你还可以通过访问执行对 `morphTo` 的调用的方法名来从多态模型获取其所属模型。在我们的例子中，这就是 `Comment` 模型上的 `commentable` 方法。因此，我们将以动态属性的形式访问该方法：\r\n\r\n    use App\\Models\\Comment;\r\n\r\n    $comment = Comment::find(1);\r\n\r\n    $commentable = $comment->commentable;\r\n\r\n`Comment` 模型的 `commentable` 关联将返回 `Post` 或 `Video` 实例，其结果取决于评论所属的模型。\r\n\r\n<a name=\"one-of-many-polymorphic-relations\"></a>\r\n### 一对多（多态）\r\n\r\n有时一个模型可能有许多相关模型，要检索关系的「最新」或「最旧」相关模型。 例如，一个 `User` 模型可能与许多 `Image` 模型相关，如果你想定义一种方便的方式来与用户上传的最新图像进行交互。 可以使用 `morphOne` 关系类型结合 `ofMany` 方法来完成此操作：\r\n\r\n```php\r\n/**\r\n * 获取用户最近的图像。\r\n */\r\npublic function latestImage()\r\n{\r\n    return $this->morphOne(Image::class, 'imageable')->latestOfMany();\r\n}\r\n```\r\n\r\n\r\n\r\n同样，你也可以定义一个方法来检索关系的「最早」或第一个相关模型：\r\n\r\n```php\r\n/**\r\n * 获取用户最早的图像。\r\n */\r\npublic function oldestImage()\r\n{\r\n    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();\r\n}\r\n```\r\n\r\n`latestOfMany` 和 `oldestOfMany` 默认根据模型的主键检索最新或最旧的相关记录，所以模型主键必须是 可排序 的。 如果要使用不同的排序条件从更大的关系中检索单个模型。\r\n\r\n例如，使用 `ofMany` 方法，可以检索用户点赞最高的图像。`ofMany` 方法接受可排序列作为其第一个参数，以及在查询相关模型时应用哪个聚合函数（`min` 或 `max`）：\r\n\r\n```php\r\n/**\r\n * Get the user's most popular image.\r\n */\r\npublic function bestImage()\r\n{\r\n    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');\r\n}\r\n```\r\n\r\n> 技巧：要构建更高级的「一对多」关系。 请查看 [进阶一对多检索](#advanced-has-one-of-many-relationships).\r\n\r\n<a name=\"many-to-many-polymorphic-relations\"></a>\r\n### 多对多（多态）\r\n\r\n<a name=\"many-to-many-polymorphic-table-structure\"></a>\r\n#### 表结构\r\n\r\n多对多多态关联比 `morphOne` 和 `morphMany` 关联略微复杂一些。例如，博客 `Post` 和 `Video` 模型能够共享关联到 `Tag` 模型的多态关系。使用多对多多态关联允许使用一个唯一标签在博客文章和视频间共享。以下是多对多多态关联的表结构：\r\n\r\n    posts\r\n        id - integer\r\n        name - string\r\n\r\n    videos\r\n        id - integer\r\n        name - string\r\n\r\n    tags\r\n        id - integer\r\n        name - string\r\n\r\n    taggables\r\n        tag_id - integer\r\n        taggable_id - integer\r\n        taggable_type - string\r\n\r\n> 技巧：在深入研究多态多对多关系之前，阅读 [多对多关系](#many-to-many) 的文档会对你有帮助。\r\n\r\n\r\n\r\n<a name=\"many-to-many-polymorphic-model-structure\"></a>\r\n#### 模型结构\r\n\r\n接下来，我们准备在模型上定义关联。Post 和 Video 模型都有调用 Eloquent 基类上 morphToMany 方法的 tags 方法。\r\n\r\n`morphToMany` 方法接受相关模型的名称以及“关系名称”。根据我们分配给中间表名的名称及其包含的键，我们将该关系称为“taggable”\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Post extends Model\r\n    {\r\n        /**\r\n         * 获取post下所有的标签.\r\n         */\r\n        public function tags()\r\n        {\r\n            return $this->morphToMany(Tag::class, 'taggable');\r\n        }\r\n    }\r\n\r\n<a name=\"many-to-many-polymorphic-defining-the-inverse-of-the-relationship\"></a>\r\n#### 自定义多态类型\r\n\r\n接下来, 在这个 `Tag` 模型中, 你应该为每个可能的父模型定义一个方法. 所以, 在这个例子中, 我们将会定义一个  `posts` 方法 和 一个 `videos` 方法. 这两个方法都应该返回 `morphedByMany`  结果\r\n\r\n`morphedByMany` 方法接受相关模型的名称以及\"关系名称\"。根据我们分配给中间表名的名称及其包含的键，我们将该关系称为“taggable”：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Tag extends Model\r\n    {\r\n        /**\r\n         * 获取分配给此标签的所有帖子。\r\n         */\r\n        public function posts()\r\n        {\r\n            return $this->morphedByMany(Post::class, 'taggable');\r\n        }\r\n\r\n        /**\r\n         * 获取分配给此视频的所有帖子.\r\n         */\r\n        public function videos()\r\n        {\r\n            return $this->morphedByMany(Video::class, 'taggable');\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"many-to-many-polymorphic-retrieving-the-relationship\"></a>\r\n#### 获取关联\r\n\r\n一旦定义了数据库表和模型，您就可以通过模型访问关系。 例如，要访问帖子的所有标签，您可以使用 `tags` 动态关系属性：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::find(1);\r\n\r\n    foreach ($post->tags as $tag) {\r\n        //\r\n    }\r\n\r\n还可以访问执行 `morphedByMany` 方法调用的方法名来从多态模型获取其所属模型。在这个示例中，就是 `Tag` 模型的 `posts` 或 `videos` 方法。可以像动态属性一样访问这些方法：\r\n\r\n    use App\\Models\\Tag;\r\n\r\n    $tag = Tag::find(1);\r\n\r\n    foreach ($tag->posts as $post) {\r\n        //\r\n    }\r\n\r\n    foreach ($tag->videos as $video) {\r\n        //\r\n    }\r\n\r\n<a name=\"custom-polymorphic-types\"></a>\r\n### 自定义多态类型\r\n\r\n默认情况下， Laravel 使用完全限定类名存储关联模型类型。在上面的一对多示例中， 因为 `Comment` 可能从属于一个 `Post` 或一个 `Video`，默认的 `commentable_type` 就将分别是 `App\\Post 或 App\\Video`。不过，你可能希望数据库与应用的内部结构解耦。在这种情况下，可以定义一个「morph 映射」来通知 Eloquent 使用自定义名称代替对应的类名：\r\n\r\n例如，我们可以不使用模型名称作为「类型」，而是使用简单的字符串，例如 `post` 和 `video`。 通过这样做，即使模型被重命名，我们数据库中的多态「类型」列值也将保持有效：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\Relation;\r\n\r\n    Relation::enforceMorphMap([\r\n        'post' => 'App\\Models\\Post',\r\n        'video' => 'App\\Models\\Video',\r\n    ]);\r\n\r\n你可以在 `App\\Providers\\AppServiceProvider` 类的 `boot` 方法中调用 `enforceMorphMap` 方法，或者你也可以创建一个单独的服务提供者。\r\n\r\n\r\n你可以在运行时使用 `getMorphClass` 方法确定给定模型的别名。相反，可以使用 `Relation::getMorphedModel` 方法来确定与别名相关联的类名：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\Relation;\r\n\r\n    $alias = $post->getMorphClass();\r\n\r\n    $class = Relation::getMorphedModel($alias);\r\n\r\n> 注意：向现有应用程序添加「变形映射」时，数据库中仍包含完全限定类的每个可变形 `*_type` 列值都需要转换为其「映射」名称。\r\n\r\n<a name=\"dynamic-relationships\"></a>\r\n### 动态关联\r\n\r\n你可以使用 `resolveRelationUsing` 方法在运行时定义 Eloquent 模型之间的关系。虽然通常不建议在常规应用程序开发中使用它，但是在开发 Laravel 软件包时，这有时可能会很有用： \r\n\r\n`resolveRelationUsing` 方法的第一个参数是关联名称。传递给该方法的第二个参数应该是一个闭包，闭包接受模型实例并返回一个有效的 Eloquent 关联定义。通常情况下，你应该在[服务提供器](/docs/laravel/9.x/providers)的启动方法中配置动态关联。\r\n\r\n    use App\\Models\\Order;\r\n    use App\\Models\\Customer;\r\n\r\n    Order::resolveRelationUsing('customer', function ($orderModel) {\r\n        return $orderModel->belongsTo(Customer::class, 'customer_id');\r\n    });\r\n\r\n> 注意：定义动态关系时，始终为 Eloquent 关系方法提供显式的键名参数。\r\n\r\n<a name=\"querying-relations\"></a>\r\n## 查询关联\r\n\r\n因为所有的 Eloquent 关联都是通过方法定义的，你可以调用这些方法来获取关联的实例，而无需真实执行查询来获取相关的模型。此外，所有的 Eloquent 关联也可以用作[查询生成器](/docs/laravel/9.x/queries)，允许你在最终对数据库执行 SQL 查询之前，继续通过链式调用添加约束条件。 \r\n\r\n\r\n\r\n例如，假设有一个博客系统，它的 `User` 模型有许多关联的 `Post` 模型：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 获取该用户的所有文章.\r\n         */\r\n        public function posts()\r\n        {\r\n            return $this->hasMany(Post::class);\r\n        }\r\n    }\r\n\r\n你可以查询 `posts` 关联，并给它添加额外的约束条件，如下例所示：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->posts()->where('active', 1)->get();\r\n\r\n\r\n你可以在关联上使用任意的 [查询构造器](/docs/laravel/9.x/queries) 方法，所以一定要阅读查询构造器的文档，了解它的所有方法，这会对你非常有用。\r\n<br>\r\n#### 在关联之后链式添加 `orWhere` 子句\r\n<br>\r\n\r\n如上例所示，你可以在查询关联时，自由的给关联添加额外的约束条件。但是，在将 `orWhere` 子句链接到关联上时，一定要小心，因为 `orWhere` 子句将在逻辑上与关联约束处于同一级别：\r\n\r\n    $user->posts()\r\n            ->where('active', 1)\r\n            ->orWhere('votes', '>=', 100)\r\n            ->get();\r\n\r\n上面的例子将生成以下 SQL。像你看到的那样， 这个 `or` 子句的查询指令，将返回大于 100 票的任一用户，查询不再限于特定的用户：\r\n\r\n```sql\r\nselect *\r\nfrom posts\r\nwhere user_id = ? and active = 1 or votes >= 100\r\n```\r\n\r\n\r\n在大多数情况下，你应该使用 [逻辑组](/docs/laravel/9.x/queries#logical-grouping) 在括号中对条件检查进行分组：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $user->posts()\r\n            ->where(function (Builder $query) {\r\n                return $query->where('active', 1)\r\n                             ->orWhere('votes', '>=', 100);\r\n            })\r\n            ->get();\r\n\r\n\r\n\r\n上面的示例将生成以下 SQL。 请注意，逻辑分组已正确分组约束，并且查询仍然受限于特定用户：\r\n\r\n```sql\r\nselect *\r\nfrom posts\r\nwhere user_id = ? and (active = 1 or votes >= 100)\r\n```\r\n\r\n<a name=\"relationship-methods-vs-dynamic-properties\"></a>\r\n### 关联方法 VS 动态属性\r\n\r\n如果你不需要向 Eloquent 关联查询添加额外的约束，您可以像访问属性一样访问关联。 例如，继续使用我们的 `User` 和 `Post` 示例模型，我们可以像这样访问用户的所有帖子：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    foreach ($user->posts as $post) {\r\n        //\r\n    }\r\n\r\n动态属性是 「懒加载」 的，只有实际访问到才会加载关联数据。因此，通常用 [预加载](#eager-loading) 来准备模型需要用到的关联数据。预加载能大量减少因加载模型关联执行的 SQL 语句。 \r\n\r\n<a name=\"querying-relationship-existence\"></a>\r\n### 查询已存在的关联\r\n\r\n检索模型记录时，你可能希望根据关系的存在限制结果。例如，假设要检索至少有一条评论的所有博客文章。 你可以将关系的名称传递给 `has` 和 `orHas` 方法：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    // 检索至少有一条评论的文章...\r\n    $posts = Post::has('comments')->get();\r\n\r\n也可以指定运算符和数量来进一步自定义查询：\r\n\r\n    // 查出至少有三条评论的文章...\r\n    $posts = Post::has('comments', '>=', 3)->get();\r\n\r\n\r\n\r\n也可以用「点」语法构造嵌套的 `has` 语句。例如，查出至少有一条评论和图片的文章：\r\n\r\n    // 查出至少有一条带图片的评论的文章...\r\n    $posts = Post::has('comments.images')->get();\r\n\r\n如果需要更多功能，可以使用 `whereHas` 和 `orWhereHas` 方法将「where」条件放到 `has` 查询上。这些方法允许你向关联加入自定义约束，比如检查评论内容：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    // 获取至少带有一条评论内容包含 code% 关键词的文章...\r\n    $posts = Post::whereHas('comments', function (Builder $query) {\r\n        $query->where('content', 'like', 'code%');\r\n    })->get();\r\n\r\n    // 获取至少带有十条评论内容包含 code% 关键词的文章...\r\n    $posts = Post::whereHas('comments', function (Builder $query) {\r\n        $query->where('content', 'like', 'code%');\r\n    }, '>=', 10)->get();\r\n\r\n> 注意：Eloquent 目前不支持跨数据库查询关系是否存在。 这些关系必须存在于同一数据库中。\r\n\r\n<a name=\"inline-relationship-existence-queries\"></a>\r\n#### 内联关系存在查询\r\n\r\n如果你想使用附加到关系查询简单的 `where` 条件来确认关系是否存在，可以现使用 `whereRelation` 和 `whereMorphRelation` 。 例如，查询所有评论未获批准的帖子：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::whereRelation('comments', 'is_approved', false)->get();\r\n\r\n当然，就像调用查询构建器的 `where` 方法一样，您也可以指定一个运算符：\r\n\r\n    $posts = Post::whereRelation(\r\n        'comments', 'created_at', '>=', now()->subHour()\r\n    )->get();\r\n\r\n\r\n\r\n<a name=\"querying-relationship-absence\"></a>\r\n### 查询不存在的关联\r\n\r\n检索模型记录时，你可能会根据不存在关系来限制结果。例如，要检索**没有**有任何评论的所有博客文章。 可以将关系的名称传递给 `doesntHave` 和 `orDoesntHave` 方法：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::doesntHave('comments')->get();\r\n\r\n如果需要更多功能，可以使用 `whereDoesntHave` 和 `orWhereDoesntHave` 方法将「where」 条件加到 `doesntHave` 查询上。这些方法允许你向关联加入自定义限制，比如检测评论内容：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $posts = Post::whereDoesntHave('comments', function (Builder $query) {\r\n        $query->where('content', 'like', 'code%');\r\n    })->get();\r\n\r\n您可以使用「点」符号对嵌套关系执行查询。例如，以下查询将检索所有没有评论的帖子；但是，有未被禁止的作者评论的帖子将包含在结果中:\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $posts = Post::whereDoesntHave('comments.author', function (Builder $query) {\r\n        $query->where('banned', 0);\r\n    })->get();\r\n\r\n<a name=\"querying-morph-to-relationships\"></a>\r\n### 多态关联查询\r\n\r\n要查询多态关联关系的存在，可以使用 `whereHasMorph` 和 `whereDoesntHaveMorph` 方法。这些方法接受关联名称作为它们的第一个参数。接下来，这些方法接受你想要包含在查询中的相关模型的名称。最后，也可以提供一个自定义关系查询的闭包：\r\n\r\n    use App\\Models\\Comment;\r\n    use App\\Models\\Post;\r\n    use App\\Models\\Video;\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    // 检索与标题类似 code% 的帖子或视频相关的评论...\r\n    $comments = Comment::whereHasMorph(\r\n        'commentable',\r\n        [Post::class, Video::class],\r\n        function (Builder $query) {\r\n            $query->where('title', 'like', 'code%');\r\n        }\r\n    )->get();\r\n\r\n    // 检索与标题不类似代码的帖子相关的评论...\r\n    $comments = Comment::whereDoesntHaveMorph(\r\n        'commentable',\r\n        Post::class,\r\n        function (Builder $query) {\r\n            $query->where('title', 'like', 'code%');\r\n        }\r\n    )->get();\r\n\r\n\r\n\r\n您可能偶尔需要根据相关多态模型的「类型」添加查询约束。 传递给 `whereHasMorph` 方法的闭包可能会接收一个 `$type` 值作为它的第二个参数。 此参数允许你检查正在构建的查询的「类型」：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $comments = Comment::whereHasMorph(\r\n        'commentable',\r\n        [Post::class, Video::class],\r\n        function (Builder $query, $type) {\r\n            $column = $type === Post::class ? 'content' : 'title';\r\n\r\n            $query->where($column, 'like', 'code%');\r\n        }\r\n    )->get();\r\n\r\n<a name=\"querying-all-morph-to-related-models\"></a>\r\n#### 查询所有关联模型\r\n\r\n你可以提供 `*` 作为通配符值，而不是传递可能存在多态模型数组。这将指示 Laravel 从数据库中检索所有可能的多态类型。为了执行此操作，Laravel 将执行一个附加查询：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {\r\n        $query->where('title', 'like', 'foo%');\r\n    })->get();\r\n\r\n<a name=\"aggregating-related-models\"></a>\r\n## 聚合关联模型\r\n\r\n<a name=\"counting-related-models\"></a>\r\n### 关联模型计数\r\n\r\n有时你可能需要计算给定关系的相关模型的数量，而不实际加载模型。 为此，你可以使用 `withCount` 方法。 `withCount` 方法将在生成的模型上放置 `{relation}_count` 属性：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::withCount('comments')->get();\r\n\r\n    foreach ($posts as $post) {\r\n        echo $post->comments_count;\r\n    }\r\n\r\n通过将数组传递到 `withCount` 方法，可以为多个关系添加「计数」，并向查询添加附加约束：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $posts = Post::withCount(['votes', 'comments' => function (Builder $query) {\r\n        $query->where('content', 'like', 'code%');\r\n    }])->get();\r\n\r\n    echo $posts[0]->votes_count;\r\n    echo $posts[0]->comments_count;\r\n\r\n\r\n\r\n你还可以以别名关系计数结果，允许对同一关系进行多个计数：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $posts = Post::withCount([\r\n        'comments',\r\n        'comments as pending_comments_count' => function (Builder $query) {\r\n            $query->where('approved', false);\r\n        },\r\n    ])->get();\r\n\r\n    echo $posts[0]->comments_count;\r\n    echo $posts[0]->pending_comments_count;\r\n\r\n<a name=\"deferred-count-loading\"></a>\r\n#### 延迟加载计数\r\n\r\n使用 `loadCount` 可以在模型获取后加载关联关系的数量。\r\n\r\n    $book = Book::first();\r\n\r\n    $book->loadCount('genres');\r\n\r\n如果你需要在统计时设置额外查询条件，可以通过传递键为关联关系名、值为查询闭包的数组来实现：\r\n\r\n    $book->loadCount(['reviews' => function ($query) {\r\n        $query->where('rating', 5);\r\n    }])\r\n\r\n<a name=\"relationship-counting-and-custom-select-statements\"></a>\r\n#### 关联关系计数与自定义获取字段\r\n\r\n如果你的查询同时包含 `withCount` 和 `select`，请确保 `withCount` 一定在 `select` 之后调用：\r\n\r\n    $posts = Post::select(['title', 'body'])\r\n                    ->withCount('comments')\r\n                    ->get();\r\n\r\n<a name=\"other-aggregate-functions\"></a>\r\n### 其他聚合函数\r\n\r\n除了 `withCount` 方法外，Eloquent 还提供了 `withMin`, `withMax`, `withAvg` 和 `withSum` 等聚合方法。\r\n这些方法会通过 `{relation}_{function}_{column}` 的命名方式将聚合结果添加到获取到的模型属性中：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::withSum('comments', 'votes')->get();\r\n\r\n    foreach ($posts as $post) {\r\n        echo $post->comments_sum_votes;\r\n    }\r\n\r\n如果你想使用其他名称访问聚合函数的结果，可以自定义的别名：\r\n\r\n    $posts = Post::withSum('comments as total_comments', 'votes')->get();\r\n\r\n    foreach ($posts as $post) {\r\n        echo $post->total_comments;\r\n    }\r\n\r\n\r\n\r\n与 `loadCount` 方法类似，这些方法也有延迟调用的方法。这些延迟方法可在已获取到的 Eloquent 模型上调用：\r\n\r\n    $post = Post::first();\r\n\r\n    $post->loadSum('comments', 'votes');\r\n\r\n如果你将这些聚合方法和一个 `select` 语句组合在一起，确保你在 `select` 方法之后调用聚合方法:\r\n\r\n    $posts = Post::select(['title', 'body'])\r\n                    ->withExists('comments')\r\n                    ->get();\r\n\r\n<a name=\"counting-related-models-on-morph-to-relationships\"></a>\r\n### 计算多态关联关系的数量\r\n\r\n如果你想预加载多态关联关系以及这个关联关系关联的其他关联关系的计数统计，可以通过将 `with` 方法与 `morphTo` 关系和 `morphWithCount` 方法结合来实现。\r\n\r\n在这个例子中，我们假设 `Photo` 和 `Post` 模型可以创建 `ActivityFeed` 模型。 我们将假设 `ActivityFeed`模型定义了一个名为`parentable`的多态关联关系，它允许我们为给定的 `ActivityFeed` 实例检索父级 `Photo` 或 `Post` 模型。 此外，让我们假设 `Photo` 模型有很多 `Tag` 模型、`Post` 模型有很多 `Comment` 模型。\r\n\r\n假如我们想要检索 `ActivityFeed` 实例并为每个 `ActivityFeed` 实例预先加载 `parentable` 父模型。 此外，我们想要检索与每张父照片关联的标签数量以及与每个父帖子关联的评论数量：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    $activities = ActivityFeed::with([\r\n        'parentable' => function (MorphTo $morphTo) {\r\n            $morphTo->morphWithCount([\r\n                Photo::class => ['tags'],\r\n                Post::class => ['comments'],\r\n            ]);\r\n        }])->get();\r\n\r\n<a name=\"morph-to-deferred-count-loading\"></a>\r\n\r\n\r\n#### 延迟加载计数\r\n\r\n假设我们已经检索了一组 `ActivityFeed` 模型，现在我们想要加载与活动提要关联的各种 `parentable` 模型的嵌套关系计数。 可以使用 `loadMorphCount` 方法来完成此操作：\r\n\r\n    $activities = ActivityFeed::with('parentable')->get();\r\n\r\n    $activities->loadMorphCount('parentable', [\r\n        Photo::class => ['tags'],\r\n        Post::class => ['comments'],\r\n    ]);\r\n\r\n<a name=\"eager-loading\"></a>\r\n## 预加载\r\n\r\n当将 Eloquent 关系作为属性访问时，相关模型是延迟加载的。 这意味着在你第一次访问该属性之前不会实际加载关联数据。 但是，Eloquent 可以在查询父模型时主动加载关联关系。 预加载减轻了 `N + 1` 查询问题。 为了说明 `N + 1` 查询问题，请参考属于 `Author` 模型的 `Book` 模型：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Book extends Model\r\n    {\r\n        /**\r\n         * 获取作者的所有书籍\r\n         */\r\n        public function author()\r\n        {\r\n            return $this->belongsTo(Author::class);\r\n        }\r\n    }\r\n\r\n我们检索所有书籍及其作者：\r\n\r\n    use App\\Models\\Book;\r\n\r\n    $books = Book::all();\r\n\r\n    foreach ($books as $book) {\r\n        echo $book->author->name;\r\n    }\r\n\r\n该循环将执行一个查询以检索数据库表中的所有书籍，然后对每本书执行另一个查询以检索该书的作者。 因此，如果我们有 25 本书，上面的代码将运行 26 个查询：一个查询原本的书籍信息，另外 25 个查询来检索每本书的作者。\r\n\r\n值得庆幸的是，我们可以使用预加载将这个操作减少到两个查询。 在构建查询时，可以使用 `with` 方法指定应该预加载哪些关系： \r\n\r\n    $books = Book::with('author')->get();\r\n\r\n    foreach ($books as $book) {\r\n        echo $book->author->name;\r\n    }\r\n\r\n\r\n\r\n对于此操作，将只执行两个查询 - 一个查询检索所有书籍，一个查询检索所有书籍的所有作者：\r\n\r\n```sql\r\nselect * from books\r\n\r\nselect * from authors where id in (1, 2, 3, 4, 5, ...)\r\n```\r\n\r\n<a name=\"eager-loading-multiple-relationships\"></a>\r\n#### 预加载多个关联\r\n\r\n有时，你可能需要在单一操作中预加载几个不同的关联。要达成此目的，只要向 `with` 方法传递多个关联名称构成的数组参数：\r\n\r\n    $books = Book::with(['author', 'publisher'])->get();\r\n\r\n<a name=\"nested-eager-loading\"></a>\r\n#### 嵌套预加载\r\n\r\n可以使用 「点」 语法预加载嵌套关联。比如在一个 Eloquent 语句中预加载所有书籍作者及其联系方式：\r\n\r\n    $books = Book::with('author.contacts')->get();\r\n\r\n<a name=\"nested-eager-loading-morphto-relationships\"></a>\r\n#### 嵌套预加载 morphTo 关联\r\n\r\n如果你希望加载一个 `morphTo` 关系，以及该关系可能返回的各种实体的嵌套关系，可以将 `with` 方法与 `morphTo` 关系的 `morphWith` 方法结合使用。为了说明这种方法，让我们参考以下模型：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class ActivityFeed extends Model\r\n    {\r\n        /**\r\n         * 获取活动提要记录的父级\r\n         */\r\n        public function parentable()\r\n        {\r\n            return $this->morphTo();\r\n        }\r\n    }\r\n\r\n在这个例子中，我们假设 `Event`，`Photo` 和 `Post` 模型可以创建 `ActivityFeed` 模型。 另外，我们假设 `Event` 模型属于 `Calendar` 模型，`Photo` 模型与 `Tag` 模型相关联，`Post` 模型属于 `Author` 模型。\r\n\r\n使用这些模型定义和关联，我们可以查询 `ActivityFeed` 模型实例并预加载所有 `parentable` 模型及其各自的嵌套关系：\r\n\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    $activities = ActivityFeed::query()\r\n        ->with(['parentable' => function (MorphTo $morphTo) {\r\n            $morphTo->morphWith([\r\n                Event::class => ['calendar'],\r\n                Photo::class => ['tags'],\r\n                Post::class => ['author'],\r\n            ]);\r\n        }])->get();\r\n\r\n\r\n\r\n<a name=\"eager-loading-specific-columns\"></a>\r\n#### 预加载指定列\r\n\r\n并不是总需要获取关系的每一列。在这种情况下，Eloquent 允许你为关联指定想要获取的列:\r\n\r\n    $books = Book::with('author:id,name,book_id')->get();\r\n\r\n\r\n> 注意：使用此功能时，应始终在要检索的列列表中包括 `id` 列和任何相关的外键列。\r\n\r\n<a name=\"eager-loading-by-default\"></a>\r\n#### 默认预加载\r\n\r\n有时可能希望在查询模型时始终加载某些关联。 为此，你可以在模型上定义 <code>$with</code> 属性\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Book extends Model\r\n    {\r\n        /**\r\n         * 默认加载的关联\r\n         *\r\n         * @var array\r\n         */\r\n        protected $with = ['author'];\r\n\r\n        /**\r\n         * 获取书籍作者\r\n         */\r\n        public function author()\r\n        {\r\n            return $this->belongsTo(Author::class);\r\n        }\r\n\r\n        /**\r\n         * 获取书籍类型.\r\n         */\r\n        public function genre()\r\n        {\r\n            return $this->belongsTo(Genre::class);\r\n        }\r\n    }\r\n\r\n如果你想从单个查询的 <code>$with</code> 属性中删除一个预加载，你可以使用 <code>without</code> 方法：\r\n\r\n    $books = Book::without('author')->get();\r\n\r\n如果你想为单个查询覆盖 <code>$with</code> 属性中的所有项目，可以使用 <code>withOnly</code> 方法：\r\n\r\n    $books = Book::withOnly('genre')->get();\r\n\r\n<a name=\"constraining-eager-loads\"></a>\r\n### 为预加载添加约束\r\n\r\n有时，你可能希望预加载一个关联，同时为预加载查询添加额外查询条件。您可以通过将一个关联数组传递给 <code>with</code> 方法来实现这一点，其中数组键是关联名称，数组值是一个闭包，它为预先加载查询添加了额外的约束：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::with(['posts' => function ($query) {\r\n        $query->where('title', 'like', '%code%');\r\n    }])->get();\r\n\r\n\r\n\r\n在这个例子中，Eloquent 只会预加载帖子的 `title` 列包含单词 `code` 的帖子。 你可以调用其他 [查询构造器](/docs/laravel/9.x/queries) 方法来自定义预加载操作：\r\n\r\n    $users = User::with(['posts' => function ($query) {\r\n        $query->orderBy('created_at', 'desc');\r\n    }])->get();\r\n\r\n> 注意：T在约束预加载时，不能使用 limit 和 take 查询构造器方法。\r\n\r\n<a name=\"constraining-eager-loading-of-morph-to-relationships\"></a>\r\n#### `morphTo` 关联预加载添加约束\r\n\r\n预加载 `morphTo` 关联关系时，Eloquent 将运行多个查询来获取每种类型的相关模型。 您可以使用 `MorphTo` 关系的 `constrain` 方法为每个查询添加额外的约束： \r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    $comments = Comment::with(['commentable' => function (MorphTo $morphTo) {\r\n        $morphTo->constrain([\r\n            Post::class => function (Builder $query) {\r\n                $query->whereNull('hidden_at');\r\n            },\r\n            Video::class => function (Builder $query) {\r\n                $query->where('type', 'educational');\r\n            },\r\n        ]);\r\n    }])->get();\r\n\r\n在这个例子中，Eloquent 只会预先加载未被隐藏的帖子，并且视频的 `type` 值为 `educational`。\r\n\r\n<a name=\"lazy-eager-loading\"></a>\r\n### 延迟预加载\r\n\r\n有时你可能需要在已检索到父模型后立即加载关系。例如，你需要动态决定是否加载相关模型，这可能很有用：\r\n\r\n    use App\\Models\\Book;\r\n\r\n    $books = Book::all();\r\n\r\n    if ($someCondition) {\r\n        $books->load('author', 'publisher');\r\n    }\r\n\r\n如果要在渴求式加载的查询语句中进行条件约束，可以通过数组的形式去加载，键为对应的关联关系，值为 `Closure` 闭包函数，该闭包的参数为一个查询实例：\r\n\r\n    $author->load(['books' => function ($query) {\r\n        $query->orderBy('published_date', 'asc');\r\n    }]);\r\n\r\n\r\n\r\n如果希望仅加载未被加载的关联关系时，你可以使用 `loadMissing` 方法：\r\n\r\n    $book->loadMissing('author');\r\n\r\n<a name=\"nested-lazy-eager-loading-morphto\"></a>\r\n#### 嵌套延迟预加载 & `morphTo`\r\n\r\n如果要预加载 `morphTo` 关系，以及该关系可能返回的各种实体上的嵌套关系，您可以使用 `loadMorph` 方法。\r\n\r\n这个方法接受 `morphTo` 关系的名称作为它的第一个参数，第二个参数接收模型数组、关系数组。例子:\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class ActivityFeed extends Model\r\n    {\r\n        /**\r\n         * 获取活动提要记录的父项。\r\n         */\r\n        public function parentable()\r\n        {\r\n            return $this->morphTo();\r\n        }\r\n    }\r\n\r\n在这个例子中，让我们假设 `Event` 、`Photo` 和 `Post` 模型可以创建 `ActivityFeed` 模型。此外，让我们假设 `Event` 模型属于 `Calendar` 模型，`Photo` 模型与 `Tag` 模型相关联，`Post` 模型属于 `Author` 模型。\r\n\r\n使用这些模型定义和关联关系，我们方可以检索 `ActivityFeed` 模型实例，并立即加载所有 `parentable` 模型及其各自的嵌套关系：\r\n\r\n    $activities = ActivityFeed::with('parentable')\r\n        ->get()\r\n        ->loadMorph('parentable', [\r\n            Event::class => ['calendar'],\r\n            Photo::class => ['tags'],\r\n            Post::class => ['author'],\r\n        ]);\r\n\r\n<a name=\"preventing-lazy-loading\"></a>\r\n### 防止延迟加载\r\n\r\n如前所述，预加载关系可以为应用程序提供显着的性能优势。 但你也可以指示 Laravel 始终防止延迟加载关系。 你可以调用基本 Eloquent 模型类提供的 `preventLazyLoading` 方法。 通常，你应该在应用程序的 `AppServiceProvider` 类的 `boot` 方法中调用此方法。\r\n\r\n\r\n\r\n`preventLazyLoading` 方法接受一个可选的布尔类型的参数，表示是否阻止延迟加载。例如，你可能希望只在非生产环境中禁用延迟加载，这样即使在生产环境代码中意外出现了延迟加载关系，你的生产环境也能继续正常运行。\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\n/**\r\n * Bootstrap any application services.\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Model::preventLazyLoading(! $this->app->isProduction());\r\n}\r\n```\r\n\r\n在阻止延迟加载之后，当你的应用程序尝试延迟加载任何 Eloquent 关系时，Eloquent 将抛出`Illuminate\\Database\\LazyLoadingViolationException`异常。\r\n\r\n你可以使用 `handleLazyLoadingViolationsUsing` 方法自定义延迟加载的违规行为。例如，使用此方法，你可以指示违规行为只被记录，而不是使用异常中断应用程序的执行：\r\n\r\n```php\r\nModel::handleLazyLoadingViolationUsing(function ($model, $relation) {\r\n    $class = get_class($model);\r\n\r\n    info(\"Attempted to lazy load [{$relation}] on model [{$class}].\");\r\n});\r\n```\r\n\r\n<a name=\"inserting-and-updating-related-models\"></a>\r\n## 插入 & 更新关联模型\r\n\r\n<a name=\"the-save-method\"></a>\r\n### `save` 方法\r\n\r\nEloquent 提供了向关系中添加新模型的便捷方法。例如，你可能需要向一篇文章（`Post` 模型）添加一条新的评论（`Comment` 模型），你不用手动设置 `Comment` 模型上的 `post_id` 属性，你可以直接使用关联模型中的 `save` 方法：\r\n\r\n    use App\\Models\\Comment;\r\n    use App\\Models\\Post;\r\n\r\n    $comment = new Comment(['message' => 'A new comment.']);\r\n\r\n    $post = Post::find(1);\r\n\r\n    $post->comments()->save($comment);\r\n\r\n注意，我们没有将 `comments` 关联作为动态属性访问，相反，我们调用了 `comments` 方法来来获得关联实例， `save` 方法会自动添加适当的 `post_id` 值到新的 `Comment` 模型中。\r\n\r\n\r\n\r\n如果需要保存多个关联模型，你可以使用 `saveMany` 方法：\r\n\r\n    $post = Post::find(1);\r\n\r\n    $post->comments()->saveMany([\r\n        new Comment(['message' => 'A new comment.']),\r\n        new Comment(['message' => 'Another new comment.']),\r\n    ]);\r\n\r\n`save` 和 `saveMany` 方法不会将新模型（`Comment`）加载到父模型（`Post`) 上， 如果你计划在使用 `save` 或 `saveMany` 方法后访问该关联模型（`Comment`），你需要使用 `refresh` 方法重新加载模型及其关联，这样你就可以访问到所有评论，包括新保存的评论了：\r\n\r\n    $post->comments()->save($comment);\r\n\r\n    $post->refresh();\r\n\r\n    // 所有评论，包括新保存的评论...\r\n    $post->comments;\r\n\r\n<a name=\"the-push-method\"></a>\r\n#### 递归保存模型和关联数据\r\n\r\n如果你想 `save` 模型及其所有关联数据，你可以使用 `push` 方法，在此示例中，将保存 `Post` 模型及其评论和评论作者：\r\n\r\n\r\n\r\n    $post = Post::find(1);\r\n\r\n    $post->comments[0]->message = 'Message';\r\n    $post->comments[0]->author->name = 'Author Name';\r\n\r\n    $post->push();\r\n\r\n<a name=\"the-create-method\"></a>\r\n### 新增方法\r\n\r\n除了 `save` 和 `saveMany` 方法外，你还可以使用 `create` 方法。它接受一个属性数组，同时会创建模型并插入到数据库中。 还有， `save` 和 `create` 方法的不同之处在于， `save` 方法接受一个完整的 Eloquent 模型实例，而 `create` 则接受普通的 PHP 数组：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::find(1);\r\n\r\n    $comment = $post->comments()->create([\r\n        'message' => 'A new comment.',\r\n    ]);\r\n\r\n\r\n\r\n你还可以使用 `createMany` 方法去创建多个关联模型：\r\n\r\n    $post = Post::find(1);\r\n\r\n    $post->comments()->createMany([\r\n        ['message' => 'A new comment.'],\r\n        ['message' => 'Another new comment.'],\r\n    ]);\r\n\r\n你还可以使用 `findOrNew`, `firstOrNew`, `firstOrCreate`, 和 `updateOrCreate` 方法来 [创建和更新关系模型](/docs/laravel/9.x/eloquent#upserts)。\r\n\r\n> 技巧：在使用 `create` 方法前，请务必确保查看过本文档的 [批量赋值](/docs/laravel/9.x/eloquent#mass-assignment) 章节。\r\n\r\n<a name=\"updating-belongs-to-relationships\"></a>\r\n### Belongs To 关联\r\n\r\n如果您想将子模型分配给新的父模型，您可以使用 `associate` 方法。在这个例子中，`User` 模型定义了一个与 `Account` 模型的 `belongsTo` 关系。 这个 `associate` 方法将在子模型上设置外键：\r\n\r\n    use App\\Models\\Account;\r\n\r\n    $account = Account::find(10);\r\n\r\n    $user->account()->associate($account);\r\n\r\n    $user->save();\r\n\r\n要从子模型中删除父模型，您可以使用 `dissociate` 方法。此方法会将关联外键设置为 `null` ：\r\n\r\n    $user->account()->dissociate();\r\n\r\n    $user->save();\r\n\r\n<a name=\"updating-many-to-many-relationships\"></a>\r\n### 多对多关联\r\n\r\n<a name=\"attaching-detaching\"></a>\r\n#### 附加 / 分离\r\n\r\nEloquent 也提供了一些额外的辅助方法，使相关模型的使用更加方便。例如，我们假设一个用户可以拥有多个角色，并且每个角色都可以被多个用户共享。给某个用户附加一个角色是通过向中间表插入一条记录实现的，可以使用 `attach` 方法完成该操作：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->roles()->attach($roleId);\r\n\r\n在将关系附加到模型时，还可以传递一组要插入到中间表中的附加数据：\r\n\r\n    $user->roles()->attach($roleId, ['expires' => $expires]);\r\n\r\n\r\n\r\n当然，有时也需要移除用户的角色。可以使用 `detach` 移除多对多关联记录。`detach` 方法将会移除中间表对应的记录。但是这两个模型都将会保留在数据库中：\r\n\r\n    // 移除用户的一个角色...\r\n    $user->roles()->detach($roleId);\r\n\r\n    // 移除用户的所有角色...\r\n    $user->roles()->detach();\r\n\r\n为了方便起见，`attach` 和 `detach` 也允许传递一个 ID 数组：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->roles()->detach([1, 2, 3]);\r\n\r\n    $user->roles()->attach([\r\n        1 => ['expires' => $expires],\r\n        2 => ['expires' => $expires],\r\n    ]);\r\n\r\n<a name=\"syncing-associations\"></a>\r\n#### 同步关联\r\n\r\n你也可以使用 `sync` 方法构建多对多关联。`sync` 方法接收一个 ID 数组以替换中间表的记录。中间表记录中，所有未在 ID 数组中的记录都将会被移除。所以该操作结束后，只有给出数组的 ID 会被保留在中间表中：\r\n\r\n    $user->roles()->sync([1, 2, 3]);\r\n\r\n你也可以通过 ID 传递额外的附加数据到中间表：\r\n\r\n    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\r\n\r\n如果您想为每个同步的模型 ID 插入相同的中间表，你可以使用 `syncWithPivotValues` 方法：\r\n\r\n    $user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);\r\n\r\n如果你不想移除现有的 ID，可以使用 `syncWithoutDetaching` 方法：\r\n\r\n    $user->roles()->syncWithoutDetaching([1, 2, 3]);\r\n\r\n<a name=\"toggling-associations\"></a>\r\n#### 切换关联\r\n\r\n多对多关联也提供了 `toggle` 方法用于「切换」给定 ID 数组的附加状态。 如果给定的 ID 已被附加在中间表中，那么它将会被移除，同样，如果给定的 ID 已被移除，它将会被附加：\r\n\r\n    $user->roles()->toggle([1, 2, 3]);\r\n\r\n\r\n\r\n<a name=\"updating-a-record-on-the-intermediate-table\"></a>\r\n#### 更新中间表上的记录\r\n\r\n如果你需要在中间表中更新一条已存在的记录，可以使用 `updateExistingPivot` 方法。 此方法接收中间表的外键与要更新的数据数组进行更新：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->roles()->updateExistingPivot($roleId, [\r\n        'active' => false,\r\n    ]);\r\n\r\n<a name=\"touching-parent-timestamps\"></a>\r\n## 更新父级时间戳\r\n\r\n当一个模型属 `belongsTo` 或者 `belongsToMany` 另一个模型时， 例如 `Comment` 属于 `Post` ，有时更新子模型导致更新父模型时间戳非常有用。\r\n\r\n例如，当 `Comment` 模型被更新时，你需要自动「触发」父级 `Post` 模型的 `updated_at` 时间戳的更新。Eloquent 让它变得简单。只要在子模型加一个包含关联名称的 `touches` 属性即可：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Comment extends Model\r\n    {\r\n        /**\r\n         * 需要触发的所有关联关系。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $touches = ['post'];\r\n\r\n        /**\r\n         * 获取评论所属文章。\r\n         */\r\n        public function post()\r\n        {\r\n            return $this->belongsTo(Post::class);\r\n        }\r\n    }\r\n\r\n> 注意：只有使用 Eloquent 的 `save` 方法更新子模型时，才会更新父模型时间戳。\r\n\r\n","p":"docs/eloquent-relationships.html"},{"t":"eloquent-collections (Eloquent: 集合)","d":"# Eloquent: 集合\r\n\r\n- [简介](#introduction)\r\n- [可用的方法](#available-methods)\r\n- [自定义集合](#custom-collections)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n所有返回多个模型查询结果的 Eloquent 方法的返回值都是 `Illuminate\\Database\\Eloquent\\Collection` 对象的实例，包括通过 `get` 方法或通过关联关系获取到的结果。 Eloquent 集合对象扩展了 Laravel 的 [base collection](https://learnku.com/docs/laravel/9.x/collections/12225)，因此它自然地继承了许多用于流畅地处理 Eloquent 模型的底层数组的方法。请务必查看 Laravel 集合文档以了解所有这些有用的方法！\r\n\r\n而且，所有的集合都可以作为迭代器，你可以像遍历简单的 PHP 数组一样来遍历它们：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where('active', 1)->get();\r\n\r\n    foreach ($users as $user) {\r\n        echo $user->name;\r\n    }\r\n\r\n不过，集合比数组更加强大，它通过更加直观的接口暴露出可链式调用的 map / reduce 等操作。例如，让我们移除所有未激活的用户并收集剩余用户的名字：\r\n\r\n    $names = User::all()->reject(function ($user) {\r\n        return $user->active === false;\r\n    })->map(function ($user) {\r\n        return $user->name;\r\n    });\r\n\r\n<a name=\"eloquent-collection-conversion\"></a>\r\n#### Eloquent 集合转换\r\n\r\n大多数 Eloquent 集合方法会返回新的 Eloquent 集合实例，但是 `collapse`， `flatten`， `flip`， `keys`， `pluck` 和 `zip` 方法除外，它们会返回一个 [base collection](https://learnku.com/docs/laravel/9.x/collections/12225) 实例。 同样，如果 `map` 操作返回的集合不包括任何 Eloquent 模型， 那么它会被自动转换成集合基类。\r\n\r\n\r\n\r\n<a name=\"available-methods\"></a>\r\n## 可用的方法\r\n\r\n所有 Eloquent 的集合都继承了 [Laravel collection](/docs/laravel/9.x/collections#available-methods)  对象；因此， 他们也继承了所有集合基类提供的强大的方法。\r\n\r\n另外， `Illuminate\\Database\\Eloquent\\Collection` 类提供了一套上层的方法来帮你管理你的模型集合。大多数方法返回  `Illuminate\\Database\\Eloquent\\Collection` 实例；然而，也会有一些方法， 例如 `modelKeys`， 它们会返回基于 `Illuminate\\Support\\Collection` 类的实例。\r\n\r\n<style>\r\n    #collection-method-list > p {\r\n        column-count: 1; -moz-column-count: 1; -webkit-column-count: 1;\r\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\r\n    }\r\n\r\n    #collection-method-list a {\r\n        display: block;\r\n    }\r\n\r\n    .collection-method code {\r\n        font-size: 14px;\r\n    }\r\n\r\n    .collection-method:not(.first-collection-method) {\r\n        margin-top: 50px;\r\n    }\r\n</style>\r\n\r\n<div id=\"collection-method-list\" markdown=\"1\">\r\n\r\n[contains](#method-contains)\r\n[diff](#method-diff)\r\n[except](#method-except)\r\n[find](#method-find)\r\n[fresh](#method-fresh)\r\n[intersect](#method-intersect)\r\n[load](#method-load)\r\n[loadMissing](#method-loadMissing)\r\n[modelKeys](#method-modelKeys)\r\n[makeVisible](#method-makeVisible)\r\n[makeHidden](#method-makeHidden)\r\n[only](#method-only)\r\n[toQuery](#method-toquery)\r\n[unique](#method-unique)\r\n\r\n</div>\r\n\r\n<a name=\"method-contains\"></a>\r\n#### `contains($key, $operator = null, $value = null)` \r\n\r\n`contains` 方法可用于判断集合中是否包含指定的模型实例。这个方法接收一个主键或者模型实例：\r\n\r\n    $users->contains(1);\r\n\r\n    $users->contains(User::find(1));\r\n\r\n<a name=\"method-diff\"></a>\r\n#### `diff($items)` \r\n\r\n`diff`  方法返回不在给定集合中的所有模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = $users->diff(User::whereIn('id', [1, 2, 3])->get());\r\n\r\n<a name=\"method-except\"></a>\r\n#### `except($keys)` \r\n\r\n`except` 方法返回给定主键外的所有模型：\r\n\r\n    $users = $users->except([1, 2, 3]);\r\n\r\n<a name=\"method-find\"></a>\r\n#### `find($key)`\r\n\r\n`find` 方法查找给定主键的模型。如果 `$key` 是一个模型实例， `find` 将会尝试返回与主键匹配的模型。 如果 `$key` 是一个关联数组， `find` 将返回所有数组主键匹配的模型：\r\n\r\n    $users = User::all();\r\n\r\n    $user = $users->find(1);\r\n\r\n\r\n\r\n<a name=\"method-fresh\"></a>\r\n#### `fresh($with = [])` \r\n\r\n`fresh`  方法用于从数据库中检索集合中每个模型的新实例。此外，还将加载任何指定的关联关系：\r\n\r\n    $users = $users->fresh();\r\n\r\n    $users = $users->fresh('comments');\r\n\r\n<a name=\"method-intersect\"></a>\r\n#### `intersect($items)` \r\n\r\n`intersect` 方法返回给定集合与当前模型的交集：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());\r\n\r\n<a name=\"method-load\"></a>\r\n#### `load($relations)` \r\n\r\n`load` 方法为集合中的所有模型加载给定关联关系：\r\n\r\n    $users->load(['comments', 'posts']);\r\n\r\n    $users->load('comments.author');\r\n\r\n<a name=\"method-loadMissing\"></a>\r\n#### `loadMissing($relations)` \r\n\r\n如果尚未加载关联关系，则 `loadMissing` 方法将加载集合中所有模型的给定关联关系：\r\n\r\n    $users->loadMissing(['comments', 'posts']);\r\n\r\n    $users->loadMissing('comments.author');\r\n\r\n<a name=\"method-modelKeys\"></a>\r\n#### `modelKeys()` \r\n\r\n`modelKeys` 方法返回集合中所有模型的主键：\r\n\r\n    $users->modelKeys();\r\n\r\n    // [1, 2, 3, 4, 5]\r\n\r\n<a name=\"method-makeVisible\"></a>\r\n#### `makeVisible($attributes)`\r\n\r\n`makeVisible`  方法 [使模型上的隐藏属性可见](/docs/laravel/9.x/eloquent-serialization#hiding-attributes-from-json) ：\r\n\r\n    $users = $users->makeVisible(['address', 'phone_number']);\r\n\r\n<a name=\"method-makeHidden\"></a>\r\n#### `makeHidden($attributes)`\r\n\r\n`makeHidden` 方法 [隐藏模型属性](/docs/laravel/9.x/eloquent-serialization#hiding-attributes-from-json) ：\r\n\r\n    $users = $users->makeHidden(['address', 'phone_number']);\r\n\r\n<a name=\"method-only\"></a>\r\n#### `only($keys)` \r\n\r\n`only` 方法返回具有给定主键的所有模型：\r\n\r\n    $users = $users->only([1, 2, 3]);\r\n\r\n<a name=\"method-toquery\"></a>\r\n\r\n\r\n#### `toQuery()` \r\n\r\n`toQuery` 方法返回一个 Eloquent 查询生成器实例，该实例包含集合模型主键上的 `whereIn` 约束：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where('status', 'VIP')->get();\r\n\r\n    $users->toQuery()->update([\r\n        'status' => 'Administrator',\r\n    ]);\r\n\r\n<a name=\"method-unique\"></a>\r\n#### `unique($key = null, $strict = false)` \r\n\r\n`unique` 方法返回集合中所有不重复的模型，若模型在集合中存在相同类型且相同主键的另一模型，该模型将被删除：\r\n\r\n    $users = $users->unique();\r\n\r\n<a name=\"custom-collections\"></a>\r\n## 自定义集合\r\n\r\n如果你想在与模型交互时使用一个自定义的 `Collection` 对象，你可以通过在模型中定义 `newCollection` 方法来实现：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Support\\UserCollection;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * Create a new Eloquent Collection instance.\r\n         *\r\n         * @param  array  $models\r\n         * @return \\Illuminate\\Database\\Eloquent\\Collection\r\n         */\r\n        public function newCollection(array $models = [])\r\n        {\r\n            return new UserCollection($models);\r\n        }\r\n    }\r\n\r\n一旦在模型中定义了一个 `newCollection` 方法，每当 Eloquent 需要返回一个 `Illuminate\\Database\\Eloquent\\Collection` 实例的时候，将会返回自定义集合的实例取代之。如果你想使每一个模型都使用自定义的集合，可以在一个模型基类中定义一个 `newCollection` 方法，然后让其它模型派生于此基类。\r\n\r\n","p":"docs/eloquent-collections.html"},{"t":"eloquent-mutators (Eloquent: 修改器 & 类型转换)","d":"# Eloquent: 修改器 & 类型转换\r\n\r\n- [简介](#introduction)\r\n- [访问器 & 修改器](#accessors-and-mutators)\r\n    - [定义一个访问器](#defining-an-accessor)\r\n    - [定义一个修改器](#defining-a-mutator)\r\n- [属性转换](#attribute-casting)\r\n    - [数组 & JSON 转换](#array-and-json-casting)\r\n    - [Date 转换](#date-casting)\r\n    - [枚举转换](#enum-casting)\r\n    - [加密转换](#encrypted-casting)\r\n    - [查询时转换](#query-time-casting)\r\n- [自定义类型转换](#custom-casts)\r\n    - [值对象转换](#value-object-casting)\r\n    - [数组 / JSON 序列化](#array-json-serialization)\r\n    - [入站转换](#inbound-casting)\r\n    - [类型转换参数](#cast-parameters)\r\n    - [Castables](#castables)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n当你在 Eloquent 模型实例中获取或设置某些属性值的时候，访问器和修改器允许你对 Eloquent 属性值进行格式化。例如，你可能需要使用 [Laravel 加密器](https://learnku.com/docs/laravel/8.5/encryption) 来加密保存在数据库中的值，而在使用 Eloquent 模型访问该属性的时候自动进行解密其值。\r\n\r\n或者，当通过 Eloquent 模型访问存储在数据库的 JSON 字符串时，你可能希望将其转换为数组。\r\n\r\n<a name=\"accessors-and-mutators\"></a>\r\n## 访问器 & 修改器\r\n\r\n<a name=\"defining-an-accessor\"></a>\r\n### 定义一个访问器\r\n\r\n访问器会在访问一个模型的属性时转换 Eloquent 值。要定义访问器，请在模型中创建一个受保护的「驼峰式」方法来表示可访问属性。此方法名称对应到真正的底层模型 `属性/数据库字段` 的表示。\r\n\r\n在本例中，我们将为 first_name 属性定义一个访问器。在尝试检索 first_name 属性的值时，Eloquent 会自动调用访问器。所有属性访问器/修改器方法必须声明 `Illuminate\\Database\\Eloquent\\Casts\\Attribute` 的返回类型提示：\r\n\r\n```\r\n<?php\r\n \r\nnamespace App\\Models;\r\n \r\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n \r\nclass User extends Model\r\n{\r\n    /**\r\n     * 获取用户的名字。\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Casts\\Attribute\r\n     */\r\n    protected function firstName(): Attribute\r\n    {\r\n        return Attribute::make(\r\n            get: fn ($value) => ucfirst($value),\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n所有访问器方法都返回一个 `Attribute` 实例，该实例定义了如何访问该属性以及如何改变该属性。 在此示例中，我们仅定义如何访问该属性。 为此，我们将 `get` 参数提供给 `Attribute` 类构造函数。\r\n\r\n如你所见，字段的原始值被传递到访问器中，允许你对它进行处理并返回结果。如果想获取被修改后的值，你可以在模型实例上访问 `first_name` 属性：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $firstName = $user->first_name;\r\n\r\n> 技巧：如果要将这些计算值添加到模型的数组/JSON 表示中，[你需要追加它们](/docs/laravel/9.x/eloquent-serialization#appending-values-to-json).\r\n\r\n<a name=\"building-value-objects-from-multiple-attributes\"></a>\r\n#### 从多个属性构建值对象\r\n\r\n有时你的访问器可能需要将多个模型属性转换为单个「值对象」。 为此，你的 `get` 闭包可以接受 `$attributes` 的第二个参数，该参数将自动提供给闭包，并将包含模型所有当前属性的数组：\r\n\r\n```php\r\nuse App\\Support\\Address;\r\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n\r\n/**\r\n * 与用户地址交互。\r\n *\r\n * @return  \\Illuminate\\Database\\Eloquent\\Casts\\Attribute\r\n */\r\npublic function address(): Attribute\r\n{\r\n    return new Attribute(\r\n        get: fn ($value, $attributes) => new Address(\r\n            $attributes['address_line_one'],\r\n            $attributes['address_line_two'],\r\n        ),\r\n    );\r\n}\r\n```\r\n\r\n从访问器返回值对象时，对值对象所做的任何更改都将在模型保存之前自动同步回模型。 这是可能的，因为 Eloquent 保留了访问器返回的实例，因此每次调用访问器时都可以返回相同的实例：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->address->lineOne = 'Updated Address Line 1 Value';\r\n    $user->address->lineTwo = 'Updated Address Line 2 Value';\r\n\r\n    $user->save();\r\n\r\n\r\n\r\n如果要禁用属性的缓存，可以在定义属性时调用 `withoutObjectCaching` 方法：\r\n\r\n```php\r\n/**\r\n * 与 user 的 address 交互.\r\n *\r\n * @return  \\Illuminate\\Database\\Eloquent\\Casts\\Attribute\r\n */\r\npublic function address(): Attribute\r\n{\r\n    return (new Attribute(\r\n        get: fn ($value, $attributes) => new Address(\r\n            $attributes['address_line_one'],\r\n            $attributes['address_line_two'],\r\n        ),\r\n    ))->withoutObjectCaching();\r\n}\r\n```\r\n\r\n<a name=\"defining-a-mutator\"></a>\r\n### 定义修改器\r\n\r\n修改器会在设置属性时生效。要定义修改器，可以在定义属性时提供 `set` 参数。让我们为 `first_name` 属性定义一个修改器。这个修改器将会在我们修改 `first_name` 属性的值时自动调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 与 user 的first name 交互\r\n         *\r\n         * @param  string  $value\r\n         * @return \\Illuminate\\Database\\Eloquent\\Casts\\Attribute\r\n         */\r\n        protected function firstName(): Attribute\r\n        {\r\n            return new Attribute(\r\n                get: fn ($value) => ucfirst($value),\r\n                set: fn ($value) => strtolower($value),\r\n            );\r\n        }\r\n    }\r\n\r\n修改器的闭包会接收将要设置的值，并允许我们使用和返回该值。要使该修改器生效，只需在模型上设置  `first_name` 即可：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->first_name = 'Sally';\r\n\r\n在本例中，值 `Sally` 将会触发 `set` 回调。然后，修改器会使用 `strtolower` 函数处理姓名，并将结果值设置在模型的 `$attributes` 数组中。\r\n\r\n\r\n\r\n<a name=\"mutating-multiple-attributes\"></a>\r\n#### 修改多个属性\r\n\r\n有时你的修改器可能需要修改底层模型的多个属性。 为此，你的 `set` 闭包可以返回一个数组，数组中的每个键都应该与模型的属性/数据库列相对应：\r\n\r\n```php\r\nuse App\\Support\\Address;\r\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n\r\n/**\r\n * 与user模型的address交互.\r\n *\r\n * @return  \\Illuminate\\Database\\Eloquent\\Casts\\Attribute\r\n */\r\npublic function address(): Attribute\r\n{\r\n    return new Attribute(\r\n        get: fn ($value, $attributes) => new Address(\r\n            $attributes['address_line_one'],\r\n            $attributes['address_line_two'],\r\n        ),\r\n        set: fn (Address $value) => [\r\n            'address_line_one' => $value->lineOne,\r\n            'address_line_two' => $value->lineTwo,\r\n        ],\r\n    );\r\n}\r\n```\r\n\r\n<a name=\"attribute-casting\"></a>\r\n## 属性转换\r\n\r\n属性转换提供了类似于访问器和修改器的功能，且无需在模型上定义任何其他方法。模型中的 `$casts` 属性提供了一个便利的方法来将属性转换为常见的数据类型。\r\n\r\n`$casts` 属性应是一个数组，且数组的键是那些需要被转换的属性名称，值则是你希望转换的数据类型。支持转换的数据类型有：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `array`\r\n- `AsStringable::class`\r\n- `boolean`\r\n- `collection`\r\n- `date`\r\n- `datetime`\r\n- `immutable_date`\r\n- `immutable_datetime`\r\n- `decimal:`<code>&lt;digits&gt;</code>\r\n- `double`\r\n- `encrypted`\r\n- `encrypted:array`\r\n- `encrypted:collection`\r\n- `encrypted:object`\r\n- `float`\r\n- `integer`\r\n- `object`\r\n- `real`\r\n- `string`\r\n- `timestamp`\r\n\r\n</div>\r\n\r\n示例， 让我们把以整数 (`0` 或 `1`) 形式存储在数据库中的 `is_admin` 属性转成布尔值：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 类型转换\r\n         *\r\n         * @var array\r\n         */\r\n        protected $casts = [\r\n            'is_admin' => 'boolean',\r\n        ];\r\n    }\r\n\r\n\r\n\r\n现在当你访问 `is_admin` 属性时，虽然保存在数据库里的值是一个整数类型，但是返回值总是会被转换成布尔值类型：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    if ($user->is_admin) {\r\n        //\r\n    }\r\n\r\n如果需要在运行时添加新的临时强制转换，可以使用 `mergeCasts` 这些强制转换定义将添加到模型上已定义的任何强制转换中：\r\n\r\n    $user->mergeCasts([\r\n        'is_admin' => 'integer',\r\n        'options' => 'object',\r\n    ]);\r\n\r\n> 注意： `null` 值属性将不会被转换。此外，禁止定义与关联同名的类型转换（或属性）。\r\n\r\n<a name=\"stringable-casting\"></a>\r\n#### 强制转换\r\n\r\n你可以用 `Illuminate\\Database\\Eloquent\\Casts\\AsStringable` 类将模型属性强制转换为 [`Illuminate\\Support\\Stringable` 对象](/docs/laravel/9.x/helpers#fluent-strings-method-list)：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\AsStringable;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * The attributes that should be cast.\r\n         *\r\n         * @var array\r\n         */\r\n        protected $casts = [\r\n            'directory' => AsStringable::class,\r\n        ];\r\n    }\r\n\r\n<a name=\"array-and-json-casting\"></a>\r\n### 数组 & JSON 转换\r\n\r\n当你在数据库存储序列化的 JSON 的数据时， `array` 类型的转换非常有用。比如：如果你的数据库具有被序列化为 JSON 的 `JSON` 或 `TEXT` 字段类型，并且在 Eloquent 模型中加入了 `array` 类型转换，那么当你访问的时候就会自动被转换为 PHP 数组：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * The attributes that should be cast.\r\n         *\r\n         * @var array\r\n         */\r\n        protected $casts = [\r\n            'options' => 'array',\r\n        ];\r\n    }\r\n\r\n\r\n\r\n一旦定义了转换，你访问 `options` 属性时他会自动从 JSON 类型反序列化为 PHP 数组。当你设置了  `options` 属性的值时，给定的数组也会自动序列化为 JSON 类型存储：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $options = $user->options;\r\n\r\n    $options['key'] = 'value';\r\n\r\n    $user->options = $options;\r\n\r\n    $user->save();\r\n\r\n当使用 `update` 方法更新 JSON 属性的单个字段时，可以使用 `->` 操作符让语法更加简洁：:\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->update(['options->key' => 'value']);\r\n\r\n<a name=\"array-object-and-collection-casting\"></a>\r\n#### 数组对象 & 集合 类型转换\r\n\r\n虽然标准的 `array` 类型转换对于许多应用程序来说已经足够了，但它确实有一些缺点。由于 `array` 类型转换返回一个基础类型，因此不可能直接改变数组键的值。例如，以下代码将触发一个 PHP 错误：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->options['key'] = $value;\r\n\r\n为了解决这个问题，Laravel 提供了一个 `AsArrayObject` 类型转换，它将 JSON 属性转换为一个 [数组对象](https://www.php.net/manual/en/class.arrayobject.php) 类。这个特性是使用 Laravel 的 [自定义类型转换](#custom-casts) 实现的，它允许 Laravel 智能地缓存和转换修改的对象，这样可以在不触发 PHP 错误的情况下修改各个键的值。要使用 `AsArrayObject` 类型转换，只需将其指定给一个属性即可：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\AsArrayObject;\r\n\r\n    /**\r\n     * 类型转换.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'options' => AsArrayObject::class,\r\n    ];\r\n\r\n类似的，Laravel 提供了一个 `AsCollection`  类型转换，它将 JSON 属性转换为 Laravel [集合](/docs/laravel/9.x/collections) 实例：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\AsCollection;\r\n\r\n    /**\r\n     * The attributes that should be cast.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'options' => AsCollection::class,\r\n    ];\r\n\r\n\r\n\r\n<a name=\"date-casting\"></a>\r\n### Date 转换\r\n\r\n默认情况下，Eloquent 会将 `created_at` 和 `updated_at` 字段转换为 [Carbon](https://github.com/briannesbitt/Carbon)实例，它继承了 PHP 原生的 `DateTime` 类并提供了各种有用的方法。你可以通过在模型的 `$casts` 属性数组中定义额外的日期类型转换，用来转换其他的日期属性。通常来说，日期应该使用 `datetime` 或 `immutable_datetime` 类型转换来转换。\r\n\r\n当使用 `date` 或 `datetime` 类型转换时，你也可以指定日期的格式。这种格式会被用在 [模型序列化为数组或者JSON](/docs/laravel/9.x/eloquent-serialization)：\r\n\r\n    /**\r\n     * The attributes that should be cast.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'created_at' => 'datetime:Y-m-d',\r\n    ];\r\n\r\n将列类型转换为日期时，可以将其值设置为 UNIX 时间戳、日期字符串（`Y-m-d`）、日期时间字符串或  `DateTime` / `Carbon` 实例。日期值将会被准确的转换并存储在数据库中。\r\n\r\n通过在模型中定义 `serializeDate` 方法，你可以自定义所有模型日期的默认序列化格式。此方法不会影响日期在数据库中存储的格式：\r\n\r\n    /**\r\n     * 为 array / JSON 序列化准备日期格式\r\n     *\r\n     * @param  \\DateTimeInterface  $date\r\n     * @return string\r\n     */\r\n    protected function serializeDate(DateTimeInterface $date)\r\n    {\r\n        return $date->format('Y-m-d');\r\n    }\r\n\r\n在模型上定义 `$dateFormat` 属性后，模型的日期将会以你指定的格式实际存储于数据库中：\r\n\r\n    /**\r\n     * 模型日期列的存储格式.\r\n     *\r\n     * @var string\r\n     */\r\n    protected $dateFormat = 'U';\r\n\r\n\r\n\r\n<a name=\"date-casting-and-timezones\"></a>\r\n#### 日期转换，序列化，& 时区\r\n\r\n默认情况下，`date` 和 `datetime` 会序列化为UTC ISO-8601格式的（ `1986-05-28T21:05:54.000000Z` ）字符串，并不会受到应用的 `timezone` 配置影响。强烈建议您始终使用此序列化格式，并不更改应用程序的 `timezone` 配置（默认 `UTC` ）以将应用程序的日期存储在UTC时区中。在整个应用程序中始终使用 UTC 时区，会使与其他 PHP 和 JavaScript 类库的互操作性更高。\r\n\r\n如果对 `date` 或 `datetime` 属性自定义了格式，例如 `datetime:Y-m-d H:i​:s`，那么在日期序列化期间将使用Carbon实例的内部时区。通常，这是应用程序的 `timezone` 配置选项中指定的时区。\r\n\r\n<a name=\"enum-casting\"></a>\r\n### 枚举转换\r\n\r\n> 注意：枚举转换仅适用于 PHP 8.1+.\r\n\r\nEloquent 还允许您将属性值强制转换为 PHP 的 [枚举](https://www.php.net/manual/en/language.enumerations.backed.php)。为此，可以在模型的 `$casts` 数组属性中指定要转换的属性和枚举：\r\n\r\n    use App\\Enums\\ServerStatus;\r\n\r\n    /**\r\n     * 要转换的属性\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'status' => ServerStatus::class,\r\n    ];\r\n\r\n在模型上定义了转换后，与属性交互时，指定的属性都将在枚举中强制转换：\r\n\r\n    if ($server->status == ServerStatus::provisioned) {\r\n        $server->status = ServerStatus::ready;\r\n\r\n        $server->save();\r\n    }\r\n\r\n\r\n\r\n<a name=\"encrypted-casting\"></a>\r\n\r\n### 加密转换\r\n\r\n`encrypted` 转换使用了 Laravel 的内置 [encryption](/docs/laravel/9.x/encryption) 功能加密模型的属性值。 此外，`encrypted:array`、`encrypted:collection`、`encrypted:object`、`AsEncryptedArrayObject` 和 `AsEncryptedCollection` 类型转换的工作方式与未加密的类型相同； 但是，正如您所料，底层值在存储在数据库中时是加密的。\r\n\r\n由于加密文本的最终长度不可预测并且比其纯文本长度要长，因此请确保关联的数据库列属性是 `TEXT` 类型或更大。此外，由于数据库中的值是加密的，您将无法查询或搜索加密的属性值。\r\n\r\n<a name=\"query-time-casting\"></a>\r\n### 查询时转换\r\n\r\n有时你可能需要在执行查询时应用强制转换，例如从表中选择原始值时。 例如，考虑以下查询：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    $users = User::select([\r\n        'users.*',\r\n        'last_posted_at' => Post::selectRaw('MAX(created_at)')\r\n                ->whereColumn('user_id', 'users.id')\r\n    ])->get();\r\n\r\n在该查询获取到的结果集中，`last_posted_at` 属性将会是一个字符串。假如我们在执行查询时进行 `datetime` 类型转换将更方便。你可以通过使用 `withCasts` 方法来完成上述操作：\r\n\r\n    $users = User::select([\r\n        'users.*',\r\n        'last_posted_at' => Post::selectRaw('MAX(created_at)')\r\n                ->whereColumn('user_id', 'users.id')\r\n    ])->withCasts([\r\n        'last_posted_at' => 'datetime'\r\n    ])->get();\r\n\r\n<a name=\"custom-casts\"></a>\r\n## 自定义类型转换\r\n\r\nLaravel 有多种内置的、有用的类型转换； 如果需要自定义的强制转换类型。 可以通过定义一个实现 `CastsAttributes` 接口的类来实现这一点。\r\n\r\n\r\n\r\n实现这个接口的类必须定义一个 `get` 和 `set` 方法。 `get` 方法负责将数据库中的原始值转换为转换值，而 `set` 方法应将转换值转换为可以存储在数据库中的原始值。 作为示例，我们将内置的 `json` 类型转换重新实现为自定义类型：\r\n\r\n    <?php\r\n\r\n    namespace App\\Casts;\r\n\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\r\n\r\n    class Json implements CastsAttributes\r\n    {\r\n        /**\r\n         * 将取出的数据进行转换\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n         * @param  string  $key\r\n         * @param  mixed  $value\r\n         * @param  array  $attributes\r\n         * @return array\r\n         */\r\n        public function get($model, $key, $value, $attributes)\r\n        {\r\n            return json_decode($value, true);\r\n        }\r\n\r\n        /**\r\n         * 转换成将要进行存储的值\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n         * @param  string  $key\r\n         * @param  array  $value\r\n         * @param  array  $attributes\r\n         * @return string\r\n         */\r\n        public function set($model, $key, $value, $attributes)\r\n        {\r\n            return json_encode($value);\r\n        }\r\n    }\r\n\r\n定义好自定义类型转换后，可以使用其类名称将其附加到模型属性里：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Casts\\Json;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 应被强制转换的属性\r\n         *\r\n         * @var array\r\n         */\r\n        protected $casts = [\r\n            'options' => Json::class,\r\n        ];\r\n    }\r\n\r\n<a name=\"value-object-casting\"></a>\r\n### 值对象转换\r\n\r\n你不仅可以将数据转换成原生的数据类型，还可以将数据转换成对象。两种自定义类型转换的定义方式非常类似。但是将数据转换成对象的自定义转换类中的 set 方法需要返回键值对数组，用于设置原始、可存储的值到对应的模型中。\r\n\r\n举个例子，定义一个自定义类型转换类用于将多个模型属性值转换成单个 `Address` 值对象，假设 `Address` 对象有两个公有属性 `lineOne` 和 `lineTwo`:\r\n\r\n\r\n\r\n例如，我们将定义一个自定义转换类，将多个模型值转换为单个「地址」值对象。 我们将假设 `Address` 值有两个公共属性：`lineOne` 和 `lineTwo`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Casts;\r\n\r\n    use App\\Models\\Address as AddressModel;\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\r\n    use InvalidArgumentException;\r\n\r\n    class Address implements CastsAttributes\r\n    {\r\n        /**\r\n         * 转换给定的值\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n         * @param  string  $key\r\n         * @param  mixed  $value\r\n         * @param  array  $attributes\r\n         * @return \\App\\Models\\Address\r\n         */\r\n        public function get($model, $key, $value, $attributes)\r\n        {\r\n            return new AddressModel(\r\n                $attributes['address_line_one'],\r\n                $attributes['address_line_two']\r\n            );\r\n        }\r\n\r\n        /**\r\n         * 准备给定值以进行存储\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n         * @param  string  $key\r\n         * @param  \\App\\Models\\Address  $value\r\n         * @param  array  $attributes\r\n         * @return array\r\n         */\r\n        public function set($model, $key, $value, $attributes)\r\n        {\r\n            if (! $value instanceof AddressModel) {\r\n                throw new InvalidArgumentException('The given value is not an Address instance.');\r\n            }\r\n\r\n            return [\r\n                'address_line_one' => $value->lineOne,\r\n                'address_line_two' => $value->lineTwo,\r\n            ];\r\n        }\r\n    }\r\n\r\n转换为值对象时，对值对象所做的任何更改都将在模型保存之前自动同步回模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->address->lineOne = 'Updated Address Value';\r\n\r\n    $user->save();\r\n\r\n> 技巧：如果你计划将包含值对象的 Eloquent 模型序列化为 JSON 或数组，那么应该在值对象上实现 `Illuminate\\Contracts\\Support\\Arrayable` 和 `JsonSerializable` 接口。\r\n\r\n<a name=\"array-json-serialization\"></a>\r\n### 数组 / JSON 序列化\r\n\r\n当使用 `toArray` 和 `toJson` 方法将 Eloquent 模型转换为数组或 JSON 时，自定义转换值对象通常会被序列化，只要它们实现 `Illuminate\\Contracts\\Support\\Arrayable` 和 `JsonSerializable` 接口。 但是，在使用第三方库提供的值对象时，你可能无法将这些接口添加到对象中。\r\n\r\n\r\n\r\n因此，你可以指定你自定义的类型转换类，它将负责序列化成值对象。为此，你自定义的类型转换类需要实现 `Illuminate\\Contracts\\Database\\Eloquent\\SerializesCastableAttributes` 接口。此接口声明类应包含 `serialize` 方法，该方法应返回值对象的序列化形式：\r\n\r\n    /**\r\n     * 获取值的序列化表示形式\r\n     *\r\n     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @param  array  $attributes\r\n     * @return mixed\r\n     */\r\n    public function serialize($model, string $key, $value, array $attributes)\r\n    {\r\n        return (string) $value;\r\n    }\r\n\r\n<a name=\"inbound-casting\"></a>\r\n### 入站转换\r\n\r\n有时候，你可能只需要对写入模型的属性值进行类型转换而不需要对从模型中获取的属性值进行任何处理。一个典型入站类型转换的例子就是 「hashing」。入站类型转换类需要实现 `CastsInboundAttributes` 接口，只需要实现 `set` 方法。\r\n\r\n    <?php\r\n\r\n    namespace App\\Casts;\r\n\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\CastsInboundAttributes;\r\n\r\n    class Hash implements CastsInboundAttributes\r\n    {\r\n        /**\r\n         * 哈希算法\r\n         *\r\n         * @var string\r\n         */\r\n        protected $algorithm;\r\n\r\n        /**\r\n         * 创建一个新的类型转换类实例\r\n         *\r\n         * @param  string|null  $algorithm\r\n         * @return void\r\n         */\r\n        public function __construct($algorithm = null)\r\n        {\r\n            $this->algorithm = $algorithm;\r\n        }\r\n\r\n        /**\r\n         * 转换成将要进行存储的值\r\n         *\r\n         * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n         * @param  string  $key\r\n         * @param  array  $value\r\n         * @param  array  $attributes\r\n         * @return string\r\n         */\r\n        public function set($model, $key, $value, $attributes)\r\n        {\r\n            return is_null($this->algorithm)\r\n                        ? bcrypt($value)\r\n                        : hash($this->algorithm, $value);\r\n        }\r\n    }\r\n\r\n<a name=\"cast-parameters\"></a>\r\n### 转换参数\r\n\r\n当将自定义类型转换附加到模型时，可以指定传入的类型转换参数。传入类型转换参数需使用 `:` 将参数与类名分隔，多个参数之间使用逗号分隔。这些参数将会传递到类型转换类的构造函数中：\r\n\r\n    /**\r\n     * The attributes that should be cast.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'secret' => Hash::class.':sha256',\r\n    ];\r\n\r\n\r\n\r\n<a name=\"castables\"></a>\r\n### 可转换\r\n\r\n如果要允许应用程序对象的值定义它们自定义转换类。除了将自定义转换类附加到你的模型之外，还可以附加一个实现 `Illuminate\\Contracts\\Database\\Eloquent\\Castable` 接口的值对象类：\r\n\r\n    use App\\Models\\Address;\r\n\r\n    protected $casts = [\r\n        'address' => Address::class,\r\n    ];\r\n\r\n实现 `Castable` 接口的对象必须定义一个 `castUsing` 方法，此方法返回的是负责将 `Castable` 类进行自定义转换的转换器类名：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\Castable;\r\n    use App\\Casts\\Address as AddressCast;\r\n\r\n    class Address implements Castable\r\n    {\r\n        /**\r\n         * 获取转换器的类名用以转换当前类型转换对象\r\n         *\r\n         * @param  array  $arguments\r\n         * @return string\r\n         */\r\n        public static function castUsing(array $arguments)\r\n        {\r\n            return AddressCast::class;\r\n        }\r\n    }\r\n\r\n使用 `Castable` 类时，仍然可以在 `$casts` 定义中提供参数。参数将传递给 `castUsing` 方法：\r\n\r\n    use App\\Models\\Address;\r\n\r\n    protected $casts = [\r\n        'address' => Address::class.':argument',\r\n    ];\r\n\r\n<a name=\"anonymous-cast-classes\"></a>\r\n#### 可转换 & 匿名类型转换类\r\n\r\n通过将 `castables` 与 PHP 的 [匿名类](https://www.php.net/manual/en/language.oop5.anonymous.php) 相结合，可以将值对象及其转换逻辑定义为单个可转换对象。为此，请从值对象的 `castUsing` 方法返回一个匿名类。匿名类应该实现 `CastsAttributes` 接口：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\Castable;\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\r\n\r\n    class Address implements Castable\r\n    {\r\n        // ...\r\n\r\n        /**\r\n         * 获取转换器类用以转换当前类型转换对象\r\n         *\r\n         * @param  array  $arguments\r\n         * @return object|string\r\n         */\r\n        public static function castUsing(array $arguments)\r\n        {\r\n            return new class implements CastsAttributes\r\n            {\r\n                public function get($model, $key, $value, $attributes)\r\n                {\r\n                    return new Address(\r\n                        $attributes['address_line_one'],\r\n                        $attributes['address_line_two']\r\n                    );\r\n                }\r\n\r\n                public function set($model, $key, $value, $attributes)\r\n                {\r\n                    return [\r\n                        'address_line_one' => $value->lineOne,\r\n                        'address_line_two' => $value->lineTwo,\r\n                    ];\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n","p":"docs/eloquent-mutators.html"},{"t":"eloquent-resources (Eloquent: API 资源)","d":"# Eloquent: API 资源\r\n\r\n- [简介](#introduction)\r\n- [生成资源](#generating-resources)\r\n- [概念综述](#concept-overview)\r\n    - [资源集合](#resource-collections)\r\n- [编写资源](#writing-resources)\r\n    - [数据包裹](#data-wrapping)\r\n    - [分页](#pagination)\r\n    - [条件属性](#conditional-attributes)\r\n    - [条件关系](#conditional-relationships)\r\n    - [添加元数据](#adding-meta-data)\r\n- [资源响应](#resource-responses)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在构建 API 时，你往往需要一个转换层来联结你的 Eloquent 模型和实际返回给用户的 JSON 响应。比如，你可能希望显示部分用户属性而不是全部，或者你可能希望在模型的 JSON 中包括某些关系。Eloquent 的资源类能够让你以更直观简便的方式将模型和模型集合转化成 JSON。\r\n\r\n当然，你可以始终使用 Eloquent 模型或集合的 `toJson` 方法将其转换为 JSON ；但是，Eloquent 的资源提供了对模型及其关系的 JSON 序列化更加精细和更加健壮的控制。\r\n\r\n<a name=\"generating-resources\"></a>\r\n## 生成资源\r\n\r\n你可以使用 `make:resource` artisan 命令来生成一个资源类。默认情况下，资源将放在应用程序的 `app/Http/Resources` 目录下。资源继承自 `Illuminate\\Http\\Resources\\Json\\JsonResource` 类：\r\n\r\n```shell\r\nphp artisan make:resource UserResource\r\n```\r\n\r\n<a name=\"generating-resource-collections\"></a>\r\n#### 资源集合\r\n\r\n除了生成转换单个模型的资源之外，你还可以生成负责转换模型集合的资源。这允许你的响应 JSON 包含与给定资源的整个集合相关的其他信息。\r\n\r\n\r\n你应该在创建资源集合时使用 `--collection` 标志来表明你要生成一个资源集合。或者，在资源名称中包含 `Collection` 一词将向 Laravel 表明它应该生成一个资源集合。资源集合继承自 `Illuminate\\Http\\Resources\\Json\\ResourceCollection` 类：\r\n\r\n```shell\r\nphp artisan make:resource User --collection\r\n\r\nphp artisan make:resource UserCollection\r\n```\r\n\r\n<a name=\"concept-overview\"></a>\r\n## 概念综述\r\n\r\n> 提示：这是对资源和资源集合的高度概述。强烈建议您阅读本文档的其他部分，以深入了解如何更好地自定义和使用资源。\r\n\r\n在深入了解如何定制化编写你的资源之前，让我们首先从高层次上了解 Laravel 中如何使用资源。一个资源类表示一个单一模型需要被转换成 JSON 格式。例如，下面是一个简单的 `UserResource` 资源类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 将资源转换为数组。\r\n         * \r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return [\r\n                'id' => $this->id,\r\n                'name' => $this->name,\r\n                'email' => $this->email,\r\n                'created_at' => $this->created_at,\r\n                'updated_at' => $this->updated_at,\r\n            ];\r\n        }\r\n    }\r\n\r\n每个资源类都定义了一个 `toArray` 方法，当资源从路由或控制器方法作为响应被调用返回时，该方法返回应该转换为 JSON 的属性数组。\r\n\r\n注意，我们可以直接使用 `$this` 变量访问模型属性。这是因为资源类将自动代理属性和方法访问到底层模型以方便访问。一旦定义了资源，你可以从路由或控制器中调用并返回它。资源通过其构造函数接受底层模型实例：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{id}', function ($id) {\r\n        return new UserResource(User::findOrFail($id));\r\n    });\r\n\r\n\r\n\r\n<a name=\"resource-collections\"></a>\r\n### 资源集合\r\n\r\n如果你要返回一个资源集合或一个分页响应，你应该在路由或控制器中创建资源实例时使用你的资源类提供的 `collection` 方法\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return UserResource::collection(User::all());\r\n    });\r\n\r\n当然了，使用如上方法你将不能添加任何附加的元数据和集合一起返回。如果你需要自定义资源集合响应，你需要创建一个专用的资源来表示集合：\r\n\r\n```shell\r\nphp artisan make:resource UserCollection\r\n```\r\n\r\n此时，你就可以轻松地自定义响应中应该包含的任何元数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * 将资源集合转换为数组\r\n\t\t *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return [\r\n                'data' => $this->collection,\r\n                'links' => [\r\n                    'self' => 'link-value',\r\n                ],\r\n            ];\r\n        }\r\n    }\r\n\r\n你可以在路由或者控制器中返回已定义的资源集合：\r\n\r\n    use App\\Http\\Resources\\UserCollection;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return new UserCollection(User::all());\r\n    });\r\n\r\n<a name=\"preserving-collection-keys\"></a>\r\n#### 保护集合的键\r\n\r\n当从路由返回一个资源集合时，Laravel 会重置集合的键，使它们按数字顺序排列。但是，您可以在资源类中添加 `preserveKeys` 属性，以指示是否应该保留集合的原始键：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 指示是否应保留资源的集合原始键。\r\n         *\r\n         * @var bool\r\n         */\r\n        public $preserveKeys = true;\r\n    }\r\n\r\n\r\n\r\n如果 `preserveKeys` 属性设置为 `true` ，那么从路由或控制器返回集合时，集合的键将会被保留：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return UserResource::collection(User::all()->keyBy->id);\r\n    });\r\n\r\n<a name=\"customizing-the-underlying-resource-class\"></a>\r\n#### 自定义基础资源类\r\n\r\n通常，资源集合的 `$this->collection` 属性会被自动填充，结果是将集合的每个项映射到其单个资源类。单个资源类被假定为资源的类名，但没有类名末尾的 `Collection` 部分。 此外，根据您的个人偏好，单个资源类可以带着后缀 `Resource` ，也可以不带。\r\n\r\n例如，`UserCollection` 会尝试将给定的用户实例映射到 `User` 或 `UserResource` 资源。想要自定义该行为，你可以重写资源集合中的 `$collects` 属性指定自定义的资源：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * The resource that this resource collects.\r\n         * 自定义资源类名\r\n         *\r\n         * @var string\r\n         */\r\n        public $collects = Member::class;\r\n    }\r\n\r\n<a name=\"writing-resources\"></a>\r\n## 编写资源\r\n\r\n> 技巧：如果您还没有阅读 [概念综述](#concept-overview)，那么在继续阅读本文档前，强烈建议您去阅读一下，会更容易理解本节的内容。\r\n\r\n从本质上说，资源的作用很简单，它只需将一个给定的模型转换为一个数组。因此，每个资源都包含一个 `toArray` 方法，这个方法会将模型的属性转换为一个 API 友好的数组，然后将该数组通过路由或控制器返回给用户：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * Transform the resource into an array.\r\n         * 将资源转换为数组\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return [\r\n                'id' => $this->id,\r\n                'name' => $this->name,\r\n                'email' => $this->email,\r\n                'created_at' => $this->created_at,\r\n                'updated_at' => $this->updated_at,\r\n            ];\r\n        }\r\n    }\r\n\r\n\r\n\r\n当 `preserveKeys` 属性设置为 `true` 时，当集合从路由或控制器返回时，集合的原始键将被保留\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return UserResource::collection(User::all()->keyBy->id);\r\n    });\r\n\r\n<a name=\"customizing-the-underlying-resource-class\"></a>\r\n#### 自定义基础资源类\r\n\r\n通常，资源集合的 `$this->collection` 属性会自动填充该集合的每个项目到其单一资源类的映射结果。单一资源类被假定为集合的类名，不包含类名末尾的 `Collection`  部分。此外，根据你的个人偏好，单一资源类可以带有或不带有 `Resource` 后缀。\r\n\r\n例如，`UserCollection` 将尝试将给定的用户实例映射到 `UserResource` 资源中。想要自定义这个行为，你可以重写资源集合的 `$collects` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * The resource that this resource collects.\r\n\t\t * collects 属性定义了资源类\r\n         *\r\n         * @var string\r\n         */\r\n        public $collects = Member::class;\r\n    }\r\n\r\n<a name=\"writing-resources\"></a>\r\n## 编写资源\r\n\r\n> 技巧：如果你还没有阅读 [概念综述](#concept-overview)，强烈建议你在继续阅读本文档之前先去阅读一下。\r\n\r\n从本质上说，资源的作用很简单，它只需要将给定的模型转换为数组。所以，每个资源都包含一个 `toArray` 方法，这个方法将模型的属性转换成一个 API 友好的数组，然后将该数组通过路由或控制器返回给用户：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * Transform the resource into an array.\r\n\t\t * 将资源转换为数组\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return [\r\n                'id' => $this->id,\r\n                'name' => $this->name,\r\n                'email' => $this->email,\r\n                'created_at' => $this->created_at,\r\n                'updated_at' => $this->updated_at,\r\n            ];\r\n        }\r\n    }\r\n\r\n\r\n\r\n创建资源之后，就可以在路由或者控制器中直接返回该资源了：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{id}', function ($id) {\r\n        return new UserResource(User::findOrFail($id));\r\n    });\r\n\r\n<a name=\"relationships\"></a>\r\n#### 关联关系\r\n\r\n如果想在响应中返回关联的资源，你可以在资源类的 `toArray` 方法中将关联关系添加上。下面的例子会展示如何将文章资源类 `PostResource` 添加到用户资源类 `UserResource` 中：\r\n\r\n    use App\\Http\\Resources\\PostResource;\r\n\r\n    /**\r\n     * Transform the resource into an array.\r\n     * 将资源转换为数组\r\n     * \r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            'posts' => PostResource::collection($this->posts),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n> 技巧：如果你希望只在关联关系被加载时才会返回，点这里查看文档 [conditional relationships](#条件关联).\r\n\r\n<a name=\"writing-resource-collections\"></a>\r\n#### 资源集合\r\n\r\nAPI 资源类将单个模型转到数组，同理，资源集合是用来将模型集合转为数组的。当然，你并不是必须要为每个类都定义一个资源集合类，因为资源类提供了 `collection` 方法用来动态的生成「临时」资源集合：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return UserResource::collection(User::all());\r\n    });\r\n\r\n如果你需要自定义资源集合返回的元数据，那就需要自己创建资源集合类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * Transform the resource collection into an array.\r\n         * 将资源集合转换成数组。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return [\r\n                'data' => $this->collection,\r\n                'links' => [\r\n                    'self' => 'link-value',\r\n                ],\r\n            ];\r\n        }\r\n    }\r\n\r\n\r\n\r\n一旦资源被定义，它可以直接从路由或控制器返回：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{id}', function ($id) {\r\n        return new UserResource(User::findOrFail($id));\r\n    });\r\n\r\n<a name=\"relationships\"></a>\r\n#### 关联关系\r\n\r\n如果你想在你的响应中包含关联的资源，你可以将它们添加到你的资源的 `toArray` 方法返回的数组中。在下面的例子中，我们将使用 `PostResource` 资源的 `collection` 方法来将用户的博客文章添加到资源响应中：\r\n\r\n    use App\\Http\\Resources\\PostResource;\r\n\r\n    /**\r\n     * Transform the resource into an array.\r\n\t * 将资源转换为数组。\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            'posts' => PostResource::collection($this->posts),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n> 技巧：如果你只希望在已经加载的关联关系中包含它们，点这里查看 [条件关联](#conditional-relationships)。\r\n\r\n<a name=\"writing-resource-collections\"></a>\r\n#### 资源集合\r\n\r\n当资源将单个模型转换为数组时，资源集合将模型集合转换为数组。当然，你并不是必须要为每个类都定义一个资源集合类，因为所有的资源都提供了一个 `collection ` 方法来动态地生成一个「临时」资源集合：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return UserResource::collection(User::all());\r\n    });\r\n\r\n当然，如果你需要自定义资源集合返回的元数据，那就需要自己创建资源集合类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * Transform the resource collection into an array.\r\n\t\t * 将资源集合转换为数组。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return [\r\n                'data' => $this->collection,\r\n                'links' => [\r\n                    'self' => 'link-value',\r\n                ],\r\n            ];\r\n        }\r\n    }\r\n\r\n\r\n\r\n和单个资源一样，你可以在路由或控制器中直接返回资源集合：\r\n\r\n    use App\\Http\\Resources\\UserCollection;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return new UserCollection(User::all());\r\n    });\r\n\r\n<a name=\"data-wrapping\"></a>\r\n### 数据包裹\r\n\r\n默认情况下，当资源响应被转换为 JSON 时，最外层的资源被包裹在 `data` 键中。因此一个典型的资源收集响应如下所示：\r\n\r\n```json\r\n{\r\n    \"data\": [\r\n        {\r\n            \"id\": 1,\r\n            \"name\": \"Eladio Schroeder Sr.\",\r\n            \"email\": \"therese28@example.com\",\r\n        },\r\n        {\r\n            \"id\": 2,\r\n            \"name\": \"Liliana Mayert\",\r\n            \"email\": \"evandervort@example.com\",\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n如果你想使用自定义键而不是 `data`，你可以在资源类上定义一个 `$wrap` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 应该应用的「数据」包装器。\r\n         *\r\n         * @var string\r\n         */\r\n        public static $wrap = 'user';\r\n    }\r\n\r\n如果你想禁用最外层资源的包裹，你应该调用基类 `Illuminate\\Http\\Resources\\Json\\JsonResource` 的 `withoutWrapping` 方法。通常，你应该从你的 `AppServiceProvider` 或其他在程序每一个请求中都会被加载的 [服务提供者](/docs/laravel/9.x/providers) 中调用这个方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function register()\r\n        {\r\n            //\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            JsonResource::withoutWrapping();\r\n        }\r\n    }\r\n\r\n> 注意：`withoutWrapping` 方法只会禁用最外层资源的包裹，不会删除你手动添加到资源集合中的 `data` 键。\r\n\r\n\r\n\r\n<a name=\"wrapping-nested-resources\"></a>\r\n#### 包裹嵌套资源\r\n\r\n你可以完全自由地决定资源关联如何被包裹。如果你希望无论怎样嵌套，所有的资源集合都包裹在一个 `data` 键中，你应该为每个资源定义一个资源集合类，并将返回的集合包裹在 `data` 键中。\r\n\r\n你可能会担心这是否会导致最外层的资源包裹在两层 `data` 键中。别担心， Laravel 永远不会让你的资源被双层包裹，所以你不必担心资源集合被多重嵌套的问题：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class CommentsCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * 将资源集合转换成数组。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return ['data' => $this->collection];\r\n        }\r\n    }\r\n\r\n<a name=\"data-wrapping-and-pagination\"></a>\r\n#### 数据包裹和分页\r\n\r\n当通过资源响应返回分页集合时，即使你调用了 `withoutWrapping` 方法，Laravel 也会将你的资源数据包裹在 `data` 键中。这是因为分页响应总会有 `meta` 和 `links` 键包含关于分页状态的信息：\r\n\r\n```json\r\n{\r\n    \"data\": [\r\n        {\r\n            \"id\": 1,\r\n            \"name\": \"Eladio Schroeder Sr.\",\r\n            \"email\": \"therese28@example.com\",\r\n        },\r\n        {\r\n            \"id\": 2,\r\n            \"name\": \"Liliana Mayert\",\r\n            \"email\": \"evandervort@example.com\",\r\n        }\r\n    ],\r\n    \"links\":{\r\n        \"first\": \"http://example.com/pagination?page=1\",\r\n        \"last\": \"http://example.com/pagination?page=1\",\r\n        \"prev\": null,\r\n        \"next\": null\r\n    },\r\n    \"meta\":{\r\n        \"current_page\": 1,\r\n        \"from\": 1,\r\n        \"last_page\": 1,\r\n        \"path\": \"http://example.com/pagination\",\r\n        \"per_page\": 15,\r\n        \"to\": 10,\r\n        \"total\": 10\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"pagination\"></a>\r\n### 分页\r\n\r\n你可以将 Laravel 分页实例传递给资源的 `collection` 方法或自定义资源集合：\r\n\r\n    use App\\Http\\Resources\\UserCollection;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return new UserCollection(User::paginate());\r\n    });\r\n\r\n\r\n\r\n分页响应中总有 `meta` 和 `links` 键包含着分页状态信息：\r\n\r\n```json\r\n{\r\n    \"data\": [\r\n        {\r\n            \"id\": 1,\r\n            \"name\": \"Eladio Schroeder Sr.\",\r\n            \"email\": \"therese28@example.com\",\r\n        },\r\n        {\r\n            \"id\": 2,\r\n            \"name\": \"Liliana Mayert\",\r\n            \"email\": \"evandervort@example.com\",\r\n        }\r\n    ],\r\n    \"links\":{\r\n        \"first\": \"http://example.com/pagination?page=1\",\r\n        \"last\": \"http://example.com/pagination?page=1\",\r\n        \"prev\": null,\r\n        \"next\": null\r\n    },\r\n    \"meta\":{\r\n        \"current_page\": 1,\r\n        \"from\": 1,\r\n        \"last_page\": 1,\r\n        \"path\": \"http://example.com/pagination\",\r\n        \"per_page\": 15,\r\n        \"to\": 10,\r\n        \"total\": 10\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"conditional-attributes\"></a>\r\n### 条件属性\r\n\r\n有些时候，你可能希望在给定条件满足时添加属性到资源响应里。例如，你可能希望如果当前用户是「管理员」时添加某个值到资源响应中。在这种情况下 Laravel 提供了一些辅助方法来帮助你解决问题。`when`方法可以被用来有条件地向资源响应添加属性：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    /**\r\n     * 将资源转换成数组\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            'secret' => $this->when(Auth::user()->isAdmin(), 'secret-value'),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n在上面这个例子中，只有当`isAdmin`方法返回 `true` 时，`secret` 键才会最终在资源响应中被返回。如果该方法返回 `false`键将会在资源响应被发送给客户端之前被删除。 `when`方法可以使你避免使用条件语句拼接数组，转而用更优雅的方式来编写你的资源。\r\n\r\n`when` 方法也接受闭包作为其第二个参数，只有在给定条件为`true` 时，才从闭包中计算返回的值：\r\n\r\n    'secret' => $this->when(Auth::user()->isAdmin(), function () {\r\n        return 'secret-value';\r\n    }),\r\n\r\n\r\n\r\n<a name=\"merging-conditional-attributes\"></a>\r\n#### 有条件地合并数据\r\n\r\n有些时候，你可能希望在给定条件满足时添加多个属性到资源响应里。在这种情况下，你可以使用`mergeWhen`方法在给定的条件为`true`时将多个属性添加到响应中：\r\n\r\n    /**\r\n     * 将资源转换成数组\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            $this->mergeWhen(Auth::user()->isAdmin(), [\r\n                'first-secret' => 'value',\r\n                'second-secret' => 'value',\r\n            ]),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n同理，如果给定的条件为`false`时，则这些属性将会在资源响应被发送给客户端之前被移除。\r\n\r\n> 注意：`mergeWhen` 方法不应该被使用在混合字符串和数字键的数组中。此外，它也不应该被使用在不按顺序排列的数字键的数组中。\r\n\r\n<a name=\"conditional-relationships\"></a>\r\n### 条件关联\r\n\r\n除了有条件地加载属性之外，你还可以根据模型关联是否已加载来有条件地在你的资源响应中包含关联。这允许你在控制器中决定加载哪些模型关联，这样你的资源可以在模型关联被加载后才添加它们。最终，这样做可以使你的资源轻松避免「N+1」查询问题。\r\n\r\n可以使用`whenLoaded`方法来有条件的加载关联。为了避免加载不必要的关联，此方法接受关联的名称而不是关联本身作为其参数：\r\n\r\n    use App\\Http\\Resources\\PostResource;\r\n\r\n    /**\r\n     * 将资源转换成数组\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            'posts' => PostResource::collection($this->whenLoaded('posts')),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n\r\n\r\n在上面这个例子中，如果关联没有被加载，则`posts`键将会在资源响应被发送给客户端之前被删除。\r\n\r\n<a name=\"conditional-pivot-information\"></a>\r\n#### 条件中间表信息\r\n\r\n除了在你的资源响应中有条件地包含关联外，你还可以使用 `whenPivotLoaded` 方法有条件地从多对多关联的中间表中添加数据。`whenPivotLoaded` 方法接受的第一个参数为中间表的名称。第二个参数是一个闭包，它定义了在模型上如果中间表信息可用时要返回的值：\r\n\r\n    /**\r\n     * 将资源转换成数组\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'expires_at' => $this->whenPivotLoaded('role_user', function () {\r\n                return $this->pivot->expires_at;\r\n            }),\r\n        ];\r\n    }\r\n\r\n如果你的关联使用的是 [自定义中间表](/docs/laravel/9.x/eloquent-relationships#defining-custom-intermediate-table-models)，你可以将中间表模型的实例作为 `whenPivotLoaded` 方法的第一个参数:\r\n\r\n    'expires_at' => $this->whenPivotLoaded(new Membership, function () {\r\n        return $this->pivot->expires_at;\r\n    }),\r\n\r\n如果你的中间表使用的是 `pivot` 以外的访问器，你可以使用 `whenPivotLoadedAs`  方法：\r\n\r\n    /**\r\n     * 将资源转换成数组\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'expires_at' => $this->whenPivotLoadedAs('subscription', 'role_user', function () {\r\n                return $this->subscription->expires_at;\r\n            }),\r\n        ];\r\n    }\r\n\r\n<a name=\"adding-meta-data\"></a>\r\n### 添加元数据\r\n\r\n一些 JSON API 标准需要你在资源和资源集合响应中添加元数据。这通常包括资源或相关资源的 `links` ，或一些关于资源本身的元数据。如果你需要返回有关资源的其他元数据，只需要将它们包含在 `toArray` 方法中即可。例如在转换资源集合时你可能需要添加 `link` 信息：\r\n\r\n    /**\r\n     * 将资源转换成数组\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'data' => $this->collection,\r\n            'links' => [\r\n                'self' => 'link-value',\r\n            ],\r\n        ];\r\n    }\r\n\r\n\r\n\r\n当添加额外的元数据到你的资源中时，你不必担心会覆盖 Laravel 在返回分页响应时自动添加的 `links` 或 `meta` 键。你添加的任何其他 `links` 会与分页响应添加的 `links` 相合并。\r\n\r\n<a name=\"top-level-meta-data\"></a>\r\n#### 顶层元数据\r\n\r\n有时候，你可能希望当资源被作为顶层资源返回时添加某些元数据到资源响应中。这通常包括整个响应的元信息。你可以在资源类中添加 `with` 方法来定义元数据。此方法应返回一个元数据数组，当资源被作为顶层资源渲染时，这个数组将会被包含在资源响应中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * 将资源集合转换成数组。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return parent::toArray($request);\r\n        }\r\n\r\n        /**\r\n         * 返回应该和资源一起返回的其他数据数组。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function with($request)\r\n        {\r\n            return [\r\n                'meta' => [\r\n                    'key' => 'value',\r\n                ],\r\n            ];\r\n        }\r\n    }\r\n\r\n<a name=\"adding-meta-data-when-constructing-resources\"></a>\r\n#### 构造资源时添加元数据\r\n\r\n你还可以在路由或者控制器中构造资源实例时添加顶层数据。所有资源都可以使用 `additional` 方法来接受应该被添加到资源响应中的数据数组：\r\n\r\n    return (new UserCollection(User::all()->load('roles')))\r\n                    ->additional(['meta' => [\r\n                        'key' => 'value',\r\n                    ]]);\r\n\r\n<a name=\"resource-responses\"></a>\r\n\r\n\r\n## 响应资源\r\n\r\n就像你知道的那样，资源可以直接在路由和控制器中被返回：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{id}', function ($id) {\r\n        return new UserResource(User::findOrFail($id));\r\n    });\r\n\r\n但有些时候，在发送给客户端前你可能需要自定义 HTTP 响应。你有两种办法。第一，你可以链式调用 `response` 方法。此方法将会返回  `Illuminate\\Http\\JsonResponse`  实例，允许你自定义响应头信息：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user', function () {\r\n        return (new UserResource(User::find(1)))\r\n                    ->response()\r\n                    ->header('X-Value', 'True');\r\n    });\r\n\r\n另外，你还可以在资源中定义一个 `withResponse` 方法。此方法将会在资源被作为顶层资源在响应时被调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 将资源转换为数组。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @return array\r\n         */\r\n        public function toArray($request)\r\n        {\r\n            return [\r\n                'id' => $this->id,\r\n            ];\r\n        }\r\n\r\n        /**\r\n         * 自定义响应信息。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Illuminate\\Http\\Response  $response\r\n         * @return void\r\n         */\r\n        public function withResponse($request, $response)\r\n        {\r\n            $response->header('X-Value', 'True');\r\n        }\r\n    }\r\n\r\n","p":"docs/eloquent-resources.html"},{"t":"eloquent-serialization (Eloquent: 序列化)","d":"\n# Eloquent: 序列化\r\n\r\n- [简介](#introduction)\r\n- [序列化模型 & 集合](#serializing-models-and-collections)\r\n    - [序列化为数组](#serializing-to-arrays)\r\n    - [序列化为 JSON](#serializing-to-json)\r\n- [隐藏 JSON 属性](#hiding-attributes-from-json)\r\n- [追加 JSON 值](#appending-values-to-json)\r\n- [序列化日期](#date-serialization)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在使用 Laravel 构建 API 时，经常需要把模型和关联转化为数组或 JSON。针对这些操作，Eloquent 提供了一些便捷方法，以及对序列化中的属性控制。\r\n\r\n> 技巧：想获得更全面处理 Eloquent 的模型和集合 JSON 序列化的方法，请查看 [Eloquent API 资源](/docs/laravel/9.x/eloquent-resources) 文档。\r\n\r\n<a name=\"serializing-models-and-collections\"></a>\r\n## 序列化模型 & 集合\r\n\r\n<a name=\"serializing-to-arrays\"></a>\r\n### 序列化为数组\r\n\r\n要转化模型及其加载的 [关联](/docs/laravel/9.x/eloquent-relationships) 为数组，可以使用 `toArray` 方法。这是一个递归的方法，因此所有的属性和关联（包括关联的关联）都将转化成数组：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::with('roles')->first();\r\n\r\n    return $user->toArray();\r\n\r\n`attributesToArray` 方法可用于将模型的属性转换为数组，但不会转换其关联：\r\n\r\n    $user = User::first();\r\n\r\n    return $user->attributesToArray();\r\n\r\n您还可以通过调用集合实例上的 `toArray` 方法，将模型的全部 [集合](/docs/laravel/9.x/eloquent-collections) 转换为数组：\r\n\r\n    $users = User::all();\r\n\r\n    return $users->toArray();\r\n\r\n<a name=\"serializing-to-json\"></a>\r\n### 序列化为 JSON\r\n\r\n您可以使用 `toJson` 方法将模型转化成 JSON。和 `toArray` 一样，`toJson` 方法也是递归的，因此所有属性和关联都会转化成 JSON, 您还可以指定由 [PHP 支持](https://secure.php.net/manual/en/function.json-encode.php)的任何  JSON 编码选项：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    return $user->toJson();\r\n\r\n    return $user->toJson(JSON_PRETTY_PRINT);\r\n\r\n\n\n或者，你也可以将模型或集合转换为字符串，模型或集合上的 `toJson` 方法会自动调用：\r\n\r\n    return (string) User::find(1);\r\n\r\n由于模型和集合在转化为字符串的时候会转成 JSON， 因此可以在应用的路由或控制器中直接返回 Eloquent 对象。Laravel 会自动将 Eloquent 模型和集合序列化为 JSON：\r\n\r\n    Route::get('users', function () {\r\n        return User::all();\r\n    });\r\n\r\n<a name=\"relationships\"></a>\r\n#### 关联关系\r\n\r\n当一个模型被转化为 JSON 的时候，它加载的关联关系也将自动转化为 JSON 对象被包含进来。同时，通过「小驼峰」定义的关联方法，关联的 JSON 属性将会是「蛇形」命名。\r\n\r\n<a name=\"hiding-attributes-from-json\"></a>\r\n## 隐藏 JSON 属性\r\n\r\n有时要将模型数组或 JSON 中的某些属性进行隐藏，比如密码。则可以在模型中添加 `$hidden` 属性。模型序列化后， `$hidden` 数组中列出的属性将不会被显示：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 数组中的属性会被隐藏。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $hidden = ['password'];\r\n    }\r\n\r\n> 技巧：隐藏关联时，需添加关联的方法名到 `$hidden` 属性中。\r\n\r\n此外，也可以使用属性 `visible` 定义一个模型数组和 JSON 可见的「白名单」。转化后的数组或 JSON 不会出现其他的属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 数组中的属性会被展示。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $visible = ['first_name', 'last_name'];\r\n    }\r\n\r\n\n\n<a name=\"temporarily-modifying-attribute-visibility\"></a>\r\n#### 临时修改可见属性\r\n\r\n如果您想要在一个模型实例中显示隐藏的属性，可以使用  `makeVisible` 方法。`makeVisible` 方法返回模型实例：\r\n\r\n    return $user->makeVisible('attribute')->toArray();\r\n\r\n相应地，如果您想要在一个模型实例中隐藏可见的属性，可以使用 `makeHidden` 方法。\r\n\r\n    return $user->makeHidden('attribute')->toArray();\r\n\r\n<a name=\"appending-values-to-json\"></a>\r\n## 追加 JSON 值\r\n\r\n有时，需要在模型转换为数组或 JSON 时添加一些数据库中不存在字段的对应属性。要实现这个功能，首先要定义一个 [访问器](/docs/laravel/9.x/eloquent-mutators)：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * Determine if the user is an administrator.\r\n         *\r\n         * @return \\Illuminate\\Database\\Eloquent\\Casts\\Attribute\r\n         */\r\n        protected function isAdmin(): Attribute\r\n        {\r\n            return new Attribute(\r\n                get: fn () => 'yes',\r\n            );\r\n        }\r\n    }\r\n\r\n然后，在模型属性 `appends` 中添加该属性名。注意，尽管访问器使用「驼峰命名法」方式定义，但是属性名通常以「蛇形命名法」的方式来引用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * The accessors to append to the model's array form.\r\n         *\r\n         * @var array\r\n         */\r\n        protected $appends = ['is_admin'];\r\n    }\r\n\r\n使用 `appends` 方法追加属性后，它将包含在模型的数组和 JSON 中。`appends` 数组中的属性也将遵循模型上配置的 `visible` 和 `hidden` 设置。\r\n\r\n\n\n<a name=\"appending-at-run-time\"></a>\r\n#### 运行时追加\r\n\r\n在运行时，您可以在单个模型实例上使用 append 方法来追加属性。或者，使用 setAppends 方法来重写整个追加属性的数组：\r\n\r\n    return $user->append('is_admin')->toArray();\r\n\r\n    return $user->setAppends(['is_admin'])->toArray();\r\n\r\n<a name=\"date-serialization\"></a>\r\n## 日期序列化\r\n\r\n<a name=\"customizing-the-default-date-format\"></a>\r\n#### 自定义默认日期格式\r\n\r\n您可以通过重写 `serializeDate` 方法来自定义默认序列化格式。此方法不会影响日期在数据库中存储的格式：\r\n\r\n    /**\r\n     * 为 array / JSON 序列化准备日期格式\r\n     *\r\n     * @param  \\DateTimeInterface  $date\r\n     * @return string\r\n     */\r\n    protected function serializeDate(DateTimeInterface $date)\r\n    {\r\n        return $date->format('Y-m-d');\r\n    }\r\n\r\n<a name=\"customizing-the-date-format-per-attribute\"></a>\r\n#### 自定义任意属性的日期格式\r\n\r\n您可以在 Eloquent 的 [属性转换](/docs/laravel/9.x/eloquent-mutators#attribute-casting) 中单独为日期属性自定义日期格式：\r\n\r\n    protected $casts = [\r\n        'birthday' => 'date:Y-m-d',\r\n        'joined_at' => 'datetime:Y-m-d H:00',\r\n    ];\r\n\n","p":"docs/eloquent-serialization.html"},{"t":"testing (测试：入门)","d":"# 测试：入门\r\n\r\n- [介绍](#introduction)\r\n- [环境](#environment)\r\n- [创建测试](#creating-tests)\r\n- [运行测试](#running-tests)\r\n    - [并行运行测试](#running-tests-in-parallel)\r\n    - [测试覆盖率报告](#reporting-test-coverage)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n`Laravel` 在构建时考虑到了测试。实际上，对 `PHPUnit` 测试的支持是开箱即用的，并且已经为你的应用程序设置了一个 `phpunit.xml` 文件。 `Laravel`还附带了方便的帮助方法，允许您对应用程序进行富有表现力的测试。\r\n\r\n默认情况下，你应用程序的`tests`目录下包含两个子目录：`Feature` 和 `Unit`。**单元测试**（`Unit`）是针对你的代码中非常少，而且相对独立的一部分代码来进行的测试。实际上，大部分单元测试都是针对单个方法进行的。在你的 `Unit` 测试目录中进行测试，不会启动你的 `Laravel` 应用程序，因此无法访问你的应用程序的数据库或其他框架服务。\r\n\r\n**功能测试**（`Feature`）能测试你的大部分代码，包括多个对象如何相互交互，甚至是对 `JSON` 端点的完整 `HTTP` 请求。 **通常，你的大多数测试应该是功能测试。这些类型的测试可以最大程度地确保你的系统作为一个整体按预期运行。**\r\n\r\n`Feature` 和 `Unit` 测试目录中都提供了一个 `ExampleTest.php` 文件。 安装新的 Laravel 应用程序后，执行 `vendor/bin/phpunit` 或 `php artisan test` 命令来运行你的测试。\r\n\r\n<a name=\"environment\"></a>\r\n## 环境\r\n\r\n运行测试时，由于 `phpunit.xml` 文件中定义了 [环境变量](/docs/laravel/9.x/configuration#environment-configuration) ，`Laravel` 会自动配置环境变量为 `testing`。`Laravel` 还会在测试时自动将会话和缓存配置到 `array` 驱动程序，这意味着在测试时不会持久化会话或缓存数据。\r\n\r\n\r\n\r\n你可以根据需要自由定义其他测试环境配置值。 `testing` 环境变量可以在应用程序的 `phpunit.xml` 文件中配置，但请确保在运行测试之前使用 `config:clear` Artisan 命令清除配置缓存！\r\n\r\n<a name=\"the-env-testing-environment-file\"></a>\r\n#### `.env.testing` 环境配置文件\r\n\r\n此外，你可以在项目的根目录中创建一个 `.env.testing` 文件。 当运行 `PHPUnit` 测试或使用 `--env=testing` 选项执行 Artisan 命令时，将不会使用 `.env` 文件，而是使用此文件。\r\n\r\n<a name=\"the-creates-application-trait\"></a>\r\n#### `CreatesApplication` Trait\r\n\r\nLaravel 包含一个 `CreatesApplication` Trait，该`Trait`应用于应用程序的基类 `TestCase` 。 这个 `trait` 包含一个 `createApplication` 方法，它在运行测试之前引导 Laravel 应用程序。 重要的是，应将此 `trait` 保留在其原始位置，因为某些功能（例如 `Laravel` 的并行测试功能）依赖于它。\r\n\r\n<a name=\"creating-tests\"></a>\r\n## 创建测试\r\n\r\n要创建新的测试用例，请使用Artisan 命令： `make:test` 。 默认情况下，测试将放置在 `tests/Feature` 目录中：\r\n\r\n```shell\r\nphp artisan make:test UserTest\r\n```\r\n\r\n如果想在 `tests/Unit` 目录中创建一个测试，你可以在执行 `make:test` 命令时使用 `--unit` 选项：\r\n\r\n```shell\r\nphp artisan make:test UserTest --unit\r\n```\r\n\r\n如果想创建一个 [Pest PHP](https://pestphp.com) 测试, 你可以为 `make:test` 命令提供 `--pest` 选项：\r\n\r\n```shell\r\nphp artisan make:test UserTest --pest\r\nphp artisan make:test UserTest --unit --pest\r\n```\r\n\r\n> 技巧：可以使用 [Stub 定制](/docs/laravel/9.x/artisan#stub-customization)来自定义测试。\r\n\r\n\r\n\r\n生成测试后，你可以像通常使用 [PHPUnit](https://phpunit.de) 那样定义测试方法。要运行测试，请从终端执行`vendor/bin/phpunit` 或 `php artisan test` 命令：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Unit;\r\n\r\n    use PHPUnit\\Framework\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基础测试样例\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_basic_test()\r\n        {\r\n            $this->assertTrue(true);\r\n        }\r\n    }\r\n\r\n> 注意：如果你在测试类中定义自己的 `setUp` 或 `tearDown` 方法，请务必在父类上调用各自的 `parent::setUp()` 或 `parent::tearDown()` 方法。\r\n\r\n<a name=\"running-tests\"></a>\r\n## 运行测试\r\n\r\n正如前面提到的，编写测试后，可以使用 `phpunit` 命令来执行测试：\r\n\r\n    ./vendor/bin/phpunit\r\n\r\n除了 `phpunit` 命令，你还可以使用 `test` Artisan 命令来运行你的测试。 Artisan 测试运行器提供了详细的测试报告，以简化开发和调试：\r\n\r\n    php artisan test\r\n\r\n任何可以传递给 `phpunit` 命令的参数也可以传递给 Artisan `test` 命令：\r\n\r\n    php artisan test --testsuite=Feature --stop-on-failure\r\n\r\n<a name=\"running-tests-in-parallel\"></a>\r\n### 并行运行测试\r\n\r\n默认情况下，`Laravel` 和 `PHPUnit` 在执行测试时，是在单进程中按照先后顺序执行的。除此之外，通过多个进程同时运行测试，则可以大大减少运行测试所需的时间。首先，请确保你的应用程序已依赖于 `^5.3` 或更高版本的 `nunomaduro/collision` 依赖包。然后，在执行 `test` Artisan 命令时，请加入 `--parallel`  选项：\r\n\r\n    php artisan test --parallel\r\n\r\n\r\n\r\n默认情况下，`Laravel` 将创建与计算机上可用 CPU 内核数量一样多的进程。但是，你可以使用 `--processes` 选项来调整进程数：\r\n\r\n    php artisan test --parallel --processes=4\r\n\r\n> 注意：在并行测试时，某些 PHPUnit 选项（例如 `--do-not-cache-result` ）可能不可用。\r\n\r\n<a name=\"parallel-testing-and-databases\"></a>\r\n#### 并行测试和数据库\r\n\r\n`Laravel` 在执行并行测试时，自动为每个进程创建并迁移生成一个测试数据库。这些测试数据库将以每个进程唯一的进程令牌作为后缀。例如，如果你有两个并行的测试进程，`Laravel` 将创建并使用 `your_db_test_1` 和 `your_db_test_2` 测试数据库。\r\n\r\n默认情况下，在多次调用 `test` Artisan 命令时，上一次的测试数据库依然存在，以便下一次的 `test` 命令可以再次使用它们。但是，你可以使用 `--recreate-databases` 选项重新创建它们：\r\n\r\n    php artisan test --parallel --recreate-databases\r\n\r\n<a name=\"parallel-testing-hooks\"></a>\r\n#### 并行测试钩子\r\n\r\n有时，你可能需要为应用程序测试准备某些资源，以便可以将它们安全地用于多个测试进程。\r\n\r\n使用 `ParallelTesting` 门面，你就可以在进程或测试用例的 `setUp` 和 `tearDown` 上指定要执行的代码。给定的闭包将分别接收包含进程令牌和当前测试用例的 `$token` 和 `$testCase` 变量：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Artisan;\r\n    use Illuminate\\Support\\Facades\\ParallelTesting;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            ParallelTesting::setUpProcess(function ($token) {\r\n                // ...\r\n            });\r\n\r\n            ParallelTesting::setUpTestCase(function ($token, $testCase) {\r\n                // ...\r\n            });\r\n\r\n            // 在创建测试数据库时执行……\r\n            ParallelTesting::setUpTestDatabase(function ($database, $token) {\r\n                Artisan::call('db:seed');\r\n            });\r\n\r\n            ParallelTesting::tearDownTestCase(function ($token, $testCase) {\r\n                // ...\r\n            });\r\n\r\n            ParallelTesting::tearDownProcess(function ($token) {\r\n                // ...\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"accessing-the-parallel-testing-token\"></a>\r\n#### 访问并行测试令牌\r\n\r\n如果你想从应用程序的测试代码中的任何其他位置访问当前的并行进程的 `token`，则可以使用 `token` 方法。该令牌（`token`）是单个测试进程的唯一字符串标识符，可用于在并行测试过程中划分资源。例如，`Laravel` 自动用此令牌值作为每个并行测试进程创建的测试数据库名的后缀：\r\n\r\n    $token = ParallelTesting::token();\r\n\r\n<a name=\"reporting-test-coverage\"></a>\r\n### 报告测试覆盖率\r\n\r\n> 注意：这个功能需要 [Xdebug](https://xdebug.org) 或 [PCOV](https://pecl.php.net/package/pcov)。\r\n\r\n在运行测试时，你可能需要确定测试用例是否真的测到了某些程序代码，以及在运行测试时究竟使用了多少应用程序代码。要实现这一点，你可以在调用 `test` 命令时，增加一个 `--coverage` 选项：\r\n\r\n    php artisan test --coverage\r\n\r\n<a name=\"enforcing-a-minimum-coverage-threshold\"></a>\r\n#### 最小覆盖率阈值限制\r\n\r\n你可以使用 `--min` 选项来为你的应用程序定义一个最小测试覆盖率阈值。如果不满足此阈值，测试套件将失败：\r\n\r\n    php artisan test --coverage --min=80.3\r\n\r\n","p":"docs/testing.html"},{"t":"http-tests (HTTP 测试)","d":"# HTTP 测试\r\n\r\n- [简介](#简介)\r\n- [创建请求](#创建请求)\r\n    - [自定义请求头](#customizing-request-headers)\r\n    - [Cookies](#cookies)\r\n    - [会话 / 认证](#session-and-authentication)\r\n    - [调试响应](#debugging-responses)\r\n    - [异常处理](#exception-handling)\r\n- [测试 JSON APIs](#testing-json-apis)\r\n    - [流畅 JSON 测试](#fluent-json-testing)\r\n- [测试文件上传](#testing-file-uploads)\r\n- [测试视图](#testing-views)\r\n    - [渲染切面 & 组件](#rendering-blade-and-components)\r\n- [可用断言](#available-assertions)\r\n    - [回应断言](#response-assertions)\r\n    - [身份验证断言](#authentication-assertions)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel提供了一个非常流畅的API，用于向应用程序发出HTTP请求并检查响应。例如，看看下面定义的特性测试:\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本的测试示例.\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_a_basic_request()\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            $response->assertStatus(200);\r\n        }\r\n    }\r\n\r\n`get`方法向应用程序发出`Get`请求，而`assertStatus`方法则断言返回的响应应该具有给定的HTTP状态代码。除了这个简单的断言之外，Laravel还包含各种用于检查响应头、内容、JSON结构等的断言。\r\n\r\n<a name=\"making-requests\"></a>\r\n## 创建请求\r\n\r\n要向应用程序发出请求，可以在测试中调用`get`、`post`、`put`、`patch`或`delete`方法。这些方法实际上不会向应用程序发出“真正的” HTTP请求。相反，整个网络请求是在内部模拟的.\r\n\r\n\r\n测试请求方法不返回`Illuminate\\Http\\Response`实例，而是返回`Illuminate\\Testing\\TestResponse`实例，该实例提供[各种有用的断言](##available-assertions),允许您检查应用程序的响应:\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本的测试示例.\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_a_basic_request()\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            $response->assertStatus(200);\r\n        }\r\n    }\r\n\r\n\r\n\r\n通常，您的每个测试应该只向您的应用发出一个请求。如果在单个测试方法中执行多个请求，则可能会出现意外行为。\r\n\r\n> 技巧：为了方便起见，运行测试时会自动禁用 CSRF 中间件。\r\n\r\n<a name=\"customizing-request-headers\"></a>\r\n### 自定义请求头\r\n\r\n您可以使用此 `withHeaders` 方法自定义请求的标头，然后再将其发送到应用程序。这使您可以将任何想要的自定义标头添加到请求中：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 一个基本的功能测试示例\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_interacting_with_headers()\r\n        {\r\n            $response = $this->withHeaders([\r\n                'X-Header' => 'Value',\r\n            ])->post('/user', ['name' => 'Sally']);\r\n\r\n            $response->assertStatus(201);\r\n        }\r\n    }\r\n\r\n<a name=\"cookies\"></a>\r\n### Cookies\r\n\r\n在发送请求前你可以使用 `withCookie` 或 `withCookies` 方法设置 cookie 。`withCookie` 接受 cookie 的名称和值这两个参数，而 `withCookies` 方法接受一个名称 / 值对数组：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_interacting_with_cookies()\r\n        {\r\n            $response = $this->withCookie('color', 'blue')->get('/');\r\n\r\n            $response = $this->withCookies([\r\n                'color' => 'blue',\r\n                'name' => 'Taylor',\r\n            ])->get('/');\r\n        }\r\n    }\r\n\r\n<a name=\"session-and-authentication\"></a>\r\n### Session / Authentication\r\n\r\nLaravel 提供了几个可在 HTTP 测试时使用 Session 的辅助函数。首先，你需要传递一个数组给 `withSession` 方法来设置 session 数据。这样在应用程序的测试请求发送之前，就会先去给数据加载 session：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_interacting_with_the_session()\r\n        {\r\n            $response = $this->withSession(['banned' => false])->get('/');\r\n        }\r\n    }\r\n\r\n\r\n\r\nLaravel 的 session 通常用于维护当前已验证用户的状态。因此，`actingAs` 方法提供了一种将给定用户作为当前用户进行身份验证的便捷方法。例如， 我们可以使用 [工厂模式](/docs/laravel/9.x/database-testing#writing-factories) 生成并验证用户:\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Models\\User;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_an_action_that_requires_authentication()\r\n        {\r\n            $user = User::factory()->create();\r\n\r\n            $response = $this->actingAs($user)\r\n                             ->withSession(['banned' => false])\r\n                             ->get('/');\r\n        }\r\n    }\r\n\r\n你也可以通过传递看守器名称作为 `actingAs` 方法的第二参数以指定用户通过哪种看守器来认证：\r\n\r\n    $this->actingAs($user, 'web')\r\n\r\n<a name=\"debugging-responses\"></a>\r\n### 调试响应\r\n\r\n在向您的应用程序发出测试请求之后，可以使用 `dump`、`dumpHeaders` 和 `dumpSession` 方法来检查和调试响应内容：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 一个最基础的测试例子\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_basic_test()\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            $response->dumpHeaders();\r\n\r\n            $response->dumpSession();\r\n\r\n            $response->dump();\r\n        }\r\n    }\r\n\r\n或者，你可以使用 `dd`、`ddHeaders` 和 `ddSession` 方法转储有关响应的信息，然后停止执行：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例子\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_basic_test()\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            $response->ddHeaders();\r\n\r\n            $response->ddSession();\r\n\r\n            $response->dd();\r\n        }\r\n    }\r\n\r\n<a name=\"exception-handling\"></a>\r\n### 异常处理\r\n\r\n有时你可能想要测试你的应用程序是否引发了特定异常。为了确保异常不会被 Laravel 的异常处理程序捕获并作为 HTTP 响应返回，可以在发出请求之前调用 `withoutExceptionHandling` 方法：\r\n\r\n    $response = $this->withoutExceptionHandling()->get('/');\r\n\r\n\r\n\r\n此外，如果想确保你的应用程序没有使用 PHP 语言或你的应用程序正在使用的库已弃用的功能，你可以在发出请求之前调用 `withoutDeprecationHandling` 方法。禁用弃用处理时，弃用警告将转换为异常，从而导致你的测试失败：\r\n\r\n    $response = $this->withoutDeprecationHandling()->get('/');\r\n\r\n<a name=\"testing-json-apis\"></a>\r\n## 测试 JSON APIs\r\n\r\nLaravel 也提供了几个辅助函数来测试 JSON APIs 和其响应。例如，`json`、`getJson`、`postJson`、`putJson`、`patchJson`、`deleteJson` 以及 `optionsJson` 可以被用于发送各种 HTTP 动作。你也可以轻松地将数据和请求头传递到这些方法中。首先，让我们实现一个测试示例， 发送 `POST` 请求到 `/api/user`，并断言返回的期望数据：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_making_an_api_request()\r\n        {\r\n            $response = $this->postJson('/api/user', ['name' => 'Sally']);\r\n\r\n            $response\r\n                ->assertStatus(201)\r\n                ->assertJson([\r\n                    'created' => true,\r\n                ]);\r\n        }\r\n    }\r\n\r\n此外，JSON 响应数据可以作为响应上的数组变量进行访问，从而使你可以方便地检查 JSON 响应中返回的各个值：\r\n\r\n    $this->assertTrue($response['created']);\r\n\r\n> 技巧：`assertJson` 方法将响应转换为数组，并利用 `PHPUnit::assertArraySubset` 验证给定数组是否存在于应用程序返回的 JSON 响应中。因此，如果 JSON 响应中还有其他属性，则只要存在给定的片段，此测试仍将通过。\r\n\r\n\r\n\r\n<a name=\"verifying-exact-match\"></a>\r\n#### 验证 JSON 完全匹配\r\n\r\n如前所述，`assertJson` 方法可用于断言 JSON 响应中存在 JSON 片段。如果您想验证给定数组是否与应用程序返回的 JSON **完全匹配**，则应使用 `assertExactJson` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 一个基本的功能测试示例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_asserting_an_exact_json_match()\r\n        {\r\n            $response = $this->postJson('/user', ['name' => 'Sally']);\r\n\r\n            $response\r\n                ->assertStatus(201)\r\n                ->assertExactJson([\r\n                    'created' => true,\r\n                ]);\r\n        }\r\n    }\r\n\r\n<a name=\"verifying-json-paths\"></a>\r\n#### 验证 JSON 路径\r\n\r\n如果你想验证 JSON 响应是否包含指定路径上的某些给定数据，可以使用 `assertJsonPath` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 一个基本的功能测试示例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_asserting_a_json_paths_value()\r\n        {\r\n            $response = $this->postJson('/user', ['name' => 'Sally']);\r\n\r\n            $response\r\n                ->assertStatus(201)\r\n                ->assertJsonPath('team.owner.name', 'Darian');\r\n        }\r\n    }\r\n\r\n<a name=\"fluent-json-testing\"></a>\r\n### JSON 流式测试\r\n\r\nLaravel 还提供了一种漂亮的方式来流畅地测试应用程序的 JSON 响应。首先，将闭包传递给 `assertJson` 方法。这个闭包将使用 `Illuminate\\Testing\\Fluent\\AssertableJson` 的实例调用，该实例可用于对应用程序返回的 JSON 进行断言。 `where` 方法可用于对 JSON 的特定属性进行断言，而 `missing` 方法可用于断言 JSON 中缺少特定属性：\r\n    use Illuminate\\Testing\\Fluent\\AssertableJson;\r\n\r\n    /**\r\n     * 一个基本的功能测试示例。\r\n     *\r\n     * @return void\r\n     */\r\n    public function test_fluent_json()\r\n    {\r\n        $response = $this->getJson('/users/1');\r\n\r\n        $response\r\n            ->assertJson(fn (AssertableJson $json) =>\r\n                $json->where('id', 1)\r\n                     ->where('name', 'Victoria Faith')\r\n                     ->missing('password')\r\n                     ->etc()\r\n            );\r\n    }\r\n\r\n\r\n\r\n#### 了解 `etc` 方法\r\n\r\n在上面的示例中，你可能已经注意到我们在断言链的末尾调用了 `etc` 方法。该方法通知 Laravel 在 JSON 对象上可能存在其他属性。如果未使用 `etc` 方法，则如果 JSON 对象上存在你未对其进行断言的其他属性，则测试将失败。\r\n\r\n此行为背后的目的是通过强制你明确对属性做出断言或通过 `etc` 方法明确允许其他属性来保护你避免无意中在 JSON 响应中暴露敏感信息。\r\n\r\n<a name=\"asserting-json-attribute-presence-and-absence\"></a>\r\n#### 断言属性存在/不存在\r\n\r\n要断言属性存在或不存在，可以使用 `has` 和 `missing` 方法：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->has('data')\r\n             ->missing('message')\r\n    );\r\n\r\n此外，`hasAll` 和 `missingAll` 方法允许同时断言多个属性的存在或不存在：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->hasAll('status', 'data')\r\n             ->missingAll('message', 'code')\r\n    );\r\n\r\n你可以使用 `hasAny` 方法来确定是否存在给定属性列表中的至少一个：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->has('status')\r\n             ->hasAny('data', 'message', 'code')\r\n    );\r\n\r\n<a name=\"asserting-against-json-collections\"></a>\r\n#### 断言反对 JSON 集合\r\n\r\n通常，你的路由将返回一个 JSON 响应，其中包含多个项目，例如多个用户：\r\n\r\n    Route::get('/users', function () {\r\n        return User::all();\r\n    });\r\n\r\n在这些情况下，我们可以使用 fluent JSON 对象的 `has` 方法对响应中包含的用户进行断言。例如，让我们断言 JSON 响应包含三个用户。接下来，我们将使用 `first` 方法对集合中的第一个用户进行一些断言。 `first` 方法接受一个闭包，该闭包接收另一个可断言的 JSON 字符串，我们可以使用它来对 JSON 集合中的第一个对象进行断言：\r\n\r\n    $response\r\n        ->assertJson(fn (AssertableJson $json) =>\r\n            $json->has(3)\r\n                 ->first(fn ($json) =>\r\n                    $json->where('id', 1)\r\n                         ->where('name', 'Victoria Faith')\r\n                         ->missing('password')\r\n                         ->etc()\r\n                 )\r\n        );\r\n\r\n\r\n\r\n<a name=\"scoping-json-collection-assertions\"></a>\r\n#### JSON 集合范围断言\r\n\r\n有时，你的应用程序的路由将返回分配有命名键的 JSON 集合：\r\n\r\n    Route::get('/users', function () {\r\n        return [\r\n            'meta' => [...],\r\n            'users' => User::all(),\r\n        ];\r\n    })\r\n\r\n在测试这些路由时，你可以使用 `has` 方法来断言集合中的项目数。此外，你可以使用 `has` 方法来确定断言链的范围：\r\n\r\n    $response\r\n        ->assertJson(fn (AssertableJson $json) =>\r\n            $json->has('meta')\r\n                 ->has('users', 3)\r\n                 ->has('users.0', fn ($json) =>\r\n                    $json->where('id', 1)\r\n                         ->where('name', 'Victoria Faith')\r\n                         ->missing('password')\r\n                         ->etc()\r\n                 )\r\n        );\r\n\r\n但是，你可以进行一次调用，提供一个闭包作为其第三个参数，而不是对 `has` 方法进行两次单独调用来断言 `users` 集合。这样做时，将自动调用闭包并将其范围限定为集合中的第一项：\r\n\r\n    $response\r\n        ->assertJson(fn (AssertableJson $json) =>\r\n            $json->has('meta')\r\n                 ->has('users', 3, fn ($json) =>\r\n                    $json->where('id', 1)\r\n                         ->where('name', 'Victoria Faith')\r\n                         ->missing('password')\r\n                         ->etc()\r\n                 )\r\n        );\r\n\r\n<a name=\"asserting-json-types\"></a>\r\n#### 断言 JSON 类型\r\n\r\n你可能只想断言 JSON 响应中的属性属于某种类型。 `Illuminate\\Testing\\Fluent\\AssertableJson` 类提供了 `whereType` 和 `whereAllType` 方法来做到这一点：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->whereType('id', 'integer')\r\n             ->whereAllType([\r\n                'users.0.name' => 'string',\r\n                'meta' => 'array'\r\n            ])\r\n    );\r\n\r\n你可以使用 `|` 字符指定多种类型，或者将类型数组作为第二个参数传递给 `whereType` 方法。如果响应值为任何列出的类型，则断言将成功：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->whereType('name', 'string|null')\r\n             ->whereType('id', ['string', 'integer'])\r\n    );\r\n\r\n\r\n\r\n`whereType` 和 `whereAllType` 方法识别以下类型：`string`、`integer`、`double`、`boolean`、`array` 和 `null`。\r\n\r\n<a name=\"testing-file-uploads\"></a>\r\n## 测试文件上传\r\n\r\n`Illuminate\\Http\\UploadedFile` 提供了一个 `fake` 方法用于生成虚拟的文件或者图像以供测试之用。它可以和 `Storage` facade 的 `fake` 方法相结合，大幅度简化了文件上传测试。举个例子，你可以结合这两者的功能非常方便地进行头像上传表单测试：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Http\\UploadedFile;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_avatars_can_be_uploaded()\r\n        {\r\n            Storage::fake('avatars');\r\n\r\n            $file = UploadedFile::fake()->image('avatar.jpg');\r\n\r\n            $response = $this->post('/avatar', [\r\n                'avatar' => $file,\r\n            ]);\r\n\r\n            Storage::disk('avatars')->assertExists($file->hashName());\r\n        }\r\n    }\r\n\r\n如果你想断言一个给定的文件不存在，则可以使用由 `Storage` facade 提供的 `AssertMissing` 方法：\r\n\r\n    Storage::fake('avatars');\r\n\r\n    // ...\r\n\r\n    Storage::disk('avatars')->assertMissing('missing.jpg');\r\n\r\n<a name=\"fake-file-customization\"></a>\r\n#### 虚拟文件定制\r\n\r\n在使用 `fake` 方法创建文件时，你可以指定图像的宽高以及大小，从而更好的验证测试规则：\r\n\r\n    UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);\r\n\r\n除创建图像外，你也可以用 `create` 方法创建其他类型的文件：\r\n\r\n    UploadedFile::fake()->create('document.pdf', $sizeInKilobytes);\r\n\r\n如果需要，可以向该方法传递一个 `$mimeType` 参数，以显式定义文件应返回的 MIME 类型：\r\n\r\n    UploadedFile::fake()->create(\r\n        'document.pdf', $sizeInKilobytes, 'application/pdf'\r\n    );\r\n\r\n\r\n\r\n<a name=\"testing-views\"></a>\r\n## 测试视图\r\n\r\nLaravel 允许在不向应用程序发出模拟 HTTP 请求的情况下独立呈现视图。为此，可以在测试中使用 `view` 方法。`view` 方法接受视图名称和一个可选的数据数组。这个方法返回一个 `Illuminate\\Testing\\TestView` 的实例，它提供了几个方法来方便地断言视图的内容：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_a_welcome_view_can_be_rendered()\r\n        {\r\n            $view = $this->view('welcome', ['name' => 'Taylor']);\r\n\r\n            $view->assertSee('Taylor');\r\n        }\r\n    }\r\n\r\n`TestView` 对象提供了以下断言方法：`assertSee`、`assertSeeInOrder`、`assertSeeText`、`assertSeeTextInOrder`、`assertDontSee` 和 `assertDontSeeText`。\r\n\r\n如果需要，你可以通过将 `TestView` 实例转换为一个字符串获得原始的视图内容：\r\n\r\n    $contents = (string) $this->view('welcome');\r\n\r\n<a name=\"sharing-errors\"></a>\r\n#### 共享错误\r\n\r\n一些视图可能依赖于 Laravel 提供的 [全局错误包](/docs/laravel/9.x/validation#quick-displaying-the-validation-errors) 中共享的错误。要在错误包中生成错误消息，可以使用 `withViewErrors` 方法：\r\n\r\n    $view = $this->withViewErrors([\r\n        'name' => ['Please provide a valid name.']\r\n    ])->view('form');\r\n\r\n    $view->assertSee('Please provide a valid name.');\r\n\r\n<a name=\"rendering-blade-and-components\"></a>\r\n### 渲染模板 & 组件\r\n\r\n必要的话，你可以使用 `blade` 方法来计算和呈现原始的 [Blade](/docs/laravel/9.x/blade) 字符串。与 `view` 方法一样，`blade` 方法返回的是 `Illuminate\\Testing\\TestView` 的实例:\r\n\r\n    $view = $this->blade(\r\n        '<x-component :name=\"$name\" />',\r\n        ['name' => 'Taylor']\r\n    );\r\n\r\n    $view->assertSee('Taylor');\r\n\r\n您可以使用 `component` 方法来评估和渲染 [Blade组件](/docs/laravel/9.x/blade#components)。类似于 `view` 方法，`component` 方法返回一个 `Illuminate\\Testing\\TestView` 的实例：\r\n\r\n    $view = $this->component(Profile::class, ['name' => 'Taylor']);\r\n\r\n    $view->assertSee('Taylor');\r\n\r\n\r\n\r\n<a name=\"available-assertions\"></a>\r\n## 可用断言\r\n\r\n<a name=\"response-assertions\"></a>\r\n### 响应断言\r\n\r\nLaravel的 `Illuminate \\ Testing \\ TestResponse` 类提供了各种自定义断言方法，您可以在测试应用程序时使用它们。可以在由 `json`、`get`、`post`、`put` 和 `delete` 方法返回的响应上访问这些断言：\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        column-count: 2; -moz-column-count: 2; -webkit-column-count: 2;\r\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[assertCookie](#assert-cookie)\r\n[assertCookieExpired](#assert-cookie-expired)\r\n[assertCookieNotExpired](#assert-cookie-not-expired)\r\n[assertCookieMissing](#assert-cookie-missing)\r\n[assertCreated](#assert-created)\r\n[assertDontSee](#assert-dont-see)\r\n[assertDontSeeText](#assert-dont-see-text)\r\n[assertDownload](#assert-download)\r\n[assertExactJson](#assert-exact-json)\r\n[assertForbidden](#assert-forbidden)\r\n[assertHeader](#assert-header)\r\n[assertHeaderMissing](#assert-header-missing)\r\n[assertJson](#assert-json)\r\n[assertJsonCount](#assert-json-count)\r\n[assertJsonFragment](#assert-json-fragment)\r\n[assertJsonMissing](#assert-json-missing)\r\n[assertJsonMissingExact](#assert-json-missing-exact)\r\n[assertJsonMissingValidationErrors](#assert-json-missing-validation-errors)\r\n[assertJsonPath](#assert-json-path)\r\n[assertJsonStructure](#assert-json-structure)\r\n[assertJsonValidationErrors](#assert-json-validation-errors)\r\n[assertJsonValidationErrorFor](#assert-json-validation-error-for)\r\n[assertLocation](#assert-location)\r\n[assertNoContent](#assert-no-content)\r\n[assertNotFound](#assert-not-found)\r\n[assertOk](#assert-ok)\r\n[assertPlainCookie](#assert-plain-cookie)\r\n[assertRedirect](#assert-redirect)\r\n[assertRedirectContains](#assert-redirect-contains)\r\n[assertRedirectToSignedRoute](#assert-redirect-to-signed-route)\r\n[assertSee](#assert-see)\r\n[assertSeeInOrder](#assert-see-in-order)\r\n[assertSeeText](#assert-see-text)\r\n[assertSeeTextInOrder](#assert-see-text-in-order)\r\n[assertSessionHas](#assert-session-has)\r\n[assertSessionHasInput](#assert-session-has-input)\r\n[assertSessionHasAll](#assert-session-has-all)\r\n[assertSessionHasErrors](#assert-session-has-errors)\r\n[assertSessionHasErrorsIn](#assert-session-has-errors-in)\r\n[assertSessionHasNoErrors](#assert-session-has-no-errors)\r\n[assertSessionDoesntHaveErrors](#assert-session-doesnt-have-errors)\r\n[assertSessionMissing](#assert-session-missing)\r\n[assertSimilarJson](#assert-similar-json)\r\n[assertStatus](#assert-status)\r\n[assertSuccessful](#assert-successful)\r\n[assertUnauthorized](#assert-unauthorized)\r\n[assertUnprocessable](#assert-unprocessable)\r\n[assertValid](#assert-valid)\r\n[assertInvalid](#assert-invalid)\r\n[assertViewHas](#assert-view-has)\r\n[assertViewHasAll](#assert-view-has-all)\r\n[assertViewIs](#assert-view-is)\r\n[assertViewMissing](#assert-view-missing)\r\n\r\n</div>\r\n\r\n<a name=\"assert-cookie\"></a>\r\n#### assertCookie\r\n\r\n断言响应中包含给定的 cookie：\r\n\r\n    $response->assertCookie($cookieName, $value = null);\r\n\r\n<a name=\"assert-cookie-expired\"></a>\r\n#### assertCookieExpired\r\n\r\n断言响应包含给定的过期的 cookie：\r\n\r\n    $response->assertCookieExpired($cookieName);\r\n\r\n<a name=\"assert-cookie-not-expired\"></a>\r\n#### assertCookieNotExpired\r\n\r\n断言响应包含给定的未过期的 cookie：\r\n\r\n    $response->assertCookieNotExpired($cookieName);\r\n\r\n<a name=\"assert-cookie-missing\"></a>\r\n#### assertCookieMissing\r\n\r\n断言响应不包含给定的 cookie:\r\n\r\n    $response->assertCookieMissing($cookieName);\r\n\r\n\r\n\r\n<a name=\"assert-created\"></a>\r\n#### assertCreated\r\n\r\n断言做状态代码为 201 的响应：\r\n\r\n    $response->assertCreated();\r\n\r\n<a name=\"assert-dont-see\"></a>\r\n#### assertDontSee\r\n\r\n断言给定的字符串不包含在响应中。除非传递第二个参数 `false`，否则此断言将给定字符串进行转义后匹配：\r\n\r\n    $response->assertDontSee($value, $escaped = true);\r\n\r\n<a name=\"assert-dont-see-text\"></a>\r\n#### assertDontSeeText\r\n\r\n断言给定的字符串不包含在响应文本中。除非你传递第二个参数 `false`，否则该断言将自动转义给定的字符串。该方法将在做出断言之前将响应内容传递给 PHP 的 `strip_tags` 函数：\r\n\r\n    $response->assertDontSeeText($value, $escaped = true);\r\n\r\n<a name=\"assert-download\"></a>\r\n#### assertDownload\r\n\r\n断言响应是「下载」。通常，这意味着返回响应的调用路由返回了 `Response::download` 响应、`BinaryFileResponse` 或 `Storage::download` 响应：\r\n\r\n    $response->assertDownload();\r\n\r\n如果你愿意，你可以断言可下载的文件被分配了一个给定的文件名：\r\n\r\n    $response->assertDownload('image.jpg');\r\n\r\n<a name=\"assert-exact-json\"></a>\r\n#### assertExactJson\r\n\r\n断言响应包含与给定 JSON 数据的完全匹配：\r\n\r\n    $response->assertExactJson(array $data);\r\n\r\n<a name=\"assert-forbidden\"></a>\r\n#### assertForbidden\r\n\r\n断言响应中有禁止访问 (403) 状态码：\r\n\r\n    $response->assertForbidden();\r\n\r\n<a name=\"assert-header\"></a>\r\n#### assertHeader\r\n\r\n断言给定的 header 在响应中存在：\r\n\r\n    $response->assertHeader($headerName, $value = null);\r\n\r\n<a name=\"assert-header-missing\"></a>\r\n#### assertHeaderMissing\r\n\r\n断言给定的 header 在响应中不存在：\r\n\r\n    $response->assertHeaderMissing($headerName);\r\n\r\n<a name=\"assert-json\"></a>\r\n#### assertJson\r\n\r\n\r\n\r\n断言响应包含给定的 JSON 数据：\r\n\r\n    $response->assertJson(array $data, $strict = false);\r\n\r\n`AssertJson` 方法将响应转换为数组，并利用 `PHPUnit::assertArraySubset` 验证给定数组是否存在于应用程序返回的 JSON 响应中。因此，如果 JSON 响应中还有其他属性，则只要存在给定的片段，此测试仍将通过。\r\n\r\n<a name=\"assert-json-count\"></a>\r\n#### assertJsonCount\r\n\r\n断言响应 JSON 中有一个数组，其中包含给定键的预期元素数量：\r\n\r\n    $response->assertJsonCount($count, $key = null);\r\n\r\n<a name=\"assert-json-fragment\"></a>\r\n#### assertJsonFragment\r\n\r\n断言响应包含给定 JSON 片段：\r\n\r\n    Route::get('/users', function () {\r\n        return [\r\n            'users' => [\r\n                [\r\n                    'name' => 'Taylor Otwell',\r\n                ],\r\n            ],\r\n        ];\r\n    });\r\n\r\n    $response->assertJsonFragment(['name' => 'Taylor Otwell']);\r\n\r\n<a name=\"assert-json-missing\"></a>\r\n#### assertJsonMissing\r\n\r\n断言响应未包含给定的 JSON 片段：\r\n\r\n    $response->assertJsonMissing(array $data);\r\n\r\n<a name=\"assert-json-missing-exact\"></a>\r\n#### assertJsonMissingExact\r\n\r\n断言响应不包含确切的 JSON 片段：\r\n\r\n    $response->assertJsonMissingExact(array $data);\r\n\r\n<a name=\"assert-json-missing-validation-errors\"></a>\r\n#### assertJsonMissingValidationErrors\r\n\r\n断言响应响应对于给定的键没有 JSON 验证错误：\r\n\r\n    $response->assertJsonMissingValidationErrors($keys);\r\n\r\n> 提示：更通用的 [assertValid](#assert-valid) 方法可用于断言响应没有以 JSON 形式返回的验证错误**并且**没有错误被闪现到会话存储中。\r\n\r\n<a name=\"assert-json-path\"></a>\r\n#### assertJsonPath\r\n\r\n断言响应包含指定路径上的给定数据：\r\n\r\n    $response->assertJsonPath($path, $expectedValue);\r\n\r\n例如，如果你的应用程序返回的 JSON 响应包含以下数据：\r\n\r\n```js\r\n{\r\n    \"user\": {\r\n        \"name\": \"Steve Schoger\"\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n你可以断言 `user` 对象的 `name` 属性匹配给定值，如下所示：\r\n\r\n    $response->assertJsonPath('user.name', 'Steve Schoger');\r\n\r\n<a name=\"assert-json-structure\"></a>\r\n#### assertJsonStructure\r\n\r\n断言响应具有给定的 JSON 结构：\r\n\r\n    $response->assertJsonStructure(array $structure);\r\n\r\n例如，如果你的应用程序返回的 JSON 响应包含以下数据：\r\n\r\n```js\r\n{\r\n    \"user\": {\r\n        \"name\": \"Steve Schoger\"\r\n    }\r\n}\r\n```\r\n\r\n你可以断言 JSON 结构符合您的期望，如下所示：\r\n\r\n    $response->assertJsonStructure([\r\n        'user' => [\r\n            'name',\r\n        ]\r\n    ]);\r\n\r\n有时，你的应用程序返回的 JSON 响应可能包含对象数组：\r\n\r\n```js\r\n{\r\n    \"user\": [\r\n        {\r\n            \"name\": \"Steve Schoger\",\r\n            \"age\": 55,\r\n            \"location\": \"Earth\"\r\n        },\r\n        {\r\n            \"name\": \"Mary Schoger\",\r\n            \"age\": 60,\r\n            \"location\": \"Earth\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n在这种情况下，你可以使用 `*` 字符来断言数组中所有对象的结构：\r\n\r\n    $response->assertJsonStructure([\r\n        'user' => [\r\n            '*' => [\r\n                 'name',\r\n                 'age',\r\n                 'location'\r\n            ]\r\n        ]\r\n    ]);\r\n\r\n<a name=\"assert-json-validation-errors\"></a>\r\n#### assertJsonValidationErrors\r\n\r\n断言响应具有给定键的给定 JSON 验证错误。在断言验证错误作为 JSON 结构返回而不是闪现到会话的响应时，应使用此方法：\r\n\r\n    $response->assertJsonValidationErrors(array $data, $responseKey = 'errors');\r\n\r\n> 技巧：更通用的 [assertInvalid](#assert-invalid) 方法可用于断言响应具有以 JSON 形式返回的验证错误**或**错误已闪存到会话存储。\r\n\r\n<a name=\"assert-json-validation-error-for\"></a>\r\n#### assertJsonValidationErrorFor\r\n\r\n断言响应对给定键有任何 JSON 验证错误：\r\n\r\n    $response->assertJsonValidationErrorFor(string $key, $responseKey = 'errors');\r\n\r\n<a name=\"assert-location\"></a>\r\n#### assertLocation\r\n\r\n断言响应在 `Location` 头部中具有给定的 URI 值：\r\n\r\n    $response->assertLocation($uri);\r\n\r\n\r\n\r\n<a name=\"assert-no-content\"></a>\r\n#### assertNoContent\r\n\r\n断言响应具有给定的 HTTP 状态码且没有内容：\r\n\r\n    $response->assertNoContent($status = 204);\r\n\r\n<a name=\"assert-not-found\"></a>\r\n#### assertNotFound\r\n\r\n断言响应具有未找到（404）HTTP 状态码：\r\n\r\n    $response->assertNotFound();\r\n\r\n<a name=\"assert-ok\"></a>\r\n#### assertOk\r\n\r\n断言响应有 200 状态码：\r\n\r\n    $response->assertOk();\r\n\r\n<a name=\"assert-plain-cookie\"></a>\r\n#### assertPlainCookie\r\n\r\n断言响应包含给定的 cookie （未加密）:\r\n\r\n    $response->assertPlainCookie($cookieName, $value = null);\r\n\r\n<a name=\"assert-redirect\"></a>\r\n#### assertRedirect\r\n\r\n断言响应会重定向到给定的 URI：\r\n\r\n    $response->assertRedirect($uri);\r\n\r\n<a name=\"assert-redirect-contains\"></a>\r\n#### assertRedirectContains\r\n\r\n断言响应是否重定向到包含给定字符串的 URI：\r\n\r\n    $response->assertRedirectContains($string);\r\n\r\n<a name=\"assert-redirect-to-signed-route\"></a>\r\n#### assertRedirectToSignedRoute\r\n\r\n断言响应是对给定签名路由的重定向：\r\n\r\n    $response->assertRedirectToSignedRoute($name = null, $parameters = []);\r\n\r\n<a name=\"assert-see\"></a>\r\n#### assertSee\r\n\r\n断言给定的字符串包含在响应中。除非传递第二个参数 `false` ，否则此断言将给定字符串进行转义后匹配：\r\n\r\n    $response->assertSee($value, $escaped = true);\r\n\r\n<a name=\"assert-see-in-order\"></a>\r\n#### assertSeeInOrder\r\n\r\n断言给定的字符串按顺序包含在响应中。除非传递第二个参数 `false` ，否则此断言将给定字符串进行转义后匹配：\r\n\r\n    $response->assertSeeInOrder(array $values, $escaped = true);\r\n\r\n<a name=\"assert-see-text\"></a>\r\n#### assertSeeText\r\n\r\n断言给定字符串包含在响应文本中。除非传递第二个参数 `false`，否则此断言将给定字符串进行转义后匹配。在做出断言之前，响应内容将被传递到 PHP 的 `strip_tags` 函数：\r\n\r\n    $response->assertSeeText($value, $escaped = true);\r\n\r\n\r\n\r\n<a name=\"assert-see-text-in-order\"></a>\r\n#### assertSeeTextInOrder\r\n\r\n断言给定的字符串按顺序包含在响应的文本中。除非传递第二个参数 `false` ，否则此断言将给定字符串进行转义后匹配。在做出断言之前，响应内容将被传递到 PHP 的 `strip_tags` 函数：\r\n\r\n    $response->assertSeeTextInOrder(array $values, $escaped = true);\r\n\r\n<a name=\"assert-session-has\"></a>\r\n#### assertSessionHas\r\n\r\n断言 Session 包含给定的数据段：\r\n\r\n    $response->assertSessionHas($key, $value = null);\r\n\r\n如果需要，可以提供一个闭包作为 `assertSessionHas` 方法的第二个参数。 如果闭包返回 `true`，则断言将通过：\r\n\r\n    $response->assertSessionHas($key, function ($value) {\r\n        return $value->name === 'Taylor Otwell';\r\n    });\r\n\r\n<a name=\"assert-session-has-input\"></a>\r\n#### assertSessionHasInput\r\n\r\nsession 在 [闪存输入数组](/docs/laravel/9.x/responses#redirecting-with-flashed-session-data) 中断言具有给定值： \r\n\r\n    $response->assertSessionHasInput($key, $value = null);\r\n\r\n如果需要，可以提供一个闭包作为 `assertSessionHasInput` 方法的第二个参数。 如果闭包返回 `true`，则断言将通过：\r\n\r\n    $response->assertSessionHasInput($key, function ($value) {\r\n        return Crypt::decryptString($value) === 'secret';\r\n    });\r\n\r\n<a name=\"assert-session-has-all\"></a>\r\n#### assertSessionHasAll\r\n\r\n断言 Session 中具有给定的键 / 值对列表：\r\n\r\n    $response->assertSessionHasAll(array $data);\r\n\r\n例如，如果您的应用程序会话包含 `name` 和 `status` 键，则可以断言它们存在并且具有指定的值，如下所示：\r\n\r\n    $response->assertSessionHasAll([\r\n        'name' => 'Taylor Otwell',\r\n        'status' => 'active',\r\n    ]);\r\n\r\n<a name=\"assert-session-has-errors\"></a>\r\n#### assertSessionHasErrors\r\n\r\n断言 session 包含给定 `$keys` 的 Laravel 验证错误。如果 `$keys` 是关联数组，则断言 session 包含每个字段（key）的特定错误消息（value）。测试将闪存验证错误到 session 的路由时，应使用此方法，而不是将其作为 JSON 结构返回：\r\n\r\n    $response->assertSessionHasErrors(\r\n        array $keys, $format = null, $errorBag = 'default'\r\n    );\r\n\r\n\r\n\r\n例如，要断言 `name` 和 `email` 字段具有已闪存到 session 的验证错误消息，可以调用 `assertSessionHasErrors` 方法，如下所示：\r\n\r\n    $response->assertSessionHasErrors(['name', 'email']);\r\n\r\n或者，您可以断言给定字段具有特定的验证错误消息：\r\n\r\n    $response->assertSessionHasErrors([\r\n        'name' => 'The given name was invalid.'\r\n    ]);\r\n\r\n<a name=\"assert-session-has-errors-in\"></a>\r\n#### assertSessionHasErrorsIn\r\n\r\n断言会话在特定的 [错误包](/docs/laravel/9.x/validation#named-error-bags) 中包含给定 `$keys` 的错误。如果 `$keys` 是一个关联数组，则断言该 session 在错误包内包含每个字段（键）的特定错误消息（值）： \r\n\r\n    $response->assertSessionHasErrorsIn($errorBag, $keys = [], $format = null);\r\n\r\n<a name=\"assert-session-has-no-errors\"></a>\r\n#### assertSessionHasNoErrors\r\n\r\n断言 session 没有验证错误：\r\n\r\n    $response->assertSessionHasNoErrors();\r\n\r\n<a name=\"assert-session-doesnt-have-errors\"></a>\r\n#### assertSessionDoesntHaveErrors\r\n\r\n断言会话对给定键没有验证错误：\r\n\r\n    $response->assertSessionDoesntHaveErrors($keys = [], $format = null, $errorBag = 'default');\r\n\r\n<a name=\"assert-session-missing\"></a>\r\n#### assertSessionMissing\r\n\r\n断言 session 中缺少指定的 $key：\r\n\r\n    $response->assertSessionMissing($key);\r\n\r\n<a name=\"assert-status\"></a>\r\n#### assertStatus\r\n\r\n断言响应指定的 http 状态码：\r\n\r\n    $response->assertStatus($code);\r\n\r\n<a name=\"assert-successful\"></a>\r\n#### assertSuccessful\r\n\r\n断言响应一个成功的状态码 (>= 200 且 < 300) :\r\n\r\n    $response->assertSuccessful();\r\n\r\n<a name=\"assert-unauthorized\"></a>\r\n#### assertUnauthorized\r\n\r\n断言一个未认证的状态码 (401)：\r\n\r\n    $response->assertUnauthorized();\r\n\r\n<a name=\"assert-unprocessable\"></a>\r\n#### assertUnprocessable\r\n\r\n断言响应具有不可处理的实体 (422) HTTP 状态代码：\r\n\r\n    $response->assertUnprocessable();\r\n\r\n<a name=\"assert-valid\"></a>\r\n#### assertValid\r\n\r\n断言响应对给定键没有验证错误。 此方法可用于断言验证错误作为 JSON 结构返回或验证错误已闪现到会话的响应：\r\n\r\n    // 断言不存在验证错误...\r\n    $response->assertValid();\r\n\r\n    // 断言给定的键没有验证错误...\r\n    $response->assertValid(['name', 'email']);\r\n\r\n\r\n\r\n<a name=\"assert-invalid\"></a>\r\n#### assertInvalid\r\n\r\n断言响应对给定键有验证错误。 此方法可用于断言验证错误作为 JSON 结构返回或验证错误已闪存到会话的响应：\r\n\r\n    $response->assertInvalid(['name', 'email']);\r\n\r\n您还可以断言给定键具有特定的验证错误消息。 这样做时，您可以提供整条消息或仅提供一部分消息：\r\n\r\n    $response->assertInvalid([\r\n        'name' => 'The name field is required.',\r\n        'email' => 'valid email address',\r\n    ]);\r\n\r\n<a name=\"assert-view-has\"></a>\r\n#### assertViewHas\r\n\r\n断言为响应视图提供了一个键值对数据：\r\n\r\n    $response->assertViewHas($key, $value = null);\r\n\r\n将闭包作为第二个参数传递给 `assertViewHas` 方法将允许您检查并针对特定的视图数据做出断言：\r\n\r\n    $response->assertViewHas('user', function (User $user) {\r\n        return $user->name === 'Taylor';\r\n    });\r\n\r\n此外，视图数据可以作为数组变量访问响应，让您可以方便地检查它：\r\n\r\n    $this->assertEquals('Taylor', $response['name']);\r\n\r\n<a name=\"assert-view-has-all\"></a>\r\n#### assertViewHasAll\r\n\r\n断言响应视图具有给定的数据列表：\r\n\r\n    $response->assertViewHasAll(array $data);\r\n\r\n该方法可用于断言该视图仅包含与给定键匹配的数据：\r\n\r\n    $response->assertViewHasAll([\r\n        'name',\r\n        'email',\r\n    ]);\r\n\r\n或者，您可以断言该视图数据存在并且具有特定值：\r\n\r\n    $response->assertViewHasAll([\r\n        'name' => 'Taylor Otwell',\r\n        'email' => 'taylor@example.com,',\r\n    ]);\r\n\r\n<a name=\"assert-view-is\"></a>\r\n#### assertViewIs\r\n\r\n断言当前路由返回的的视图是给定的视图：\r\n\r\n    $response->assertViewIs($value);\r\n\r\n\r\n\r\n<a name=\"assert-view-missing\"></a>\r\n#### assertViewMissing\r\n\r\n断言给定的数据键不可用于应用程序响应中返回的视图：\r\n\r\n    $response->assertViewMissing($key);\r\n\r\n<a name=\"authentication-assertions\"></a>\r\n### Authentication Assertions\r\n\r\nLaravel 还提供了各种与身份验证相关的断言，您可以在应用程序的功能测试中使用它们。 请注意，这些方法是在测试类本身上调用的，而不是由诸如 `get` 和 `post` 等方法返回的 `Illuminate\\Testing\\TestResponse` 实例。\r\n\r\n<a name=\"assert-authenticated\"></a>\r\n#### assertAuthenticated\r\n\r\n断言用户已通过身份验证：\r\n\r\n    $this->assertAuthenticated($guard = null);\r\n\r\n<a name=\"assert-guest\"></a>\r\n#### assertGuest\r\n\r\n断言用户未通过身份验证：\r\n\r\n    $this->assertGuest($guard = null);\r\n\r\n<a name=\"assert-authenticated-as\"></a>\r\n#### assertAuthenticatedAs\r\n\r\n断言特定用户已通过身份验证：\r\n\r\n    $this->assertAuthenticatedAs($user, $guard = null);\r\n\r\n","p":"docs/http-tests.html"},{"t":"console-tests (控制台测试)","d":"\n# 控制台测试\r\n\r\n- [介绍](#introduction)\r\n- [期望成功/失败](#success-failure-expectations)\r\n- [期望输入/输出](#input-output-expectations)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n除了简化 HTTP 测试之外，Laravel 还提供了一个简单的 API 来测试应用程序的 [自定义控制台命令](/docs/laravel/9.x/artisan)。\r\n\r\n<a name=\"success-failure-expectations\"></a>\r\n## 期望成功/失败\r\n\r\n首先，让我们探索如何对 Artisan 命令的退出代码进行断言。为此，我们将使用 `artisan` 方法从我们的测试中调用 Artisan 命令。然后，我们将使用 `assertExitCode` 方法断言该命令以给定的退出代码完成：\r\n\r\n    /**\r\n     * 测试控制台命令。\r\n     *\r\n     * @return void\r\n     */\r\n    public function test_console_command()\r\n    {\r\n        $this->artisan('inspire')->assertExitCode(0);\r\n    }\r\n\r\n您可以使用 `assertNotExitCode` 方法断言命令没有以给定的退出代码退出：\r\n\r\n    $this->artisan('inspire')->assertNotExitCode(1);\r\n\r\n当然，所有终端命令通常在成功时以 `0` 状态码退出，在不成功时以非零退出码退出。因此，为方便起见，您可以使用 `assertSuccessful` 和 `assertFailed` 断言来断言给定命令是否以成功的退出代码退出：\r\n\r\n    $this->artisan('inspire')->assertSuccessful();\r\n\r\n    $this->artisan('inspire')->assertFailed();\r\n\r\n<a name=\"input-output-expectations\"></a>\r\n## 期望输入/输出\r\n\r\nLaravel 允许您使用 `expectsQuestion` 方法轻松 「mock」控制台命令的用户输入。此外，您可以使用 `assertExitCode` 和 `expectsOutput` 方法指定您希望通过控制台命令输出的退出代码和文本。例如，考虑以下控制台命令：\r\n\r\n    Artisan::command('question', function () {\r\n        $name = $this->ask('What is your name?');\r\n\r\n        $language = $this->choice('Which language do you prefer?', [\r\n            'PHP',\r\n            'Ruby',\r\n            'Python',\r\n        ]);\r\n\r\n        $this->line('Your name is '.$name.' and you prefer '.$language.'.');\r\n    });\r\n\r\n\n\n您可以使用以下测试来测试此命令，该测试利用了 `expectsQuestion`、`expectsOutput`、`doesntExpectOutput` 和 `assertExitCode` 方法：\r\n\r\n    /**\r\n     * 测试控制台命令。\r\n     *\r\n     * @return void\r\n     */\r\n    public function test_console_command()\r\n    {\r\n        $this->artisan('question')\r\n             ->expectsQuestion('What is your name?', 'Taylor Otwell')\r\n             ->expectsQuestion('Which language do you prefer?', 'PHP')\r\n             ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')\r\n             ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')\r\n             ->assertExitCode(0);\r\n    }\r\n\r\n<a name=\"confirmation-expectations\"></a>\r\n#### 确认期望\r\n\r\n当编写一个期望以「是」或「否」答案形式确认的命令时，您可以使用 `expectsConfirmation` 方法：\r\n\r\n    $this->artisan('module:import')\r\n        ->expectsConfirmation('Do you really wish to run this command?', 'no')\r\n        ->assertExitCode(1);\r\n\r\n<a name=\"table-expectations\"></a>\r\n#### 表格期望\r\n\r\n如果您的命令使用 Artisan 的 `table` 方法显示信息表，则为整个表格编写输出预期会很麻烦。相反，您可以使用 `expectsTable` 方法。此方法接受表格的标题作为它的第一个参数和表格的数据作为它的第二个参数：\r\n\r\n    $this->artisan('users:all')\r\n        ->expectsTable([\r\n            'ID',\r\n            'Email',\r\n        ], [\r\n            [1, 'taylor@example.com'],\r\n            [2, 'abigail@example.com'],\r\n        ]);\r\n\n","p":"docs/console-tests.html"},{"t":"dusk (Laravel Dusk)","d":"\n# Laravel Dusk\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n    - [管理 ChromeDriver 安装](#managing-chromedriver-installations)\r\n    - [使用其他浏览器](#using-other-browsers)\r\n- [开始](#getting-started)\r\n    - [创建测试](#generating-tests)\r\n    - [数据库迁移](#migrations)\r\n    - [运行测试](#running-tests)\r\n    - [环境变量处理](#environment-handling)\r\n- [浏览器基础](#browser-basics)\r\n    - [创建浏览器](#creating-browsers)\r\n    - [导航](#navigation)\r\n    - [调整浏览器窗口大小](#resizing-browser-windows)\r\n    - [浏览器宏](#browser-macros)\r\n    - [验证](#authentication)\r\n    - [Cookies](#cookies)\r\n    - [执行 JavaScript](#executing-javascript)\r\n    - [获取截图](#taking-a-screenshot)\r\n    - [输出结果保存到硬盘](#storing-console-output-to-disk)\r\n    - [输出结果保存到硬盘](#storing-page-source-to-disk)\r\n- [与元素交互](#interacting-with-elements)\r\n    - [Dusk 选择器](#dusk-selectors)\r\n    - [文本、值和属性](#text-values-and-attributes)\r\n    - [使用表单](#interacting-with-forms)\r\n    - [附加文件](#attaching-files)\r\n    - [按钮](#pressing-buttons)\r\n    - [点击链接](#clicking-links)\r\n    - [使用键盘](#using-the-keyboard)\r\n    - [使用鼠标](#using-the-mouse)\r\n    - [JavaScript 对话框](#javascript-dialogs)\r\n    - [作用域选择](#scoping-selectors)\r\n    - [等待元素渲染](#waiting-for-elements)\r\n    - [将元素滚动到可见区域](#scrolling-an-element-into-view)\r\n- [可用的断言](#available-assertions)\r\n- [网页](#pages)\r\n    - [创建网页](#generating-pages)\r\n    - [配置网页](#configuring-pages)\r\n    - [导航至网页](#navigating-to-pages)\r\n    - [选择器简写](#shorthand-selectors)\r\n    - [网页方法](#page-methods)\r\n- [组件](#components)\r\n    - [创建组件](#generating-components)\r\n    - [使用组件](#using-components)\r\n- [持续集成](#continuous-integration)\r\n    - [Heroku CI](#running-tests-on-heroku-ci)\r\n    - [Travis CI](#running-tests-on-travis-ci)\r\n    - [GitHub Actions](#running-tests-on-github-actions)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Dusk](https://github.com/laravel/dusk) Laravel Dusk 提供了富有表现力、简单易用的浏览器自动化及测试 API 。默认情况下，Dusk 不需要在你的机器上安装 JDK 或者 Selenium 。而是需要使用单独的 [ChromeDriver](https://sites.google.com/chromium.org/driver) 进行安装。当然，你也可以自由使用其他的兼容 Selenium 的驱动程序。\r\n\r\n\n\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，您应该安装 [Google Chrome](https://www.google.com/chrome)并将 `laravel/dusk`  依赖项添加到你的项目中:\r\n\r\n```shell\r\ncomposer require --dev laravel/dusk\r\n```\r\n\r\n> 注意：如果你是手动注册 Dusk 服务提供者，一定 **不能** 在你的生产环境中注册，这样可能会导致一些不守规矩的用户拥有控制你应用的权限。\r\n\r\n安装好 Dusk 包后，运行 `dusk:install`  命令。`dusk:install` 命令会创建一个 `tests/Browser` 目录和一个测试例子：\r\n\r\n```shell\r\nphp artisan dusk:install\r\n```\r\n\r\n接下来，在你的 `.env` 文件中设置  `APP_URL`  变量。这个值应该与你在浏览器中打开本应用的 URL 相匹配。\r\n\r\n> 技巧：如果您使用 [Laravel Sail](/docs/laravel/9.x/sail) 管理您的本地开发环境，还请查阅  [configuring and running Dusk tests](/docs/laravel/9.x/sail#laravel-dusk) 的文档。\r\n\r\n<a name=\"managing-chromedriver-installations\"></a>\r\n### 管理 ChromeDriver 安装\r\n\r\n如果你想安装与 Laravel Dusk 附带版本不同的 ChromeDriver，可以使用 `dusk:chrome-driver` 命令:\r\n\r\n```shell\r\n# 为你的操作系统安装最新版本的 ChromeDriver...\r\nphp artisan dusk:chrome-driver\r\n\r\n# 为你的操作系统安装指定版本的 ChromeDriver...\r\nphp artisan dusk:chrome-driver 86\r\n\r\n# 为所有支持的操作系统安装指定版本的 ChromeDriver...\r\nphp artisan dusk:chrome-driver --all\r\n\r\n# 安装与您的操作系统检测到的 Chrome/Chromium 版本匹配的 ChromeDriver 版本...\r\nphp artisan dusk:chrome-driver --detect\r\n```\r\n\r\n> 注意：Dusk 要求 `chromedriver` 二进制文件是可执行的。如果在 Dusk 运行时遇到问题，可以使用以下命令确保二进制文件是可执行的： `chmod -R 0755 vendor/laravel/dusk/bin/`。\r\n\r\n\n\n<a name=\"using-other-browsers\"></a>\r\n### 使用其他浏览器\r\n\r\n默认情况下， Dusk 使用 Google Chrome 浏览器和一个单独安装的 [ChromeDriver](https://sites.google.com/chromium.org/driver) 来运行你的浏览器测试。当然，你可以运行你自己的 Selenium 服务，用任何你想用的浏览器来进行测试。\r\n\r\n如果要这么做，打开你的 `tests/DuskTestCase.php` 文件，这个是应用测试用例的基类。在这个文件中，你可以移除对 `startChromeDriver` 方法的调用。这样 Dusk 就不会自动启动 ChromeDriver 了。\r\n\r\n    /**\r\n     * Prepare for Dusk test execution.\r\n     *\r\n     * @beforeClass\r\n     * @return void\r\n     */\r\n    public static function prepare()\r\n    {\r\n        // static::startChromeDriver();\r\n    }\r\n\r\n然后，你可以按照自己的意愿修改 `driver` 方法来连接到你选定的 URL 和端口。此外，你可以修改 「desired capabilities」（期望能力），它将会被传递给 WebDriver：\r\n\r\n    /**\r\n     * Create the RemoteWebDriver instance.\r\n     *\r\n     * @return \\Facebook\\WebDriver\\Remote\\RemoteWebDriver\r\n     */\r\n    protected function driver()\r\n    {\r\n        return RemoteWebDriver::create(\r\n            'http://localhost:4444/wd/hub', DesiredCapabilities::phantomjs()\r\n        );\r\n    }\r\n\r\n<a name=\"getting-started\"></a>\r\n## 开始\r\n\r\n<a name=\"generating-tests\"></a>\r\n### 创建测试\r\n\r\n要创建一个 Dusk 测试，可以使用 `dusk:make` 命令。创建的测试将会被放在 `tests/Browser` 目录中：\r\n\r\n```shell\r\nphp artisan dusk:make LoginTest\r\n```\r\n\r\n<a name=\"migrations\"></a>\r\n### 数据库迁移\r\n\r\n编写的测试，大多数都是从数据库中查询数据的页面，与这些页面进行交互。但是，你的 Dusk 测试不应使用 `RefreshDatabase ` Trait。 `RefreshDatabase` Trait 利用了数据库事务，该事务在 HTTP 请求中将不适用或不可用。相反，请使用 `DatabaseMigrations` Trait，该 Trait 将为每个测试重新迁移数据库：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Foundation\\Testing\\DatabaseMigrations;\r\n    use Laravel\\Dusk\\Chrome;\r\n    use Tests\\DuskTestCase;\r\n\r\n    class ExampleTest extends DuskTestCase\r\n    {\r\n        use DatabaseMigrations;\r\n    }\r\n\r\n> 注意：执行 Dusk 测试时，可能不使用 SQLite 内存数据库。由于浏览器在其自己的进程中执行，因此它将无法访问其他进程的内存数据库。\r\n\n\n<a name=\"running-tests\"></a>\r\n### 运行时测试\r\n\r\n要运行浏览器测试，请执行 `Dask` Artisan 命令：\r\n\r\n```shell\r\nphp artisan dusk\r\n```\r\n\r\n如果您上次运行 `dush` 命令时测试失败，可以先使用 `dusk:fails` 命令重新运行失败的测试，以节约时间：\r\n\r\n```shell\r\nphp artisan dusk:fails\r\n```\r\n\r\n`dusk` 命令接受 PHPUnit 测试运行程序通常接受的任何参数，例如只允许您为给定的[组](https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.group):运行测试\r\n\r\n```shell\r\nphp artisan dusk --group=foo\r\n```\r\n\r\n> 技巧：如果您使用 [Laravel Sail](/docs/laravel/9.x/sail) 管理您的本地开发环境，还请查阅 [配置和运行 Dusk 测试](/docs/laravel/9.x/sail#laravel-dusk) 的文档。\r\n\r\n<a name=\"manually-starting-chromedriver\"></a>\r\n#### 手动启动 ChromeDriver\r\n\r\n\r\n默认情况下，Dusk 将自动尝试启动 ChromeDriver。如果这不适用于您的特定系统，您可以在运行 `dusk` 命令之前手动启动 ChromeDriver。如果你选择手动启动 ChromeDriver，你应该注释掉下面的 `tests/testcase.php` 文件：\r\n\r\n    /**\r\n     * Prepare for Dusk test execution.\r\n     *\r\n     * @beforeClass\r\n     * @return void\r\n     */\r\n    public static function prepare()\r\n    {\r\n        // static::startChromeDriver();\r\n    }\r\n\r\n此外，如果在9515以外的端口上启动 ChromeDriver，则应修改同类一的 `driver` 方法，以映射正确的端口：\r\n\r\n    /**\r\n     * 创建RemoteWebDriver实例。\r\n     *\r\n     * @return \\Facebook\\WebDriver\\Remote\\RemoteWebDriver\r\n     */\r\n    protected function driver()\r\n    {\r\n        return RemoteWebDriver::create(\r\n            'http://localhost:9515', DesiredCapabilities::chrome()\r\n        );\r\n    }\r\n\r\n<a name=\"environment-handling\"></a>\r\n### 环境处理\r\n\r\n\n\n要强制 Dusk 在运行测试时使用它自己的环境文件，请在项目的根目录中创建一个 `.env.dusk.{environment}` 文件。 例如，如果您要从 `local` 环境启动 `dusk` 命令，则应创建一个 `.env.dusk.local` 文件。\r\n\r\n运行测试时，Dusk 会备份你的 `.env` 文件并将你的 Dusk 环境重命名为 `.env`。 测试完成后，`.env` 文件将被恢复。\r\n\r\n<a name=\"browser-basics\"></a>\r\n## 浏览器基础\r\n\r\n<a name=\"creating-browsers\"></a>\r\n### 创建浏览器\r\n\r\n首先，让我们编写一个测试来验证我们可以登录到我们的应用程序。生成测试后，我们可以修改它以导航到登录页面，输入一些凭据，然后单击「登录」按钮。要创建浏览器实例，您可以在 Dusk 测试中调用 `browse` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Foundation\\Testing\\DatabaseMigrations;\r\n    use Laravel\\Dusk\\Chrome;\r\n    use Tests\\DuskTestCase;\r\n\r\n    class ExampleTest extends DuskTestCase\r\n    {\r\n        use DatabaseMigrations;\r\n\r\n        /**\r\n         * 基本的浏览器测试示例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_basic_example()\r\n        {\r\n            $user = User::factory()->create([\r\n                'email' => 'taylor@laravel.com',\r\n            ]);\r\n\r\n            $this->browse(function ($browser) use ($user) {\r\n                $browser->visit('/login')\r\n                        ->type('email', $user->email)\r\n                        ->type('password', 'password')\r\n                        ->press('Login')\r\n                        ->assertPathIs('/home');\r\n            });\r\n        }\r\n    }\r\n\r\n正如你在上面的例子中看到的，`browse` 方法接受一个闭包。 Dusk 会自动将一个浏览器实例传递给这个闭包，用于与您的应用程序交互和对应用程序进行断言的主要对象。\r\n\r\n\n\n<a name=\"creating-multiple-browsers\"></a>\r\n#### 创建多个浏览器\r\n\r\n有时您可能需要多个浏览器才能正确执行测试。例如，可能需要多个浏览器来测试与 websocket 交互的聊天页面。要创建多个浏览器，只需将更多浏览器参数添加到 `browse` 方法的闭包签名中：\r\n\r\n    $this->browse(function ($first, $second) {\r\n        $first->loginAs(User::find(1))\r\n              ->visit('/home')\r\n              ->waitForText('Message');\r\n\r\n        $second->loginAs(User::find(2))\r\n               ->visit('/home')\r\n               ->waitForText('Message')\r\n               ->type('message', 'Hey Taylor')\r\n               ->press('Send');\r\n\r\n        $first->waitForText('Hey Taylor')\r\n              ->assertSee('Jeffrey Way');\r\n    });\r\n\r\n<a name=\"navigation\"></a>\r\n### 导航\r\n\r\n可以使用 `visit` 方法导航到应用程序中的给定 URI：\r\n\r\n    $browser->visit('/login');\r\n\r\n你也可以使用 `visitRoute` 方法导航到 [命名路由](/docs/laravel/9.x/routing#named-routes)：\r\n\r\n    $browser->visitRoute('login');\r\n\r\n可以使用 `back` 和 `forward` 方法导航 「后退」和 「前进」：\r\n\r\n    $browser->back();\r\n\r\n    $browser->forward();\r\n\r\n可以使用 `refresh` 方法刷新页面：\r\n\r\n    $browser->refresh();\r\n\r\n<a name=\"resizing-browser-windows\"></a>\r\n### 改变浏览器窗口大小\r\n\r\n可以使用 `resize` 方法去调整浏览器的窗口大小：\r\n\r\n    $browser->resize(1920, 1080);\r\n\r\n该 `maximize` 方法可以将浏览器窗口最大化：\r\n\r\n    $browser->maximize();\r\n\r\n该 `fitContent` 方法将自动适配浏览器的窗口大小和页面内容的尺寸：\r\n\r\n    $browser->fitContent();\r\n\r\n测试失败时，Dusk 会自动将浏览器窗口缩放至内容大小并拍下屏幕快照，你可以通过调用 `disableFitOnFailure` 方法来禁用这一特性：\r\n\r\n    $browser->disableFitOnFailure();\r\n\n\n你可以使用 `move` 方法将浏览器窗口移动到屏幕上的其他位置：\r\n\r\n    $browser->move($x = 100, $y = 100);\r\n\r\n<a name=\"browser-macros\"></a>\r\n### 浏览器宏\r\n\r\n如果你想定义一个可以在各种测试中重复使用的自定义浏览器方法，可以在 `Browser` 类中使用 `macro` 方法。通常，你应该从 [服务提供者](/docs/laravel/9.x/providers) 的 `boot` 方法中调用它：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Laravel\\Dusk\\Browser;\r\n\r\n    class DuskServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * Register Dusk's browser macros.\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            Browser::macro('scrollToElement', function ($element = null) {\r\n                $this->script(\"$('html, body').animate({ scrollTop: $('$element').offset().top }, 0);\");\r\n\r\n                return $this;\r\n            });\r\n        }\r\n    }\r\n\r\n该 `macro` 函数接收方法名作为其第一个参数，并接收闭包作为其第二个参数。 将宏作为 `Browser` 实现上的方法调用宏时，将执行宏的闭包：\r\n\r\n    $this->browse(function ($browser) use ($user) {\r\n        $browser->visit('/pay')\r\n                ->scrollToElement('#credit-card-details')\r\n                ->assertSee('Enter Credit Card Details');\r\n    });\r\n\r\n<a name=\"authentication\"></a>\r\n### 用户认证\r\n\r\n我们经常会测试需要身份验证的页面，你可以使用 Dusk 的 `loginAs` 方法来避免在每次测试期间与登录页面进行交互。该 `loginAs` 方法接收用户 ID 或者用户模型实例：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $this->browse(function ($browser) {\r\n        $browser->loginAs(User::find(1))\r\n              ->visit('/home');\r\n    });\r\n\r\n> 注意：使用 `loginAs` 方法后，用户会话在文件中的所有测试被维护。\r\n\n\n<a name=\"cookies\"></a>\r\n### Cookies\r\n\r\n你可以使用 `cookie` 方法来获取或者设置加密过的 cookie 的值：\r\n\r\n    $browser->cookie('name');\r\n\r\n    $browser->cookie('name', 'Taylor');\r\n\r\n使用 `plainCookie` 则可以获取或者设置未加密过的 cookie 的值：\r\n\r\n    $browser->plainCookie('name');\r\n\r\n    $browser->plainCookie('name', 'Taylor');\r\n\r\n你可以使用 `deleteCookie` 方法删除指定的 cookie：\r\n\r\n    $browser->deleteCookie('name');\r\n\r\n<a name=\"executing-javascript\"></a>\r\n### 运行 JavaScript\r\n\r\n可以使用 `script` 方法在浏览器中执行任意 JavaScript 语句：\r\n\r\n    $browser->script('document.documentElement.scrollTop = 0');\r\n\r\n    $browser->script([\r\n        'document.body.scrollTop = 0',\r\n        'document.documentElement.scrollTop = 0',\r\n    ]);\r\n\r\n    $output = $browser->script('return window.location.pathname');\r\n\r\n<a name=\"taking-a-screenshot\"></a>\r\n### 获取截图\r\n\r\n你可以使用 `screenshot` 方法来截图并将其指定文件名存储，所有截图都将存放在 `tests/Browser/screenshots` 目录下：\r\n\r\n    $browser->screenshot('filename');\r\n\r\n<a name=\"storing-console-output-to-disk\"></a>\r\n### 控制台输出结果保存到硬盘\r\n\r\n你可以使用 `storeConsoleLog` 方法将控制台输出指定文件名并写入磁盘，控制台输出默认存放在 `tests/Browser/console` 目录下：\r\n\r\n    $browser->storeConsoleLog('filename');\r\n\r\n<a name=\"storing-page-source-to-disk\"></a>\r\n### 页面源码保存到硬盘\r\n\r\n你可以使用 `storeSource` 方法将页面当前源代码指定文件名并写入磁盘，页面源代码默认会存放到 `tests/Browser/source` 目录：\r\n\r\n    $browser->storeSource('filename');\r\n\r\n<a name=\"interacting-with-elements\"></a>\r\n## 与元素交互\r\n\r\n<a name=\"dusk-selectors\"></a>\r\n### Dusk 选择器\r\n\r\n编写 Dusk 测试最困难的部分之一就是选择良好的 CSS 选择器与元素进行交互。 随着时间的推移，前端的更改可能会导致如下所示的 CSS 选择器无法通过测试：\r\n\r\n    // HTML...\r\n\r\n    <button>Login</button>\r\n\r\n    // Test...\r\n\r\n    $browser->click('.login-page .container div > button');\r\n\r\n\n\nDusk 选择器可以让你专注于编写有效的测试，而不必记住 CSS 选择器。要定义一个选择器，你需要添加一个 `dusk` 属性在 HTML 元素中。然后在选择器前面加上 `@` 用来在 Dusk 测试中操作元素：\r\n\r\n    // HTML...\r\n\r\n    <button dusk=\"login-button\">Login</button>\r\n\r\n    // Test...\r\n\r\n    $browser->click('@login-button');\r\n\r\n<a name=\"text-values-and-attributes\"></a>\r\n### 文本、值 & 属性\r\n\r\n<a name=\"retrieving-setting-values\"></a>\r\n#### 获取 & 设置值\r\n\r\nDusk 提供了多个方法用于和页面元素的当前显示文本、值和属性进行交互，例如，要获取匹配指定选择器的元素的「值」，使用 `value` 方法：\r\n\r\n    // 获取值...\r\n    $value = $browser->value('selector');\r\n\r\n    // 设置值...\r\n    $browser->value('selector', 'value');\r\n\r\n你可以使用 `inputValue` 方法来获取包含指定字段名称的输入元素的「值」：\r\n\r\n    $value = $browser->inputValue('field');\r\n\r\n<a name=\"retrieving-text\"></a>\r\n#### 获取文本\r\n\r\n该 `text` 方法可以用于获取匹配指定选择器元素文本：\r\n\r\n    $text = $browser->text('selector');\r\n\r\n<a name=\"retrieving-attributes\"></a>\r\n#### 获取属性\r\n\r\n最后，该 `attribute` 方法可以用于获取匹配指定选择器元素属性：\r\n\r\n    $attribute = $browser->attribute('selector', 'value');\r\n\r\n<a name=\"interacting-with-forms\"></a>\r\n### 使用表单\r\n\r\n<a name=\"typing-values\"></a>\r\n#### 输入值\r\n\r\nDusk 提供了多种方法来与表单和输入元素进行交互。首先，让我们看一个在字段中输入值的示例：\r\n\r\n    $browser->type('email', 'taylor@laravel.com');\r\n\r\n\n\n注意，尽管该方法在需要时接收，但是我们不需要将 CSS 选择器传递给 `type` 方法。如果没有提供 CSS 选择器，Dusk 会搜索包含指定 `name` 属性的 `input` 或 `textarea` 字段。\r\n\r\n要想将文本附加到一个字段之后而且不清除其内容， 你可以使用 `append` 方法：\r\n\r\n    $browser->type('tags', 'foo')\r\n            ->append('tags', ', bar, baz');\r\n\r\n你可以使用 `clear` 方法清除输入值：\r\n\r\n    $browser->clear('email');\r\n\r\n你可以使用 `typeSlowly` 方法指示 Dusk 缓慢键入。 默认情况下，Dusk 在两次按键之间将暂停 100 毫秒。 要自定义按键之间的时间量，你可以将适当的毫秒数作为方法的第二个参数传递：\r\n\r\n    $browser->typeSlowly('mobile', '+1 (202) 555-5555');\r\n\r\n    $browser->typeSlowly('mobile', '+1 (202) 555-5555', 300);\r\n\r\n你可以使用 `appendSlowly` 方法缓慢添加文本：\r\n\r\n    $browser->type('tags', 'foo')\r\n            ->appendSlowly('tags', ', bar, baz');\r\n\r\n<a name=\"dropdowns\"></a>\r\n#### 下拉菜单\r\n\r\n需要在下拉菜单中选择值，你可以使用 `select` 方法。 类似于 `type` 方法， 该 `select` 方法并不是一定要传入 CSS 选择器。 当使用 `select` 方法时，你应该传递选项实际的值而不是它的显示文本：\r\n\r\n    $browser->select('size', 'Large');\r\n\r\n你也可以通过省略第二个参数来随机选择一个选项：\r\n\r\n    $browser->select('size');\r\n\r\n通过将数组作为 `select` 方法的第二个参数，可以指示该方法选择多个选项：\r\n\r\n    $browser->select('categories', ['Art', 'Music']);\r\n\r\n\n\n<a name=\"checkboxes\"></a>\r\n#### 复选框\r\n\r\n使用「check」 复选框时，你可以使用 `check` 方法。 像其他许多与 input 相关的方法，并不是必须传入 CSS 选择器。 如果准确的选择器无法找到的时候，Dusk 会搜索能够与 `name` 属性匹配的复选框：\r\n\r\n    $browser->check('terms');\r\n\r\n该 `uncheck` 方法可用于「取消选中」复选框输入：\r\n\r\n    $browser->uncheck('terms');\r\n\r\n<a name=\"radio-buttons\"></a>\r\n#### 单选按钮\r\n\r\n使用 「select」中单选按钮选项时，你可以使用 `radio` 这个方法。 像很多其他的与输入相关的方法一样， 它也并不是必须传入 CSS 选择器。如果准确的选择器无法被找到的时候， Dusk 会搜索能够与 `name` 属性或者 `value` 属性相匹配的 `radio` 单选按钮：\r\n\r\n    $browser->radio('size', 'large');\r\n\r\n<a name=\"attaching-files\"></a>\r\n### 附件\r\n\r\n该 `attach` 方法可以附加一个文件到 `file`  input 元素中。 像很多其他的与输入相关的方法一样，他也并不是必须传入 CSS 选择器。如果准确的选择器没有被找到的时候， Dusk 会搜索与 `name` 属性匹配的文件输入框：\r\n\r\n    $browser->attach('photo', __DIR__.'/photos/mountains.png');\r\n\r\n> 注意：attach 方法需要使用 PHP `Zip` 扩展，你的服务器必须安装了此扩展。\r\n\r\n<a name=\"pressing-buttons\"></a>\r\n### 点击按钮\r\n\r\n可以使用 `press` 方法来单击页面上的按钮元素。该 `press` 方法的第一个参数可以是按钮的显示文本，也可以是 CSS/ Dusk 选择器：\r\n\r\n    $browser->press('Login');\r\n\r\n提交表单时，许多应用程序在按下表单后会禁用表单的提交按钮，然后在表单提交的 HTTP 请求完成后重新启用该按钮。要按下按钮并等待按钮被重新启用，可以使用 `pressAndWaitFor` 方法：\r\n\r\n    // Press the button and wait a maximum of 5 seconds for it to be enabled...\r\n    $browser->pressAndWaitFor('Save');\r\n\r\n    // Press the button and wait a maximum of 1 second for it to be enabled...\r\n    $browser->pressAndWaitFor('Save', 1);\r\n\r\n\n\n<a name=\"clicking-links\"></a>\r\n### 点击链接\r\n\r\n要点击链接，可以在浏览器实例下使用 `clickLink` 方法。该 `clickLink` 方法将点击指定文本的链接：\r\n\r\n    $browser->clickLink($linkText);\r\n\r\n您可以使用 `seeLink` 方法来确定具有给定显示文本的链接在页面上是否可见：\r\n\r\n    if ($browser->seeLink($linkText)) {\r\n        // ...\r\n    }\r\n\r\n> 注意：这些方法与 jQuery 交互。 如果页面上没有 jQuery ， Dusk 会自动将其注入到页面中，以便在测试期间可用。\r\n\r\n<a name=\"using-the-keyboard\"></a>\r\n### 使用键盘\r\n\r\n该 `keys` 方法让你可以再指定元素中输入比 `type` 方法更加复杂的输入序列。例如，你可以在输入值的同时按下按键。在这个例子中，输入 `taylor` 时， `shift` 键也同时被按下。当 `taylor` 输入完之后， 将会输入 `swift` 而不会按下任何按键：\r\n\r\n    $browser->keys('selector', ['{shift}', 'taylor'], 'swift');\r\n\r\n`keys` 方法的另一个有价值的用例是向您的应用程序的主要 CSS 选择器发送「键盘快捷键」组合：\r\n\r\n    $browser->keys('.app', ['{command}', 'j']);\r\n\r\n> 技巧：所有修饰符键如 `{command}` 都包裹在 `{}` 字符中，并且与在 `Facebook\\WebDriver\\WebDriverKeys` 类中定义的常量匹配，该类可以 [在 GitHub 上找到](https://github.com/php-webdriver/php-webdriver/blob/master/lib/WebDriverKeys.php)。\r\n\r\n<a name=\"using-the-mouse\"></a>\r\n### 使用鼠标\r\n\r\n<a name=\"clicking-on-elements\"></a>\r\n\n\n#### 点击元素\r\n\r\n该 `click` 方法可用于「点击」与给定选择器匹配的元素：\r\n\r\n    $browser->click('.selector');\r\n\r\n该 `clickAtXPath` 方法可用于「单击」与给定 XPath 表达式匹配的元素：\r\n\r\n    $browser->clickAtXPath('//div[@class = \"selector\"]');\r\n\r\n该 `clickAtPoint` 方法可用于「点击」相对于浏览器可视区域的给定坐标对上的最高元素：\r\n\r\n    $browser->clickAtPoint($x = 0, $y = 0);\r\n\r\n该 `doubleClick` 方法可用于模拟鼠标的双击：\r\n\r\n    $browser->doubleClick();\r\n\r\n该 `rightClick` 方法可用于模拟鼠标的右击：\r\n\r\n    $browser->rightClick();\r\n\r\n    $browser->rightClick('.selector');\r\n\r\n该 `clickAndHold` 方法可用于模拟被单击并按住的鼠标按钮。 随后调用 `releaseMouse` 方法将撤消此行为并释放鼠标按钮：\r\n\r\n    $browser->clickAndHold()\r\n            ->pause(1000)\r\n            ->releaseMouse();\r\n\r\n<a name=\"mouseover\"></a>\r\n#### 鼠标悬停\r\n\r\n该 `mouseover` 方法可用于与给定选择器匹配的元素的鼠标悬停动作：\r\n\r\n    $browser->mouseover('.selector');\r\n\r\n<a name=\"drag-drop\"></a>\r\n#### 拖放\r\n\r\n该 `drag` 方法用于将与指定选择器匹配的元素拖到其它元素：\r\n\r\n    $browser->drag('.from-selector', '.to-selector');\r\n\r\n或者，可以在单一方向上拖动元素：\r\n\r\n    $browser->dragLeft('.selector', $pixels = 10);\r\n    $browser->dragRight('.selector', $pixels = 10);\r\n    $browser->dragUp('.selector', $pixels = 10);\r\n    $browser->dragDown('.selector', $pixels = 10);\r\n\r\n最后，你可以将元素拖动给定的偏移量：\r\n\r\n    $browser->dragOffset('.selector', $x = 10, $y = 10);\r\n\r\n\n\n<a name=\"javascript-dialogs\"></a>\r\n### JavaScript 对话框\r\n\r\nDusk 提供了各种与 JavaScript 对话框进行交互的方法。例如，您可以使用 `waitForDialog` 方法来等待 JavaScript 对话框的出现。此方法接受一个可选参数，该参数指示等待对话框出现多少秒：\r\n\r\n    $browser->waitForDialog($seconds = null);\r\n\r\n该 `assertDialogOpened` 方法，断言对话框已经显示，并且其消息与给定值匹配：\r\n\r\n    $browser->assertDialogOpened('Dialog message');\r\n\r\n`typeInDialog` 方法，在打开的 JavaScript 提示对话框中输入给定值：\r\n\r\n    $browser->typeInDialog('Hello World');\r\n\r\n`acceptDialog` 方法，通过点击确定按钮关闭打开的 JavaScript 对话框：\r\n\r\n    $browser->acceptDialog();\r\n\r\n`dismissDialog` 方法，通过点击取消按钮关闭打开的 JavaScript 对话框（仅对确认对话框有效）：\r\n\r\n    $browser->dismissDialog();\r\n\r\n<a name=\"scoping-selectors\"></a>\r\n### 选择器作用范围\r\n\r\n有时可能希望在给定的选择器范围内执行多个操作。比如，可能想要断言表格中存在某些文本，然后点击表格中的一个按钮。那么你可以使用 `with` 方法实现此需求。在传递给 `with` 方法的闭包内执行的所有操作都将限于原始选择器：\r\n\r\n    $browser->with('.table', function ($table) {\r\n        $table->assertSee('Hello World')\r\n              ->clickLink('Delete');\r\n    });\r\n\r\n你可能偶尔需要在当前范围之外执行断言。 你可以使用 `elsewhere` 和 `elsewhereWhenAvailable` 方法来完成此操作：\r\n\r\n     $browser->with('.table', function ($table) {\r\n        // 当前范围是 `body .table`...\r\n\r\n        $browser->elsewhere('.page-title', function ($title) {\r\n            // 当前范围是 `body .page-title`...\r\n            $title->assertSee('Hello World');\r\n        });\r\n\r\n        $browser->elsewhereWhenAvailable('.page-title', function ($title) {\r\n            // 当前范围是 `body .page-title`...\r\n            $title->assertSee('Hello World');\r\n        });\r\n     });\r\n\r\n\n\n<a name=\"waiting-for-elements\"></a>\r\n### 等待元素\r\n\r\n在测试大面积使用 JavaScript 的应用时，在进行测试之前，通常有必要 「等待」 某些元素或数据可用。Dusk 可轻松实现。使用一系列方法，可以等到页面元素可用，甚至给定的 JavaScript 表达式执行结果为 `true`。\r\n\r\n<a name=\"waiting\"></a>\r\n#### 等待\r\n\r\n如果需要测试暂停指定的毫秒数， 使用 `pause` 方法：\r\n\r\n    $browser->pause(1000);\r\n\r\n<a name=\"waiting-for-selectors\"></a>\r\n#### 等待选择器\r\n\r\n该 `waitFor` 方法可以用于暂停执行测试，直到页面上与给定 CSS 选择器匹配的元素被显示。默认情况下，将在暂停超过 5 秒后抛出异常。如有必要，可以传递自定义超时时长作为其第二个参数：\r\n\r\n    // 等待选择器不超过 5 秒...\r\n    $browser->waitFor('.selector');\r\n\r\n    // 等待选择器不超过 1 秒...\r\n    $browser->waitFor('.selector', 1);\r\n\r\n你也可以等待选择器显示给定文字：\r\n\r\n    //  等待选择器不超过 5 秒包含给定文字...\r\n    $browser->waitForTextIn('.selector', 'Hello World');\r\n\r\n    //  等待选择器不超过 1 秒包含给定文字...\r\n    $browser->waitForTextIn('.selector', 'Hello World', 1);\r\n\r\n你也可以等待指定选择器从页面消失:\r\n\r\n    // 等待不超过 5 秒 直到选择器消失...\r\n    $browser->waitUntilMissing('.selector');\r\n\r\n    // 等待不超过 1 秒 直到选择器消失...\r\n    $browser->waitUntilMissing('.selector', 1);\r\n\r\n\n\n或者，您可以等待与给定选择器匹配的元素被启用或禁用：\r\n\r\n    // 最多等待 5 秒钟，直到选择器启用...\r\n    $browser->waitUntilEnabled('.selector');\r\n\r\n    // 最多等待 1 秒钟，直到选择器启用...\r\n    $browser->waitUntilEnabled('.selector', 1);\r\n\r\n    // 最多等待 5 秒钟，直到选择器被禁用...\r\n    $browser->waitUntilDisabled('.selector');\r\n\r\n    // 最多等待 1 秒钟，直到选择器被禁用...\r\n    $browser->waitUntilDisabled('.selector', 1);\r\n\r\n<a name=\"scoping-selectors-when-available\"></a>\r\n#### 限定作用域范围（可用时）\r\n\r\n有时，你或许希望等待给定选择器出现，然后与匹配选择器的元素进行交互。例如，你可能希望等到模态窗口可用，然后在模态窗口中点击「确定」按钮。在这种情况下，可以使用 `whenAvailable` 方法。给定回调内的所有要执行的元素操作都将被限定在起始选择器上:\r\n\r\n    $browser->whenAvailable('.modal', function ($modal) {\r\n        $modal->assertSee('Hello World')\r\n              ->press('OK');\r\n    });\r\n\r\n<a name=\"waiting-for-text\"></a>\r\n#### 等待文本\r\n\r\n该 `waitForText` 方法可以用于等待页面上给定文字被显示：\r\n\r\n    // 等待指定文本不超过 5 秒...\r\n    $browser->waitForText('Hello World');\r\n\r\n    // 等待指定文本不超过 1 秒...\r\n    $browser->waitForText('Hello World', 1);\r\n\r\n你可以使用 `waitUntilMissingText` 方法来等待，直到显示的文本已从页面中删除为止:\r\n\r\n    // 最多等待 5 秒删除文本...\r\n    $browser->waitUntilMissingText('Hello World');\r\n\r\n    // 最多等待 1 秒删除文本...\r\n    $browser->waitUntilMissingText('Hello World', 1);\r\n\r\n\n\n<a name=\"waiting-for-links\"></a>\r\n#### 等待链接\r\n\r\n该 `waitForLink` 方法用于等待给定链接文字在页面上显示:\r\n\r\n    // 等待链接最多 5 秒...\r\n    $browser->waitForLink('Create');\r\n\r\n    // 等待链接最多 1 秒...\r\n    $browser->waitForLink('Create', 1);\r\n\r\n<a name=\"waiting-on-the-page-location\"></a>\r\n#### 等待页面跳转\r\n\r\n当给出类似 `$browser->assertPathIs('/home')` 的路径断言时，如果 `window.location.pathname` 被异步更新，断言就会失败。可以使用 `waitForLocation` 方法等待页面跳转到给定路径：\r\n\r\n    $browser->waitForLocation('/secret');\r\n\r\n该 `waitForLocation` 方法还可用于等待当前窗口位置成为完全限定的 URL：\r\n\r\n    $browser->waitForLocation('https://example.com/path');\r\n\r\n还可以使用 [被命名的路由](/docs/laravel/9.x/routing#named-routes) 等待跳转：\r\n\r\n    $browser->waitForRoute($routeName, $parameters);\r\n\r\n<a name=\"waiting-for-page-reloads\"></a>\r\n#### 等待页面重新加载\r\n\r\n如果要在页面重新加载后断言，可以使用 `waitForReload` 方法：\r\n\r\n    use Laravel\\Dusk\\Browser;\r\n\r\n    $browser->waitForReload(function (Browser $browser) {\r\n        $browser->press('Submit');\r\n    })\r\n    ->assertSee('Success!');\r\n\r\n由于需要等待页面重新加载通常发生在单击按钮之后，为了方便起见，您可以使用 `clickAndWaitForReload` 方法：\r\n\r\n    $browser->clickAndWaitForReload('.selector')\r\n            ->assertSee('something');\r\n\r\n<a name=\"waiting-on-javascript-expressions\"></a>\r\n#### 等待 JavaScript 表达式\r\n\r\n有时候会希望暂停测试的执行，直到给定的 JavaScript 表达式执行结果为 `true`。可以使用 `waitUntil` 方法轻松地达成此目的。 通过这个方法执行表达式，不需要包含 `return` 关键字或者结束分号：\r\n\r\n    // 等待表达式为 true 5 秒时间...\r\n    $browser->waitUntil('App.data.servers.length > 0');\r\n\r\n    // 等待表达式为 true 1 秒时间...\r\n    $browser->waitUntil('App.data.servers.length > 0', 1);\r\n\r\n\n\n<a name=\"waiting-on-vue-expressions\"></a>\r\n#### 等待 Vue 表达式\r\n\r\n该 `waitUntilVue` 和 `waitUntilVueIsNot` 方法可以一直等待，直到 [Vue 组件](https://vuejs.org) 的属性包含给定的值：\r\n\r\n    // 一直等待，直到组件属性包含给定的值...\r\n    $browser->waitUntilVue('user.name', 'Taylor', '@user');\r\n\r\n    // 一直等待，直到组件属性不包含给定的值...\r\n    $browser->waitUntilVueIsNot('user.name', null, '@user');\r\n\r\n<a name=\"waiting-with-a-callback\"></a>\r\n#### 等待回调\r\n\r\nDusk 中的许多 「wait」 方法都依赖于底层方法 waitUsing。你可以直接用这个方法去等待一个回调函数返回 `waitUsing` 。你可以直接用这个方法去等待一个回调函数返回 `true`。该 `waitUsing` 方法接收一个最大的等待秒数，闭包执行间隔时间，闭包，以及一个可选的失败信息：\r\n\r\n    $browser->waitUsing(10, 1, function () use ($something) {\r\n        return $something->isReady();\r\n    }, \"Something wasn't ready in time.\");\r\n\r\n<a name=\"scrolling-an-element-into-view\"></a>\r\n### 滚动元素到视图中\r\n\r\n有时您可能无法单击某个元素，因为该元素在浏览器的可见区域之外。该 `scrollIntoView` 方法可以将元素滚动到浏览器可视窗口内：\r\n\r\n    $browser->scrollIntoView('.selector')\r\n            ->click('.selector');\r\n\r\n<a name=\"available-assertions\"></a>\r\n## 可用的断言\r\n\r\nDusk 提供了各种你可以对应用使用的断言。所有可用的断言罗列如下：\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\r\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[assertTitle](#assert-title)\r\n[assertTitleContains](#assert-title-contains)\r\n[assertUrlIs](#assert-url-is)\r\n[assertSchemeIs](#assert-scheme-is)\r\n[assertSchemeIsNot](#assert-scheme-is-not)\r\n[assertHostIs](#assert-host-is)\r\n[assertHostIsNot](#assert-host-is-not)\r\n[assertPortIs](#assert-port-is)\r\n[assertPortIsNot](#assert-port-is-not)\r\n[assertPathBeginsWith](#assert-path-begins-with)\r\n[assertPathIs](#assert-path-is)\r\n[assertPathIsNot](#assert-path-is-not)\r\n[assertRouteIs](#assert-route-is)\r\n[assertQueryStringHas](#assert-query-string-has)\r\n[assertQueryStringMissing](#assert-query-string-missing)\r\n[assertFragmentIs](#assert-fragment-is)\r\n[assertFragmentBeginsWith](#assert-fragment-begins-with)\r\n[assertFragmentIsNot](#assert-fragment-is-not)\r\n[assertHasCookie](#assert-has-cookie)\r\n[assertHasPlainCookie](#assert-has-plain-cookie)\r\n[assertCookieMissing](#assert-cookie-missing)\r\n[assertPlainCookieMissing](#assert-plain-cookie-missing)\r\n[assertCookieValue](#assert-cookie-value)\r\n[assertPlainCookieValue](#assert-plain-cookie-value)\r\n[assertSee](#assert-see)\r\n[assertDontSee](#assert-dont-see)\r\n[assertSeeIn](#assert-see-in)\r\n[assertDontSeeIn](#assert-dont-see-in)\r\n[assertSeeAnythingIn](#assert-see-anything-in)\r\n[assertSeeNothingIn](#assert-see-nothing-in)\r\n[assertScript](#assert-script)\r\n[assertSourceHas](#assert-source-has)\r\n[assertSourceMissing](#assert-source-missing)\r\n[assertSeeLink](#assert-see-link)\r\n[assertDontSeeLink](#assert-dont-see-link)\r\n[assertInputValue](#assert-input-value)\r\n[assertInputValueIsNot](#assert-input-value-is-not)\r\n[assertChecked](#assert-checked)\r\n[assertNotChecked](#assert-not-checked)\r\n[assertRadioSelected](#assert-radio-selected)\r\n[assertRadioNotSelected](#assert-radio-not-selected)\r\n[assertSelected](#assert-selected)\r\n[assertNotSelected](#assert-not-selected)\r\n[assertSelectHasOptions](#assert-select-has-options)\r\n[assertSelectMissingOptions](#assert-select-missing-options)\r\n[assertSelectHasOption](#assert-select-has-option)\r\n[assertSelectMissingOption](#assert-select-missing-option)\r\n[assertValue](#assert-value)\r\n[assertValueIsNot](#assert-value-is-not)\r\n[assertAttribute](#assert-attribute)\r\n[assertAttributeContains](#assert-attribute-contains)\r\n[assertAriaAttribute](#assert-aria-attribute)\r\n[assertDataAttribute](#assert-data-attribute)\r\n[assertVisible](#assert-visible)\r\n[assertPresent](#assert-present)\r\n[assertNotPresent](#assert-not-present)\r\n[assertMissing](#assert-missing)\r\n[assertInputPresent](#assert-input-present)\r\n[assertInputMissing](#assert-input-missing)\r\n[assertDialogOpened](#assert-dialog-opened)\r\n[assertEnabled](#assert-enabled)\r\n[assertDisabled](#assert-disabled)\r\n[assertButtonEnabled](#assert-button-enabled)\r\n[assertButtonDisabled](#assert-button-disabled)\r\n[assertFocused](#assert-focused)\r\n[assertNotFocused](#assert-not-focused)\r\n[assertAuthenticated](#assert-authenticated)\r\n[assertGuest](#assert-guest)\r\n[assertAuthenticatedAs](#assert-authenticated-as)\r\n[assertVue](#assert-vue)\r\n[assertVueIsNot](#assert-vue-is-not)\r\n[assertVueContains](#assert-vue-contains)\r\n[assertVueDoesNotContain](#assert-vue-does-not-contain)\r\n\r\n</div>\r\n\r\n\n\n<a name=\"assert-title\"></a>\r\n#### assertTitle\r\n\r\n断言页面标题为给定文本：\r\n\r\n    $browser->assertTitle($title);\r\n\r\n<a name=\"assert-title-contains\"></a>\r\n#### assertTitleContains\r\n\r\n断言页面标题包含给定文本：\r\n\r\n    $browser->assertTitleContains($title);\r\n\r\n<a name=\"assert-url-is\"></a>\r\n#### assertUrlIs\r\n\r\n断言当前的 URL（不包含 query string）是给定的字符串：\r\n\r\n    $browser->assertUrlIs($url);\r\n\r\n<a name=\"assert-scheme-is\"></a>\r\n#### assertSchemeIs\r\n\r\n断言当前的 URL scheme 是给定的 scheme：\r\n\r\n    $browser->assertSchemeIs($scheme);\r\n\r\n<a name=\"assert-scheme-is-not\"></a>\r\n#### assertSchemeIsNot\r\n\r\n断言当前的 URL scheme 不是给定的 scheme：\r\n\r\n    $browser->assertSchemeIsNot($scheme);\r\n\r\n<a name=\"assert-host-is\"></a>\r\n#### assertHostIs\r\n\r\n断言当前的 URL host 是给定的 host：\r\n\r\n    $browser->assertHostIs($host);\r\n\r\n<a name=\"assert-host-is-not\"></a>\r\n#### assertHostIsNot\r\n\r\n断言当前的 URL host 不是给定的 host：\r\n\r\n    $browser->assertHostIsNot($host);\r\n\r\n<a name=\"assert-port-is\"></a>\r\n#### assertPortIs\r\n\r\n断言当前的 URL 端口是给定的端口：\r\n\r\n    $browser->assertPortIs($port);\r\n\r\n<a name=\"assert-port-is-not\"></a>\r\n#### assertPortIsNot\r\n\r\n断言当前的 URL 端口不是给定的端口：\r\n\r\n    $browser->assertPortIsNot($port);\r\n\r\n<a name=\"assert-path-begins-with\"></a>\r\n#### assertPathBeginsWith\r\n\r\n断言当前的 URL 路径以给定的路径开始：\r\n\r\n    $browser->assertPathBeginsWith('/home');\r\n\r\n<a name=\"assert-path-is\"></a>\r\n#### assertPathIs\r\n\r\n断言当前的路径是给定的路径：\r\n\r\n    $browser->assertPathIs('/home');\r\n\r\n<a name=\"assert-path-is-not\"></a>\r\n#### assertPathIsNot\r\n\r\n断言当前的路径不是给定的路径：\r\n\r\n    $browser->assertPathIsNot('/home');\r\n\r\n<a name=\"assert-route-is\"></a>\r\n#### assertRouteIs\r\n\r\n断言给定的 URL 是给定的 [命名路由](/docs/laravel/9.x/routing#named-routes) 的 URL:\r\n\r\n    $browser->assertRouteIs($name, $parameters);\r\n\r\n\n\n<a name=\"assert-query-string-has\"></a>\r\n#### assertQueryStringHas\r\n\r\n断言给定的查询字符串参数存在：\r\n\r\n    $browser->assertQueryStringHas($name);\r\n\r\n断言给定的查询字符串参数存在并且具有给定的值：\r\n\r\n    $browser->assertQueryStringHas($name, $value);\r\n\r\n<a name=\"assert-query-string-missing\"></a>\r\n#### assertQueryStringMissing\r\n\r\n断言缺少给定的查询字符串参数：\r\n\r\n    $browser->assertQueryStringMissing($name);\r\n\r\n<a name=\"assert-fragment-is\"></a>\r\n#### assertFragmentIs\r\n\r\n断言 URL 的当前哈希片段与给定的片段匹配：\r\n\r\n    $browser->assertFragmentIs('anchor');\r\n\r\n<a name=\"assert-fragment-begins-with\"></a>\r\n#### assertFragmentBeginsWith\r\n\r\n断言 URL 的当前哈希片段以给定片段开头：\r\n\r\n    $browser->assertFragmentBeginsWith('anchor');\r\n\r\n<a name=\"assert-fragment-is-not\"></a>\r\n#### assertFragmentIsNot\r\n\r\n断言 URL 的当前哈希片段与给定的片段不匹配：\r\n\r\n    $browser->assertFragmentIsNot('anchor');\r\n\r\n<a name=\"assert-has-cookie\"></a>\r\n#### assertHasCookie\r\n\r\n断言给定的加密 cookie 存在：\r\n\r\n    $browser->assertHasCookie($name);\r\n\r\n<a name=\"assert-has-plain-cookie\"></a>\r\n#### assertHasPlainCookie\r\n\r\n断言给定的未加密 cookie 存在：\r\n\r\n    $browser->assertHasPlainCookie($name);\r\n\r\n<a name=\"assert-cookie-missing\"></a>\r\n#### assertCookieMissing\r\n\r\n断言给定的加密 cookie 不存在：\r\n\r\n    $browser->assertCookieMissing($name);\r\n\r\n<a name=\"assert-plain-cookie-missing\"></a>\r\n#### assertPlainCookieMissing\r\n\r\n断言给定的未加密 cookie 不存在：\r\n\r\n    $browser->assertPlainCookieMissing($name);\r\n\r\n<a name=\"assert-cookie-value\"></a>\r\n#### assertCookieValue\r\n\r\n断言加密的 cookie 具有给定值：\r\n\r\n    $browser->assertCookieValue($name, $value);\r\n\r\n<a name=\"assert-plain-cookie-value\"></a>\r\n#### assertPlainCookieValue\r\n\r\n断言未加密的 cookie 具有给定值：\r\n\r\n    $browser->assertPlainCookieValue($name, $value);\r\n\r\n<a name=\"assert-see\"></a>\r\n#### assertSee\r\n\r\n断言在页面中有给定的文本：\r\n\r\n    $browser->assertSee($text);\r\n\r\n<a name=\"assert-dont-see\"></a>\r\n#### assertDontSee\r\n\r\n断言在页面中没有给定的文本：\r\n\r\n    $browser->assertDontSee($text);\r\n\r\n\n\n<a name=\"assert-see-in\"></a>\r\n#### assertSeeIn\r\n\r\n断言在选择器中有给定的文本：\r\n\r\n    $browser->assertSeeIn($selector, $text);\r\n\r\n<a name=\"assert-dont-see-in\"></a>\r\n#### assertDontSeeIn\r\n\r\n断言在选择器中不存在给定的文本：\r\n\r\n    $browser->assertDontSeeIn($selector, $text);\r\n\r\n<a name=\"assert-see-anything-in\"></a>\r\n#### assertSeeAnythingIn\r\n\r\n断言在选择器中存在任意的文本：\r\n\r\n    $browser->assertSeeAnythingIn($selector);\r\n\r\n<a name=\"assert-see-nothing-in\"></a>\r\n#### assertSeeNothingIn\r\n\r\n断言在选择器中不存在文本：\r\n\r\n    $browser->assertSeeNothingIn($selector);\r\n\r\n<a name=\"assert-script\"></a>\r\n#### assertScript\r\n\r\n断言给定的 JavaScript 表达式结果为给定的值：\r\n\r\n    $browser->assertScript('window.isLoaded')\r\n            ->assertScript('document.readyState', 'complete');\r\n\r\n<a name=\"assert-source-has\"></a>\r\n#### assertSourceHas\r\n\r\n断言在页面中存在给定的源码：\r\n\r\n    $browser->assertSourceHas($code);\r\n\r\n<a name=\"assert-source-missing\"></a>\r\n#### assertSourceMissing\r\n\r\n断言页面中没有给定的源码：\r\n\r\n    $browser->assertSourceMissing($code);\r\n\r\n<a name=\"assert-see-link\"></a>\r\n#### assertSeeLink\r\n\r\n断言在页面中存在指定的链接：\r\n\r\n    $browser->assertSeeLink($linkText);\r\n\r\n<a name=\"assert-dont-see-link\"></a>\r\n#### assertDontSeeLink\r\n\r\n断言页面中没有指定的链接：\r\n\r\n    $browser->assertDontSeeLink($linkText);\r\n\r\n<a name=\"assert-input-value\"></a>\r\n#### assertInputValue\r\n\r\n断言输入框（input）有给定的值：\r\n\r\n    $browser->assertInputValue($field, $value);\r\n\r\n<a name=\"assert-input-value-is-not\"></a>\r\n#### assertInputValueIsNot\r\n\r\n断言输入框没有给定的值：\r\n\r\n    $browser->assertInputValueIsNot($field, $value);\r\n\r\n<a name=\"assert-checked\"></a>\r\n#### assertChecked\r\n\r\n断言复选框（checkbox）被选中：\r\n\r\n    $browser->assertChecked($field);\r\n\r\n<a name=\"assert-not-checked\"></a>\r\n#### assertNotChecked\r\n\r\n断言复选框没有被选中：\r\n\r\n    $browser->assertNotChecked($field);\r\n\r\n<a name=\"assert-radio-selected\"></a>\r\n#### assertRadioSelected\r\n\r\n断言单选框（radio）被选中：\r\n\r\n    $browser->assertRadioSelected($field, $value);\r\n\r\n\n\n<a name=\"assert-radio-not-selected\"></a>\r\n#### assertRadioNotSelected\r\n\r\n断言单选框（radio）没有被选中：\r\n\r\n    $browser->assertRadioNotSelected($field, $value);\r\n\r\n<a name=\"assert-selected\"></a>\r\n#### assertSelected\r\n\r\n断言下拉框有给定的值:\r\n\r\n    $browser->assertSelected($field, $value);\r\n\r\n<a name=\"assert-not-selected\"></a>\r\n#### assertNotSelected\r\n\r\n断言下拉框没有给定的值：\r\n\r\n    $browser->assertNotSelected($field, $value);\r\n\r\n<a name=\"assert-select-has-options\"></a>\r\n#### assertSelectHasOptions\r\n\r\n断言给定的数组值是可选的：\r\n\r\n    $browser->assertSelectHasOptions($field, $values);\r\n\r\n<a name=\"assert-select-missing-options\"></a>\r\n#### assertSelectMissingOptions\r\n\r\n断言给定的数组值是不可选的：\r\n\r\n    $browser->assertSelectMissingOptions($field, $values);\r\n\r\n<a name=\"assert-select-has-option\"></a>\r\n#### assertSelectHasOption\r\n\r\n断言给定的值在给定的地方是可供选择的：\r\n\r\n    $browser->assertSelectHasOption($field, $value);\r\n\r\n<a name=\"assert-select-missing-option\"></a>\r\n#### assertSelectMissingOption\r\n\r\n断言给定的值不可选：\r\n\r\n    $browser->assertSelectMissingOption($field, $value);\r\n\r\n<a name=\"assert-value\"></a>\r\n#### assertValue\r\n\r\n断言选择器范围内的元素存在指定的值：\r\n\r\n    $browser->assertValue($selector, $value);\r\n\r\n<a name=\"assert-value-is-not\"></a>\r\n#### assertValueIsNot\r\n\r\n断言选择器范围内的元素不存在指定的值：\r\n\r\n    $browser->assertValueIsNot($selector, $value);\r\n\r\n<a name=\"assert-attribute\"></a>\r\n#### assertAttribute\r\n\r\n断言与给定选择器匹配的元素在提供的属性中具有给定的值：\r\n\r\n    $browser->assertAttribute($selector, $attribute, $value);\r\n\r\n<a name=\"assert-attribute-contains\"></a>\r\n#### assertAttributeContains\r\n\r\n断言匹配给定选择器的元素在提供的属性中包含给定值：\r\n\r\n    $browser->assertAttributeContains($selector, $attribute, $value);\r\n\r\n<a name=\"assert-aria-attribute\"></a>\r\n#### assertAriaAttribute\r\n\r\n断言与给定选择器匹配的元素在给定的 aria 属性中具有给定的值：\r\n\r\n    $browser->assertAriaAttribute($selector, $attribute, $value);\r\n\r\n\n\n例如，给定标记 `<button aria-label=\"Add\"></button>`，您可以像这样声明 `aria-label` 属性：\r\n\r\n    $browser->assertAriaAttribute('button', 'label', 'Add')\r\n\r\n<a name=\"assert-data-attribute\"></a>\r\n#### assertDataAttribute\r\n\r\n断言与给定选择器匹配的元素在提供的 data 属性中具有给定的值：\r\n\r\n    $browser->assertDataAttribute($selector, $attribute, $value);\r\n\r\n例如，给定标记 `<tr id=\"row-1\" data-content=\"attendees\"></tr>`，您可以像这样断言 `data-label` 属性：\r\n\r\n    $browser->assertDataAttribute('#row-1', 'content', 'attendees')\r\n\r\n<a name=\"assert-visible\"></a>\r\n#### assertVisible\r\n\r\n断言匹配给定选择器的元素可见:\r\n\r\n    $browser->assertVisible($selector);\r\n\r\n<a name=\"assert-present\"></a>\r\n#### assertPresent\r\n\r\n断言匹配给定选择器的元素存在：\r\n\r\n    $browser->assertPresent($selector);\r\n\r\n<a name=\"assert-not-present\"></a>\r\n#### assertNotPresent\r\n\r\n断言源中不存在与给定选择器匹配的元素：\r\n\r\n    $browser->assertNotPresent($selector);\r\n\r\n<a name=\"assert-missing\"></a>\r\n#### assertMissing\r\n\r\n断言匹配给定选择器的元素不可见：\r\n\r\n    $browser->assertMissing($selector);\r\n\r\n<a name=\"assert-input-present\"></a>\r\n#### assertInputPresent\r\n\r\n断言具有给定名称的输入存在：\r\n\r\n    $browser->assertInputPresent($name);\r\n\r\n<a name=\"assert-input-missing\"></a>\r\n#### assertInputMissing\r\n\r\n断言源中不存在具有给定名称的输入：\r\n\r\n    $browser->assertInputMissing($name);\r\n\r\n<a name=\"assert-dialog-opened\"></a>\r\n#### assertDialogOpened\r\n\r\n断言已打开带有给定消息的 JavaScript 对话框：\r\n\r\n    $browser->assertDialogOpened($message);\r\n\r\n<a name=\"assert-enabled\"></a>\r\n#### assertEnabled\r\n\r\n断言给定的字段已启用：\r\n\r\n    $browser->assertEnabled($field);\r\n\r\n<a name=\"assert-disabled\"></a>\r\n#### assertDisabled\r\n\r\n断言给定的字段被禁用：\r\n\r\n    $browser->assertDisabled($field);\r\n\r\n<a name=\"assert-button-enabled\"></a>\r\n\n\n#### assertButtonEnabled\r\n\r\n断言给定的按钮已启用：\r\n\r\n    $browser->assertButtonEnabled($button);\r\n\r\n<a name=\"assert-button-disabled\"></a>\r\n#### assertButtonDisabled\r\n\r\n断言给定的按钮被禁用：\r\n\r\n    $browser->assertButtonDisabled($button);\r\n\r\n<a name=\"assert-focused\"></a>\r\n#### assertFocused\r\n\r\n断言给定的字段是焦点：\r\n\r\n    $browser->assertFocused($field);\r\n\r\n<a name=\"assert-not-focused\"></a>\r\n#### assertNotFocused\r\n\r\n断言给定字段未聚焦：\r\n\r\n    $browser->assertNotFocused($field);\r\n\r\n<a name=\"assert-authenticated\"></a>\r\n#### assertAuthenticated\r\n\r\n断言用户已通过身份验证：\r\n\r\n    $browser->assertAuthenticated();\r\n\r\n<a name=\"assert-guest\"></a>\r\n#### assertGuest\r\n\r\n断言用户未通过身份验证：\r\n\r\n    $browser->assertGuest();\r\n\r\n<a name=\"assert-authenticated-as\"></a>\r\n#### assertAuthenticatedAs\r\n\r\n断言用户已作为给定用户进行身份验证：\r\n\r\n    $browser->assertAuthenticatedAs($user);\r\n\r\n<a name=\"assert-vue\"></a>\r\n#### assertVue\r\n\r\nDusk 甚至允许您对 [Vue 组件](https://vuejs.org) 数据的状态进行断言。例如，假设您的应用程序包含以下 Vue 组件：\r\n\r\n    // HTML...\r\n\r\n    <profile dusk=\"profile-component\"></profile>\r\n\r\n    // 组件定义...\r\n\r\n    Vue.component('profile', {\r\n        template: '<div>{{ user.name }}</div>',\r\n\r\n        data: function () {\r\n            return {\r\n                user: {\r\n                    name: 'Taylor'\r\n                }\r\n            };\r\n        }\r\n    });\r\n\r\n你可以像这样断言 Vue 组件的状态：\r\n\r\n    /**\r\n     * 一个基本的 Vue 测试示例\r\n     *\r\n     * @return void\r\n     */\r\n    public function testVue()\r\n    {\r\n        $this->browse(function (Browser $browser) {\r\n            $browser->visit('/')\r\n                    ->assertVue('user.name', 'Taylor', '@profile-component');\r\n        });\r\n    }\r\n\r\n<a name=\"assert-vue-is-not\"></a>\r\n#### assertVueIsNot\r\n\r\n断言 Vue 组件数据的属性不匹配给定的值：\r\n\r\n    $browser->assertVueIsNot($property, $value, $componentSelector = null);\r\n\r\n<a name=\"assert-vue-contains\"></a>\r\n#### assertVueContains\r\n\r\n断言 Vue 组件数据的属性是一个数组，并包含给定的值：\r\n\r\n    $browser->assertVueContains($property, $value, $componentSelector = null);\r\n\r\n<a name=\"assert-vue-does-not-contain\"></a>\r\n\n\n#### assertVueDoesNotContain\r\n\r\n断言 Vue 组件数据的属性是一个数组，且不包含给定的值：\r\n\r\n    $browser->assertVueDoesNotContain($property, $value, $componentSelector = null);\r\n\r\n<a name=\"pages\"></a>\r\n## Pages\r\n\r\n有时，测试需要按顺序执行几个复杂的操作。这会使测试代码更难阅读和理解。 Dusk Pages 允许您定义语义化的操作，然后可以通过单一方法在给定页面上执行这些操作。Pages 还可以为应用或单个页面定义通用选择器的快捷方式。\r\n\r\n<a name=\"generating-pages\"></a>\r\n### 生成 Pages\r\n\r\n`dusk:page` Artisan 命令可以生成页面对象。所有的页面对象都位于 `tests/Browser/Pages` 目录：\r\n\r\n    php artisan dusk:page Login\r\n\r\n<a name=\"configuring-pages\"></a>\r\n### 配置 Pages\r\n\r\n默认情况下，页面具有三种方法：`url`、`assert` 和 `elements`。我们现在将讨论 `url` 和 `assert` 方法。 `elements` 方法将 [在下面更详细地讨论](#shorthand-selectors)。\r\n\r\n<a name=\"the-url-method\"></a>\r\n#### `url` 方法\r\n\r\n`url` 方法应该返回表示页面 URL 的路径。 Dusk 将会在浏览器中使用这个 URL 来导航到具体页面：\r\n\r\n    /**\r\n     * 获取页面的 URL。\r\n     *\r\n     * @return string\r\n     */\r\n    public function url()\r\n    {\r\n        return '/login';\r\n    }\r\n\r\n<a name=\"the-assert-method\"></a>\r\n#### `assert` 方法\r\n\r\n`assert` 方法可以作出任何断言来验证浏览器是否在指定页面上。实际上没有必要在这个方法中放置任何东西；但是，你可以按自己的需求来做出这些断言。导航到页面时，这些断言将自动运行：\r\n\r\n    /**\r\n     * 断言浏览器当前处于指定页面。\r\n     *\r\n     * @return void\r\n     */\r\n    public function assert(Browser $browser)\r\n    {\r\n        $browser->assertPathIs($this->url());\r\n    }\r\n\r\n\n\n<a name=\"navigating-to-pages\"></a>\r\n### 导航至页面\r\n\r\n一旦页面定义好之后，你可以使用 `visit` 方法导航至页面：\r\n\r\n    use Tests\\Browser\\Pages\\Login;\r\n\r\n    $browser->visit(new Login);\r\n\r\n有时您可能已经在给定的页面上，需要将页面的选择器和方法「加载」到当前的测试上下文中。 这在通过按钮重定向到指定页面而没有明确导航到该页面时很常见。 在这种情况下，您可以使用 `on` 方法加载页面：\r\n\r\n    use Tests\\Browser\\Pages\\CreatePlaylist;\r\n\r\n    $browser->visit('/dashboard')\r\n            ->clickLink('Create Playlist')\r\n            ->on(new CreatePlaylist)\r\n            ->assertSee('@create');\r\n\r\n<a name=\"shorthand-selectors\"></a>\r\n### 选择器简写\r\n\r\n该 `elements` 方法允许你为页面中的任何 CSS 选择器定义简单易记的简写。例如，让我们为应用登录页中的 email 输入框定义一个简写：\r\n\r\n    /**\r\n     * 获取页面元素的简写\r\n     *\r\n     * @return array\r\n     */\r\n    public function elements()\r\n    {\r\n        return [\r\n            '@email' => 'input[name=email]',\r\n        ];\r\n    }\r\n\r\n一旦定义了简写，你就可以用这个简写来代替之前在页面中使用的完整 CSS 选择器：\r\n\r\n    $browser->type('@email', 'taylor@laravel.com');\r\n\r\n<a name=\"global-shorthand-selectors\"></a>\r\n#### 全局的选择器简写\r\n\r\n安装 Dusk 之后， `Page` 基类存放在你的 `tests/Browser/Pages` 目录。该类中包含一个 `siteElements` 方法，这个方法可以用来定义全局的选择器简写，这样在你应用中每个页面都可以使用这些全局选择器简写了：\r\n\r\n    /**\r\n     * 获取站点全局的选择器简写。\r\n     *\r\n     * @return array\r\n     */\r\n    public static function siteElements()\r\n    {\r\n        return [\r\n            '@element' => '#selector',\r\n        ];\r\n    }\r\n\r\n\n\n<a name=\"page-methods\"></a>\r\n### 页面方法\r\n\r\n除了页面中已经定义的默认方法之外，你还可以定义在整个测试过程中会使用到的其他方法。例如，假设我们正在开发一个音乐管理应用，在应用中每个页面都可能需要一个公共的方法来创建播放列表，而不是在每一个测试类中都重写一遍创建播放列表的逻辑，这时候你可以在你的页面类中定义一个  `createPlaylist`方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser\\Pages;\r\n\r\n    use Laravel\\Dusk\\Browser;\r\n\r\n    class Dashboard extends Page\r\n    {\r\n        // 其他页面方法...\r\n\r\n        /**\r\n         * 创建一个新的播放列表\r\n         *\r\n         * @param  \\Laravel\\Dusk\\Browser  $browser\r\n         * @param  string  $name\r\n         * @return void\r\n         */\r\n        public function createPlaylist(Browser $browser, $name)\r\n        {\r\n            $browser->type('name', $name)\r\n                    ->check('share')\r\n                    ->press('Create Playlist');\r\n        }\r\n    }\r\n\r\n方法被定义之后，你可以在任何使用到该页的测试中使用它了。浏览器实例会自动作为第一个参数传递给自定义页面方法：\r\n\r\n    use Tests\\Browser\\Pages\\Dashboard;\r\n\r\n    $browser->visit(new Dashboard)\r\n            ->createPlaylist('My Playlist')\r\n            ->assertSee('My Playlist');\r\n\r\n<a name=\"components\"></a>\r\n## 组件\r\n\r\n组件类似于 Dusk 的 「页面对象」，不过它更多的是贯穿整个应用程序中频繁重用的 UI 和功能片断，比如说导航条或信息通知弹窗。因此，组件并不会绑定于某个明确的 URL。\r\n\r\n<a name=\"generating-components\"></a>\r\n### 生成组件\r\n\r\n使用 `dusk:component` Artisan 命令即可生成组件。新生成的组件位于 `tests/Browser/Components` 目录下：\r\n\r\n    php artisan dusk:component DatePicker\r\n\r\n如上所示，这是生成一个 「日期选择器」（date picker） 组件的示例，这个组件可能会贯穿使用在你应用程序的许多页面中。在整个测试套件的大量测试页面中，手动编写日期选择的浏览器自动化逻辑会非常麻烦。 更方便的替代办法是，定义一个表示日期选择器的 Dusk 组件，然后把自动化逻辑封装在该组件内：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser\\Components;\r\n\r\n    use Laravel\\Dusk\\Browser;\r\n    use Laravel\\Dusk\\Component as BaseComponent;\r\n\r\n    class DatePicker extends BaseComponent\r\n    {\r\n        /**\r\n         * 获取组件的 root selector。\r\n         *\r\n         * @return string\r\n         */\r\n        public function selector()\r\n        {\r\n            return '.date-picker';\r\n        }\r\n\r\n        /**\r\n         * 断言浏览器包含组件。\r\n         *\r\n         * @param  Browser  $browser\r\n         * @return void\r\n         */\r\n        public function assert(Browser $browser)\r\n        {\r\n            $browser->assertVisible($this->selector());\r\n        }\r\n\r\n        /**\r\n         * 读取组件的元素简写。\r\n         *\r\n         * @return array\r\n         */\r\n        public function elements()\r\n        {\r\n            return [\r\n                '@date-field' => 'input.datepicker-input',\r\n                '@year-list' => 'div > div.datepicker-years',\r\n                '@month-list' => 'div > div.datepicker-months',\r\n                '@day-list' => 'div > div.datepicker-days',\r\n            ];\r\n        }\r\n\r\n        /**\r\n         * 选择给定日期。\r\n         *\r\n         * @param  \\Laravel\\Dusk\\Browser  $browser\r\n         * @param  int  $year\r\n         * @param  int  $month\r\n         * @param  int  $day\r\n         * @return void\r\n         */\r\n        public function selectDate(Browser $browser, $year, $month, $day)\r\n        {\r\n            $browser->click('@date-field')\r\n                    ->within('@year-list', function ($browser) use ($year) {\r\n                        $browser->click($year);\r\n                    })\r\n                    ->within('@month-list', function ($browser) use ($month) {\r\n                        $browser->click($month);\r\n                    })\r\n                    ->within('@day-list', function ($browser) use ($day) {\r\n                        $browser->click($day);\r\n                    });\r\n        }\r\n    }\r\n\r\n\n\n<a name=\"using-components\"></a>\r\n### 使用组件\r\n\r\n一旦定义了组件，在任何测试页面的日期选择器中选定一个日期就很轻松了。并且，如果需要修改选定日期的逻辑，仅修改该组件即可：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser;\r\n\r\n    use Illuminate\\Foundation\\Testing\\DatabaseMigrations;\r\n    use Laravel\\Dusk\\Browser;\r\n    use Tests\\Browser\\Components\\DatePicker;\r\n    use Tests\\DuskTestCase;\r\n\r\n    class ExampleTest extends DuskTestCase\r\n    {\r\n        /**\r\n         * 基本的组件测试示例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function testBasicExample()\r\n        {\r\n            $this->browse(function (Browser $browser) {\r\n                $browser->visit('/')\r\n                        ->within(new DatePicker, function ($browser) {\r\n                            $browser->selectDate(2019, 1, 30);\r\n                        })\r\n                        ->assertSee('January');\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"continuous-integration\"></a>\r\n## 持续集成\r\n\r\n> 注意：大多数 Dusk 持续集成配置都希望您的 Laravel 应用程序使用端口 8000 上的内置 PHP 开发服务器提供服务。因此，您应该确保您的持续集成环境有一个 `APP_URL` 境变量，值为 `http://127.0.0.1:8000`。\r\n\r\n<a name=\"running-tests-on-heroku-ci\"></a>\r\n### Heroku CI\r\n\r\n要在 [Heroku CI](https://www.heroku.com/continuous-integration) 运行 Dusk 测试，请将以下 Google Chrome buildpack 和 脚本添加到 Heroku 的 `app.json` 文件中：\r\n\r\n    {\r\n      \"environments\": {\r\n        \"test\": {\r\n          \"buildpacks\": [\r\n            { \"url\": \"heroku/php\" },\r\n            { \"url\": \"https://github.com/heroku/heroku-buildpack-google-chrome\" }\r\n          ],\r\n          \"scripts\": {\r\n            \"test-setup\": \"cp .env.testing .env\",\r\n            \"test\": \"nohup bash -c './vendor/laravel/dusk/bin/chromedriver-linux > /dev/null 2>&1 &' && nohup bash -c 'php artisan serve --no-reload > /dev/null 2>&1 &' && php artisan dusk\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n<a name=\"running-tests-on-travis-ci\"></a>\r\n### Travis CI\r\n\r\n要在 [Travis CI](https://travis-ci.org/) 运行 Dusk 测试，可以使用下面这个 `.travis.yml` 配置。由于 Travis CI 不是一个图形化的环境，我们还需要一些额外的步骤以便启动 Chrome 浏览器。此外，我们将会使用 `php artisan serve` 来启动 PHP 自带的 Web 服务器：\r\n\r\n```yaml\r\nlanguage: php\r\n\r\nphp:\r\n  - 7.3\r\n\r\naddons:\r\n  chrome: stable\r\n\r\ninstall:\r\n  - cp .env.testing .env\r\n  - travis_retry composer install --no-interaction --prefer-dist\r\n  - php artisan key:generate\r\n  - php artisan dusk:chrome-driver\r\n\r\nbefore_script:\r\n  - google-chrome-stable --headless --disable-gpu --remote-debugging-port=9222 http://localhost &\r\n  - php artisan serve --no-reload &\r\n\r\nscript:\r\n  - php artisan dusk\r\n```\r\n\r\n\n\n<a name=\"running-tests-on-github-actions\"></a>\r\n### GitHub Actions\r\n\r\n如果你正在使用 [Github Actions](https://github.com/features/actions) 来运行你的 Dusk 测试，你应该使用以下这份配置文件为起点。像 TravisCI 一样，我们使用 `php artisan serve` 命令来启动 PHP 的内置 Web 服务：\r\n\r\n```yaml\r\nname: CI\r\non: [push]\r\njobs:\r\n\r\n  dusk-php:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n      - name: Prepare The Environment\r\n        run: cp .env.example .env\r\n      - name: Create Database\r\n        run: |\r\n          sudo systemctl start mysql\r\n          mysql --user=\"root\" --password=\"root\" -e \"CREATE DATABASE 'my-database' character set UTF8mb4 collate utf8mb4_bin;\"\r\n      - name: Install Composer Dependencies\r\n        run: composer install --no-progress --prefer-dist --optimize-autoloader\r\n      - name: Generate Application Key\r\n        run: php artisan key:generate\r\n      - name: Upgrade Chrome Driver\r\n        run: php artisan dusk:chrome-driver `/opt/google/chrome/chrome --version | cut -d \" \" -f3 | cut -d \".\" -f1`\r\n      - name: Start Chrome Driver\r\n        run: ./vendor/laravel/dusk/bin/chromedriver-linux &\r\n      - name: Run Laravel Server\r\n        run: php artisan serve --no-reload &\r\n      - name: Run Dusk Tests\r\n        env:\r\n          APP_URL: \"http://127.0.0.1:8000\"\r\n        run: php artisan dusk\r\n      - name: Upload Screenshots\r\n        if: failure()\r\n        uses: actions/upload-artifact@v2\r\n        with:\r\n          name: screenshots\r\n          path: tests/Browser/screenshots\r\n      - name: Upload Console Logs\r\n        if: failure()\r\n        uses: actions/upload-artifact@v2\r\n        with:\r\n          name: console\r\n          path: tests/Browser/console\r\n```\r\n\n","p":"docs/dusk.html"},{"t":"database-testing (数据库测试)","d":"# 数据库测试\r\n\r\n- [介绍](#introduction)\r\n    - [每次测试后重置数据库](#resetting-the-database-after-each-test)\r\n- [定义模型的工厂](#defining-model-factories)\r\n    - [概念概述](#concept-overview)\r\n    - [创建工厂](#generating-factories)\r\n    - [工厂状态](#factory-states)\r\n    - [工厂回调](#factory-callbacks)\r\n- [使用工厂创建模型](#creating-models-using-factories)\r\n    - [实例化模型](#instantiating-models)\r\n    - [持久化模型](#persisting-models)\r\n    - [序列](#sequences)\r\n- [工厂关系](#factory-relationships)\r\n    - [一对多关系](#has-many-relationships)\r\n    - [一对多（反向）关系](#belongs-to-relationships)\r\n    - [多对多关系](#many-to-many-relationships)\r\n    - [多态关系](#polymorphic-relationships)\r\n    - [定义工厂内部关系](#defining-relationships-within-factories)\r\n- [运行 Seeders](#running-seeders)\r\n- [可用断言](#available-assertions)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 提供了各种有用的工具和断言，使测试数据库驱动的应用程序更加容易。此外，Laravel 模型工厂和 Seeders 可以轻松地使用应用程序的 Eloquent 模型和关系创建测试数据库记录。我们将在下面的文档中讨论所有这些强大的功能。\r\n\r\n<a name=\"resetting-the-database-after-each-test\"></a>\r\n### 每次测试后重置数据库\r\n\r\n在继续进行之前，让我们讨论如何在每个测试之后重置数据库，以便前一个测试的数据不会干扰后续测试。Laravel 包含的 Trait`Illuminate\\Foundation\\Testing\\RefreshDatabase` 将为你解决这一问题。只需在测试类上使用这个 Trait：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        use RefreshDatabase;\r\n\r\n        /**\r\n         * 一个基本的功能测试示例。\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_basic_example()\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            // ...\r\n        }\r\n    }\r\n\r\n如果你的数据库模式（Schema）是最新的，那么这个 Trait`Illuminate\\Foundation\\Testing\\RefreshDatabase` 并不会迁移数据库。相反，它将只在一个数据库事务中执行测试。因此，任何由测试用例添加到数据库的记录，如果不使用这个 Trait，可能仍然存在于数据库中。\r\n\r\n\r\n如果你想使用迁移来完全重置数据库，可以使用 Trait `Illuminate\\Foundation\\Testing\\DatabaseMigrations` 来代替。然而，`DatabaseMigrations`Trait 明显比 `RefreshDatabase` Trait 慢。\r\n\r\n<a name=\"defining-model-factories\"></a>\r\n## 定义模型工厂\r\n\r\n<a name=\"concept-overview\"></a>\r\n### 概念概述\r\n\r\n首先，让我们谈谈 Eloquent 模型工厂。测试时，你可能需要在执行测试之前向数据库中插入一些记录。 Laravel 允许你使用模型工厂为每个 [Eloquent 模型](/docs/laravel/9.x/eloquent) 定义一组默认属性，而不是在创建测试数据时手动指定每一列的值。\r\n\r\n要了解如何编写工厂的示例，请查看应用程序中的 `database/factories/UserFactory.php` 文件。这个工厂包含在所有新的 Laravel 源码程序中，并包含以下工厂定义：\r\n\r\n    namespace Database\\Factories;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    class UserFactory extends Factory\r\n    {\r\n        /**\r\n         * 定义模型的默认值。\r\n         *\r\n         * @return array\r\n         */\r\n        public function definition()\r\n        {\r\n            return [\r\n                'name' => $this->faker->name,\r\n                'email' => $this->faker->unique()->safeEmail,\r\n                'email_verified_at' => now(),\r\n                'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password\r\n                'remember_token' => Str::random(10),\r\n            ];\r\n        }\r\n    }\r\n\r\n正如你所见，在最基本的形式中，factories 是继承 Laravel 的基础 factory 类和定义 `definition` 方法的类。`definition` 方法返回使用 factory 创建模型时应用的默认属性值集合。\r\n\r\n通过 `faker` 属性， factories 可以访问 [Faker](https://github.com/FakerPHP/Faker)  PHP 函数库，它允许你便捷的生成各种随机数据来进行测试。\r\n\r\n> 技巧：你也可以在 `config/app.php` 配置文件中添加 `faker_locale` 选项来设置 Faker 的语言环境。\r\n\r\n<a name=\"generating-factories\"></a>\r\n### 创建工厂\r\n\r\n要创建工厂，请使用 [Artisan 命令](/docs/laravel/9.x/artisan) `make:factory`：\r\n\r\n```shell\r\nphp artisan make:factory PostFactory\r\n```\r\n\r\n新工厂将放置在你的 `database/factories` 目录下。\r\n\r\n<a name=\"factory-and-model-discovery-conventions\"></a>\r\n#### 模型和工厂的关联约定\r\n\r\n定义工厂后，可以在模型中使用 `Illuminate\\Database\\Eloquent\\Factories\\HasFactory` 特性提供的 `factory` 静态方法，来为模型实例化工厂。\r\n\r\n`HasFactory` 特性的 `factory` 方法将按约定来为模型确定合适的工厂。具体来说，该方法将在 `Database\\Factorys` 的命名空间下查找类名与模型名相匹配，并以 `Factory` 为后缀的工厂。如果当前约定不适用于你的特定应用程序或工厂，你可以重写模型中的 `newFactory` 方法，返回模型实际对应的工厂实例：\r\n\r\n    use Database\\Factories\\Administration\\FlightFactory;\r\n\r\n    /**\r\n     * 为当前模型创建一个工厂实例\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Factories\\Factory\r\n     */\r\n    protected static function newFactory()\r\n    {\r\n        return FlightFactory::new();\r\n    }\r\n\r\n接下来，在对应的工厂中定义 `model` 属性：\r\n\r\n    use App\\Administration\\Flight;\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\n\r\n    class FlightFactory extends Factory\r\n    {\r\n        /**\r\n         * 工厂对应的模型名称\r\n         *\r\n         * @var string\r\n         */\r\n        protected $model = Flight::class;\r\n    }\r\n\r\n<a name=\"factory-states\"></a>\r\n### 工厂状态\r\n\r\n你可以定义各自独立的状态操作方法，并可以任意组合应用于你的模型工厂。例如，你的 `Database\\Factories\\UserFactory` 工厂可能包含修改其默认属性值的 `suspended` 状态方法\r\n\r\n\r\n\r\n状态转换方法通常会调用 Laravel 的基础工厂类提供的 `state` 方法 。 `state` 方法接收一个闭包，该闭包将收到工厂的原始属性数组，并应该返回要修改的属性数组：\r\n\r\n    /**\r\n     * 标识用户已停用\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Factories\\Factory\r\n     */\r\n    public function suspended()\r\n    {\r\n        return $this->state(function (array $attributes) {\r\n            return [\r\n                'account_status' => 'suspended',\r\n            ];\r\n        });\r\n    }\r\n\r\n<a name=\"factory-callbacks\"></a>\r\n### 工厂回调\r\n\r\n工厂回调是通过 `afterMaking` 和 `afterCreating` 方法来注册的，并且允许你在创建模型之后执行其他任务。 你应该通过在工厂类上定义 `configure` 方法来注册这些回调。 实例化工厂后，Laravel 将自动调用此方法：\r\n\r\n    namespace Database\\Factories;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    class UserFactory extends Factory\r\n    {\r\n        /**\r\n         * 配置模型工厂\r\n         *\r\n         * @return $this\r\n         */\r\n        public function configure()\r\n        {\r\n            return $this->afterMaking(function (User $user) {\r\n                //\r\n            })->afterCreating(function (User $user) {\r\n                //\r\n            });\r\n        }\r\n\r\n        // ...\r\n    }\r\n\r\n<a name=\"creating-models-using-factories\"></a>\r\n## 使用工厂创建模型\r\n\r\n<a name=\"instantiating-models\"></a>\r\n### 实例化模型\r\n\r\n一旦你定义了工厂，就可以使用 `Illuminate\\Database\\Eloquent\\Factories\\HasFactory` 特性为你的模型提供的 `factory` 静态方法来实例化工厂。让我们来看几个创建模型的例子。首先，我们将使用 `make` 方法来创建模型而且不需要将它们持久化到数据库中：\r\n\r\n    use App\\Models\\User;\r\n\r\n    public function test_models_can_be_instantiated()\r\n    {\r\n        $user = User::factory()->make();\r\n\r\n        // 在测试中使用模型...\r\n    }\r\n\r\n\r\n\r\n你可以使用 `count` 方法创建许多模型的集合：\r\n\r\n    $users = User::factory()->count(3)->make();\r\n\r\n<a name=\"applying-states\"></a>\r\n#### 应用各种状态\r\n\r\n你也可以应用你的任何一个 [states](#factory-states) 到模型. 如果你想向模型应用多个状态转换，则可以直接调用状态转换方法：\r\n\r\n    $users = User::factory()->count(5)->suspended()->make();\r\n\r\n<a name=\"overriding-attributes\"></a>\r\n#### 覆盖属性\r\n\r\n如果你想覆盖模型的一些默认值, 你可以将数组传递给`make`方法. 只有指定的属性将被替换，而这些属性的其余部分保持设置为其默认值，则为出厂指定：\r\n\r\n    $user = User::factory()->make([\r\n        'name' => 'Abigail Otwell',\r\n    ]);\r\n\r\n或者，可以直接在出厂实例上调用`state`方法以执行内联状态转换：\r\n\r\n    $user = User::factory()->state([\r\n        'name' => 'Abigail Otwell',\r\n    ])->make();\r\n\r\n> 技巧：[批量分配保护](/docs/laravel/9.x/eloquent#mass-assignment) 使用工厂创建模型时会自动禁用.\r\n\r\n<a name=\"persisting-models\"></a>\r\n### 持久化模型\r\n\r\n`create` 方法创建模型实例，并使用  Eloquent 的 `save` 方法其持久化到数据库中：\r\n\r\n    use App\\Models\\User;\r\n\r\n    public function test_models_can_be_persisted()\r\n    {\r\n        // 创建单个 App\\Models\\User 实例...\r\n        $user = User::factory()->create();\r\n\r\n        // 创建三个 App\\Models\\User 实例...\r\n        $users = User::factory()->count(3)->create();\r\n\r\n        // 在测试中使用模型...\r\n    }\r\n\r\n你可以通过将属性数组传递给 `create` 方法来覆盖模型上的属性：\r\n\r\n    $user = User::factory()->create([\r\n        'name' => 'Abigail',\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"sequences\"></a>\r\n### 序列\r\n\r\n有时，你可能希望为每个创建的模型替换给定模型属性的值。 你可以通过将状态转换定义为 Sequence 实例来完成此操作。 例如，我们可能希望为每个创建的用户在 User 模型上的 `admin` 列的值在 `Y` 和 `N` 之间切换：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Sequence;\r\n\r\n    $users = User::factory()\r\n                    ->count(10)\r\n                    ->state(new Sequence(\r\n                        ['admin' => 'Y'],\r\n                        ['admin' => 'N'],\r\n                    ))\r\n                    ->create();\r\n\r\n在本例中，将创建 5 个用户 `admin` 值为 `Y`，创建另外 5 个用户 `admin` 值为 `N`。\r\n\r\n如有必要，你可以引入闭包作为 sequence 的值，每次 sequence 需要新值的时候这个闭包都会被调用。\r\n\r\n    $users = User::factory()\r\n                    ->count(10)\r\n                    ->state(new Sequence(\r\n                        fn ($sequence) => ['role' => UserRoles::all()->random()],\r\n                    ))\r\n                    ->create();\r\n\r\n在序列闭包中，你可以访问注入闭包的序列实例的 `$index` 或 `$count` 属性。 `$index` 属性包含到目前为止已发生的序列的迭代次数，而 `$count` 属性包含将调用序列的总次数：\r\n\r\n    $users = User::factory()\r\n                    ->count(10)\r\n                    ->sequence(fn ($sequence) => ['name' => 'Name '.$sequence->index])\r\n                    ->create();\r\n\r\n<a name=\"factory-relationships\"></a>\r\n## 工厂关系\r\n\r\n<a name=\"has-many-relationships\"></a>\r\n### 一对多关系\r\n\r\n接下来，让我们探索使用 Laravel 流畅的工厂方法建立 Eloquent 模型关系。 首先，假设我们的应用程序具有 `App\\Models\\User` 模型和 `App\\Models\\Post` 模型。同样，假设 `User` 模型定义了与 `Post` 的 `hasMany` 关系 。 我们可以通过 Laravel 的工厂提供的 `has` 方法创建一个拥有三个帖子的用户。 `has` 方法接受工厂实例：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()\r\n                ->has(Post::factory()->count(3))\r\n                ->create();\r\n\r\n\r\n\r\n按照惯例，在将 `Post` 模型传递给 `has` 方法时，Laravel 会假设 `User` 模型必须有一个定义关系的 `posts` 方法。如有必要，你可以明确指定要操作的关系的名称：\r\n\r\n    $user = User::factory()\r\n                ->has(Post::factory()->count(3), 'posts')\r\n                ->create();\r\n\r\n当然，你可以对相关模型执行状态操作。此外，如果状态更改需要访问父模型，则可以传递基于闭包的状态转换：\r\n\r\n    $user = User::factory()\r\n                ->has(\r\n                    Post::factory()\r\n                            ->count(3)\r\n                            ->state(function (array $attributes, User $user) {\r\n                                return ['user_type' => $user->type];\r\n                            })\r\n                )\r\n                ->create();\r\n\r\n<a name=\"has-many-relationships-using-magic-methods\"></a>\r\n#### 使用魔术方法\r\n\r\n为了方便起见 ，你可以使用 Laravel 的 魔术工厂关系方法来构建关系。例如，以下示例将使用约定来确定应通过 `User` 模型上的 `posts` 关系方法创建相关模型：\r\n\r\n    $user = User::factory()\r\n                ->hasPosts(3)\r\n                ->create();\r\n\r\n在使用魔术方法创建工厂关系时，你可以传递要在相关模型上覆盖的属性数组：\r\n\r\n    $user = User::factory()\r\n                ->hasPosts(3, [\r\n                    'published' => false,\r\n                ])\r\n                ->create();\r\n\r\n如果状态更改需要访问父模型，你可以提供基于闭包的状态转换：\r\n\r\n    $user = User::factory()\r\n                ->hasPosts(3, function (array $attributes, User $user) {\r\n                    return ['user_type' => $user->type];\r\n                })\r\n                ->create();\r\n\r\n<a name=\"belongs-to-relationships\"></a>\r\n### 从属关系\r\n\r\n既然我们已经探索了如何使用工厂构建「has many」关系，那么让我们来看看该关系的反面。`for` 方法可用于定义工厂创建的模型所属的父模型。例如，我们可以创建三个属于单个用户的 `App\\Models\\Post` 模型实例：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    $posts = Post::factory()\r\n                ->count(3)\r\n                ->for(User::factory()->state([\r\n                    'name' => 'Jessica Archer',\r\n                ]))\r\n                ->create();\r\n\r\n\r\n\r\n如果你已经有一个应该与你正在创建的模型相关联的父模型实例，可以传递这个模型实例给 `for` 方法：\r\n\r\n    $user = User::factory()->create();\r\n\r\n    $posts = Post::factory()\r\n                ->count(3)\r\n                ->for($user)\r\n                ->create();\r\n\r\n<a name=\"belongs-to-relationships-using-magic-methods\"></a>\r\n#### 从属关系使用魔法方法\r\n\r\n为方便起见，你可以使用工厂的魔术关系方法来定义「属于」关系。例如，下面的示例将使用约定来确定这三个帖子应该属于 `Post` 模型上的 `user` 关系：\r\n\r\n    $posts = Post::factory()\r\n                ->count(3)\r\n                ->forUser([\r\n                    'name' => 'Jessica Archer',\r\n                ])\r\n                ->create();\r\n\r\n<a name=\"many-to-many-relationships\"></a>\r\n### 多对多关系\r\n\r\n像 [一对多关系](#has-many-relationships),一样，可以使用 ` has` 方法创建「多对多」关系：\r\n\r\n    use App\\Models\\Role;\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()\r\n                ->has(Role::factory()->count(3))\r\n                ->create();\r\n\r\n<a name=\"pivot-table-attributes\"></a>\r\n#### Pivot (中转) 表属性\r\n\r\n如果需要定义应该在链接模型的中转表 / 中间表上设置的属性，可以使用 `hasAttached` 方法。此方法接受中转表属性名称和值的数组作为其第二个参数：\r\n\r\n    use App\\Models\\Role;\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()\r\n                ->hasAttached(\r\n                    Role::factory()->count(3),\r\n                    ['active' => true]\r\n                )\r\n                ->create();\r\n\r\n如果你的状态更改需要访问相关模型，则可以提供基于闭包的状态转换：\r\n\r\n    $user = User::factory()\r\n                ->hasAttached(\r\n                    Role::factory()\r\n                        ->count(3)\r\n                        ->state(function (array $attributes, User $user) {\r\n                            return ['name' => $user->name.' Role'];\r\n                        }),\r\n                    ['active' => true]\r\n                )\r\n                ->create();\r\n\r\n\r\n\r\n你可以通过将模型实例传递给 `hasAttached` 方法的形式，将其附加到正在创建的模型实例中。下面示例中是将三个相同的角色附加到三个用户：\r\n\r\n    $roles = Role::factory()->count(3)->create();\r\n\r\n    $user = User::factory()\r\n                ->count(3)\r\n                ->hasAttached($roles, ['active' => true])\r\n                ->create();\r\n\r\n<a name=\"many-to-many-relationships-using-magic-methods\"></a>\r\n#### 多对多关系使用魔术方法\r\n\r\n为方便起见，你可以使用工厂的魔术关系方法来定义多对多关系。例如，下面的示例将使用约定来确定应通过  `User` 模型上的 `Roles` 关系方法创建相关模型：\r\n\r\n    $user = User::factory()\r\n                ->hasRoles(1, [\r\n                    'name' => 'Editor'\r\n                ])\r\n                ->create();\r\n\r\n<a name=\"polymorphic-relationships\"></a>\r\n### 多态关系\r\n\r\n[多态关系](/docs/laravel/9.x/eloquent-relationships#polymorphic-relationships) 也可以使用工厂创建。多态的 「morph many」关系的创建方式与典型的 「has many」 关系的创建方式相同。例如，如果 `App\\Models\\Post` 模型与 `App\\Models\\Comment` 模型存在 `morMany` 关系：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::factory()->hasComments(3)->create();\r\n\r\n<a name=\"morph-to-relationships\"></a>\r\n#### 变形关系\r\n\r\n魔术方法不能用于创建 `morTo` 关系。相反，必须直接使用 `for` 方法，并且必须显式提供关系的名称。例如，假设 `Comment` 模型有一个 `commentable` 方法，该方法定义了一个 `morTo` 关系。在这种情况下，我们可以直接使用 `for` 方法创建属于单个帖子的三条评论：\r\n\r\n    $comments = Comment::factory()->count(3)->for(\r\n        Post::factory(), 'commentable'\r\n    )->create();\r\n\r\n\r\n\r\n<a name=\"polymorphic-many-to-many-relationships\"></a>\r\n#### 多态多对多关系\r\n\r\n可以像创建非多态的 「多对多」(`morphToMany` / `morphedByMany`) 关系一样创建多态的「多对多」关系：\r\n\r\n    use App\\Models\\Tag;\r\n    use App\\Models\\Video;\r\n\r\n    $videos = Video::factory()\r\n                ->hasAttached(\r\n                    Tag::factory()->count(3),\r\n                    ['public' => true]\r\n                )\r\n                ->create();\r\n\r\n当然，魔术 `has` 方法也可以用于创建多态「多对多」关系：\r\n\r\n    $videos = Video::factory()\r\n                ->hasTags(3, ['public' => true])\r\n                ->create();\r\n\r\n<a name=\"defining-relationships-within-factories\"></a>\r\n### 定义工厂内的关系\r\n\r\n要在模型工厂中定义关系，通常会将新工厂实例分配给关系的外键。这通常用于「反向」关系，像 `belongsTo` 和 `morphTo` 关系。例如，如果你想在创建帖子的同时创建一个新用户，你可以执行以下操作：\r\n\r\n    use App\\Models\\User;\r\n\r\n    /**\r\n     * 定义模型的默认状态\r\n     *\r\n     * @return array\r\n     */\r\n    public function definition()\r\n    {\r\n        return [\r\n            'user_id' => User::factory(),\r\n            'title' => $this->faker->title(),\r\n            'content' => $this->faker->paragraph(),\r\n        ];\r\n    }\r\n\r\n如果关系的列依赖于定义它的工厂，你可以为属性分配一个闭包。闭包将接收工厂的评估属性数组：\r\n\r\n    /**\r\n     * 定义模型的默认状态\r\n     *\r\n     * @return array\r\n     */\r\n    public function definition()\r\n    {\r\n        return [\r\n            'user_id' => User::factory(),\r\n            'user_type' => function (array $attributes) {\r\n                return User::find($attributes['user_id'])->type;\r\n            },\r\n            'title' => $this->faker->title(),\r\n            'content' => $this->faker->paragraph(),\r\n        ];\r\n    }\r\n\r\n<a name=\"running-seeders\"></a>\r\n## 运行填充\r\n\r\n如果你在功能测试时希望使用 [数据库填充](/docs/laravel/9.x/seeding) 来填充你的数据库， 你可以调用 `seed` 方法。 默认情况下，  `seed` 方法将会执行 `DatabaseSeeder`， 它应该执行你的所有其他种子器。或者，你传递指定的种子器类名给 `seed` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Database\\Seeders\\OrderStatusSeeder;\r\n    use Database\\Seeders\\TransactionStatusSeeder;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        use RefreshDatabase;\r\n\r\n        /**\r\n         * 测试创建新订单\r\n         *\r\n         * @return void\r\n         */\r\n        public function test_orders_can_be_created()\r\n        {\r\n            // 运行 DatabaseSeeder...\r\n            $this->seed();\r\n\r\n            // 运行指定填充...\r\n            $this->seed(OrderStatusSeeder::class);\r\n\r\n            // ...\r\n\r\n            // 运行指定数组内填充...\r\n            $this->seed([\r\n                OrderStatusSeeder::class,\r\n                TransactionStatusSeeder::class,\r\n                // ...\r\n            ]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n或者，你可以指示 `RefreshDatabase` trait 在每次测试之前自动为数据库填充数据。你可以通过在测试类上定义 `$seed` 属性来实现：\r\n\r\n    <?php\r\n\r\n    namespace Tests;\r\n\r\n    use Illuminate\\Foundation\\Testing\\TestCase as BaseTestCase;\r\n\r\n    abstract class TestCase extends BaseTestCase\r\n    {\r\n        use CreatesApplication;\r\n\r\n        /**\r\n         * 指示是否应在每次测试之前运行默认数据填充\r\n         *\r\n         * @var bool\r\n         */\r\n        protected $seed = true;\r\n    }\r\n\r\n当 `$seed` 属性为 `true` 时，测试将在每个使用 `RefreshDatabase` trait 的测试之前运行 `Database\\Seeders\\DatabaseSeeder` 类。但是，你可以通过在测试类上定义 `$seeder` 属性来指定应该执行的特定数据填充：\r\n\r\n    use Database\\Seeders\\OrderStatusSeeder;\r\n\r\n    /**\r\n     * 每次测试前运行指定数据填充     *\r\n     * @var string\r\n     */\r\n    protected $seeder = OrderStatusSeeder::class;\r\n\r\n<a name=\"available-assertions\"></a>\r\n## 可用的断言\r\n\r\nLaravel 为你的 [PHPUnit](https://phpunit.de/) 功能测试提供了几个数据库断言。我们将在下面逐个讨论。\r\n\r\n<a name=\"assert-database-count\"></a>\r\n#### assertDatabaseCount\r\n\r\n断言数据库中的表包含给定数量的记录：\r\n\r\n    $this->assertDatabaseCount('users', 5);\r\n\r\n<a name=\"assert-database-has\"></a>\r\n#### assertDatabaseHas\r\n\r\n断言数据库中的表包含给定键/值查询约束的记录：\r\n\r\n    $this->assertDatabaseHas('users', [\r\n        'email' => 'sally@example.com',\r\n    ]);\r\n\r\n<a name=\"assert-database-missing\"></a>\r\n#### assertDatabaseMissing\r\n\r\n断言数据库中的表不包含给定键/值查询约束的记录：\r\n\r\n    $this->assertDatabaseMissing('users', [\r\n        'email' => 'sally@example.com',\r\n    ]);\r\n\r\n<a name=\"assert-deleted\"></a>\r\n#### assertSoftDeleted\r\n\r\n `assertSoftDeleted` 断言给定的 Eloquent 模型已被「软删除」：\r\n\r\n    $this->assertSoftDeleted($user);\r\n\r\n<a name=\"assert-model-exists\"></a>\r\n#### assertModelExists\r\n\r\n断言给定模型存在于数据库中：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()->create();\r\n\r\n    $this->assertModelExists($user);\r\n\r\n<a name=\"assert-model-missing\"></a>\r\n#### assertModelMissing\r\n\r\n断言数据库中不存在给定模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()->create();\r\n\r\n    $user->delete();\r\n\r\n    $this->assertModelMissing($user);\r\n\r\n","p":"docs/database-testing.html"},{"t":"mocking (Mocking)","d":"\n# Mocking\r\n\r\n- [简介](#introduction)\r\n- [模拟对象](#mocking-objects)\r\n- [模拟 Facades](#mocking-facades)\r\n    - [Facade Spies](#facade-spies)\r\n- [任务模拟](#bus-fake)\r\n    - [任务链](#bus-job-chains)\r\n    - [批量任务](#job-batches)\r\n- [事件模拟](#event-fake)\r\n    - [Scoped 事件模拟](#scoped-event-fakes)\r\n- [HTTP 模拟](#http-fake)\r\n- [邮件模拟](#mail-fake)\r\n- [通知模拟](#notification-fake)\r\n- [队列模拟](#queue-fake)\r\n    - [任务链](#job-chains)\r\n- [存储模拟](#storage-fake)\r\n- [时间交互](#interacting-with-time)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n在 Laravel 应用程序测试中，你可能希望「模拟」应用程序的某些功能的行为，从而避免该部分在测试中真正执行。例如：在控制器执行过程中会触发事件，您可能希望模拟事件监听器，从而避免该事件在测试时真正执行。这允许你在仅测试控制器 HTTP 响应的情况时，而不必担心触发事件，因为事件侦听器可以在它们自己的测试用例中进行测试。\r\n\r\nLaravel 针对事件、任务和 Facades 的模拟，提供了开箱即用的辅助函数。这些函数基于 Mocker 封装而成，使用非常方便，无需手动调用复杂的 Mockery 函数。\r\n\r\n<a name=\"mocking-objects\"></a>\r\n## 模拟对象\r\n\r\n当模拟一个对象将通过 Laravel 的 [服务容器](/docs/laravel/9.x/container) 注入到应用中时，你将需要将模拟实例作为 `instance` 绑定到容器中。这将告诉容器使用对象的模拟实例，而不是构造对象的真身：\r\n\r\n    use App\\Service;\r\n    use Mockery;\r\n    use Mockery\\MockInterface;\r\n\r\n    public function test_something_can_be_mocked()\r\n    {\r\n        $this->instance(\r\n            Service::class,\r\n            Mockery::mock(Service::class, function (MockInterface $mock) {\r\n                $mock->shouldReceive('process')->once();\r\n            })\r\n        );\r\n    }\r\n\r\n\n\n为了让以上过程更加便捷，你可以使用 Laravel 的基本测试用例类提供 `mock` 方法：\r\n\r\n    use App\\Service;\r\n    use Mockery\\MockInterface;\r\n\r\n    $mock = $this->mock(Service::class, function (MockInterface $mock) {\r\n        $mock->shouldReceive('process')->once();\r\n    });\r\n\r\n当你只需要模拟对象的几个方法时，可以使用 `partialMock` 方法。 未被模拟的方法将在调用时正常执行：\r\n\r\n    use App\\Service;\r\n    use Mockery\\MockInterface;\r\n\r\n    $mock = $this->partialMock(Service::class, function (MockInterface $mock) {\r\n        $mock->shouldReceive('process')->once();\r\n    });\r\n\r\n同样，如果你想侦查一个对象，Laravel 的基本测试用例类提供了一个便捷的 [spy](http://docs.mockery.io/en/latest/reference/spies.html) 方法作为 `Mockery::spy` 的替代方法,但是，spy会记录spy与被测试代码之间的任何交互，从而允许您在执行代码后做出断言：\r\n\r\n    use App\\Service;\r\n\r\n    $spy = $this->spy(Service::class);\r\n\r\n    // ...\r\n\r\n    $spy->shouldHaveReceived('process');\r\n\r\n<a name=\"mocking-facades\"></a>\r\n## Facades模拟\r\n\r\n与传统静态方法调用不同的是，[facades](/docs/laravel/9.x/facades) (including [real-time facades](/docs/laravel/9.x/facades#real-time-facades)) 也可以被模拟。相较传统的静态方法而言，它具有很大的优势，即便你使用依赖注入，可测试性不逊半分。在测试中，你可能想在控制器中模拟对 Laravel Facade 的调用。比如下面控制器中的行为：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示该应用程序的所有用户的列表.\r\n         *\r\n         * @return \\Illuminate\\Http\\Response\r\n         */\r\n        public function index()\r\n        {\r\n            $value = Cache::get('key');\r\n\r\n            //\r\n        }\r\n    }\r\n\n\n我们可以使用 `shouldReceive` 方法模拟对 `Cache` Facade 的调用，该方法将返回一个 [Mockery](https://github.com/padraic/mockery) 模拟的实例。由于 Facades 实际上是由 Laravel [服务容器](/docs/laravel/9.x/container) 解析和管理的，因此它们比传统的静态类具有更好的可测试性。例如，让我们模拟对 `Cache` Facade 的 `get` 方法的调用：\r\n\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n    use Tests\\TestCase;\r\n\r\n    class UserControllerTest extends TestCase\r\n    {\r\n        public function testGetIndex()\r\n        {\r\n            Cache::shouldReceive('get')\r\n                        ->once()\r\n                        ->with('key')\r\n                        ->andReturn('value');\r\n\r\n            $response = $this->get('/users');\r\n\r\n            // ...\r\n        }\r\n    }\r\n\r\n> 注意：你不应该模拟 `Request` facade。相反，在运行测试时将您想要的输入传递到 [HTTP 测试方法](/docs/laravel/9.x/http-tests) 中，例如 `get` 和 `post`。同样，不要模拟 `Config` facade，而是在测试中调用 `Config::set` 方法。\r\n\r\n<a name=\"facade-spies\"></a>\r\n### Facade Spies\r\n\r\n如果你想 [spy](http://docs.mockery.io/en/latest/reference/spies.html) 一个 facade，你可以在相应的 facade 上调用 `spy` 方法。spy 类似于模拟；但是，spy 记录 spy 和被测试代码之间的所有交互，允许你在代码执行后做出断言：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    public function test_values_are_be_stored_in_cache()\r\n    {\r\n        Cache::spy();\r\n\r\n        $response = $this->get('/');\r\n\r\n        $response->assertStatus(200);\r\n\r\n        Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);\r\n    }\r\n\r\n<a name=\"bus-fake\"></a>\r\n\n\n## Bus Fake\r\n\r\n在测试分发任务的代码时，您通常希望断言已分发给定任务，但实际不进入队列或执行任务。这是因为任务的执行通常可以在单独的测试类中进行测试。\r\n\r\n您可以使用 `Bus` facade 的 `fake` 方法来防止将任务分发到队列。然后，在执行测试代码后，您可以使用 `assertDispatched` 和 `assertNotDispatched` 方法检查应用试图分发的任务：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Jobs\\ShipOrder;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_orders_can_be_shipped()\r\n        {\r\n            Bus::fake();\r\n\r\n            // 执行订单发货……\r\n\r\n            // 断言任务被分发……\r\n            Bus::assertDispatched(ShipOrder::class);\r\n\r\n            // 断言任务没有被分发\r\n            Bus::assertNotDispatched(AnotherJob::class);\r\n        }\r\n    }\r\n\r\n您可以将闭包传递给 `assertDispatched` 或 `assertNotDispatched` 方法，以断言已分发的任务通过了给定的「真实性测试」。如果至少分发了一个通过给定真实性测试的任务，则断言将成功。例如，您可能希望声明已为特定订单分发任务：\r\n\r\n    Bus::assertDispatched(function (ShipOrder $job) use ($order) {\r\n        return $job->order->id === $order->id;\r\n    });\r\n\r\n\n\n<a name=\"bus-job-chains\"></a>\r\n### 任务链\r\n`Bus` facade 的 `assertChained` 方法可用于断言 [任务链](/docs/laravel/9.x/queues#job-chaining) 已被调度。 `assertChained` 方法接受一个链式任务数组作为它的第一个参数：\r\n\r\n    use App\\Jobs\\RecordShipment;\r\n    use App\\Jobs\\ShipOrder;\r\n    use App\\Jobs\\UpdateInventory;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n\r\n    Bus::assertChained([\r\n        ShipOrder::class,\r\n        RecordShipment::class,\r\n        UpdateInventory::class\r\n    ]);\r\n\r\n\r\n\r\n\r\n如上例所示，链式任务的数组可是任务类名的数组。但是，您也可以提供实际任务实例的数组。执行此操作时，Laravel 将确保任务实例属于同一类，并且具有与应用分发的任务链相同的属性值：\r\n\r\n    Bus::assertChained([\r\n        new ShipOrder,\r\n        new RecordShipment,\r\n        new UpdateInventory,\r\n    ]);\r\n\r\n<a name=\"job-batches\"></a>\r\n### 任务批处理\r\n\r\n`Bus` facade 的 `assertBatched` 方法可以用来断言 [批量任务](/docs/laravel/9.x/queues#job-batches) 被分发。提供给 `assertBatched` 方法的闭包接收一个 `Illuminate\\Bus\\PendingBatch` 的实例，它可用于检查批处理中的任务：\r\n\r\n    use Illuminate\\Bus\\PendingBatch;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n\r\n    Bus::assertBatched(function (PendingBatch $batch) {\r\n        return $batch->name == 'import-csv' &&\r\n               $batch->jobs->count() === 10;\r\n    });\r\n\r\n<a name=\"event-fake\"></a>\r\n## 事件模拟\r\n\r\n在测试分发事件的代码时，您可能希望指示 Laravel 不要执行事件的监听器。 使用 `Event` facade 的 `fake` 方法可以阻止监听器执行，执行测试代码后使用 `assertDispatched` 、`assertNotDispatched` 和 `assertNothingDispatched` 方法断言应用分发了哪些事件：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Events\\OrderFailedToShip;\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 测试订单发货\r\n         */\r\n        public function test_orders_can_be_shipped()\r\n        {\r\n            Event::fake();\r\n\r\n            // 指定订单发货……\r\n\r\n            // 断言事件被分发……\r\n            Event::assertDispatched(OrderShipped::class);\r\n\r\n            // 断言事件被分发了两次……\r\n            Event::assertDispatched(OrderShipped::class, 2);\r\n\r\n            // 断言事件未被分发……\r\n            Event::assertNotDispatched(OrderFailedToShip::class);\r\n\r\n            // 断言没有任务事件被分发……\r\n            Event::assertNothingDispatched();\r\n        }\r\n    }\r\n\r\n\n\n您可以将闭包传递给 `assertDispatched` 或 `assertNotDispatched` 方法，以断言已分发的事件通过了给定的「真实性测试」。如果至少分发了一个通过给定真实性测试的事件，则断言将成功\r\n\r\n    Event::assertDispatched(function (OrderShipped $event) use ($order) {\r\n        return $event->order->id === $order->id;\r\n    });\r\n\r\n\r\n> 注意：调用 `Event::fake()` 后不会执行事件监听器。所以，如果你的测试用到了依赖于事件的模型工厂，例如，在模型的 `creating` 事件中创建 UUID ，那么你应该在使用模型工厂   **之后** 调用 `Event::fake()`。\r\n\r\n<a name=\"faking-a-subset-of-events\"></a>\r\n#### 模拟事件的子集\r\n\r\n如果你只想为特定的一组事件模拟事件监听器，你可以将它们传递给 `fake` 或 `fakeFor` 方法：\r\n\r\n    /**\r\n     * 测试订单流程。\r\n     */\r\n    public function test_orders_can_be_processed()\r\n    {\r\n        Event::fake([\r\n            OrderCreated::class,\r\n        ]);\r\n\r\n        $order = Order::factory()->create();\r\n\r\n        Event::assertDispatched(OrderCreated::class);\r\n\r\n        // 其他事件照常分发……\r\n        $order->update([...]);\r\n    }\r\n\r\n<a name=\"scoped-event-fakes\"></a>\r\n### Scoped 事件模拟\r\n\r\n如果你只想为部分测试模拟事件监听，则可以使用 `fakeFor` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Events\\OrderCreated;\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 测试订单流程。\r\n         */\r\n        public function test_orders_can_be_processed()\r\n        {\r\n            $order = Event::fakeFor(function () {\r\n                $order = Order::factory()->create();\r\n\r\n                Event::assertDispatched(OrderCreated::class);\r\n\r\n                return $order;\r\n            });\r\n\r\n            // 事件照常分发，且观察者将运行 ...\r\n            $order->update([...]);\r\n        }\r\n    }\r\n\r\n\n\n<a name=\"http-fake\"></a>\r\n## HTTP 模拟\r\n\r\n`Http` facade 的 `fake` 方法允许您指示 HTTP 客户端在发出请求时返回虚拟响应。有关伪造发出 HTTP 请求的更多信息，请参阅 [HTTP客户端测试文档](/docs/laravel/9.x/http-client#testing)。\r\n\r\n<a name=\"mail-fake\"></a>\r\n## 邮件模拟\r\n\r\n\r\n您可以使用 `Mail` facade 的 `fake` 方法阻止邮件发送。通常，发送邮件与实际测试的代码无关。一般只要断言发送了给定的邮件就足够了。\r\n\r\n调用 `Mail` facade 的 `fake` 方法后，您可以断言 [mailables](/docs/laravel/9.x/Mail) 被指示发送给用户，甚至检查 mailables 收到的数据：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Mail\\OrderShipped;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_orders_can_be_shipped()\r\n        {\r\n            Mail::fake();\r\n\r\n            // 执行订单发货……\r\n\r\n            // 断言没有发送任何邮件……\r\n            Mail::assertNothingSent();\r\n\r\n            // 断言发送了邮件……\r\n            Mail::assertSent(OrderShipped::class);\r\n\r\n            // 断言邮件发送了两遍……\r\n            Mail::assertSent(OrderShipped::class, 2);\r\n\r\n            // 断言邮件未发送……\r\n            Mail::assertNotSent(AnotherMailable::class);\r\n        }\r\n    }\r\n\r\n如果你用后台任务执行邮件发送队列，你应该使用 `assertQueued` 代替 `assertSent`：\r\n\r\n    Mail::assertQueued(OrderShipped::class);\r\n\r\n    Mail::assertNotQueued(OrderShipped::class);\r\n\r\n    Mail::assertNothingQueued();\r\n\r\n你可以将闭包传递给 `assertSent`, `assertNotSent`, `assertQueued` 或 `assertNotQueued` 方法，以断言发送的邮件通过了给定的 「真实性测试」。如果至少发送了一封通过给定真实性测试的邮件，则断言将成功：\r\n\r\n    Mail::assertSent(function (OrderShipped $mail) use ($order) {\r\n        return $mail->order->id === $order->id;\r\n    });\r\n\r\n\n\n调用 `Mail` facade 的断言方法时, 所提供的闭包接受的 mailable 实例公开了检查 mailable   的收件人的实用方法：\r\n\r\n    Mail::assertSent(OrderShipped::class, function ($mail) use ($user) {\r\n        return $mail->hasTo($user->email) &&\r\n               $mail->hasCc('...') &&\r\n               $mail->hasBcc('...');\r\n    });\r\n\r\n你可能已经注意到，有两种方法可以断言邮件没有被发送：`assertNotSent` 和 `assertNotQueued`。有时你可能希望断言没有邮件被发送 **或** 存入队列。为了达到这个目的，你可以使用`assertNothingOutgoing`和`assertNotOutgoing`方法。\r\n\r\n    Mail::assertNothingOutgoing();\r\n\r\n    Mail::assertNotOutgoing(function (OrderShipped $mail) use ($order) {\r\n        return $mail->order->id === $order->id;\r\n    });\r\n\r\n<a name=\"notification-fake\"></a>\r\n## 通知模拟\r\n你可以使用 `Notification` facade 的 `fake`方法来阻止发送通知。通常，发送通知与实际测试的代码无关。一般，只要断言 Laravel 发送给定的通知就足够了。\r\n\r\n调用了 `Notification` facade 的 `fake` 方法之后，你可以断言 [通知](/docs/laravel/9.x/notifications) 被发送给用户， 甚至可以检查 notifications 收到的数据：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Notifications\\OrderShipped;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Support\\Facades\\Notification;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_orders_can_be_shipped()\r\n        {\r\n            Notification::fake();\r\n\r\n            // 执行订单发货……\r\n\r\n            // 断言没有发送任何通知……\r\n            Notification::assertNothingSent();\r\n\r\n            // 断言通知被发送给指定用户……\r\n            Notification::assertSentTo(\r\n                [$user], OrderShipped::class\r\n            );\r\n\r\n            // 断言通知未发送……\r\n            Notification::assertNotSentTo(\r\n                [$user], AnotherNotification::class\r\n            );\r\n        }\r\n    }\r\n\r\n\n\n您可以将闭包传递给 `assertSentTo` 或 `assertNotSentTo` 方法，以断言发送的通知通过了给定的 「真实性测试」。如果至少发送了一个通过给定真实性测试的通知，则断言将成功：\r\n\r\n    Notification::assertSentTo(\r\n        $user,\r\n        function (OrderShipped $notification, $channels) use ($order) {\r\n            return $notification->order->id === $order->id;\r\n        }\r\n    );\r\n\r\n\r\n\r\n<a name=\"on-demand-notifications\"></a>\r\n#### 按需通知\r\n\r\n如果您正在测试发送 [按需通知](/docs/laravel/9.x/notifications#on-demand-notifications)，则您需要断言通知已发送到 `Illuminate\\Notifications\\AnonymousNotifiable` 实例：\r\n\r\n    use Illuminate\\Notifications\\AnonymousNotifiable;\r\n\r\n    Notification::assertSentTo(\r\n        new AnonymousNotifiable, OrderShipped::class\r\n    );\r\n\r\n通过将闭包作为第三个参数传递给通知断言方法，您可以确定是否已将按需通知发送到正确的「路由」地址：\r\n\r\n    Notification::assertSentTo(\r\n        new AnonymousNotifiable,\r\n        OrderShipped::class,\r\n        function ($notification, $channels, $notifiable) use ($user) {\r\n            return $notifiable->routes['mail'] === $user->email;\r\n        }\r\n    );\r\n\r\n<a name=\"queue-fake\"></a>\r\n## 队列模拟\r\n可以使用 `Queue` facade 的 `fake` 方法来防止任务被推送到队列中。通常，只要断言将给定的任务推送到队列就足够了，因为队列任务本身可以在另一个测试类中进行测试。\r\n\r\n调用 `Queue` facade 的 `fake` 方法后，您可以断言应用试图将任务推送到队列：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Jobs\\AnotherJob;\r\n    use App\\Jobs\\FinalJob;\r\n    use App\\Jobs\\ShipOrder;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_orders_can_be_shipped()\r\n        {\r\n            Queue::fake();\r\n\r\n            // 执行订单发货……\r\n\r\n            // 断言没有任务被推送……\r\n            Queue::assertNothingPushed();\r\n\r\n            // 断言任务被推送到指定队列……\r\n            Queue::assertPushedOn('queue-name', ShipOrder::class);\r\n\r\n            //  断言任务被推送了两次……\r\n            Queue::assertPushed(ShipOrder::class, 2);\r\n\r\n            // 断言任务未被推送……\r\n            Queue::assertNotPushed(AnotherJob::class);\r\n        }\r\n    }\r\n\r\n\n\n您可以将闭包传递给 `assertPushed` 或 `assertNotPushed` 方法，以断言推送的任务通过了给定的 「真实性测试」。如果至少推送了一个通过给定真实性测试的任务，则断言将成功：\r\n\r\n    Queue::assertPushed(function (ShipOrder $job) use ($order) {\r\n        return $job->order->id === $order->id;\r\n    });\r\n\r\n<a name=\"job-chains\"></a>\r\n### 任务链\r\n\r\n`Queue` facade 的 `assertPushedWithChain` 和 `assertPushedWithoutChain` 方法可用于检查推送任务的任务链。 `assertPushedWithChain` 方法接受主任务作为第一个参数，接受链式任务数组作为第二个参数：\r\n\r\n\r\n    use App\\Jobs\\RecordShipment;\r\n    use App\\Jobs\\ShipOrder;\r\n    use App\\Jobs\\UpdateInventory;\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n\r\n    Queue::assertPushedWithChain(ShipOrder::class, [\r\n        RecordShipment::class,\r\n        UpdateInventory::class\r\n    ]);\r\n\r\n如上例所示，链式任务的数组可能是任务类名的数组。但是，您也可以提供实际任务实例的数组。执行此操作时，Laravel 将确保任务实例属于同一类，并且具有应用调度的任务链的相同属性值：\r\n\r\n    Queue::assertPushedWithChain(ShipOrder::class, [\r\n        new RecordShipment,\r\n        new UpdateInventory,\r\n    ]);\r\n\r\n您可以使用 `assertPushedWithoutChain` 方法断言在没有任务链的情况下推送任务：\r\n\r\n\r\n    Queue::assertPushedWithoutChain(ShipOrder::class);\r\n\r\n<a name=\"storage-fake\"></a>\r\n## 存储模拟\r\n\r\n你可以使用 `Storage` Facade 的 `fake` 方法，轻松的生成一个模拟磁盘，结合 `Illuminate\\Http\\UploadedFile` 类的文件生成工具，极大的简化了文件上传测试。例如：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Http\\UploadedFile;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_albums_can_be_uploaded()\r\n        {\r\n            Storage::fake('photos');\r\n\r\n            $response = $this->json('POST', '/photos', [\r\n                UploadedFile::fake()->image('photo1.jpg'),\r\n                UploadedFile::fake()->image('photo2.jpg')\r\n            ]);\r\n\r\n            // 断言一个或多个文件已存储……\r\n            Storage::disk('photos')->assertExists('photo1.jpg');\r\n            Storage::disk('photos')->assertExists(['photo1.jpg', 'photo2.jpg']);\r\n\r\n            //  断言一个或多个文件未存储……\r\n            Storage::disk('photos')->assertMissing('missing.jpg');\r\n            Storage::disk('photos')->assertMissing(['missing.jpg', 'non-existing.jpg']);\r\n        }\r\n    }\r\n\r\n\n\n有关测试文件上传的更多信息，您可以参考 [HTTP测试文档的文件上传信息](/docs/laravel/9.x/http-tests#testing-file-uploads)。\r\n\r\n\r\n\r\n> 技巧：默认情况下，`fake` 方法将删除临时目录下所有文件。如果你想保留这些文件，你可以使用 「persistentFake」。\r\n\r\n<a name=\"interacting-with-time\"></a>\r\n## 时间交互\r\n\r\n测试时，有时可能需要修改诸如 `now` 或 `Illuminate\\Support\\Carbon::now()` 之类的助手返回的时间。 值得庆幸的是，Laravel 的基本功能测试类包括一些帮助程序，可让您操纵当前时间：\r\n\r\n\r\n    public function testTimeCanBeManipulated()\r\n    {\r\n        // 调至未来……\r\n        $this->travel(5)->milliseconds();\r\n        $this->travel(5)->seconds();\r\n        $this->travel(5)->minutes();\r\n        $this->travel(5)->hours();\r\n        $this->travel(5)->days();\r\n        $this->travel(5)->weeks();\r\n        $this->travel(5)->years();\r\n\r\n        // 调至过去……\r\n        $this->travel(-5)->hours();\r\n\r\n        // 调至一个明确的时间……\r\n        $this->travelTo(now()->subHours(6));\r\n\r\n        // 返回现在……\r\n        $this->travelBack();\r\n    }\r\n\n","p":"docs/mocking.html"},{"t":"billing (Laravel Cashier (Stripe))","d":"\n# Laravel Cashier (Stripe)\r\n\r\n- [简介](#introduction)\r\n- [升级 Cashier](#upgrading-cashier)\r\n- [安装](#installation)\r\n    - [数据库迁移](#database-migrations)\r\n- [配置信息](#configuration)\r\n    - [计费模型](#billable-model)\r\n    - [API 密钥](#api-keys)\r\n    - [货币配置](#currency-configuration)\r\n    - [税务配置](#tax-configuration)\r\n    - [日志](#logging)\r\n    - [使用自定义模型](#using-custom-models)\r\n- [消费者](#customers)\r\n    - [获取消费者](#retrieving-customers)\r\n    - [创建消费者](#creating-customers)\r\n    - [更新消费者](#updating-customers)\r\n    - [余额](#balances)\r\n    - [税号](#tax-ids)\r\n    - [使用 Stripe 同步客户数据](#syncing-customer-data-with-stripe)\r\n    - [计费门户](#billing-portal)\r\n- [支付方式](#payment-methods)\r\n    - [存储支付方式](#storing-payment-methods)\r\n    - [检索支付方式](#retrieving-payment-methods)\r\n    - [判断用户是否有支付方式](#check-for-a-payment-method)\r\n    - [更新默认支付方式](#updating-the-default-payment-method)\r\n    - [添加支付方式](#adding-payment-methods)\r\n    - [删除支付方式](#deleting-payment-methods)\r\n- [订阅内容](#subscriptions)\r\n    - [创建订阅](#creating-subscriptions)\r\n    - [检查订阅状态](#checking-subscription-status)\r\n    - [修改价格](#changing-prices)\r\n    - [订阅数量](#subscription-quantity)\r\n    - [多方案订阅计划](#multiprice-subscriptions)\r\n    - [计量计费](#metered-billing)\r\n    - [订阅税](#subscription-taxes)\r\n    - [订阅锚定日期](#subscription-anchor-date)\r\n    - [取消订阅](#cancelling-subscriptions)\r\n    - [恢复订阅](#resuming-subscriptions)\r\n- [订阅试用](#subscription-trials)\r\n    - [预先使用付款方式](#with-payment-method-up-front)\r\n    - [没有预先付款方式](#without-payment-method-up-front)\r\n    - [延长试用期](#extending-trials)\r\n- [处理 Stripe Webhooks](#handling-stripe-webhooks)\r\n    - [定义 Webhook 事件处理器](#defining-webhook-event-handlers)\r\n    - [验证 Webhook 签名](#verifying-webhook-signatures)\r\n- [单次收费](#single-charges)\r\n    - [基本使用](#simple-charge)\r\n    - [带发票的支付](#charge-with-invoice)\r\n    - [退款](#refunding-charges)\r\n- [结账](#checkout)\r\n    - [产品结账](#product-checkouts)\r\n    - [单次支付结账](#single-charge-checkouts)\r\n    - [订阅结账](#subscription-checkouts)\r\n    - [收集税号](#collecting-tax-ids)\r\n- [发票](#invoices)\r\n    - [获取发票](#retrieving-invoices)\r\n    - [即将发布的发票](#upcoming-invoices)\r\n    - [预览订阅发票](#previewing-subscription-invoices)\r\n    - [生成发票 PDF](#generating-invoice-pdfs)\r\n- [处理支付失败](#handling-failed-payments)\r\n- [强大的客户身份验证 (SCA)](#strong-customer-authentication)\r\n    - [需要额外确认的支付](#payments-requiring-additional-confirmation)\r\n    - [非会话支付通知](#off-session-payment-notifications)\r\n- [Stripe SDK](#stripe-sdk)\r\n- [测试](#testing)\r\n\r\n\n\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Cashier Stripe](https://github.com/laravel/cashier-stripe) 为 [Stripe](https://stripe.com) 的订阅计费服务提供了一个富有表现力、流畅的接口。它处理了几乎所有你害怕编写的订阅计费样板代码。除了基本的订阅管理，Cashier 还可以处理优惠券、交换订阅、订阅 「数量」、取消宽限期，甚至生成发票 PDF。\r\n\r\n<a name=\"upgrading-cashier\"></a>\r\n## 升级 Cashier\r\n\r\n升级到新版本的 Cashier 时，请务必仔细阅读 [升级指南](https://github.com/laravel/cashier-stripe/blob/master/UPGRADE.md)。\r\n\r\n> 注意：为了防止破坏性变更，Cashier 使用固定的 Stripe API 版本。 Cashier 13 使用 Stripe API 版本 `2020-08-27` 。Stripe API 版本将在次要版本上更新，以利用新的 Stripe 功能和改进。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，使用 Composer 为 Stripe 安装 Cashier 扩展包：\r\n\r\n```shell\r\ncomposer require laravel/cashier\r\n```\r\n\r\n> 注意：为确保 Cashier 正确处理所有 Stripe 事件，请记得 [设置 Cashier 的 webhook](#handling-stripe-webhooks)。\r\n\r\n<a name=\"database-migrations\"></a>\r\n### 数据库迁移\r\n\r\nCashier 的服务提供器注册了自己的数据库迁移目录，因此请记住在安装此包后迁移数据库。Cashier 迁移将向 `users` 表中添加多个列，并创建一个新的 `subscriptions` 表来保存客户的所有订阅：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n如果需要覆盖 Cashier 附带的迁移，可以使用 `vendor:publish` Artisan 命令发布它们：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=\"cashier-migrations\"\r\n```\r\n\r\n\n\n如果你想阻止 Cashier 的迁移完全运行，可以使用 Cashier 提供的`ignoreMigrations` 方法。通常应在 `AppServiceProvider` 类的 `register` 方法中调用此方法：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    /**\r\n     * Register any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        Cashier::ignoreMigrations();\r\n    }\r\n\r\n> 注意：Stripe 建议用于存储 Stripe 标识符的任何列都应区分大小写。因此，在使用 MySQL 时，应该确保将 `stripe_id` 列排序规则设置为 `utf8_bin` 。更多关于这方面的信息可以在 [Stripe 文档](https://stripe.com/docs/upgrades#what-changes-does-stripe-consider-to-be-backwards-compatible) 中找到。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"billable-model\"></a>\r\n### 订单模型\r\n\r\n在使用 Cashier 之前，需要将 `Billable` trait 添加到可订单模型定义中。通常会放在 `App\\Models\\User` 模型中。这个特性提供了多个方法以便执行常用支付任务，如创建订阅、应用优惠券和更新支付方法信息：\r\n\r\n    use Laravel\\Cashier\\Billable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Billable;\r\n    }\r\n\r\nCashier 默认假设你的 Billable 模型是 Laravel 自带的 `App\\Models\\User` 类。如果需要修改可以在 `useCustomerModel` 方法定义一个不同的模型。通常此方法在 `AppServiceProvider` 类的`boot`方法中被调用：\r\n\r\n    use App\\Models\\Cashier\\User;\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Cashier::useCustomerModel(User::class);\r\n    }\r\n\r\n> 注意：如果你使用的不是 Laravel 自带的 `App\\Models\\User` 模型，需要发布并修改默认的 [Cashier 迁移](#installation) 文件以匹配你使用模型对应的表名。\r\n\r\n\n\n<a name=\"api-keys\"></a>\r\n### API 秘钥\r\n\r\n接下来需要在 `.env` 文件中配置 Stripe 秘钥，可以在 Stripe 后台控制面板中获取Stripe API 秘钥：\r\n\r\n```ini\r\nSTRIPE_KEY=your-stripe-key\r\nSTRIPE_SECRET=your-stripe-secret\r\n```\r\n\r\n<a name=\"currency-configuration\"></a>\r\n### 货币配置\r\n\r\nCashier 默认货币是美元 (USD)，可以在 `.env` 中设置 `CASHIER_CURRENCY` 环境变量来修改默认的货币配置：\r\n\r\n```ini\r\nCASHIER_CURRENCY=eur\r\n```\r\n\r\n除了配置 Cashier 的货币之外，还可以在格式化用于显示在发票上的金额时指定本地化配置。在底层，Cashier 使用了 [PHP 的 `NumberFormatter` 类](https://www.php.net/manual/en/class.numberformatter.php) 来设置本地货币：\r\n\r\n```ini\r\nCASHIER_CURRENCY_LOCALE=nl_BE\r\n```\r\n\r\n> 注意：为了使用本地化配置而不是 `en`，需要确保安装了 PHP `ext-intl` PHP 扩展并在服务器上启用配置。\r\n\r\n<a name=\"tax-configuration\"></a>\r\n### 税务配置\r\n\r\n感谢[Stripe  税务](https://stripe.com/tax)，可以自动计算 Stripe 生成的所有发票的税费。 可以通过应用程序的 `App\\Providers\\AppServiceProvider`类的 `boot` 方法中调用 `calculateTaxes` 来启用自动税务计算：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Cashier::calculateTaxes();\r\n    }\r\n\r\n启动税务计算后，任何新订阅和生成的一次性发票都会进行自动税务计算。\r\n\r\n为了使这个功能正常使用，客户的账单明细中例如客户姓名、住址、发票 ID 需要同步到 Stripe。你可以使用 Cashier 提供的 [客户数据同步](#syncing-customer-data-with-stripe) 和 [Tax ID](#tax-ids) 方法来完成此操作。\r\n\r\n> 注意：遗憾的是，目前不支持计算 [单笔交易](#single-charges) 或 [单笔交易支付](#single-charge-checkouts)。此外 Stripe Tax 目在测试期间仅限“受邀”使用。你可以通过 [Stripe Tax 网站](https://stripe.com/tax#request-access)请求访问 Stripe 税务。\r\n\r\n\n\n<a name=\"logging\"></a>\r\n### 日志\r\n\r\nCashier 允许你指定日志通道来记录所有与 Stripe 相关的异常。可以通过在  `.env` 中配置 `CASHIER_LOGGER` 来指定：\r\n\r\n```ini\r\nCASHIER_LOGGER=stack\r\n```\r\n\r\n对 Stripe 的 API 调用生成的异常将通过应用程序的默认日志通道记录。\r\n\r\n<a name=\"using-custom-models\"></a>\r\n### 使用自定义模型\r\n\r\n你可以通过定义自己的模型并扩展相应的 `Cashier` 模型来自由扩展 Cashier 内部的模型，增加一些方法：\r\n\r\n    use Laravel\\Cashier\\Subscription as CashierSubscription;\r\n\r\n    class Subscription extends CashierSubscription\r\n    {\r\n        // ...\r\n    }\r\n\r\n定义模型后，可以通过 `Laravel\\Cashier\\Cashier` 类配置 Cashier 使用自定义的模型。通常还需要在 `App\\Providers\\AppServiceProvider` 类的 `boot` 中注册一下：\r\n\r\n    use App\\Models\\Cashier\\Subscription;\r\n    use App\\Models\\Cashier\\SubscriptionItem;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Cashier::useSubscriptionModel(Subscription::class);\r\n        Cashier::useSubscriptionItemModel(SubscriptionItem::class);\r\n    }\r\n\r\n<a name=\"customers\"></a>\r\n## 消费者\r\n\r\n<a name=\"retrieving-customers\"></a>\r\n### 查询消费者\r\n\r\n你可以使用 `Cashier::findBillable` 方法通过 Stripe ID 查询消费者信息。该方法返回的是一个 billable 模型实例：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    $user = Cashier::findBillable($stripeId);\r\n\r\n<a name=\"creating-customers\"></a>\r\n### 创建消费者\r\n\r\n有时候，你可能希望在不开始订阅的情况下创建一个 Stripe 消费者。这可以通过 `createAsStripeCustomer` 方法来实现：\r\n\r\n    $stripeCustomer = $user->createAsStripeCustomer();\r\n\r\n消费者在 Stripe 中创建后，可以过一段时间再开始订阅。还可以使用可选的 `$options` 数组传入所有 [Stripe API 支持的创建消费者参数](https://stripe.com/docs/api/customers/create) 额外支持的参数：\r\n\r\n    $stripeCustomer = $user->createAsStripeCustomer($options);\r\n\r\n\n\n如果你要返回消费者对象，你可以使用 `asStripeCustomer` 方法：\r\n\r\n    $stripeCustomer = $user->asStripeCustomer();\r\n\r\n此外，可以使用 `createOrGetStripeCustomer` 方法来获取不确定查询的 Stripe 消费者在 Stripe 中是否已经存在。如果不存在，这个方法会创建一个消费者：\r\n\r\n    $stripeCustomer = $user->createOrGetStripeCustomer();\r\n\r\n<a name=\"updating-customers\"></a>\r\n### 更新消费者\r\n\r\n有时候，你可能想要使用额外的信息直接更新 Stripe 顾客信息，可以使用 `updateStripeCustomer` 方法来完成。这个方法接受 [Stripe API](https://stripe.com/docs/api/customers/update) 数组：\r\n\r\n    $stripeCustomer = $user->updateStripeCustomer($options);\r\n\r\n<a name=\"balances\"></a>\r\n### 余额\r\n\r\nStripe 允许你借记贷记消费者的“余额”。余额将体现在发票上面为借记或贷记。可以使用 `balance` 方法检测用户的可用余额。`balance` 方法会返回消费者货币余额格式化后的字符串：\r\n\r\n    $balance = $user->balance();\r\n\r\n要计入用户的余额，可以为 `applyBalance` 方法提供一个负值。如果愿意的话可以提供描述信息：\r\n\r\n    $user->applyBalance(-500, 'Premium customer top-up.');\r\n\r\n提供一个正数值给 `applyBalance` 方法将增加客户的余额：\r\n\r\n    $user->applyBalance(300, 'Bad usage penalty.');\r\n\r\n `applyBalance` 方法会创建一条客户余额流水记录。可以通过调用 `balanceTransactions` 方法获取余额交易记录，这有助于提供借记或贷记记录给客户查看：\r\n\r\n    // Retrieve all transactions...\r\n    $transactions = $user->balanceTransactions();\r\n\r\n    foreach ($transactions as $transaction) {\r\n        // Transaction amount...\r\n        $amount = $transaction->amount(); // $2.31\r\n\r\n        // Retrieve the related invoice when available...\r\n        $invoice = $transaction->invoice();\r\n    }\r\n\r\n\n\n<a name=\"tax-ids\"></a>\r\n### 税号\r\n\r\nCashier 提供了一种管理客户税号的简便方法。`taxIds` 例如，`taxIds` 方法可用于检索作为集合分配给客户的所有 [税号](https://stripe.com/docs/api/customer_tax_ids/object)：\r\n    $taxIds = $user->taxIds();\r\n\r\n您还可以通过标识符检索客户的特定税号：\r\n\r\n    $taxId = $user->findTaxId('txi_belgium');\r\n\r\n您可以通过向 `createTaxId` 方法提供有效的 [type](https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object-type) 和值来创建新的税号：\r\n\r\n    $taxId = $user->createTaxId('eu_vat', 'BE0123456789');\r\n\r\n`createTaxId` 方法将立即将增值税 ID 添加到客户的帐户中。 [增值税 ID 的验证也由 Stripe 完成](https://stripe.com/docs/invoicing/customer/tax-ids#validation)； 然而，这是一个异步的过程。 您可以通过订阅 `customer.tax_id.updated` webhook 事件并检查 [增值税 ID `verification` 参数]（https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object- 确认）。 有关处理 webhook 的更多信息，请参阅 [有关定义 webhook 处理程序的文档](#handling-stripe-webhooks)。\r\n\r\n您可以使用 `deleteTaxId` 方法删除税号：\r\n\r\n    $user->deleteTaxId('txi_belgium');\r\n\r\n<a name=\"syncing-customer-data-with-stripe\"></a>\r\n### 使用 Stripe 同步客户数据\r\n\r\n通常，当您的应用程序的用户更新他们的姓名、电子邮件地址或其他也由 Stripe 存储的信息时，您应该通知 Stripe 更新。 这样一来，Stripe 的信息副本将与您的应用程序同步。\r\n\r\n\n\n要自动执行此操作，您可以在计费模型上定义一个事件侦听器，以响应模型的「更新」事件。然后，在您的事件监听器中，您可以在模型上调用 `syncStripeCustomerDetails` 方法：\r\n\r\n    use function Illuminate\\Events\\queueable;\r\n\r\n    /**\r\n     * 模型的「引导」方法。\r\n     *\r\n     * @return void\r\n     */\r\n    protected static function booted()\r\n    {\r\n        static::updated(queueable(function ($customer) {\r\n            if ($customer->hasStripeId()) {\r\n                $customer->syncStripeCustomerDetails();\r\n            }\r\n        }));\r\n    }\r\n\r\n现在，每次更新您的客户模型时，其信息都会与 Stripe 同步。 为方便起见，Cashier 会在初始创建客户时自动将您客户的信息与 Stripe 同步。\r\n\r\n您可以通过覆盖 Cashier 提供的各种方法来自定义用于将客户信息同步到 Stripe 的列。 例如，当 Cashier 将客户信息同步到 Stripe 时，您可以重写 `stripeName` 方法来自定义应该被视为客户「姓名」的属性：\r\n\r\n    /**\r\n     * 获取应同步到 Stripe 的客户名称。\r\n     *\r\n     * @return string|null\r\n     */\r\n    public function stripeName()\r\n    {\r\n        return $this->company_name;\r\n    }\r\n\r\n同样，您可以复写 `stripeEmail`、`stripePhone` 和 `stripeAddress` 方法。 当[更新 Stripe 客户对象](https://stripe.com/docs/api/customers/update) 时，这些方法会将信息同步到其相应的客户参数。 如果您希望完全控制客户信息同步过程，您可以复写 `syncStripeCustomerDetails` 方法。\r\n\r\n<a name=\"billing-portal\"></a>\r\n### 订单入口\r\n\r\nStripe 提供了一个简单的方式来[设置订单入口](https://stripe.com/docs/billing/subscriptions/customer-portal)以便用户可以管理订阅、支付方法、以及查看历史账单。你可以在控制器或路由中使用 `redirectToBillingPortal` 方法将用户重定向到账单入口： \r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/billing-portal', function (Request $request) {\r\n        return $request->user()->redirectToBillingPortal();\r\n    });\r\n\r\n\n\n默认情况下，当用户完成对订阅的管理后，会将能够通过 Stripe 计费门户中的链接返回到应用的 home 路由，你可以通过传递 URL 作为 `redirectToBillingPortal` 方法的参数来自定义用户返回的 URL： \r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/billing-portal', function (Request $request) {\r\n        return $request->user()->redirectToBillingPortal(route('billing'));\r\n    });\r\n\r\n如果你只想要生成订单入口的 URL，可以使用 `billingPortalUrl` 方法： \r\n\r\n    $url = $request->user()->billingPortalUrl(route('billing'));\r\n\r\n<a name=\"payment-methods\"></a>\r\n## 支付方式\r\n\r\n<a name=\"storing-payment-methods\"></a>\r\n### 存储支付方式\r\n\r\n为了使用 Stripe 创建订阅或者进行「一次性」支付，你需要存储支付方法并从 `Stripe` 中获取对应的标识符。这种方式可用于实现你是否计划使用这个支付方法进行订阅还是单次收费，下面我们分别来介绍这两种方法。 \r\n\r\n<a name=\"payment-methods-for-subscriptions\"></a>\r\n#### 用于订阅的支付方法\r\n\r\n当我们为消费者存储信用卡支付方式以便将来使用时，必须使用 Stripe Setup Intents API 来安全地收集顾客的支付方式细节，比如回调错误信息 。「Setup Intents」用于告知 Stripe 使用顾客的支付方法进行收费的意图。Cashier 的 `Billable` Trait 包含了 `createSetupIntent` 方法来创建新的「Setup Intent」，你需要在渲染收集顾客支付方法细节表单的路由或控制器方法中调用这个方法：\r\n\r\n    return view('update-payment-method', [\r\n        'intent' => $user->createSetupIntent()\r\n    ]);\r\n\r\n\n\n创建完 Setup Intent 并将其传递给视图之后，你需要在收集支付方法的元素中添加它的 secret。例如，参考下面这个「更新支付方法」表单： \r\n\r\n```html\r\n<input id=\"card-holder-name\" type=\"text\">\r\n\r\n<!-- Stripe Elements Placeholder -->\r\n<div id=\"card-element\"></div>\r\n\r\n<button id=\"card-button\" data-secret=\"{{ $intent->client_secret }}\">\r\n    Update Payment Method\r\n</button>\r\n```\r\n\r\n接下来，会通过 Stripe.js 库添加一个 [Stripe 元素](https://stripe.com/docs/stripe-js)到表单，并安全地收集顾客的支付细节： \r\n\r\n```html\r\n<script src=\"https://js.stripe.com/v3/\"></script>\r\n\r\n<script>\r\n    const stripe = Stripe('stripe-public-key');\r\n\r\n    const elements = stripe.elements();\r\n    const cardElement = elements.create('card');\r\n\r\n    cardElement.mount('#card-element');\r\n</script>\r\n```\r\n\r\n然后，使用 [Stripe 的 handleCardSetup 方法](https://stripe.com/docs/stripe-js/reference#stripe-handle-card-setup)验证信用卡并从 Stripe 获取一个安全的「支付方法标识符」： \r\n\r\n```js\r\nconst cardHolderName = document.getElementById('card-holder-name');\r\nconst cardButton = document.getElementById('card-button');\r\nconst clientSecret = cardButton.dataset.secret;\r\n\r\ncardButton.addEventListener('click', async (e) => {\r\n    const { setupIntent, error } = await stripe.confirmCardSetup(\r\n        clientSecret, {\r\n            payment_method: {\r\n                card: cardElement,\r\n                billing_details: { name: cardHolderName.value }\r\n            }\r\n        }\r\n    );\r\n\r\n    if (error) {\r\n        // 显示错误信息给用户...\r\n    } else {\r\n        // 信用卡验证成功...\r\n    }\r\n});\r\n```\r\n\r\n在 Stripe 验证卡后，您可以将生成的 `setupIntent.payment_method` 标识符传递给您的 Laravel 应用程序，并在其中将其附加到客户。支付方式可以是[添加为新的支付方式](#adding-payment-methods) 或[用于更新默认支付方式](#updating-the-default-payment-method)。您还可以立即使用付款方式标识符来[创建新订阅](#creating-subscriptions)。\r\n\r\n> 技巧：如果你想要了解更多关于 Setup Intents 以及获取顾客支付细节的信息，可以参考 [Stripe 官方文档](https://stripe.com/docs/payments/save-and-reuse#php)。\r\n\r\n\n\n<a name=\"payment-methods-for-single-charges\"></a>\r\n#### 用于单次付费的支付方法\r\n\r\n当然，如果消费者支付方法使用的是单次付费，我们只需要使用支付方法标识符一次即可。由于 Stripe 本身的限制，你不可以使用存储的默认顾客支付方法进行单次付费，必须允许顾客通过 Stripe.js 库进入他们的支付方法细节。例如，参考下面这个表单： \r\n\r\n```html\r\n<input id=\"card-holder-name\" type=\"text\">\r\n\r\n<!-- Stripe Elements Placeholder -->\r\n<div id=\"card-element\"></div>\r\n\r\n<button id=\"card-button\">\r\n    Process Payment\r\n</button>\r\n```\r\n\r\n接下来跟上面文档相似，通过 Stripe.js 库添加 [Stripe 元素](https://stripe.com/docs/stripe-js) 到这个表单，并安全地收集顾客的支付细节： \r\n\r\n```html\r\n<script src=\"https://js.stripe.com/v3/\"></script>\r\n\r\n<script>\r\n    const stripe = Stripe('stripe-public-key');\r\n\r\n    const elements = stripe.elements();\r\n    const cardElement = elements.create('card');\r\n\r\n    cardElement.mount('#card-element');\r\n</script>\r\n```\r\n\r\n然后，使用 [Stripe 的 createPaymentMethod 方法](https://stripe.com/docs/stripe-js/reference#stripe-create-payment-method)验证信用卡并获取一个安全的「支付方法标识符」： \r\n\r\n```js\r\nconst cardHolderName = document.getElementById('card-holder-name');\r\nconst cardButton = document.getElementById('card-button');\r\n\r\ncardButton.addEventListener('click', async (e) => {\r\n    const { paymentMethod, error } = await stripe.createPaymentMethod(\r\n        'card', cardElement, {\r\n            billing_details: { name: cardHolderName.value }\r\n        }\r\n    );\r\n\r\n    if (error) {\r\n        // Display \"error.message\" to the user...\r\n    } else {\r\n        // The card has been verified successfully...\r\n    }\r\n});\r\n```\r\n\r\n如果信用卡验证成功，就可以传递 `paymentMethod.id` 到你的 Laravel 应用并处理[一次性付费](https://learnku.com/docs/laravel/8.5/billing/10421#Simple-Charge)。 \r\n\r\n<a name=\"retrieving-payment-methods\"></a>\r\n\n\n### 获取支付方法\r\n\r\nBillable 模型实例上的 `paymentMethods` 方法会返回 `Laravel\\Cashier\\PaymentMethod` 实例集合： \r\n\r\n    $paymentMethods = $user->paymentMethods();\r\n\r\n默认情况下，此方法将返回 `card` 类型的付款方式。 要检索不同类型的付款方式，您可以将 `type` 作为参数传递给该方法：\r\n\r\n    $paymentMethods = $user->paymentMethods('sepa_debit');\r\n\r\n要获取消费者默认的支付方法，可以使用 `defaultPaymentMethod` 方法： \r\n\r\n    $paymentMethod = $user->defaultPaymentMethod();\r\n\r\n还可以使用 `findPaymentMethod` 方法通过 Billable 模型获取指定支付方法： \r\n\r\n    $paymentMethod = $user->findPaymentMethod($paymentMethodId);\r\n\r\n<a name=\"check-for-a-payment-method\"></a>\r\n### 判断消费者是否拥有支付方法\r\n\r\n要判断某个 `Billable` 模型对应账户是否有默认的支付方法，可以使用 `hasDefaultPaymentMethod` 方法： \r\n\r\n    if ($user->hasDefaultPaymentMethod()) {\r\n        //\r\n    }\r\n\r\n要判断某个 `Billable` 模型对应账户是否有支付方法，可以使用 `hasPaymentMethod` 方法： \r\n\r\n    if ($user->hasPaymentMethod()) {\r\n        //\r\n    }\r\n\r\n此方法将确定计费模型是否具有 `card` 类型的付款方式。 要确定模型是否存在另一种类型的付款方式，您可以将 `type` 作为参数传递给该方法：\r\n\r\n    if ($user->hasPaymentMethod('sepa_debit')) {\r\n        //\r\n    }\r\n\r\n<a name=\"updating-the-default-payment-method\"></a>\r\n### 更新默认支付方式\r\n\r\n更新顾客的默认支付方式信息 可以用 `updateDefaultPaymentMethod` 方法 ，该方法接收一个 Stripe 支付方法标识符并将新的支付方法分配为默认的支付方法： \r\n\r\n    $user->updateDefaultPaymentMethod($paymentMethod);\r\n\r\n要同步应用的默认支付方法信息到 Stripe 顾客的默认支付方式信息，可以使用 `updateDefaultPaymentMethodFromStripe` 方法: \r\n\r\n    $user->updateDefaultPaymentMethodFromStripe();\r\n\r\n> 注意：消费者的默认支付方式只能用于发票和创建新的订阅，由于 Stripe 的限制，不能将其用于单次付费。 \r\n\r\n\n\n<a name=\"adding-payment-methods\"></a>\r\n### 添加支付方式\r\n\r\n要添加新的支付方式，可以调用 Billable 用户的 `addPaymentMethod` 方法，并传递支付方法标识符：\r\n\r\n    $user->addPaymentMethod($paymentMethod);\r\n\r\n> 技巧：要了解如何获取支付方法标识符，请参考[支付方式存储文档](https://learnku.com/docs/laravel/8.5/billing/10421#storing-payment-methods). \r\n\r\n<a name=\"deleting-payment-methods\"></a>\r\n### 删除支付方式 \r\n\r\n删除一个支付方法，你可以调用要删除的 `Laravel\\Cashier\\PaymentMethod` 实例上的 `delete` 方法：\r\n\r\n    $paymentMethod->delete();\r\n\r\n删除指定 Billable 模型上的所有支付方法信息可以使用 `deletePaymentMethods` 方法： \r\n\r\n    $user->deletePaymentMethod('pm_visa');\r\n\r\n`deletePaymentMethods` 方法将删除计费模型的所有付款方式信息：\r\n\r\n    $user->deletePaymentMethods();\r\n\r\n默认情况下，此方法将删除 `card` 类型的付款方式。 要删除不同类型的付款方式，您可以将 `type` 作为参数传递给该方法：\r\n\r\n    $user->deletePaymentMethods('sepa_debit');\r\n\r\n> 注意：如果用户有活动订阅，您的应用程序不应允许他们删除其默认付款方式。\r\n\r\n<a name=\"subscriptions\"></a>\r\n## 订阅内容\r\n\r\n订阅提供了一种为消费者设置定期付款的方式。由收银员管理的 Stripe 订阅 提供对多个订阅计划、订阅数量、试用等的支持。 \r\n\r\n<a name=\"creating-subscriptions\"></a>\r\n### 创建订阅 \r\n\r\n创建一个订阅，首先要获取一个账单模型的实例，通常是 `App\\Models\\User` 的实例。获取到该模型实例之后，可以使用 `newSubscription` 方法来创建该模型的订阅：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription(\r\n            'default', 'price_monthly'\r\n        )->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n\n\n`newSubscription` 方法的第一个参数是该订阅的名字，如果应用只有一个订阅，可以将其称作 `default` 或 `primary`，第二个参数用于指定用户订阅的计划，这个值对应 `Stripe` 中相应计划的标识符。\r\n\r\n`create` 方法接收 [Stripe 支付方法标识符](https://laravelacademy.org/post/22032#toc-13)或者 Stripe `PaymentMethod` 对象的 `create` 方法会自动创建这个 Stripe 订阅，同时更新数据库中 Stripe 的消费者 ID（即 `users` 表中的 `stripe_id`）和其它相关的账单信息。 \r\n\r\n> 注意：直接传递支付方法标识符到 create () 订阅方法还会自动将其添加到用户存储的支付方法中。\r\n\r\n<a name=\"collecting-recurring-payments-via-invoice-emails\"></a>\r\n#### 通过发票电子邮件收集定期付款\r\n\r\n您可以指示 Stripe 在每次定期付款到期时通过电子邮件将发票发送给客户，而不是自动收取客户的定期付款。 然后，客户可以在收到发票后手动支付发票。 通过发票收取定期付款时，客户无需预先提供付款方式：\r\n\r\n    $user->newSubscription('default', 'price_monthly')->createAndSendInvoice();\r\n\r\n客户在取消订阅之前必须支付发票的时间取决于您在 [Stripe 仪表板](https://dashboard.stripe.com/settings/billing/automatic) 中的订阅和发票设置。\r\n\r\n\n\n<a name=\"subscription-quantities\"></a>\r\n#### 数量\r\n\r\n如果你想要在创建订阅时设置计划的具体数量，可以使用 `quantity` 方法： \r\n\r\n    $user->newSubscription('default', 'price_monthly')\r\n         ->quantity(5)\r\n         ->create($paymentMethod);\r\n\r\n<a name=\"additional-details\"></a>\r\n#### 其它细节\r\n\r\n如果你想要指定其它[消费者](https://stripe.com/docs/api/customers/create)或者[订阅细节](https://stripe.com/docs/api/subscriptions/create)，你可以将其作为第二个参数传递给 `create` 方法： \r\n\r\n    $user->newSubscription('default', 'price_monthly')->create($paymentMethod, [\r\n        'email' => $email,\r\n    ], [\r\n        'metadata' => ['note' => 'Some extra information.'],\r\n    ]);\r\n\r\n<a name=\"coupons\"></a>\r\n#### 优惠券\r\n\r\n如果你想在创建订阅的时候使用优惠券，你可以使用 `withCoupon` 方法:\r\n\r\n    $user->newSubscription('default', 'price_monthly')\r\n         ->withCoupon('code')\r\n         ->create($paymentMethod);\r\n\r\n或者，如果你想使用 [Stripe 推广代码](https://stripe.com/docs/billing/subscriptions/discounts/codes)，可以使用 `withPromotionCode` 方法：\r\n\r\n    $user->newSubscription('default', 'price_monthly')\r\n         ->withPromotionCode('promo_code')\r\n         ->create($paymentMethod);\r\n\r\n<a name=\"adding-subscriptions\"></a>\r\n#### 添加订阅\r\n\r\n如果你想要为已经有默认支付方式的消费者添加订阅，可以在使用 `newSubscription` 方法时使用 `add` 方法：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->newSubscription('default', 'price_monthly')->add();\r\n\r\n\n\n<a name=\"creating-subscriptions-from-the-stripe-dashboard\"></a>\r\n#### 从 Stripe 面板中创建订阅\r\n\r\n你也可以从 Stripe 面板中创建订阅。在面板中创建订阅时候，收银员将同步新添加的订阅，并为它们分配一个名称为 `default` 的订阅。要自定义分配给仪表板创建订阅的订阅名，[扩展’ WebhookController ‘](https://learnku.com/docs/laravel/8.5/billing/10421#defining-webhook-event-handlers)并覆盖 `newSubscriptionName` 方法。 \r\n\r\n此外，只能通过 Stripe 面板中创建一种订阅类型。如果应用程序提供使用不同名称的多个订阅，则只能通过 Stripe 面板添加一种订阅类型。 \r\n\r\n最后，应该始终确保对应用程序提供的每种订阅类型只添加一个活动订阅。如果消费者有两个 `default` 订阅，那么收银员只会使用最近添加的订阅，即使这两个订阅都将与应用程序的数据库同步。 \r\n\r\n<a name=\"checking-subscription-status\"></a>\r\n### 检查订阅状态 \r\n\r\n客户订阅您的应用程序后，您可以使用各种便捷的方法检查他们的订阅状态。首先，如果客户有活动订阅，则 `subscribed` 方法会返回 `true`，即使订阅当前处于试用期也是如此。`subscribed` 方法接受订阅的名称作为它的第一个参数:\r\n\r\n    if ($user->subscribed('default')) {\r\n        //\r\n    }\r\n\r\n`subscribed` 方法也可以用于[路由中间件](https://learnku.com/docs/laravel/8.5/middleware) , 基于消费者订阅状态允许你对路由和控制器的访问进行过滤：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n\r\n    class EnsureUserIsSubscribed\r\n    {\r\n        /**\r\n         * 处理传入的请求。\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Closure  $next\r\n         * @return mixed\r\n         */\r\n        public function handle($request, Closure $next)\r\n        {\r\n            if ($request->user() && ! $request->user()->subscribed('default')) {\r\n                // 该用户不是付费用户...\r\n                return redirect('billing');\r\n            }\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n\n\n如果你想要判断一个消费者是否还在试用期，可以使用 `onTrial` 方法，该方法对于还处于试用期的用户显示警告信息很有用：\r\n\r\n    if ($user->subscription('default')->onTrial()) {\r\n        //\r\n    }\r\n\r\n`subscribedToProduct` 方法可用于根据给定 Stripe 产品的标识符确定用户是否订阅了给定产品。 在 Stripe 中，产品是价格的集合。 在此示例中，我们将确定用户的 `默认` 订阅是否主动订阅了应用程序的 `高级` 产品。 给定的 Stripe 产品标识符应与您在 Stripe 仪表板中的产品标识符之一相对应：\r\n\r\n    if ($user->subscribedToProduct('prod_premium', 'default')) {\r\n        //\r\n    }\r\n\r\n\r\n\r\n    if ($user->subscribedToProduct(['prod_basic', 'prod_premium'], 'default')) {\r\n        //\r\n    }\r\n\r\n`subscribedToPrice` 方法可用于确定客户的订阅是否对应于给定的价格 ID：\r\n\r\n    if ($user->subscribedToPrice('price_basic_monthly', 'default')) {\r\n        //\r\n    }\r\n\r\n`recurring` 方法可用于确定用户当前是否已订阅并且不再处于试用期内：\r\n\r\n    if ($user->subscription('default')->recurring()) {\r\n        //\r\n    }\r\n\r\n> 注意：如果消费者有两个具有相同名称的订阅，则 subscription 方法将始终返回最近的订阅。例如，消费者可能有两条名为 default 的订阅记录；但是，其中一个订阅可能是旧的、过期的订阅，而另一个是当前的、活动的订阅。最新的订阅将始终返回，而旧的订阅将保留在数据库中以进行历史回顾。\r\n\r\n\n\n<a name=\"cancelled-subscription-status\"></a>\r\n#### 已取消的订阅状态\r\n\r\n要判断消费者是否曾经是有效的订阅者，但现在取消了订阅，可以使用 `cancelled` 方法：\r\n\r\n    if ($user->subscription('default')->canceled()) {\r\n        //\r\n    }\r\n\r\n还可以判断消费者是否曾经取消过订阅，但现在仍然在「宽限期」直到完全失效。例如，如果一个消费者在 3 月 5 号取消了一个实际有效期到 3 月 10 号的订阅，该消费者处于「宽限期」直到 3 月 10 号。注意 `subscribed` 方法在此期间仍然返回 `true`。 \r\n\r\n    if ($user->subscription('default')->onGracePeriod()) {\r\n        //\r\n    }\r\n\r\n要去定消费者已经取消订阅并且不在「宽限期」内，可以使用 `ended` 方法： \r\n\r\n    if ($user->subscription('default')->ended()) {\r\n        //\r\n    }\r\n\r\n<a name=\"incomplete-and-past-due-status\"></a>\r\n#### 未完成和过期状态\r\n\r\n如果某个订阅要求创建完订阅后进行二次付款操作，将被标记为 `incomplete`。订阅状态被存储在 `Cashier subscriptions` 数据表的 `stripe_status` 字段。\r\n\r\n类似的，如果在切换订阅计划时也需要进行二次付款操作，对应的订阅会被标记为 `past_due`。当你的订阅处于这种状态时，只有等到消费者确认支付后它们才会被激活。我们可以使用 `Billable` 模型或者订阅实例的 `hasIncompletePayment` 方法来检查某个订阅是否存在未完成支付：\r\n\r\n    if ($user->hasIncompletePayment('default')) {\r\n        //\r\n    }\r\n\r\n    if ($user->subscription('default')->hasIncompletePayment()) {\r\n        //\r\n    }\r\n\r\n如果某个订阅存在未完成支付，你需要引导消费者到 Cashier 的支付确认页面，并传递 `latestPayment` 标识符。你可以使用订阅实例上的 `latestPayment` 方法来获取这个标识符：\r\n\r\n```html\r\n<a href=\"{{ route('cashier.payment', $subscription->latestPayment()->id) }}\">\r\n    Please confirm your payment.\r\n</a>\r\n```\r\n\r\n\n\n如果你想要订阅在 `past_due` 状态下依然有效，可以使用 Cashier 提供的 `keepPastDueSubscriptionsActive` 方法，通常，该方法需要在 `AppServiceProvider` 的 `boot` 方法中调用：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    /**\r\n     * Register any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        Cashier::keepPastDueSubscriptionsActive();\r\n    }\r\n\r\n> 注意：当某个订阅处于 `incomplete` 状态，只有等到支付被确认后才能进行修改。因此，当订阅处于 `incomplete` 状态时，执行 `swap` 和 `updateQuantity` 方法会抛出异常。\r\n\r\n<a name=\"subscription-scopes\"></a>\r\n#### 订阅范围\r\n\r\n大多数订阅状态也可用作查询范围，以便你可以轻松地查询数据库中处于给定状态的订阅：\r\n\r\n    // 获取所有有效订阅...\r\n    $subscriptions = Subscription::query()->active()->get();\r\n\r\n    // Get all of the canceled subscriptions for a user...\r\n    $subscriptions = $user->subscriptions()->canceled()->get();\r\n\r\n所有内置的订阅查询范围列表如下：\r\n\r\n    Subscription::query()->active();\r\n    Subscription::query()->canceled();\r\n    Subscription::query()->ended();\r\n    Subscription::query()->incomplete();\r\n    Subscription::query()->notCanceled();\r\n    Subscription::query()->notOnGracePeriod();\r\n    Subscription::query()->notOnTrial();\r\n    Subscription::query()->onGracePeriod();\r\n    Subscription::query()->onTrial();\r\n    Subscription::query()->pastDue();\r\n    Subscription::query()->recurring();\r\n\r\n<a name=\"changing-prices\"></a>\r\n### 修改计划\r\n\r\n消费者订阅应用后，有时候想要改变到新的订阅计划，需要将消费者切换到新的订阅，传递计划标识符到 swap 方法：\r\n\r\n在交换价格时，假设用户想要重新激活他们的订阅（如果之前取消订阅）。 给定的价格标识符应对应于 Stripe 仪表板中可用的 Stripe 价格标识符：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    $user->subscription('default')->swap('price_yearly');\r\n\r\n\n\n如果消费者在试用，试用期将会被维护。还有，如果订阅存在多个，数量也可以被维护。\r\n\r\n如果你想要切换计划并取消消费者所在的所有试用期，可以使用 skipTrial 方法：\r\n\r\n    $user->subscription('default')\r\n            ->skipTrial()\r\n            ->swap('price_yearly');\r\n\r\n如果你想要切换计划并立即为消费者开具发票，而不是等到下一个结算周期，可以使用 `swapAndInvoice` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swapAndInvoice('price_yearly');\r\n\r\n<a name=\"prorations\"></a>\r\n#### 按比例分配\r\n\r\n默认情况下，Stripe 会在订阅计划间切换时按比例进行分配，`noProrate` 可用于在修改订阅计划时不使用按比例分配机制：\r\n\r\n    $user->subscription('default')->noProrate()->swap('price_yearly');\r\n\r\n更多关于订阅计划按比例分配的细节，请参考 [Stripe 官方文档](https://stripe.com/docs/billing/subscriptions/prorations)。\r\n\r\n> 注意：在 `wapAndInvoice` 方法之前执行 `noProrate` 方法不会影响按比例分配。发票始终都会开具。\r\n\r\n<a name=\"subscription-quantity\"></a>\r\n### 订阅数量 \r\n\r\n有时候订阅也会被数量影响，例如，应用中每个账户每月需要付费 $10，要简单增加或减少订阅数量，使用 `incrementQuantity` 和 `decrementQuantity` 方法： \r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->incrementQuantity();\r\n\r\n    // 向订阅的当前数量添加五个...\r\n    $user->subscription('default')->incrementQuantity(5);\r\n\r\n    $user->subscription('default')->decrementQuantity();\r\n\r\n    // 从订阅的当前数量中减去五...\r\n    $user->subscription('default')->decrementQuantity(5);\r\n\r\n\n\n你也可以使用 `updateQuantity` 方法指定具体的数量：\r\n\r\n    $user->subscription('default')->updateQuantity(10);\r\n\r\n`noProrate` 方法可用于更新订阅数量而无需对收费进行评级：\r\n\r\n    $user->subscription('default')->noProrate()->updateQuantity(10);\r\n\r\n想要了解更多订阅数量信息，可以参考 [Stripe 官方文档](https://stripe.com/docs/subscriptions/quantities).\r\n\r\n<a name=\"multiprice-subscription-quantities\"></a>\r\n#### 多方案订阅数量\r\n\r\n如果你的订阅是[多方案订阅计划](https://learnku.com/docs/laravel/8.5/billing/10421#multiplan-subscriptions) , 你应该将其数量要递增或递减的计划的名称作为第二个参数传递给递增 / 递减方法\r\n\r\n    $user->subscription('default')->incrementQuantity(1, 'price_chat');\r\n\r\n<a name=\"multiprice-subscriptions\"></a>\r\n### 多方案订阅计划\r\n\r\n[多方案订阅计划](https://stripe.com/docs/billing/subscriptions/multiplan) 可以分配多个付费方案给单个订阅计划。例如，假设你正在构建一个顾客咨询服务应用，其中包含了一个基础的￥10 / 月的订阅方案，但是如果提供附加的实时聊天服务，需要支付￥15 / 月，订阅信息存储在收银员的 `Subscription_items` 数据库表中：\r\n\r\n可以通过将计划数组作为第二个参数传递给 `newSubscription` 方法，为给定的订阅指定多个计划：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription('default', [\r\n            'price_monthly',\r\n            'price_chat',\r\n        ])->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n在上面的示例代码中，消费者的 `default` 订阅添加了两个订阅计划。这两个计划都将按各自的计费间隔收费。如果需要，可以使用 `Quantity` 方法来表示每个计划的具体数量：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->newSubscription('default', ['price_monthly', 'price_chat'])\r\n        ->quantity(5, 'price_chat')\r\n        ->create($paymentMethod);\r\n\r\n\n\n如果您想为现有订阅添加其他价格，可以调用订阅的 `addPrice` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->addPrice('price_chat');\r\n\r\n上面的示例代码会添加新方案并且顾客会在下个支付周期为其支付。如果你想要让顾客立即支付，可以使用 `addPlanAndInvoice` 方法：\r\n\r\n    $user->subscription('default')->addPriceAndInvoice('price_chat');\r\n\r\n如果你想要添加指定数量的方案，可以将数量值作为第二个参数传递给 `addPlan` 或者 `addPlanAndInvoice` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->addPrice('price_chat', 5);\r\n\r\n你也可以使用 `removePlan` 方法从订阅计划中移除这些方案：\r\n\r\n    $user->subscription('default')->removePrice('price_chat');\r\n\r\n> 注意：不能移除订阅计划中最后一个方案（至少需要保留一个）, 相反，需要通过取消订阅的方式移除该方案。\r\n\r\n<a name=\"swapping-prices\"></a>\r\n#### 多方案订阅切换\r\n\r\n您还可以更改多价订阅的附加价格。 例如，假设客户订阅了带有 `price_chat` 附加价格的 `price_basic`，并且您想将客户从 `price_basic` 升级到 `price_pro` 价格：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swap(['price_pro', 'price_chat']);\r\n\r\n执行上面的示例时，带有 `price_basic` 的底层订阅项目被删除，而带有`price_chat` 的订阅项目被保留。 此外，还会为 `price_pro` 创建一个新的订阅项目。\r\n\r\n您还可以通过将一组键/值对传递给“swap”方法来指定订阅项目选项。 例如，您可能需要指定订阅价格的数量：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swap([\r\n        'price_pro' => ['quantity' => 5],\r\n        'price_chat'\r\n    ]);\r\n\r\n\n\n如果您想交换订阅的单一价格，您可以使用订阅项目本身的“swap”方法来实现。 如果您想保留订阅的其他价格上的所有现有元数据，此方法特别有用：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')\r\n            ->findItemOrFail('price_basic')\r\n            ->swap('price_pro');\r\n\r\n<a name=\"proration\"></a>\r\n#### 按比例分配\r\n\r\n默认情况下，在多价订阅中添加或删除价格时，Stripe 将按比例收取费用。 如果您想在没有按比例分配的情况下进行价格调整，您应该将 `noProrate` 方法链接到您的价格操作：\r\n\r\n    $user->subscription('default')->noProrate()->removePrice('price_chat');\r\n\r\n<a name=\"swapping-quantities\"></a>\r\n#### 数量\r\n\r\n如果您想更新单个订阅价格的数量，您可以使用 [现有数量方法](#subscription-quantity) 将价格名称作为附加参数传递给该方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->incrementQuantity(5, 'price_chat');\r\n\r\n    $user->subscription('default')->decrementQuantity(3, 'price_chat');\r\n\r\n    $user->subscription('default')->updateQuantity(10, 'price_chat');\r\n\r\n> 注意：当订阅有多个价格时，“Subscription”模型上的“stripe_price”和“quantity”属性将为“null”。 要访问单个价格属性，您应该使用 `Subscription` 模型上可用的 `items` 关系。\r\n\r\n<a name=\"subscription-items\"></a>\r\n#### 订阅项目\r\n\r\n当订阅有多个价格时，它将有多个订阅“项目”存储在数据库的 `subscription_items` 表中。 您可以通过订阅上的 `items` 关系访问这些：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $subscriptionItem = $user->subscription('default')->items->first();\r\n\r\n    // 检索特定商品的 Stripe 价格和数量...\r\n    $stripePrice = $subscriptionItem->stripe_price;\r\n    $quantity = $subscriptionItem->quantity;\r\n\r\n\n\n您还可以使用 `findItemOrFail` 方法检索特定价格：\r\n\r\n    $user = User::find(1);\r\n\r\n    $subscriptionItem = $user->subscription('default')->findItemOrFail('price_chat');\r\n\r\n<a name=\"metered-billing\"></a>\r\n### 计量计费\r\n\r\n[计量计费](https://stripe.com/docs/billing/subscriptions/metered-billing) 允许您根据客户在计费周期内的产品使用情况向他们收费。 例如，您可以根据客户每月发送的短信或电子邮件的数量向他们收费。\r\n\r\n要开始使用计量计费，您首先需要在 Stripe 仪表板中创建一个具有计量价格的新产品。 然后，使用 `meteredPrice` 将计量价格 ID 添加到客户订阅中：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription('default')\r\n            ->meteredPrice('price_metered')\r\n            ->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n您也可以通过 [Stripe Checkout](#checkout) 开始计量订阅：\r\n\r\n    $checkout = Auth::user()\r\n            ->newSubscription('default', [])\r\n            ->meteredPrice('price_metered')\r\n            ->checkout();\r\n\r\n    return view('your-checkout-view', [\r\n        'checkout' => $checkout,\r\n    ]);\r\n\r\n<a name=\"reporting-usage\"></a>\r\n#### 报告使用情况\r\n\r\n当您的客户使用您的应用程序时，您将向 Stripe 报告他们的使用情况，以便准确计费。 要增加计量订阅的使用量，您可以使用 `reportUsage` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->reportUsage();\r\n\r\n默认情况下，计费周期会添加 1 的“使用量”。 或者，您可以传递特定数量的“使用量”以添加到客户在计费期间的使用量：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->reportUsage(15);\r\n\r\n如果您的应用程序在单个订阅中提供多个价格，您将需要使用 `reportUsageFor` 方法来指定要报告使用情况的计量价格：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->reportUsageFor('price_metered', 15);\r\n\r\n\n\n有时，您可能需要更新之前报告的使用情况。 为此，您可以将时间戳或“DateTimeInterface”实例作为第二个参数传递给“reportUsage”。 这样做时，Stripe 将更新在给定时间报告的使用情况。 您可以继续更新以前的使用记录，因为给定的日期和时间仍在当前计费周期内：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->reportUsage(5, $timestamp);\r\n\r\n<a name=\"retrieving-usage-records\"></a>\r\n#### 检索使用记录\r\n\r\n要检索客户过去的使用情况，您可以使用订阅实例的 `usageRecords` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $usageRecords = $user->subscription('default')->usageRecords();\r\n\r\n如果您的应用程序在单个订阅中提供多个价格，您可以使用 `usageRecordsFor` 方法指定您希望检索使用记录的计量价格：\r\n\r\n    $user = User::find(1);\r\n\r\n    $usageRecords = $user->subscription('default')->usageRecordsFor('price_metered');\r\n\r\n`usageRecords` 和 `usageRecordsFor` 方法返回一个包含使用记录关联数组的 Collection 实例。 您可以遍历此数组以显示客户的总使用量：\r\n\r\n    @foreach ($usageRecords as $usageRecord)\r\n        - Period Starting: {{ $usageRecord['period']['start'] }}\r\n        - Period Ending: {{ $usageRecord['period']['end'] }}\r\n        - Total Usage: {{ $usageRecord['total_usage'] }}\r\n    @endforeach\r\n\r\n有关返回的所有使用数据以及如何使用 Stripe 的基于光标的分页的完整参考，请参阅 [官方 Stripe API 文档](https://stripe.com/docs/api/usage_records/subscription_item_summary_list)。\r\n\r\n<a name=\"subscription-taxes\"></a>\r\n### 订阅 Taxes\r\n\r\n> 注意：您可以[使用 StripeTax 自动计算税金](#tax-configuration)，而不是手动计算税率\r\n\r\n\n\n要指定用户为订阅支付的税率，您应该在计费模型上实现 `taxRates` 方法并返回一个包含 Stripe 税率 ID 的数组。 您可以在 [您的 Stripe 仪表板](https://dashboard.stripe.com/test/tax-rates) 中定义这些税率：\r\n\r\n    /**\r\n     * 应适用于客户订阅的税率。\r\n     *\r\n     * @return array\r\n     */\r\n    public function taxRates()\r\n    {\r\n        return ['txr_id'];\r\n    }\r\n\r\n`taxRates` 方法使您可以逐个客户应用税率，这可能有助于跨越多个国家和税率的用户群。\r\n\r\n如果您提供多价订阅，您可以通过在计费模型上实现 `priceTaxRates` 方法为每个价格定义不同的税率：\r\n\r\n    /**\r\n     * The tax rates that should apply to the customer's subscriptions.\r\n     *\r\n     * @return array\r\n     */\r\n    public function priceTaxRates()\r\n    {\r\n        return [\r\n            'price_monthly' => ['txr_id'],\r\n        ];\r\n    }\r\n\r\n> 注意：`taxRates` 方法仅适用于订阅费用。 如果您使用 Cashier 进行“一次性”收费，您将需要手动指定当时的税率。\r\n\r\n<a name=\"syncing-tax-rates\"></a>\r\n#### 同步税率\r\n\r\n更改 `taxRates` 方法返回的硬编码税率 ID 时，用户现有订阅的税费设置将保持不变。 如果您希望使用新的 `taxRates` 值更新现有订阅的税值，则应在用户的订阅实例上调用 `syncTaxRates` 方法：\r\n\r\n    $user->subscription('default')->syncTaxRates();\r\n\r\n这还将同步任何多价订阅项目税率。 如果您的应用程序提供多价订阅，您应该确保您的计费模型实现了 `priceTaxRates` 方法 [如上所述](#subscription-taxes)。\r\n\r\n\n\n<a name=\"tax-exemption\"></a>\r\n#### 免税\r\n\r\nCashier 还提供了 `isNotTaxExempt`、`isTaxExempt` 和 `reverseChargeApplies` 方法来确定客户是否免税。 这些方法将调用 Stripe API 来确定客户的免税状态：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->isTaxExempt();\r\n    $user->isNotTaxExempt();\r\n    $user->reverseChargeApplies();\r\n\r\n> 注意：这些方法也适用于任何 `Laravel\\Cashier\\Invoice` 对象。 但是，当在“发票”对象上调用时，这些方法将在创建发票时确定豁免状态。\r\n\r\n<a name=\"subscription-anchor-date\"></a>\r\n### 订阅锚定日期\r\n\r\n默认情况下，计费周期锚点是订阅的创建日期，或者，如果使用试用期，则为试用结束的日期。 如果您想修改计费锚定日期，可以使用 `anchorBillingCycleOn` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $anchor = Carbon::parse('first day of next month');\r\n\r\n        $request->user()->newSubscription('default', 'price_monthly')\r\n                    ->anchorBillingCycleOn($anchor->startOfDay())\r\n                    ->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n有关管理订阅计费周期的更多信息，请参阅 [Stripe 计费周期文档](https://stripe.com/docs/billing/subscriptions/billing-cycle)\r\n\r\n<a name=\"cancelling-subscriptions\"></a>\r\n### 取消订阅\r\n\r\n要取消订阅，请在用户订阅上调用 `cancel` 方法：\r\n\r\n    $user->subscription('default')->cancel();\r\n\r\n取消订阅后，Cashier 会自动在您的 `subscriptions` 数据库表中设置 `ends_at` 列。 此列用于了解 `subscribed` 方法应该何时开始返回 `false`。\r\n\r\n例如，如果客户在 3 月 1 日取消订阅，但订阅计划到 3 月 5 日才结束，则 `subscribed` 方法将继续返回 `true` 直到 3 月 5 日。 这样做是因为通常允许用户继续使用应用程序，直到他们的计费周期结束。\r\n\r\n\n\n您可以使用 `onGracePeriod` 方法确定用户是否已取消订阅但仍处于“宽限期”：\r\n\r\n    if ($user->subscription('default')->onGracePeriod()) {\r\n        //\r\n    }\r\n\r\n如果您想立即取消订阅，请在用户订阅上调用 `cancelNow` 方法：\r\n\r\n    $user->subscription('default')->cancelNow();\r\n\r\n如果您希望立即取消订阅并为任何剩余的未开票计量使用或新的/待定的按比例发票项目开具发票，请在用户的订阅上调用 `cancelNowAndInvoice` 方法：\r\n\r\n    $user->subscription('default')->cancelNowAndInvoice();\r\n\r\n您也可以选择在特定时间取消订阅：\r\n\r\n    $user->subscription('default')->cancelAt(\r\n        now()->addDays(10)\r\n    );\r\n\r\n<a name=\"resuming-subscriptions\"></a>\r\n### 恢复订阅\r\n\r\n如果客户取消了他们的订阅并且您希望恢复它，您可以在订阅上调用 `resume` 方法。 客户必须仍在其“宽限期”内才能恢复订阅：\r\n\r\n    $user->subscription('default')->resume();\r\n\r\n如果客户取消订阅，然后在订阅完全过期之前恢复订阅，则不会立即向客户收费。 相反，他们的订阅将被重新激活，并将按原始计费周期计费。\r\n\r\n<a name=\"subscription-trials\"></a>\r\n## 订阅 Trials\r\n\r\n<a name=\"with-payment-method-up-front\"></a>\r\n### 预先使用付款方式\r\n\r\n如果您想为您的客户提供试用期，同时仍然预先收集付款方式信息，您应该在创建订阅时使用 `trialDays` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription('default', 'price_monthly')\r\n                    ->trialDays(10)\r\n                    ->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n\n\n此方法将在数据库中的订阅记录上设置试用期结束日期，并指示 Stripe 在此日期之后才开始向客户收费。 当使用 `trialDays` 方法时，Cashier 将覆盖为 Stripe 中的价格配置的任何默认试用期。\r\n\r\n> 注意：如果客户的订阅没有在试用期结束日期之前取消，他们将在试用期结束后立即收费，因此您应该确保通知您的用户他们的试用期结束日期。\r\n\r\n`trialUntil` 方法允许你提供一个 `DateTime` 实例来指定试用期的结束时间：\r\n\r\n    use Carbon\\Carbon;\r\n\r\n    $user->newSubscription('default', 'price_monthly')\r\n                ->trialUntil(Carbon::now()->addDays(10))\r\n                ->create($paymentMethod);\r\n\r\n您可以使用用户实例的“onTrial”方法或订阅实例的“onTrial”方法来确定用户是否在试用期内。 下面的两个例子是等价的：\r\n\r\n    if ($user->onTrial('default')) {\r\n        //\r\n    }\r\n\r\n    if ($user->subscription('default')->onTrial()) {\r\n        //\r\n    }\r\n\r\n您可以使用 `endTrial` 方法立即结束订阅试用：\r\n\r\n    $user->subscription('default')->endTrial();\r\n\r\n<a name=\"defining-trial-days-in-stripe-cashier\"></a>\r\n#### 在 Stripe 中定义试用天数 / Cashier\r\n\r\n您可以选择在 Stripe 仪表板中定义您的价格收到多少试用天，或者始终使用 Cashier 明确传递它们。 如果您选择在 Stripe 中定义价格的试用天数，您应该知道新订阅（包括过去订阅过的客户的新订阅）将始终收到试用期，除非您明确调用 `skipTrial()` 方法.\r\n\r\n\n\n<a name=\"without-payment-method-up-front\"></a>\r\n### 没有预付款方式\r\n\r\n如果您想提供试用期而不预先收集用户的付款方式信息，您可以将用户记录上的“trial_ends_at”列设置为您想要的试用结束日期。 这通常在用户注册期间完成：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::create([\r\n        // ...\r\n        'trial_ends_at' => now()->addDays(10),\r\n    ]);\r\n\r\n> 注意：请务必在计费模型的类定义中为 `trial_ends_at` 属性添加 [日期转换](/docs/laravel/9.x/eloquent-mutators##date-casting)。\r\n\r\nCashier 将这种类型的试用称为“通用试用”，因为它不附加到任何现有订阅。 如果当前日期未超过 `trial_ends_at` 的值，可计费模型实例上的 `onTrial` 方法将返回 `true`：\r\n\r\n    if ($user->onTrial()) {\r\n        // 用户在试用期内...\r\n    }\r\n\r\n一旦你准备好为用户创建一个实际的订阅，你可以像往常一样使用`newSubscription`方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->newSubscription('default', 'price_monthly')->create($paymentMethod);\r\n\r\n要检索用户的试用结束日期，您可以使用 `trialEndsAt` 方法。 如果用户正在试用，此方法将返回一个 Carbon 日期实例，如果不是，则返回“null”。 如果您想获取除默认订阅之外的特定订阅的试用结束日期，您还可以传递可选订阅名称参数：\r\n\r\n    if ($user->onTrial()) {\r\n        $trialEndsAt = $user->trialEndsAt('main');\r\n    }\r\n\r\n如果您想明确知道用户处于 “generic” 试用期并且尚未创建实际订阅，您也可以使用 `onGenericTrial` 方法：\r\n\r\n    if ($user->onGenericTrial()) {\r\n        // 用户在他们的 “generic” 试用期内...\r\n    }\r\n\r\n\n\n<a name=\"extending-trials\"></a>\r\n### 延长试用\r\n\r\n`extendTrial` 方法允许您在创建订阅后延长订阅的试用期。 如果试用期已经过期并且客户已经被收取订阅费用，您仍然可以为他们提供延长试用期。 试用期内花费的时间将从客户的下一张发票中扣除：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $subscription = User::find(1)->subscription('default');\r\n\r\n    // 从现在起 7 天后结束试用...\r\n    $subscription->extendTrial(\r\n        now()->addDays(7)\r\n    );\r\n\r\n    // 试用期再增加 5 天...\r\n    $subscription->extendTrial(\r\n        $subscription->trial_ends_at->addDays(5)\r\n    );\r\n\r\n<a name=\"handling-stripe-webhooks\"></a>\r\n## 处理 Stripe webhook\r\n\r\n> 技巧：您可以使用 [the Stripe CLI](https://stripe.com/docs/stripe-cli) 在本地开发期间帮助测试 webhook。\r\n\r\nStripe 可以通过 webhook 通知您的应用程序各种事件。 默认情况下，指向 Cashier 的 webhook 控制器的路由由 Cashier 服务提供者自动注册。 此控制器将处理所有传入的 webhook 请求。\r\n\r\n默认情况下，Cashier webhook 控制器将自动处理取消订阅失败的次数过多（由您的 Stripe 设置定义）、客户更新、客户删除、订阅更新和付款方式更改； 然而，我们很快就会发现，你可以扩展这个控制器来处理你喜欢的任何 Stripe webhook 事件。\r\n\r\n为确保您的应用程序可以处理 Stripe webhook，请务必在 Stripe 控制面板中配置 webhook URL。 默认情况下，Cashier 的 webhook 控制器响应 `/stripe/webhook` URL 路径。您应该在 Stripe 控制面板中启用的所有 webhook 的完整列表是：\r\n\r\n- `customer.subscription.created`\r\n- `customer.subscription.updated`\r\n- `customer.subscription.deleted`\r\n- `customer.updated`\r\n- `customer.deleted`\r\n- `invoice.payment_action_required`\r\n\r\n\n\n为方便起见，Cashier 包含一个 `cashier:webhook` Artisan 命令。 此命令将在 Stripe 中创建一个 webhook，用于监听 Cashier 所需的所有事件：\r\n\r\n```shell\r\nphp artisan cashier:webhook\r\n```\r\n\r\n默认情况下，创建的 webhook 将指向由 `APP_URL` 环境变量和 Cashier 包含的 `cashier.webhook` 路由定义的 URL。 如果您想使用不同的 URL，可以在调用命令时提供 `--url` 选项：\r\n\r\n```shell\r\nphp artisan cashier:webhook --url \"https://example.com/stripe/webhook\"\r\n```\r\n\r\n创建的 webhook 将使用与您的 Cashier 版本兼容的 Stripe API 版本。 如果你想使用不同的 Stripe 版本，你可以提供 `--api-version` 选项：\r\n\r\n```shell\r\nphp artisan cashier:webhook --api-version=\"2019-12-03\"\r\n```\r\n\r\n创建后，webhook 将立即激活。 如果您希望创建 webhook 但在准备好之前将其禁用，您可以在调用命令时提供 `--disabled` 选项：\r\n\r\n```shell\r\nphp artisan cashier:webhook --disabled\r\n```\r\n\r\n> 注意：确保使用 Cashier 包含的 [webhook 签名验证](#verifying-webhook-signatures) 中间件保护传入的 Stripe webhook 请求。\r\n\r\n<a name=\"webhooks-csrf-protection\"></a>\r\n#### Webhook 和 CSRF 保护\r\n\r\n由于 Stripe webhook 需要绕过 Laravel 的 [CSRF 保护](/docs/laravel/9.x/csrf)，因此请务必在应用程序的 `App\\Http\\Middleware\\VerifyCsrfToken` 中间件中将 URI 列为异常或列出路由在 `web` 中间件组之外：\r\n\r\n    protected $except = [\r\n        'stripe/*',\r\n    ];\r\n\r\n<a name=\"defining-webhook-event-handlers\"></a>\r\n### 定义 webhook 事件处理程序\r\n\r\nCashier 自动处理因收费失败和其他常见的 Stripe webhook 事件而取消的订阅。 但是，如果您有其他想要处理的 webhook 事件，您可以通过收听 Cashier 调度的以下事件来实现：\r\n\r\n- `Laravel\\Cashier\\Events\\WebhookReceived`\r\n- `Laravel\\Cashier\\Events\\WebhookHandled`\r\n\r\n\n\n这两个事件都包含 Stripe webhook 的完整负载。 例如，如果你想处理 `invoice.payment_succeeded` webhook，你可以注册一个 [listener](/docs/laravel/9.x/events#defining-listeners) 来处理事件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Laravel\\Cashier\\Events\\WebhookReceived;\r\n\r\n    class StripeEventListener\r\n    {\r\n        /**\r\n         * 处理收到的 Stripe webhook。\r\n         *\r\n         * @param  \\Laravel\\Cashier\\Events\\WebhookReceived  $event\r\n         * @return void\r\n         */\r\n        public function handle(WebhookReceived $event)\r\n        {\r\n            if ($event->payload['type'] === 'invoice.payment_succeeded') {\r\n                // 处理传入事件...\r\n            }\r\n        }\r\n    }\r\n\r\n一旦你的监听器被定义，你可以在你的应用程序的`EventServiceProvider`中注册它：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Listeners\\StripeEventListener;\r\n    use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\n    use Laravel\\Cashier\\Events\\WebhookReceived;\r\n\r\n    class EventServiceProvider extends ServiceProvider\r\n    {\r\n        protected $listen = [\r\n            WebhookReceived::class => [\r\n                StripeEventListener::class,\r\n            ],\r\n        ];\r\n    }\r\n\r\n<a name=\"verifying-webhook-signatures\"></a>\r\n### 验证 Webhook 签名\r\n\r\n为了保护您的 webhook，您可以使用 [Stripe 的 webhook 签名](https://stripe.com/docs/webhooks/signatures)。 为方便起见，Cashier 自动包含一个中间件，用于验证传入的 Stripe webhook 请求是否有效。\r\n\r\n要启用 webhook 验证，请确保在应用程序的 .env 文件中设置了 `STRIPE_WEBHOOK_SECRET` 环境变量。 可以从您的 Stripe 帐户仪表板中检索 webhook `secret`。\r\n\r\n<a name=\"single-charges\"></a>\r\n## 单次 Charges\r\n\r\n<a name=\"simple-charge\"></a>\r\n### 简单 Charge\r\n\r\n> 注意：`charge` 方法接受您希望以应用程序使用的货币的最低分母收取的金额。例如，使用美元时，金额应以便士表示。\r\n\r\n如果您想向客户一次性收费，您可以在可计费模型实例上使用 `charge` 方法。您需要[提供付款方式标识符]（#单笔费用的付款方式）作为 `charge` 方法的第二个参数：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/purchase', function (Request $request) {\r\n        $stripeCharge = $request->user()->charge(\r\n            100, $request->paymentMethodId\r\n        );\r\n\r\n        // ...\r\n    });\r\n\r\n\n\n`charge` 方法接受一个数组作为它的第三个参数，允许您将任何您希望的选项传递给底层的 Stripe 电荷创建。 有关创建费用时可用选项的更多信息，请参阅 [Stripe 文档](https://stripe.com/docs/api/charges/create)：\r\n\r\n    $user->charge(100, $paymentMethod, [\r\n        'custom_option' => $value,\r\n    ]);\r\n\r\n您也可以在没有潜在客户或用户的情况下使用“收费”方法。 为此，请在应用程序的计费模型的新实例上调用 `charge` 方法：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $stripeCharge = (new User)->charge(100, $paymentMethod);\r\n\r\n如果充电失败，`charge` 方法会抛出异常。 如果收费成功，方法会返回一个 `Laravel\\Cashier\\Payment` 的实例：\r\n\r\n    try {\r\n        $payment = $user->charge(100, $paymentMethod);\r\n    } catch (Exception $e) {\r\n        //\r\n    }\r\n\r\n<a name=\"charge-with-invoice\"></a>\r\n### 用发票收费\r\n\r\n有时您可能需要一次性收费并向客户提供 PDF 收据。 `invoicePrice` 方法可以让你做到这一点。 例如，让我们为客户开具五件新衬衫的发票：\r\n\r\n    $user->invoicePrice('price_tshirt', 5);\r\n\r\n发票将立即根据用户的默认付款方式收取。 `invoicePrice` 方法也接受一个数组作为它的第三个参数。 此数组包含发票项目的计费选项。 该方法接受的第四个参数也是一个数组，其中应包含发票本身的计费选项：\r\n\r\n    $user->invoicePrice('price_tshirt', 5, [\r\n        'discounts' => [\r\n            ['coupon' => 'SUMMER21SALE']\r\n        ],\r\n    ], [\r\n        'default_tax_rates' => ['txr_id'],\r\n    ]);\r\n\r\n或者，您可以使用 `invoiceFor` 方法对客户的默认付款方式进行“一次性”收费：\r\n\r\n    $user->invoiceFor('One Time Fee', 500);\r\n\r\n\n\n虽然 `invoiceFor` 方法可供您使用，但建议您使用具有预定义价格的 `invoicePrice` 方法。 通过这样做，您将可以在您的 Stripe 仪表板中访问更好的分析和数据，以了解您在每个产品的基础上的销售情况。\r\n\r\n> 注意：`invoicePrice` 和 `invoiceFor` 方法将创建一个 Stripe 发票，该发票将重试失败的计费尝试。 如果您不希望发票重试失败的费用，则需要在第一次失败的费用后使用 Stripe API 关闭它们。\r\n\r\n<a name=\"refunding-charges\"></a>\r\n### 退款费用\r\n\r\n如果您需要退还 Stripe 费用，您可以使用 `refund` 方法。 此方法接受 Stripe [payment intent ID](#payment-methods-for-single-charges) 作为其第一个参数：\r\n\r\n    $payment = $user->charge(100, $paymentMethodId);\r\n\r\n    $user->refund($payment->id);\r\n\r\n<a name=\"invoices\"></a>\r\n## 发票\r\n\r\n<a name=\"retrieving-invoices\"></a>\r\n### 检索发票\r\n\r\n您可以使用 `invoices` 方法轻松检索可计费模型的发票数组。 `invoices` 方法返回 `Laravel\\Cashier\\Invoice` 实例的集合：\r\n\r\n    $invoices = $user->invoices();\r\n\r\n如果您想在结果中包含待处理的发票，您可以使用 `invoicesIncludingPending` 方法：\r\n\r\n    $invoices = $user->invoicesIncludingPending();\r\n\r\n您可以使用 `findInvoice` 方法通过其 ID 检索特定发票：\r\n\r\n    $invoice = $user->findInvoice($invoiceId);\r\n\r\n<a name=\"displaying-invoice-information\"></a>\r\n#### 显示发票信息\r\n\r\n在为客户列出发票时，您可以使用发票的方法显示相关的发票信息。 例如，您可能希望在表格中列出每张发票，以便用户轻松下载其中任何一张：\r\n\r\n    <table>\r\n        @foreach ($invoices as $invoice)\r\n            <tr>\r\n                <td>{{ $invoice->date()->toFormattedDateString() }}</td>\r\n                <td>{{ $invoice->total() }}</td>\r\n                <td><a href=\"/user/invoice/{{ $invoice->id }}\">Download</a></td>\r\n            </tr>\r\n        @endforeach\r\n    </table>\r\n\r\n\n\n<a name=\"upcoming-invoices\"></a>\r\n### 进货发票\r\n\r\n要检索客户即将收到的发票，您可以使用 `upcomingInvoice` 方法：\r\n\r\n    $invoice = $user->upcomingInvoice();\r\n\r\n类似地，如果客户有多个订阅，您还可以检索特定订阅的即将到来的发票：\r\n\r\n    $invoice = $user->subscription('default')->upcomingInvoice();\r\n\r\n<a name=\"previewing-subscription-invoices\"></a>\r\n### 预览订阅发票\r\n\r\n使用 `previewInvoice` 方法，您可以在更改价格之前预览发票。 这将允许您确定在进行给定价格更改时客户发票的外观：\r\n\r\n    $invoice = $user->subscription('default')->previewInvoice('price_yearly');\r\n\r\n您可以将一组价格传递给 `previewInvoice` 方法，以便预览具有多个新价格的发票：\r\n    $invoice = $user->subscription('default')->previewInvoice(['price_yearly', 'price_metered']);\r\n\r\n<a name=\"generating-invoice-pdfs\"></a>\r\n### 生成发票 PDF\r\n\r\n在路由或控制器中，您可以使用 `downloadInvoice` 方法生成给定发票的 PDF 下载。 此方法将自动生成下载发票所需的正确 HTTP 响应：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/invoice/{invoice}', function (Request $request, $invoiceId) {\r\n        return $request->user()->downloadInvoice($invoiceId, [\r\n            'vendor' => 'Your Company',\r\n            'product' => 'Your Product',\r\n        ]);\r\n    });\r\n\r\n默认情况下，发票上的所有数据都来自存储在 Stripe 中的客户和发票数据。 但是，您可以通过提供一个数组作为 `downloadInvoice` 方法的第二个参数来自定义其中的一些数据。 此数组允许您自定义信息，例如您的公司和产品详细信息：\r\n\r\n    return $request->user()->downloadInvoice($invoiceId, [\r\n        'vendor' => 'Your Company',\r\n        'product' => 'Your Product',\r\n        'street' => 'Main Str. 1',\r\n        'location' => '2000 Antwerp, Belgium',\r\n        'phone' => '+32 499 00 00 00',\r\n        'email' => 'info@example.com',\r\n        'url' => 'https://example.com',\r\n        'vendorVat' => 'BE123456789',\r\n    ], 'my-invoice');\r\n\r\n\n\n`downloadInvoice` 方法还允许通过其第三个参数自定义文件名。 此文件名将自动以 `.pdf` 为后缀：\r\n\r\n    return $request->user()->downloadInvoice($invoiceId, [], 'my-invoice');\r\n\r\n<a name=\"custom-invoice-render\"></a>\r\n#### 自定义发票渲染器\r\n\r\nCashier 还可以使用自定义发票渲染器。 默认情况下，Cashier 使用 `DompdfInvoiceRenderer` 实现，它利用 [dompdf](https://github.com/dompdf/dompdf) PHP 库来生成 Cashier 的发票。 但是，你可以通过实现 `Laravel\\Cashier\\Contracts\\InvoiceRenderer` 接口来使用任何你想要的渲染器。 例如，您可能希望使用对第三方 PDF 呈现服务的 API 调用来呈现发票 PDF：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n    use Laravel\\Cashier\\Contracts\\InvoiceRenderer;\r\n    use Laravel\\Cashier\\Invoice;\r\n\r\n    class ApiInvoiceRenderer implements InvoiceRenderer\r\n    {\r\n        /**\r\n         * 呈现给定的发票并返回原始 PDF 字节。\r\n         *\r\n         * @param  \\Laravel\\Cashier\\Invoice. $invoice\r\n         * @param  array  $data\r\n         * @param  array  $options\r\n         * @return string\r\n         */\r\n        public function render(Invoice $invoice, array $data = [], array $options = []): string\r\n        {\r\n            $html = $invoice->view($data)->render();\r\n\r\n            return Http::get('https://example.com/html-to-pdf', ['html' => $html])->get()->body();\r\n        }\r\n    }\r\n\r\n一旦你实现了发票渲染器合约，你应该在你的应用程序的 config/cashier.php 配置文件中更新 `cashier.invoices.renderer` 配置值。 此配置值应设置为自定义渲染器实现的类名。\r\n\r\n<a name=\"checkout\"></a>\r\n## 结账\r\n\r\nCashier Stripe 还提供对 [Stripe Checkout](https://stripe.com/payments/checkout) 的支持。 Stripe Checkout 通过提供预构建的托管支付页面，消除了实施自定义页面以接受付款的痛苦。\r\n\r\n\n\n以下文档包含有关如何开始使用 Stripe Checkout with Cashier 的信息。 要了解有关 Stripe Checkout 的更多信息，您还应该考虑查看 [Stripe 自己的 Checkout 文档](https://stripe.com/docs/payments/checkout)。\r\n\r\n<a name=\"product-checkouts\"></a>\r\n### 产品结账\r\n\r\n您可以在计费模型上使用“checkout”方法对已在 Stripe 仪表板中创建的现有产品执行结帐。 `checkout` 方法将启动一个新的 Stripe Checkout 会话。 默认情况下，您需要传递 Stripe Price ID：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()->checkout('price_tshirt');\r\n    });\r\n\r\n如果需要，您还可以指定产品数量：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()->checkout(['price_tshirt' => 15]);\r\n    });\r\n\r\n当客户访问此路线时，他们将被重定向到 Stripe 的结帐页面。 默认情况下，当用户成功完成或取消购买时，他们将被重定向到您的 `home` 路由位置，但您可以使用 `success_url` 和 `cancel_url` 选项指定自定义回调 URL：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()->checkout(['price_tshirt' => 1], [\r\n            'success_url' => route('your-success-route'),\r\n            'cancel_url' => route('your-cancel-route'),\r\n        ]);\r\n    });\r\n\r\n在定义 `success_url` 结帐选项时，您可以指示 Stripe 在调用 URL 时将结帐会话 ID 添加为查询字符串参数。 为此，请将文字字符串 `{CHECKOUT_SESSION_ID}` 添加到您的 `success_url` 查询字符串。Stripe 将用实际的结帐会话 ID 替换此占位符：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Stripe\\Checkout\\Session;\r\n    use Stripe\\Customer;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()->checkout(['price_tshirt' => 1], [\r\n            'success_url' => route('checkout-success') . '?session_id={CHECKOUT_SESSION_ID}',\r\n            'cancel_url' => route('checkout-cancel'),\r\n        ]);\r\n    });\r\n\r\n    Route::get('/checkout-success', function (Request $request) {\r\n        $checkoutSession = $request->user()->stripe()->checkout->sessions->retrieve($request->get('session_id'));\r\n\r\n        return view('checkout.success', ['checkoutSession' => $checkoutSession]);\r\n    })->name('checkout-success');\r\n\r\n\n\n<a name=\"checkout-promotion-codes\"></a>\r\n#### 兑换码\r\n\r\n默认情况下，Stripe Checkout 不允许 [用户可兑换促销代码](https://stripe.com/docs/billing/subscriptions/discounts/codes)。 幸运的是，有一种简单的方法可以为您的结帐页面启用这些功能。 为此，您可以调用 `allowPromotionCodes` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()\r\n            ->allowPromotionCodes()\r\n            ->checkout('price_tshirt');\r\n    });\r\n\r\n<a name=\"single-charge-checkouts\"></a>\r\n### 单次收费结账\r\n\r\n您还可以对尚未在 Stripe 仪表板中创建的临时产品进行简单收费。 为此，您可以在计费模型上使用 `checkoutCharge` 方法，并向其传递可计费金额、产品名称和可选数量。 当客户访问此路线时，他们将被重定向到 Stripe 的结帐页面：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/charge-checkout', function (Request $request) {\r\n        return $request->user()->checkoutCharge(1200, 'T-Shirt', 5);\r\n    });\r\n\r\n> 注意：当使用 `checkoutCharge` 方法时，Stripe 将始终在您的 Stripe 仪表板中创建新产品和价格。 因此，我们建议您在 Stripe 仪表板中预先创建产品，并改用 `checkout` 方法。\r\n\r\n<a name=\"subscription-checkouts\"></a>\r\n### 订阅结帐\r\n\r\n> 注意：使用 Stripe Checkout 进行订阅需要您在 Stripe 仪表板中启用 `customer.subscription.created` webhook。 此 webhook 将在您的数据库中创建订阅记录并存储所有相关的订阅项。\r\n\r\n您也可以使用 Stripe Checkout 来启动订阅。 在使用 Cashier 的订阅构建器方法定义您的订阅后，您可以调用 `checkout ` 方法。 当客户访问此路线时，他们将被重定向到 Stripe 的结帐页面：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/subscription-checkout', function (Request $request) {\r\n        return $request->user()\r\n            ->newSubscription('default', 'price_monthly')\r\n            ->checkout();\r\n    });\r\n\r\n\n\n与产品结帐一样，您可以自定义成功和取消 URL：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/subscription-checkout', function (Request $request) {\r\n        return $request->user()\r\n            ->newSubscription('default', 'price_monthly')\r\n            ->checkout([\r\n                'success_url' => route('your-success-route'),\r\n                'cancel_url' => route('your-cancel-route'),\r\n            ]);\r\n    });\r\n\r\n当然，您也可以为订阅结帐启用促销代码：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/subscription-checkout', function (Request $request) {\r\n        return $request->user()\r\n            ->newSubscription('default', 'price_monthly')\r\n            ->allowPromotionCodes()\r\n            ->checkout();\r\n    });\r\n\r\n> 注意：不幸的是，在开始订阅时，Stripe Checkout 不支持所有订阅计费选项。 在订阅生成器上使用 `anchorBillingCycleOn` 方法、设置按比例分配行为或设置支付行为在 Stripe Checkout 会话期间不会有任何影响。 请查阅 [Stripe Checkout Session API 文档](https://stripe.com/docs/api/checkout/sessions/create) 以查看可用的参数。\r\n\r\n<a name=\"stripe-checkout-trial-periods\"></a>\r\n#### 条纹结帐和试用期\r\n\r\n当然，您可以在构建将使用 Stripe Checkout 完成的订阅时定义试用期：\r\n\r\n    $checkout = Auth::user()->newSubscription('default', 'price_monthly')\r\n        ->trialDays(3)\r\n        ->checkout();\r\n\r\n但是，试用期必须至少为 48 小时，这是 Stripe Checkout 支持的最短试用时间。\r\n\r\n<a name=\"stripe-checkout-subscriptions-and-webhooks\"></a>\r\n#### Subscriptions & Webhooks\r\n\r\n请记住，Stripe 和 Cashier 通过 webhook 更新订阅状态，因此当客户在输入付款信息后返回应用程序时，订阅可能尚未激活。 要处理这种情况，您可能希望显示一条消息，通知用户他们的付款或订阅处于待处理状态。\r\n\r\n\n\n<a name=\"collecting-tax-ids\"></a>\r\n### 收税ID\r\n\r\nCheckout 还支持收集客户的税号。 要在结帐会话上启用此功能，请在创建会话时调用 `collectTaxIds` 方法：\r\n\r\n    $checkout = $user->collectTaxIds()->checkout('price_tshirt');\r\n\r\n调用此方法时，客户可以使用一个新的复选框，允许他们指示他们是否作为公司进行采购。 如果是这样，他们将有机会提供他们的税号。\r\n\r\n> 注意：如果您已经在应用程序的服务提供者中配置了[自动征税](#tax-configuration)，那么该功能将自动启用，无需调用 `collectTaxIds` 方法。\r\n\r\n<a name=\"handling-failed-payments\"></a>\r\n## 处理失败的付款\r\n\r\n有时，订阅或单笔费用的付款可能会失败。 当这种情况发生时，Cashier 会抛出一个 `Laravel\\Cashier\\Exceptions\\IncompletePayment` 异常，通知你发生了这种情况。 捕获此异常后，您有两个选择如何继续。\r\n\r\n首先，您可以将您的客户重定向到 Cashier 附带的专用付款确认页面。 该页面已经有一个通过 Cashier 的服务提供商注册的关联命名路由。 因此，您可能会捕获 `IncompletePayment` 异常并将用户重定向到付款确认页面：\r\n\r\n    use Laravel\\Cashier\\Exceptions\\IncompletePayment;\r\n\r\n    try {\r\n        $subscription = $user->newSubscription('default', 'price_monthly')\r\n                                ->create($paymentMethod);\r\n    } catch (IncompletePayment $exception) {\r\n        return redirect()->route(\r\n            'cashier.payment',\r\n            [$exception->payment->id, 'redirect' => route('home')]\r\n        );\r\n    }\r\n\r\n在付款确认页面上，将提示客户再次输入他们的信用卡信息并执行 Stripe 要求的任何其他操作，例如“3D Secure”确认。 确认付款后，用户将被重定向到上面指定的 `redirect` 参数提供的 URL。 重定向后，“message”（字符串）和“success”（整数）查询字符串变量将被添加到 URL。 支付页面目前支持以下支付方式类型：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- Credit Cards\r\n- Alipay\r\n- Bancontact\r\n- BECS Direct Debit\r\n- EPS\r\n- Giropay\r\n- iDEAL\r\n- SEPA Direct Debit\r\n\r\n</div>\r\n\r\n\n\n或者，您可以让 Stripe 为您处理付款确认。在这种情况下，您可以在 Stripe 控制面板中[设置 Stripe 的自动结算电子邮件](https://dashboard.stripe.com/account/billing/automatic)，而不是重定向到付款确认页面。但是，如果捕获到 `IncompletePayment` 异常，您仍应通知用户他们将收到一封包含进一步付款确认说明的电子邮件。\r\n\r\n对于使用 `Billable` 特征的模型，可能会为以下方法引发付款异常：`charge`、`invoiceFor` 和 `invoice`。与订阅交互时，`SubscriptionBuilder` 上的 `create` 方法，以及 `Subscription` 和 `SubscriptionItem` 模型上的 `incrementAndInvoice` 和 `swapAndInvoice` 方法可能会抛出不完整的支付异常。\r\n\r\n可以使用计费模型或订阅实例上的“hasIncompletePayment”方法来确定现有订阅是否有不完整的付款：\r\n\r\n    if ($user->hasIncompletePayment('default')) {\r\n        //\r\n    }\r\n\r\n    if ($user->subscription('default')->hasIncompletePayment()) {\r\n        //\r\n    }\r\n\r\n您可以通过检查异常实例上的 `payment` 属性来得出未完成付款的具体状态：\r\n\r\n    use Laravel\\Cashier\\Exceptions\\IncompletePayment;\r\n\r\n    try {\r\n        $user->charge(1000, 'pm_card_threeDSecure2Required');\r\n    } catch (IncompletePayment $exception) {\r\n        // 获取付款意向状态...\r\n        $exception->payment->status;\r\n\r\n        // 检查具体情况...\r\n        if ($exception->payment->requiresPaymentMethod()) {\r\n            // ...\r\n        } elseif ($exception->payment->requiresConfirmation()) {\r\n            // ...\r\n        }\r\n    }\r\n\r\n<a name=\"strong-customer-authentication\"></a>\r\n## 强大的客户认证\r\n\r\n如果您的企业或您的一位客户位于欧洲，您将需要遵守欧盟的强客户认证 (SCA) 法规。 这些规定由欧盟于 2019 年 9 月实施，以防止支付欺诈。 幸运的是，Stripe 和 Cashier 已准备好构建符合 SCA 的应用程序。\r\n\r\n> 注意：在开始之前，请查看 [关于 PSD2 和 SCA 的 Stripe 指南](https://stripe.com/guides/strong-customer-authentication) 以及他们的 [关于新 SCA API 的文档](https://stripe.com /docs/strong-customer-authentication）。\r\n\r\n\n\n<a name=\"payments-requiring-additional-confirmation\"></a>\r\n### 需要额外确认的付款\r\n\r\nSCA 法规通常需要额外的验证才能确认和处理付款。 当这种情况发生时，Cashier 会抛出一个 `Laravel\\Cashier\\Exceptions\\IncompletePayment` 异常，通知你需要额外的验证。 有关如何处理这些异常的更多信息，请参阅有关 [处理失败的付款](#handling-failed-payments) 的文档。\r\n\r\nStripe 或 Cashier 提供的支付确认屏幕可能会针对特定银行或发卡机构的支付流程进行定制，并且可能包括额外的卡确认、临时小额费用、单独的设备身份验证或其他形式的验证。\r\n\r\n<a name=\"incomplete-and-past-due-state\"></a>\r\n#### 不完整和逾期状态\r\n\r\n当付款需要额外确认时，订阅将保持在“未完成”或“过去到期”状态，如“stripe_status”数据库列所示。 付款确认完成后，Cashier 将自动激活客户的订阅，并且 Stripe 通过 webhook 通知您的应用程序完成。\r\n\r\n有关 `incomplete` 和 `past_due` 状态的更多信息，请参阅 [我们关于这些状态的附加文档](#incomplete-and-past-due-status)。\r\n\r\n<a name=\"off-session-payment-notifications\"></a>\r\n### 场外付款通知\r\n\r\n由于 SCA 法规要求客户即使在订阅处于活动状态时也偶尔验证其付款详细信息，因此当需要确认会话外付款时，Cashier 可以向客户发送通知。 例如，这可能在续订订阅时发生。 可以通过将 `CASHIER_PAYMENT_NOTIFICATION` 环境变量设置为通知类来启用收银员的付款通知。 默认情况下，此通知被禁用。 当然，Cashier 包含一个您可以用于此目的的通知类，但如果需要，您可以自由地提供自己的通知类：\r\n\r\n```ini\r\nCASHIER_PAYMENT_NOTIFICATION=Laravel\\Cashier\\Notifications\\ConfirmPayment\r\n```\r\n\r\n\n\n为确保发送会话外付款确认通知，请确认您的应用程序的 [Stripe webhook 已配置](#handling-stripe-webhooks) 并且在您的 Stripe 仪表板中启用了 `invoice.payment_action_required` webhook。 此外，你的 `Billable` 模型也应该使用 Laravel 的 `Illuminate\\Notifications\\Notifiable` trait。\r\n\r\n> 注意：即使客户手动进行需要额外确认的付款，也会发送通知。 不幸的是，Stripe 无法知道付款是手动完成的还是“非会话”完成的。 但是，如果客户在确认付款后访问付款页面，他们只会看到“付款成功”消息。 不允许客户意外确认两次相同的付款并导致意外的第二次收费。\r\n\r\n<a name=\"stripe-sdk\"></a>\r\n## Stripe SDK\r\n\r\nCashier 的许多对象都是 Stripe SDK 对象的包装器。 如果您想直接与 Stripe 对象交互，您可以使用 `asStripe` 方法方便地检索它们：\r\n\r\n    $stripeSubscription = $subscription->asStripeSubscription();\r\n\r\n    $stripeSubscription->application_fee_percent = 5;\r\n\r\n    $stripeSubscription->save();\r\n\r\n您也可以使用 `updateStripeSubscription` 方法直接更新 Stripe 订阅：\r\n\r\n    $subscription->updateStripeSubscription(['application_fee_percent' => 5]);\r\n\r\n如果您想直接使用 `Stripe\\StripeClient` 客户端，可以调用 `Cashier` 类的 `stripe` 方法。 例如，您可以使用此方法访问“StripeClient”实例并从您的 Stripe 帐户中检索价格列表：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    $prices = Cashier::stripe()->prices->all();\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n在测试使用 Cashier 的应用程序时，您可以模拟对 Stripe API 的实际 HTTP 请求； 但是，这需要您部分地重新实现 Cashier 自己的行为。 因此，我们建议允许您的测试使用实际的 Stripe API。 虽然速度较慢，但是它可以让您更加确信您的应用程序正在按预期工作，并且任何慢速测试都可以放在他们自己的 PHPUnit 测试组中。\r\n\r\n\n\n测试时，请记住 Cashier 本身已经有一个很棒的测试套件，因此您应该只专注于测试您自己的应用程序的订阅和支付流程，而不是每个底层的 Cashier 行为。\r\n\r\n首先，将 Stripe 密钥的 **testing** 版本添加到您的 `phpunit.xml` 文件中：\r\n\r\n    <env name=\"STRIPE_SECRET\" value=\"sk_test_<your-key>\"/>\r\n\r\n现在，每当您在测试时与 Cashier 交互时，它都会向您的 Stripe 测试环境发送实际的 API 请求。为方便起见，您应该使用您可能在测试期间使用的订阅 / 计划预先填写您的 Stripe 测试帐户。\r\n\r\n> 技巧：为了测试各种计费场景，例如信用卡拒付和失败，您可以使用 Stripe 提供的大量的 [测试卡号和令牌](https://stripe.com/docs/testing) 。\r\n\n","p":"docs/billing.html"},{"t":"cashier-paddle (Laravel 交易工具包 (Paddle))","d":"\n# Laravel 交易工具包 (Paddle)\r\n\r\n- [简介](#introduction)\r\n- [升级 Cashier](#upgrading-cashier)\r\n- [安装](#installation)\r\n    - [Paddle 沙盒](#paddle-sandbox)\r\n    - [数据迁移](#database-migrations)\r\n- [配置](#configuration)\r\n    - [Billable 模型](#billable-model)\r\n    - [API Keys](#api-keys)\r\n    - [Paddle JS](#paddle-js)\r\n    - [货币配置](#currency-configuration)\r\n    - [扩展默认模型](#overriding-default-models)\r\n- [核心概念](#core-concepts)\r\n    - [支付链接](#pay-links)\r\n    - [內联结账](#inline-checkout)\r\n    - [用户鉴定](#user-identification)\r\n- [价格](#prices)\r\n- [用户](#customers)\r\n    - [用户默认设置](#customer-defaults)\r\n- [订阅](#subscriptions)\r\n    - [创建订阅](#creating-subscriptions)\r\n    - [检查订阅状态](#checking-subscription-status)\r\n    - [订阅一次性收费](#subscription-single-charges)\r\n    - [更新交易信息](#updating-payment-information)\r\n    - [更新计划](#changing-plans)\r\n    - [订阅量](#subscription-quantity)\r\n    - [更新订阅](#subscription-modifiers)\r\n    - [暂停订阅](#pausing-subscriptions)\r\n    - [取消订阅](#cancelling-subscriptions)\r\n- [订阅试用](#subscription-trials)\r\n    - [预付款方式](#with-payment-method-up-front)\r\n    - [非预付款方式](#without-payment-method-up-front)\r\n- [处理 Paddle Webhooks](#handling-paddle-webhooks)\r\n    - [定义 Webhook 事件处理程序](#defining-webhook-event-handlers)\r\n    - [校验 Webhook 签名](#verifying-webhook-signatures)\r\n- [一次性收费](#single-charges)\r\n    - [简单收费](#simple-charge)\r\n    - [收费产品](#charging-products)\r\n    - [退款订单](#refunding-orders)\r\n- [收据](#receipts)\r\n    - [过去与将来的交易](#past-and-upcoming-payments)\r\n- [处理失败交易](#handling-failed-payments)\r\n- [测试](#testing)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Cashier Paddle](https://github.com/laravel/cashier-paddle) 为 [Paddle's](https://paddle.com) 订阅计费服务提供了一个富有表现力、流畅的界面。它几乎能够处理所有你所恐惧的各种订阅计费逻辑和代码。除了基本的订阅管理，Cashier 还可以处理：优惠券、交换订阅、订阅「数量」、取消宽限期等。\r\n\r\n在使用 Cashier 时，推荐你回顾一下 Paddle 的[用户手册](https://developer.paddle.com/guides) and [API 文档](https://developer.paddle.com/api-reference/intro).\r\n\n\n<a name=\"upgrading-cashier\"></a>\r\n## 升级 Cashier\r\n\r\n在升级到一个新版本的 Cashier 时，仔细回顾 [升级指南](https://github.com/laravel/cashier-paddle/blob/master/UPGRADE.md) 将非常重要。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，使用 Composer 包管理器安装 Paddle 的 Cashier 包：\r\n\r\n```shell\r\ncomposer require laravel/cashier-paddle\r\n```\r\n\r\n> 注意：为了确保 Cashier 正确处理所有 Paddle 事件，请记得 [配置 Cashier 的 webhook 处理](#handling-paddle-webhooks)。\r\n\r\n<a name=\"paddle-sandbox\"></a>\r\n### Paddle 沙盒\r\n\r\n在本地和预发布开发中，你应该 [注册一个 Paddle 沙盒账号](https://developer.paddle.com/getting-started/sandbox)。这个账号将为你提供一个沙盒环境来测试和开发你的应用，而不会产生真实的交易。你也许会使用 Paddle 的 [测试卡号](https://developer.paddle.com/getting-started/sandbox#test-cards) 来模拟各种交易场景。\r\n\r\n在使用Pable沙盒环境时，你应在应用程序的 `.env` 环境文件中将 `PADDLE_SANDBOX` 环境变量设置为 `true` ：\r\n\r\n```ini\r\nPADDLE_SANDBOX=true\r\n```\r\n\r\n在你已经完成你的应用开发之后，你也许会 [申请一个 Paddle 正式账号](https://paddle.com) 。 在您的应用程序投入生产之前，Paddle 需要批准您的应用程序的域。\r\n\r\n<a name=\"database-migrations\"></a>\r\n### 数据迁移\r\n\r\nCashier 服务提供者注册它自己的数据迁移目录，所以你记得在安装扩展包之后执行数据迁移。 Cashier 数据迁移将生成新的  `customers` 表。另外，新的 `subscriptions` 表将被创建，来存储所有你的用户的订阅。最后，新的 `receipts` 表也将被创建，来存储所有你的收据信息:\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n\n\n如果你需要重写 Cashier 中的数据迁移，你可以使用  `vendor:publish` Artisan 命令来发布它们：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=\"cashier-migrations\"\r\n```\r\n\r\n如果你想阻止 Cashier 的数据迁移全部执行，你可以使用 Cashier 提供的 `ignoreMigrations`。通常，这个方法会在 `AppServiceProvider` 的 `register` 方法中被调用：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    /**\r\n     * 注册服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        Cashier::ignoreMigrations();\r\n    }\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"billable-model\"></a>\r\n### Billable 模型\r\n\r\n在使用 Cashier 之前，你必须将 `Billable` trait 添加到你的用户模型定义中。 此 trait 提供了多种方法来允许你执行常见的计费任务，例如创建订阅、应用优惠券和更新付款方式信息：\r\n\r\n    use Laravel\\Paddle\\Billable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Billable;\r\n    }\r\n\r\n如果你有非用户的计费实体，你还可以将特征添加到这些类中：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Paddle\\Billable;\r\n\r\n    class Team extends Model\r\n    {\r\n        use Billable;\r\n    }\r\n\r\n<a name=\"api-keys\"></a>\r\n### API Keys\r\n\r\n接下来，你应该在应用程序的 `.env` 文件中配置你的 Paddle 。 你可以从 Paddle 控制面板检索你的 Paddle API 密钥：\r\n\r\n```ini\r\nPADDLE_VENDOR_ID=your-paddle-vendor-id\r\nPADDLE_VENDOR_AUTH_CODE=your-paddle-vendor-auth-code\r\nPADDLE_PUBLIC_KEY=\"your-paddle-public-key\"\r\nPADDLE_SANDBOX=true\r\n```\r\n\r\n当你使用 [Paddle 的沙箱环境](#paddle-sandbox) 时，`PADDLE_SANDBOX` 环境变量应该设置为 `true`。 如果你将应用程序部署到生产环境并使用 Paddle 的实时供应商环境，则 `PADDLE_SANDBOX` 变量应该设置为 `false`。\r\n\r\n\n\n<a name=\"paddle-js\"></a>\r\n### Paddle JS\r\n\r\nPaddle 依赖其自己的 JavaScript 库来启动 Paddle 结账小部件。 您可以通过在应用程序布局中的 `</head>` 标签关闭之前放置 `@paddleJS` Blade 指令来加载 JavaScript 库：\r\n\r\n```blade\r\n<head>\r\n    ...\r\n\r\n    @paddleJS\r\n</head>\r\n```\r\n\r\n<a name=\"currency-configuration\"></a>\r\n### 货币配置\r\n\r\n默认 Cashier 货币是美元（USD）。您可以在 `.env` 文件中定义 `CASHIER_CURRENCY` 环境变量来更改默认货币：\r\n\r\n```ini\r\nCASHIER_CURRENCY=EUR\r\n```\r\n\r\n除了配置 Cashier 的货币之外，您还可以指定在格式化货币值以显示在发票上时要使用的区域。Cashier 内部利用 PHP 的 [ NumberFormatter ](https://www.php.net/manual/en/class.numberformatter.php) 类来设置货币区域：\r\n\r\n```ini\r\nCASHIER_CURRENCY_LOCALE=nl_BE\r\n```\r\n\r\n> 注意：为了使用 `en` 以外的语言环境，请确保在您的服务器上安装并配置了 `ext-intl` PHP 扩展。\r\n\r\n<a name=\"overriding-default-models\"></a>\r\n### 覆盖默认模型\r\n\r\n您可以通过定义自己的模型并继承相应的 Cashier 模型来自由扩展 Cashier 模型：\r\n\r\n    use Laravel\\Paddle\\Subscription as CashierSubscription;\r\n\r\n    class Subscription extends CashierSubscription\r\n    {\r\n        // ...\r\n    }\r\n\r\n定义模型后，您可以通过 `Laravel\\Paddle\\Cashier` 类指示 Cashier 使用您的自定义模型。通常，您应该在应用的 `App\\Providers\\AppServiceProvider` 类的 `boot` 方法中通知 Cashier 关于你的自定义模型：\r\n\r\n    use App\\Models\\Cashier\\Receipt;\r\n    use App\\Models\\Cashier\\Subscription;\r\n\r\n    /**\r\n     * 引导应用服务.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Cashier::useReceiptModel(Receipt::class);\r\n        Cashier::useSubscriptionModel(Subscription::class);\r\n    }\r\n\r\n\n\n<a name=\"core-concepts\"></a>\r\n## 核心概念\r\n\r\n<a name=\"pay-links\"></a>\r\n### 支付链接\r\n\r\nPaddle 缺乏广泛的 CRUD API 来执行订阅状态更改。 因此，与 Paddle 的大多数交互都是通过其 [结帐小部件](https://developer.paddle.com/guides/how-tos/checkout/paddle-checkout) 完成的。 在使用结账小部件之前，我们必须使用 Cashier 生成一个 「支付链接」。 「支付链接」将通知结账小部件我们希望执行的计费操作：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/subscribe', function (Request $request) {\r\n        $payLink = $request->user()->newSubscription('default', $premium = 34567)\r\n            ->returnTo(route('home'))\r\n            ->create();\r\n\r\n        return view('billing', ['payLink' => $payLink]);\r\n    });\r\n\r\nCashier 包括一个 `paddle-button` [Blade 组件](/docs/laravel/9.x/blade#components)。 我们可以将支付链接 URL 作为 「prop」传递给该组件。 单击此按钮时，将显示 Paddle 的结帐小部件：\r\n\r\n```html\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\">\r\n    订阅\r\n</x-paddle-button>\r\n```\r\n\r\n默认情况下，这将显示一个具有标准 Paddle 样式的按钮。 你可以通过向组件添加 `data-theme=\"none\"` 属性来删除所有 Paddle 样式：\r\n\r\n```html\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\" data-theme=\"none\">\r\n    订阅\r\n</x-paddle-button>\r\n```\r\n\r\nPaddle 结账小部件是异步的。 一旦用户在小部件中创建或更新订阅，Paddle 将发送你的应用程序 webhook，以便你可以在我们自己的数据库中正确更新订阅状态。 因此，正确 [设置 webhooks](#handling-paddle-webhooks) 以同步 Paddle 的状态变化非常重要。\r\n\r\n有关支付链接的更多信息，你可以查看 [有关支付链接生成的 Paddle API 文档](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink)。\r\n\r\n> 注意：订阅状态更改后，接收相应 webhook 的延迟通常很小，但你应该在应用程序中考虑到这一点，因为你的用户订阅在完成结帐后可能不会立即生效。\r\n\r\n\n\n<a name=\"manually-rendering-pay-links\"></a>\r\n#### 手动呈现支付链接\r\n\r\n你也可以在不使用 Laravel 内置的 Blade 组件的情况下手动渲染支付链接。 首先，生成支付链接 URL，如先前所示：\r\n\r\n    $payLink = $request->user()->newSubscription('default', $premium = 34567)\r\n        ->returnTo(route('home'))\r\n        ->create();\r\n\r\n接下来，只需将支付链接 URL 附加到 HTML 中的 `a` 元素：\r\n\r\n    <a href=\"#!\" class=\"ml-4 paddle_button\" data-override=\"{{ $payLink }}\">\r\n        Paddle Checkout\r\n    </a>\r\n\r\n<a name=\"payments-requiring-additional-confirmation\"></a>\r\n#### 需要额外确认的付款\r\n\r\n有时需要额外的验证才能确认和处理付款。发生这种情况时，Paddle 将显示付款确认屏幕。 Paddle 或 Cashier 显示的付款确认屏幕可能会针对特定银行或发卡机构的付款流程进行定制，并且可能包括额外的卡确认、临时小额费用、单独的设备身份验证或其他形式的验证。\r\n\r\n<a name=\"inline-checkout\"></a>\r\n### 内联结账\r\n\r\n如果你不想使用 Paddle 的 「叠加」样式结帐小部件，Paddle 还提供了内嵌显示小部件的选项。 虽然这种方法不允许你调整任何结帐的 HTML 字段，但它允许你将小部件嵌入到你的应用中。\r\n\r\n为了让你轻松开始内联结账，Cashier 包含一个 `paddle-checkout` Blade 组件。 首先，你应该 [生成支付链接](#pay-links) 并将支付链接传递给组件的`override` 属性：\r\n\r\n```blade\r\n<x-paddle-checkout :override=\"$payLink\" class=\"w-full\" />\r\n```\r\n\r\n要调整内联结帐组件的高度，你可以将 `height` 属性传递给 Blade 组件：\r\n\r\n```blade\r\n<x-paddle-checkout :override=\"$payLink\" class=\"w-full\" height=\"500\" />\r\n```\r\n\r\n\n\n<a name=\"inline-checkout-without-pay-links\"></a>\r\n#### 没有支付链接的内联结账\r\n\r\n或者，你可以使用自定义选项而不是使用支付链接来自定义小部件：\r\n\r\n```blade\r\n@php\r\n$options = [\r\n    'product' => $productId,\r\n    'title' => 'Product Title',\r\n];\r\n@endphp\r\n\r\n<x-paddle-checkout :options=\"$options\" class=\"w-full\" />\r\n```\r\n\r\n请参阅 Paddle 的 [Inline Checkout 指南](https://developer.paddle.com/guides/how-tos/checkout/inline-checkout) 以及他们的 [参数参考](https://developer.paddle.com/reference/paddle-js/parameters) 以获取有关内联结帐可用选项的更多详细信息。\r\n\r\n> 注意：如果你想在指定自定义选项时也使用 `passthrough` 选项，你应该提供一个键/值数组作为其值。 Cashier 将自动处理将数组转换为 JSON 字符串。 此外，`customer_id` passthrough 选项保留供内部 Cashier 使用。\r\n\r\n<a name=\"manually-rendering-an-inline-checkout\"></a>\r\n#### 手动呈现内联结账\r\n\r\n你也可以在不使用 Laravel 的内置 Blade 组件的情况下手动渲染内联结账。 首先，生成支付链接 URL [如前面示例中所示](#pay-links)。\r\n\r\n接下来，你可以使用 Paddle.js 来初始化结帐。 为了让这个例子简单，我们将使用 [Alpine.js](https://github.com/alpinejs/alpine) 来演示； 但是，你可以自由地将此示例转换为你自己的前端技术栈：\r\n\r\n```alpine\r\n<div class=\"paddle-checkout\" x-data=\"{}\" x-init=\"\r\n    Paddle.Checkout.open({\r\n        override: {{ $payLink }},\r\n        method: 'inline',\r\n        frameTarget: 'paddle-checkout',\r\n        frameInitialHeight: 366,\r\n        frameStyle: 'width: 100%; background-color: transparent; border: none;'\r\n    });\r\n\">\r\n</div>\r\n```\r\n\r\n<a name=\"user-identification\"></a>\r\n### 用户识别\r\n\r\n与 Stripe 相比，Paddle 用户在所有 Paddle 中都是独一无二的，而不是每个 Paddle 帐户都是独一无二的。因此，Paddle 的 API 目前不提供更新用户详细信息（例如电子邮件地址）的方法。在生成支付链接时，Paddle 使用 `customer_email` 参数识别用户。创建订阅时，Paddle 将尝试将用户提供的电子邮件与现有 Paddle 用户进行匹配。\r\n\r\n\n\n鉴于这种行为，在使用 Cashier 和 Paddle 时需要记住一些重要的事情。首先，你应该知道，即使 Cashier 中的订阅绑定到同一个应用程序用户，**它们也可能绑定到 Paddle 内部系统中的不同用户**。其次，每个订阅都有自己的连接支付方式信息，并且在 Paddle 的内部系统中也可能有不同的电子邮件地址（取决于创建订阅时分配给用户的电子邮件）。\r\n\r\n因此，在显示订阅时，你应该始终告知用户哪些电子邮件地址或付款方式信息与订阅相关联。可以使用 `Laravel\\Paddle\\Subscription` 模型提供的以下方法检索这些信息：\r\n\r\n    $subscription = $user->subscription('default');\r\n\r\n    $subscription->paddleEmail();\r\n    $subscription->paymentMethod();\r\n    $subscription->cardBrand();\r\n    $subscription->cardLastFour();\r\n    $subscription->cardExpirationDate();\r\n\r\n当前，没有办法通过Paddle API修改用户的电子邮件地址。当用户想在Paddle内更新他们的电子邮件地址时，他们唯一的方法是联系Paddle客户支持。在与Paddle沟通时，他们需要提供订阅的`paddleEmail`，这样Paddle就可以更新正确的用户。\r\n\r\n<a name=\"prices\"></a>\r\n## 定价\r\n\r\nPaddle允许你自定义每种货币对应的价格，也就是说Paddle允许你为不同国家和地区配置不同的价格。Cashier Paddle允许你使用`productPrices`方法检索一个特定产品的所有价格。这个方法接受你希望检索价格的产品的产品ID：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    $prices = Cashier::productPrices([123, 456]);\r\n\r\n\n\n货币将根据请求的 IP 地址来确定，当然你也可以传入一个可选的国家和地区参数来检索特定国家和地区的价格：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    $prices = Cashier::productPrices([123, 456], ['customer_country' => 'BE']);\r\n\r\n检索出价格后，您可以根据需要显示它们：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - {{ $price->price()->gross() }}</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n你也可以显示净价（不含税）并将税额显示分离：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - {{ $price->price()->net() }} (+ {{ $price->price()->tax() }} tax)</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n如果你检索了订阅的价格，你可以分别显示其原始价格和连续订阅价格：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - Initial: {{ $price->initialPrice()->gross() }} - Recurring: {{ $price->recurringPrice()->gross() }}</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n更多相关信息，请 [查看 Paddle 的价格 API 文档](https://developer.paddle.com/api-reference/checkout-api/prices/getprices)。\r\n\r\n<a name=\"prices-customers\"></a>\r\n#### 客户\r\n\r\n如果用户已经是客户并且您希望显示适用于该客户的价格，您可以通过直接从客户实例检索价格来实现：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $prices = User::find(1)->productPrices([123, 456]);\r\n\r\n在内部，Cashier 将使用用户的 [`paddleCountry` 方法](#customer-defaults) 来检索以他们的货币表示的价格。 例如，居住在美国的用户将看到以美元为单位的价格，而位于比利时的用户将看到以欧元为单位的价格。 如果找不到匹配的货币，则将使用产品的默认货币。 您可以在 Paddle 控制面板中自定义产品或订阅计划的所有价格。\r\n\r\n\n\n<a name=\"prices-coupons\"></a>\r\n#### 优惠券\r\n\r\n你也可以展示选择优惠券后的折扣价。 在调用 `productPrices` 方法时，优惠券可以作为逗号分隔的字符串传递：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    $prices = Cashier::productPrices([123, 456], [\r\n        'coupons' => 'SUMMERSALE,20PERCENTOFF'\r\n    ]);\r\n\r\n然后，使用 `price` 方法显示计算出的价格：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - {{ $price->price()->gross() }}</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n你可以使用 `listPrice` 方法显示原价（没有优惠券折扣）：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - {{ $price->listPrice()->gross() }}</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n> 注意：使用价格 API 时，Paddle 仅允许将优惠券应用于一次性购买的产品，而不允许应用于订阅计划。\r\n\r\n<a name=\"customers\"></a>\r\n## 客户\r\n\r\n<a name=\"customer-defaults\"></a>\r\n### 客户默认值\r\n\r\nCashier 允许你在创建支付链接时为你的客户定义一些默认值。 设置这些默认值允许你预先填写客户的电子邮件地址、国家 / 地区和邮政编码，以便他们可以立即转到结帐小部件的付款部分。 你可以通过覆盖计费模型上的以下方法来设置这些默认值：\r\n\r\n    /**\r\n     * 获取客户的电子邮件地址以与 Paddle 关联。\r\n     *\r\n     * @return string|null\r\n     */\r\n    public function paddleEmail()\r\n    {\r\n        return $this->email;\r\n    }\r\n\r\n    /**\r\n     * 获取客户的国家与 Paddle 关联。\r\n     *\r\n     * 这需要一个 2 个字母的代码。 有关支持的国家 / 地区，请参阅以下链接。\r\n     *\r\n     * @return string|null\r\n     * @link https://developer.paddle.com/reference/platform-parameters/supported-countries\r\n     */\r\n    public function paddleCountry()\r\n    {\r\n        //\r\n    }\r\n\r\n    /**\r\n     * 获取客户的邮政编码以与 Paddle 关联。\r\n     *\r\n     * 有关需要此功能的国家 / 地区，请参阅以下链接。\r\n     *\r\n     * @return string|null\r\n     * @link https://developer.paddle.com/reference/platform-parameters/supported-countries#countries-requiring-postcode\r\n     */\r\n    public function paddlePostcode()\r\n    {\r\n        //\r\n    }\r\n\r\n\n\n这些默认值将用于 Cashier 中生成 [支付链接](#pay-links) 的每个操作。\r\n\r\n<a name=\"subscriptions\"></a>\r\n## 订阅\r\n\r\n<a name=\"creating-subscriptions\"></a>\r\n### 创建订阅\r\n\r\n要创建订阅，请首先检索计费模型的实例，该实例通常是 `App\\Models\\User` 的实例。 检索模型实例后，你可以使用 `newSubscription` 方法来创建模型的订阅支付链接：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/subscribe', function (Request $request) {\r\n        $payLink = $request->user()->newSubscription('default', $premium = 12345)\r\n            ->returnTo(route('home'))\r\n            ->create();\r\n\r\n        return view('billing', ['payLink' => $payLink]);\r\n    });\r\n\r\n传递给 `newSubscription` 方法的第一个参数应该是订阅的名称。 如果你的应用只提供一个订阅，你可以将其称为 `default` 或 `primary`。 第二个参数是用户订阅的特定计划。 该值应对应于 Paddle 中的计划标识符。 `returnTo` 方法接受一个 URL，你的用户在成功完成结帐后将被重定向到该 URL。\r\n\r\n`create` 方法将创建一个支付链接，你可以使用它来生成一个支付按钮。 可以使用 Cashier Paddle 附带的 `paddle-button` [Blade 组件](/docs/laravel/9.x/blade#components) 生成支付按钮：\r\n\r\n```blade\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\">\r\n    订阅\r\n</x-paddle-button>\r\n```\r\n\r\n\n\n用户完成结帐后，将从 Paddle 发送一个 `subscription_created` webhook。 Cashier 将收到此 webhook 并为你的客户设置订阅。 为了确保你的应用程序正确接收和处理所有 webhook，请确保你正确地 [设置 webhook 处理](#handling-paddle-webhooks)。\r\n\r\n<a name=\"additional-details\"></a>\r\n#### 额外细节\r\n\r\n如果你想指定额外的客户或订阅详细信息，你可以通过将它们作为键 / 值对数组传递给 `create` 方法来实现。 要了解有关 Paddle 支持的其他字段的更多信息，请查看 Paddle 关于 [生成支付链接](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink) 的文档：\r\n\r\n    $payLink = $user->newSubscription('default', $monthly = 12345)\r\n        ->returnTo(route('home'))\r\n        ->create([\r\n            'vat_number' => $vatNumber,\r\n        ]);\r\n\r\n<a name=\"subscriptions-coupons\"></a>\r\n#### 优惠券\r\n\r\n如果你想在创建订阅时申请优惠券，你可以使用 `withCoupon` 方法：\r\n\r\n    $payLink = $user->newSubscription('default', $monthly = 12345)\r\n        ->returnTo(route('home'))\r\n        ->withCoupon('code')\r\n        ->create();\r\n\r\n<a name=\"metadata\"></a>\r\n#### 元数据\r\n\r\n你还可以使用 `withMetadata` 方法传递元数据数组：\r\n\r\n    $payLink = $user->newSubscription('default', $monthly = 12345)\r\n        ->returnTo(route('home'))\r\n        ->withMetadata(['key' => 'value'])\r\n        ->create();\r\n\r\n> 注意：提供元数据时，请避免使用 `subscription_name` 作为元数据键。 此密钥保留供 Cashier 内部使用。\r\n\r\n<a name=\"checking-subscription-status\"></a>\r\n### 检查订阅状态\r\n\r\n一旦用户订阅了你的应用程序，你就可以使用各种便利的方法检查他们的订阅状态。 首先，如果用户有活动订阅，`subscribed` 方法返回 `true`，即使订阅当前处于试用期：\r\n\r\n    if ($user->subscribed('default')) {\r\n        //\r\n    }\r\n\r\n\n\n该 `subscribed` 方法也非常适合 [路由中间件](/docs/laravel/9.x/middleware)，允许您根据用户的订阅状态过滤对路由和控制器的访问：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n\r\n    class EnsureUserIsSubscribed\r\n    {\r\n        /**\r\n         * 处理请求.\r\n         *\r\n         * @param  \\Illuminate\\Http\\Request  $request\r\n         * @param  \\Closure  $next\r\n         * @return mixed\r\n         */\r\n        public function handle($request, Closure $next)\r\n        {\r\n            if ($request->user() && ! $request->user()->subscribed('default')) {\r\n                // 此用户非付费客户...\r\n                return redirect('billing');\r\n            }\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n如果您想确定用户是否仍在试用期内，您可以使用 `onTrial` 方法。此方法可用于确定是否应向用户显示他们仍在试用期的警告：\r\n\r\n    if ($user->subscription('default')->onTrial()) {\r\n        //\r\n    }\r\n\r\n该 `subscribedToPlan` 方法可用于根据给定的 Paddle 计划 ID 确定用户是否订阅了给定的计划。 在这个例子中，我们将确定用户的 `default` 订阅是否订阅包月计划：\r\n\r\n    if ($user->subscribedToPlan($monthly = 12345, 'default')) {\r\n        //\r\n    }\r\n\r\n通过将数组传递给 `subscribedToPlan` 方法，您可以确定用户的 `default` 订阅是积极订阅月度或年度计划：\r\n\r\n    if ($user->subscribedToPlan([$monthly = 12345, $yearly = 54321], 'default')) {\r\n        //\r\n    }\r\n\r\n该 `recurring` 方法可用于确定用户当前是否已订阅并且不再处于试用期：\r\n\r\n    if ($user->subscription('default')->recurring()) {\r\n        //\r\n    }\r\n\r\n<a name=\"cancelled-subscription-status\"></a>\r\n#### 已取消订阅状态\r\n\r\n要确定用户是否曾经是订阅者但现在已取消订阅，您可以使用 `cancelled` 方法：\r\n\r\n    if ($user->subscription('default')->cancelled()) {\r\n        //\r\n    }\r\n\r\n\n\n你还可以确定用户是否已取消订阅，但在订阅完全到期之前仍处于 「宽限期」。 例如，如果用户在 3 月 5 日取消原定于 3 月 10 日到期的订阅，则用户将处于「宽限期」，直到 3 月 10 日。 请注意，在此期间 `subscribed` 方法仍然返回 `true`：\r\n\r\n    if ($user->subscription('default')->onGracePeriod()) {\r\n        //\r\n    }\r\n\r\n要确定用户是否已取消订阅并且不再处于「宽限期」内，你可以使用 `ended` 方法：\r\n\r\n    if ($user->subscription('default')->ended()) {\r\n        //\r\n    }\r\n\r\n<a name=\"past-due-status\"></a>\r\n#### 逾期状态\r\n\r\n如果订阅的付款失败，它将被标记为 `past_due`。 当你的订阅处于此状态时，在客户更新其付款信息之前，它不会处于活动状态。 你可以使用订阅实例上的 `pastDue` 方法来确定订阅是否过期：\r\n\r\n    if ($user->subscription('default')->pastDue()) {\r\n        //\r\n    }\r\n\r\n当订阅过期时，你应该指示用户 [更新他们的付款信息](#updating-payment-information)。 你可以在 [Paddle 订阅设置](https://vendors.paddle.com/subscription-settings) 中配置逾期订阅的处理方式。\r\n\r\n如果你希望订阅在 `past_due` 时仍被视为活动，你可以使用 Cashier 提供的 `keepPastDueSubscriptionsActive` 方法。 通常，此方法应在你的 `AppServiceProvider` 的 `register` 方法中调用：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    /**\r\n     * 注册应用服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        Cashier::keepPastDueSubscriptionsActive();\r\n    }\r\n\r\n> 注意：当订阅处于 `past_due` 状态时，在付款信息更新之前无法更改。 因此，当订阅处于 `past_due` 状态时，`swap` 和 `updateQuantity` 方法将抛出异常。\r\n\r\n\n\n<a name=\"subscription-scopes\"></a>\r\n#### 订阅范围\r\n\r\n大多数订阅状态也可用作查询范围，以便你可以轻松查询数据库中处于给定状态的订阅：\r\n\r\n    // 获取所有有效订阅...\r\n    $subscriptions = Subscription::query()->active()->get();\r\n\r\n    // 获取给定用户的所有已取消订阅...\r\n    $subscriptions = $user->subscriptions()->cancelled()->get();\r\n\r\n可用范围的完整列表如下：\r\n\r\n    Subscription::query()->active();\r\n    Subscription::query()->onTrial();\r\n    Subscription::query()->notOnTrial();\r\n    Subscription::query()->pastDue();\r\n    Subscription::query()->recurring();\r\n    Subscription::query()->ended();\r\n    Subscription::query()->paused();\r\n    Subscription::query()->notPaused();\r\n    Subscription::query()->onPausedGracePeriod();\r\n    Subscription::query()->notOnPausedGracePeriod();\r\n    Subscription::query()->cancelled();\r\n    Subscription::query()->notCancelled();\r\n    Subscription::query()->onGracePeriod();\r\n    Subscription::query()->notOnGracePeriod();\r\n\r\n<a name=\"subscription-single-charges\"></a>\r\n### 订阅单次收费\r\n\r\n订阅单次收费允许你在订阅的基础上向订阅者收取一次性费用：\r\n\r\n    $response = $user->subscription('default')->charge(12.99, 'Support Add-on');\r\n\r\n与 [单一费用](#single-charges) 相比，此方法将立即向客户存储的订阅付款方式收费。 收费金额应始终以订阅的货币定义。\r\n\r\n<a name=\"updating-payment-information\"></a>\r\n### 更新付款信息\r\n\r\nPaddle 始终为每个订阅保存一种付款方式。 如果要更新订阅的默认付款方式，则应首先使用订阅模型上的 `updateUrl` 方法生成订阅 「更新 URL」：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $updateUrl = $user->subscription('default')->updateUrl();\r\n\r\n然后，你可以将生成的 URL 与 Cashier 提供的 `paddle-button` Blade 组件结合使用，以允许用户启动 Paddle 小部件并更新他们的付款信息：\r\n\r\n```html\r\n<x-paddle-button :url=\"$updateUrl\" class=\"px-8 py-4\">\r\n    更新付款信息\r\n</x-paddle-button>\r\n```\r\n\r\n\n\n当用户更新完他们的信息后，Paddle 将发送一个 `subscription_updated` webhook，订阅详细信息将在你的应用数据库中更新。\r\n\r\n<a name=\"changing-plans\"></a>\r\n### 改变计划\r\n\r\n用户订阅你的应用程序后，他们可能偶尔想要更改为新的订阅计划。 要为用户更新订阅计划，你应该将 Paddle 计划的标识符传递给订阅的 `swap` 方法：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swap($premium = 34567);\r\n\r\n如果你想变更计划并立即为用户开具发票，而不是等待他们的下一个计费周期，您可以使用 `swapAndInvoice` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swapAndInvoice($premium = 34567);\r\n\r\n> 注意：试用活动期间不能变更计划。有关此限制的更多信息，请参阅 [Paddle 文档](https://developer.paddle.com/api-reference/subscription-api/users/updateuser#usage-notes)。\r\n\r\n<a name=\"prorations\"></a>\r\n#### 按比例分配\r\n\r\n默认情况下，Paddle 在计划变更时按比例分配费用。 `noProrate` 方法可用于在不按比例分配费用的情况下更新订阅：\r\n\r\n    $user->subscription('default')->noProrate()->swap($premium = 34567);\r\n\r\n<a name=\"subscription-quantity\"></a>\r\n### 订阅数量\r\n\r\n有时订阅会受到 「数量」的影响。 例如，项目管理应用可能对每个项目每月收费 10 美元。 要增加或减少订阅数量，请使用 `incrementQuantity` 和 `decrementQuantity` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->incrementQuantity();\r\n\r\n    // 订阅增加 5 个...\r\n    $user->subscription('default')->incrementQuantity(5);\r\n\r\n    $user->subscription('default')->decrementQuantity();\r\n\r\n    // 订阅减少 5 个...\r\n    $user->subscription('default')->decrementQuantity(5);\r\n\r\n\n\n或者，您可以使用 `updateQuantity` 方法设置特定数量：\r\n\r\n    $user->subscription('default')->updateQuantity(10);\r\n\r\n该 `noProrate` 方法可用于更新订阅数量而不按比例分配费用：\r\n\r\n    $user->subscription('default')->noProrate()->updateQuantity(10);\r\n\r\n<a name=\"subscription-modifiers\"></a>\r\n### 订阅修饰符\r\n\r\n订阅修饰符允许您实施 [计量计费](https://developer.paddle.com/guides/how-tos/subscriptions/metered-billing#using-subscription-price-modifiers) 或使用附加组件扩展订阅。\r\n\r\n例如，您可能想为标准订阅提供 「高级支持」附加组件。 你可以像这样创建这个修饰符：\r\n\r\n    $modifier = $user->subscription('default')->newModifier(12.99)->create();\r\n\r\n上例将向订阅添加 $12.99 的附加组件。 默认情况下，此费用将在您为订阅配置的每个时间周期内重复收取。 如果您愿意，可以使用修饰符的 `description` 方法向修饰符添加可读的描述：\r\n\r\n    $modifier = $user->subscription('default')->newModifier(12.99)\r\n        ->description('Premium Support')\r\n        ->create();\r\n\r\n为了说明如何使用修饰符实现计量计费，假设您的应用程序对用户发送的每条 SMS 消息收费。 首先，您应该在 Paddle 仪表板中创建一个 $0 的计划。 用户订阅此计划后，您可以向订阅添加代表每个单独费用的修饰符：\r\n\r\n    $modifier = $user->subscription('default')->newModifier(0.99)\r\n        ->description('New text message')\r\n        ->oneTime()\r\n        ->create();\r\n\r\n如您所见，我们在创建此修饰符时调用了 `oneTime` 方法。此方法将确保修改器只收费一次，并且不会在每个计费周期重复。\r\n\r\n<a name=\"retrieving-modifiers\"></a>\r\n#### 检索修饰符\r\n\r\n\n\n您可以通过 `modifiers` 方法检索订阅的所有修饰符的列表：\r\n\r\n    $modifiers = $user->subscription('default')->modifiers();\r\n\r\n    foreach ($modifiers as $modifier) {\r\n        $modifier->amount(); // $0.99\r\n        $modifier->description; // New text message.\r\n    }\r\n\r\n<a name=\"deleting-modifiers\"></a>\r\n#### 删除修饰符\r\n\r\n修改器可以通过调用 `Laravel\\Paddle\\Modifier` 实例上的 `delete` 方法来删除：\r\n\r\n    $modifier->delete();\r\n\r\n<a name=\"pausing-subscriptions\"></a>\r\n### 暂停订阅\r\n\r\n要暂停订阅，请调用用户订阅的 `pause` 方法：\r\n\r\n    $user->subscription('default')->pause();\r\n\r\n当订阅暂停时，Cashier 将自动在您的数据库中设置 `paused_from` 列。此列用于确定 `paused` 方法何时应该开始返回 `true`。例如，如果客户在 3 月 1 日暂停订阅，但该订阅直到 3 月 5 日才计划重复发生，则 `paused` 方法将继续返回 `false` ，直到 3 月 5 日。这样做是因为通常允许用户继续使用应用程序，直到他们的计费周期结束。\r\n\r\n您可以使用 `onPausedGracePeriod` 方法确定用户是否已暂停订阅但仍处于 「宽限期」：\r\n\r\n    if ($user->subscription('default')->onPausedGracePeriod()) {\r\n        //\r\n    }\r\n\r\n要恢复暂停的订阅，您可以调用用户订阅的 `unpause` 方法：\r\n\r\n    $user->subscription('default')->unpause();\r\n\r\n> 注意：订阅暂停时无法修改。 如果您想切换到不同的计划或更新数量，您必须先恢复订阅。\r\n\r\n<a name=\"cancelling-subscriptions\"></a>\r\n### 取消订阅\r\n\r\n要取消订阅，请调用用户订阅的 `cancel` 方法：\r\n\r\n    $user->subscription('default')->cancel();\r\n\r\n\n\n当订阅被取消时，Cashier 将自动在你的数据库中设置 `ends_at` 列。 此列用于确定 `subscribed` 方法应该何时开始返回 `false`。 例如，如果客户在 3 月 1 日取消订阅，但订阅计划在 3 月 5 日之前结束，则 `subscribed` 方法将在 3 月 5 日之前继续返回 `true`。 这样做是因为通常允许用户继续使用应用程序，直到他们的计费周期结束。\r\n\r\n你可以使用 `onGracePeriod` 方法确定用户是否已取消订阅但仍处于「宽限期」：\r\n\r\n    if ($user->subscription('default')->onGracePeriod()) {\r\n        //\r\n    }\r\n\r\n如果你想立即取消订阅，你可以调用用户订阅的 `cancelNow` 方法：\r\n\r\n    $user->subscription('default')->cancelNow();\r\n\r\n> 注意：取消后无法恢复 Paddle 的订阅。 如果你的客户希望恢复订阅，则他们必须重新订阅。\r\n\r\n<a name=\"subscription-trials\"></a>\r\n## 订阅试用\r\n\r\n<a name=\"with-payment-method-up-front\"></a>\r\n### 预先收集付费方式\r\n\r\n> 注意：在预先试用和收集付款方式详细信息时，Paddle 会阻止任何订阅更改，例如更换计划或更新数量。 如果你想允许客户在试用期间更换计划，则必须取消并重新创建订阅。\r\n\r\n如果你想为你的客户提供试用期，同时仍然预先收集付款方式信息，你应该在创建订阅付款链接时使用 `trialDays` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/subscribe', function (Request $request) {\r\n        $payLink = $request->user()->newSubscription('default', $monthly = 12345)\r\n                    ->returnTo(route('home'))\r\n                    ->trialDays(10)\r\n                    ->create();\r\n\r\n        return view('billing', ['payLink' => $payLink]);\r\n    });\r\n\r\n\n\n此方法将在你的应用数据库中的订阅记录上设置试用期结束日期，并指示 Paddle 在此日期之后才开始向客户收费。\r\n\r\n> 注意：如果客户的订阅未在试用结束日期之前取消，他们将在试用到期后立即收费，因此你务必将试用结束日期通知你的用户。\r\n\r\n你可以使用用户实例的 `onTrial` 方法或订阅实例的 `onTrial` 方法来确定用户是否在试用期内。 下面的两个例子是等价的：\r\n\r\n    if ($user->onTrial('default')) {\r\n        //\r\n    }\r\n\r\n    if ($user->subscription('default')->onTrial()) {\r\n        //\r\n    }\r\n\r\n<a name=\"defining-trial-days-in-paddle-cashier\"></a>\r\n#### 在 Paddle / Cashier 中定义试用天数\r\n\r\n你可以选择在 Paddle 仪表板中定义你的计划接收的试用天数，或者始终使用 Cashier 明确传递它们。 如果你选择在 Paddle 中定义计划的试用天数，你应该知道新订阅，包括过去订阅过的客户的新订阅，将始终获得试用期，除非你明确调用 `trialDays(0)` 方法。\r\n\r\n<a name=\"without-payment-method-up-front\"></a>\r\n### 未预先收集付款方式\r\n\r\n如果你想提供试用期而不预先收集用户的付款方式信息，你可以将附加到你的用户的客户记录上的 `trial_ends_at` 列设置为你想要的试用结束日期。 这通常在用户注册期间完成：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::create([\r\n        // ...\r\n    ]);\r\n\r\n    $user->createAsCustomer([\r\n        'trial_ends_at' => now()->addDays(10)\r\n    ]);\r\n\r\n\n\nCashier 将这种类型的试用称为「通用试用」，因为它不附属于任何现有订阅。如果当前日期未超过  `trial_ends_at` 的值，则 `User` 实例上的 `onTrial` 方法将返回 `true`：\r\n\r\n    if ($user->onTrial()) {\r\n        // 用户在试用期内...\r\n    }\r\n\r\n一旦你准备好为用户创建一个实际的订阅，你可以像往常一样使用 `newSubscription` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/subscribe', function (Request $request) {\r\n        $payLink = $user->newSubscription('default', $monthly = 12345)\r\n            ->returnTo(route('home'))\r\n            ->create();\r\n\r\n        return view('billing', ['payLink' => $payLink]);\r\n    });\r\n\r\n要检索用户的试用结束日期，您可以使用 `trialEndsAt` 方法。如果用户正在试用，则此方法将返回一个 Carbon 日期实例，否则将返回 `null` 。如果您想获取特定订阅而不是默认订阅的试用结束日期，您还可以传递一个可选的订阅名称参数：\r\n\r\n    if ($user->onTrial()) {\r\n        $trialEndsAt = $user->trialEndsAt('main');\r\n    }\r\n\r\n如果您希望明确知道用户处于 「通用」试用期内并且尚未创建实际订阅，则可以使用 `onGenericTrial` 方法：\r\n\r\n    if ($user->onGenericTrial()) {\r\n        // 用户在通用试用期内...\r\n    }\r\n\r\n> 注意：创建 Paddle 订阅后，无法延长或修改其试用期。\r\n\r\n<a name=\"handling-paddle-webhooks\"></a>\r\n## 处理 Paddle Webhooks\r\n\r\nPaddle 可以通过 webhook 通知您的应用各种事件。默认情况下，指向 Cashier 的 webhook 控制器的路由由 Cashier 服务提供商注册。该控制器将处理所有传入的 webhook 请求。\r\n\r\n\n\n默认情况下，此控制器将自动处理付费失败过多的取消订阅（[由你的 Paddle 订阅设置定义](https://vendors.paddle.com/subscription-settings)）、订阅更新和付款方式更改；但是，我们很快就会发现，你可以扩展这个控制器来处理你喜欢的任何 Paddle webhook 事件。\r\n\r\n为确保你的应用可以处理 Paddle webhooks，请务必 [在 Paddle 控制面板中配置 webhook URL](https://vendors.paddle.com/alerts-webhooks)。默认情况下，Cashier 的 webhook 控制器响应 `/paddle/webhook` URL 路径。你应该在 Paddle 控制面板中启用的所有 webhook 的完整列表是：\r\n\r\n- 订阅创建\r\n- 订阅更新\r\n- 订阅取消\r\n- 付款成功\r\n- 订阅付款成功\r\n\r\n> 注意：确保使用 Cashier 包含的 [webhook 签名验证](/docs/laravel/9.x/cashier-paddle#verifying-webhook-signatures) 中间件保护传入请求。\r\n\r\n<a name=\"webhooks-csrf-protection\"></a>\r\n#### Webhook 和 CSRF 保护\r\n\r\n由于 Paddle webhooks 需要绕过 Laravel 的 [CSRF 保护](/docs/laravel/9.x/csrf)，请务必在你的 `App\\Http\\Middleware\\VerifyCsrfToken` 中间件中将 URI 作为例外列出或列出外面的路由 `web` 中间件组的：\r\n\r\n    protected $except = [\r\n        'paddle/*',\r\n    ];\r\n\r\n<a name=\"webhooks-local-development\"></a>\r\n#### Webhook 和本地开发\r\n\r\n为了让 Paddle 能够在本地开发期间发送你的应用程序 webhook，你需要通过站点共享服务公开你的应用程序，例如 [Ngrok](https://ngrok.com/) 或 [Expose](https://expose.dev/docs/introduction)。如果你使用 [Laravel Sail](/docs/laravel/9.x/sail) 在本地开发应用程序，你可以使用 Sail 的 [站点共享命令](/docs/laravel/9.x/sail#sharing-your-site)。\r\n\n\n<a name=\"defining-webhook-event-handlers\"></a>\r\n### 定义 webhook 事件处理程序\r\n\r\nCashier 会自动处理因收费失败和其他常见的 paddle webhook 取消订阅。 但是，如果您有其他想要处理的 webhook 事件，您可以通过收听 Cashier 调度的以下事件来实现：\r\n\r\n- `Laravel\\Paddle\\Events\\WebhookReceived`\r\n- `Laravel\\Paddle\\Events\\WebhookHandled`\r\n\r\n这两个事件都包含 Paddle webhook 的完整负载。 例如，如果你想处理 `invoice.payment_succeeded` webhook，你可以注册一个 [listener](/docs/laravel/9.x/events#defining-listeners) 来处理事件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Laravel\\Paddle\\Events\\WebhookReceived;\r\n\r\n    class PaddleEventListener\r\n    {\r\n        /**\r\n         * 处理收到的 Paddle webhook。\r\n         *\r\n         * @param  \\Laravel\\Paddle\\Events\\WebhookReceived  $event\r\n         * @return void\r\n         */\r\n        public function handle(WebhookReceived $event)\r\n        {\r\n            if ($event->payload['alert_name'] === 'payment_succeeded') {\r\n                // 处理传入事件...\r\n            }\r\n        }\r\n    }\r\n\r\n一旦你的监听器被定义，你可以在你的应用程序的`EventServiceProvider`中注册它：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Listeners\\PaddleEventListener;\r\n    use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\n    use Laravel\\Paddle\\Events\\WebhookReceived;\r\n\r\n    class EventServiceProvider extends ServiceProvider\r\n    {\r\n        protected $listen = [\r\n            WebhookReceived::class => [\r\n                PaddleEventListener::class,\r\n            ],\r\n        ];\r\n    }\r\n\r\nCashier 还会发出专用于接收到的 webhook 类型的事件。 除了来自 Paddle 的完整有效负载之外，它们还包含用于处理 webhook 的相关模型，例如计费模型、订阅或收据：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `Laravel\\Paddle\\Events\\PaymentSucceeded`\r\n- `Laravel\\Paddle\\Events\\SubscriptionPaymentSucceeded`\r\n- `Laravel\\Paddle\\Events\\SubscriptionCreated`\r\n- `Laravel\\Paddle\\Events\\SubscriptionUpdated`\r\n- `Laravel\\Paddle\\Events\\SubscriptionCancelled`\r\n\r\n</div>\r\n\r\n\n\n您还可以通过在应用程序的 `.env` 文件中定义 `CASHIER_WEBHOOK` 环境变量来覆盖默认的内置 webhook 路由。 此值应该是您的 webhook 路由的完整 URL，并且需要与您在 Paddle 控制面板中设置的 URL 相匹配：\r\n\r\n```ini\r\nCASHIER_WEBHOOK=https://example.com/my-paddle-webhook-url\r\n```\r\n\r\n<a name=\"verifying-webhook-signatures\"></a>\r\n### 验证 Webhook 签名\r\n\r\n为了保护您的 webhook，您可以使用 [Paddle 的 webhook 签名](https://developer.paddle.com/webhook-reference/verifying-webhooks)。 为方便起见，Cashier 自动包含一个中间件，用于验证传入的 Paddle webhook 请求是否有效。\r\n\r\n要启用 webhook 验证，请确保在应用程序的 .env 文件中定义了 `PADDLE_PUBLIC_KEY` 环境变量。 可以从您的 Paddle 帐户仪表板中检索公钥。\r\n\r\n<a name=\"single-charges\"></a>\r\n## 单次收费\r\n\r\n<a name=\"simple-charge\"></a>\r\n### Simple Charge\r\n\r\n如果您想对客户进行一次性收费，您可以在可计费模型实例上使用“charge”方法来生成收费的支付链接。 `charge` 方法接受费用金额（浮点数）作为它的第一个参数和一个费用描述作为它的第二个参数：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/store', function (Request $request) {\r\n        return view('store', [\r\n            'payLink' => $user->charge(12.99, 'Action Figure')\r\n        ]);\r\n    });\r\n\r\n生成支付链接后，您可以使用 Cashier 提供的 `paddle-button` Blade 组件让用户启动 Paddle 小部件并完成收费：\r\n\r\n```blade\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\">\r\n    Buy\r\n</x-paddle-button>\r\n```\r\n\r\n`charge` 方法接受一个数组作为其第三个参数，允许您将任何您希望的选项传递给底层 Paddle 支付链接创建。 请查阅 [Paddle 文档](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink) 了解更多关于创建费用时可用的选项：\r\n\r\n    $payLink = $user->charge(12.99, 'Action Figure', [\r\n        'custom_option' => $value,\r\n    ]);\r\n\r\n\n\n费用以 `cashier.currency` 配置选项中指定的货币进行。 默认情况下，这设置为美元。 您可以通过在应用程序的 `.env` 文件中定义 `CASHIER_CURRENCY` 环境变量来覆盖默认货币：\r\n\r\n```ini\r\nCASHIER_CURRENCY=EUR\r\n```\r\n\r\n您还可以使用 Paddle 的动态定价匹配系统 [覆盖每种货币的价格](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink#price-overrides)。为此，请通过价格数组而不是固定金额：\r\n\r\n    $payLink = $user->charge([\r\n        'USD:19.99',\r\n        'EUR:15.99',\r\n    ], 'Action Figure');\r\n\r\n<a name=\"charging-products\"></a>\r\n### Charging Products\r\n\r\n如果您想对 Paddle 中配置的特定产品进行一次性收费，您可以在计费模型实例上使用 `chargeProduct` 方法来生成付款链接：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/store', function (Request $request) {\r\n        return view('store', [\r\n            'payLink' => $request->user()->chargeProduct($productId = 123)\r\n        ]);\r\n    });\r\n\r\n然后，您可以提供 `paddle-button` 组件的支付链接，以允许用户初始化 Paddle 小部件：\r\n\r\n```blade\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\">\r\n    Buy\r\n</x-paddle-button>\r\n```\r\n\r\n`chargeProduct` 方法接受一个数组作为其第二个参数，允许您将任何您希望的选项传递给底层 Paddle 支付链接创建。 请查阅 [Paddle 文档](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink) 关于创建费用时可用的选项：\r\n\r\n    $payLink = $user->chargeProduct($productId, [\r\n        'custom_option' => $value,\r\n    ]);\r\n\r\n<a name=\"refunding-orders\"></a>\r\n### 退款订单\r\n\r\n如果您需要对桨订单进行退款，您可以使用 `refund` 方法。 此方法接受 Paddle 订单 ID 作为其第一个参数。 您可以使用 `receipts` 方法检索给定计费模型的收据：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $receipt = $user->receipts()->first();\r\n\r\n    $refundRequestId = $user->refund($receipt->order_id);\r\n\r\n\n\n您可以选择指定具体的退款金额以及退款原因：\r\n\r\n    $receipt = $user->receipts()->first();\r\n\r\n    $refundRequestId = $user->refund(\r\n        $receipt->order_id, 5.00, 'Unused product time'\r\n    );\r\n\r\n> 技巧：联系 Paddle 支持时，您可以使用“$refundRequestId”作为退款参考。\r\n\r\n<a name=\"receipts\"></a>\r\n## 收据\r\n\r\n您可以通过 `receipts` 属性轻松检索可计费模型的收据数组：\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $receipts = $user->receipts;\r\n\r\n在为客户列出收据时，您可以使用收据实例的方法来显示相关的收据信息。 例如，您可能希望在表格中列出每张收据，以便用户轻松下载任何收据：\r\n\r\n```html\r\n<table>\r\n    @foreach ($receipts as $receipt)\r\n        <tr>\r\n            <td>{{ $receipt->paid_at->toFormattedDateString() }}</td>\r\n            <td>{{ $receipt->amount() }}</td>\r\n            <td><a href=\"{{ $receipt->receipt_url }}\" target=\"_blank\">Download</a></td>\r\n        </tr>\r\n    @endforeach\r\n</table>\r\n```\r\n\r\n<a name=\"past-and-upcoming-payments\"></a>\r\n### 过去 & 未来的付款\r\n\r\n您可以使用 `lastPayment` 和 `nextPayment` 方法来检索和显示客户过去或即将进行的定期订阅付款：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $subscription = $user->subscription('default');\r\n\r\n    $lastPayment = $subscription->lastPayment();\r\n    $nextPayment = $subscription->nextPayment();\r\n\r\n这两种方法都会返回一个 `Laravel\\Paddle\\Payment` 的实例； 但是，当计费周期结束时（例如取消订阅时），`nextPayment` 将返回 `null`：\r\n\r\n```blade\r\nNext payment: {{ $nextPayment->amount() }} due on {{ $nextPayment->date()->format('d/m/Y') }}\r\n```\r\n\r\n<a name=\"handling-failed-payments\"></a>\r\n## 处理失败的付款\r\n\r\n订阅支付失败的原因有多种，例如卡过期或卡资金不足。 发生这种情况时，我们建议您让 Paddle 为您处理付款失败。 具体来说，您可以在您的 Paddle 仪表板中[设置 Paddle 的自动计费电子邮件](https://vendors.paddle.com/subscription-settings)。\r\n\r\n\n\n或者，您可以通过捕获 [`subscription_payment_failed`](https://developer.paddle.com/webhook-reference/subscription-alerts/subscription-payment-failed) webhook 并启用“订阅付款失败”来执行更精确的自定义Paddle 仪表板的 Webhook 设置中的选项：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Laravel\\Paddle\\Http\\Controllers\\WebhookController as CashierController;\r\n\r\n    class WebhookController extends CashierController\r\n    {\r\n        /**\r\n         * 处理订阅付款失败。\r\n         *\r\n         * @param  array  $payload\r\n         * @return void\r\n         */\r\n        public function handleSubscriptionPaymentFailed($payload)\r\n        {\r\n            // 处理订阅付款失败...\r\n        }\r\n    }\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n在测试时，您应该手动测试您的计费流程，以确保您的集成按预期工作。\r\n\r\n对于自动化测试，包括在 CI 环境中执行的测试，你可以使用 [Laravel 的 HTTP 客户端](/docs/laravel/9.x/http-client#testing) 来伪造对 Paddle 的 HTTP 调用。 尽管这不会测试来自 Paddle 的实际响应，但它确实提供了一种无需实际调用 Paddle API 即可测试您的应用程序的方法。\r\n\n","p":"docs/cashier-paddle.html"},{"t":"envoy (Laravel Envoy)","d":"# Laravel Envoy\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n- [编写任务](#writing-tasks)\r\n    - [定义任务](#defining-tasks)\r\n    - [多服务器](#multiple-servers)\r\n    - [配置](#setup)\r\n    - [变量](#variables)\r\n    - [脚本故事](#stories)\r\n    - [任务钩子](#completion-hooks)\r\n- [运行任务](#running-tasks)\r\n    - [任务确认](#confirming-task-execution)\r\n- [消息通知](#notifications)\r\n    - [Slack](#slack)\r\n    - [Discord](#discord)\r\n    - [Telegram](#telegram)\r\n    - [Microsoft Teams](#microsoft-teams)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Envoy](https://github.com/laravel/envoy) 是一套在远程服务器上执行日常任务的工具。使用了 [Blade](/docs/laravel/9.x/blade) 风格语法, 你可以轻松地配置部署任务、Artisan 命令的执行等。目前，Envoy 仅支持 Mac 和 Linux 操作系统。但是可以使用 [WSL2](https://docs.microsoft.com/en-us/windows/wsl/install-win10) 以实现在 Windows 上使用。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，运行 Composer 将 Envoy 安装到你的项目中：\r\n\r\n```shell\r\ncomposer require laravel/envoy --dev\r\n```\r\n\r\n安装 Envoy 之后, Envoy 的可执行文件将出现在你项目的 `vendor/bin` 目录下：\r\n\r\n```shell\r\nphp vendor/bin/envoy\r\n```\r\n\r\n<a name=\"writing-tasks\"></a>\r\n## 编写任务\r\n\r\n<a name=\"defining-tasks\"></a>\r\n### 定义任务\r\n\r\n任务是 Envoy 的基础构建元素, 任务定义了你想在远程服务器上当任务被调用时所执行的 Shell 命令。例如, 你可能定义了一个任务, 在你所有的队列服务器上执行 `php artisan queue:restart` 命令。\r\n\r\n你所有的 Envoy 任务都应该在项目根目录中的 `Envoy.blade.php` 文件中定义。 以下是一个帮助你入门的例子：\r\n\r\n```blade\r\n@servers(['web' => ['user@192.168.1.1'], 'workers' => ['user@192.168.1.2']])\r\n\r\n@task('restart-queues', ['on' => 'workers'])\r\n    cd /home/user/example.com\r\n    php artisan queue:restart\r\n@endtask\r\n```\r\n\r\n\r\n\r\n如你所见，文件顶部定义了一个 `@server` 数组，允许你在任务声明的 `on` 选项中引用这些服务器。`@server` 声明应始终放在一行中。在你的 `@task` 声明中，你应该放置任务被调用执行时你期望在服务器上运行的 Shell 命令。\r\n\r\n<a name=\"local-tasks\"></a>\r\n#### 本地任务\r\n\r\n你可以通过将服务器的 IP 地址指定为 `127.0.0.1` 来强制脚本在本地运行：\r\n\r\n```blade\r\n@servers(['localhost' => '127.0.0.1'])\r\n```\r\n\r\n<a name=\"importing-envoy-tasks\"></a>\r\n#### 导入 Envoy 任务\r\n\r\n使用 `@import` 指令, 你可以从其他的 Envoy 文件导入它们的故事与任务并添加到您的文件中。文件导入后，你可以执行他们所定义的任务，就像这些任务是在你的 Envoy 文件中被定义的一样：\r\n\r\n```blade\r\n@import('vendor/package/Envoy.blade.php')\r\n```\r\n\r\n<a name=\"multiple-servers\"></a>\r\n### 多服务器\r\n\r\nEnvoy 允许你轻松跨多台服务器运行任务。 首先，在 `@server` 声明中添加额外的服务器。每台服务器都应分配一个唯一的名称。一旦你定义了额外的服务器，你可以在任务的 `on` 数组中的列出每一台服务器：\r\n\r\n```blade\r\n@servers(['web-1' => '192.168.1.1', 'web-2' => '192.168.1.2'])\r\n\r\n@task('deploy', ['on' => ['web-1', 'web-2']])\r\n    cd /home/user/example.com\r\n    git pull origin {{ $branch }}\r\n    php artisan migrate --force\r\n@endtask\r\n```\r\n\r\n<a name=\"parallel-execution\"></a>\r\n#### 并行执行\r\n\r\n默认情况下，任务将在每台服务器上串行执行。 换句话说，任务将在第一台服务器上完成运行后，再继续在第二台服务器上执行。如果你想并行运行多个服务器上的任务，请在任务声明中添加 `parallel` 选项：\r\n\r\n```blade\r\n@servers(['web-1' => '192.168.1.1', 'web-2' => '192.168.1.2'])\r\n\r\n@task('deploy', ['on' => ['web-1', 'web-2'], 'parallel' => true])\r\n    cd /home/user/example.com\r\n    git pull origin {{ $branch }}\r\n    php artisan migrate --force\r\n@endtask\r\n```\r\n\r\n\r\n\r\n<a name=\"setup\"></a>\r\n### 配置\r\n\r\n有时，你可能需要在执行 Envoy 任务之前执行一些 PHP 代码。你可以使用 `@setup` 指令声明变量，并在执行任何其他任务之前执行其他常规 PHP 工作：\r\n\r\n```php\r\n@setup\r\n    $now = new DateTime;\r\n@endsetup\r\n```\r\n\r\n如果你需要在任务执行前引用其他PHP文件，你可以在 `Envoy.blade.php` 文件的顶部使用 `@include` 指令：\r\n\r\n```blade\r\n@include('vendor/autoload.php')\r\n\r\n@task('restart-queues')\r\n    # ...\r\n@endtask\r\n```\r\n\r\n<a name=\"variables\"></a>\r\n### 变量\r\n\r\n如果需要，你可以在调用 Envoy 任务时通过在命令行中指定参数，将参数传递给 Envoy 任务：\r\n\r\n```shell\r\nphp vendor/bin/envoy run deploy --branch=master\r\n```\r\n\r\n你可以通过 Blade 的「echo」 语法访问传入任务中的参数。你也可以在任务中使用 `if` 语句和循环。 例如，在执行 `git pull` 命令之前，我们先验证 `$branch` 变量是否存在：\r\n\r\n```blade\r\n@servers(['web' => ['user@192.168.1.1']])\r\n\r\n@task('deploy', ['on' => 'web'])\r\n    cd /home/user/example.com\r\n\r\n    @if ($branch)\r\n        git pull origin {{ $branch }}\r\n    @endif\r\n\r\n    php artisan migrate --force\r\n@endtask\r\n```\r\n\r\n<a name=\"stories\"></a>\r\n### 脚本故事\r\n\r\n你可以将多个同类型任务组合到在一起，我们称之为脚本故事。 例如， 运行 `deploy` 这个故事脚本时会运行定义在其中的 `update-code` 和 `install-dependencies` 两个任务：\r\n\r\n```blade\r\n@servers(['web' => ['user@192.168.1.1']])\r\n\r\n@story('deploy')\r\n    update-code\r\n    install-dependencies\r\n@endstory\r\n\r\n@task('update-code')\r\n    cd /home/user/example.com\r\n    git pull origin master\r\n@endtask\r\n\r\n@task('install-dependencies')\r\n    cd /home/user/example.com\r\n    composer install\r\n@endtask\r\n```\r\n\r\n一旦编写了脚本故事，你可以像调用任务一样调用脚本故事：\r\n\r\n```shell\r\nphp vendor/bin/envoy run deploy\r\n```\r\n\r\n\r\n\r\n<a name=\"completion-hooks\"></a>\r\n### 任务钩子\r\n\r\n当任务和故事脚本运行时，会执行许多钩子。Envoy 支持的钩子类型有 `@before`、`@after`、`@error`、`@success` 和 `@finished`。这些钩子中的所有代码都被解释为 PHP 并在本地执行，而不是在你的任务与之交互的远程服务器上执行。\r\n\r\n你可以根据需要定义任意数量的这些。这些钩子将按照它们在您的 Envoy 脚本中出现的顺序执行。\r\n\r\n<a name=\"hook-before\"></a>\r\n#### `@before`\r\n\r\n在每个任务执行之前，Envoy 脚本中注册的所有 `@before` 钩子都会执行。 `@before` 钩子负责接收将要执行的任务的名称：\r\n\r\n```blade\r\n@before\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@endbefore\r\n```\r\n\r\n<a name=\"completion-after\"></a>\r\n#### `@after`\r\n\r\n每次任务执行后，Envoy 脚本中注册的所有 `@after` 钩子都会执行。 `@after` 钩子负责接收已执行任务的名称：\r\n\r\n```blade\r\n@after\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@endafter\r\n```\r\n\r\n<a name=\"completion-error\"></a>\r\n#### `@error`\r\n\r\n在每次任务失败后（以大于 `0` 的状态码退出执行），Envoy 脚本中注册的所有 `@error` 钩子都将执行。 `@error` 钩子负责接收已执行任务的名称：\r\n\r\n```blade\r\n@error\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@enderror\r\n```\r\n\r\n<a name=\"completion-success\"></a>\r\n#### `@success`\r\n\r\n如果所有任务都已正确执行，则 Envoy 脚本中注册的所有 `@success` 钩子都将执行：\r\n\r\n```blade\r\n@success\r\n    // ...\r\n@endsuccess\r\n```\r\n\r\n<a name=\"completion-finished\"></a>\r\n#### `@finished`\r\n\r\n在所有任务都执行完毕后（不管退出状态如何），所有的 `@finished` 钩子都会被执行。 `@finished` 钩子负责接收已完成任务的状态码，它可能是 `null` 或大于或等于 `0` 的 `integer`：\r\n\r\n```blade\r\n@finished\r\n    if ($exitCode > 0) {\r\n        // There were errors in one of the tasks...\r\n    }\r\n@endfinished\r\n```\r\n\r\n\r\n\r\n<a name=\"running-tasks\"></a>\r\n## 运行任务\r\n\r\n要运行在 `Envoy.blade.php` 文件中定义的任务或故事，请执行 Envoy 的 `run` 命令，传递您要执行的任务或故事的名称。 当任务运行时， Envoy 将运行任务并显示服务器的输出：\r\n\r\n```shell\r\nphp vendor/bin/envoy run deploy\r\n```\r\n\r\n<a name=\"confirming-task-execution\"></a>\r\n### 确认任务执行\r\n\r\n如果你希望在服务器上运行给定任务之前提示你进行确认，则应将 `confirm` 指令添加到任务声明中。 此选项对于破坏性操作特别有用：\r\n\r\n```blade\r\n@task('deploy', ['on' => 'web', 'confirm' => true])\r\n    cd /home/user/example.com\r\n    git pull origin {{ $branch }}\r\n    php artisan migrate\r\n@endtask\r\n```\r\n\r\n<a name=\"notifications\"></a>\r\n## 消息通知\r\n\r\n<a name=\"slack\"></a>\r\n### Slack\r\n\r\nEnvoy 还支持在执行每个任务后向 [Slack](https://slack.com) 发送通知。 `@slack` 指令接受 Slack 钩子 URL 和通道名称。 你可以通过在 Slack 控制面板中创建 Incoming WebHooks 集成来检索你的 webhook URL 。 你应该将整个 webhook URL 传递给 `@slack` 指令：\r\n\r\n你应该将整个 webhook URL 作为第一个参数传递给 `@slack` 指令。`@slack` 指令的第二个参数应该是频道名称（`#channel`）或用户名（`@user`）：\r\n\r\n```blade\r\n@finished\r\n    @slack('webhook-url', '#bots')\r\n@endfinished\r\n```\r\n\r\n默认情况下，Envoy 通知将向通知通道发送一条消息，描述已执行的任务。但是，你可以通过将第三个参数传递给 `@slack` 指令，用你自己的自定义消息覆盖此消息：\r\n\r\n```blade\r\n@finished\r\n    @slack('webhook-url', '#bots', 'Hello, Slack.')\r\n@endfinished\r\n```\r\n\r\n\r\n\r\n<a name=\"discord\"></a>\r\n### Discord\r\n\r\nEnvoy 还支持在每个任务执行后向 [Discord](https://discord.com) 发送通知。 `@discord` 指令接受 Discord hook URL 和消息。你可以通过在服务器设置中创建「Webhook」并选择 Webhook 应该发布到哪个频道来检索你的 Webhook URL。你应该将整个 Webhook URL 传递到 `@discord` 指令中：\r\n\r\n```blade\r\n@finished\r\n    @discord('discord-webhook-url')\r\n@endfinished\r\n```\r\n\r\n<a name=\"telegram\"></a>\r\n### Telegram\r\n\r\nEnvoy 还支持在执行每个任务后向 [Telegram](https://telegram.org) 发送通知。`@telegram` 指令接受Telegram Bot ID 和 Chat ID。你可以使用 [BotFather](https://t.me/botfather) 创建一个新的机器人（Bot）来检索 Bot ID。你可以使用 [@username_to_id_bot](https://t.me/username_to_id_bot) 检索有效的 Chat ID。你应该将整个 Bot ID 和 Chat ID 传递到 `@telegram` 指令中：\r\n\r\n```blade\r\n@finished\r\n    @telegram('bot-id','chat-id')\r\n@endfinished\r\n```\r\n\r\n<a name=\"microsoft-teams\"></a>\r\n### Microsoft Teams\r\n\r\nEnvoy 还支持在每个任务执行后向 [Microsoft Teams](https://www.microsoft.com/en-us/microsoft-teams) 发送通知。 `@microsoftTeams` 指令接受 Teams Webhook（必需）、消息、主题颜色（成功、信息、警告、错误）和一系列选项。您可以通过创建新的 [incoming webhook] (https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/add-incoming-webhook) 来检索你的 Teams Webbook。 Teams API 具有许多其他属性来自定义你的消息框，例如标题、摘要和局部片段。你可以在 [Microsoft Teams 文档](https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/connectors-using?tabs=cURL#example-of-connector-message)。你应该将整个 Webhook URL 传递到 `@microsoftTeams` 指令中：\r\n\r\n```blade\r\n@finished\r\n    @microsoftTeams('webhook-url')\r\n@endfinished\r\n```\r\n\r\n","p":"docs/envoy.html"},{"t":"fortify (Laravel Fortify)","d":"# Laravel Fortify\r\n\r\n- [介绍](#introduction)\r\n    - [Fortify 是什么?](#what-is-fortify)\r\n    - [何时使用 Fortify?](#when-should-i-use-fortify)\r\n- [安装](#installation)\r\n    - [服务提供者](#the-fortify-service-provider)\r\n    - [Fortify 功能](#fortify-features)\r\n    - [禁用视图](#disabling-views)\r\n- [认证](#authentication)\r\n    - [自定义用户认证](#customizing-user-authentication)\r\n    - [自定义身份验证渠道](#customizing-the-authentication-pipeline)\r\n    - [自定义重定向](#customizing-authentication-redirects)\r\n- [双重认证](#two-factor-authentication)\r\n    - [启用双重认证](#enabling-two-factor-authentication)\r\n    - [使用双重认证](#authenticating-with-two-factor-authentication)\r\n    - [禁用双重认证](#disabling-two-factor-authentication)\r\n- [注册](#registration)\r\n    - [自定义注册](#customizing-registration)\r\n- [重置密码](#password-reset)\r\n    - [请求重置密码连接](#requesting-a-password-reset-link)\r\n    - [重置密码](#resetting-the-password)\r\n    - [自定义重置密码](#customizing-password-resets)\r\n- [邮件认证](#email-verification)\r\n    - [保护路由](#protecting-routes)\r\n- [确认密码](#password-confirmation)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Fortify](https://github.com/laravel/fortify) 是一个与前端无关的身份认证后端实现。Fortify 注册了所有实现 Laravel 身份验证功能所需的路由和控制器，包括登录，注册，重置密码，邮件认证等。安装 Fortify 之后，你可以运行 Artisan 命令 `route:list` 来查看 Fortify 已注册的路由。\r\n\r\n由于 Fortify 不提供其自己的用户界面，因此应与你自己的用户界面配对，该用户界面向其注册的路由发出请求。在本文档的其余部分中，我们将进一步讨论如何向这些路由发出请求。\r\n\r\n> 技巧：请记住，Fortify 是一个软件包，旨在使你能够快速开始实施 Laravel 的身份验证功能。你不必非要使用它不可。 你始终可以按照以下说明中提供的文档，自由地与 Laravel 的身份认证服务进行交互，[用户认证](/docs/laravel/9.x/authentication)， [重置密码](/docs/laravel/9.x/passwords) 和 [邮箱认证](/docs/laravel/9.x/verification) documentation. 文档。\r\n\r\n\r\n\r\n<a name=\"what-is-fortify\"></a>\r\n### Fortify 是什么？\r\n\r\n如上所述，Laravel Fortify 是一个与前端无关的身份认证后端实现，Fortify 注册了所有实现 Laravel 身份验证功能所需的路由和控制器，包括登录，注册，重置密码，邮件认证等。\r\n\r\n**你不必使用 Fortify，也可以使用 Laravel 的身份认证功能。** 你始终可以按照 [用户认证](/docs/laravel/9.x/authentication)，[重置密码](/docs/laravel/9.x/passwords) 和 [邮箱认证](/docs/laravel/9.x/verification) 文档中提供的文档来手动与 Laravel 的身份验证服务进行交互。\r\n\r\n如果你是一名新手，在使用 Laravel Fortify 之前不妨尝试使用 [Laravel Breeze](/docs/laravel/9.x/starter-kits) 应用入门套件。Laravel Breeze 为你的应用提供身份认证支架，其中包括使用 [Tailwind CSS](https://tailwindcss.com)。与 Fortify 不同，Breeze 将其路由和控制器直接发布到你的应用程序中。这使你可以学习并熟悉 Laravel 的身份认证功能，然后再允许 Laravel Fortify 为您实现这些功能。\r\n\r\nLaravel Fortify 本质上是采用了 Laravel Breeze 的路由和控制器，且提供了不包含用户界面的扩展。这样，你可以快速搭建应用程序身份认证层的后端实现，而不必依赖于任何特定的前端实现。\r\n\r\n<a name=\"when-should-i-use-fortify\"></a>\r\n### 何时使用 Fortify？\r\n\r\n你可能想知道何时使用 Laravel Fortify。 首先，如果你正在使用 Laravel 的 [应用入门套件](/docs/laravel/9.x/starter-kits)，你不需要安装 Laravel Fortify，因为它已经提供了完整的身份认证实现。\r\n\r\n\r\n\r\n如果你不使用应用入门套件，并且你的应用需要身份认证功能，则有两个选择：手动实现应用的身份认证功能或使用由 Laravel Fortify 提供这些功能的后端实现。\r\n\r\n如果你选择安装 Fortify，你的用户界面将向 Fortify 的身份验证路由发出请求，本文档中对此进行了详细介绍，以便对用户进行身份认证和注册。\r\n\r\n如果你选择手动与 Laravel 的身份认证服务进行交互而不是使用 Fortify，可以按照 [用户认证](/docs/laravel/9.x/authentication)，[重置密码](/docs/laravel/9.x/passwords) 和 [邮箱认证](/docs/laravel/9.x/verification) 文档中提供的说明进行操作。\r\n\r\n<a name=\"laravel-fortify-and-laravel-sanctum\"></a>\r\n#### Laravel Fortify & Laravel Sanctum\r\n\r\n一些开发人员对 [Laravel Sanctum](/docs/laravel/9.x/sanctum) 和 Laravel Fortify 两者之间的区别感到困惑。由于这两个软件包解决了两个不同但相关的问题，因此 Laravel Fortify 和 Laravel Sanctum 并非互斥或竞争的软件包。\r\n\r\nLaravel Sanctum 只关心管理 API 令牌和使用会话 cookie 或令牌来认证现有用户。 Sanctum 不提供任何处理用户注册，重置密码等相关的路由。\r\n\r\n如果你尝试为提供 API 或用作单页应用的后端的应用手动构建身份认证层，那么完全有可能同时使用 Laravel Fortify（用于用户注册，重置密码等）和 Laravel Sanctum（API 令牌管理，会话身份认证）。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，使用 Composer 软件包管理器安装 Fortify：\r\n\r\n```shell\r\ncomposer require laravel/fortify\r\n```\r\n\r\n\r\n\r\n下一步，使用 `vendor:publish` 命令来发布 Fortify 的资源：\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Fortify\\FortifyServiceProvider\"\r\n```\r\n\r\n该命令会将 Fortify 的行为类发布到您的 `app/Actions` 目录，如果该目录不存在，则会创建该目录。此外，还将发布 Fortify 的配置和迁移文件。\r\n\r\n下一步，你应该迁移数据库：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"the-fortify-service-provider\"></a>\r\n### Fortify 服务提供商\r\n\r\n上面讨论的 `vendor:publish` 命令还将发布 `App\\Providers\\FortifyServiceProvider` 类。你应该确保该类已在应用程序的 `config/app.php` 配置文件的 `providers` 数组中注册。\r\n\r\nFortify 服务提供商注册了 Fortify 所发布的行为类，并指导 Fortify 在执行各自的任务时使用它们。\r\n\r\n<a name=\"fortify-features\"></a>\r\n### Fortify 包含的功能\r\n\r\n该 `fortify` 配置文件包含一个 `features` 配置数组。该数组默路定义了 Fortify 的路由和功能。如果你不打算将 Fortify 与 [Laravel Jetstream](https://jetstream.laravel.com) 配合使用，我们建议你仅启用以下功能，这是大多数 Laravel 应用提供的基本身份认证功能：\r\n\r\n```php\r\n'features' => [\r\n    Features::registration(),\r\n    Features::resetPasswords(),\r\n    Features::emailVerification(),\r\n],\r\n```\r\n\r\n<a name=\"disabling-views\"></a>\r\n### 禁用视图\r\n\r\n默认情况下，Fortify 定义用于返回视图的路由，例如登录或注册。但是，如果要构建 JavaScript 驱动的单页应用，那么可能不需要这些路由。因此，你可以通过将 `config/fortify.php` 配置文件中的  `views` 配置值设为 `false` 来禁用这些路由：\r\n\r\n```php\r\n'views' => false,\r\n```\r\n\r\n\r\n\r\n<a name=\"disabling-views-and-password-reset\"></a>\r\n#### 禁用视图 & 重置密码\r\n\r\n如果你选择禁用 Fortify 的视图，并且将为你的应用实现重置密码功能，这时你仍然需要定义一个名为 `password.reset` 的路由，该路由负责显示应用的「重置密码」视图。这是必要的，因为 Laravel 的 `Illuminate\\Auth\\Notifications\\ResetPassword` 通知将通过名为 `password.reset` 的路由生成重置密码 URL。\r\n\r\n<a name=\"authentication\"></a>\r\n## 身份认证\r\n\r\n首先，我们需要指导 Fortify 如何返回「登录」视图。记住，Fortify 是一个无头认证扩展。如果你想要一个已经为你完成的 Laravel 身份认证功能的前端实现， 你应该使用 [应用入门套件](/docs/laravel/9.x/starter-kits)。\r\n\r\n所有的身份认证视图逻辑，都可以使用 `Laravel\\Fortify\\Fortify` 类提供的方法来自定义。通常，你应该从应用的 `App\\Providers\\FortifyServiceProvider` 的 `boot` 方法中调用此方法。Fortify 将负责定义返回此视图的 `/login` 路由：\r\n\r\n    use Laravel\\Fortify\\Fortify;\r\n\r\n    /**\r\n     * 引导任何应用服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Fortify::loginView(function () {\r\n            return view('auth.login');\r\n        });\r\n\r\n        // ...\r\n    }\r\n\r\n你的登录模板应包括一个向 `/login` 发出 POST 请求的表单。 `/login` 表单需要一个 `email` / `username` 和 `password`。 `email` / `username` 字段与 `config/fortify.php` 配置文件中的 `username` 值相匹配。另外，可以提供布尔值 `remember` 字段来指导用户想要使用 Laravel 提供的「记住我」功能。\r\n\r\n\r\n\r\n如果登录尝试成功，Fortify 会将您重定向到通过应用程序 `fortify` 配置文件中的 `home` 配置选项配置的 URI。 如果登录请求是 XHR 请求，将返回 200 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回登录页，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/9.x/validation#quick-displaying-the-validation-errors) 提供给你。 或者，在 XHR 请求的情况下，验证错误将与 422 HTTP 响应一起返回。\r\n\r\n<a name=\"customizing-user-authentication\"></a>\r\n### 自定义用户认证\r\n\r\nFortify 将根据提供的凭据和为您的应用程序配置的身份验证保护自动检索和验证用户。 但是，您有时可能希望对登录凭据的身份验证和用户的检索方式进行完全自定义。 幸运的是，Fortify 允许您使用 `Fortify::authenticateUsing` 方法轻松完成此操作。\r\n\r\n此方法接受接收传入 HTTP 请求的闭包。 闭包负责验证附加到请求的登录凭据并返回关联的用户实例。 如果凭据无效或找不到用户，则闭包应返回 `null` 或 `false` 。 通常，这个方法应该从你的 `FortifyServiceProvider` 的 `boot` 方法中调用：\r\n\r\n```php\r\nuse App\\Models\\User;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Facades\\Hash;\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导应用服务\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Fortify::authenticateUsing(function (Request $request) {\r\n        $user = User::where('email', $request->email)->first();\r\n\r\n        if ($user &&\r\n            Hash::check($request->password, $user->password)) {\r\n            return $user;\r\n        }\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"authentication-guard\"></a>\r\n#### 身份验证看守器\r\n\r\n您可以在应用程序的 `fortify` 文件中自定义 Fortify 使用的身份验证看守器。 但是，您应该确保配置的看守器是 `Illuminate\\Contracts\\Auth\\StatefulGuard` 的实现。 如果您尝试使用 Laravel Fortify 对 SPA 进行身份验证，您应该将 Laravel 的默认 `web` 防护与 [Laravel Sanctum](https://laravel.com/docs/sanctum) 结合使用。\r\n\r\n<a name=\"customizing-the-authentication-pipeline\"></a>\r\n### 自定义身份验证管道\r\n\r\nLaravel Fortify通过可调用类的管道对登录请求进行身份验证。如果您愿意，您可以定义一个自定义的类管道，登录请求应该通过管道传输。每个类都应该有一个 `__invoke` 方法，该方法接收传入 `Illuminate\\Http\\Request` 实例的方法，并且像 [中间件](/docs/laravel/9.x/middleware) 一样，调用一个 `$next` 变量，以便将请求传递给管道中的下一个类。\r\n\r\n要定义自定义管道，可以使用 `Fortify::authenticateThrough` 方法。此方法接受一个闭包，该闭包应返回类数组，以通过管道传递登录请求。通常，应该从 `App\\Providers\\FortifyServiceProvider` 的 `boot` 方法调用此方法。\r\n\r\n下面的示例包含默认管道定义，您可以在自己进行修改时将其用作开始：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Actions\\AttemptToAuthenticate;\r\nuse Laravel\\Fortify\\Actions\\EnsureLoginIsNotThrottled;\r\nuse Laravel\\Fortify\\Actions\\PrepareAuthenticatedSession;\r\nuse Laravel\\Fortify\\Actions\\RedirectIfTwoFactorAuthenticatable;\r\nuse Laravel\\Fortify\\Fortify;\r\nuse Illuminate\\Http\\Request;\r\n\r\nFortify::authenticateThrough(function (Request $request) {\r\n    return array_filter([\r\n            config('fortify.limiters.login') ? null : EnsureLoginIsNotThrottled::class,\r\n            Features::enabled(Features::twoFactorAuthentication()) ? RedirectIfTwoFactorAuthenticatable::class : null,\r\n            AttemptToAuthenticate::class,\r\n            PrepareAuthenticatedSession::class,\r\n    ]);\r\n});\r\n```\r\n\r\n\r\n\r\n<a name=\"customizing-authentication-redirects\"></a>\r\n### 自定义跳转\r\n\r\n如果登录尝试成功，Fortify 会将您重定向到您应用程序 `Fortify` 的配置文件中的 `home` 配置选项的 URI 值. 如果登录请求是 XHR 请求，将返回 200 HTTP 响应。用户注销应用程序后，该用户将被重定向到 `/` 地址。\r\n\r\n如果需要对这种行为进行高级定制，可以将 `LoginResponse` 和 `LogoutResponse` 契约的实现绑定到 Laravel [服务容器](/docs/laravel/9.x/container) 。通常，这应该在你应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `register` 方法中完成：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Contracts\\LogoutResponse;\r\n\r\n/**\r\n * 注册任何应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function register()\r\n{\r\n    $this->app->instance(LogoutResponse::class, new class implements LogoutResponse {\r\n        public function toResponse($request)\r\n        {\r\n            return redirect('/');\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n<a name=\"two-factor-authentication\"></a>\r\n## 双因素认证\r\n\r\n当 Fortify 的双因素身份验证功能启用时，用户需要在身份验证过程中输入一个六位数的数字令牌。该令牌使用基于时间的一次性密码（TOTP）生成，该密码可以从任何与 TOTP 兼容的移动认证应用程序（如Google Authenticator）中检索。\r\n\r\n在开始之前，您应该首先确保应用程序的 `App\\Models\\User` 模型使用 `Laravel\\Fortify\\TwoFactorAuthenticatable` trait：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\nuse Illuminate\\Notifications\\Notifiable;\r\nuse Laravel\\Fortify\\TwoFactorAuthenticatable;\r\n\r\nclass User extends Authenticatable\r\n{\r\n    use Notifiable, TwoFactorAuthenticatable;\r\n}\r\n ```\r\n\r\n接下来，您应该在应用程序中构建一个页面，用户可以在其中管理他们的双因素身份验证设置。该页面应允许用户启用和禁用双因素身份验证，以及重新生成双因素身份验证恢复的代码。\r\n\r\n> 默认情况下， `fortify` 配置文件的 `features` 数组管理着 Fortify 的双因素身份验证设置在修改前需要密码确认。因此，在使用之前，你的应用程序应该实现 Fortify 的 [密码确认](#password-confirmation) 功能 。\r\n\r\n<a name=\"enabling-two-factor-authentication\"></a>\r\n### 启用双因素身份验证\r\n\r\n要启用双重身份验证，你的应用程序应向 Fortify 定义的 `/user/two-factor-authentication` 发出 POST 请求。 如果请求成功，用户将被重定向回之前的 URL，并且 `status` session 变量将设置为 `two-factor-authentication-enabled`。 你可以在模板中检测这个 `status` session 变量以显示适当的成功消息。 如果请求是 XHR 请求，将返回  `200` HTTP 响应：\r\n\r\n```html\r\n@if (session('status') == 'two-factor-authentication-enabled')\r\n    <div class=\"mb-4 font-medium text-sm text-green-600\">\r\n        Two factor authentication has been enabled.\r\n    </div>\r\n@endif\r\n```\r\n\r\n接下来，你应该显示双重身份验证二维码，供用户扫描到他们的身份验证器应用程序中。 如果你使用 Blade 呈现应用程序的前端，则可以使用用户实例上可用的 `twoFactorQrCodeSvg` 方法检索二维码 SVG：\r\n\r\n```php\r\n$request->user()->twoFactorQrCodeSvg();\r\n```\r\n\r\n如果你正在构建由 JavaScript 驱动的前端，你可以向 `/user/two-factor-qr-code` 发出 XHR GET 请求以检索用户的双重身份验证二维码。 将返回一个包含 `svg` 键的 JSON 对象。\r\n\r\n<a name=\"displaying-the-recovery-codes\"></a>\r\n#### 显示恢复代码\r\n\r\n你还应该显示用户的两个因素恢复代码。这些恢复代码允许用户在无法访问其移动设备时进行身份验证。如果你使用 Blade 来渲染应用程序的前端，你可以通过经过身份验证的用户实例访问恢复代码：\r\n\r\n```php\r\n(array) $request->user()->recoveryCodes()\r\n```\r\n\r\n如果你正在构建一个 JavaScript 驱动的前端，你可以向 `/user/two-factor-recovery-codes` 端点发出 XHR GET 请求。此端点将返回一个包含用户恢复代码的 JSON 数组。\r\n\r\n\r\n要重新生成用户的恢复代码，您的应用程序应向 `/user/two-factor-recovery-codes` 端点发出 POST 请求。\r\n\r\n<a name=\"authenticating-with-two-factor-authentication\"></a>\r\n### 使用双因素身份验证进行身份验证\r\n\r\n在身份验证过程中，Fortify 将自动将用户重定向到您的应用程序的双因素身份验证检查页面。 但是，如果您的应用程序正在发出 XHR 登录请求，则在成功进行身份验证尝试后返回的 JSON 响应将包含一个具有 `two_factor` 布尔属性的 JSON 对象。 您应该检查此值以了解是否应该重定向到应用程序的双因素身份验证检查页面。\r\n\r\n要开始实现两因素身份验证功能，我们需要指示 Fortify 如何返回我们的双因素身份验证检查页面。 Fortify 的所有身份验证视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。 通常，您应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Fortify::twoFactorChallengeView(function () {\r\n        return view('auth.two-factor-challenge');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nFortify 将负责定义返回此视图的 `/two-factor-challenge` 路由。 您的 `two-factor-challenge` 模板应包含一个向 `/two-factor-challenge` 端点发出 POST 请求的表单。 `/two-factor-challenge` 操作需要包含有效 TOTP 令牌的 `code` 字段或包含用户恢复代码之一的 `recovery_code` 字段。\r\n\r\n如果登录尝试成功，Fortify 会将用户重定向到通过应用程序的 `fortify` 配置文件中的 `home` 配置选项配置的 URI。 如果登录请求是 XHR 请求，将返回 204 HTTP 响应。\r\n\r\n\r\n\r\n如果请求不成功，用户将被重定向回两因素挑战屏幕，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/9.x/验证#快速显示验证错误）。 或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n<a name=\"禁用双因素身份验证\"></a>\r\n### 禁用两因素身份验证\r\n\r\n要禁用双因素身份验证，您的应用程序应向 `/user/two-factor-authentication` 端点发出 DELETE 请求。 请记住，Fortify 的两个因素身份验证端点在被调用之前需要 [密码确认](#password-confirmation)。\r\n\r\n<a name=\"registration\"></a>\r\n## 注册\r\n\r\n要开始实现我们应用程序的注册功能，我们需要指示 Fortify 如何返回我们的“注册”视图。 请记住，Fortify 是一个无头身份验证库。 如果你想要一个已经为你完成的 Laravel 身份验证功能的前端实现，你应该使用 [application starter kit](/docs/laravel/9.x/starter-kits)。\r\n\r\nFortify 的所有视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。 通常，您应该从 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Fortify::registerView(function () {\r\n        return view('auth.register');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nFortify 将负责定义返回此视图的 `/register` 路由。 您的 `register` 模板应包含一个向 Fortify 定义的 `/register` 端点发出 POST 请求的表单。\r\n\r\n`/register` 端点需要一个字符串 `name`、字符串电子邮件地址/用户名、`password` 和 `password_confirmation` 字段。 电子邮件/用户名字段的名称应与应用程序的“fortify”配置文件中定义的“用户名”配置值匹配。\r\n\r\n\r\n\r\n如果注册尝试成功，Fortify 会将用户重定向到通过应用程序的 `fortify` 配置文件中的 `home` 配置选项配置的 URI。 如果登录请求是 XHR 请求，将返回 200 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回注册屏幕，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/9.x/validation#快速显示验证错误）。 或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n<a name=\"customizing-registration\"></a>\r\n### 定制注册\r\n\r\n可以通过修改安装 Laravel Fortify 时生成的 `App\\Actions\\Fortify\\CreateNewUser` 操作来自定义用户验证和创建过程。\r\n\r\n<a name=\"password-reset\"></a>\r\n## 重设密码\r\n\r\n<a name=\"requesting-a-password-reset-link\"></a>\r\n### 请求密码重置链接\r\n\r\n要开始实现我们应用程序的密码重置功能，我们需要指示 Fortify 如何返回我们的“忘记密码”视图。 请记住，Fortify 是一个无头身份验证库。 如果你想要一个已经为你完成的 Laravel 身份验证功能的前端实现，你应该使用 [application starter kit](/docs/laravel/9.x/starter-kits)。\r\n\r\nFortify 的所有视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。 通常，您应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Fortify::requestPasswordResetLinkView(function () {\r\n        return view('auth.forgot-password');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\r\n\r\nFortify 将负责定义返回此视图的 `/forgot-password` 端点。 你的 `forgot-password` 模板应该包含一个向 `/forgot-password` 端点发出 POST 请求的表单。\r\n\r\n`/forgot-password` 端点需要一个字符串 `email` 字段。 此字段/数据库列的名称应与应用程序的 `fortify` 配置文件中的 `email` 配置值匹配。\r\n\r\n<a name=\"handling-the-password-reset-link-request-response\"></a>\r\n#### 处理密码重置链接请求响应\r\n\r\n如果密码重置链接请求成功，Fortify 会将用户重定向回 `/forgot-password` 端点，并向用户发送一封电子邮件，其中包含可用于重置密码的安全链接。 如果请求是 XHR 请求，将返回 200 HTTP 响应。\r\n\r\n在成功请求后被重定向回 `/forgot-password` 端点后，`status` 会话变量可用于显示密码重置链接请求尝试的状态。 此会话变量的值将匹配应用程序的“密码”[语言文件](/docs/laravel/9.x/localization) 中定义的翻译字符串之一：\r\n\r\n```html\r\n@if (session('status'))\r\n    <div class=\"mb-4 font-medium text-sm text-green-600\">\r\n        {{ session('status') }}\r\n    </div>\r\n@endif\r\n```\r\n\r\n如果请求不成功，用户将被重定向回请求密码重置链接屏幕，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/9.x) 提供给您/validation#quick-displaying-the-validation-errors）。 或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n<a name=\"resetting-the-password\"></a>\r\n### 重设密码\r\n\r\n为了完成应用程序的密码重置功能，我们需要指示 Fortify 如何返回我们的“重置密码”视图。\r\n\r\n\r\n\r\nFortify 的所有视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。 通常，您应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Fortify::resetPasswordView(function ($request) {\r\n        return view('auth.reset-password', ['request' => $request]);\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nFortify 将负责定义显示此视图的路线。 您的 `reset-password` 模板应该包含一个向 `/reset-password` 发出 POST 请求的表单。\r\n\r\n`/reset-password` 端点需要一个字符串`email` 字段、一个`password` 字段、一个`password_confirmation` 字段和一个名为`token` 的隐藏字段，其中包含`request()->route(' 的值令牌'）`。 “email”字段/数据库列的名称应与应用程序的“fortify”配置文件中定义的“email”配置值匹配。\r\n\r\n<a name=\"handling-the-password-reset-response\"></a>\r\n#### 处理密码重置响应\r\n\r\n如果密码重置请求成功，Fortify 将重定向回 `/login` 路由，以便用户可以使用新密码登录。 此外，还将设置一个 `status` 会话变量，以便您可以在登录屏幕上显示重置的成功状态：\r\n\r\n```blade\r\n@if (session('status'))\r\n    <div class=\"mb-4 font-medium text-sm text-green-600\">\r\n        {{ session('status') }}\r\n    </div>\r\n@endif\r\n```\r\n\r\n如果请求是 XHR 请求，将返回 200 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回重置密码屏幕，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/9.x/validation #快速显示验证错误）。 或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n\r\n\r\n<a name=\"customizing-password-resets\"></a>\r\n### 自定义密码重置\r\n\r\n可以通过修改安装 Laravel Fortify 时生成的 `App\\Actions\\ResetUserPassword` 操作来自定义密码重置过程。\r\n\r\n<a name=\"email-verification\"></a>\r\n## 电子邮件验证\r\n\r\n注册后，您可能希望用户在继续访问您的应用程序之前验证他们的电子邮件地址。 要开始使用，请确保在 `fortify` 配置文件的 `features` 数组中启用了 `emailVerification` 功能。 接下来，你应该确保你的 App\\Models\\User 类实现了 Illuminate\\Contracts\\Auth\\MustVerifyEmail 接口。\r\n\r\n完成这两个设置步骤后，新注册的用户将收到一封电子邮件，提示他们验证其电子邮件地址的所有权。 但是，我们需要通知 Fortify 如何显示电子邮件验证屏幕，通知用户他们需要点击电子邮件中的验证链接。\r\n\r\nFortify 的所有视图的渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。 通常，您应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导所有应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Fortify::verifyEmailView(function () {\r\n        return view('auth.verify-email');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n当用户被 Laravel 内置的 `verified` 中间件重定向到 `/email/verify` 端点时，Fortify 将负责定义显示此视图的路由。\r\n\r\n您的“验证电子邮件”模板应包含一条信息性消息，指示用户单击发送到其电子邮件地址的电子邮件验证链接。\r\n\r\n<a name=\"resending-email-verification-links\"></a>\r\n\r\n\r\n#### 重新发送电子邮件验证链接\r\n\r\n如果您愿意，您可以在应用程序的 `verify-email` 模板中添加一个按钮，该按钮会触发对 `/email/verification-notification` 端点的 POST 请求。 当此端点收到请求时，将通过电子邮件将新的验证电子邮件链接发送给用户，如果先前的验证链接被意外删除或丢失，则允许用户获取新的验证链接。\r\n\r\n如果重新发送验证链接电子邮件的请求成功，Fortify 将使用 `status` 会话变量将用户重定向回 `/email/verify` 端点，允许您向用户显示信息性消息，通知他们操作已完成成功的。 如果请求是 XHR 请求，将返回 202 HTTP 响应：\r\n\r\n```blade\r\n@if (session('status') == 'verification-link-sent')\r\n    <div class=\"mb-4 font-medium text-sm text-green-600\">\r\n        新的电子邮件验证链接已通过电子邮件发送给您！\r\n    </div>\r\n@endif\r\n```\r\n\r\n<a name=\"protecting-routes\"></a>\r\n### 保护路线\r\n\r\n要指定一个路由或一组路由要求用户验证他们的电子邮件地址，您应该将 Laravel 的内置 `verified` 中间件附加到该路由。 该中间件在您的应用程序的 `App\\Http\\Kernel` 类中注册：\r\n\r\n```php\r\nRoute::get('/dashboard', function () {\r\n    // ...\r\n})->middleware(['verified']);\r\n```\r\n\r\n<a name=\"password-confirmation\"></a>\r\n## 确认密码\r\n\r\n在构建应用程序时，您可能偶尔会有一些操作需要用户在执行操作之前确认其密码。 通常，这些路由受到 Laravel 内置的 `password.confirm` 中间件的保护。\r\n\r\n要开始实现密码确认功能，我们需要指示 Fortify 如何返回应用程序的“密码确认”视图。 请记住，Fortify 是一个无头身份验证库。 如果你想要一个已经为你完成的 Laravel 身份验证功能的前端实现，你应该使用 [application starter kit](/docs/laravel/9.x/starter-kits)。\r\n\r\n\r\n\r\nFortify 的所有视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。 通常，您应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导所有应用程序服务。\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Fortify::confirmPasswordView(function () {\r\n        return view('auth.confirm-password');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nFortify 将负责定义返回此视图的 `/user/confirm-password` 端点。 您的 `confirm-password` 模板应包含一个表单，该表单向 `/user/confirm-password` 端点发出 POST 请求。 `/user/confirm-password` 端点需要一个包含用户当前密码的 `password` 字段。\r\n\r\n如果密码与用户的当前密码匹配，Fortify 会将用户重定向到他们尝试访问的路由。 如果请求是 XHR 请求，将返回 201 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回确认密码屏幕，验证错误将通过共享的 `$errors` Blade 模板变量提供给您。 或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n","p":"docs/fortify.html"},{"t":"homestead (Laravel Homestead)","d":"# Laravel Homestead\r\n\r\n- [介绍](#introduction)\r\n- [安装与设置](#installation-and-setup)\r\n    - [第一步](#first-steps)\r\n    - [配置 Homestead](#configuring-homestead)\r\n    - [配置 Nginx 站点](#configuring-nginx-sites)\r\n    - [配置服务](#configuring-services)\r\n    - [启动 Vagrant Box](#launching-the-vagrant-box)\r\n    - [为项目单独安装](#per-project-installation)\r\n    - [安装可选功能](#installing-optional-features)\r\n    - [别名](#aliases)\r\n- [更新 Homestead](#updating-homestead)\r\n- [日常使用方法](#daily-usage)\r\n    - [通过 SSH 连接](#connecting-via-ssh)\r\n    - [添加其他站点](#adding-additional-sites)\r\n    - [环境变量](#environment-variables)\r\n    - [端口](#ports)\r\n    - [多 PHP 版本](#php-versions)\r\n    - [连接数据库](#connecting-to-databases)\r\n    - [数据库备份](#database-backups)\r\n    - [配置 Cron 调度器](#configuring-cron-schedules)\r\n    - [配置 MailHog](#configuring-mailhog)\r\n    - [配置 Minio](#configuring-minio)\r\n    - [Laravel Dusk](#laravel-dusk)\r\n    - [共享你的环境](#sharing-your-environment)\r\n- [调试与性能分析](#debugging-and-profiling)\r\n    - [使用 Xdebug 调试 Web 请求](#debugging-web-requests)\r\n    - [调试 CLI 应用程序](#debugging-cli-applications)\r\n    - [使用 Blackfire 为应用程序分析性能](#profiling-applications-with-blackfire)\r\n- [网络接口](#network-interfaces)\r\n- [扩展 Homestead](#extending-homestead)\r\n- [针对虚拟机软件的特殊设置](#provider-specific-settings)\r\n    - [VirtualBox](#provider-specific-virtualbox)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 努力让整个 PHP 开发体验愉快，包括你的本地开发环境。 [Laravel Homestead](https://github.com/laravel/homestead) 是 Lavarel 官方预封装的 Vagrant Box 套件，它为你提供了一个绝佳的开发环境，而无需你在本地机器上安装 PHP 、Web 服务器及任何其他服务器软件。\r\n\r\n[Vagrant](https://www.vagrantup.com) 提供了一种简单、优雅的方式来管理和配置虚拟机。 Vagrant Box 完全是一次性的。如果出现问题，你可以在几分钟内销毁并重新创建 Box !\r\n\r\nHomestead 可以在任何 Windows、 macOS 或 Linux 系统上运行，它预装好了  Nginx、 PHP、 MySQL、 PostgreSQL、 Redis、 Memcached、 Node 以及开发令人惊叹的 Laravel 应用程序所需的所有其他软件。\r\n\r\n> 注意：如果你使用的是 Windows ，你可能需要启用硬件虚拟化（ VT-x ）。该功能通常需要通过你的 BIOS 启用。如果你在 UEFI 系统上使用 Hyper-V ，则可能还需要禁用 Hyper-V 才能访问 VT-x 。\r\n\r\n\r\n\r\n<a name=\"included-software\"></a>\r\n### 内置软件\r\n\r\n<style>\r\n    #software-list > ul {\r\n        column-count: 2; -moz-column-count: 2; -webkit-column-count: 2;\r\n        column-gap: 5em; -moz-column-gap: 5em; -webkit-column-gap: 5em;\r\n        line-height: 1.9;\r\n    }\r\n</style>\r\n\r\n<div id=\"software-list\" markdown=\"1\">\r\n- Ubuntu 20.04\r\n- Git\r\n- PHP 8.1\r\n- PHP 8.0\r\n- PHP 7.4\r\n- PHP 7.3\r\n- PHP 7.2\r\n- PHP 7.1\r\n- PHP 7.0\r\n- PHP 5.6\r\n- Nginx\r\n- MySQL 8.0\r\n- lmm\r\n- Sqlite3\r\n- PostgreSQL 13\r\n- Composer\r\n- Node (包括 Yarn， Bower， Grunt 和 Gulp)\r\n- Redis\r\n- Memcached\r\n- Beanstalkd\r\n- Mailhog\r\n- avahi\r\n- ngrok\r\n- Xdebug\r\n- XHProf / Tideways / XHGui\r\n- wp-cli\r\n</div>\r\n\r\n<a name=\"optional-software\"></a>\r\n### 可选软件\r\n\r\n<style>\r\n    #software-list > ul {\r\n        column-count: 2; -moz-column-count: 2; -webkit-column-count: 2;\r\n        column-gap: 5em; -moz-column-gap: 5em; -webkit-column-gap: 5em;\r\n        line-height: 1.9;\r\n    }\r\n</style>\r\n\r\n<div id=\"software-list\" markdown=\"1\">\r\n- Apache\r\n- Blackfire\r\n- Cassandra\r\n- Chronograf\r\n- CouchDB\r\n- Crystal & Lucky Framework\r\n- Docker\r\n- Elasticsearch\r\n- EventStoreDB\r\n- Gearman\r\n- Go\r\n- Grafana\r\n- InfluxDB\r\n- MariaDB\r\n- Meilisearch\r\n- MinIO\r\n- MongoDB\r\n- Neo4j\r\n- Oh My Zsh\r\n- Open Resty\r\n- PM2\r\n- Python\r\n- R\r\n- RabbitMQ\r\n- RVM (Ruby 版本管理)\r\n- Solr\r\n- TimescaleDB\r\n- Trader <small>(PHP 扩展)</small>\r\n- Webdriver & Laravel Dusk Utilities\r\n</div>\r\n\r\n<a name=\"installation-and-setup\"></a>\r\n## 安装 & 设置\r\n\r\n<a name=\"first-steps\"></a>\r\n### 第一步\r\n\r\n在你启动 Homestead 环境之前， 你必须安装 [Vagrant](https://www.vagrantup.com/downloads.html) 及以下受支持的虚拟机之一：\r\n\r\n- [VirtualBox 6.1.x](https://www.virtualbox.org/wiki/Downloads)\r\n- [Parallels](https://www.parallels.com/products/desktop/)\r\n\r\n以上所有软件均针对不同的操作系统提供了易于使用的可视化安装包。\r\n\r\n\r\n\r\n如果要使用 Parallels 提供虚拟机服务，你需要安装 [Parallels Vagrant 插件](https://github.com/Parallels/vagrant-parallels)。这个插件是免费的。\r\n\r\n<a name=\"installing-homestead\"></a>\r\n#### 安装 Homestead\r\n\r\n你可以通过将 Homestead 存储库克隆到你的主机上来安装 Homestead。 考虑将存储库克隆到 `home` 目录中的 `Homestead` 文件夹中，因为 Homestead 虚拟机将作为所有 Laravel 应用程序的主机。 在本文档中，我们将此目录称为你的「Homestead 目录」：\r\n\r\n```shell\r\ngit clone https://github.com/laravel/homestead.git ~/Homestead\r\n```\r\n\r\n克隆 Laravel Homestead 存储库后，你应该检出 `release` 分支。 这个分支总是包含 Homestead 的最新稳定版本：\r\n\r\n```shell\r\ncd ~/Homestead\r\n\r\ngit checkout release\r\n```\r\n\r\n接下来，从 Homestead 目录执行 `bash init.sh` 命令以创建 `Homestead.yaml` 配置文件。 `Homestead.yaml` 文件是你为 Homestead 安装配置所有设置的地方。 这个文件将被放置在 Homestead 目录中：\r\n\r\n```shell\r\n# macOS / Linux...\r\nbash init.sh\r\n\r\n# Windows...\r\ninit.bat\r\n```\r\n\r\n<a name=\"configuring-homestead\"></a>\r\n### 配置 Homestead\r\n\r\n<a name=\"setting-your-provider\"></a>\r\n#### 设置提供服务的虚拟机程序\r\n\r\n`Homestead.yaml` 文件中的 `provider` 键指示应该使用哪个 Vagrant 提供虚拟机服务：`virtualbox` 或 `parallels`：\r\n\r\n    provider: virtualbox\r\n\r\n> 注意：如果你使用的是 Apple Silicon，你应该将 `box: laravel/homestead-arm` 添加到你的 `Homestead.yaml` 文件中。 Apple Silicon 下需要使用 Parallels 提供虚拟机服务。\r\n\r\n<a name=\"configuring-shared-folders\"></a>\r\n#### 配置共享文件夹\r\n\r\n`Homestead.yaml` 文件的 `folders` 属性列出了你希望与 Homestead 环境共享的所有文件夹。 当这些文件夹中的文件发生更改时，它们将在你的本地机器和 Homestead 虚拟环境之间保持同步。 你可以根据需要配置任意数量的共享文件夹：\r\n\r\n```yaml\r\nfolders:\r\n    - map: ~/code/project1\r\n      to: /home/vagrant/project1\r\n```\r\n\r\n> 注意：Windows 用户不应使用 `~/` 路径语法，而应使用其项目的完整路径，例如 `C:\\Users\\user\\Code\\project1`。\r\n\r\n\r\n你应该始终将单个应用程序映射到它们自己的文件夹映射，而不是映射包含所有应用程序的单个大目录。 映射文件夹时，虚拟机需要跟踪文件夹中*每个*文件的所有磁盘 IO。 如果文件夹中有大量文件，性能可能会降低：\r\n\r\n```yaml\r\nfolders:\r\n    - map: ~/code/project1\r\n      to: /home/vagrant/project1\r\n    - map: ~/code/project2\r\n      to: /home/vagrant/project2\r\n```\r\n\r\n> 注意：在使用 Homestead 时，你永远不应该挂载 `.`（当前目录）。 这会导致 Vagrant 不会将当前文件夹映射到 `/vagrant`，并且会在配置时破坏可选功能并导致意外结果。\r\n\r\n要启用 [NFS](https://www.vagrantup.com/docs/synced-folders/nfs.html)，你可以在文件夹映射中添加一个 `type` 选项：\r\n\r\n```yaml\r\nfolders:\r\n    - map: ~/code/project1\r\n      to: /home/vagrant/project1\r\n      type: \"nfs\"\r\n```\r\n\r\n> 注意：在 Windows 上使用 NFS 时，应考虑安装 [vagrant-winnfsd](https://github.com/winnfsd/vagrant-winnfsd) 插件。 该插件将维护 Homestead 虚拟机中文件和目录的正确用户/组权限。\r\n\r\n你还可以通过在 `options` 键下列出它们来传递 Vagrant 的 [同步文件夹](https://www.vagrantup.com/docs/synced-folders/basic_usage.html) 支持的任何选项：\r\n\r\n```yaml\r\nfolders:\r\n    - map: ~/code/project1\r\n      to: /home/vagrant/project1\r\n      type: \"rsync\"\r\n      options:\r\n          rsync__args: [\"--verbose\", \"--archive\", \"--delete\", \"-zz\"]\r\n          rsync__exclude: [\"node_modules\"]\r\n```\r\n\r\n<a name=\"configuring-nginx-sites\"></a>\r\n### 配置 Nginx 站点\r\n\r\n不熟悉 Nginx？ 没问题。 你的 `Homestead.yaml` 文件的 `sites` 属性允许你轻松地将「域」映射到 Homestead 环境中的文件夹。 Homestead.yaml 文件中包含一个示例站点配置。 同样，你可以根据需要向 Homestead 环境添加任意数量的站点。 Homestead 可以为你正在开发的每个 Laravel 应用程序提供方便的虚拟化环境：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n```\r\n\r\n\r\n\r\n如果你在配置 Homestead 虚拟机后更改了 `sites` 属性，你应该在终端中执行 `vagrant reload --provision` 命令来更新虚拟机上的 Nginx 配置。\r\n\r\n> 注意：Homestead 脚本被构建为尽可能具有幂等性。 但是，如果你在配置时遇到问题，你应该通过执行 `vagrant destroy && vagrant up` 命令来销毁和重建机器。\r\n\r\n<a name=\"hostname-resolution\"></a>\r\n#### 主机名解析\r\n\r\nHomestead 使用`mDNS` 发布主机名以进行自动主机解析。 如果你在 `Homestead.yaml` 文件中设置 `hostname: homestead`，主机将在 `homestead.local` 中可用。 macOS、iOS 和 Linux 桌面发行版默认包含 `mDNS` 支持。 如果你使用的是 Windows，则必须安装 [Bonjour Print Services for Windows](https://support.apple.com/kb/DL999?viewlocale=en_US&locale=en_US)。\r\n\r\n使用自动主机名最适合 Homestead 的 [每个项目安装](#per-project-installation)。 如果你在单个 Homestead 实例上托管多个站点，你可以将你网站的「域」添加到你机器上的 `hosts` 文件中。 `hosts` 文件会将你对 Homestead 站点的请求重定向到你的 Homestead 虚拟机中。 在 macOS 和 Linux 上，此文件位于`/etc/hosts`。 在 Windows 上，它位于「C:\\Windows\\System32\\drivers\\etc\\hosts」。 你添加到此文件的行将如下所示：\r\n\r\n    192.168.56.56  homestead.test\r\n\r\n确保列出的 IP 地址是你在 `Homestead.yaml` 文件中设置的地址。 将域添加到 `hosts` 文件并启动 Vagrant 框后，你将能够通过 Web 浏览器访问该站点：\r\n\r\n```shell\r\nhttp://homestead.test\r\n```\r\n\r\n\r\n\r\n<a name=\"configuring-services\"></a>\r\n### 配置服务\r\n\r\nHomestead 默认会启动好几个服务； 但你可以在配置的时候自定义启用或禁用哪些服务。 例如，你可以通过修改 `Homestead.yaml` 文件中的 `services` 选项来启用 PostgreSQL 并禁用 MySQL：\r\n\r\n```yaml\r\nservices:\r\n    - enabled:\r\n        - \"postgresql\"\r\n    - disabled:\r\n        - \"mysql\"\r\n```\r\n\r\n指定的服务将根据它们在 `enabled` 和 `disabled` 指令中的顺序启动或停止。\r\n\r\n<a name=\"launching-the-vagrant-box\"></a>\r\n### 启动 The Vagrant Box\r\n\r\n你根据自己的需求修改 `Homestead.yaml` 后，你可以通过在 Homestead 目录运行 `vagrant up` 命令来启动 Vagrant 虚拟机。 Vagrant 将启动虚拟机并自动配置你的共享文件夹和 Nginx 站点。\r\n\r\n要销毁虚拟机实例，你可以使用 `vagrant destroy` 命令。\r\n\r\n<a name=\"per-project-installation\"></a>\r\n### 为项目单独安装\r\n\r\n你可以为你管理的每个项目配置一个 Homestead 实例，而不是全局安装 Homestead 并在所有项目中共享相同的 Homestead 虚拟机。 如果你希望随项目一起提供 `Vagrantfile`，允许其他人在克隆项目的存储库后立即 `vagrant up`，则为每个项目安装 Homestead 可能会有所帮助。\r\n\r\n你可以使用 Composer 包管理器将 Homestead 安装到你的项目中：\r\n\r\n```shell\r\ncomposer require laravel/homestead --dev\r\n```\r\n\r\n安装 Homestead 后，调用 Homestead 的 `make` 命令为你的项目生成 `Vagrantfile` 和 `Homestead.yaml` 文件。 这些文件将放置在项目的根目录中。 `make` 命令将自动配置 `Homestead.yaml` 文件中的站点和文件夹指令：\r\n\r\n```shell\r\n# macOS / Linux...\r\nphp vendor/bin/homestead make\r\n\r\n# Windows...\r\nvendor\\\\bin\\\\homestead make\r\n```\r\n\r\n\r\n\r\n接下来，在终端中运行 `vagrant up` 命令并在浏览器中通过 `http://homestead.test` 访问你的项目。 请记住，如果你不使用自动 [主机名解析](#hostname-resolution)，你仍然需要为 `homestead.test` 或你选择的域在 `/etc/hosts` 文件中添加一个主机名映射。\r\n\r\n<a name=\"installing-optional-features\"></a>\r\n### 安装可选功能\r\n\r\n使用 `Homestead.yaml` 文件中的 `features` 选项可以安装可选软件。 大多数功能可以使用布尔值启用或禁用，部分功能允许使用多个配置选项：\r\n\r\n```yaml\r\nfeatures:\r\n    - blackfire:\r\n        server_id: \"server_id\"\r\n        server_token: \"server_value\"\r\n        client_id: \"client_id\"\r\n        client_token: \"client_value\"\r\n    - cassandra: true\r\n    - chronograf: true\r\n    - couchdb: true\r\n    - crystal: true\r\n    - docker: true\r\n    - elasticsearch:\r\n        version: 7.9.0\r\n    - eventstore: true\r\n        version: 21.2.0\r\n    - gearman: true\r\n    - golang: true\r\n    - grafana: true\r\n    - influxdb: true\r\n    - mariadb: true\r\n    - meilisearch: true\r\n    - minio: true\r\n    - mongodb: true\r\n    - neo4j: true\r\n    - ohmyzsh: true\r\n    - openresty: true\r\n    - pm2: true\r\n    - python: true\r\n    - r-base: true\r\n    - rabbitmq: true\r\n    - rvm: true\r\n    - solr: true\r\n    - timescaledb: true\r\n    - trader: true\r\n    - webdriver: true\r\n```\r\n\r\n<a name=\"elasticsearch\"></a>\r\n#### Elasticsearch\r\n\r\n你可以指定支持的 Elasticsearch 版本，该版本必须是确切的版本号 (major.minor.patch)。 默认安装将创建一个名为「homestead」的集群。 你永远不应该给 Elasticsearch 超过操作系统一半的内存，所以确保你的 Homestead 虚拟机至少有 Elasticsearch 分配的两倍。\r\n\r\n> 技巧：查看 [Elasticsearch 文档](https://www.elastic.co/guide/en/elasticsearch/reference/current) 了解如何自定义你的配置。\r\n\r\n\r\n\r\n<a name=\"mariadb\"></a>\r\n#### MariaDB\r\n\r\n启用 MariaDB 将会移除 MySQL 并安装 MariaDB。MariaDB 通常是 MySQL 的替代品，完全兼容 MySQL，所以在应用数据库配置中你仍然可以使用 `mysql` 驱动。\r\n\r\n<a name=\"mongodb\"></a>\r\n#### MongoDB\r\n\r\n默认安装的 MongoDB 将会设置数据库用户名为 `homestead` 及对应的密码为 `secret`。\r\n\r\n<a name=\"neo4j\"></a>\r\n#### Neo4j\r\n\r\n[Neo4j](https://neo4j.com/) 是一个图形数据库，默认安装的 Neo4j 会设置数据库用户名为 `homestead` 及对应的密码 `secret`。要通过浏览器访问 Neo4j ，请通过 Web 浏览器访问 `http://homestead.test:7474`。默认情况下，服务预设了端口 `7687`（Bolt）、`7474`（HTTP）和 `7473`（HTTPS）为来自 Neo4j 客户端的请求提供服务。\r\n\r\n<a name=\"aliases\"></a>\r\n### 系统命令别名\r\n\r\n您可以通过修改 Homestead 目录中的 `aliases` 文件将 Bash 命令别名添加到 Homestead 虚拟机：\r\n\r\n```shell\r\nalias c='clear'\r\nalias ..='cd ..'\r\n```\r\n\r\n当你更新完 `aliases` 文件后，你需要通过` vagrant reload --provision ` 命令重启 Homestead 机器，以确保新的别名在机器上生效。\r\n\r\n<a name=\"updating-homestead\"></a>\r\n## 更新 Homestead\r\n\r\n更新 Homestead 之前确保你已经在 Homestead 目录下通过如下命令移除了当前的虚拟机：\r\n\r\n```shell\r\nvagrant destroy\r\n```\r\n\r\n接下来，需要更新 Homestead 源码，如果你已经克隆仓库到本地，可以在项目根目录下运行如下命令进行更新：\r\n\r\n```shell\r\ngit fetch\r\n\r\ngit pull origin release\r\n```\r\n\r\n这些命令会从 Github 存储库中拉取最新的 Homestead 仓库代码到本地，包括最新的标签版本。你可以在 Homestead 的 [GitHub 发布页面](https://github.com/laravel/homestead/releases) 上找到最新的稳定版本。\r\n\r\n\r\n如果你是通过 Composer 在指定 Laravel 项目中安装的 Homestead，需要确保 `composer.json` 中包含了 `\"laravel/homestead\": \"^12\"`，然后更新这个依赖：\r\n\r\n```shell\r\ncomposer update\r\n```\r\n\r\n之后，你需要通过 `vagrant box update` 命令更新 Vagrant：\r\n\r\n```shell\r\nvagrant box update\r\n```\r\n\r\n接下来，你可以从 Homestead 目录下运行 `bash init.sh` 命令来更新 Homestead 额外的配置文件，你会被询问是否覆盖已存在的 `Homestead.yaml`、`after.sh` 以及 `aliases` 文件：\r\n\r\n```shell\r\n# macOS / Linux...\r\nbash init.sh\r\n\r\n# Windows...\r\ninit.bat\r\n```\r\n\r\n最后，你需要重新生成新的 Homestead 虚拟机来使用最新安装的 Vagrant：\r\n\r\n```shell\r\nvagrant up\r\n```\r\n\r\n<a name=\"daily-usage\"></a>\r\n## 日常使用方法\r\n\r\n<a name=\"connecting-via-ssh\"></a>\r\n### 通过 SSH 连接\r\n\r\n你可以在 Homestead 目录下通过运行 `vagrant ssh` 以 SSH 方式连接到虚拟机。如果你设置了全部访问 Homestead，也可以在任意路径下通过 homestead ssh 登录到虚拟机。\r\n\r\n<a name=\"adding-additional-sites\"></a>\r\n### 添加其他站点\r\n\r\nHomestead 虚拟机在运行时，可能需要添加多个 Laravel 应用到 Nginx 站点。如果是在单个 Homestead 环境中运行多个 Laravel 应用，添加站点很简单，只需将站点添加到 `Homestead.yaml` 文件：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n    - map: another.test\r\n      to: /home/vagrant/project2/public\r\n```\r\n\r\n> 注意：在添加站点之前，你应该确保已经为项目的目录配置了[配置共享文件夹](#configuring-shared-folders)。\r\n\r\n如果 Vagrant 没有自动管理你的「hosts」文件，你可能还需要将新站点添加到该文件中。在 macOS 和 Linux 上，此文件位于 `/etc/hosts`。在 Windows 上，它位于 `C:\\Windows\\System32\\drivers\\etc\\hosts`：\r\n\r\n    192.168.56.56  homestead.test\r\n    192.168.56.56  another.test\r\n\r\n\r\n\r\n添加站点后，你需要从 Homestead 目录执行 `vagrant reload --provision` 命令以保证 Vagrant 加载新的站点。\r\n\r\n<a name=\"site-types\"></a>\r\n#### 站点类型\r\n\r\nHomestead 支持多种「类型」的站点，让你可以轻松运行不是基于 Laravel 的项目。 例如，我们可以使用 `statamic` 站点类型轻松地将 Statamic 应用程序添加到 Homestead：\r\n\r\n```yaml\r\nsites:\r\n    - map: statamic.test\r\n      to: /home/vagrant/my-symfony-project/web\r\n      type: \"statamic\"\r\n```\r\n\r\n可用的站点类型有： `apache`、`apigility`、`expressive`、`laravel`（默认）、`proxy`、`silverstripe`、`statamic`、`symfony2`、`symfony4` 和 `zf`。\r\n\r\n<a name=\"site-parameters\"></a>\r\n#### 站点参数\r\n\r\n你可以通过 `params` 站点指令向你的站点添加额外的 Nginx `fastcgi_param` 值：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n      params:\r\n          - key: FOO\r\n            value: BAR\r\n```\r\n\r\n<a name=\"environment-variables\"></a>\r\n### 环境变量\r\n\r\n你可以 `Homestead.yaml` 文件来定义全局环境变量：\r\n\r\n```yaml\r\nvariables:\r\n    - key: APP_ENV\r\n      value: local\r\n    - key: FOO\r\n      value: bar\r\n```\r\n\r\n更新 `Homestead.yaml` 文件后，请务必通过执行 `vagrant reload --provision` 命令重新配置机器。 这将更新所有已安装 PHP 版本的 PHP-FPM 配置，并为 `vagrant` 用户更新环境。\r\n\r\n<a name=\"ports\"></a>\r\n### 端口\r\n\r\n默认情况下，以下端口会转发到你的 Homestead 环境：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- **HTTP:** 8000 &rarr; 转发到 80\r\n- **HTTPS:** 44300 &rarr; 转发到 443\r\n\r\n</div>\r\n\r\n<a name=\"forwarding-additional-ports\"></a>\r\n#### 转发额外的端口\r\n\r\n如你所愿，你可以通过在你的 `Homestead.yaml` 文件中定义一个 `ports` 配置项来将额外的端口转发到 Vagrant 虚拟机。 更新`Homestead.yaml` 文件后，请务必通过执行`vagrant reload --provision` 命令重新载入虚拟机配置：\r\n\r\n```yaml\r\nports:\r\n    - send: 50000\r\n      to: 5000\r\n    - send: 7777\r\n      to: 777\r\n      protocol: udp\r\n```\r\n\r\n\r\n\r\n以下是你可能希望从主机映射到 Vagrant box 的其他 Homestead 服务的端口清单：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- **SSH:** 2222 &rarr; 转发到 22\r\n- **ngrok UI:** 4040 &rarr; 转发到 4040\r\n- **MySQL:** 33060 &rarr; 转发到 3306\r\n- **PostgreSQL:** 54320 &rarr; 转发到 5432\r\n- **MongoDB:** 27017 &rarr; 转发到 27017\r\n- **Mailhog:** 8025 &rarr; 转发到 8025\r\n- **Minio:** 9600 &rarr; 转发到 9600\r\n\r\n</div>\r\n\r\n<a name=\"php-versions\"></a>\r\n### 多 PHP 版本\r\n\r\nHomestead 6 引入了对在同一虚拟机上运行多个版本的 PHP 的支持。 你可以在 `Homestead.yaml` 文件中指定用于特定站点的 PHP 版本。 可用的 PHP 版本有：「5.6」、「7.0」、「7.1」、「7.2」、「7.3」、「7.4」、「8.0」（默认）和「8.1」：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n      php: \"7.1\"\r\n```\r\n\r\n[在你的 Homestead 虚拟机中](#connecting-via-ssh)，你可以通过 CLI 使用任何支持的 PHP 版本：\r\n\r\n\r\n```shell\r\nphp5.6 artisan list\r\nphp7.0 artisan list\r\nphp7.1 artisan list\r\nphp7.2 artisan list\r\nphp7.3 artisan list\r\nphp7.4 artisan list\r\nphp8.0 artisan list\r\nphp8.1 artisan list\r\n```\r\n\r\n你可以通过在 Homestead 虚拟机中发出以下命令来更改 CLI 使用的默认 PHP 版本：\r\n\r\n```shell\r\nphp56\r\nphp70\r\nphp71\r\nphp72\r\nphp73\r\nphp74\r\nphp80\r\nphp81\r\n```\r\n\r\n<a name=\"connecting-to-databases\"></a>\r\n### 连接到数据库\r\n\r\nHomestead 开箱即用地为 MySQL 和 PostgreSQL 配置了一个 `homestead` 数据库。如果你想用宿主机的数据库客户端连接到 MySQL 或 PostgreSQL 数据库，你可以通过连接 `127.0.0.1` （本地网络）的 `33060` 端口（MySQL） 或 `54320` 端口（PostgreSQL）。 两个数据库的用户名和密码都是 `homestead`/`secret`。\r\n\r\n> 注意：只有在从宿主机连接到数据库时，你才需要使用这些非标准端口。 由于 Laravel 在虚拟机中运行，因此你将在 Laravel 应用程序的数据库配置文件中使用默认的 3306 和 5432 端口。\r\n\r\n\r\n\r\n<a name=\"database-backups\"></a>\r\n### 数据库备份\r\n\r\n当你的 Homestead 虚拟机被破坏时，Homestead 可以自动备份你的数据库。 要使用此功能，你必须使用 Vagrant 2.1.0 或更高版本。 或者，如果你使用的是旧版本的 Vagrant，则必须安装 `vagrant-triggers` 插件。要启用自动数据库备份，请将以下行添加到你的 `Homestead.yaml` 文件中：\r\n\r\n    backup: true\r\n\r\n配置完成后，当执行 `vagrant destroy` 命令时，Homestead 会将你的数据库导出到 `mysql_backup` 和 `postgres_backup` 目录。 如果你选择了[为项目单独安装](#per-project-installation) Homestead，你可以在项目安装 Homestead 的文件夹中找到这些目录，或者在你的项目根目录中找到它们。\r\n\r\n<a name=\"configuring-cron-schedules\"></a>\r\n### 配置 Cron 计划\r\n\r\nLaravel 提供了一种便捷方式来满足[任务调度](/docs/laravel/9.x/scheduling)，通过 Artisan 命令 `schedule:run` 实现了定时运行（每分钟执行一次）。 `schedule:run` 命令将检查在 `App\\Console\\Kernel` 类中定义的作业计划，以确定要运行哪些计划任务。\r\n\r\n如果你想为 Homestead 站点运行 `schedule:run` 命令，可以在定义站点时将 `schedule` 选项设置为 `true`：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n      schedule: true\r\n```\r\n\r\n站点的 cron 作业将在 Homestead 虚拟机的 `/etc/cron.d` 目录中被定义。\r\n\r\n<a name=\"configuring-mailhog\"></a>\r\n### 配置 MailHog\r\n\r\n\r\n[MailHog](https://github.com/mailhog/MailHog) 会在你本地开发的过程中拦截应用程序发送的电子邮件，而不是将邮件实际发送给收件人。如果要使用 MailHog，你需要参考以下邮件配置并更新应用程序的 `.env` 文件：\r\n\r\n```ini\r\nMAIL_MAILER=smtp\r\nMAIL_HOST=localhost\r\nMAIL_PORT=1025\r\nMAIL_USERNAME=null\r\nMAIL_PASSWORD=null\r\nMAIL_ENCRYPTION=null\r\n```\r\n\r\n\r\n\r\n配置 MailHog 后，你可以通过 `http://localhost:8025` 访问 MailHog 仪表盘。\r\n\r\n<a name=\"configuring-minio\"></a>\r\n### 配置 Minio\r\n\r\n[Minio](https://github.com/minio/minio) 是一个具有 Amazon S3 兼容 API 的开源对象存储服务器。 要安装 Minio，请使用 [features](#installing-optional-features) 部分中的以下配置选项更新你的 `Homestead.yaml` 文件：\r\n\r\n[Minio](https://github.com/minio/minio) 是一个具有 Amazon S3 兼容 API 的开源对象存储服务器。 要安装 Minio，请使用 [features](#installing-optional-features) 部分中的以下配置选项更新你的 `Homestead.yaml` 文件：\r\n\r\n    minio: true\r\n\r\n默认情况下，Minio 在端口 9600 上可用。你可以通过访问 `http://localhost:9600` 访问 Minio 控制面板。 默认访问密钥是 `homestead`，而默认密钥是 `secretkey`。 访问 Minio 时，应始终使用区域 `us-east-1`。\r\n\r\n为了使用 Minio，你需要在应用程序的 `config/filesystems.php` 配置文件中调整 S3 磁盘配置。 你需要将 `use_path_style_endpoint` 选项添加到磁盘配置中，并将 `url` 键更改为 `endpoint`:\r\n\r\n    's3' => [\r\n        'driver' => 's3',\r\n        'key' => env('AWS_ACCESS_KEY_ID'),\r\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n        'region' => env('AWS_DEFAULT_REGION'),\r\n        'bucket' => env('AWS_BUCKET'),\r\n        'endpoint' => env('AWS_URL'),\r\n        'use_path_style_endpoint' => true,\r\n    ]\r\n\r\n最后，确保你的 `.env` 文件包含以下选项：\r\n\r\n```ini\r\nAWS_ACCESS_KEY_ID=homestead\r\nAWS_SECRET_ACCESS_KEY=secretkey\r\nAWS_DEFAULT_REGION=us-east-1\r\nAWS_URL=http://localhost:9600\r\n```\r\n\r\n要配置 Minio 支持的「S3」存储桶，请在你的 `Homestead.yaml` 文件中添加 `buckets` 指令。 定义存储桶后，你应该在终端中执行 `vagrant reload --provision` 命令重载虚拟机：\r\n\r\n```yaml\r\nbuckets:\r\n    - name: your-bucket\r\n      policy: public\r\n    - name: your-private-bucket\r\n      policy: none\r\n```\r\n\r\n支持的 `policy` 值包括：`none`、`download`、`upload` 和 `public`。\r\n\r\n\r\n\r\n<a name=\"laravel-dusk\"></a>\r\n### Laravel Dusk 测试工具\r\n\r\n为了在 Homestead 中运行 [Laravel Dusk](/docs/laravel/9.x/dusk) 测试，你应该在 Homestead 配置中启用 [`webdriver` 功能](#installing-optional-features):\r\n\r\n```yaml\r\nfeatures:\r\n    - webdriver: true\r\n```\r\n\r\n启用 `webdriver` 功能后，你应该在终端中执行 `vagrant reload --provision` 命令重载虚拟机。\r\n\r\n<a name=\"sharing-your-environment\"></a>\r\n### 共享你的环境\r\n\r\n有时，你可能希望与同事或客户分享你目前正在做的事情。 Vagrant 通过 `vagrant share` 命令内置了对此的支持； 但是，如果你在 `Homestead.yaml` 文件中配置了多个站点，这个功能将不可用。\r\n\r\n为了解决这个问题，Homestead 包含了自己的 `share` 命令。 首先，通过 `vagrant ssh` [SSH 到你的 Homestead 虚拟机](#connecting-via-ssh) 并执行 `share homestead.test` 命令。 此命令将从你的 `Homestead.yaml` 配置文件中共享 `homestead.test` 站点。 你可以将任何其他配置的站点替换为 `homestead.test`：\r\n\r\n```shell\r\nshare homestead.test\r\n```\r\n\r\n运行该命令后，你将看到一个 Ngrok 屏幕出现，其中包含活动日志和共享站点的可公开访问的 URL。 如果你想指定自定义区域、子域或其他 Ngrok 运行时选项，你可以将它们添加到你的 `share` 命令中：\r\n\r\n```shell\r\nshare homestead.test -region=eu -subdomain=laravel\r\n```\r\n\r\n> 注意：请记住，Vagrant 本质上是不安全的，并且你在运行 `share` 命令时会将虚拟机暴露在 Internet 上。\r\n\r\n<a name=\"debugging-and-profiling\"></a>\r\n## 调试和分析\r\n\r\n<a name=\"debugging-web-requests\"></a>\r\n### 使用 Xdebug 调试 Web 请求\r\n\r\n\r\n\r\nHomestead 支持使用 [Xdebug](https://xdebug.org) 进行步骤调试。例如，你可以在浏览器中访问一个页面，PHP 将连接到你的 IDE 以允许检查和修改正在运行的代码。\r\n\r\n默认情况下，Xdebug 将自动运行并准备好接受连接。 如果需要在 CLI 上启用 Xdebug，请在 Homestead 虚拟机中执行 `sudo phpenmod xdebug` 命令 . 接下来，按照 IDE 的说明启用调试。最后，配置你的浏览器以使用扩展名或 [bookmarklet](https://www.jetbrains.com/phpstorm/marklets/) 触发 Xdebug。\r\n\r\n> 注意：Xdebug 导致 PHP 运行速度明显变慢。要禁用 Xdebug，请在 Homestead 虚拟机中运行 sudo phpdismod xdebug 并重新启动 FPM 服务。\r\n\r\n<a name=\"autostarting-xdebug\"></a>\r\n#### 自动启动 Xdebug\r\n\r\n在调试向 Web 服务器发出请求的功能测试时，自动启动调试比修改测试以通过自定义标头或 cookie 来触发调试更容易。 要强制 Xdebug 自动启动，请修改 Homestead 虚拟机中的 `/etc/php/7.x/fpm/conf.d/20-xdebug.ini` 文件并添加以下配置:\r\n\r\n在调试向 Web 服务器发出请求的功能测试时，**自动启动调试**会比**通过自定义请求头或 cookie 修改测试逻辑来触发调试**更容易。要强制 Xdebug 自动启动，请修改 Homestead 虚拟机中的 `/etc/php/7.x/fpm/conf.d/20-xdebug.ini` 文件并添加以下配置：\r\n\r\n\r\n```ini\r\n; 如果 Homestead.yaml 包含 IP 地址的不同子网，则这个 IP 地址可能会不一样\r\nxdebug.remote_host = 192.168.10.1\r\nxdebug.remote_autostart = 1\r\n```\r\n\r\n<a name=\"debugging-cli-applications\"></a>\r\n### 调试 CLI 应用程序\r\n\r\n要调试 PHP CLI 应用程序，请在 Homestead 虚拟机中使用 `xphp` shell 别名：\r\n\r\n    xphp /path/to/script\r\n\r\n<a name=\"profiling-applications-with-blackfire\"></a>\r\n### 使用 Blackfire 分析应用程序\r\n\r\n[Blackfire](https://blackfire.io/docs/introduction) 是一种用于分析 Web 请求和 CLI 应用程序的服务。它提供了一个交互式用户界面，可在调用图和时间线中显示配置文件数据。Blackfire 专为在开发、登台和生产中使用而构建，对最终用户没有任何开销。此外，Blackfire 还提供对代码和 `php.ini` 配置设置的性能、质量和安全检查。\r\n\r\n\r\n\r\n[Blackfire Player](https://blackfire.io/docs/player/index) 是一个开源的 Web 爬行、Web 测试和 Web 抓取应用程序，可以与 Blackfire 联合使用以编写分析场景的脚本。\r\n\r\n要启用 Blackfire，请使用 Homestead 配置文件中的「features」配置项：\r\n\r\n```yaml\r\nfeatures:\r\n    - blackfire:\r\n        server_id: \"server_id\"\r\n        server_token: \"server_value\"\r\n        client_id: \"client_id\"\r\n        client_token: \"client_value\"\r\n```\r\n\r\nBlackfire 服务器凭据和客户端凭据需要使用 [Blackfire 帐户](https://blackfire.io/signup)。 Blackfire 提供了多种选项来分析应用程序，包括 CLI 工具和浏览器扩展。 请查看 [Blackfire 文档](https://blackfire.io/docs/cookbooks/index)以获取更多详细信息。\r\n\r\n<a name=\"network-interfaces\"></a>\r\n## 网络接口\r\n\r\n`Homestead.yaml` 文件的 `networks` 属性为你的 Homestead 虚拟机配置网络接口。 你可以根据需要配置任意数量的接口：\r\n\r\n```yaml\r\nnetworks:\r\n    - type: \"private_network\"\r\n      ip: \"192.168.10.20\"\r\n```\r\n\r\n要启用 [bridged](https://www.vagrantup.com/docs/networking/public_network.html) 接口，请为将网络配置调整为 `bridge` 并将网络类型更改为 `public_network`：\r\n\r\n```yaml\r\nnetworks:\r\n    - type: \"public_network\"\r\n      ip: \"192.168.10.20\"\r\n      bridge: \"en1: Wi-Fi (AirPort)\"\r\n```\r\n\r\n要启用 [DHCP](https://www.vagrantup.com/docs/networking/public_network.html) 功能，你只需从配置中删除 `ip` 选项：\r\n\r\n```yaml\r\nnetworks:\r\n    - type: \"public_network\"\r\n      bridge: \"en1: Wi-Fi (AirPort)\"\r\n```\r\n\r\n<a name=\"extending-homestead\"></a>\r\n## 扩展 Homestead\r\n\r\n你可以使用 Homestead 目录根目录中的 `after.sh` 脚本扩展 Homestead。 在此文件中，你可以添加正确配置和自定义虚拟机所需的任何 shell 命令。\r\n\r\n\r\n\r\n当你自定义 Homestead 时，Ubuntu 可能会询问你是要保留软件包的原始配置还是使用新的配置文件覆盖它。 为了避免这种情况，你应该在安装软件包时使用以下命令，以避免覆盖 Homestead 之前编写的任何配置:\r\n\r\n```shell\r\nsudo apt-get -y \\\r\n    -o Dpkg::Options::=\"--force-confdef\" \\\r\n    -o Dpkg::Options::=\"--force-confold\" \\\r\n    install package-name\r\n```\r\n\r\n<a name=\"user-customizations\"></a>\r\n### 用户自定义\r\n\r\n与你的团队一起使用 Homestead 时，你可能需要调整 Homestead 以更好地适应你的个人开发风格。 为此，你可以在 Homestead 目录（包含 `Homestead.yaml` 文件的同一目录）的根目录中创建一个 `user-customizations.sh` 文件。 在此文件中，你可以进行任何你想要的自定义； 但是， `user-customizations.sh` 不应受版本管理工具控制。\r\n\r\n\r\n<a name=\"provider-specific-settings\"></a>\r\n## 针对虚拟机软件的特殊设置\r\n\r\n<a name=\"provider-specific-virtualbox\"></a>\r\n### VirtualBox\r\n\r\n<a name=\"natdnshostresolver\"></a>\r\n#### `natdnshostresolver`\r\n\r\n默认情况下，Homestead 将 `natdnshostresolver` 设置配置为 `on`。 这允许 Homestead 使用你的主机操作系统的 DNS 设置。 如果你想覆盖此行为，请将以下配置选项添加到你的 `Homestead.yaml` 文件中：\r\n\r\n```yaml\r\nprovider: virtualbox\r\nnatdnshostresolver: 'off'\r\n```\r\n\r\n<a name=\"symbolic-links-on-windows\"></a>\r\n#### Windows 上的符号链接\r\n\r\n如果符号链接在你的 Windows 机器上不能正常工作，你可能需要将以下代码块添加到你的 Vagrantfile：\r\n\r\n```ruby\r\nconfig.vm.provider \"virtualbox\" do |v|\r\n    v.customize [\"setextradata\", :id, \"VBoxInternal2/SharedFoldersEnableSymlinksCreate/v-root\", \"1\"]\r\nend\r\n```\r\n\r\n","p":"docs/homestead.html"},{"t":"horizon (Laravel Horizon)","d":"# Laravel Horizon\r\n\r\n- [介绍](#introduction)\r\n- [安装](#installation)\r\n    - [配置](#configuration)\r\n    - [均衡策略](#balancing-strategies)\r\n    - [控制面板授权](#dashboard-authorization)\r\n- [升级 Horizon](#upgrading-horizon)\r\n- [运行 Horizon](#running-horizon)\r\n    - [部署 Horizon](#deploying-horizon)\r\n- [标记](#tags)\r\n- [通知](#notifications)\r\n- [指标](#metrics)\r\n- [删除失败的作业](#deleting-failed-jobs)\r\n- [从队列中清除作业](#clearing-jobs-from-queues)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n> 提示：在深入了解 Laravel Horizon 之前，您应该熟悉 Laravel 的基础 [队列服务](/docs/laravel/9.x/queues)。 Horizon 为 Laravel 的队列增加了额外的功能，如果你还不熟悉 Laravel 提供的基本队列功能，这些功能可能会让人感到困惑。\r\n\r\n[Laravel Horizon](https://github.com/laravel/horizon) 为你的 Laravel [Redis queues](/docs/laravel/9.x/queues).提供了一个美观的仪表盘和代码驱动的配置；它可以方便的监控队列系统的关键指标：任务吞吐量、运行时间、作业失败情况。\r\n\r\n所有的 worker 配置存储在一个简单的配置文件中，你可以在整个团队都可以进行协作的地方进行源码控制。\r\n\r\n在使用 Horizon 时，所有队列的 worker 配置都存储在一个简单的配置文件中。通过在受版本控制的文件中定义应用程序的 worker 配置，你可以在部署应用程序时轻松扩展或修改应用程序的队列 worker。\r\n\r\n<img src=\"https://laravel.com/img/docs/horizon-example.png\">\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n> 注意：Laravel Horizon 要求你使用 [Redis](https://redis.io) 来为你的队列服务。因此，你应该确保在应用程序的 `config/queue.php` 配置文件中将队列连接设置为 `redis`。\r\n\r\n你可以使用 Composer 将 Horizon 安装到你的 Laravel 项目里：\r\n\r\n```shell\r\ncomposer require laravel/horizon\r\n```\r\n\r\nHorizon 安装之后，使用 `horizon:install` Artisan 命令发布资源：\r\n\r\n```shell\r\nphp artisan horizon:install\r\n```\r\n\r\n\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\nHorizon 资源发布之后，其主要配置文件会被分配到 `config/horizon.php` 文件。可以用这个配置文件配置工作选项，每个配置选项包含一个用途描述，请务必仔细研究这个文件。\r\n\r\n>注意：Horizon 在内部使用名为 `horizon` 的 Redis 连接。此 Redis 连接名称是保留的，不应分配给 `database.php` 配置文件中的另一个 Redis 连接或作为 `horizon.php` 配置文件中的 `use` 选项的值。\r\n\r\n<a name=\"environments\"></a>\r\n#### 环境配置\r\n\r\n安装后，你需要熟悉的重点 Horizon 配置选项是 `environments` 配置选项。此配置选项定义了你的应用程序运行的一系列环境，并为每个环境定义了工作进程选项。默认情况下，此条目包含　`生产 (production)`　和 `本地 (local)`环境。简而言之，你可以根据自己的需要自由添加更多环境：\r\n\r\n    'environments' => [\r\n        'production' => [\r\n            'supervisor-1' => [\r\n                'maxProcesses' => 10,\r\n                'balanceMaxShift' => 1,\r\n                'balanceCooldown' => 3,\r\n            ],\r\n        ],\r\n\r\n        'local' => [\r\n            'supervisor-1' => [\r\n                'maxProcesses' => 3,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n当你启动 Horizon 时，它将使用指定应用程序运行环境所配置的 worker 进程选项。通常，环境配置由 `APP_ENV` [环境变量](/docs/laravel/9.x/configuration#determining-the-current-environment) 的值确定。例如，默认的 `local` Horizon 环境配置为启动三个工作进程，并自动平衡分配给每个队列的工作进程数量。默认的「生产」环境配置为最多启动 10 个 worker 进程，并自动平衡分配给每个队列的 worker 进程数量。\r\n\r\n> 注意：您应该确保您的 `horizon` 配置文件的 `environments` 部分包含您计划在其上运行 Horizon 的每个 [环境](/docs/laravel/9.x/configuration#environment-configuration) 的配置。\r\n\r\n\r\n<a name=\"supervisors\"></a>\r\n#### Supervisors\r\n\r\n正如你在 Horizon 的默认配置文件中看到的那样。每个环境可以包含一个或多个 Supervisor 配置。默认情况下，配置文件将这个Supervisor 定义为 `supervisor-1`；但是，你可以随意命名你的 Supervisor。每个 Supervisor 负责监督一组 worker，并负责平衡队列之间的 worker。\r\n\r\n如果你想定义一组在指定环境中运行的新 worker，可以向相应的环境添加额外的 Supervisor。如果你想为应用程序使用的特定队列定义不同的平衡策略或 worker 数量，也可以选择这样做。\r\n\r\n<a name=\"default-values\"></a>\r\n#### 默认值\r\n\r\n在 Horizon 的默认配置文件中，你会注意到一个 `defaults` 配置选项。这个配置选项指定应用程序的 [supervisors](#supervisors) 的默认值。Supervisor 的默认配置值将合并到每个环境的 Supervisor  配置中，让你在定义 Supervisor 时避免不必要的重复工作。\r\n\r\n<a name=\"balancing-strategies\"></a>\r\n### 均衡策略\r\n\r\n与 Laravel 的默认队列系统不同，Horizon 允许你从三个平衡策略中进行选择：`simple`， `auto`， 和 `false`。`simple` 策略是配置文件的默认选项，它会在进程之间平均分配进入的任务：\r\n\r\n    'balance' => 'simple',\r\n\r\n`auto` 策略根据队列的当前工作负载来调整每个队列的工作进程数量。举个例子，如果你的 `notifications` 队列有 1000 个等待的任务，而你的 `render` 队列是空的，那么 Horizon 将为 `notifications` 队列分配更多的工作线程，直到队列为空。\r\n\r\n\r\n当 `balance` 选项被设置为 `false` 时，将使用默认的 Laravel 行为，它按照配置中列出的顺序处理队列。\r\n\r\n当使用 `auto` 策略时，你可以定义 `minProcesses` 和 `maxProcesses` 的配置选项来控制 Horizon  扩展进程的最小和最大数量：\r\n\r\n    'environments' => [\r\n        'production' => [\r\n            'supervisor-1' => [\r\n                'connection' => 'redis',\r\n                'queue' => ['default'],\r\n                'balance' => 'auto',\r\n                'minProcesses' => 1,\r\n                'maxProcesses' => 10,\r\n                'balanceMaxShift' => 1,\r\n                'balanceCooldown' => 3,\r\n                'tries' => 3,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n`balanceMaxShift` 和 `balanceCooldown` 配置项可以确定 Horizon 将以多快的速度扩展进程，在上面的示例中，每 3 秒钟最多创建或销毁一个新进程，你可以根据应用程序的需要随意调整这些值。\r\n\r\n当 `balance` 选项设置为 `false` 时，将使用默认的 Laravel 行为，它按照队列在配置中列出的顺序处理队列。\r\n\r\n<a name=\"dashboard-authorization\"></a>\r\n### 控制面板授权\r\n\r\nHorizon 在 `/horizon` 上显示了一个控制面板。默认情况下，你只能在 `local` 环境中访问这个面板。在你的 `app/Providers/HorizonServiceProvider.php` 文件中，有一个 [授权拦截器（Gates）](/docs/laravel/9.x/authorization#gates) 的方法定义，该拦截器用于控制在**非本地**环境中对 Horizon 的访问。末可以根据需要修改此方法，来限制对 Horizon 的访问：\r\n\r\n    /**\r\n     * 注册 Horizon 授权\r\n     *\r\n     * 此方法决定了谁可以在非本地环境中访问 Horizon\r\n     *\r\n     * @return void\r\n     */\r\n    protected function gate()\r\n    {\r\n        Gate::define('viewHorizon', function ($user) {\r\n            return in_array($user->email, [\r\n                'taylor@laravel.com',\r\n            ]);\r\n        });\r\n    }\r\n\r\n<a name=\"alternative-authentication-strategies\"></a>\r\n#### 可替代的身份验证策略\r\n\r\n需要留意的是，Laravel 会自动将经过 *authenticated*  的用户注入到拦截器（Gate）闭包中。如果你的应用程序通过其他方法（例如 IP 限制）提供 Horizon 安全性保障，那么你访问 Horizon 用户可能不需要实现这个「登录」动作。因此，你需要将上面的 `function ($user)` 更改为 `function ($user = null)` 以强制 Laravel 跳过身份验证。\r\n\r\n\r\n<a name=\"upgrading-horizon\"></a>\r\n## 升级 Horizon\r\n\r\n当你升级到 Horizon 的一个新的主要版本时，你需要仔细阅读 [升级指南](https://github.com/laravel/horizon/blob/master/UPGRADE.md)。\r\n\r\n此外，升级到新的 Horizon 版本时，你应该重新发布 Horizon 资源：\r\n\r\n```shell\r\nphp artisan horizon:publish\r\n```\r\n为了使资源文件保持最新并避免以后的更新中出现问题，你可以将以下  `horizon:publish`  命令添加到 `composer.json` 文件中的 `post-update-cmd` 脚本中：\r\n\r\n```json\r\n{\r\n    \"scripts\": {\r\n        \"post-update-cmd\": [\r\n            \"@php artisan horizon:publish --ansi\"\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"running-horizon\"></a>\r\n## 运行 Horizon\r\n\r\n在 `config/horizon.php` 中配置了你的 workers 之后，你可以使用 `horizon` Artisan 命令启动 Horizon。只需这一个命令你就可以启动你的所有已配置的 workers：\r\n\r\n```shell\r\nphp artisan horizon\r\n```\r\n\r\n你可以暂停 Horizon 进程，并使用 `horizon:pause` 和 `horizon:continue` Artisan 命令指示它继续处理任务：\r\n\r\n```shell\r\nphp artisan horizon:pause\r\n\r\nphp artisan horizon:continue\r\n```\r\n\r\n你还可以使用 `horizon:pause-supervisor` 和 `horizon:continue-supervisor` Artisan 命令暂停和继续指定的 Horizon [supervisors](#supervisors)：\r\n\r\n```shell\r\nphp artisan horizon:pause-supervisor supervisor-1\r\n\r\nphp artisan horizon:continue-supervisor supervisor-1\r\n```\r\n\r\n你可以使用 `horizon:status` Artisan 命令检查 Horizon 进程的当前状态：\r\n\r\n```shell\r\nphp artisan horizon:status\r\n```\r\n\r\n你可以使用 `horizon:terminate` Artisan 命令优雅地终止机器上的主 Horizon 进程。Horizon 会等当前正在处理的所有任务都完成后退出：\r\n\r\n```shell\r\nphp artisan horizon:terminate\r\n```\r\n\r\n\r\n\r\n<a name=\"deploying-horizon\"></a>\r\n### 部署 Horizon\r\n\r\n如果要将 Horizon 部署到一个正在运行的服务器上，应该配置一个进程监视器来监视 `php artisan horizon` 命令，并在它意外退出时重新启动它。\r\n\r\n在将新代码部署到服务器时，你需要终止 Horizon 主进程，以便进程监视器重新启动它并接收代码的更改。\r\n\r\n```shell\r\nphp artisan horizon:terminate\r\n```\r\n\r\n<a name=\"installing-supervisor\"></a>\r\n#### 安装 Supervisor\r\n\r\nSupervisor 是一个用于 Linux 操作系统的进程监视器。如果 `Horizon` 进程被退出或终止，Supervisor 将自动重启你的 `Horizon` 进程。如果要在 Ubuntu 上安装 Supervisor，你可以使用以下命令。如果你不使用 Ubuntu，也可以使用操作系统的包管理器安装 Supervisor：\r\n\r\n```shell\r\nsudo apt-get install supervisor\r\n```\r\n\r\n> 技巧：如果你觉得自己配置 Supervisor 难如登天，可以考虑使用 [Laravel Forge](https://forge.laravel.com)，它将自动为你的 Laravel 项目安装和配置 Supervisor。\r\n\r\n<a name=\"supervisor-configuration\"></a>\r\n#### Supervisor 配置\r\n\r\nSupervisor 配置文件通常存储在 `/etc/supervisor/conf.d` 目录下。在此目录中，你可以创建任意数量的配置文件，这些配置文件会告诉 supervisor 如何监视你的进程。例如，让我们创建一个 `horizon.conf` 文件，它启动并监视一个 `horizon` 进程：\r\n\r\n```ini\r\n[program:horizon]\r\nprocess_name=%(program_name)s\r\ncommand=php /home/forge/example.com/artisan horizon\r\nautostart=true\r\nautorestart=true\r\nuser=forge\r\nredirect_stderr=true\r\nstdout_logfile=/home/forge/example.com/horizon.log\r\nstopwaitsecs=3600\r\n```\r\n\r\n> 注意：要确保 `stopwaitsecs` 的值大于运行时间最长的任务所消耗的秒数。否则，Supervisor 可能会在工作完成前终止任务。\r\n\r\n\r\n<a name=\"starting-supervisor\"></a>\r\n#### 启动 Supervisor\r\n\r\n创建了配置文件后，可以使用以下命令更新 Supervisor 配置并启动进程：\r\n\r\n```shell\r\nsudo supervisorctl reread\r\n\r\nsudo supervisorctl update\r\n\r\nsudo supervisorctl start horizon\r\n```\r\n\r\n> 技巧：关于 Supervisor 的更多信息，可以查阅 [Supervisor 文档](http://supervisord.org/index.html)。\r\n\r\n<a name=\"tags\"></a>\r\n## 标记\r\n\r\nHorizon 允许你将 `tags` 分配给任务，包括邮件、事件广播、通知和排队的事件监听器。实际上，Horizon 会根据附加到作业上的有 Eloquent 模型，智能地、自动地标记大多数任务。例如，看看下面的任务：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use App\\Models\\Video;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class RenderVideo implements ShouldQueue\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * video 实例\r\n         *\r\n         * @var \\App\\Models\\Video\r\n         */\r\n        public $video;\r\n\r\n        /**\r\n         * 创建一个新的任务实例\r\n         *\r\n         * @param  \\App\\Models\\Video  $video\r\n         * @return void\r\n         */\r\n        public function __construct(Video $video)\r\n        {\r\n            $this->video = $video;\r\n        }\r\n\r\n        /**\r\n         * 执行任务\r\n         *\r\n         * @return void\r\n         */\r\n        public function handle()\r\n        {\r\n            //\r\n        }\r\n    }\r\n\r\n\r\n如果此任务与 `App\\Models\\Video` 实例一起排队，且该实例的 `id` 为 `1`，则该作业将自动接收 `App\\Models\\Video:1` 标记。这是因为 Horizon 将为任何有 Eloquent 的模型检查任务的属性。如果找到了有 Eloquent 的模型，Horizon 将智能地使用模型的类名和主键标记任务：\r\n\r\n    use App\\Jobs\\RenderVideo;\r\n    use App\\Models\\Video;\r\n\r\n    $video = Video::find(1);\r\n\r\n    RenderVideo::dispatch($video);\r\n\r\n\r\n\r\n<a name=\"manually-tagging-jobs\"></a>\r\n#### 手动标记作业\r\n\r\n如果你想手动定义你的一个队列对象的标签，你可以在类上定义一个 `tags` 方法：\r\n\r\n    class RenderVideo implements ShouldQueue\r\n    {\r\n        /**\r\n         * 获取应该分配给任务的标记\r\n         *\r\n         * @return array\r\n         */\r\n        public function tags()\r\n        {\r\n            return ['render', 'video:'.$this->video->id];\r\n        }\r\n    }\r\n\r\n<a name=\"notifications\"></a>\r\n## 通知\r\n\r\n> **注意：** 当配置 Horizon 发送 Slack 或 SMS 通知时，你应该查看 [相关通知驱动程序的先决条件](/docs/laravel/9.x/notifications)。\r\n\r\n如果你希望在一个队列有较长的等待时间时得到通知，你可以使用 `Horizon::routeMailNotificationsTo`, `Horizon::routeSlackNotificationsTo`, 和 `Horizon::routeSmsNotificationsTo` 方法。你可以从你的应用程序的 `HorizonServiceProvider` 调用这些方法：\r\n\r\n    /**\r\n     * 服务引导\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        parent::boot();\r\n\r\n        Horizon::routeSmsNotificationsTo('15556667777');\r\n        Horizon::routeMailNotificationsTo('example@example.com');\r\n        Horizon::routeSlackNotificationsTo('slack-webhook-url', '#channel');\r\n    }\r\n\r\n<a name=\"configuring-notification-wait-time-thresholds\"></a>\r\n#### 配置通知等待时间阈值\r\n\r\n你可以在 `config/horizon.php` 的配置文件中配置多少秒算是「长等待」。你可以用该文件中的 `waits` 配置选项控制每个 连接 / 队列 组合的长等待阈值：\r\n\r\n    'waits' => [\r\n        'redis:default' => 60,\r\n        'redis:critical,high' => 90,\r\n    ],\r\n\r\n<a name=\"metrics\"></a>\r\n## 指标\r\n\r\nHorizon 有一个指标控制面板，它提供了任务和队列的等待时间和吞吐量等信息。要让这些信息显示在这个控制面板上，你应该配置 Horizon 的 `snapshot` Artisan 命令，通过你的应用程序的 [调度器](/docs/laravel/9.x/scheduling) 每五分钟运行一次：\r\n\r\n    /**\r\n     * 定义应用程序的命令调度\r\n     *\r\n     * @param  \\Illuminate\\Console\\Scheduling\\Schedule  $schedule\r\n     * @return void\r\n     */\r\n    protected function schedule(Schedule $schedule)\r\n    {\r\n        $schedule->command('horizon:snapshot')->everyFiveMinutes();\r\n    }\r\n\r\n\r\n\r\n<a name=\"deleting-failed-jobs\"></a>\r\n## 删除失败的作业\r\n\r\n如果你想删除失败的作业，可以使用 `horizon:forget` 命令。 `horizon:forget` 命令接受失败作业的 ID 或 UUID 作为其唯一参数：\r\n\r\n```shell\r\nphp artisan horizon:forget 5\r\n```\r\n\r\n<a name=\"clearing-jobs-from-queues\"></a>\r\n## 从队列中清除作业\r\n\r\n如果你想从应用程序的默认队列中删除所有作业，你可以使用 `horizon:clear` Artisan 命令执行此操作：\r\n\r\n```shell\r\nphp artisan horizon:clear\r\n```\r\n\r\n你可以设置 `queue` 选项来从特定队列中删除作业：\r\n\r\n```shell\r\nphp artisan horizon:clear --queue=emails\r\n```\r\n\r\n","p":"docs/horizon.html"},{"t":"octane (Laravel Octane)","d":"# Laravel Octane\r\n\r\n- [介绍](#introduction)\r\n- [安装](#installation)\r\n- [服务器先决条件](#server-prerequisites)\r\n    - [RoadRunner](#roadrunner)\r\n    - [Swoole](#swoole)\r\n- [为应用程序提供服务](#serving-your-application)\r\n    - [通过 HTTPS 服务应用程序](#serving-your-application-via-https)\r\n    - [通过 NGINX 提供服务](#serving-your-application-via-nginx)\r\n    - [监听文件更改](#watching-for-file-changes)\r\n    - [指定工作程序数量](#specifying-the-worker-count)\r\n    - [指定最大请求数量](#specifying-the-max-request-count)\r\n    - [重载 workers](#reloading-the-workers)\r\n    - [停止服务](#stopping-the-server)\r\n- [依赖注入与 Octane](#dependency-injection-and-octane)\r\n    - [容器注入](#container-injection)\r\n    - [请求注入](#request-injection)\r\n    - [配置文件注入](#configuration-repository-injection)\r\n- [管理内存泄漏](#managing-memory-leaks)\r\n- [并发任务](#concurrent-tasks)\r\n- [刻度和间隔](#ticks-and-intervals)\r\n- [Octane 缓存](#the-octane-cache)\r\n- [表](#tables)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Octane](https://github.com/laravel/octane) 通过使用高性能应用程序服务器为您的应用程序提供服务来增强您的应用程序的性能，包括 [Open Swoole](https://swoole.co.uk)，[Swoole](https://github.com/swoole/swoole-src)，和 [RoadRunner](https://roadrunner.dev)。Octane 启动您的应用程序一次，将其保存在内存中，然后以极快的速度向它提供请求。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\nOctane 可以通过 Composer 包管理器安装：\r\n\r\n```shell\r\ncomposer require laravel/octane\r\n```\r\n\r\n安装 Octane 后，您可以执行 `octane:install` 命令，该命令会将 Octane 的配置文件安装到您的应用程序中：\r\n\r\n```shell\r\nphp artisan octane:install\r\n```\r\n\r\n<a name=\"server-prerequisites\"></a>\r\n## 服务器先决条件\r\n\r\n> 注意：Laravel Octane 需要 [PHP 8.0+](https://php.net/releases/).\r\n\r\n<a name=\"roadrunner\"></a>\r\n### RoadRunner\r\n\r\n[RoadRunner](https://roadrunner.dev) 由使用 Go 构建的 RoadRunner 二进制文件提供支持。当您第一次启动基于 RoadRunner 的 Octane 服务器时，Octane 将为您提供下载和安装 RoadRunner 二进制文件。\r\n\r\n\r\n\r\n<a name=\"roadrunner-via-laravel-sail\"></a>\r\n####  通过 Laravel Sail 安装 RoadRunner\r\n\r\n如果你打算使用 [Laravel Sail](/docs/laravel/9.x/sail) 开发你的应用程序，你应该运行以下命令来安装 Octane 和 RoadRunner：\r\n\r\n```shell\r\n./vendor/bin/sail up\r\n\r\n./vendor/bin/sail composer require laravel/octane spiral/roadrunner\r\n```\r\n\r\n接下来应启动 Sail shell 并使用 `rr` 可执行文件来检查基于 Linux 的最新版本的 RoadRunner 二进制文件：\r\n\r\n```shell\r\n./vendor/bin/sail shell\r\n\r\n# Within the Sail shell...\r\n./vendor/bin/rr get-binary\r\n```\r\n\r\n安装 RoadRunner 二进制文件后可退出 Sail shell 会话。接下来需要调整 Sail 使用的 `supervisor.conf` 文件以保持应用运行。首先，执行 `sail:publish` Artisan 命令：\r\n\r\n```shell\r\n./vendor/bin/sail artisan sail:publish\r\n```\r\n\r\n接下来，更新应用程序的 `docker/supervisord.conf` 文件的 `command` 指令，以便 Sail 使用 Octane 作为服务器为你的应用提供服务：\r\n\r\n```ini\r\ncommand=/usr/bin/php -d variables_order=EGPCS /var/www/html/artisan octane:start --server=roadrunner --host=0.0.0.0 --rpc-port=6001 --port=8000\r\n```\r\n\r\n最后，确保 `rr` 二进制文件是可执行的并重新构建 Sail 镜像：\r\n\r\n```shell\r\nchmod +x ./rr\r\n\r\n./vendor/bin/sail build --no-cache\r\n```\r\n\r\n<a name=\"swoole\"></a>\r\n### Swoole\r\n\r\n如果你打算使用 Swoole 应用服务器来配合 Laravel Octane，你必须安装 Swoole PHP 扩展。通常可以通过 PECL 完成：\r\n\r\n```shell\r\npecl install swoole\r\n```\r\n\r\n<a name=\"swoole-via-laravel-sail\"></a>\r\n#### 通过 Laravel Sail 使用 Swoole \r\n\r\n> 注意：在通过 Sail 提供 Octane 应用程序之前，请确保你使用的是最新版本的 Laravel Sail 并在应用程序的根目录中执行 `./vendor/bin/sail build --no-cache`。\r\n\r\n\r\n\r\n你可以使用 [Laravel Sail](/docs/laravel/9.x/sail) （Laravel 基于 Docker 的官方开发环境）开发基于 Swoole 的 Octane 应用程序。Laravel Sail 默认包含 Swoole 扩展。但是，你仍然需要调整 Sail 使用的 `supervisor.conf` 文件以保持应用运行。首先，执行 `sail:publish` Artisan 命令：\r\n\r\n```shell\r\n./vendor/bin/sail artisan sail:publish\r\n```\r\n\r\n接下来，更新应用程序的 `docker/supervisord.conf` 文件的 `command` 指令，以便 Sail 使用 Octane 替代 PHP 开发服务器：\r\n\r\n```ini\r\ncommand=/usr/bin/php -d variables_order=EGPCS /var/www/html/artisan octane:start --server=swoole --host=0.0.0.0 --port=80\r\n```\r\n\r\n最后，构建你的 Sail 镜像：\r\n\r\n```shell\r\n./vendor/bin/sail build --no-cache\r\n```\r\n\r\n<a name=\"swoole-configuration\"></a>\r\n#### Swoole 配置\r\n\r\nSwoole 支持一些额外的配置选项，如果需要，你可以将它们添加到您的 `octane` 配置文件中。因为它们很少需要修改，所以这些选项不包含在默认配置文件中：\r\n\r\n```php\r\n'swoole' => [\r\n    'options' => [\r\n        'log_file' => storage_path('logs/swoole_http.log'),\r\n        'package_max_length' => 10 * 1024 * 1024,\r\n    ],\r\n];\r\n```\r\n\r\n<a name=\"serving-your-application\"></a>\r\n## 启用服务\r\n\r\nOctane 服务器可以通过 `octane:start` Artisan 命令启动。此命令将使用由应用程序的 `octane` 配置文件的 `server` 配置选项指定的服务器：\r\n\r\n```shell\r\nphp artisan octane:start\r\n```\r\n\r\nOctane 将在 8000 端口上启动服务器（可配置），因此你可以在 Web 浏览器中通过 `http://localhost:8000` 访问你的应用程序。\r\n\r\n<a name=\"serving-your-application-via-https\"></a>\r\n### 通过 HTTPS 为应用程序提供服务\r\n\r\n\r\n\r\n默认情况下，通过 Octane 运行的应用程序会生成以 `http://` 为前缀的链接。当使用 HTTPS 时，可将在应用的`config/octane.php` 配置文件中使用的 `OCTANE_HTTPS` 环境变量设置为 `true`。当此配置值设置为 `true` 时，Octane 将指示 Laravel 在所有生成的链接前加上 `https://`：\r\n\r\n```php\r\n'https' => env('OCTANE_HTTPS', false),\r\n```\r\n\r\n<a name=\"serving-your-application-via-nginx\"></a>\r\n### 通过 Nginx 为应用提供服务\r\n\r\n> 提示：如果你还没有准备好管理自己的服务器配置，或者不习惯配置运行健壮的 Laravel Octane 应用所需的所有各种服务，请查看 [Laravel Forge](https://forge.laravel.com)。\r\n\r\n在生产环境中，你应该在传统 Web 服务器（例如 Nginx 或 Apache）之后为 Octane 应用提供服务。 这样做将允许 Web 服务器为你的静态资源（例如图片和样式表）提供服务，并管理 SSL 证书。\r\n\r\n在下面的 Nginx 配置示例文件中，Nginx 将向在端口 8000 上运行的 Octane 服务器提供站点的静态资源和代理请求：\r\n\r\n```nginx\r\nmap $http_upgrade $connection_upgrade {\r\n    default upgrade;\r\n    ''      close;\r\n}\r\n\r\nserver {\r\n    listen 80;\r\n    listen [::]:80;\r\n    server_name domain.com;\r\n    server_tokens off;\r\n    root /home/forge/domain.com/public;\r\n\r\n    index index.php;\r\n\r\n    charset utf-8;\r\n\r\n    location /index.php {\r\n        try_files /not_exists @octane;\r\n    }\r\n\r\n    location / {\r\n        try_files $uri $uri/ @octane;\r\n    }\r\n\r\n    location = /favicon.ico { access_log off; log_not_found off; }\r\n    location = /robots.txt  { access_log off; log_not_found off; }\r\n\r\n    access_log off;\r\n    error_log  /var/log/nginx/domain.com-error.log error;\r\n\r\n    error_page 404 /index.php;\r\n\r\n    location @octane {\r\n        set $suffix \"\";\r\n\r\n        if ($uri = /index.php) {\r\n            set $suffix ?$query_string;\r\n        }\r\n\r\n        proxy_http_version 1.1;\r\n        proxy_set_header Host $http_host;\r\n        proxy_set_header Scheme $scheme;\r\n        proxy_set_header SERVER_PORT $server_port;\r\n        proxy_set_header REMOTE_ADDR $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection $connection_upgrade;\r\n\r\n        proxy_pass http://127.0.0.1:8000$suffix;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"watching-for-file-changes\"></a>\r\n### 监视文件修改\r\n\r\n由于应用在 Octane 服务启动时已经加载到内存中了，因此代码修改后不会起作用。例如，`routes/web.php` 文件增加路由，在服务重启之前，都不会生效。为了方便，可以使用 `--watch` 标识来让 Octane 在应用中任何文件修改时都能够自动重启：\r\n\r\n```shell\r\nphp artisan octane:start --watch\r\n```\r\n\r\n使用该功能之前，必须保证本地开发环境安装了 [Node](https://nodejs.org) 。并且在项目库中安装 [Chokidar](https://github.com/paulmillr/chokidar) 文件监视库：\r\n\r\n```shell\r\nnpm install --save-dev chokidar\r\n```\r\n\r\n你可以使用应用程序的 `config/octane.php` 配置文件中的 `watch` 配置选项配置应监视的目录和文件。\r\n\r\n<a name=\"specifying-the-worker-count\"></a>\r\n### 指定线程数\r\n\r\n默认，Octane 会对机器的每个 CPU 核心启动一个应用线程。这些线程将处理进入应用的 HTTP 请求。你可以通过 `octane:start` 命令的 `--workers` 参数手动设置线程数：\r\n\r\n```shell\r\nphp artisan octane:start --workers=4\r\n```\r\n\r\n如果是使用 Swoole 服务，可以设置 [「任务线程」](#concurrent-tasks) 数量：\r\n\r\n```shell\r\nphp artisan octane:start --workers=4 --task-workers=6\r\n```\r\n\r\n<a name=\"specifying-the-max-request-count\"></a>\r\n\r\n\r\n### 指定最大请求计数\r\n\r\n为了防止内存泄漏，Octane 可在处理了给定数量的请求后优雅地重新启动 worker。要指示 Octane 执行此操作，你可以使用 `--max-requests` 选项：\r\n\r\n```shell\r\nphp artisan octane:start --max-requests=250\r\n```\r\n\r\n<a name=\"reloading-the-workers\"></a>\r\n### 重载 Workers\r\n\r\n你可以使用 `octane:reload` 命令优雅地重新启动 Octane 服务器的应用 workers。通常，这应该在部署后完成，以便将新部署的代码加载到内存中并用于为后续请求提供服务：\r\n\r\n```shell\r\nphp artisan octane:reload\r\n```\r\n\r\n<a name=\"stopping-the-server\"></a>\r\n### 停止服务器\r\n\r\n你可以使用 `octane:stop` Artisan 命令停止 Octane 服务器：\r\n\r\n```shell\r\nphp artisan octane:stop\r\n```\r\n\r\n<a name=\"checking-the-server-status\"></a>\r\n#### 检查服务器状态\r\n\r\n你可以使用 `octane:status` Artisan 命令检查 Octane 服务器的当前状态：\r\n\r\n```shell\r\nphp artisan octane:status\r\n```\r\n\r\n<a name=\"dependency-injection-and-octane\"></a>\r\n## 依赖注入和 Octane\r\n\r\n由于 Octane 会引导你的应用程序一次并在服务请求时将其保存在内存中，因此在构建应用程序时应考虑一些注意事项。例如，应用程序服务提供者的 `register` 和 `boot` 方法只会在 request worker 初始启动时执行一次。在后续请求中，将重用相同的应用程序实例。\r\n\r\n鉴于这个机制，在将应用服务容器或请求注入任何对象的构造函数时应特别小心。该对象需支持容器的陈旧版本用以对后续请求的支持。\r\n\r\n\r\n\r\nOctane 将自动处理在请求之间重置框架状态。但是，Octane 并不总是知道如何重置由你的应用创建的全局状态。因此，你应该了解如何以一种对 Octane 友好的方式构建你的应用。下面，我们将讨论在使用 Octane 时可能导致问题的常见情况。\r\n\r\n<a name=\"container-injection\"></a>\r\n### 容器注入\r\n\r\n一般来说，你应该避免将应用服务容器或 HTTP 请求实例注入到其他对象的构造函数中。例如，以下绑定将整个应用程序服务容器注入到绑定为单例的对象中：\r\n\r\n```php\r\nuse App\\Service;\r\n\r\n/**\r\n * 注册应用服务。\r\n *\r\n * @return void\r\n */\r\npublic function register()\r\n{\r\n    $this->app->singleton(Service::class, function ($app) {\r\n        return new Service($app);\r\n    });\r\n}\r\n```\r\n\r\n在此示例中，如果在应用程序启动过程中解析了 `Service` 实例，则容器将被注入到服务中，并且该容器将在后续请求中由 `Service` 实例持有。这 **可能** 对于你的特定应用程序来说不是问题；但是，它可能导致容器意外丢失在引导周期后期或后续请求中添加的绑定。\r\n\r\n作为解决方法，可以停止将绑定注册为单例，或者将容器解析器闭包注入到始终解析当前容器实例的服务中：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Container\\Container;\r\n\r\n$this->app->bind(Service::class, function ($app) {\r\n    return new Service($app);\r\n});\r\n\r\n$this->app->singleton(Service::class, function () {\r\n    return new Service(fn () => Container::getInstance());\r\n});\r\n```\r\n\r\n\r\n\r\n全局 `app` 助手和 `Container::getInstance()` 方法会一直返回应用容器的最新版本。\r\n\r\n<a name=\"request-injection\"></a>\r\n### 请求注入\r\n\r\n通常，你应该避免在其他对象的构造器中注入应用服务容器或 HTTP 请求实例。例如，下面将一整个请求实例作为单例绑定到一个对象上：\r\n\r\n```php\r\nuse App\\Service;\r\n\r\n/**\r\n * 注册应用服务。\r\n *\r\n * @return void\r\n */\r\npublic function register()\r\n{\r\n    $this->app->singleton(Service::class, function ($app) {\r\n        return new Service($app['request']);\r\n    });\r\n}\r\n```\r\n\r\n例子中，如果 `Service` 实例在应用启动时生成，HTTP 请求会注入到这个服务中，随后请求中的相同请求都会被 `Service` 实例处理。这样，全部的 headers ，输入，和查询数据，以及其他数据都会不正确的。\r\n\r\n想要解决此问题，就需要停止单例绑定，或者将请求处理程序注入到一个始终生成当前请求实例的服务中。又或者，最推荐的方法是将对象需要的请求信息作为传参：\r\n\r\n```php\r\nuse App\\Service;\r\n\r\n$this->app->bind(Service::class, function ($app) {\r\n    return new Service($app['request']);\r\n});\r\n\r\n$this->app->singleton(Service::class, function ($app) {\r\n    return new Service(fn () => $app['request']);\r\n});\r\n\r\n// Or...\r\n\r\n$service->method($request->input('name'));\r\n```\r\n\r\n全局 `request` 助手始终返回当前处理的请求，因此可以安全地使用。\r\n\r\n> 提示：控制器方法中或者路由闭包中，依然可以使用 `Illuminate\\Http\\Request` 作为类型提示。\r\n\r\n\r\n\r\n<a name=\"configuration-repository-injection\"></a>\r\n### 配置仓库注入\r\n\r\n通常，应该避免将配置仓库实例注入到其他对象的构造器中。例如，下面的绑定将配置仓库作为单例注入到对象中：\r\n\r\n```php\r\nuse App\\Service;\r\n\r\n/**\r\n * 注册程序服务\r\n *\r\n * @return void\r\n */\r\npublic function register()\r\n{\r\n    $this->app->singleton(Service::class, function ($app) {\r\n        return new Service($app->make('config'));\r\n    });\r\n}\r\n```\r\n\r\n例子中，如果请求中的配置值改变了，服务将无法获取新值，因为它依赖原始的仓库实例。\r\n\r\n如要解决，应该停止单例绑定，或者将配置仓库注入到一个类中：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Container\\Container;\r\n\r\n$this->app->bind(Service::class, function ($app) {\r\n    return new Service($app->make('config'));\r\n});\r\n\r\n$this->app->singleton(Service::class, function () {\r\n    return new Service(fn () => Container::getInstance()->make('config'));\r\n});\r\n```\r\n\r\n全局 `config` 始终返回配置仓库的最新版本 ，可以安全地使用它。\r\n\r\n<a name=\"managing-memory-leaks\"></a>\r\n### 管理内存泄漏\r\n\r\n记住， 在请求中，Octane 将应用维护在内存中；因此，向静态数组中添加数据，可能会造成内存泄漏。例如，下面的控制器存在内存泄漏，因为每个请求持续向静态数组 `$data` 中添加数据：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Str;\r\n\r\n/**\r\n * 处理列表请求\r\n *\r\n * @param  \\Illuminate\\Http\\Request  $request\r\n * @return void\r\n */\r\npublic function index(Request $request)\r\n{\r\n    Service::$data[] = Str::random(10);\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\r\n\r\n开发应用时，需要特别注意尽量避免造成这些类型的内存泄漏。本地开发时时刻监控内存使用情况，从而确保不会造成新的内存泄漏。\r\n\r\n<a name=\"concurrent-tasks\"></a>\r\n## 并行任务\r\n\r\n> 注意：这个功能仅支持 [Swoole](#swoole).\r\n\r\nSwoole 允许并行执行一些轻量化的后台任务。 这可以通过 Octane 的 `concurrently` 方法实现。可以将这个方法与 PHP 数组解构结合来接收每个操作的结果：\r\n\r\n```php\r\nuse App\\User;\r\nuse App\\Server;\r\nuse Laravel\\Octane\\Facades\\Octane;\r\n\r\n[$users, $servers] = Octane::concurrently([\r\n    fn () => User::all(),\r\n    fn () => Server::all(),\r\n]);\r\n```\r\n\r\nOctane 利用 Swoole 的 “task workers” 处理并行任务，在与传入请求完全不同的进程中执行。并行任务可用的执行者的数量由 `octane:start` 命令的 `--task-workers` 参数决定：\r\n\r\n```shell\r\nphp artisan octane:start --workers=4 --task-workers=6\r\n```\r\n\r\n<a name=\"ticks-and-intervals\"></a>\r\n## 计时与间隔\r\n\r\n> 注意：此功能仅支持 [Swoole](#swoole).\r\n\r\nSwoole 中，“计时”操作能够按指定的秒数间隔执行。`tick` 方法可以注册 “计时” 回调操作。`tick` 方法的第一个参数代表计时器的名称，第二个参数代表指定间隔执行的回调。\r\n\r\n例子中，注册了一个每 10 秒执行一次的闭包。通常，`tick` 方法应该在应用服务提供者的 `boot` 方法中调用：\r\n\r\n```php\r\nOctane::tick('simple-ticker', fn () => ray('Ticking...'))\r\n        ->seconds(10);\r\n```\r\n\r\n\r\n\r\n使用 `immediate` 方法指示 Octane 在启动服务时立即调用 tick 回调，此后每 N 秒调用一次：\r\n\r\n```php\r\nOctane::tick('simple-ticker', fn () => ray('Ticking...'))\r\n        ->seconds(10)\r\n        ->immediate();\r\n```\r\n\r\n<a name=\"the-octane-cache\"></a>\r\n## Octane 缓存\r\n\r\n> 注意：此功能仅支持 [Swoole](#swoole).\r\n\r\n使用 Swoole 时，你可以利用 Octane 缓存驱动程序，它提供高达每秒 200 万次操作的读取和写入速度。因此，对于需要从其缓存层获得极高读/写速度的应用程序，此缓存驱动程序是绝佳选择。\r\n\r\n此缓存驱动程序由 [Swoole tables](https://www.swoole.co.uk/docs/modules/swoole-table) 提供支持。 服务器上的所有 Workers 都可以使用缓存中存储的所有数据。但是，当服务器重新启动时，缓存的数据将被刷新：\r\n\r\n```php\r\nCache::store('octane')->put('framework', 'Laravel', 30);\r\n```\r\n\r\n> 技巧：Octane 缓存中允许的最大条目数可以在应用程序的 `octane` 配置文件中定义。\r\n\r\n<a name=\"cache-intervals\"></a>\r\n### 缓存间隔\r\n\r\n除了 Laravel 缓存系统提供的常见方法之外，Octane 缓存驱动程序还具有基于间隔的缓存。这些缓存会在指定的时间间隔自动刷新，并且应该在你的应用程序服务提供商之一的`boot`方法中注册。例如，以下缓存将每五秒刷新一次：\r\n\r\n```php\r\nuse Illuminate\\Support\\Str;\r\n\r\nCache::store('octane')->interval('random', function () {\r\n    return Str::random(10);\r\n}, seconds: 5)\r\n```\r\n\r\n<a name=\"tables\"></a>\r\n## 表\r\n\r\n> 注意：此功能仅支持 [Swoole](#swoole).\r\n\r\n使用 Swoole 时，你可以定义自己的任意 [Swoole tables](https://www.swoole.co.uk/docs/modules/swoole-table) 并与之交互。 Swoole table 提供了极高的性能吞吐量，服务器上的所有 Workers 都可以访问这些表中的数据。但是，当服务器重新启动时，其中的数据将丢失。\r\n\r\n\r\n\r\n表在应用 `octane` 配置文件 `tables` 数组配置中设定。最大运行 1000 行的示例表已经配置。像下面这样，字符串行支持的最大长度在列类型后面设置：\r\n\r\n```php\r\n'tables' => [\r\n    'example:1000' => [\r\n        'name' => 'string:1000',\r\n        'votes' => 'int',\r\n    ],\r\n],\r\n```\r\n\r\n通过 `Octane::table` 方法访问表：\r\n\r\n```php\r\nuse Laravel\\Octane\\Facades\\Octane;\r\n\r\nOctane::table('example')->set('uuid', [\r\n    'name' => 'Nuno Maduro',\r\n    'votes' => 1000,\r\n]);\r\n\r\nreturn Octane::table('example')->get('uuid');\r\n```\r\n\r\n> 注意：Swoole table 支持的列类型有： `string` ，`int` 和 `float` 。\r\n\r\n","p":"docs/octane.html"},{"t":"passport (Laravel Passport)","d":"# Laravel Passport\r\n\r\n- [介绍](#introduction)\r\n    - [选择 Passport 还是 Sanctum？](#passport-or-sanctum)\r\n- [安装](#installation)\r\n    - [部署 Passport](#deploying-passport)\r\n    - [自定义迁移](#migration-customization)\r\n    - [升级 Passport](#upgrading-passport)\r\n- [配置](#configuration)\r\n    - [客户端密钥 Hashing](#client-secret-hashing)\r\n    - [Token 生命周期](#token-lifetimes)\r\n    - [重载默认模型](#overriding-default-models)\r\n- [发布访问令牌](#issuing-access-tokens)\r\n    - [客户端管理](#managing-clients)\r\n    - [请求令牌](#requesting-tokens)\r\n    - [刷新令牌](#refreshing-tokens)\r\n    - [撤销令牌](#revoking-tokens)\r\n    - [清除令牌](#purging-tokens)\r\n- [通过 PKCE 发布令牌](#code-grant-pkce)\r\n    - [创建客户端](#creating-a-auth-pkce-grant-client)\r\n    - [请求令牌](#requesting-auth-pkce-grant-tokens)\r\n- [密码授权方式的令牌](#password-grant-tokens)\r\n    - [创建密码授权方式客户端](#creating-a-password-grant-client)\r\n    - [请求令牌](#requesting-password-grant-tokens)\r\n    - [请求所有的作用域](#requesting-all-scopes)\r\n    - [自定义用户提供者](#customizing-the-user-provider)\r\n    - [自定义用户名字段](#customizing-the-username-field)\r\n    - [自定义密码验证](#customizing-the-password-validation)\r\n- [隐式授权令牌](#implicit-grant-tokens)\r\n- [客户端授权令牌](#client-credentials-grant-tokens)\r\n- [个人访问令牌](#personal-access-tokens)\r\n    - [创建个人访问令牌的客户端](#creating-a-personal-access-client)\r\n    - [管理个人访问令牌](#managing-personal-access-tokens)\r\n- [路由保护](#protecting-routes)\r\n    - [通过中间件](#via-middleware)\r\n    - [传递访问令牌](#passing-the-access-token)\r\n- [令牌作用域](#token-scopes)\r\n    - [定义作用域](#defining-scopes)\r\n    - [默认作用域](#default-scope)\r\n    - [给令牌分配作用域](#assigning-scopes-to-tokens)\r\n    - [检查作用域](#checking-scopes)\r\n- [使用 JavaScript 接入 API](#consuming-your-api-with-javascript)\r\n- [事件](#events)\r\n- [测试](#testing)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Passport](https://github.com/laravel/passport) 可以在几分钟之内为你的应用程序提供完整的 OAuth2 服务端实现。Passport 是基于由 Andy Millington 和 Simon Hamp 维护的 [League OAuth2 server](https://github.com/thephpleague/oauth2-server) 建立的。\r\n\r\n> 注意：本文档假定你已熟悉 OAuth2 。如果你并不了解 OAuth2 ，阅读之前请先熟悉下 OAuth2 的 [常用术语](https://oauth2.thephpleague.com/terminology/) 和特性。\r\n\r\n\r\n\r\n<a name=\"passport-or-sanctum\"></a>\r\n### Passport 还是 Sanctum?\r\n\r\n在开始之前，我们希望您先确认下是 Laravel Passport 还是 [Laravel Sanctum](/docs/laravel/9.x/sanctum) 能为您的应用提供更好的服务。如果您的应用确确实实需要支持 OAuth2，那没疑问，你需要选用 Laravel Passport。\r\n\r\n然而，如果你只是试图要去认证一个单页应用，或者手机应用，或者发布 API 令牌，您应该选用 [Laravel Sanctum](/docs/laravel/9.x/sanctum)。 Laravel Sanctum 不支持 OAuth2，它提供了更为简单的 API 授权开发体验。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n在开始使用之前，使用 Composer 包管理器安装 Passport：\r\n\r\n```shell\r\ncomposer require laravel/passport\r\n```\r\n\r\nPassport 的 [服务提供器](/docs/laravel/9.x/providers) 注册了自己的数据库迁移脚本目录， 所以你应该在安装软件包完成后迁移你自己的数据库。 Passport 的迁移脚本将为你的应用创建用于存储 OAuth2 客户端和访问令牌的数据表：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n接下来，你需要执行 Artisan 命令 `passport:install `。这个命令将会创建一个用于生成安全访问令牌的加密秘钥。另外，这个命令也将创建用于生成访问令牌的 “个人访问” 客户端和 “密码授权” 客户端 ：\r\n\r\n```shell\r\nphp artisan passport:install\r\n```\r\n\r\n> 技巧：如果你想用使用 UUIDS 作为 Passport `Client` 模型的主键，代替默认的自动增长整形字段，请在安装 Passport 时使用 [`uuids` 参数](#client-uuids) 参数。\r\n\r\n在执行 `passport:install` 命令后， 添加 `Laravel\\Passport\\HasApiTokens` trait 到你的 `App\\Models\\User` 模型中。 这个 trait 会提供一些帮助方法用于检查已认证用户的令牌和权限范围。如果您的模型已经在使用 `Laravel\\Sanctum\\HasApiTokens` trait，您可以删除该 trait：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Laravel\\Passport\\HasApiTokens;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use HasApiTokens, HasFactory, Notifiable;\r\n    }\r\n\r\n\r\n\r\n接着你需要在 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中调用 `Passport::routes` 方法。这个方法将注册一些必须的路由，用于发布或撤销访问令牌，操作客户端以及个人的访问令牌：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    class AuthServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 应用的策略映射。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $policies = [\r\n            'App\\Models\\Model' => 'App\\Policies\\ModelPolicy',\r\n        ];\r\n\r\n        /**\r\n         * 注册鉴权/授权服务。\r\n         *\r\n         * @return void\r\n         */\r\n        public function boot()\r\n        {\r\n            $this->registerPolicies();\r\n\r\n        }\r\n    }\r\n\r\n最后，在你应用的配置文件 `config/auth.php` 中， 将 api 的授权看守器 guards 的 `driver` 参数的值设置为 `passport`。此调整会让你的应用程序使用 Passport 的 `TokenGuard` 鉴权 API 接口请求：\r\n\r\n    'guards' => [\r\n        'web' => [\r\n            'driver' => 'session',\r\n            'provider' => 'users',\r\n        ],\r\n\r\n        'api' => [\r\n            'driver' => 'passport',\r\n            'provider' => 'users',\r\n        ],\r\n    ],\r\n\r\n<a name=\"client-uuids\"></a>\r\n#### UUIDS 客户端\r\n\r\n你也可以在使用 `passport:install` 命令时带上 `--uuids` 参数。这个参数将促使 Passport 使用 UUIDS 代替默认的自增长整形字段作为 Passport `Client` 模型的主键。 在你带上 `--uuids` 参数执行 `passport:install` 命令后，你将得到关于禁用 Passport 默认迁移的相关指令说明。\r\n\r\n```shell\r\nphp artisan passport:install --uuids\r\n```\r\n\r\n<a name=\"deploying-passport\"></a>\r\n### 部署 Passport\r\n\r\n当你第一次部署 Passport 到你的应用服务器，你需要运行 `passport:keys` 命令。命令将生成一个 Passport 需要的加密秘钥，用于生成访问令牌。生成的秘钥不建议放到源码管理中：\r\n\r\n```shell\r\nphp artisan passport:keys\r\n```\r\n\r\n如有必要，您可以定义应该从中加载 Passport 密钥的路径。 您可以使用 `Passport::loadKeysFrom` 方法来完成此操作。 通常，应该从应用程序的 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n    /**\r\n     * Register any authentication / authorization services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n\r\n        Passport::loadKeysFrom(__DIR__.'/../secrets/oauth');\r\n    }\r\n\r\n<a name=\"loading-keys-from-the-environment\"></a>\r\n#### 从环境中加载秘钥\r\n\r\n或者你可以使用 Artisan 命令 `vendor:publish` 发布 Passport 的配置文件：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=passport-config\r\n```\r\n\r\n配置文件发布好后，可以将加密秘钥定义成环境变量，再加载它们：\r\n\r\n```ini\r\nPASSPORT_PRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY-----\r\n<private key here>\r\n-----END RSA PRIVATE KEY-----\"\r\n\r\nPASSPORT_PUBLIC_KEY=\"-----BEGIN PUBLIC KEY-----\r\n<public key here>\r\n-----END PUBLIC KEY-----\"\r\n```\r\n\r\n<a name=\"migration-customization\"></a>\r\n### 自定义迁移\r\n\r\n如果你不想使用 Passport 的默认迁移，你需要在 `App\\Providers\\AppServiceProvider` 类中的 `register` 方法中调用 `Passport::ignoreMigrations` 方法。你可以使用 Artisan 命令 `vendor:publish` 导出默认的迁移文件：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=passport-migrations\r\n```\r\n\r\n<a name=\"upgrading-passport\"></a>\r\n### Passport 的升级\r\n\r\n当升级到 Passport 新的主要版本时，你一定要仔细查看[升级指南](https://github.com/laravel/passport/blob/master/UPGRADE.md)。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"client-secret-hashing\"></a>\r\n### 客户端秘钥的 hash 加密\r\n\r\n如果你希望客户端秘钥在存储到数据库时被 hash 加密， 你需要在 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中调用 `Passport::hashClientSecrets` 方法：\r\n\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    Passport::hashClientSecrets();\r\n\r\n\r\n\r\n如果开启 hash 加密，所有的客户端秘钥将只会在创建时显示。因为明文的客户秘钥没有存储在数据库中，所以一旦秘钥丢失，就不可能再恢复。\r\n\r\n<a name=\"token-lifetimes\"></a>\r\n### Token 生命周期\r\n\r\n默认情况下，Passport 会发行生命周期一年的长期 token 。如果要配置更长或更短生命周期的 token，可以使用 `tokensExpireIn` 、`refreshTokensExpireIn` 和 `personalAccessTokensExpireIn` 方法。这些方法需要在应用的 `App\\Providers\\AuthServiceProvider` 的 `boot` 方法中调用：\r\n\r\n    /**\r\n     * 注册身份验证/授权服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n\r\n        Passport::tokensExpireIn(now()->addDays(15));\r\n        Passport::refreshTokensExpireIn(now()->addDays(30));\r\n        Passport::personalAccessTokensExpireIn(now()->addMonths(6));\r\n    }\r\n> 注意：Passport 数据库表上的 expires_at 列是只读的，只用于显示。在生成 token 时，Passport 将过期信息存储在签名和加密的 token 中。如果你需要使一个令牌失效，你应该 [撤销](#revoking-tokens)它。\r\n\r\n<a name=\"overriding-default-models\"></a>\r\n### 重载默认模型\r\n\r\n可以通过自定义模型来扩展 Passport 使用的默认模型:\r\n\r\n    use Laravel\\Passport\\Client as PassportClient;\r\n\r\n    class Client extends PassportClient\r\n    {\r\n        // ...\r\n    }\r\n\r\n在自定义模型后，可以通过 Laravel\\Passport\\Passport 类引导 Passport 使用自定义模型。通常情况下，你应该在应用程序 App\\Providers\\AuthServiceProvider 类的 `boot` 方法中定义 Passport 使用自定义模型\r\n\r\n    use App\\Models\\Passport\\AuthCode;\r\n    use App\\Models\\Passport\\Client;\r\n    use App\\Models\\Passport\\PersonalAccessClient;\r\n    use App\\Models\\Passport\\Token;\r\n\r\n    /**\r\n     * 注册身份验证/授权服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n\r\n        Passport::useTokenModel(Token::class);\r\n        Passport::useClientModel(Client::class);\r\n        Passport::useAuthCodeModel(AuthCode::class);\r\n        Passport::usePersonalAccessClientModel(PersonalAccessClient::class);\r\n    }\r\n\r\n\r\n\r\n<a name=\"issuing-access-tokens\"></a>\r\n## 发布访问令牌\r\n\r\n通过授权码使用 OAuth2 是大多数开发人员熟悉的方式。使用授权码方式时，客户端应用程序会将用户重定向到你的服务器，在那里他们会批准或拒绝向客户端发出访问令牌的请求。\r\n\r\n<a name=\"managing-clients\"></a>\r\n### 客户端管理\r\n\r\n首先，开发者如果想要搭建一个与你的服务端接口交互的应用端，需要在服务端这边注册一个 “客户端”。通常，这需要开发者提供应用程序的名称和一个 URL，在应用软件的使用者授权请求后，应用程序会被重定向到该 URL。\r\n\r\n<a name=\"the-passportclient-command\"></a>\r\n#### `passport:client` 命令\r\n\r\n使用 Artisan 命令 `passport:client` 是一种最简单的创建客户端的方式。 这个命令可以创建你自己私有的客户端，用于 Oauth2 功能测试。 当你执行 `client` 命令后， Passport 将会给你更多关于客户端的提示，以及生成的客户端 ID\r\n\r\n```shell\r\nphp artisan passport:client\r\n```\r\n\r\n**多重定向 URL 地址的设置**\r\n\r\n如果你想为你的客户端提供多个重定向 URL ，你可以在执行 `Passport:client` 命令出现提示输入 URL 地址的时候，输入用逗号分割的多个 URL 。任何包含逗号的 URL 都需要先执行 URL 转码：\r\n\r\n```shell\r\nhttp://example.com/callback,http://examplefoo.com/callback\r\n```\r\n\r\n<a name=\"clients-json-api\"></a>\r\n#### JSON API\r\n\r\n因为应用程序的开发者是无法使用 `client` 命令的，所以 Passport 提供了 JSON 格式的 API ，用于创建客户端。 这解决了你还要去手动创建控制器代码（代码用于添加，更新，删除客户端）的麻烦。\r\n\r\n\r\n\r\n但是，你需要结合 Passport 的 JSON API 接口和你的前端面板管理页面， 为你的用户提供客户端管理功能。接下里，我们会回顾所有用于管理客户端的的 API 接口。方便起见，我们使用 [Axios](https://github.com/axios/axios) 模拟对端点的 HTTP 请求。\r\n\r\n这些 JSON API 接口被 `web` 和 `auth` 两个中间件保护着，因此，你只能从你的应用中调用。 外部来源的调用是被禁止的。\r\n\r\n<a name=\"get-oauthclients\"></a>\r\n#### `GET /oauth/clients`\r\n\r\n下面的路由将为授权用户返回所有的客户端。最主要的作用是列出所有的用户客户端，接下来就可以编辑或删除它们了：\r\n\r\n```js\r\naxios.get('/oauth/clients')\r\n    .then(response => {\r\n        console.log(response.data);\r\n    });\r\n```\r\n\r\n<a name=\"post-oauthclients\"></a>\r\n#### `POST /oauth/clients`\r\n\r\n下面的路由用于创建新的客户端。 它需要两个参数： `客户端名称`和`重定向URL` 地址。 `重定向URL` 地址是使用者在授权或者拒绝授权后被重定向到的地方。\r\n\r\n客户端被创建后，将会生成客户端 ID 和客户端秘钥。 这对值用于从你的应用获取访问令牌。 调用下面的客户端创建路由将创建新的客户端实例：\r\n\r\n```js\r\nconst data = {\r\n    name: 'Client Name',\r\n    redirect: 'http://example.com/callback'\r\n};\r\n\r\naxios.post('/oauth/clients', data)\r\n    .then(response => {\r\n        console.log(response.data);\r\n    })\r\n    .catch (response => {\r\n        // List errors on response...\r\n    });\r\n```\r\n\r\n<a name=\"put-oauthclientsclient-id\"></a>\r\n#### `PUT /oauth/clients/{client-id}`\r\n\r\n\r\n\r\n下面的路由用来更新客户端。它需要两个参数： 客户端名称和重定向 URL 地址。 重定向 URL 地址是用户在授权或者拒绝授权后被重定向到的地方。路由将返回更新后的客户端实例：\r\n\r\n```js\r\nconst data = {\r\n    name: 'New Client Name',\r\n    redirect: 'http://example.com/callback'\r\n};\r\n\r\naxios.put('/oauth/clients/' + clientId, data)\r\n    .then(response => {\r\n        console.log(response.data);\r\n    })\r\n    .catch (response => {\r\n        // List errors on response...\r\n    });\r\n```\r\n\r\n<a name=\"delete-oauthclientsclient-id\"></a>\r\n#### `DELETE /oauth/clients/{client-id}`\r\n\r\n下面的路由用于删除客户端：\r\n\r\n```js\r\naxios.delete('/oauth/clients/' + clientId)\r\n    .then(response => {\r\n        //\r\n    });\r\n```\r\n\r\n<a name=\"requesting-tokens\"></a>\r\n### 请求令牌\r\n\r\n<a name=\"requesting-tokens-redirecting-for-authorization\"></a>\r\n#### 授权重定向\r\n\r\n客户端创建好后，开发者使用 client ID 和秘钥向你的应用服务器发送请求，以便获取授权码和访问令牌。 首先，接收到请求的业务端服务器会重定向到你应用的 `/oauth/authorize` 路由上，如下所示：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    Route::get('/redirect', function (Request $request) {\r\n        $request->session()->put('state', $state = Str::random(40));\r\n\r\n        $query = http_build_query([\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'response_type' => 'code',\r\n            'scope' => '',\r\n            'state' => $state,\r\n        ]);\r\n\r\n        return redirect('http://passport-app.test/oauth/authorize?'.$query);\r\n    });\r\n\r\n> 技巧：请记住，`/oauth/authorize` 路由默认已经在 `Passport::route` 方法中定义，你无需手动定义它。\r\n\r\n<a name=\"approving-the-request\"></a>\r\n#### 请求认证\r\n\r\n当接收到一个请求后， Passport 会自动展示一个模板页面给用户，用户可以选择授权或者拒绝授权。如果请求被认证，用户将被重定向到之前业务服务器设置的`重定向地址`上去。 这个`重定向地址`就是客户端在创建时提供的重定向地址参数。\r\n\r\n\r\n\r\n如果你想自定义授权页面，你可以先使用 Artisan 命令 `vendor:publish` 发布 Passport 的视图页面。 被发布的视图页面位于 `resources/views/vendor/passport` 路径下：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=passport-views\r\n```\r\n\r\n有时，您可能希望跳过授权提示，比如在授权第一梯队客户端的时候。您可以通过 [继承 `Client` 模型](#overriding-default-models)并实现 `skipsAuthorization` 方法。如果 `skipsAuthorization` 方法返回 `true`， 客户端就会直接被认证并立即重定向到设置的重定向地址：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models\\Passport;\r\n\r\n    use Laravel\\Passport\\Client as BaseClient;\r\n\r\n    class Client extends BaseClient\r\n    {\r\n        /**\r\n         * 确定客户端是否应跳过授权提示。\r\n         *\r\n         * @return bool\r\n         */\r\n        public function skipsAuthorization()\r\n        {\r\n            return $this->firstParty();\r\n        }\r\n    }\r\n\r\n<a name=\"requesting-tokens-converting-authorization-codes-to-access-tokens\"></a>\r\n#### 授权码到授权令牌的转化\r\n\r\n如果用户授权了访问，他们会被重定向到业务服务端。首先，业务端服务需要检查 `state` 参数是否和重定向之前存储的值一致。 如果 state 参数的值正确，业务端服务器需要对你的应用发起获取 access token 的 `POST` 请求。 请求需要携带有授权码，授权码就是之前用户授权后由你的应用服务器生成的码：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Route::get('/callback', function (Request $request) {\r\n        $state = $request->session()->pull('state');\r\n\r\n        throw_unless(\r\n            strlen($state) > 0 && $state === $request->state,\r\n            InvalidArgumentException::class\r\n        );\r\n\r\n        $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n            'grant_type' => 'authorization_code',\r\n            'client_id' => 'client-id',\r\n            'client_secret' => 'client-secret',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'code' => $request->code,\r\n        ]);\r\n\r\n        return $response->json();\r\n    });\r\n\r\n\r\n\r\n调用路由 `/oauth/token` 将返回一串 json 字符串，包含了 `access_token`, `refresh_token` 和 `expires_in` 属性。`expires_in` 属性的值是 access_token 剩余的有效时间。\r\n\r\n> 技巧：就和 `/oauth/authorize` 路由一样， `/oauth/token` 路由已经在 `Passport::routes` 方法中定义，你无需再自定义这个路由。\r\n\r\n<a name=\"tokens-json-api\"></a>\r\n#### JSON API\r\n\r\nPassport 同样包含了一个 JSON API 接口用来管理授权访问令牌。你可以使用该接口为用户搭建一个管理访问令牌的控制面板。方便来着，我们将使用 [Axios](https://github.com/mzabriskie/axios) 模拟 HTTP 对端点发起请求。由于 JSON API 被中间件 `web` 和 `auth` 保护着，我们只能在应用内部调用。\r\n\r\n<a name=\"get-oauthtokens\"></a>\r\n#### `GET /oauth/tokens`\r\n\r\n下面的路由包含了授权用户创建的所有授权访问令牌。接口的主要作用是列出用户所有可撤销的令牌：\r\n\r\n```js\r\naxios.get('/oauth/tokens')\r\n    .then(response => {\r\n        console.log(response.data);\r\n    });\r\n```\r\n\r\n<a name=\"delete-oauthtokenstoken-id\"></a>\r\n#### `DELETE /oauth/tokens/{token-id}`\r\n\r\n下面的路由用于撤销授权访问令牌以及相关的刷新令牌：\r\n\r\n```js\r\naxios.delete('/oauth/tokens/' + tokenId);\r\n```\r\n\r\n<a name=\"refreshing-tokens\"></a>\r\n### 刷新令牌\r\n\r\n如果你的应用发布的是短生命周期访问令牌，用户需要使用刷新令牌来延长访问令牌的生命周期，刷新令牌是在生成访问令牌时同时生成的：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n        'grant_type' => 'refresh_token',\r\n        'refresh_token' => 'the-refresh-token',\r\n        'client_id' => 'client-id',\r\n        'client_secret' => 'client-secret',\r\n        'scope' => '',\r\n    ]);\r\n\r\n    return $response->json();\r\n\r\n调用路由 `/oauth/token` 将返回一串 json 字符串，包含了 `access_token`, `refresh_token` 和 `expires_in` 属性。`expires_in` 属性的值是 access_token 剩余的有效时间。\r\n\r\n\r\n\r\n<a name=\"revoking-tokens\"></a>\r\n### 撤销令牌\r\n\r\n你可以使用 `Laravel\\Passport\\TokenRepository` 类的 `revokeAccessToken` 方法撤销令牌。你可以使用 `Laravel\\Passport\\RefreshTokenRepository` 类的 `revokeRefreshTokensByAccessTokenId` 方法撤销刷新令牌。这两个类可以通过 Laravel 的[服务容器](/docs/laravel/9.x/container)得到：\r\n\r\n    use Laravel\\Passport\\TokenRepository;\r\n    use Laravel\\Passport\\RefreshTokenRepository;\r\n\r\n    $tokenRepository = app(TokenRepository::class);\r\n    $refreshTokenRepository = app(RefreshTokenRepository::class);\r\n\r\n    // Revoke an access token...\r\n    $tokenRepository->revokeAccessToken($tokenId);\r\n\r\n    // Revoke all of the token's refresh tokens...\r\n    $refreshTokenRepository->revokeRefreshTokensByAccessTokenId($tokenId);\r\n\r\n<a name=\"purging-tokens\"></a>\r\n### 清除令牌\r\n\r\n如果令牌已经被撤销或者已经过期了，你可能希望把它们从数据库中清理掉。Passport 提供了 Artisan 命令 `passport:purge` 帮助你实现这个操作\r\n\r\n```shell\r\n# 清除已经撤销或者过期的令牌以及授权码\r\nphp artisan passport:purge\r\n\r\n# 只清理撤销的令牌以及授权码\r\nphp artisan passport:purge --revoked\r\n\r\n# 只清理过期的令牌以及授权码\r\nphp artisan passport:purge --expired\r\n```\r\n\r\n你可以在应用的 `App\\Console\\Kernel` 类中配置一个[定时任务](/docs/laravel/9.x/scheduling)，每天自动的清理令牌：\r\n\r\n    /**\r\n     * 定义应用程序的命令调度。\r\n     *\r\n     * @param  \\Illuminate\\Console\\Scheduling\\Schedule  $schedule\r\n     * @return void\r\n     */\r\n    protected function schedule(Schedule $schedule)\r\n    {\r\n        $schedule->command('passport:purge')->hourly();\r\n    }\r\n\r\n<a name=\"code-grant-pkce\"></a>\r\n## 通过 PKCE 发布授权码\r\n\r\n通过 PKCE (Proof Key for Code Exchange, 中文译为” 代码交换的证明密钥”) 发放授权码是对单页面应用或原生应用进行认证以便访问 API 接口的安全方式。这种发放授权码是用于不能保证客户端密码被安全储存，或为降低攻击者拦截授权码的威胁。在这种模式下，当授权码获取令牌时，用 “验证码”(code verifier) 和 “质疑码”（code challenge, “challenge”，名词可译为’挑战；异议；质疑’等）的组合来交换客户端访问密钥。\r\n\r\n\r\n\r\n<a name=\"creating-a-auth-pkce-grant-client\"></a>\r\n### 创建客户端\r\n\r\n在使用 PKCE 方式发布令牌之前，你需要先创建一个启用了 PKCE 的客户端。你可以使用 Artisan 命令 `passport:client` 并带上 `--public` 参数来完成该操作：\r\n\r\n```shell\r\nphp artisan passport:client --public\r\n```\r\n\r\n<a name=\"requesting-auth-pkce-grant-tokens\"></a>\r\n### 请求令牌\r\n\r\n<a name=\"code-verifier-code-challenge\"></a>\r\n#### 验证码（Code Verifier ）和质疑码（Code Challenge）\r\n\r\n这种授权方式不提供授权秘钥，开发者需要创建一个验证码和质疑码的组合来请求得到一个令牌。\r\n\r\n验证码是一串包含 43 位到 128 位字符的随机字符串。可用字符包括字母，数字以及下面这些字符：`\"-\"`, `\".\"`, `\"_\"`, `\"~\"` 。 可参考 [RFC 7636 specification](https://tools.ietf.org/html/rfc7636) 定义。\r\n\r\n质疑码是一串 Base64 编码包含 URL 和文件名安全字符的字符串，字符串结尾的 `=` 号需要删除，并且不能包含换行符，空白符或其他附加字符。\r\n\r\n    $encoded = base64_encode(hash('sha256', $code_verifier, true));\r\n\r\n    $codeChallenge = strtr(rtrim($encoded, '='), '+/', '-_');\r\n\r\n<a name=\"code-grant-pkce-redirecting-for-authorization\"></a>\r\n#### 授权重定向\r\n\r\n客户端创建完后，你可以使用客户端 ID 以及生成的验证码，质疑码从你的应用请求获取授权码和访问令牌。首先，业务端应用需要向服务端路由 `/oauth/authorize` 发起重定向请求：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    Route::get('/redirect', function (Request $request) {\r\n        $request->session()->put('state', $state = Str::random(40));\r\n\r\n        $request->session()->put(\r\n            'code_verifier', $code_verifier = Str::random(128)\r\n        );\r\n\r\n        $codeChallenge = strtr(rtrim(\r\n            base64_encode(hash('sha256', $code_verifier, true))\r\n        , '='), '+/', '-_');\r\n\r\n        $query = http_build_query([\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'response_type' => 'code',\r\n            'scope' => '',\r\n            'state' => $state,\r\n            'code_challenge' => $codeChallenge,\r\n            'code_challenge_method' => 'S256',\r\n        ]);\r\n\r\n        return redirect('http://passport-app.test/oauth/authorize?'.$query);\r\n    });\r\n\r\n\r\n\r\n<a name=\"code-grant-pkce-converting-authorization-codes-to-access-tokens\"></a>\r\n#### 验证码到访问令牌的转换\r\n\r\n用户授权访问后，将重定向到业务端服务。正如标准授权定义那样，业务端需要验证回传的 `state` 参数的值和在重定向之前设置的值是否一致。\r\n\r\n如果 state 的值验证通过，业务接入端需要向应用端发起一个获取访问令牌的 `POST` 请求。请求的参数需要包括之前用户授权通过后你的应用生成的授权码，以及之前生成的验证码：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Route::get('/callback', function (Request $request) {\r\n        $state = $request->session()->pull('state');\r\n\r\n        $codeVerifier = $request->session()->pull('code_verifier');\r\n\r\n        throw_unless(\r\n            strlen($state) > 0 && $state === $request->state,\r\n            InvalidArgumentException::class\r\n        );\r\n\r\n        $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n            'grant_type' => 'authorization_code',\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'code_verifier' => $codeVerifier,\r\n            'code' => $request->code,\r\n        ]);\r\n\r\n        return $response->json();\r\n    });\r\n\r\n<a name=\"password-grant-tokens\"></a>\r\n## 密码授权方式的令牌\r\n\r\n> 注意：我们不再建议使用密码授予令牌。相反，你应该选择\r\n [OAuth2服务器当前推荐的授权类型](https://oauth2.thephpleague.com/authorization-server/which-grant/).\r\n\r\nOAuth2 的密码授权方式允许你自己的客户端（比如手机端应用），通过使用邮箱 / 用户名和密码获取访问秘钥。这样你就可以安全的为自己发放令牌，而不需要完整地走 OAuth2 的重定向授权访问流程。\r\n\r\n<a name=\"creating-a-password-grant-client\"></a>\r\n### 创建密码授权方式客户端\r\n\r\n在你使用密码授权方式发布令牌前，你需要先创建密码授权方式的客户端。你可以通过 Artisan 命令 `passport:client` ， 并加上 `--password` 参数来创建这样的客户端。 **如果你已经运行过 `passport:install` 命令，则不需要再运行下面的命令:**\r\n\r\n```shell\r\nphp artisan passport:client --password\r\n```\r\n\r\n<a name=\"requesting-password-grant-tokens\"></a>\r\n### 请求令牌\r\n\r\n密码授权方式的客户端创建好后，你就可以使用用户邮箱和密码向 `/oauth/token` 路由发起 `POST` 请求，以获取访问令牌。请记住，该路由已经在 `Passport::routes` 方法中定义，你无需再手动实现它。如果请求成功，你将在返回 JSON 串中获取到 `access_token` 和 `refresh_token` :\r\n\r\n```\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n        'grant_type' => 'password',\r\n        'client_id' => 'client-id',\r\n        'client_secret' => 'client-secret',\r\n        'username' => 'taylor@laravel.com',\r\n        'password' => 'my-password',\r\n        'scope' => '',\r\n    ]);\r\n\r\n    return $response->json();\r\n```\r\n\r\n> 技巧：记住，默认情况下 access token 都是长生命周期的，但是如果有需要的话，你可以主动去 [设置 access token 的过期时间](#configuration) 。\r\n\r\n<a name=\"requesting-all-scopes\"></a>\r\n### 请求所有的作用域\r\n\r\n当使用密码授权（password grant）或者客户端认证授权（client credentials grant）方式时, 你可能希望将应用所有的作用域范围都授权给令牌。你可以通过设置 scope 参数为 `*` 来实现。 一旦你这样设置了，所有的 `can` 方法都将返回 `true` 值。 此范围只能在密码授权 `password` 或客户端认证授权 `client_credentials` 下使用：\r\n\r\n```\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n        'grant_type' => 'password',\r\n        'client_id' => 'client-id',\r\n        'client_secret' => 'client-secret',\r\n        'username' => 'taylor@laravel.com',\r\n        'password' => 'my-password',\r\n        'scope' => '*',\r\n    ]);\r\n```\r\n\r\n\r\n<a name=\"customizing-the-user-provider\"></a>\r\n### 自定义用户提供者\r\n\r\n如果您的应用程序使用多个 [authentication user provider](/docs/laravel/9.x/authentication#introduction)，您可以通过在创建客户端通过 `artisan passport:client --password` 命令。 给定的提供者名称应与应用程序的 `config/auth.php` 配置文件中定义的有效提供者匹配。 然后，您可以 [使用中间件保护您的路线](#via-middleware) 以确保只有来自守卫指定提供商的用户才被授权。\r\n\r\n<a name=\"customizing-the-username-field\"></a>\r\n### 自定义用户名字段\r\n\r\n当使用密码授权进行身份验证时，Passport 将使用可验证模型的“电子邮件”属性作为“用户名”。 但是，您可以通过在模型上定义 `findForPassport` 方法来自定义此行为：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Laravel\\Passport\\HasApiTokens;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use HasApiTokens, Notifiable;\r\n\r\n        /**\r\n         * 查找给定用户名的用户实例。\r\n         *\r\n         * @param  string  $username\r\n         * @return \\App\\Models\\User\r\n         */\r\n        public function findForPassport($username)\r\n        {\r\n            return $this->where('username', $username)->first();\r\n        }\r\n    }\r\n\r\n<a name=\"customizing-the-password-validation\"></a>\r\n### 自定义密码验证\r\n\r\n当使用密码授权进行身份验证时，Passport 将使用模型的“密码”属性来验证给定的密码。 如果您的模型没有 `password` 属性或者您希望自定义密码验证逻辑，您可以在模型上定义 `validateForPassportPasswordGrant` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Laravel\\Passport\\HasApiTokens;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use HasApiTokens, Notifiable;\r\n\r\n        /**\r\n         * 验证用户的密码以获得 Passport 密码授权。\r\n         *\r\n         * @param  string  $password\r\n         * @return bool\r\n         */\r\n        public function validateForPassportPasswordGrant($password)\r\n        {\r\n            return Hash::check($password, $this->password);\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"implicit-grant-tokens\"></a>\r\n## 隐式授权令牌\r\n\r\n> 注意：我们不再推荐使用隐式授权令牌。 相反，您应该选择 [OAuth2 服务器当前推荐的授权类型](https://oauth2.thephpleague.com/authorization-server/which-grant/)。\r\n\r\n隐式授权类似于授权码授权； 但是，令牌会在不交换授权码的情况下返回给客户端。 此授权最常用于无法安全存储客户端凭据的 JavaScript 或移动应用程序。 要启用授权，请在应用程序的 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中调用 `enableImplicitGrant` 方法：\r\n\r\n    /**\r\n     * 注册任何身份验证/授权服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n\r\n        Passport::enableImplicitGrant();\r\n    }\r\n\r\n启用授权后，开发人员可以使用他们的客户端 ID 从您的应用程序请求访问令牌。 消费应用程序应该向应用程序的 `/oauth/authorize` 路由发出重定向请求，如下所示：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/redirect', function (Request $request) {\r\n        $request->session()->put('state', $state = Str::random(40));\r\n\r\n        $query = http_build_query([\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'response_type' => 'token',\r\n            'scope' => '',\r\n            'state' => $state,\r\n        ]);\r\n\r\n        return redirect('http://passport-app.test/oauth/authorize?'.$query);\r\n    });\r\n\r\n> 技巧：请记住，`/oauth/authorize` 路由已经由`Passport::routes` 方法定义。 您无需手动定义此路由。\r\n\r\n<a name=\"client-credentials-grant-tokens\"></a>\r\n## 客户凭证授予令牌\r\n\r\n客户端凭据授予适用于机器对机器身份验证。 例如，您可以在通过 API 执行维护任务的计划作业中使用此授权。\r\n\r\n\r\n\r\n要想让应用程序可以通过客户端凭据授权发布令牌，首先，您需要创建一个客户端凭据授权客户端。你可以使用 `passport:client` Artisan 命令的 `--client` 选项来执行此操作：\r\n\r\n```shell\r\nphp artisan passport:client --client\r\n```\r\n\r\n接下来，要使用这种授权，你首先需要在 `app/Http/Kernel.php` 的`$routeMiddleware` 属性中添加 `CheckClientCredentials` 中间件：\r\n\r\n    use Laravel\\Passport\\Http\\Middleware\\CheckClientCredentials;\r\n\r\n    protected $routeMiddleware = [\r\n        'client' => CheckClientCredentials::class,\r\n    ];\r\n\r\n之后，在路由上附加中间件：\r\n\r\n    Route::get('/orders', function (Request $request) {\r\n        ...\r\n    })->middleware('client');\r\n\r\n要将对路由的访问限制为特定范围，你可以在将 `client` 中间件附加到路由时提供所需范围的逗号分隔列表：\r\n\r\n    Route::get('/orders', function (Request $request) {\r\n        ...\r\n    })->middleware('client:check-status,your-scope');\r\n\r\n<a name=\"retrieving-tokens\"></a>\r\n### 检索令牌\r\n\r\n要使用此授权类型检索令牌，请向 `oauth/token` 端点发出请求：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n        'grant_type' => 'client_credentials',\r\n        'client_id' => 'client-id',\r\n        'client_secret' => 'client-secret',\r\n        'scope' => 'your-scope',\r\n    ]);\r\n\r\n    return $response->json()['access_token'];\r\n\r\n<a name=\"personal-access-tokens\"></a>\r\n## 个人访问令牌\r\n\r\n有时，你的用户要在不经过传统的授权码重定向流程的情况下向自己颁发访问令牌。允许用户通过应用程序用户界面对自己发布令牌，有助于用户体验你的 API，或者也可以将其作为一种更简单的发布访问令牌的方式。\r\n\r\n> 提示：如果您的应用程序主要使用 Passport 来发布个人访问令牌，请考虑使用 Laravel 的轻量级第一方库 [Laravel Sanctum](/docs/laravel/9.x/sanctum) 来发布 API 访问令牌。\r\n\r\n\r\n\r\n<a name=\"creating-a-personal-access-client\"></a>\r\n### 创建个人访问客户端\r\n\r\n在应用程序发出个人访问令牌前，你需要在 `passport:client` 命令后带上 `--personal` 参数来创建对应的客户端。如果你已经运行了 `passport:install` 命令，则无需再运行此命令:\r\n\r\n```shell\r\nphp artisan passport:client --personal\r\n```\r\n\r\n创建个人访问客户端后，将客户端的 ID 和纯文本密钥放在应用程序的 `.env` 文件中:\r\n\r\n```ini\r\nPASSPORT_PERSONAL_ACCESS_CLIENT_ID=\"client-id-value\"\r\nPASSPORT_PERSONAL_ACCESS_CLIENT_SECRET=\"unhashed-client-secret-value\"\r\n```\r\n\r\n<a name=\"managing-personal-access-tokens\"></a>\r\n### 管理个人令牌\r\n\r\n创建个人访问客户端后, 你可以使用 `App\\Models\\User` 模型实例的 `createToken` 方法来为给定用户发布令牌。`createToken` 方法接受令牌的名称作为其第一个参数和可选的 [作用域](#token-scopes) 数组作为其第二个参数:\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    // 创建没有作用域的令牌...\r\n    $token = $user->createToken('Token Name')->accessToken;\r\n\r\n    // 创建具有作用域的令牌...\r\n    $token = $user->createToken('My Token', ['place-orders'])->accessToken;\r\n\r\n<a name=\"personal-access-tokens-json-api\"></a>\r\n#### JSON API\r\n\r\nPassport 中还有一个用于管理个人访问令牌的 JSON API。你可以将其与你自己的前端配对，为你的用户提供一个用于管理个人访问令牌的仪表板。下面，我们将回顾所有用于管理个人访问令牌的 API 。为了方便起见，我们将使用 [Axios](https://github.com/mzabriskie/axios) 来演示向 API 发出 HTTP 请求。\r\n\r\n\r\n\r\nJSON API 由 `web` 和 `auth` 这两个中间件保护。因此，只能从你自己的应用程序中调用它。无法从外部源调用它。\r\n\r\n<a name=\"get-oauthscopes\"></a>\r\n#### `GET /oauth/scopes`\r\n\r\n此路由会返回应用中定义的所有 [作用域](#token-scopes) 。你可以使用此路由列出用户可以分配给个人访问令牌的范围:\r\n\r\n```js\r\naxios.get('/oauth/scopes')\r\n    .then(response => {\r\n        console.log(response.data);\r\n    });\r\n```\r\n\r\n<a name=\"get-oauthpersonal-access-tokens\"></a>\r\n#### `GET /oauth/personal-access-tokens`\r\n\r\n此路由返回认证用户创建的所有个人访问令牌。这主要用于列出用户的所有令牌，以便他们可以编辑和撤销它们:\r\n\r\n```js\r\naxios.get('/oauth/personal-access-tokens')\r\n    .then(response => {\r\n        console.log(response.data);\r\n    });\r\n```\r\n\r\n<a name=\"post-oauthpersonal-access-tokens\"></a>\r\n#### `POST /oauth/personal-access-tokens`\r\n\r\n此路由创建新的个人访问令牌. 它需要两个数据: 令牌的 `name` 和 `scopes` 。\r\n\r\n```js\r\nconst data = {\r\n    name: 'Token Name',\r\n    scopes: []\r\n};\r\n\r\naxios.post('/oauth/personal-access-tokens', data)\r\n    .then(response => {\r\n        console.log(response.data.accessToken);\r\n    })\r\n    .catch (response => {\r\n        // 列出响应的错误...\r\n    });\r\n```\r\n\r\n<a name=\"delete-oauthpersonal-access-tokenstoken-id\"></a>\r\n#### `DELETE /oauth/personal-access-tokens/{token-id}`\r\n\r\n此路由可用于撤销个人访问令牌：\r\n\r\n```js\r\naxios.delete('/oauth/personal-access-tokens/' + tokenId);\r\n```\r\n\r\n<a name=\"protecting-routes\"></a>\r\n## 路由保护\r\n\r\n<a name=\"via-middleware\"></a>\r\n### 通过中间件\r\n\r\nPassport 包含一个 [验证保护机制](/docs/laravel/9.x/authentication#adding-custom-guards) 验证请求中传入的访问令牌。  若配置 `api` 的看守器使用 `passport` 驱动，你只要在需要有效访问令牌的路由上指定 `auth:api` 中间件即可：\r\n\r\n    Route::get('/user', function () {\r\n        //\r\n    })->middleware('auth:api');\r\n\r\n> 注意：如果你正在使用 [客户端授权令牌](#client-credentials-grant-tokens)，你应该使用 [`client` 中间件](#client-credentials-grant-tokens) 来保护你的路由，而不是使用 `auth:api` 中间件。\r\n\r\n\r\n\r\n<a name=\"multiple-authentication-guards\"></a>\r\n#### 多个身份验证 guard\r\n\r\n如果你的应用程序可能使用完全不同的 `Eloquent` 模型、不同类型的用户进行身份验证，则可能需要为应用程序中的每种用户设置 `guard`。 这使您可以保护特定 `guard` 的请求。 例如，设置以下 `guard` `config/auth.php` 配置文件：\r\n\r\n    'api' => [\r\n        'driver' => 'passport',\r\n        'provider' => 'users',\r\n    ],\r\n\r\n    'api-customers' => [\r\n        'driver' => 'passport',\r\n        'provider' => 'customers',\r\n    ],\r\n\r\n以下路由将使用 `customers` 用户提供者的 `api-customers` guard 来验证传入的请求：\r\n\r\n    Route::get('/customer', function () {\r\n        //\r\n    })->middleware('auth:api-customers');\r\n\r\n> 技巧：For more information on using multiple user providers with Passport, please consult the [password grant documentation](#customizing-the-user-provider).\r\n\r\n<a name=\"passing-the-access-token\"></a>\r\n### 传递访问令牌\r\n\r\n当调用 Passport 保护下的路由时，接入的 API 应用需要将访问令牌作为 `Bearer` 令牌放在请求头 `Authorization 中`。例如，使用 Guzzle HTTP 库时：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::withHeaders([\r\n        'Accept' => 'application/json',\r\n        'Authorization' => 'Bearer '.$accessToken,\r\n    ])->get('https://passport-app.test/api/user');\r\n\r\n    return $response->json();\r\n\r\n<a name=\"token-scopes\"></a>\r\n## 令牌作用域\r\n\r\n作用域可以让 API 客户端在请求账户授权时请求特定的权限。例如，如果你正在构建电子商务应用程序，并不是所有接入的 API 应用都需要下订单的功能。你可以让接入的 API 应用只被允许授权访问订单发货状态。换句话说，作用域允许应用程序的用户限制第三方应用程序执行的操作。\r\n\r\n\r\n<a name=\"defining-scopes\"></a>\r\n### 定义作用域\r\n\r\n你可以在 `App\\Providers\\AuthServiceProvider` 的 `boot` 方法中使用 `Passport::tokensCan` 方法来定义 API 的作用域。`tokensCan` 方法接受一个包含作用域名称和描述的数组作为参数。作用域描述将会在授权确认页中直接展示给用户，你可以将其定义为任何你需要的内容：\r\n\r\n    /**\r\n     * 注册身份验证/授权服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n\r\n        Passport::tokensCan([\r\n            'place-orders' => 'Place orders',\r\n            'check-status' => 'Check order status',\r\n        ]);\r\n    }\r\n\r\n<a name=\"default-scope\"></a>\r\n### 默认作用域\r\n\r\n如果客户端没有请求任何特定的范围，你可以在 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中使用 `setDefaultScope` 方法来定义默认的作用域。\r\n\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    Passport::tokensCan([\r\n        'place-orders' => 'Place orders',\r\n        'check-status' => 'Check order status',\r\n    ]);\r\n\r\n    Passport::setDefaultScope([\r\n        'check-status',\r\n        'place-orders',\r\n    ]);\r\n\r\n<a name=\"assigning-scopes-to-tokens\"></a>\r\n### 给令牌分配作用域\r\n\r\n<a name=\"when-requesting-authorization-codes\"></a>\r\n#### 请求授权码\r\n\r\n使用授权码请求访问令牌时，接入的应用需为 `scope` 参数指定所需作用域。 `scope` 参数包含多个作用域时，名称之间使用空格分割：\r\n\r\n    Route::get('/redirect', function () {\r\n        $query = http_build_query([\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://example.com/callback',\r\n            'response_type' => 'code',\r\n            'scope' => 'place-orders check-status',\r\n        ]);\r\n\r\n        return redirect('http://passport-app.test/oauth/authorize?'.$query);\r\n    });\r\n\r\n<a name=\"when-issuing-personal-access-tokens\"></a>\r\n#### 分发个人访问令牌\r\n\r\n使用 `App\\Models\\User` 模型的 `createToken` 方法发放个人访问令牌时，可以将所需作用域的数组作为第二个参数传给此方法：\r\n\r\n    $token = $user->createToken('My Token', ['place-orders'])->accessToken;\r\n\r\n\r\n\r\n<a name=\"checking-scopes\"></a>\r\n### 检查作用域\r\n\r\nPassport 包含两个中间件，可用于验证传入的请求是否包含访问指定作用域的令牌。 使用之前，需要将下面的中间件添加到 `app/Http/Kernel.php` 文件的 `$routeMiddleware` 属性中：\r\n\r\n    'scopes' => \\Laravel\\Passport\\Http\\Middleware\\CheckScopes::class,\r\n    'scope' => \\Laravel\\Passport\\Http\\Middleware\\CheckForAnyScope::class,\r\n\r\n<a name=\"check-for-all-scopes\"></a>\r\n#### 检查所有作用域\r\n\r\n路由可以使用 `scopes`  中间件来检查当前请求是否拥有指定的 *所有* 作用域：\r\n\r\n    Route::get('/orders', function () {\r\n        // 访问令牌具有 \"check-status\" 和 \"place-orders\" 作用域...\r\n    })->middleware(['auth:api', 'scopes:check-status,place-orders']);\r\n\r\n<a name=\"check-for-any-scopes\"></a>\r\n#### 检查任意作用域\r\n\r\n路由可以使用 `scope` 中间件来检查当前请求是否拥有指定的 *任意* 作用域：\r\n\r\n    Route::get('/orders', function () {\r\n        // 访问令牌具有 \"check-status\" 或 \"place-orders\" 作用域...\r\n    })->middleware(['auth:api', 'scope:check-status,place-orders']);\r\n\r\n<a name=\"checking-scopes-on-a-token-instance\"></a>\r\n#### 检查令牌实例上的作用域\r\n\r\n就算含有访问令牌验证的请求已经通过应用程序的验证，你仍然可以使用当前授权 `App\\Models\\User`  实例上的 `tokenCan` 方法来验证令牌是否拥有指定的作用域：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/orders', function (Request $request) {\r\n        if ($request->user()->tokenCan('place-orders')) {\r\n            //\r\n        }\r\n    });\r\n\r\n<a name=\"additional-scope-methods\"></a>\r\n#### 附加作用域方法\r\n\r\n`scopeIds` 方法将返回所有已定义 ID / 名称的数组：\r\n\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    Passport::scopeIds();\r\n\r\n\r\n\r\n`scopes` 方法将返回一个包含所有已定义作用域数组的 `Laravel\\Passport\\Scope` 实例：\r\n\r\n    Passport::scopes();\r\n\r\n`scopesFor` 方法将返回与给定 ID / 名称匹配的 `Laravel\\Passport\\Scope` 实例数组：\r\n\r\n    Passport::scopesFor(['place-orders', 'check-status']);\r\n\r\n你可以使用 `hasScope` 方法确定是否已定义给定作用域：\r\n\r\n    Passport::hasScope('place-orders');\r\n\r\n<a name=\"consuming-your-api-with-javascript\"></a>\r\n## 使用 JavaScript 接入 API\r\n\r\n在构建 API 时， 如果能通过 JavaScript 应用接入自己的 API 将会给开发过程带来极大的便利。这种 API 开发方法允许你使用自己的应用程序的 API 和别人共享的 API 。你的 Web 应用程序、移动应用程序、第三方应用程序以及可能在各种软件包管理器上发布的任何 SDK 都可能会使用相同的 API 。\r\n\r\n通常，如果要在 JavaScript 应用程序中使用 API ，需要手动向应用程序发送访问令牌，并将其传递给应用程序。但是， Passport 有一个可以处理这个问题的中间件。将 `CreateFreshApiToken` 中间件添加到 `app/Http/Kernel.php` 文件中的 `web` 中间件组就可以了：\r\n\r\n    'web' => [\r\n        // 其他中间件...\r\n        \\Laravel\\Passport\\Http\\Middleware\\CreateFreshApiToken::class,\r\n    ],\r\n\r\n> 注意：你需要确保 `CreateFreshApiToken` 中间件是你的中间件堆栈中的最后一个中间件。\r\n\r\n该中间件会将 `laravel_token` cookie 附加到您的响应中。该 cookie 将包含一个加密后的 JWT ， Passport 将用来验证来自 JavaScript 应用程序的 API 请求。JWT 的生命周期等于您的 `session.lifetime` 配置值。至此，您可以在不明确传递访问令牌的情况下向应用程序的 API 发出请求：\r\n\r\n    axios.get('/api/user')\r\n        .then(response => {\r\n            console.log(response.data);\r\n        });\r\n\r\n\r\n\r\n<a name=\"customizing-the-cookie-name\"></a>\r\n#### 自定义 Cookie 名称\r\n\r\n如果需要，你可以在 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中使用 `Passport::cookie` 方法来自定义 `laravel_token` cookie 的名称:\r\n\r\n    /**\r\n     * 注册认证 / 授权服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n\r\n        Passport::cookie('custom_name');\r\n    }\r\n\r\n<a name=\"csrf-protection\"></a>\r\n#### CSRF 保护\r\n\r\n当使用这种授权方法时，您需要确认请求中包含有效的 CSRF 令牌。默认的 Laravel JavaScript 脚手架会包含一个 Axios 实例，该实例是自动使用加密的 `XSRF-TOKEN` cookie 值在同源请求上发送 `X-XSRF-TOKEN` 请求头。\r\n\r\n> 技巧：如果您选择发送 `X-CSRF-TOKEN` 请求头而不是 `X-XSRF-TOKEN` ，则需要使用 `csrf_token()` 提供的未加密令牌。\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\nPassport 在发出访问令牌和刷新令牌时引发事件。 您可以使用这些事件来修改或撤消数据库中的其他访问令牌。如果您愿意，您可以在应用程序的 `App\\Providers\\EventServiceProvider` 类中将侦听器附加到这些事件：\r\n\r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Laravel\\Passport\\Events\\AccessTokenCreated' => [\r\n            'App\\Listeners\\RevokeOldTokens',\r\n        ],\r\n\r\n        'Laravel\\Passport\\Events\\RefreshTokenCreated' => [\r\n            'App\\Listeners\\PruneOldTokens',\r\n        ],\r\n    ];\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\nPassport 的 `actingAs` 方法可以指定当前已认证用户及其作用域。`actingAs` 方法的第一个参数是用户实例，第二个参数是用户令牌作用域数组：\r\n\r\n    use App\\Models\\User;\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    public function test_servers_can_be_created()\r\n    {\r\n        Passport::actingAs(\r\n            User::factory()->create(),\r\n            ['create-servers']\r\n        );\r\n\r\n        $response = $this->post('/api/create-server');\r\n\r\n        $response->assertStatus(201);\r\n    }\r\n\r\n\r\n\r\nPassport 的 `actingAsClient` 方法可以指定当前已认证用户及其作用域。 `actingAsClient` 方法的第一个参数是用户实例，第二个参数是用户令牌作用域数组：\r\n\r\n    use Laravel\\Passport\\Client;\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    public function test_orders_can_be_retrieved()\r\n    {\r\n        Passport::actingAsClient(\r\n            Client::factory()->create(),\r\n            ['check-status']\r\n        );\r\n\r\n        $response = $this->get('/api/orders');\r\n\r\n        $response->assertStatus(200);\r\n    }\r\n\r\n","p":"docs/passport.html"},{"t":"sail (Laravel Sail)","d":"# Laravel Sail\r\n\r\n- [介绍](#introduction)\r\n- [安装 & 设定](#installation)\r\n  - [安装 Sail 到当前应用中](#installing-sail-into-existing-applications)\r\n  - [配置 Bash 别名](#configuring-a-bash-alias)\r\n- [启动 & 停止 Sail](#starting-and-stopping-sail)\r\n- [执行命令](#executing-sail-commands)\r\n  - [执行 PHP 命令](#executing-php-commands)\r\n  - [执行 Composer 命令](#executing-composer-commands)\r\n  - [执行 Artisan 命令](#executing-artisan-commands)\r\n  - [执行 Node / NPM 命令](#executing-node-npm-commands)\r\n- [与数据库交互](#interacting-with-sail-databases)\r\n  - [MySQL](#mysql)\r\n  - [Redis](#redis)\r\n  - [MeiliSearch](#meilisearch)\r\n- [文件存储](#file-storage)\r\n-   [运行测试](#running-tests)\r\n  - [Laravel Dusk](#laravel-dusk)\r\n- [预览电子邮件](#previewing-emails)\r\n- [容器 CLI](#sail-container-cli)\r\n- [PHP 版本](#sail-php-versions)\r\n- [Node 版本](#sail-node-versions)\r\n- [共享您的网站](#sharing-your-site)\r\n- [使用 Xdebug 进行调试](#debugging-with-xdebug)\r\n  - [通过命令行使用 Xdebug 进行调试](#xdebug-cli-usage)\r\n  - [通过浏览器使用 Xdebug 进行调试](#xdebug-browser-usage)\r\n- [定制化](#sail-customization)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Sail](https://github.com/laravel/sail) 是一个轻量级的命令行界面，用于与 Laravel 的默认 Docker 开发环境进行交互。Sail 为使用 PHP，MySQL 和 Redis 构建 Laravel 应用程序提供了一个很好的起点，而无需事先具有 Docker 经验。\r\n\r\nSail 的核心是 `docker-compose.yml` 文件和存储在项目根目录的 `sail` 脚本。`sail` 脚本为 CLI 提供了便捷的方法，可用于与 `docker-compose.yml` 文件定义的 Docker 容器进行交互。\r\n\r\nLaravel Sail 支持 macOS、Linux 和 Windows (通过 [WSL2](https://docs.microsoft.com/en-us/windows/wsl/about)）。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装 & 设定\r\n\r\nLaravel Sail 会随着所有全新的 Laravel 应用程序一起自动安装，因此你可以立即的开始使用它. 要了解如何创建一个新的 Laravel 应用程序，请查阅适合您目前操作系统的 [安装文档](https://learnku.com/docs/laravel/8.x/installation)。在安装过程中，你将被要求选择你的应用程序将与哪些 Sail 支持的服务进行交互。\r\n\r\n<a name=\"installing-sail-into-existing-applications\"></a>\r\n### 安装 Sail 到当前应用中\r\n\r\n假如你有兴趣在你现有的 Laravel 应用程序中使用 Sail，你可以透过 Composer 套件管理简单的安装 Sail。当然，这些步骤的前提是假设你现有的本地开发环境允许你安装 Copmoser 依赖：\r\n\r\n```shell\r\ncomposer require laravel/sail --dev\r\n```\r\n\r\n在 Sail 完成安装后，你可以运行 Artisan 命令 `sail:install`。这个命令将会发布 Sail 的 `docker-compose.yml` 文件到你应用程序的根目录：\r\n\r\n```shell\r\nphp artisan sail:install\r\n```\r\n\r\n最后，你可以启动 Sail 的服务了。想要继续学习如何使用 Sail，请接着阅读本文挡的其余部分：\r\n\r\n```shell\r\n./vendor/bin/sail up\r\n```\r\n\r\n<a name=\"using-devcontainers\"></a>\r\n#### 使用开发容器\r\n\r\n如果你想在 [Devcontainer](https://code.visualstudio.com/docs/remote/containers) 中进行开发，你可以在执行 `sail:install` 命令时添加 `--devcontainer` 参数。`--devcontainer` 将指示 `sail:install` 命令将默认的 `.devcontainer/devcontainer.json` 文件发布到你的应用程序根目录：\r\n\r\n```shell\r\nphp artisan sail:install --devcontainer\r\n```\r\n\r\n<a name=\"configuring-a-bash-alias\"></a>\r\n### 配置 Bash 别名\r\n\r\n默认情况下，Sail 命令使用 `vendor/bin/sail` 脚本调用，该脚本已包含在所有新建的 Laravel 应用程序中：\r\n\r\n```shell\r\n./vendor/bin/sail up\r\n```\r\n\r\n但与其重复的输入 `vendor/bin/sail` 来执行 Sail 命令，你可能会希望配置一个 Bash 别名方便你更容易的执行 Sail 命令：\r\n\r\n```shell\r\nalias sail='[ -f sail ] && bash sail || bash vendor/bin/sail'\r\n```\r\n\r\n> 补充：通过 `vim ~/.bashrc` 或  `vim ~/.zshrc` 加入别名，可以让别名常驻。\r\n\r\n一旦配置了 Bash 别名，你可以通过简单的键入 `sail` 来执行 Sail 命令. 本文接下来的示例都假定你已经配置了此别名：\r\n\r\n```shell\r\nsail up\r\n```\r\n\r\n\r\n\r\n<a name=\"starting-and-stopping-sail\"></a>\r\n## 启动 & 停止 Sail\r\n\r\nLaravel Sail 的 `docker-compose.yml` 文件定义了各种 Docker 容器，它们可以协同工作以帮助你构建 Laravel 应用程序。每一个容器都定义在 `docker-compose.yml` 文件的 `services` 的配置内。 `laravel.test` 容器是将服务于您的应用程序的主要应用程序容器。\r\n\r\n在开始 Sail 之前，你应该确认没有其他的网站服务器或数据库正运行在你的本地计算机上. 要开始启用 `docker-compose.yml` 文件中定义的所有 Docker 容器，请执行 `up` 命令：\r\n\r\n```shell\r\nsail up\r\n```\r\n\r\n要在后台启动所有 Docker 容器，你可以在「分离 (detached)」模式下启动 Sail：\r\n\r\n```shell\r\nsail up -d\r\n```\r\n\r\n启动应用程序的容器后，你可以通过 Web 浏览器中访问项目：[http://localhost](http://localhost/).\r\n\r\n要停止所有容器，只需按下 `Control + C` 即可停止容器的执行。如果容器在后台运行，你可以使用 `stop` 命令：\r\n\r\n```shell\r\nsail stop\r\n```\r\n\r\n<a name=\"executing-sail-commands\"></a>\r\n## 执行命令\r\n\r\n使用 Laravel Sail 时，应用程序在 Docker 容器中执行，并且与本地计算机隔离。不过 Sail 提供了一种针对应用程序运行各种命令的便捷方法，例如任意的 PHP 命令，Artisan 命令，Composer 命令和 Node / NPM 命令。\r\n\r\n**当你阅读 Laravel 文档时，你可能经常看到在未使用 Sail 的状况下运行 Composer，Artisan 或是 Node / NPM 命令。** 以下示例假设你已经在本地计算机上安装上述工具。如果你打算使用 Sail 建构你的本地开发环境 ，你需要改用 Sail 运行这些命令：\r\n\r\n```shell\r\n# Running Artisan commands locally...\r\nphp artisan queue:work\r\n\r\n# Running Artisan commands within Laravel Sail...\r\nsail artisan queue:work\r\n```\r\n\r\n\r\n\r\n<a name=\"executing-php-commands\"></a>\r\n### 执行 PHP 命令\r\n\r\nPHP 命令可以使用 `php` 命令执行。当然，这些命令将使用为你的应用程序配置的 PHP 版本执行。要了解更多关于 PHP 版本可用的 Laravel Sail 信息，请查阅 [PHP 版本文档](#sail-php-versions)：\r\n\r\n```shell\r\nsail php --version\r\n\r\nsail php script.php\r\n```\r\n\r\n<a name=\"executing-composer-commands\"></a>\r\n### 执行 Composer 命令\r\n\r\nComposer 命令可以使用 `composer` 命令执行。Laravel Sail 的应用程序容器中已经安装 Composer 2.x：\r\n\r\n```nothing\r\nsail composer require laravel/sanctum\r\n```\r\n\r\n<a name=\"installing-composer-dependencies-for-existing-projects\"></a>\r\n#### 在已运行的应用中安装 Composer 依赖\r\n\r\n假如你与团队一起开发应用程序，你也许不是最初创建 Laravel 应用程序的人。因此，当你克隆应用程序的仓库到本地计算机后，仓库默认不会安装的任何 Composer 依赖项，也包括 Sail。\r\n\r\n你可以进入到应用程序目录下并执行以下命令来安装应用所需的依赖，这个命令使用一个包含 PHP 与 Composer 的小型 Docker 容器进行应用程序依赖的安装：\r\n\r\n```shell\r\ndocker run --rm \\\r\n    -u \"$(id -u):$(id -g)\" \\\r\n    -v $(pwd):/var/www/html \\\r\n    -w /var/www/html \\\r\n    laravelsail/php81-composer:latest \\\r\n    composer install --ignore-platform-reqs\r\n```\r\n\r\n\r\n当你使用 `laravelsail/phpXX-composer` 镜像时，你应该选择和你的应用程序所用环境相同的 PHP 版本（`74`、`80` 或 `81`）。\r\n\r\n<a name=\"executing-artisan-commands\"></a>\r\n### 执行 Artisan 命令\r\n\r\nArtisan 命令可以使用 `artisan` 命令执行：\r\n\r\n```shell\r\nsail artisan queue:work\r\n```\r\n\r\n<a name=\"executing-node-npm-commands\"></a>\r\n### 执行 Node / NPM 命令\r\n\r\n\r\n\r\nNode 命令可以使用 `node` 命令执行，而 NPM 命令可以使用 `npm` 命令执行：\r\n\r\n```shell\r\nsail node --version\r\n\r\nsail npm run prod\r\n```\r\n\r\n如果你愿意，你可以使用 Yarn 代替 NPM：\r\n\r\n```shell\r\nsail yarn\r\n```\r\n\r\n<a name=\"interacting-with-sail-databases\"></a>\r\n## 与数据库交互\r\n\r\n<a name=\"mysql\"></a>\r\n### MySQL\r\n\r\n你可能已经注意到，应用程序的 `docker-compose.yml` 文件包含一个 MySQL 容器的配置。该容器使用了 [Docker volume](https://docs.docker.com/storage/volumes/)，以便即使在停止和重新启动容器时依然可以持久存储数据库中存储的数据。此外，当 MySQL 容器启动时，它将确保存在名称与你的 `DB_DATABASE` 环境变量的值匹配的数据库。\r\n\r\n启动容器后，你可以通过将应用程序 `.env` 文件中的 `DB_HOST` 环境变量设置为 `mysql` 来连接到应用程序中的 MySQL 实例。\r\n\r\n要从本地计算机连接到应用程序的 MySQL 数据库，你可以使用图形数据库管理应用程序，例如 [TablePlus](https://tableplus.com/)。默认情况下，可以从 `localhost` 的 3306 端口访问 MySQL 数据库。\r\n\r\n<a name=\"redis\"></a>\r\n### Redis\r\n\r\n应用程序的 `docker-compose.yml` 文件也包含 [Redis](https://redis.io/) 容器的配置，此容器使用 [Docker volume](https://docs.docker.com/storage/volumes/)，以便即使在停止和重新启动容器后，Redis 数据中存储的数据也可以持久保存。启动容器后，可以通过将应用程序 `.env` 文件中的环境变量 `REDIS_HOST` 设置为 `redis` 来连接到应用程序中的 Redis 实例。\r\n\r\n要从本地计算机连接到应用程序的 Redis 数据库，可以使用图形数据库管理应用程序，例如 [TablePlus](https://tableplus.com/)。默认情况下，可以从 `localhost` 的 6379 端口访问 Redis 数据库。\r\n\r\n<a name=\"meilisearch\"></a>\r\n### MeiliSearch\r\n\r\n如果你在安装 Sail 时选择安装 [MeiliSearch](https://www.meilisearch.com) 服务，你的应用程序的 `docker-compose.yml` 文件将包含一个 [Laravel Scout](/docs/laravel/9.x/scout) 兼容且强大的[搜索引擎服务组件配置](https://github.com/meilisearch/meilisearch-laravel-scout)。启动容器后，你可以通过将环境变量 `MEILISEARCH_HOST` 设置为 `http://meilisearch:7700` 来连接到应用程序中的 MeiliSearch 实例。\r\n\r\n要从本地计算机访问 MeiliSearch 的 Web 管理面板，你可以通过浏览器访问 `http://localhost:7700`。\r\n\r\n<a name=\"file-storage\"></a>\r\n## 文件存储\r\n\r\n如果你计划在生产环境中运行应用程序时使用 Amazon S3 存储文件，你可能希望在安装 Sail 时安装 [MinIO](https://min.io) 服务。 MinIO 提供了一个与 S3 兼容的 API，你可以使用 Laravel 的 `s3` 文件存储驱动程序在本地进行开发，而无需在生产 S3 环境中创建用于测试的存储桶。如果在安装 Sail 时选择安装 MinIO，部分 MinIO 相关的配置将添加到应用程序的 `docker-compose.yml` 文件中。\r\n\r\n默认情况下，应用程序的 `filesystems`  配置文件已经包含 `s3` 磁盘的磁盘配置。除了使用此磁盘与 Amazon S3 交互之外，你还可以使用它与任何 S3 兼容的文件存储服务（例如 MinIO）进行交互，只需修改控制其配置的关联环境变量即可。例如，在使用 MinIO 时，你的文件系统环境变量配置应定义如下：\r\n\r\n```ini\r\nFILESYSTEM_DRIVER=s3\r\nAWS_ACCESS_KEY_ID=sail\r\nAWS_SECRET_ACCESS_KEY=password\r\nAWS_DEFAULT_REGION=us-east-1\r\nAWS_BUCKET=local\r\nAWS_ENDPOINT=http://minio:9000\r\nAWS_USE_PATH_STYLE_ENDPOINT=true\r\n```\r\n\r\n\r\n<a name=\"running-tests\"></a>\r\n## 运行测试\r\n\r\nLaravel 提供了出色的开箱即用测试，你可以使用 Sail 的 `test` 命令运行应用程序的 [功能和单元测试](/docs/laravel/9.x/testing)。任何 PHPUnit 可接受的命令选项都可以透过 `test` 命令传递：\r\n\r\n\r\n```shell\r\nsail test\r\n\r\nsail test --group orders\r\n```\r\n\r\nSail `test` 命令相当于运行 Artisan `test` 命令：\r\n\r\n```shell\r\nsail artisan test\r\n```\r\n\r\n<a name=\"laravel-dusk\"></a>\r\n### Laravel Dusk\r\n\r\n[Laravel Dusk](/docs/laravel/9.x/dusk) 提供了非常优雅、易于使用的浏览器自动化测试 API。有了 Sail，进行浏览器测试更加方便了，你甚至不用在你的本地电脑上安装 Selenium 或者任何其他工具。要开启这项功能，请在 `docker-compose.yml` 文件中取消 Selenium 服务相关配置的注释：\r\n\r\n```yaml\r\nselenium:\r\n    image: 'selenium/standalone-chrome'\r\n    volumes:\r\n        - '/dev/shm:/dev/shm'\r\n    networks:\r\n        - sail\r\n```\r\n\r\n下一步，请确认 `docker-compose.yml` 文件中的 `laravel.test` 服务配置 `depends_on` 是否包含了 `selenium` 选项：\r\n\r\n```yaml\r\ndepends_on:\r\n    - mysql\r\n    - redis\r\n    - selenium\r\n```\r\n\r\n最后，你可以透过启动 Sail 并运行 `dusk` 命令来进行 Dusk 测试：\r\n\r\n```shell\r\nsail dusk\r\n```\r\n\r\n<a name=\"selenium-on-apple-silicon\"></a>\r\n#### 在 Apple Silicon 上运行 Selenium\r\n\r\n如果你的本地机器包含 Apple Silicon 芯片，你的 `selenium` 服务必须使用 `seleniarm/standalone-chromium` 镜像：\r\n\r\n```yaml\r\nselenium:\r\n    image: 'seleniarm/standalone-chromium'\r\n    volumes:\r\n        - '/dev/shm:/dev/shm'\r\n    networks:\r\n        - sail\r\n```\r\n\r\n<a name=\"previewing-emails\"></a>\r\n## 预览电子邮件\r\n\r\nLaravel Sail 默认的 `docker-compose.yml` 文件中包含了一个服务项 [MailHog](https://github.com/mailhog/MailHog)。MailHog 会在你本地开发的过程中拦截应用程序发送的电子邮件，并提供一个便捷的 Web 界面，方便你透过浏览器预览电子邮件。使用 Sail 时，MailHog 默认的主机名称是 `mailhog` 并使用 1025 端口：\r\n\r\n```ini\r\nMAIL_HOST=mailhog\r\nMAIL_PORT=1025\r\nMAIL_ENCRYPTION=null\r\n```\r\n\r\n\r\n\r\n当 Sail 运行时，你可以透过 [http://localhost:8025](http://localhost:8025/) 访问 MailHog 的 Web 界面。\r\n\r\n<a name=\"sail-container-cli\"></a>\r\n## 容器 CLI\r\n\r\n有时候，你可能想要在应用容器中开启一个 Bash 会话。 可以通过执行 `shell` 命令，以访问容器中的文件和已安装的服务，此外，你还可以执行其他任意 Shell 指令：\r\n\r\n```shell\r\nsail shell\r\n\r\nsail root-shell\r\n```\r\n\r\n想打开一个新的 [Laravel Tinker](https://github.com/laravel/tinker) 会话，你可以执行 `tinker` 命令：\r\n\r\n```shell\r\nsail tinker\r\n```\r\n\r\n<a name=\"sail-php-versions\"></a>\r\n## PHP 版本\r\n\r\nSail 目前支持通过 PHP 8.1、PHP 8.0 或 PHP 7.4 为你的应用程序提供服务。想更改应用程序使用的 PHP 版本，请在 `docker-compose.yml` 文件定义的容器 `laravel.test` 相应配置中调整 `build` 定义:\r\n\r\n```yaml\r\n# PHP 8.1\r\ncontext: ./vendor/laravel/sail/runtimes/8.1\r\n\r\n# PHP 8.0\r\ncontext: ./vendor/laravel/sail/runtimes/8.0\r\n\r\n# PHP 7.4\r\ncontext: ./vendor/laravel/sail/runtimes/7.4\r\n```\r\n\r\n此外，你如果想更新你的镜像名称来反映当前使用的 PHP 版本，你可以在 `docker-compose.yml` 文件中调整 `image` 字段：\r\n\r\n```yaml\r\nimage: sail-8.1/app\r\n```\r\n\r\n在修改 `docker-compose.yml` 文件过后，你需要重建容器镜像并重启 Sail：\r\n\r\n```shell\r\nsail build --no-cache\r\n\r\nsail up\r\n```\r\n\r\n<a name=\"sail-node-versions\"></a>\r\n## Node 版本\r\n\r\nSail 默认安装 Node 16。要更改镜像构建时所安装的 Node 版本，你可以在应用程序的 `docker-compose.yml` 文件中更新 `laravel.test` 服务的 `build.args` 定义：\r\n\r\n```yaml\r\nbuild:\r\n    args:\r\n        WWWGROUP: '${WWWGROUP}'\r\n        NODE_VERSION: '14'\r\n```\r\n\r\n在修改 `docker-compose.yml` 文件过后，你需要重建容器镜像并重启 Sail：\r\n\r\n```shell\r\nsail build --no-cache\r\n\r\nsail up\r\n```\r\n\r\n\r\n\r\n<a name=\"sharing-your-site\"></a>\r\n## 共享你的网站\r\n\r\n有时候你可能需要公开分享你的网站给同事，或是测试应用与 Webhook 的集成。想共享你的网站时，可以使用 `share` 命令。当你执行此命令后，将会获取一个随机的网址，例如 `laravel-sail.site` 用来访问你的应用程序：\r\n\r\n```shell\r\nsail share\r\n```\r\n\r\n当通过 `share` 命令共享您的站点时，您应该在 `TrustProxies` 中间件中配置应用程序的可信代理。否则，相关的URL 生成的助手函数，例如 `url` 和 `route` 将无法在生成 URL 生成过程中选择正确 HTTP 主机地址：\r\n\r\n    /**\r\n     * 应用程序的受信任代理\r\n     *\r\n     * @var array|string|null\r\n     */\r\n    protected $proxies = '*';\r\n\r\n如果你想为你的共享站点自定义子域名，可以在执行 `share` 命令时加上 `subdomain` 参数：\r\n\r\n```shell\r\nsail share --subdomain=my-sail-site\r\n```\r\n\r\n> Tip：`share` 命令是由 [Expose](https://github.com/beyondcode/expose) 提供，这是 [BeyondCode](https://beyondco.de/) 的一个开源网络隧道服务。\r\n\r\n<a name=\"debugging-with-xdebug\"></a>\r\n## 使用 Xdebug 进行调试\r\n\r\nLaravel Sail 的 Docker 配置包含对 [Xdebug](https://xdebug.org/) 的支持，这是一个流行且强大的 PHP 调试器。为了启用 Xdebug，你需要在应用程序的 `.env` 文件中添加一些变量以 [配置 Xdebug](https://xdebug.org/docs/step_debug#mode)。要启用 Xdebug，您必须在启动 Sail 之前设置适当的应用模式：\r\n\r\n```ini\r\nSAIL_XDEBUG_MODE=develop,debug\r\n```\r\n\r\n#### Linux 主机 IP 配置\r\n\r\n\r\n\r\n在容器内部，`XDEBUG_CONFIG` 环境变量被定义为 `client_host=host.docker.internal` 以便为 Mac 和 Windows (WSL2) 正确配置 Xdebug。如果你的本地机器运行的是 Linux，你将需要手动定义这个环境变量。\r\n\r\n首先，你需要通过运行以下命令来确定要添加到环境变量中的正确主机 IP 地址。通常，`<container-name>` 应该是为你的应用程序提供服务的容器的名称，并且通常以 `_laravel.test_1` 结尾：\r\n\r\n```shell\r\ndocker inspect -f {{range.NetworkSettings.Networks}}{{.Gateway}}{{end}} <container-name>\r\n```\r\n\r\n在获得正确的主机 IP 地址后，你需要在应用程序的 `.env` 文件中定义 `SAIL_XDEBUG_CONFIG` 变量：\r\n\r\n```ini\r\nSAIL_XDEBUG_CONFIG=\"client_host=<host-ip-address>\"\r\n```\r\n\r\n<a name=\"xdebug-cli-usage\"></a>\r\n### 通过命令行使用 Xdebug 进行调试\r\n\r\n在运行 Artisan 命令时，可以使用 `sail debug` 命令启动调试会话：\r\n\r\n```shell\r\n# 在没有 Xdebug 的情况下运行 Artisan 命令...\r\nsail artisan migrate\r\n\r\n# 使用 Xdebug 运行 Artisan 命令...\r\nsail debug migrate\r\n```\r\n\r\n<a name=\"xdebug-browser-usage\"></a>\r\n### 通过浏览器使用 Xdebug 进行调试\r\n\r\n要在通过 Web 浏览器与应用程序交互时调试你的应用程序，请按照 [Xdebug 提供的说明](https://xdebug.org/docs/step_debug#web-application) 从 Web 浏览器启动 Xdebug 会话。\r\n\r\n如果你使用的是 PhpStorm，请查看 JetBrains 关于 [零配置调试](https://www.jetbrains.com/help/phpstorm/zero-configuration-debugging.html) 的文档。\r\n\r\n> 注意：Laravel Sail 依赖于 `artisan serve` 来为你的应用程序提供服务。从 Laravel 8.53.0 版本开始，`artisan serve` 命令只接受 `XDEBUG_CONFIG` 和 `XDEBUG_MODE` 变量。旧版本的 Laravel（8.52.0 及以下）不支持这些变量并且不接受调试连接。\r\n\r\n\r\n<a name=\"sail-customization\"></a>\r\n## 定制化\r\n\r\n因为 Sail 就是 Docker，所以你可以自由的定制任何内容，使用 `sail:publish` 命令可以将 Sail 预设的 Dockerfile 发布到你的应用程序中，以便于进行定制：\r\n\r\n```shell\r\nsail artisan sail:publish\r\n```\r\n\r\n运行这个命令后，Laravel Sail 预设好的 Dockerfile 和其他配置文件将被生成发布到项目根目录的 `docker` 目录中。当你自行定制 Sail 配置之后，你可以在应用程序的 `docker-compose.yml` 文件中更改应用程序容器的映像名称。在完成上述操作后，你需要使用 `build` 命令重新构建容器。如果你使用 Sail 在单台机器上开发多个 Laravel 应用程序，那么为应用程序的镜像分配一个唯一的名称将尤为重要：\r\n\r\n```shell\r\nsail build --no-cache\r\n```\r\n\r\n","p":"docs/sail.html"},{"t":"sanctum (Laravel Sanctum)","d":"\n# Laravel Sanctum\r\n\r\n- [介绍](#introduction)\r\n    - [工作原理](#how-it-works)\r\n- [安装](#installation)\r\n- [配置](#configuration)\r\n    - [覆盖默认模型](#overriding-default-models)\r\n- [API 令牌认证](#api-token-authentication)\r\n    - [发行 API 令牌](#issuing-api-tokens)\r\n    - [令牌能力](#token-abilities)\r\n    - [保护路由](#protecting-routes)\r\n    - [撤销令牌](#revoking-tokens)\r\n- [SPA 认证](#spa-authentication)\r\n    - [配置](#spa-configuration)\r\n    - [认证](#spa-authenticating)\r\n    - [保护路由](#protecting-spa-routes)\r\n    - [授权私人广播频道](#authorizing-private-broadcast-channels)\r\n- [移动应用认证](#mobile-application-authentication)\r\n    - [发行 API 令牌](#issuing-mobile-api-tokens)\r\n    - [保护路由](#protecting-mobile-api-routes)\r\n    - [撤销令牌](#revoking-mobile-api-tokens)\r\n- [测试](#testing)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Sanctum](https://github.com/laravel/sanctum) 为 SPA（单页应用程序）、移动应用程序和基于令牌的、简单的 API 提供轻量级身份验证系统。Sanctum 允许应用程序的每个用户为他们的帐户生成多个 API 令牌。这些令牌可以被授予指定允许令牌执行哪些操作的能力 / 范围。\r\n\r\n<a name=\"how-it-works\"></a>\r\n### 工作原理\r\n\r\nLaravel Sanctum 是为了解决两个独立问题而生。在深入研究之前，我们先来讨论一下。\r\n\r\n<a name=\"how-it-works-api-tokens\"></a>\r\n#### API 令牌\r\n\r\n首先，它是一个简单的包，用于向用户发出 API 令牌，而不涉及 OAuth。这个功能的灵感来自 GitHub 的「访问令牌」。例如，假设应用程序的「帐户设置」有一个界面，用户可以在其中为其帐户生成 API 令牌。你可以使用 Sanctum 来生成和管理这些令牌。这些令牌通常有很长的过期时间（以年计），当然用户可以随时手动将其撤销。\r\n\n\nLaravel Sanctum 的这个特性是通过将用户 API 令牌存储在单个数据库表中，并通过包含了有效 API 令牌的 `Authorization` 标识头对传入的请求进行身份验证而实现的。\r\n\r\n<a name=\"how-it-works-spa-authentication\"></a>\r\n#### SPA 身份验证\r\n\r\n其次，Sanctum 提供了一种简单的方法来认证需要与基于 Laravel 的 API 进行通信的单页应用程序 (SPAs)。这些 SPAs 可能与 Laravel 应用程序存在于同一仓库中，也可能是一个完全独立的仓库，例如使用 Vue CLI 或者 Next.js 创建的单页应用。\r\n\r\n对于此功能，Sanctum 不使用任何类型的令牌。相反，Sanctum 使用 Laravel 内置的基于 cookie 的会话身份验证服务。这提供了 CSRF 保护，会话身份验证以及防止因 XSS 攻击而泄漏身份验证凭据。仅当传入请求来自您自己的 SPA 前端时，Sanctum 才会尝试使用 Cookie 进行身份验证。通常，Sanctum 利用 Laravel 的 web 身份验证保护来实现这一点。这提供了 CSRF 保护、会话身份验证以及防止通过 XSS 攻击而泄漏身份验证凭据。\r\n\r\nSanctum 处理你自己的 SPA 前端的请求时，只会尝试使用 cookie 进行身份验证。当 Sanctum 检查传入的 HTTP 请求时，它将首先检查验证身份的 cookie，如果不存在，Sanctum 将检查 `Authorization` 标识头以获取有效的 API 令牌。\r\n\r\n> 技巧：仅将 Sanctum 用于API令牌身份验证或仅用于 SPA 身份验证也是完全可以的。因为你使用 Sanctum 并不意味着你必须同时使用它提供的两种功能。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n> 技巧：最新版本的 Laravel 已经包含了 Laravel Sanctum，但是，如果您的应用程序中 composer.json 文件里不包含 `\"laravel/sanctum\"` 的话，您可以按照下面的说明进行安装。\r\n\r\n\n\n您可以通过Composer软件包管理器安装Laravel Sanctum：\r\n\r\n```shell\r\ncomposer require laravel/sanctum\r\n```\r\n接下来，你需要使用 `vendor:publish` Artisan 命令发布 Sanctum 的配置和迁移文件。Sanctum 的配置文件将会保存在 `config` 文件夹中：\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Sanctum\\SanctumServiceProvider\"\r\n```\r\n\r\n最后，您应该运行数据库迁移。 Sanctum 将创建一个数据库表来存储 API 令牌：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n接下来，如果您想利用 Sanctum 对 SPA 进行身份验证，您应该将 Sanctum 的中间件添加到您应用的 `app/Http/Kernel.php` 文件中的 `api` 中间件组中：\r\n\r\n    'api' => [\r\n        \\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class,\r\n        'throttle:api',\r\n        \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n    ],\r\n\r\n<a name=\"migration-customization\"></a>\r\n#### 自定义迁移\r\n\r\n如果你不想使用 Sanctum 的默认迁移，你应该在 ` App\\Providers\\AppServiceProvider` 类的 register 方法中调用 `Sanctum::ignoreMigrations` 方法。 您可以通过执行以下命令导出默认迁移：`php artisan vendor:publish --tag=sanctum-migrations`\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"overriding-default-models\"></a>\r\n### 重写默认模型\r\n\r\n尽管通常不需要，但您可以自由扩展 Sanctum 内部使用的 `PersonalAccessToken` 模型：\r\n\r\n    use Laravel\\Sanctum\\PersonalAccessToken as SanctumPersonalAccessToken;\r\n\r\n    class PersonalAccessToken extends SanctumPersonalAccessToken\r\n    {\r\n        // ...\r\n    }\r\n\r\n然后，您可以通过 Sanctum 提供的 `usePersonalAccessTokenModel` 方法指示 Sanctum 使用您的自定义模型。 通常，您应该在应用程序的服务提供器的 `boot` 方法中调用此方法：\r\n\r\n    use App\\Models\\Sanctum\\PersonalAccessToken;\r\n    use Laravel\\Sanctum\\Sanctum;\r\n\r\n    /**\r\n     * 引导应用程序服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Sanctum::usePersonalAccessTokenModel(PersonalAccessToken::class);\r\n    }\r\n\r\n\n\n<a name=\"api-token-authentication\"></a>\r\n## API 令牌认证\r\n\r\n> 技巧：你不应使用 API 令牌来验证自己的第一方 SPA。 而应使用 Sanctum 的内置 [SPA 身份验证功能](#spa-authentication)。\r\n\r\n<a name=\"issuing-api-tokens\"></a>\r\n### 发布 API Tokens\r\n\r\nSanctum 允许你发布 API 令牌／个人访问令牌，用于对你的应用程序的 API 请求进行身份验证。 使用 API 令牌发出请求时，令牌应作为 `Bearer` 令牌包含在 `Authorization` 请求头中。\r\n\r\n要开始为用户颁发令牌，你的 User 模型应使用 `Laravel\\Sanctum\\HasApiTokens` trait：\r\n\r\n    use Laravel\\Sanctum\\HasApiTokens;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use HasApiTokens, HasFactory, Notifiable;\r\n    }\r\n\r\n要发布令牌，你可以使用 `createToken` 方法。 `createToken` 方法返回一个 `Laravel\\Sanctum\\NewAccessToken` 实例。 在存入数据库之前，API 令牌已使用 SHA-256 哈希加密过，但你可以使用 `NewAccessToken` 实例的 `plainTextToken` 属性访问令牌的纯文本值。创建令牌后，你应该立即向用户显示此值：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/tokens/create', function (Request $request) {\r\n        $token = $request->user()->createToken($request->token_name);\r\n\r\n        return ['token' => $token->plainTextToken];\r\n    });\r\n\r\n你可以使用 `HasApiTokens` trait 提供的 `tokens` Eloquent 关系访问用户的所有令牌：\r\n\r\n    foreach ($user->tokens as $token) {\r\n        //\r\n    }\r\n\r\n<a name=\"token-abilities\"></a>\r\n### 令牌能力\r\n\r\nSanctum 允许你将 「能力」分配给令牌。能力的用途与 OAuth 的「Scope」类似。你可以将字符串能力数组作为第二个参数传递给 `createToken` 方法：\r\n\r\n    return $user->createToken('token-name', ['server:update'])->plainTextToken;\r\n\r\n\n\n在处理由 Sanctum 验证的传入请求时，你可以使用 `tokenCan` 方法确定令牌是否具有给定的能力：\r\n\r\n    if ($user->tokenCan('server:update')) {\r\n        //\r\n    }\r\n\r\n<a name=\"token-ability-middleware\"></a>\r\n#### 令牌能力中间件\r\n\r\nSanctum 还包括两个中间件，可用于验证传入请求是否使用已被授予给定能力的令牌进行身份验证。首先，将以下中间件添加到应用程序的 `app/Http/Kernel.php` 文件的 `$routeMiddleware` 属性中：\r\n\r\n    'abilities' => \\Laravel\\Sanctum\\Http\\Middleware\\CheckAbilities::class,\r\n    'ability' => \\Laravel\\Sanctum\\Http\\Middleware\\CheckForAnyAbility::class,\r\n\r\n`abilities` 中间件可以分配给一个路由，以验证传入请求的令牌是否具有所有列出的能力：\r\n\r\n    Route::get('/orders', function () {\r\n        // Token has both \"check-status\" and \"place-orders\" abilities...\r\n    })->middleware(['auth:sanctum', 'abilities:check-status,place-orders']);\r\n\r\n`ability` 中间件可以分配给一个路由，以验证传入请求的令牌是否具有*至少一个*列出的能力：\r\n\r\n    Route::get('/orders', function () {\r\n        // Token has the \"check-status\" or \"place-orders\" ability...\r\n    })->middleware(['auth:sanctum', 'ability:check-status,place-orders']);\r\n\r\n<a name=\"first-party-ui-initiated-requests\"></a>\r\n#### 第一方 UI 发起的请求\r\n\r\n为方便起见，如果传入的经过身份验证的请求来自你的第一方 SPA，并且你正在使用 Sanctum 的内置 [SPA 身份验证](#spa-authentication)，则 `tokenCan` 方法将始终返回 `true`。\r\n\r\n但是，这并不一定意味着你的应用必须允许用户执行操作。通常，你的应用的 [授权策略](/docs/laravel/9.x/authorization#creating-policies) 将确定令牌是否已被授予执行能力的权限，并检查是否应允许用户实例本身来执行操作。\r\n\r\n\n\n例如，假设我们有一个管理服务器的应用，那就要检查令牌是否有权更新服务器 **和** 服务器是否属于用户：\r\n\r\n```php\r\nreturn $request->user()->id === $server->user_id &&\r\n       $request->user()->tokenCan('server:update')\r\n```\r\n\r\n起初，允许调用 `tokenCan` 方法并始终为第一方 UI 发起的请求返回 `true` 可能看起来很奇怪； 但是，能够始终假设 API 令牌可用并且可以通过 `tokenCan` 方法进行检查是很方便的。 通过采用这种方法，你可以始终在应用程序的授权策略中调用 `tokenCan` 方法，而无需担心请求是从应用程序的 UI 触发还是由 API 的第三方使用者之一发起。\r\n\r\n<a name=\"protecting-routes\"></a>\r\n### 保护路由\r\n\r\n为了保护路由，所有传入请求都必须经过身份验证，你应该将 `sanctum` 身份验证看守器附加到 `routes/web.php` 和 `routes/api.php` 中的受保护路由。 如果请求来自第三方，此看守器将确保传入请求被验证为有状态的 cookie 验证请求或包含有效的 API 令牌请求头。\r\n\r\n你可能想知道为什么我们建议你使用 `sanctum` 看守器来验证应用程序的 `routes/web.php` 文件中的路由。 请记住，Sanctum 将首先尝试使用 Laravel 的典型 session 身份验证 cookie 对传入请求进行身份验证。 如果该 cookie 不存在，则 Sanctum 将尝试使用请求的 `Authorization` 请求头中的令牌来验证请求。 此外，使用 Sanctum 对所有请求进行身份验证可确保我们始终可以在当前经过身份验证的用户实例上调用 `tokenCan` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::middleware('auth:sanctum')->get('/user', function (Request $request) {\r\n        return $request->user();\r\n    });\r\n\r\n\n\n<a name=\"revoking-tokens\"></a>\r\n### 撤销令牌\r\n\r\n你可以通过使用 `Laravel\\Sanctum\\HasApiTokens` trait 提供的 `tokens` 关联关系从数据库中删除令牌，以达到「撤销」令牌的目的：\r\n\r\n    // 撤销所有令牌...\r\n    $user->tokens()->delete();\r\n\r\n    // 撤销用于验证当前请求的令牌...\r\n    $request->user()->currentAccessToken()->delete();\r\n\r\n    // 撤销指定令牌...\r\n    $user->tokens()->where('id', $tokenId)->delete();\r\n\r\n<a name=\"spa-authentication\"></a>\r\n## SPA 认证\r\n\r\nSanctum 还提供了一种简单的方法来验证需要与 Laravel 支持的 API 通信的单页应用程序 （SPA）。 这些 SPA 可能与 Laravel 应用程序存在于同一个存储库中，也可能是一个完全独立的存储库。\r\n\r\n对于此功能，Sanctum 不使用任何类型的令牌。 相反，Sanctum 使用 Laravel 内置的基于 cookie 的 session 身份验证服务。 这种身份验证方法提供了 CSRF 保护、session 身份验证以及防止身份验证凭据通过 XSS 泄漏的好处。\r\n\r\n> 注意：为了进行身份验证，你的 SPA 和 API 必须共享同一个顶级域。但是，它们可能被放置在不同的子域中。此外，你应确保随请求发送 `Accept: application/json` 请求头。\r\n\r\n<a name=\"spa-configuration\"></a>\r\n### 配置 \r\n\r\n<a name=\"configuring-your-first-party-domains\"></a>\r\n#### 配置你的第一个域\r\n\r\n首先，你应该配置你的 SPA 将从哪些域发出请求。 你可以使用 `sanctum` 配置文件中的 `stateful` 选项来配置这些域。 此配置设置确定哪些域将在向你的 API 发出请求时使用 Laravel session cookie 维护「有状态的」身份验证。\r\n\r\n> 注意：如果你通过包含端口 （`127.0.0.1:8000`）的 URL 访问应用程序，则应确保在域中包含端口号。\r\n\r\n\n\n<a name=\"sanctum-middleware\"></a>\r\n#### Sanctum 中间件\r\n\r\n接下来，你应该将 Sanctum 的中间件添加到你的 `app/Http/Kernel.php` 文件中的 `api` 中间件组中。 这个中间件负责确保来自 SPA 的传入请求可以使用 Laravel 的会话 cookie 进行身份验证，同时仍然允许来自第三方或移动应用程序的请求使用 API 令牌进行身份验证：\r\n\r\n    'api' => [\r\n        \\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class,\r\n        'throttle:api',\r\n        \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n    ],\r\n\r\n<a name=\"cors-and-cookies\"></a>\r\n#### CORS & Cookies\r\n\r\n如果你无法从在单独子域上执行的 SPA 对你的应用程序进行身份验证，则你可能错误配置了 CORS（跨源资源共享）或会话 cookie 设置。\r\n\r\n你应该确保应用程序的 CORS 配置返回的 `Access-Control-Allow-Credentials` 请求头的值为 `true`。 这可以通过将应用程序的 `config/cors.php` 配置文件中的 `supports_credentials` 选项设置为 `true` 来实现。\r\n\r\n此外，你应该在应用程序的全局 `axios` 实例上启用 `withCredentials` 选项。 通常，这应该在你的 `resources/js/bootstrap.js` 文件中执行。 如果你没有使用 Axios 从你的前端发出 HTTP 请求，你应该在你自己的 HTTP 客户端上执行等效的配置：\r\n\r\n```js\r\naxios.defaults.withCredentials = true;\r\n```\r\n\r\n最后，你应该确保应用程序的会话 cookie 域配置支持根域的任何子域。 你可以通过在应用程序的 `config/session.php` 配置文件中使用前导 `.` 作为域的前缀来实现此目的：\r\n\r\n    'domain' => '.domain.com',\r\n\r\n<a name=\"spa-authenticating\"></a>\r\n### 验证\r\n\r\n<a name=\"csrf-protection\"></a>\r\n#### CSRF 保护\r\n\r\n\n\n要验证你的 SPA，你的 SPA 的 「登录」页面应首先向 `/sanctum/csrf-cookie` 发出请求以初始化应用程序的 CSRF 保护：\r\n\r\n```js\r\naxios.get('/sanctum/csrf-cookie').then(response => {\r\n        // 登录...\r\n});\r\n```\r\n\r\n在此请求期间，Laravel 将设置一个包含当前 CSRF 令牌的 `XSRF-TOKEN` cookie。然后，此令牌应在后续请求的 `X-XSRF-TOKEN` 请求头中传递，某些 HTTP 客户端库（如 Axios 和 Angular HttpClient）将自动为你执行此操作。如果你的 JavaScript HTTP 库没有为你设置该值，你将需要手动设置 `X-XSRF-TOKEN` 请求头以匹配此路由设置的 `XSRF-TOKEN` cookie 的值。\r\n\r\n<a name=\"logging-in\"></a>\r\n#### 登录\r\n\r\n一旦 CSRF 保护被初始化，你应该向 Laravel 应用程序的 `/login` 路由发出 `POST` 请求。这个 `/login` 路由可以 [手动实现](/docs/laravel/9.x/authentication#authenticating-users) 或使用无请求头身份验证包，如 [Laravel Fortify](/docs/laravel/9.x/fortify)。\r\n\r\n如果登录请求成功，你将通过身份验证，随后对你的应用程序路由的请求将通过 Laravel 应用程序发布给你的客户端的会话 cookie 自动进行身份验证。此外，由于你的应用程序已经向 `/sanctum/csrf-cookie` 路由发出请求，只要你的 JavaScript HTTP 客户端发送 `XSRF-TOKEN` cookie 的值，后续请求应该会自动接受 CSRF 保护 `X-XSRF-TOKEN` 请求头。\r\n\r\n当然，如果你的用户 session 由于缺乏活动而过期，后续对 Laravel 应用程序的请求可能会收到 401 或 419 HTTP 错误响应。在这种情况下，你应该将用户重定向到 SPA 的登录页面。\r\n\r\n> 注意：你可以自由编写自己的 `/login` 端点；但是，你应该确保它使用标准的 [Laravel 提供的基于 session 的身份验证服务](/docs/laravel/8.x/authentication#authenticating-users) 对用户进行身份验证。通常，这意味着使用 「web」身份验证看守器。\r\n\r\n\n\n<a name=\"protecting-spa-routes\"></a>\r\n### 路由保护\r\n\r\n为了保护路由，以便所有传入的请求都必须经过身份验证，你应该将 `sanctum` 身份验证看守器附加到 `routes/api.php` 文件中的 API 路由。此看守器将确保传入请求被验证为来自你的 SPA 的有状态的已验证请求，或者如果请求来自第三方，则包含有效的 API 令牌请求头：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::middleware('auth:sanctum')->get('/user', function (Request $request) {\r\n        return $request->user();\r\n    });\r\n\r\n<a name=\"authorizing-private-broadcast-channels\"></a>\r\n### 授权私有广播频道\r\n\r\n如果你的单页面应用需要通过 [私有 / presence 广播频道](/docs/laravel/9.x/broadcasting#authorizing-channels) 进行身份认证，你需要在你的 `routes/api.php` 文件中调用 `Broadcast::routes` 方法：\r\n\r\n    Broadcast::routes(['middleware' => ['auth:sanctum']]);\r\n\r\n接下来，为了让 Pusher 的授权请求成功，你需要在初始化 [Laravel Echo](/docs/laravel/9.x/broadcasting#installing-laravel-echo) 时提供一个自定义的 Pusher `authorizer`。这允许你的应用程序配置 Pusher 以使用 [为跨域请求正确配置](#cors-and-cookies) 的 `axios` 实例：\r\n\r\n```js\r\nwindow.Echo = new Echo({\r\n    broadcaster: \"pusher\",\r\n    cluster: process.env.MIX_PUSHER_APP_CLUSTER,\r\n    encrypted: true,\r\n    key: process.env.MIX_PUSHER_APP_KEY,\r\n    authorizer: (channel, options) => {\r\n        return {\r\n            authorize: (socketId, callback) => {\r\n                axios.post('/api/broadcasting/auth', {\r\n                    socket_id: socketId,\r\n                    channel_name: channel.name\r\n                })\r\n                .then(response => {\r\n                    callback(false, response.data);\r\n                })\r\n                .catch(error => {\r\n                    callback(true, error);\r\n                });\r\n            }\r\n        };\r\n    },\r\n})\r\n```\r\n\r\n<a name=\"mobile-application-authentication\"></a>\r\n## 移动应用身份验证\r\n\r\n你可以使用 Sanctum 令牌来验证你的移动应用程序对 API 的请求。验证移动应用请求的过程类似于验证第三方 API 请求；但是，在发布 API 令牌的方式上存在细微差别。\r\n\r\n\n\n<a name=\"issuing-mobile-api-tokens\"></a>\r\n### 发行 API 令牌\r\n\r\n首先，创建一个接受用户电子邮件/用户名、密码和设备名称的路由，然后将这些凭据交换为新的 Sanctum 令牌。赋予此端点的「设备名称」仅供参考，可以是你希望的任何值。通常，设备名称值应该是用户可以识别的名称，例如「Nuno's iPhone 12」。\r\n\r\n通常，你将从移动应用程序的「登录」屏幕向令牌端点发出请求。端点将返回纯文本 API 令牌，然后可以将其存储在移动设备上并用于发出其他 API 请求：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Illuminate\\Validation\\ValidationException;\r\n\r\n    Route::post('/sanctum/token', function (Request $request) {\r\n        $request->validate([\r\n            'email' => 'required|email',\r\n            'password' => 'required',\r\n            'device_name' => 'required',\r\n        ]);\r\n\r\n        $user = User::where('email', $request->email)->first();\r\n\r\n        if (! $user || ! Hash::check($request->password, $user->password)) {\r\n            throw ValidationException::withMessages([\r\n                'email' => ['The provided credentials are incorrect.'],\r\n            ]);\r\n        }\r\n\r\n        return $user->createToken($request->device_name)->plainTextToken;\r\n    });\r\n\r\n当移动设备使用令牌向你的应用程序发出 API 请求时，它应将令牌作为 `Bearer` 令牌传递到 `Authorization` 请求头中。\r\n\r\n> 技巧：在为移动应用程序发行令牌时，你还可以自由指定 [token abilities](#token-abilities)。\r\n\r\n<a name=\"protecting-mobile-api-routes\"></a>\r\n### 路由保护\r\n\r\n如前所述，你需要保护路由，因此必须通过在路由上附加 `Sanctum` 身份验证看守器来对所有传入请求进行身份验证。\r\n\r\n    Route::middleware('auth:sanctum')->get('/user', function (Request $request) {\r\n        return $request->user();\r\n    });\r\n\r\n\n\n<a name=\"revoking-mobile-api-tokens\"></a>\r\n### 撤销令牌\r\n\r\n为了允许用户撤销发给移动设备的 API 令牌，你可以在 Web 应用程序 UI 的「帐户设置」部分中按名称列出它们，并附带 「撤销」按钮。 当用户点击「撤销」按钮时，你可以从数据库中删除令牌。 请记住，你可以通过 `Laravel\\Sanctum\\HasApiTokens` trait 提供的 `tokens` 关系访问用户的 API 令牌：\r\n\r\n    // 撤销所有令牌...\r\n    $user->tokens()->delete();\r\n\r\n    // 撤销特定令牌...\r\n    $user->tokens()->where('id', $tokenId)->delete();\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n在测试时，`Sanctum::actingAs` 方法可用于验证用户并指定为其令牌授予哪些能力：\r\n\r\n    use App\\Models\\User;\r\n    use Laravel\\Sanctum\\Sanctum;\r\n\r\n    public function test_task_list_can_be_retrieved()\r\n    {\r\n        Sanctum::actingAs(\r\n            User::factory()->create(),\r\n            ['view-tasks']\r\n        );\r\n\r\n        $response = $this->get('/api/task');\r\n\r\n        $response->assertOk();\r\n    }\r\n\r\n如果你想授予令牌所有的能力，你应该在提供给 `actingAs` 方法的能力列表中包含 `*`：\r\n\r\n    Sanctum::actingAs(\r\n        User::factory()->create(),\r\n        ['*']\r\n    );\r\n\n","p":"docs/sanctum.html"},{"t":"scout (Laravel Scout)","d":"# Laravel Scout\r\n\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n    - [驱动必要条件](#driver-prerequisites)\r\n    - [队列](#queueing)\r\n- [配置](#configuration)\r\n    - [配置模型索引](#configuring-model-indexes)\r\n    - [配置可搜索数据](#configuring-searchable-data)\r\n    - [配置模型ID](#configuring-the-model-id)\r\n    - [识别用户](#identifying-users)\r\n- [数据库/收集引擎](#database-and-collection-engines)\r\n    - [数据库引擎](#database-engine)\r\n    - [Collection 引擎](#collection-engine)\r\n- [索引](#indexing)\r\n    - [批量导入](#batch-import)\r\n    - [添加记录](#adding-records)\r\n    - [修改记录](#updating-records)\r\n    - [删除记录](#removing-records)\r\n    - [暂停索引](#pausing-indexing)\r\n    - [有条件可搜索的模型实例](#conditionally-searchable-model-instances)\r\n- [搜索](#searching)\r\n    - [Where 语句](#where-clauses)\r\n    - [分页](#pagination)\r\n    - [软删除](#soft-deleting)\r\n    - [自定义引擎搜索](#customizing-engine-searches)\r\n- [自定义引擎](#custom-engines)\r\n- [生成器宏](#builder-macros)\r\n- [Custom Engines](#custom-engines)\r\n- [Builder Macros](#builder-macros)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n\r\n[Laravel Scout](https://github.com/laravel/scout) 为 [Eloquent 模型](/docs/laravel/9.x/eloquent) 的全文搜索提供了一个简单的基于驱动程序的解决方案，通过使用模型观察者，Scout将自动同步 Eloquent 记录的搜索索引。\r\n\r\n目前，Scout 附带 [Algolia](https://www.algolia.com/)、[MeiliSearch](https://www.meilisearch.com) 和 MySQL / PostgreSQL (`database`) 驱动程序。此外，Scout 包括一个「collection」驱动程序，该驱动程序专为本地开发使用而设计，不需要任何外部依赖项或第三方服务。此外，编写自定义驱动程序很简单，你可以使用自己的搜索实现自由扩展 Scout。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，通过 Composer 软件包管理器安装 Scout：\r\n\r\n```shell\r\ncomposer require laravel/scout\r\n```\r\n\r\nScout 安装完成后，使用Artisan 命令 `vendor:publish` 生成 Scout 配置文件。此命令将会在你的 `config` 目录下 生成一个 `scout.php` 配置文件:\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Scout\\ScoutServiceProvider\"\r\n```\r\n\r\n\r\n\r\n最后，在你要做搜索的模型中添加 `Laravel\\Scout\\Searchable` trait 。这个 trait 会注册一个模型观察者来保持模型和搜索驱动的同步:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class Post extends Model\r\n    {\r\n        use Searchable;\r\n    }\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动的先决条件\r\n\r\n<a name=\"algolia\"></a>\r\n#### Algolia\r\n\r\n使用 Algolia 驱动时，需要在 `config/scout.php` 配置文件配置你的 Algolia `id` 和 `secret` 凭证。配置好凭证之后，还需要使用 Composer 安装 Algolia PHP SDK：\r\n\r\n```shell\r\ncomposer require algolia/algoliasearch-client-php\r\n```\r\n\r\n<a name=\"meilisearch\"></a>\r\n#### MeiliSearch\r\n\r\n[MeiliSearch](https://www.meilisearch.com) 是一个速度极快的开源搜索引擎。如果你不确定如何在本地机器上安装 MeiliSearch，你可以使用 Laravel 官方支持的 Docker 开发环境 [Laravel Sail](/docs/laravel/9.x/sail#meilisearch)。\r\n\r\n使用 MeiliSearch 驱动程序时，你需要通过 Composer 包管理器安装 MeiliSearch PHP SDK：\r\n\r\n```shell\r\ncomposer require meilisearch/meilisearch-php http-interop/http-factory-guzzle\r\n```\r\n\r\n然后，在应用程序的 .env 文件中设置 `SCOUT_DRIVER` 环境变量以及你的 MeiliSearch `host` 和 `key` 凭据：\r\n\r\n```ini\r\nSCOUT_DRIVER=meilisearch\r\nMEILISEARCH_HOST=http://127.0.0.1:7700\r\nMEILISEARCH_KEY=masterKey\r\n```\r\n\r\n更多关于 MeiliSearch 的信息，请参考 [MeiliSearch 技术文档](https://docs.meilisearch.com/learn/getting_started/quick_start.html)。\r\n\r\n此外，你应该通过查看 [MeiliSearch 关于二进制兼容性的文档](https://github.com/meilisearch/meilisearch-php#-compatibility-with-meilisearch) 确保安装与你的 MeiliSearch 二进制版本兼容的 `meilisearch/meilisearch-php` 版本。\r\n\r\n> 注意：在使用 MeiliSearch 的应用程序上升级 Scout 时，您应该始终留意查看关于 MeiliSearch 升级发布的 [其他重大（破坏性）更改](https://github.com/meilisearch/MeiliSearch/releases)，以保证升级顺利。\r\n\r\n\r\n<a name=\"queueing\"></a>\r\n### 队列\r\n\r\n虽然不是严格要求使用队列，但在使用库之前，你应该强烈考虑配置 [队列驱动](/docs/laravel/9.x/queues)。 运行队列 worker 将允许 Scout 将所有将你的模型信息同步到你的搜索索引的操作进行排队，从而为你的应用的 Web 界面提供更好的响应时间。\r\n\r\n配置好队列驱动后，将 `config/scout.php` 配置文件中的 `queue` 选项的值设置为 `true`：\r\n\r\n    'queue' => true,\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"configuring-model-indexes\"></a>\r\n### 配置模型索引\r\n\r\n\r\n每个 Eloquent 模型都与给定的搜索 「索引」同步，该索引包含该模型的所有可搜索记录。 换句话说，你可以将每个索引视为一个 MySQL 表。 默认情况下，每个模型都将持久化到与模型的典型 「表」名称匹配的索引。 通常，是模型名称的复数形式； 但你可以通过重写模型上的 `searchableAs` 方法来自由地自定义模型的索引：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class Post extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取与模型关联的索引的名称。\r\n         *\r\n         * @return string\r\n         */\r\n        public function searchableAs()\r\n        {\r\n            return 'posts_index';\r\n        }\r\n    }\r\n\r\n<a name=\"configuring-searchable-data\"></a>\r\n### 配置可搜索数据\r\n\r\n默认情况下，模型以完整的 `toArray` 格式持久化到搜索索引。如果要自定义同步到搜索索引的数据，可以覆盖模型上的 `toSearchableArray` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class Post extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取模型的可索引的数据。\r\n         *\r\n         * @return array\r\n         */\r\n        public function toSearchableArray()\r\n        {\r\n            $array = $this->toArray();\r\n\r\n            // 自定义数据数组...\r\n\r\n            return $array;\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"configuring-the-model-id\"></a>\r\n### 配置模型 ID\r\n\r\n默认情况下，Scout 将使用模型的主键作为搜索索引中存储的唯一 ID / key。 可以通过模型上的 `getScoutKey` 和 `getScoutKeyName` 方法自定义：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class User extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取用于索引模型的值\r\n         *\r\n         * @return mixed\r\n         */\r\n        public function getScoutKey()\r\n        {\r\n            return $this->email;\r\n        }\r\n\r\n        /**\r\n         * 获取用于索引模型的键名\r\n         *\r\n         * @return mixed\r\n         */\r\n        public function getScoutKeyName()\r\n        {\r\n            return 'email';\r\n        }\r\n    }\r\n\r\n<a name=\"identifying-users\"></a>\r\n### 识别用户\r\n\r\n\r\nScout 还允许您在使用 [Algolia](https://algolia.com) 时自动识别用户。在 Algolia 的仪表板中查看搜索分析时，将经过身份验证的用户与搜索操作相关联可能会有所帮助。您可以通过在应用程序的 `.env` 文件中将 `SCOUT_IDENTIFY` 环境变量定义为 `true` 来启用用户标识：\r\n\r\n```ini\r\nSCOUT_IDENTIFY=true\r\n```\r\n\r\n启用此功能还会将请求的 IP 地址和经过身份验证的用户的主标识符传递给 Algolia，以便将此数据与用户发出的任何搜索请求相关联。\r\n\r\n<a name=\"database-and-collection-engines\"></a>\r\n## 数据库 / Collection 引擎\r\n\r\n<a name=\"database-engine\"></a>\r\n### 数据库引擎\r\n\r\n> 注意：数据库引擎目前支持 MySQL 和 PostgreSQL。\r\n\r\n如果你的应用程序使用中小型数据库交互，且数据库本身负载较低，你可能会发现使用 Scout 的「数据库引擎」会更方便。数据库引擎将在过滤现有数据库的结果时使用「where like」子句和全文索引，以确定查询的适用搜索结果。\r\n\r\n\r\n要使用数据库引擎，你可以简单地将 `SCOUT_DRIVER` 环境变量的值设置为 `database`，或者直接在应用程序的 `scout` 配置文件中指定 `database` 驱动程序：\r\n\r\n```ini\r\nSCOUT_DRIVER=database\r\n```\r\n\r\n一旦你将数据库引擎指定为首选驱动程序后，你必须 [配置你的可搜索数据](#configuring-searchable-data)。然后，你可以针对你的模型开始 [执行搜索查询](#searching)。使用数据库引擎时不需要搜索引擎索引，例如填充 Algolia 或 MeiliSearch 索引所需的索引。\r\n\r\n#### 自定义数据库搜索策略\r\n\r\n默认情况下，数据库引擎将对你已[配置为可搜索](#configuring-searchable-data) 的每个模型属性执行「where like」查询。但是，在某些情况下，这可能会导致性能不佳。因此，你可以通过配置数据库引擎的搜索策略，使某些指定的列使用全文搜索查询或仅使「where like」约束来搜索字符串的前缀（`example%`），而不是在整个字符串中搜索（`%example%`)。\r\n\r\n要定义此行为，你可以将 PHP 属性分配给模型的 `toSearchableArray` 方法。任何未分配额外搜索策略行为的列将继续使用默认的「where like」策略：\r\n\r\n```php\r\nuse Laravel\\Scout\\Attributes\\SearchUsingFullText;\r\nuse Laravel\\Scout\\Attributes\\SearchUsingPrefix;\r\n\r\n/**\r\n * 获取模型的可索引数据数组。\r\n *\r\n * @return array\r\n */\r\n#[SearchUsingPrefix(['id', 'email'])]\r\n#[SearchUsingFullText(['bio'])]\r\npublic function toSearchableArray()\r\n{\r\n    return [\r\n        'id' => $this->id,\r\n        'name' => $this->name,\r\n        'email' => $this->email,\r\n        'bio' => $this->bio,\r\n    ];\r\n}\r\n```\r\n\r\n> 注意：在指定列应使用全文查询约束之前，请确保已为该列分配了 [全文索引](/docs/laravel/9.x/migrations#available-index-types)。\r\n\r\n<a name=\"collection-engine\"></a>\r\n### Collection 引擎\r\n\r\n虽然你在本地开发过程中可以自由使用 Algolia 或 MeiliSearch 搜索引擎，但你可能会发现使用「Collection」引擎更方便。Collection 引擎将对现有数据库的结果使用「where」子句和收集过滤来确定适用于你的查询的搜索结果。使用此引擎时，无需为您的可搜索模型「索引」，因为它们只会从您的本地数据库中检索。\r\n\r\n要使用收集引擎，你可以简单地将 `SCOUT_DRIVER` 环境变量的值设置为 `collection`，或者直接在应用程序的 `scout` 配置文件中指定 `collection` 驱动程序：\r\n\r\n```ini\r\nSCOUT_DRIVER=collection\r\n```\r\n\r\n一旦你将 Collection  驱动指定为首选驱动程序，你就可以开始对你的模型[执行搜索查询](#searching)。使用 Collection 引擎时，不需要搜索引擎索引，例如填充 Algolia 或 MeiliSearch 索引所需的索引。\r\n\r\n#### 与数据库引擎的区别\r\n\r\n乍一看，「数据库」和「Collection 」引擎非常相似。它们都直接与你的数据库交互以检索搜索结果。但是，Collection 引擎不使用全文索引或「LIKE」子句来查找匹配记录。相反，它会提取所有可能的记录并使用 Laravel 的 `Str::is` 帮助器来确定搜索字符串是否存在于模型属性值中。\r\n\r\nCollection 引擎是最便携的搜索引擎，因为它适用于 Laravel 支持的所有关系数据库（包括 SQLite 和 SQL Server）；但是，它的效率低于 Scout 的数据库引擎。\r\n\r\n\r\n<a name=\"indexing\"></a>\r\n## 索引\r\n\r\n<a name=\"batch-import\"></a>\r\n### 批量导入\r\n\r\n如果要将 Scout 安装到现有项目中，则可能已有需要导入索引的数据库记录。Scout 提供 Artisan 命令 `scout:import`，可用于将所有现有记录导入搜索索引：\r\n\r\n```shell\r\nphp artisan scout:import \"App\\Models\\Post\"\r\n```\r\n\r\n `flush` 命令可用于从搜索索引中删除模型的所有记录：\r\n\r\n```shell\r\nphp artisan scout:flush \"App\\Models\\Post\"\r\n```\r\n\r\n<a name=\"modifying-the-import-query\"></a>\r\n#### 修改导入查询\r\n\r\n如果要修改用于检索所有模型以进行批量导入的查询，可以在模型上定义 `makeAllSearchableUsing` 方法。这是一个很好的地方，可以在导入模型之前添加任何可能需要的即时关系加载：\r\n\r\n    /**\r\n     * 在使所有模型都可搜索时，修改用于检索模型的查询。\r\n     *\r\n     * @param  \\Illuminate\\Database\\Eloquent\\Builder  $query\r\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n     */\r\n    protected function makeAllSearchableUsing($query)\r\n    {\r\n        return $query->with('author');\r\n    }\r\n\r\n<a name=\"adding-records\"></a>\r\n### 添加记录\r\n\r\n一旦将 `Laravel\\Scout\\Searchable` trait 添加到模型中，你只需 `save` 或 `create` 模型实例，它就会自动添加到搜索索引中。如果已将 Scout 配置为 [使用队列](#queueing)，此操作将由队列 worker 进程在后台执行：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $order = new Order;\r\n\r\n    // ...\r\n\r\n    $order->save();\r\n\r\n<a name=\"adding-records-via-query\"></a>\r\n\r\n\r\n#### 通过查询添加\r\n\r\n如果你希望通过 Eloquent 查询将模型集合添加到搜索索引中，你也可以在 Eloquent 查询构造器上链式调用 `searchable` 方法。`searchable` 会把构造器的查询 [结果分块](/docs/laravel/9.x/eloquent#chunking-results) 并将记录添加到搜索索引中。同样，如果你已将 Scout 配置为使用队列，则队列 worker 将在后台导入所有块：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    Order::where('price', '>', 100)->searchable();\r\n\r\n你还可以在 Eloquent 关联实例上调用 `searchable` 方法：\r\n\r\n    $user->orders()->searchable();\r\n\r\n或者，如果内存中已经有一组 Eloquent 模型，可以调用集合实例上的 `searchable` 方法，将模型实例添加到相应的索引中：\r\n\r\n    $orders->searchable();\r\n\r\n> 技巧：`searchable` 方法可被视为 「upsert」操作。换句话说，如果模型记录已经在索引中，它将被更新。如果它不存在于搜索索引中，则将其添加到索引中。\r\n\r\n<a name=\"updating-records\"></a>\r\n### 更新记录\r\n\r\n要更新可搜索的模型，只需要更新模型实例的属性并将模型 `save` 到数据库。Scout 会自动将更新同步到你的搜索索引中：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $order = Order::find(1);\r\n\r\n    // 更新订单...\r\n\r\n    $order->save();\r\n\r\n你也可以在 Eloquent 查询语句上使用 `searchable` 方法来更新一个模型的集合。如果这个模型不存在你检索的索引里，就会被创建：\r\n\r\n    Order::where('price', '>', 100)->searchable();\r\n\r\n\r\n\r\n如果要更新关系中所有模型的搜索索引记录，可以在关系实例上调用 `searchable` ：\r\n\r\n    $user->orders()->searchable();\r\n\r\n或者，如果内存中已经有 Eloquent 模型集合，则可以调用集合实例上的 `searchable` 方法来更新相应索引中的模型实例：\r\n\r\n    $orders->searchable();\r\n\r\n<a name=\"removing-records\"></a>\r\n### 移除记录\r\n\r\n要从索引中删除记录，只需从数据库中 `delete` 模型即可。即使你正在使用 [软删除](/docs/laravel/9.x/eloquent#soft-deleting) 模型，也可以这样做：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $order = Order::find(1);\r\n\r\n    $order->delete();\r\n\r\n如果你不希望记录在删除之前被检索到，可以在 Eloquent 查询实例或集合上使用 `unsearchable` 方法：\r\n\r\n    Order::where('price', '>', 100)->unsearchable();\r\n\r\n如果要删除关系中所有模型的搜索索引记录，可以在关系实例上调用 `unsearchable` ：\r\n\r\n    $user->orders()->unsearchable();\r\n\r\n或者，如果内存中已经有 Eloquent 模型集合，则可以调用集合实例上的 `unsearchable` 方法，从相应的索引中删除模型实例：\r\n\r\n    $orders->unsearchable();\r\n\r\n<a name=\"pausing-indexing\"></a>\r\n### 暂停索引\r\n\r\n你可能需要在执行一批 Eloquent 操作的时候，不同步模型数据到搜索索引。此时你可以使用 `withoutSyncingToSearch` 方法来执行此操作。这个方法接受一个立即执行的回调。该回调中所有的操作都不会同步到模型的索引：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    Order::withoutSyncingToSearch(function () {\r\n        // 执行模型操作...\r\n    });\r\n\r\n\r\n\r\n<a name=\"conditionally-searchable-model-instances\"></a>\r\n### 有条件的搜索模型实例\r\n\r\n有时你可能只需要在某些条件下使模型可搜索。例如，假设你有 `App\\Models\\Post` 模型可能是两种状态之一：「草稿」和「已发布」。你可能只允许搜索 「已发布」的帖子。为了实现这一点，你需要在模型中定义一个 `shouldBeSearchable` 方法：\r\n\r\n    /**\r\n     * 确定模型是否可搜索\r\n     *\r\n     * @return bool\r\n     */\r\n    public function shouldBeSearchable()\r\n    {\r\n        return $this->isPublished();\r\n    }\r\n\r\n仅当通过 `save` 和 `create` 方法、查询或关联模型操作时，才应使用 `shouldBeSearchable` 方法。直接使用 `searchable` 方法将使模型或集合的可搜索结果覆盖 `shouldBeSearchable` 方法的结果:\r\n\r\n> 注意：`shouldBeSearchable` 方法在使用 Scout 的“数据库”引擎时不适用，因为所有可搜索的数据始终存储在数据库中。要在使用数据库引擎时实现类似的行为，你应该改用 [where 子句](#where-clauses)。\r\n\r\n<a name=\"searching\"></a>\r\n## 搜索\r\n\r\n你可以使用 `search` 方法来搜索模型。search 方法接受一个用于搜索模型的字符串。你还需要在搜索查询上链式调用 `get` 方法，才能用给定的搜索语句查询与之匹配的 Eloquent 模型：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $orders = Order::search('Star Trek')->get();\r\n\r\n由于 Scout 搜索返回 Eloquent 模型的集合，你甚至可以直接从路由或控制器返回结果，结果将自动转换为 JSON ：\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/search', function (Request $request) {\r\n        return Order::search($request->search)->get();\r\n    });\r\n\r\n\r\n\r\n如果你想在它们转换成 Eloquent 模型前得到原始结果，你应该使用 `raw` 方法：\r\n\r\n    $orders = Order::search('Star Trek')->raw();\r\n\r\n<a name=\"custom-indexes\"></a>\r\n#### 自定义索引\r\n\r\n搜索查询通常会在模型的 [`searchableAs`](#configuring-model-indexes) 方法指定的索引上执行。但是，你可以使用 `within` 方法指定应搜索的自定义索引：\r\n\r\n    $orders = Order::search('Star Trek')\r\n        ->within('tv_shows_popularity_desc')\r\n        ->get();\r\n\r\n<a name=\"where-clauses\"></a>\r\n### Where 子句\r\n\r\nScout 允许你在搜索查询中添加简单的「where」子句。目前，这些子句仅支持基本的数值相等性检查，主要用于按所有者 ID 确定搜索查询的范围。\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $orders = Order::search('Star Trek')->where('user_id', 1)->get();\r\n\r\n你可以使用 `whereIn` 方法将结果限制在给定的一组值上：\r\n\r\n    $orders = Order::search('Star Trek')->whereIn(\r\n        'status', ['paid', 'open']\r\n    )->get();\r\n\r\n由于搜索索引不是关系数据库，因此目前不支持更高级的「where」子句。\r\n\r\n<a name=\"pagination\"></a>\r\n### 分页\r\n\r\n除了检索模型的集合，你也可以使用 `paginate` 方法对搜索结果进行分页。这个方法会返回一个就像 [传统的 Eloquent 查询分页 ](/docs/laravel/9.x/pagination) 一样的 `Illuminate\\Pagination\\LengthAwarePaginator` 实例：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $orders = Order::search('Star Trek')->paginate();\r\n\r\n通过将数量作为第一个参数传递给 `paginate` 方法，可以指定每页要检索多少个模型：\r\n\r\n    $orders = Order::search('Star Trek')->paginate(15);\r\n\r\n\r\n\r\n检索结果后，你可以使用 [Blade](/docs/laravel/9.x/blade) 显示结果并呈现页面链接，就像对传统的 Eloquent 查询进行分页一样：\r\n\r\n```html\r\n<div class=\"container\">\r\n    @foreach ($orders as $order)\r\n        {{ $order->price }}\r\n    @endforeach\r\n</div>\r\n\r\n{{ $orders->links() }}\r\n```\r\n\r\n当然，如果希望以 JSON 形式检索分页结果，可以直接从路由或控制器返回分页器实例：\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/orders', function (Request $request) {\r\n        return Order::search($request->input('query'))->paginate(15);\r\n    });\r\n\r\n<a name=\"soft-deleting\"></a>\r\n### 软删除\r\n\r\n如果你索引的模型是 [软删除](/docs/laravel/9.x/eloquent#soft-deleting)，并且你需要搜索已删除的模型，请将 `config/scout.php` 配置文件中的 `soft_delete` 选项设置为  `true`：\r\n\r\n    'soft_delete' => true,\r\n\r\n当此配置选项为 `true` 时，Scout 不会从搜索索引中删除软删除的模型。相反，它将在索引记录上设置一个隐藏的`__soft_deleted` 属性。然后，你可以在搜索时使用 `withTrashed` 或 `onlyTrashed` 方法检索软删除记录：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    // 检索结果包括已删除记录\r\n    $orders = Order::search('Star Trek')->withTrashed()->get();\r\n\r\n    // 仅检索已删除记录...\r\n    $orders = Order::search('Star Trek')->onlyTrashed()->get();\r\n\r\n> 技巧：当使用 `forceDelete` 永久删除软删除模型时，Scout 会自动将其从搜索索引中删除。\r\n\r\n<a name=\"customizing-engine-searches\"></a>\r\n### 自定义搜索引擎\r\n\r\n\r\n如果需要对引擎的搜索行为执行高级自定义，可以将闭包作为第二个参数传递给 `search`  方法。例如，在将搜索查询传递给 Algolia 之前，可以使用此回调将地理位置数据添加到搜索选项中：\r\n\r\n    use Algolia\\AlgoliaSearch\\SearchIndex;\r\n    use App\\Models\\Order;\r\n\r\n    Order::search(\r\n        'Star Trek',\r\n        function (SearchIndex $algolia, string $query, array $options) {\r\n            $options['body']['query']['bool']['filter']['geo_distance'] = [\r\n                'distance' => '1000km',\r\n                'location' => ['lat' => 36, 'lon' => 111],\r\n            ];\r\n\r\n            return $algolia->search($query, $options);\r\n        }\r\n    )->get();\r\n\r\n\r\n\r\n<a name=\"custom-engines\"></a>\r\n## 自定义引擎\r\n\r\n<a name=\"writing-the-engine\"></a>\r\n#### 编写引擎\r\n\r\n如果内置的 Scout 搜索引擎不能满足你的需求，你可以编写自定义的引擎并且将它注册到 Scout。 你的引擎需要继承 `Laravel\\Scout\\Engines\\Engine` 抽象类，这个抽象类包含了你自定义的引擎必须要实现的八个方法：\r\n\r\n    use Laravel\\Scout\\Builder;\r\n\r\n    abstract public function update($models);\r\n    abstract public function delete($models);\r\n    abstract public function search(Builder $builder);\r\n    abstract public function paginate(Builder $builder, $perPage, $page);\r\n    abstract public function mapIds($results);\r\n    abstract public function map(Builder $builder, $results, $model);\r\n    abstract public function getTotalCount($results);\r\n    abstract public function flush($model);\r\n\r\n在 `Laravel\\Scout\\Engines\\AlgoliaEngine` 类里查看这些方法的实现会对你有较大的帮助。这个类会为你在学习如何在自定义引擎中实现这些方法提供一个好的起点。\r\n\r\n<a name=\"registering-the-engine\"></a>\r\n#### 注册引擎\r\n\r\n\r\n一旦你写好了自定义引擎，你可以用 Scout 引擎管理的 `extend` 方法将它注册到 Scout。你只需要从`App\\Providers\\AppServiceProvider`  下的 `boot` 方法或者应用中使用的任何一个服务提供器中调用 `extend` 方法。\r\n\r\n举个例子，如果你写好了一个 `MySqlSearchEngine`，你可以像这样去注册它：\r\n\r\n    use App\\ScoutExtensions\\MySqlSearchEngine\r\n    use Laravel\\Scout\\EngineManager;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        resolve(EngineManager::class)->extend('mysql', function () {\r\n            return new MySqlSearchEngine;\r\n        });\r\n    }\r\n\r\n引擎注册后，你可以在 `config/scout.php` ,配置文件中指定它为默认的 Scout  `driver` :\r\n\r\n    'driver' => 'mysql',\r\n\r\n\r\n\r\n<a name=\"builder-macros\"></a>\r\n## 生成宏命令\r\n\r\n如果你想要自定义生成器方法，你可以使用`Laravel\\Scout\\Builder` 类下的\"macro\" 方法。 通常，定义「macros」时，需要实现 [service provider's](/docs/laravel/9.x/providers) `boot` 方法:\r\n\r\n    use Illuminate\\Support\\Facades\\Response;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Laravel\\Scout\\Builder;\r\n\r\n    /**\r\n     * 注册应用的 Scout 宏命令\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Builder::macro('count', function () {\r\n            return $this->engine()->getTotalCount(\r\n                $this->engine()->search($this)\r\n            );\r\n        });\r\n    }\r\n\r\n`macro` 函数接受一个名字作为第一个参数，第二个参数为一个闭包函数。当调用  `Laravel\\Scout\\Builder` 宏命令时，调用这个函数.\r\n\r\n    use App\\Models\\Order;\r\n\r\n    Order::search('Star Trek')->count();\r\n\r\n","p":"docs/scout.html"},{"t":"socialite (Laravel Socialite)","d":"# Laravel Socialite\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n- [升级](#upgrading-socialite)\r\n- [配置](#configuration)\r\n- [认证](#authentication)\r\n    - [路由](#routing)\r\n    - [身份验证和存储](#authentication-and-storage)\r\n    - [访问范围](#access-scopes)\r\n    - [可选参数](#optional-parameters)\r\n- [检索用户详细信息](#retrieving-user-details)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n除了典型的基于表单的身份验证之外，Laravel 还提供了一种使用 [Laravel Socialite](https://github.com/laravel/socialite)对 OAuth providers 进行身份验证的简单方便的方法。 Socialite 目前支持 Facebook，Twitter，LinkedIn，Google，GitHub，GitLab 和 Bitbucket 的身份验证。\r\n\r\n> 技巧：其他平台的驱动器可以在 [Socialite Providers](https://socialiteproviders.com/) 社区驱动网站查找。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n在开始使用 Socialite 之前，通过 Composer 软件包管理器将软件包添加到项目的依赖项中:\r\n\r\n```shell\r\ncomposer require laravel/socialite\r\n```\r\n\r\n<a name=\"upgrading-socialite\"></a>\r\n## 升级\r\n\r\n升级到 Socialite 的新主要版本时，请务必仔细查看 [the upgrade guide](https://github.com/laravel/socialite/blob/master/UPGRADE.md).\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n在使用 Socialite 之前，需要为应用程序使用的 OAuth 服务添加凭据。这些凭证应该放在你的 `config/services.php` 配置文件中， 并且应该使用 `facebook`， `twitter`，`linkedin`， `google`， `github`， `gitlab`， 或 `bitbucket`作为键名，取决于应用程序所需的 Providers 。例如:\r\n\r\n    'github' => [\r\n        'client_id' => env('GITHUB_CLIENT_ID'),\r\n        'client_secret' => env('GITHUB_CLIENT_SECRET'),\r\n        'redirect' => 'http://example.com/callback-url',\r\n    ],\r\n\r\n> 技巧：如果 `redirect` 项的值包含一个相对路径，它将会自动解析为全称 URL。\r\n\r\n\r\n\r\n<a name=\"authentication\"></a>\r\n## 认证\r\n\r\n<a name=\"routing\"></a>\r\n### 路由\r\n\r\n要使用 OAuth 提供程序对用户进行身份验证，你需要两个路由：一个用于将用户重定向到 OAuth provider，另一个用于在身份验证后接收来自 provider 的回调。下面的示例控制器演示了这两个路由的实现：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    Route::get('/auth/redirect', function () {\r\n        return Socialite::driver('github')->redirect();\r\n    });\r\n\r\n    Route::get('/auth/callback', function () {\r\n        $user = Socialite::driver('github')->user();\r\n\r\n        // $user->token\r\n    });\r\n\r\n`redirect` 提供的方法 `Socialite` facade 负责将用户重定向到 OAuth provider，而该 user 方法将读取传入的请求并在身份验证后从提供程序中检索用户的信息。\r\n\r\n<a name=\"authentication-and-storage\"></a>\r\n### 身份验证和存储\r\n\r\n从 OAuth 提供程序检索到用户后，你可以确定该用户是否存在于应用程序的数据库中并[验证用户](/docs/laravel/9.x/authentication#authenticate-a-user-instance)。如果用户在应用程序的数据库中不存在，通常会在数据库中创建一条新记录来代表该用户：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    Route::get('/auth/callback', function () {\r\n        $githubUser = Socialite::driver('github')->user();\r\n\r\n        $user = User::where('github_id', $githubUser->id)->first();\r\n\r\n        if ($user) {\r\n            $user->update([\r\n                'github_token' => $githubUser->token,\r\n                'github_refresh_token' => $githubUser->refreshToken,\r\n            ]);\r\n        } else {\r\n            $user = User::create([\r\n                'name' => $githubUser->name,\r\n                'email' => $githubUser->email,\r\n                'github_id' => $githubUser->id,\r\n                'github_token' => $githubUser->token,\r\n                'github_refresh_token' => $githubUser->refreshToken,\r\n            ]);\r\n        }\r\n\r\n        Auth::login($user);\r\n\r\n        return redirect('/dashboard');\r\n    });\r\n\r\n> 技巧：有关特定 OAuth 提供商提供哪些用户信息的更多信息，请参阅有关 [检索用户详细信息](#retrieving-user-details) 的文档。\r\n\r\n\r\n<a name=\"access-scopes\"></a>\r\n### 访问作用域\r\n\r\n在重定向用户之前，你还可以使用 `scopes` 方法在请求中添加其他「作用域」。此方法会将所有现有作用域与你提供的作用域合并：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    return Socialite::driver('github')\r\n        ->scopes(['read:user', 'public_repo'])\r\n        ->redirect();\r\n\r\n你可以使用 `setScopes` 方法覆盖所有现有范围：\r\n\r\n    return Socialite::driver('github')\r\n        ->setScopes(['read:user', 'public_repo'])\r\n        ->redirect();\r\n\r\n<a name=\"optional-parameters\"></a>\r\n### 可选参数\r\n\r\n许多 OAuth providers 支持重定向请求中的可选参数。 要在请求中包含任何可选参数，请使用关联数组调用 `with` 方法：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    return Socialite::driver('google')\r\n        ->with(['hd' => 'example.com'])\r\n        ->redirect();\r\n\r\n> 注意：使用  `with` 方法时, 注意不要传递任何保留的关键字，例如 `state` 或 `response_type`。\r\n\r\n<a name=\"retrieving-user-details\"></a>\r\n## 检索用户详细信息\r\n\r\n在将用户重定向回你的身份验证回调路由之后，你可以使用 Socialite 的 `user` 方法检索用户的详细信息。`user` 方法为返回的用户对象提供了各种属性和方法，你可以使用这些属性和方法在你自己的数据库中存储有关该用户的信息。你可以使用不同的属性和方法这取决于要进行身份验证的 OAuth 提供程序是否支持 OAuth 1.0 或 OAuth 2.0：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    Route::get('/auth/callback', function () {\r\n        $user = Socialite::driver('github')->user();\r\n\r\n        // OAuth 2.0 providers...\r\n        $token = $user->token;\r\n        $refreshToken = $user->refreshToken;\r\n        $expiresIn = $user->expiresIn;\r\n\r\n        // OAuth 1.0 providers...\r\n        $token = $user->token;\r\n        $tokenSecret = $user->tokenSecret;\r\n\r\n        // All providers...\r\n        $user->getId();\r\n        $user->getNickname();\r\n        $user->getName();\r\n        $user->getEmail();\r\n        $user->getAvatar();\r\n    });\r\n\r\n\r\n\r\n<a name=\"retrieving-user-details-from-a-token-oauth2\"></a>\r\n#### 从令牌中检索用户详细信息 (OAuth2)\r\n\r\n如果你已经有了一个用户的有效访问令牌，你可以使用 Socialite 的 `userFromToken` 方法检索其详细信息：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    $user = Socialite::driver('github')->userFromToken($token);\r\n\r\n<a name=\"retrieving-user-details-from-a-token-and-secret-oauth1\"></a>\r\n#### 从令牌和秘钥中检索用户的详细信息 (OAuth1)\r\n\r\n如果你已经有了一对有效的用户令牌/秘钥，你可以使用 Socialite 的 `userFromTokenAndSecret` 方法检索他们的详细信息：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    $user = Socialite::driver('twitter')->userFromTokenAndSecret($token, $secret);\r\n\r\n<a name=\"stateless-authentication\"></a>\r\n#### 无认证状态\r\n\r\n`stateless` 方法可用于禁用会话状态验证。 这在向 API 添加社交身份验证时非常有用：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    return Socialite::driver('google')->stateless()->user();\r\n\r\n> 注意：Twitter 驱动程序不支持无状态身份验证，它使用 OAuth 1.0 进行身份验证\r\n\r\n","p":"docs/socialite.html"},{"t":"telescope (Laravel Telescope)","d":"# Laravel Telescope\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n    - [仅本地安装](#local-only-installation)\r\n    - [配置](#configuration)\r\n    - [数据修改](#data-pruning)\r\n    - [仪表盘授权](#dashboard-authorization)\r\n- [升级 Telescope](#upgrading-telescope)\r\n- [过滤](#filtering)\r\n    - [单项过滤](#filtering-entries)\r\n    - [批量过滤](#filtering-batches)\r\n- [标记](#tagging)\r\n- [可用的监视器](#available-watchers)\r\n    - [批量监视器](#batch-watcher)\r\n    - [缓存监视器](#cache-watcher)\r\n    - [命令监视器](#command-watcher)\r\n    - [输出监视器](#dump-watcher)\r\n    - [事件监视器](#event-watcher)\r\n    - [异常监视器](#exception-watcher)\r\n    - [Gate 监视器](#gate-watcher)\r\n    - [HTTP Client 监视器](#http-client-watcher)\r\n    - [任务监视器](#job-watcher)\r\n    - [日志监视器](#log-watcher)\r\n    - [邮件监视器](#mail-watcher)\r\n    - [模型监视器](#model-watcher)\r\n    - [消息通知监视器](#notification-watcher)\r\n    - [数据查询监视器](#query-watcher)\r\n    - [Redis 监视器](#redis-watcher)\r\n    - [请求监视器](#request-watcher)\r\n    - [定时任务监视器](#schedule-watcher)\r\n    - [视图监视器](#view-watcher)\r\n- [显示用户头像](#displaying-user-avatars)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Telescope](https://github.com/laravel/telescope) 是Laravel本地开发环境的绝佳伴侣。Telescope可以洞察你的应用程序的请求、异常、日志条目、数据库查询、排队的作业、邮件、消息通知、缓存操作、定时计划任务、变量打印等。\r\n\r\n<img src=\"https://laravel.com/img/docs/telescope-example.png\">\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n你可以使用 Composer 将 Telescope 安装到 Laravel 项目中：\r\n\r\n```shell\r\ncomposer require laravel/telescope\r\n```\r\n\r\n安装Telescope后, 你应使用 `telescope:install` 命令来发布其公共资源，然后运行 `migrate` 命令执行数据库变更:\r\n\r\n```shell\r\nphp artisan telescope:install\r\n\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"migration-customization\"></a>\r\n#### 自定义迁移\r\n\r\n\r\n\r\n如果不打算使用 Telescope 的默认迁移，则应在应用程序的`App\\Providers\\AppServiceProvider` 类的 `register` 方法中调用  `Telescope::ignoreMigrations` 方法。你可以使用以下命令导出默认迁移：`php artisan vendor:publish --tag=telescope-migrations`\r\n\r\n<a name=\"local-only-installation\"></a>\r\n### 本地安装\r\n\r\n如果你仅打算使用 Telescope 来帮助你的本地开发，你可以使用 `--dev` 标记安装 Telescope：\r\n\r\n```shell\r\ncomposer require laravel/telescope --dev\r\n\r\nphp artisan telescope:install\r\n\r\nphp artisan migrate\r\n```\r\n\r\n运行 `telescope:install` 后，应该从应用程序的 `config/app.php` 配置文件中删除 `TelescopeServiceProvider` 服务提供者注册。相反，手动注册 telescope 的服务提供者在 `App\\Providers\\AppServiceProvider` 类的 `register` 方法中。在注册提供者之前，我们会确保当前环境是 `local`：\r\n\r\n    /**\r\n     * 注册应用服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        if ($this->app->environment('local')) {\r\n            $this->app->register(\\Laravel\\Telescope\\TelescopeServiceProvider::class);\r\n            $this->app->register(TelescopeServiceProvider::class);\r\n        }\r\n    }\r\n\r\n最后，你还应该将以下内容添加到你的 `composer.json` 文件中来防止 Telescope 扩展包被 [自动发现](/docs/laravel/9.x/packages#package-discovery)。\r\n\r\n```json\r\n\"extra\": {\r\n    \"laravel\": {\r\n        \"dont-discover\": [\r\n            \"laravel/telescope\"\r\n        ]\r\n    }\r\n},\r\n```\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\n使用 Telescope，其主要配置文件将位于 `config/telescope.php`。此配置文件允许你配置监听 [观察者选项](#available-watchers)，每个配置选项都包含其用途说明，因此请务必彻底浏览此文件。\r\n\r\n如果需要，你可以使用 `enabled` 配置选项完全禁用 Telescope 的数据收集：\r\n\r\n    'enabled' => env('TELESCOPE_ENABLED', true),\r\n\r\n\r\n\r\n<a name=\"data-pruning\"></a>\r\n### 数据修改\r\n\r\n有了数据修改， `telescope_entries` 表可以非常快速地累积记录。 为了缓解这个问题，你应该使用 [调度](/docs/laravel/9.x/scheduling) 每天运行 `telescope:prune` 命令：\r\n\r\n    $schedule->command('telescope:prune')->daily();\r\n\r\n默认情况下，将获取超过 24 小时的所有数据。在调用命令时可以使用 `hours` 选项来确定保留 `Telescope` 数据的时间。例如，以下命令将删除 48 小时前创建的所有记录：\r\n\r\n    $schedule->command('telescope:prune --hours=48')->daily();\r\n\r\n<a name=\"dashboard-authorization\"></a>\r\n### 仪表板授权\r\n\r\n访问 `/telescope` 即可显示仪表盘。默认情况下，你只能在 `local` 环境中访问此仪表板。 在 `app/Providers/TelescopeServiceProvider.php` 文件中，有一个 [gate 授权](/docs/laravel/9.x/authorization#gates) 。此授权能控制在 **非本地** 环境中对 Telescope 的访问。你可以根据需要随意修改此权限以限制对 Telescope 安装和访问：\r\n\r\n    /**\r\n     * 注册 Telescope gate。\r\n     *\r\n     * 该 gate 确定谁可以在非本地环境中访问 Telescope\r\n     *\r\n     * @return void\r\n     */\r\n    protected function gate()\r\n    {\r\n        Gate::define('viewTelescope', function ($user) {\r\n            return in_array($user->email, [\r\n                'taylor@laravel.com',\r\n            ]);\r\n        });\r\n    }\r\n\r\n> 注意：你应该确保在生产环境中将 `APP_ENV` 环境变量更改为 `Production`。 否则，你的 Telescope 调试工具将公开可用。\r\n\r\n<a name=\"upgrading-telescope\"></a>\r\n## 更新 Telescope\r\n\r\n升级到 Telescope 的新主要版本时，务必仔细阅读 [升级指南](https://github.com/laravel/telescope/blob/master/UPGRADE.md).\r\n\r\n\r\n\r\n此外，升级到任何新的 Telescope 版本时，你都应该重建 Telescope 实例：\r\n\r\n```shell\r\nphp artisan telescope:publish\r\n```\r\n\r\n为了使实例保持最新状态并避免将来的更新中出现问题，可以在应用程序的 `composer.json` 文件中的 `post-update-cmd` 脚本添加 `telescope:publish` 命令：\r\n\r\n```json\r\n{\r\n    \"scripts\": {\r\n        \"post-update-cmd\": [\r\n            \"@php artisan telescope:publish --ansi\"\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"filtering\"></a>\r\n## 过滤\r\n\r\n<a name=\"filtering-entries\"></a>\r\n### 单项过滤\r\n\r\n你可以通过在 `App\\Providers\\TelescopeServiceProvider` 类中定义的 `filter` 闭包来过滤 Telescope 记录的数据。 默认情况下，此回调会记录 `local` 环境中的所有数据以及异常、失败任务、计划任务和带有受监控标记的数据：\r\n\r\n    use Laravel\\Telescope\\IncomingEntry;\r\n    use Laravel\\Telescope\\Telescope;\r\n\r\n    /**\r\n     * 注册应用服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->hideSensitiveRequestDetails();\r\n\r\n        Telescope::filter(function (IncomingEntry $entry) {\r\n            if ($this->app->environment('local')) {\r\n                return true;\r\n            }\r\n\r\n            return $entry->isReportableException() ||\r\n                $entry->isFailedJob() ||\r\n                $entry->isScheduledTask() ||\r\n                $entry->isSlowQuery() ||\r\n                $entry->hasMonitoredTag();\r\n        });\r\n    }\r\n\r\n<a name=\"filtering-batches\"></a>\r\n### 批量过滤\r\n\r\n`filter` 闭包过滤单个条目的数据， 你也可以使用 `filterBatch` 方法注册一个闭包，该闭包过滤给定请求或控制台命令的所有数据。如果闭包返回 `true`，则所有数据都由 Telescope 记录：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n    use Laravel\\Telescope\\Telescope;\r\n\r\n    /**\r\n     * 注册应用服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->hideSensitiveRequestDetails();\r\n\r\n        Telescope::filterBatch(function (Collection $entries) {\r\n            if ($this->app->environment('local')) {\r\n                return true;\r\n            }\r\n\r\n            return $entries->contains(function ($entry) {\r\n                return $entry->isReportableException() ||\r\n                    $entry->isFailedJob() ||\r\n                    $entry->isScheduledTask() ||\r\n                    $entry->isSlowQuery() ||\r\n                    $entry->hasMonitoredTag();\r\n                });\r\n        });\r\n    }\r\n\r\n\r\n\r\n<a name=\"tagging\"></a>\r\n## 标签\r\n\r\nTelescope 允许你通过 「tag」 搜索条目。通常，标签是 Eloquent 模型的类名或经过身份验证的用户 ID， 这些标签会自动添加到条目中。有时，你可能希望将自己的自定义标签附加到条目中。 你可以使用 `Telescope::tag` 方法。 `tag` 方法接受一个闭包，该闭包应返回一个标签数组。返回的标签将与 Telescope 自动附加到条目的所有标签合并。你应该在 `App\\Providers\\TelescopeServiceProvider` 类中的 `register` 方法调用 `tag` 方法：\r\n\r\n    use Laravel\\Telescope\\IncomingEntry;\r\n    use Laravel\\Telescope\\Telescope;\r\n\r\n    /**\r\n     * 注册应用服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        $this->hideSensitiveRequestDetails();\r\n\r\n        Telescope::tag(function (IncomingEntry $entry) {\r\n            return $entry->type === 'request'\r\n                        ? ['status:'.$entry->content['response_status']]\r\n                        : [];\r\n        });\r\n     }\r\n\r\n<a name=\"available-watchers\"></a>\r\n## 可用的观察者\r\n\r\nTelescope 「观察者」 在执行请求或控制台命令时收集应用数据。你可以在 `config/telescope.php` 配置文件中自定义启用的观察者列表：\r\n\r\n    'watchers' => [\r\n        Watchers\\CacheWatcher::class => true,\r\n        Watchers\\CommandWatcher::class => true,\r\n        ...\r\n    ],\r\n\r\n一些监视器还允许你提供额外的自定义选项：\r\n\r\n    'watchers' => [\r\n        Watchers\\QueryWatcher::class => [\r\n            'enabled' => env('TELESCOPE_QUERY_WATCHER', true),\r\n            'slow' => 100,\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"batch-watcher\"></a>\r\n### 批量监视器\r\n\r\n批量监视器记录队列 [批量任务](/docs/laravel/9.x/queues#job-batching) 的信息，包括任务和连接信息。\r\n\r\n<a name=\"cache-watcher\"></a>\r\n### 缓存监视器\r\n\r\n当缓存键被命中、未命中、更新和删除时，缓存监视器会记录数据。\r\n\r\n<a name=\"command-watcher\"></a>\r\n\r\n\r\n### 命令监视器\r\n\r\n只要执行 Artisan 命令，命令监视器就会记录参数、选项、退出码和输出。如果你想排除监视器记录的某些命令，你可以在 `config/telescope.php` 文件的 `ignore` 选项中指定命令：\r\n\r\n    'watchers' => [\r\n        Watchers\\CommandWatcher::class => [\r\n            'enabled' => env('TELESCOPE_COMMAND_WATCHER', true),\r\n            'ignore' => ['key:generate'],\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"dump-watcher\"></a>\r\n### 输出监视器\r\n\r\n输出监视器在 Telescope 中记录并显示你的变量输出。使用 Laravel 时，可以使用全局 `dump` 函数输出变量。必须在浏览器中打开数据监视器选项卡，才能进行输出变量，否则监视器将忽略此次输出。\r\n\r\n<a name=\"event-watcher\"></a>\r\n### 事件监视器\r\n\r\n事件监视器记录应用分发的所有 [事件](/docs/laravel/9.x/events) 的有效负载、监听器和广播数据。事件监视器忽略了 Laravel 框架的内部事件。\r\n\r\n<a name=\"exception-watcher\"></a>\r\n### 异常监视器\r\n\r\n异常监视器记录应用抛出的任何可报告异常的数据和堆栈跟踪。\r\n\r\n<a name=\"gate-watcher\"></a>\r\n### Gate（拦截）监视器\r\n\r\nGate 监视器记录你的应用的 [gate 和策略](/docs/laravel/9.x/authorization) 检查的数据和结果。如果你希望将某些属性排除在监视器的记录之外，你可 `config/telescope.php` 文件的 `ignore_abilities` 选项中指定它们：\r\n\r\n    'watchers' => [\r\n        Watchers\\GateWatcher::class => [\r\n            'enabled' => env('TELESCOPE_GATE_WATCHER', true),\r\n            'ignore_abilities' => ['viewNova'],\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"http-client-watcher\"></a>\r\n### HTTP 客户端监视器 \r\n\r\nHTTP 客户端监视器记录你的应用程序发出的传出 [HTTP 客户端请求](/docs/laravel/9.x/http-client)。\r\n\r\n<a name=\"job-watcher\"></a>\r\n### 任务监视器\r\n\r\n任务监视器记录应用程序分发的任何 [任务](/docs/laravel/9.x/queues) 的数据和状态。\r\n\r\n<a name=\"log-watcher\"></a>\r\n### 日志监视器\r\n\r\n日志监视器记录应用程序写入的任何日志的 [日志数据](/docs/laravel/8.x/logging)。\r\n\r\n<a name=\"mail-watcher\"></a>\r\n### 邮件监视器\r\n\r\n邮件监视器允许你查看应用发送的 [邮件](/docs/laravel/9.x/mail) 及其相关数据的浏览器内预览。你也可以将该电子邮件下载为 `.eml` 文件。\r\n\r\n<a name=\"model-watcher\"></a>\r\n### 模型监视器\r\n\r\n每当调度 Eloquent 的 [模型事件](/docs/laravel/9.x/eloquent#events) 时，模型监视器就会记录模型更改。你可以通过监视器的 `events` 选项指定应记录哪些模型事件：\r\n\r\n    'watchers' => [\r\n        Watchers\\ModelWatcher::class => [\r\n            'enabled' => env('TELESCOPE_MODEL_WATCHER', true),\r\n            'events' => ['eloquent.created*', 'eloquent.updated*'],\r\n        ],\r\n        ...\r\n    ],\r\n\r\n如果你想记录在给定请求期间融合的模型数量，请启用 `hydrations` 选项：\r\n\r\n    'watchers' => [\r\n        Watchers\\ModelWatcher::class => [\r\n            'enabled' => env('TELESCOPE_MODEL_WATCHER', true),\r\n            'events' => ['eloquent.created*', 'eloquent.updated*'],\r\n            'hydrations' => true,\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"notification-watcher\"></a>\r\n### 消息通知监视器\r\n\r\n消息通知监听器记录你的应用程序发送的所有 [消息通知](/docs/laravel/9.x/notifications) 。如果通知触发了电子邮件并且你启用了邮件监听器，则电子邮件也可以在邮件监视器屏幕上进行预览。\r\n\r\n<a name=\"query-watcher\"></a>\r\n### 数据查询监视器\r\n\r\n数据查询监视器记录应用程序执行的所有查询的原始 SQL、绑定和执行时间。监视器还将任何慢于 `100` 毫秒的查询标记为 `slow`。你可以使用监视器的 `slow` 选项自定义慢查询阈值：\r\n\r\n    'watchers' => [\r\n        Watchers\\QueryWatcher::class => [\r\n            'enabled' => env('TELESCOPE_QUERY_WATCHER', true),\r\n            'slow' => 50,\r\n        ],\r\n        ...\r\n    ],\r\n\r\n\r\n\r\n<a name=\"redis-watcher\"></a>\r\n### Redis 监视器\r\n\r\nRedis 监视器记录你的应用程序执行的所有 [Redis](/docs/laravel/9.x/redis) 命令。如果你使用 Redis 进行缓存，Redis 监视器也会记录缓存命令。\r\n\r\n<a name=\"request-watcher\"></a>\r\n### 请求监视器\r\n\r\n请求监视器记录与应用程序处理的任何请求相关联的请求、请求头、会话和响应数据。你可以通过 `size_limit`（以KB为单位）选项限制记录的响应数据：\r\n\r\n    'watchers' => [\r\n        Watchers\\RequestWatcher::class => [\r\n            'enabled' => env('TELESCOPE_REQUEST_WATCHER', true),\r\n            'size_limit' => env('TELESCOPE_RESPONSE_SIZE_LIMIT', 64),\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"schedule-watcher\"></a>\r\n### 定时任务监视器\r\n\r\n 定时任务监视器记录应用程序运行的任何 [计划任务](/docs/laravel/9.x/scheduling) 的命令和输出。\r\n\r\n<a name=\"view-watcher\"></a>\r\n### 视图监视器\r\n\r\n视图监视器记录渲染视图时使用的 [视图](/docs/laravel/9.x/views) 名称、路径、数据和「composer」组件。\r\n\r\n<a name=\"displaying-user-avatars\"></a>\r\n## 显示用户头像\r\n\r\nTelescope 仪表盘显示保存给定条目时会有登录用户的用户头像。 默认情况下，Telescope 将使用 Gravatar Web 服务检索头像。 但是，你可以通过在 `App\\Providers\\TelescopeServiceProvider` 中注册一个回调来自定义头像 URL。 回调将收到用户的 ID 和电子邮件地址，并应返回用户的头像 URL：\r\n\r\n    use App\\Models\\User;\r\n    use Laravel\\Telescope\\Telescope;\r\n\r\n    /**\r\n     * 注册应用服务\r\n     *\r\n     * @return void\r\n     */\r\n    public function register()\r\n    {\r\n        // ...\r\n\r\n        Telescope::avatar(function ($id, $email) {\r\n            return '/avatars/'.User::find($id)->avatar_path;\r\n        });\r\n    }\r\n\r\n","p":"docs/telescope.html"},{"t":"valet (Laravel Valet)","d":"# Laravel Valet\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n    - [升级](#upgrading-valet)\r\n- [服务站点](#serving-sites)\r\n    - [Park 命令](#the-park-command)\r\n    - [Link 命令](#the-link-command)\r\n    - [使用TLS保护站点](#securing-sites)\r\n    - [服务默认站点](#serving-a-default-site)\r\n- [共享站点](#sharing-sites)\r\n    - [通过 Ngrok 共享站点](#sharing-sites-via-ngrok)\r\n    - [通过 Expose 共享站点](#sharing-sites-via-expose)\r\n    - [共享本地网络站点](#sharing-sites-on-your-local-network)\r\n- [网络特点环境变量](#site-specific-environment-variables)\r\n- [代理服务](#proxying-services)\r\n- [自定义 Valet 驱动](#custom-valet-drivers)\r\n    - [本地驱动](#local-drivers)\r\n- [其他 Valet 命令](#other-valet-commands)\r\n- [Valet 目录和文件](#valet-directories-and-files)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Valet](https://github.com/laravel/valet) 是面向 macOS 极简主义者的 Laravel 开发环境。Laravel Valet 为你的 Mac 设置了开机后始终在后台运行 [Nginx](https://www.nginx.com/)。Valet 使用 [DnsMasq](https://en.wikipedia.org/wiki/Dnsmasq) 代理所有 `*.test` 域名的请求，指向安装在你本地计算机上的站点。\r\nValet 不能完全替代 [Sail](/docs/laravel/9.x/sail) 或 [Homestead](/docs/laravel/9.x/homestead)，但 Valet 为你提供了另外提供一种使用起来更灵活、快速且内存占用更少的选择。\r\n\r\n开箱即用，Valet 支持包括但不限于以下内容：\r\n\r\n<style>\r\n    #valet-support > ul {\r\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\r\n        line-height: 1.9;\r\n    }\r\n</style>\r\n\r\n<div id=\"valet-support\" markdown=\"1\">\r\n\r\n- [Laravel](https://laravel.com)\r\n- [Lumen](https://lumen.laravel.com)\r\n- [Bedrock](https://roots.io/bedrock/)\r\n- [CakePHP 3](https://cakephp.org)\r\n- [Concrete5](https://www.concrete5.org/)\r\n- [Contao](https://contao.org/en/)\r\n- [Craft](https://craftcms.com)\r\n- [Drupal](https://www.drupal.org/)\r\n- [ExpressionEngine](https://www.expressionengine.com/)\r\n- [Jigsaw](https://jigsaw.tighten.co)\r\n- [Joomla](https://www.joomla.org/)\r\n- [Katana](https://github.com/themsaid/katana)\r\n- [Kirby](https://getkirby.com/)\r\n- [Magento](https://magento.com/)\r\n- [OctoberCMS](https://octobercms.com/)\r\n- [Sculpin](https://sculpin.io/)\r\n- [Slim](https://www.slimframework.com)\r\n- [Statamic](https://statamic.com)\r\n- 静态 HTML 页面\r\n- [Symfony](https://symfony.com)\r\n- [WordPress](https://wordpress.org)\r\n- [Zend](https://framework.zend.com)\r\n\r\n</div>\r\n\r\n\r\n\r\n但是，你可以使用自己的 [自定义驱动程序](#custom-valet-drivers) 扩展 Valet 。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n> 注意：Valet 需要 macOS 和 [Homebrew](https://brew.sh/) ，你应该确保没有其他程序 (例如 Apache 或者 Nginx) 占用本地计算机的 80 端口。\r\n\r\n首先，你首先需要使用以下 `update` 命令确保 Homebrew 是最新的：\r\n\r\n```shell\r\nbrew update\r\n```\r\n\r\n接下来，你应该使用 Homebrew 安装 PHP:\r\n\r\n```shell\r\nbrew install php\r\n```\r\n\r\n在安装 PHP 之后，就可以安装 [Composer 软件包管理器](https://getcomposer.org) 了。 另外，你应该确保 `~/.composer/vendor/bin` 目录位于系统的「PATH」 中。安装 Composer 之后，你可以将 Laravel Valet 安装为全局 Composer 软件包：\r\n\r\n```shell\r\ncomposer global require laravel/valet\r\n```\r\n\r\n最后，你可以执行 Valet 的 `install` 命令。这将配置并安装 Valet 和 DnsMasq。此外，Valet 依赖的守护程序将配置为在系统启动时启动：\r\n\r\n```shell\r\nvalet install\r\n```\r\n\r\n安装 Valet 后，请尝试使用如 之类的命令 `ping foobar.test` ping 终端上的任何 `*.test` 域。 如果 Valet 安装正确，你应该看到该域在 `127.0.0.1` 上响应。\r\n\r\n每当你的机器启动时，Valet 将自动启动其所需的相关服务。\r\n\r\n<a name=\"php-versions\"></a>\r\n#### PHP 版本\r\n\r\nValet 允许你使用 `valet use php@version` 命令切换 PHP 版本。如果尚未安装， Valet 将通过 Homebrew 安装指定的 PHP 版本：\r\n\r\n```shell\r\nvalet use php@7.2\r\n\r\nvalet use php\r\n```\r\n\r\n\r\n\r\n你也可以在项目根目录中创建一个 `.valetphprc` 文件。 该 `.valetphprc` 文件应包含网站应使用的PHP版本：\r\n\r\n```shell\r\nphp@7.2\r\n```\r\n\r\n创建此文件后，您可以简单地执行 `valet use` 命令，该命令将通过读取该文件来确定站点的首选PHP版本。\r\n\r\n> 注意：即使您安装了多个 PHP 版本，Valet 服务一次只能提供一个 PHP 版本。\r\n\r\n<a name=\"database\"></a>\r\n#### 数据库\r\n\r\n如果你的站点需要使用数据库，尝试使用 [DBngin](https://dbngin.com)。DBngin 是一个免费的，可以管理多种数据库的工具，包括 MySQL，PostgreSQL 和 Redis。在安装完成 DBngin 以后，你可以使用 `root` 用户名和空密码连接到你的本地 `127.0.0.1` 数据库。\r\n\r\n<a name=\"resetting-your-installation\"></a>\r\n#### 重新安装\r\n\r\n如果你的 Valet 无法正常运行，执行 `composer global update` 命令后再执行 `valet install` 重新安装可解决各种问题。在极少数情况下，可能需要执行 `valet uninstall --force` 然后执行 `valet install` 来「硬复位」 Valet。\r\n\r\n<a name=\"upgrading-valet\"></a>\r\n### 升级 Valet\r\n\r\n你可以在命令行终端运行 `composer global update` 更新你的 Valet。更新完成后，最好再运行一次 `valet install` 命令，这样 Valet 可以在必要时对配置文件进行升级。\r\n\r\n<a name=\"serving-sites\"></a>\r\n## 服务站点\r\n\r\n安装 Valet 之后，你就可以配置 Laravel 站点。Valet 提供了 2 个命令来配置： `park` 和 `link`。\r\n\r\n\r\n\r\n<a name=\"the-park-command\"></a>\r\n### `park` 命令\r\n\r\n该 `park` 命令将注册了你的 Mac 上的一个包含服务的路径。一旦路径被「parked」成为 Valet 的一部分，可以使用域名 `http://<directory-name>.test` 通过浏览器访问此路径下的目录：\r\n\r\n```shell\r\ncd ~/Sites\r\n\r\nvalet park\r\n```\r\n\r\n这就是所有需要手动的操作。现在，任何你创建在「parked」目录中的服务都可以使用 `http://<directory-name>.test` 域名自动访问。例如，如果你的「parked」路径下包括一个名为「laravel」的目录，可以使用 `http://laravel.test` 来访问。另外，Valet 自动允许二级域名访问此站点。 (`http://foo.laravel.test`)。\r\n\r\n<a name=\"the-link-command\"></a>\r\n### `link` 命令\r\n\r\n该 `link` 命令也可以用来为你的 Laravel 站点提供服务。如果要为目录中的单个站点而不是整个目录提供服务，则此命令非常有用。\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nvalet link\r\n```\r\n\r\n在运行 `link` 命令链接一个站点后，你可以使用目录名称来访问这个链接。例如，你可以在浏览器中通过 `http://laravel.test` 访问站点。另外，Valet 自动添加了站点二级目录的访问功能，例如 (`http://foo.laravel.test`)。\r\n\r\n如果你想要使用不同的域名来访问相同站点，你可以使用 `link` 命令来构造站点。例如，你可以使用以下命令来使目录可以通过 `http://application.test` 访问：\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nvalet link application\r\n```\r\n\r\n\r\n\r\n你可以使用 `links` 命令来查看所有的目录链接：\r\n\r\n```shell\r\nvalet links\r\n```\r\n\r\n该 `unlink` 命令可以用来删除动态链接：\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nvalet unlink\r\n```\r\n\r\n<a name=\"securing-sites\"></a>\r\n### 使用 TLS 保护站点\r\n\r\n默认情况下，Valet 使用 HTTP 协议提供服务。当然，如果您想要使用 HTTP/2 通过 TLS 加密您的站点，您可以使用 `secure` 命令。例如，如果您的站点通过 Valet 在 `laravel.test` 域名上提供服务，您可以使用如下命令以为站点实现安全保护功能：\r\n\r\n```shell\r\nvalet secure laravel\r\n```\r\n\r\n要 「解除保护」并回退至 HTTP ，请使用 `unsecure` 命令。像 `secure` 命令一样，该命令接受您想要解除保护的主机名：\r\n\r\n```shell\r\nvalet unsecure laravel\r\n```\r\n\r\n<a name=\"serving-a-default-site\"></a>\r\n### 为默认站点提供服务\r\n\r\n有时，当访问未知的 `test` 域时，您可能希望将Valet配置为「默认」站点，而不是 `404` 。要实现这一点，您可以在 `~/.config/valet/config.json` 配置文件中添加一个 `default` 选项。 其中包含应作为默认站点的路径：\r\n\r\n    \"default\": \"/Users/Sally/Sites/foo\",\r\n\r\n<a name=\"sharing-sites\"></a>\r\n## 共享站点\r\n\r\nValet 甚至包含了一个命令，用于与全世界共享您的站点，它提供了一种方便的可在手机上测试站点或和您的团队成员共享站点的方式。\r\n\r\n<a name=\"sharing-sites-via-ngrok\"></a>\r\n### 使用 Ngrok 共享站点\r\n\r\n要共享站点，请在终端中定位到站点目录，并运行 Valet `share` 命令。一个公开可访问的 URL 将会插入到您的剪贴板中，您可以分享它给您的团队成员或在浏览器中打开它:\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nvalet share\r\n```\r\n\r\n\r\n\r\n要停止共享你的站点，请按 `Control + C` 去取消该过程。使用Ngrok共享您的网站需要您 [创建  Ngrok 帐户](https://dashboard.ngrok.com/signup) 和 [设置身份验证令牌](https://dashboard.ngrok.com/get-started/your-authtoken)。\r\n\r\n> 技巧：您可以向 share 命令传递额外的参数， 如 `valet share --region=eu`。 更多信息，请参考 [ngrok 文档](https://ngrok.com/docs)。\r\n\r\n<a name=\"sharing-sites-via-expose\"></a>\r\n### 通过 Expose 共享站点\r\n\r\n如果你安装了 [Expose](https://expose.dev) ，打开命令行进入网站根目录执行 `expose` 就可以共享你的网站。查看 [Expose 文档](https://expose.dev/docs) 获取更多支持的命令行参数。成功共享站点后，Expose 将显示可共享的 URL，您可以在其他设备上或在团队成员之间使用该 URL:\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nexpose\r\n```\r\n\r\n要停止共享你的站点，请按 `Control + C` 去取消该过程。\r\n\r\n<a name=\"sharing-sites-on-your-local-network\"></a>\r\n### 在本地网络上共享站点\r\n\r\n默认情况下，Valet 将传入流量限制为内部 `127.0.0.1` 接口。这样，您的开发机器就不会暴露在来自 Internet 的安全风险中。\r\n\r\n如果您希望在本地网络上允许其他设备通过机器的 IP 地址访问计算机上的代码站点 (如： `192.168.1.10/application.test` )，您需要手动编辑该站点的相应 Nginx 配置文件，以删除对 `listen` 指令的限制。您应该删除端口 80 和 443 `listen` 指令中的 `127.0.0.1:` 前缀。\r\n\r\n如果您没有在项目上运行 `valet secure` 您可以通过编辑， `/usr/local/etc/nginx/valet/valet.conf` 文件来为所有非 HTTPS 站点打开所有非 HTTPS 站点的网络访问。但是，如果您在 HTTPS 上为项目站点提供服务（您已为网站运行 `valet secure` ），那么您应该编辑 `~/.config/valet/Nginx/app-name.test` 文件。\r\n\r\n\r\n\r\n更新了 nginx 配置后，运行 `valet restart` 命令以应用配置更改。\r\n\r\n<a name=\"site-specific-environment-variables\"></a>\r\n## 站点特定环境变量\r\n\r\n使用其他框架的某些应用程序可能取决于服务器环境变量，但不提供要在项目中配置的变量的方法。 Valet 允许您通过在项目根部内添加 `.valet-env.php` 文件来配置站点特定环境变量。 此文件应返回一个站点 / 环境变量对数组，该对将为阵列中指定的每个站点添加到全局 `$_SERVER` 数组中：\r\n\r\n    <?php\r\n\r\n    return [\r\n        // 为 laravel.test 站点设置 $_SERVER['key'] 对应的 \"value\" 值 ...\r\n        'laravel' => [\r\n            'key' => 'value',\r\n        ],\r\n\r\n        // 为所有站点设置 $_SERVER['key'] 对应的 \"value\" 值 ...\r\n        '*' => [\r\n            'key' => 'value',\r\n        ],\r\n    ];\r\n\r\n<a name=\"proxying-services\"></a>\r\n## 代理服务\r\n\r\n有时您可能希望将代客域代理到本地机器上的 Valet 站点。 例如，您可能偶尔需要运行 Valet，同时在 Docker 中运行单独的站点； 但是， Valet 和 Docker 不能同时绑定到端口 80。\r\n\r\n为了解决这个问题，你可能用到 `proxy` 命令去生成一个代理。例如，您可以代理所有流量从 `http://elasticsearch.test` 到  `http://127.0.0.1:9200`：\r\n\r\n```shell\r\n# Proxy over HTTP...\r\nvalet proxy elasticsearch http://127.0.0.1:9200\r\n\r\n# Proxy over TLS + HTTP/2...\r\nvalet proxy elasticsearch http://127.0.0.1:9200 --secure\r\n```\r\n\r\n你可以用 `unproxy` 命令去删除一个代理：\r\n\r\n```shell\r\nvalet unproxy elasticsearch\r\n```\r\n\r\n你可以用 `proxies` 命令列出代理的所有站点配置：\r\n\r\n```shell\r\nvalet proxies\r\n```\r\n\r\n\r\n\r\n<a name=\"custom-valet-drivers\"></a>\r\n## 定制 Valet 驱动\r\n\r\n你可以编写自己的 Valet「驱动」，以服务于在框架或 CMS 上运行的 PHP 应用程序，该应用程序未受 Valet 支持的。 安装 Valet 时，创建了一个 `~/.config/valet/Drivers` 目录，其中包含一个 `samplevaletdriver.php` 文件。 此文件包含示例驱动程序实现，以演示如何编写自定义驱动程序。写驱动只需要你实现三种方法：`serves` ， `isStaticFile` ， 和 `frontControllerPath` 。\r\n\r\n这三种方法都接收 `$sitePath`, `$siteName`, and `$uri` 值作为其参数。 `$sitePath` 是你机器上服务的网站的完整的路径， 如 `/Users/Lisa/Sites/my-project`。  `$siteName` 是 「host」/「site name」域名的一部分 (`my-project`)。`$uri` 是传入的请求 URI (`/foo/bar`)。\r\n\r\n完成你的自定义 Valet 驱动后, 使用 `frameworkvaletdriver.php` 命名约定将它放在 `~/.config/valet/Drivers` 目录中。 例如，如果你正在为 WordPress 编写自定义 Valet 驱动，则你的文件名应该是 `WordPressValetDriver.php`。\r\n\r\n我们来看看自定义的 Valet 驱动程序应该实现的每种方法的示例实现。\r\n<a name=\"the-serves-method\"></a>\r\n#### `serves` 方法\r\n\r\n如果驱动程序应该处理传入的请求，`serves` 方法应该返回 `true`。否则，该方法应返回 `false`。因此，在这个方法中，你应该尝试确定给定的 `$sitePath` 是否包含你试图服务的类型的项目。\r\n\r\n例如，假设我们正在编写一个 `WordPressValetDriver`。我们的 `serves` 方法可能看起来如下所示：\r\n\r\n    /**\r\n     * 确定驱动程序是否为请求服务。\r\n     *\r\n     * @param  string  $sitePath\r\n     * @param  string  $siteName\r\n     * @param  string  $uri\r\n     * @return bool\r\n     */\r\n    public function serves($sitePath, $siteName, $uri)\r\n    {\r\n        return is_dir($sitePath.'/wp-admin');\r\n    }\r\n\r\n\r\n\r\n<a name=\"the-isstaticfile-method\"></a>\r\n#### `isStaticFile` 方法\r\n\r\n`isStaticFile` 应当确定即将到来的请求是否针对一个「静态」文件，比如：图片和样式表。如果文件是静态的，此方法应当返回静态文件在磁盘上的完全限定路径。如果即将到来的请求不是针对一个静态文件，这个方法应当返回 `false`：\r\n\r\n    /**\r\n     * 确定即将到来的请求是否针对静态文件。\r\n     *\r\n     * @param  string  $sitePath\r\n     * @param  string  $siteName\r\n     * @param  string  $uri\r\n     * @return string|false\r\n     */\r\n    public function isStaticFile($sitePath, $siteName, $uri)\r\n    {\r\n        if (file_exists($staticFilePath = $sitePath.'/public/'.$uri)) {\r\n            return $staticFilePath;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n> 注意：仅当 `serves` 方法对传入请求返回 `true` 且请求 URI 不是 `/` 时，才会调用 `isStaticFile` 方法。\r\n\r\n<a name=\"the-frontcontrollerpath-method\"></a>\r\n####  `frontControllerPath` 方法\r\n\r\n`frontControllerPath` 方法应该返回你的应用的「前端控制器」的完全限定路径，它通常是 「index.php」 或等效的文件：\r\n\r\n    /**\r\n     * 获取应用程序前端控制器的完全解析路径。\r\n     *\r\n     * @param  string  $sitePath\r\n     * @param  string  $siteName\r\n     * @param  string  $uri\r\n     * @return string\r\n     */\r\n    public function frontControllerPath($sitePath, $siteName, $uri)\r\n    {\r\n        return $sitePath.'/public/index.php';\r\n    }\r\n\r\n<a name=\"local-drivers\"></a>\r\n### 本地驱动\r\n\r\n如果你想要为单个应用自定义一个 Valet 驱动，请在应用根目录创建一个 `LocalValetDriver.php` 文件。你的自定义驱动可以继承 `ValetDriver` 基类或继承现有应用的特定驱动程序，如 `LaravelValetDriver`：\r\n\r\n    class LocalValetDriver extends LaravelValetDriver\r\n    {\r\n        /**\r\n         * 确定驱动程序是否给请求提供服务。\r\n         *\r\n         * @param  string  $sitePath\r\n         * @param  string  $siteName\r\n         * @param  string  $uri\r\n         * @return bool\r\n         */\r\n        public function serves($sitePath, $siteName, $uri)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * 获取对应用程序的前端控制器的完全解析路径。\r\n         *\r\n         * @param  string  $sitePath\r\n         * @param  string  $siteName\r\n         * @param  string  $uri\r\n         * @return string\r\n         */\r\n        public function frontControllerPath($sitePath, $siteName, $uri)\r\n        {\r\n            return $sitePath.'/public_html/index.php';\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"other-valet-commands\"></a>\r\n## 其他 Valet 命令\r\n\r\n命令  | 描述\r\n------------- | -------------\r\n`valet forget` | 从「驻留」目录运行此命令，将其从驻留目录列表中删除。\r\n`valet log` | 查看 Valet 服务记录的日志列表。\r\n`valet paths` | 查看所有「驻留」的路径。\r\n`valet restart` | 重启 Valet 守护进程。\r\n`valet start` | 启动 Valet 守护进程。\r\n`valet stop` | 停止 Valet 守护进程。\r\n`valet trust` | 为 Brew 和 Valet 添加 sudoers 文件，使 Valet 输入命令的时候不需要输入密码。\r\n`valet uninstall` | 卸载 Valet：显示手动卸载的说明。 传递 `--force` 选项来主动删除 Valet 的所有资源。\r\n\r\n<a name=\"valet-directories-and-files\"></a>\r\n## Valet 目录和文件\r\n\r\n你可能会发现以下目录和文件信息对排查你的 Valet 环境故障问题很有帮助：\r\n\r\n#### `~/.config/valet`\r\n\r\n包含 Valet 所有的配置，您可能希望对此文件夹进行备份。\r\n\r\n#### `~/.config/valet/dnsmasq.d/`\r\n\r\n此目录包含 DNSMasq 的配置。\r\n\r\n#### `~/.config/valet/Drivers/`\r\n\r\n此目录包含 Valet 的驱动，驱动判断如何为特定的 framework/CMS 提供服务。\r\n\r\n#### `~/.config/valet/Extensions/`\r\n\r\n此目录包括自定义的 Valet 扩展和指令。\r\n\r\n#### `~/.config/valet/Nginx/`\r\n\r\n此目录包含所有 Valet 的 Nginx 站点配置，当运行 `install`、`secure`、`tld` 指令时会重建这些配置文件。\r\n\r\n#### `~/.config/valet/Sites/`\r\n\r\n此目录包含所有 [链接项目](#the-link-command) 的符号链接。\r\n\r\n#### `~/.config/valet/config.json`\r\n\r\n此文件是 Valet 的主要配置文件。\r\n\r\n#### `~/.config/valet/valet.sock`\r\n\r\n这个文件是 Valet 中 Nginx 安装使用的 PHP-FPM 套接字，只有在 PHP 正常运行的情况下，它才会存在。\r\n\r\n\r\n\r\n#### `~/.config/valet/Log/fpm-php.www.log`\r\n\r\n此文件是 PHP 错误的用户日志。\r\n\r\n#### `~/.config/valet/Log/nginx-error.log`\r\n\r\n此文件是 Nginx 错误的用户日志。\r\n\r\n#### `/usr/local/var/log/php-fpm.log`\r\n\r\n此文件是 PHP-FPM 错误的系统日志。\r\n\r\n#### `/usr/local/var/log/nginx`\r\n\r\n此目录包含 Nginx 的访问和错误日志。\r\n\r\n#### `/usr/local/etc/php/X.X/conf.d`\r\n\r\n此目录包含用于各种 PHP 配置设置的  `*.ini` 文件。\r\n\r\n#### `/usr/local/etc/php/X.X/php-fpm.d/valet-fpm.conf`\r\n\r\n此文件是 PHP-FPM 池配置文件。\r\n\r\n#### `~/.composer/vendor/laravel/valet/cli/stubs/secure.valet.conf`\r\n\r\n此文件是用于为站点构建 SSL 证书的默认 Nginx 配置。\r\n\r\n","p":"docs/valet.html"}]