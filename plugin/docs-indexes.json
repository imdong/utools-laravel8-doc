[{"t":"releases (发行说明)","d":"# 发行说明\r\n\r\n- [版本控制方案](/docs/laravel/10.x/releases/#versioning-scheme)\r\n\r\n- [支持政策](/docs/laravel/10.x/releases/#support-policy)\r\n测试\r\n- [Laravel 10](/docs/laravel/10.x/releases/#laravel-10)\r\n\r\n<a name=\"versioning-scheme\"></a>\r\n\r\n## 版本控制方案\r\n\r\nLaravel 及其其他第一方软件包遵循 [语义化版本控制](https://semver.org/)。主要框架版本释出是每年 (~Q1)，而较小和补丁版本则可能每周释出一次。较小和补丁版本决不能包含破坏性更改。\r\n\r\n当从你的应用程序或软件包引用 Laravel 框架或其组件时，应始终使用类似 `^10.0` 的版本约束，因为 Laravel 的主要版本包含破坏性更改。但是，我们始终努力确保你可以在一天或更短时间内更新到新的主要版本。\r\n\r\n<a  name=\"named-arguments\"></a>\r\n\r\n#### 命名参数\r\n\r\n[命名参数](https://www.php.net/manual/en/functions.arguments.php#functions.named-arguments) 未被 Laravel 的向后兼容性指导方针所覆盖。我们可能会在必要时重命名函数参数，以改进 Laravel 代码库。因此，当调用 Laravel 方法时使用命名参数应该谨慎进行，并且要知道参数名称可能会在未来更改。\r\n\r\n<a  name=\"support-policy\"></a>\r\n\r\n## 支持政策\r\n\r\n对于所有 Laravel 版本，修复错误将提供 18 个月支持，而安全修复将提供 2 年支持。对于所有其他库，包括 Lumen，在更新最新的主要发布版本之前只提供 bug 修复。此外，请查看 [Laravel 支持的数据库版本](/docs/laravel/10.x/databasemd/14882#e05dce)。\r\n\r\n| 版本 | PHP (\\*) | 发布日期 | Bug 修复截止日期 | 安全修复截止日期 |\r\n| ---- | --------- | ------------------ | ------------------ | ------------------ |\r\n| 8 | 7.3 - 8.1 | 2020 年 9 月 8 日 | 2022 年 7 月 26 日 | 2023 年 1 月 24 日 |\r\n| 9 | 8.0 - 8.2 | 2022 年 2 月 8 日 | 2023 年 8 月 8 日 | 2024 年 2 月 6 日 |\r\n| 10 | 8.1 - 8.2 | 2023 年 2 月 14 日 | 2024 年 8 月 6 日 | 2025 年 2 月 4 日 |\r\n| 11 | 8.2 | 2024 年 Q1 | 2025 年 8 月 5 日 | 2026 年 2 月 3 日 |\r\n\r\n(\\*) 支持的 PHP 版本\r\n\r\n<a name=\"laravel-10\"></a>\r\n\r\n## Laravel 10\r\n\r\n正如你可能已经知道的那样，Laravel 在发布 Laravel 8 后转向每年发布一次。之前，每 6 个月发布一个主要版本。这种转变旨在减轻社区的维护负担，并挑战我们的开发团队在不引入破坏性变化的情况下发布令人惊叹、功能强大的新功能。因此，我们为 Laravel 9 提供了许多强大的功能，而不会破坏向后兼容性。\r\n\r\n因此，这种致力于在当前发布期间发布出色新功能的承诺可能会导致未来的「主要」版本主要用于诸如升级上游依赖项之类的「维护」任务，这些可以在这些发布说明中看到。\r\n\r\nLaravel 10 继续在 Laravel 9.x 中所做的改进，通过向所有应用程序骨架方法和所有存根文件引入参数和返回类型，以及向外部进程启动和交互引入了一种新的开发人员友好的抽象层。此外，引入了 Laravel Pennant，为管理你的应用程序的「特性标志」提供了一种奇妙的方法。\r\n\r\n<a name=\"php-8\"></a>\r\n\r\n### PHP 8.1\r\n\r\nLaravel 10.x 要求至少使用 PHP 版本 8.1。\r\n\r\n<a  name=\"types\"></a>\r\n\r\n### Types\r\n\r\n_应用程序骨架和存根的类型提示由 [Nuno Maduro](https://github.com/nunomaduro) 提供。_\r\n\r\n在最初发布时，Laravel 利用了 PHP 当时提供的所有类型提示特性。然而，在随后的几年中，PHP 添加了许多新的功能，包括额外的基本类型提示、返回类型和联合类型。\r\n\r\nLaravel 10.x 彻底更新了应用程序骨架和框架使用的所有存根，以向所有方法签名引入参数和返回类型。此外，已删除冗余的 「doc block」 类型提示信息。\r\n\r\n这个更改完全向后兼容现有应用程序。因此，没有这些类型提示的现有应用程序将继续正常运行。\r\n\r\n<a name=\"laravel-pennant\"></a>\r\n\r\n### Laravel Pennant\r\n\r\n_Laravel Pennant 由 [Tim MacDonald](https://github.com/timacdonald) 贡献。_\r\n\r\n发布了一个新的第一方软件包，Laravel Pennant。Laravel Pennant 提供了一种轻量级、简洁的方法来管理应用程序的特性标志。Pennant 出厂时包括一个内存中的 `array` 驱动程序和一个 `database` 驱动程序，用于持久化特性存储。\r\n\r\n可以通过 `Feature::define` 方法轻松地定义特性：\r\n\r\n```\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nuse Illuminate\\Support\\Lottery;\r\n\r\nFeature::define('new-onboarding-flow', function () {\r\n\r\nreturn Lottery::odds(1, 10);\r\n\r\n});\r\n\r\n```\r\n\r\n定义特性后，你可以轻松地确定当前用户是否有访问给定特性的权限：\r\n\r\n```\r\nif (Feature::active('new-onboarding-flow')) {\r\n\r\n// ...\r\n\r\n}\r\n\r\n```\r\n\r\n当然，为了方便起见，Blade 指令也可用：\r\n\r\n```\r\n@feature('new-onboarding-flow')\r\n\r\n<div>\r\n\r\n<!-- ... -->\r\n\r\n</div>\r\n\r\n@endfeature\r\n\r\n```\r\n\r\nPennant 提供了各种更高级的特性和 API。有关更多信息，请参阅 [详细的 Pennant 文档](/docs/laravel/10.x/pennantmd/14911)。\r\n\r\n<a name=\"process\"></a>\r\n\r\n### 进程交互\r\n\r\n_进程抽象层由 [Nuno Maduro](https://github.com/nunomaduro) 和 [Taylor Otwell](https://github.com/taylorotwell) 贡献。_\r\n\r\nLaravel 10.x 引入了一个美丽的抽象层，用于通过新的 `Process` 门面启动和与外部进程交互：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\n$result = Process::run('ls -la');\r\n\r\nreturn  $result->output();\r\n\r\n```\r\n\r\n甚至可以在池中启动进程，允许方便地执行和管理并发进程：\r\n\r\n```php\r\nuse Illuminate\\Process\\Pool;\r\n\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\n[$first, $second, $third] =  Process::concurrently(function (Pool  $pool) {\r\n\r\n$pool->command('cat first.txt');\r\n\r\n$pool->command('cat second.txt');\r\n\r\n$pool->command('cat third.txt');\r\n\r\n});\r\n\r\nreturn  $first->output();\r\n\r\n```\r\n\r\n这一变化完全向后兼容现有的应用程序。因此，没有这些类型提示的现有应用程序将继续正常运行。\r\n\r\n此外，进程可能会被虚构，以方便测试：\r\n\r\n```php\r\nProcess::fake();\r\n\r\n// ...\r\n\r\nProcess::assertRan('ls -la');\r\n\r\n```\r\n\r\n有关与进程交互的更多信息，请参阅 [详细的进程管理文档](/docs/laravel/10.x/processesmd/14872)。\r\n\r\n<a name=\"test-profiling\"></a>\r\n\r\n### 测试分析\r\n\r\n_测试分析由 [Nuno Maduro](https://github.com/nunomaduro) 贡献。_\r\n\r\nArtisan 的 `test` 命令现在具有一个新的 `--profile` 选项，使你可以轻松识别应用程序中最慢的测试：\r\n\r\n```shell\r\nphp artisan  test  --profile\r\n\r\n```\r\n\r\n为了方便起见，最慢的测试将直接显示在 CLI 输出中：\r\n\r\n<p align=\"center\">\r\n\r\n<img width=\"100%\" src=\"https://user-images.githubusercontent.com/5457236/217328439-d8d983ec-d0fc-4cde-93d9-ae5bccf5df14.png\"/>\r\n\r\n</p>\r\n\r\n<a  name=\"pest-scaffolding\"></a>\r\n\r\n### Pest 脚手架\r\n\r\n现在，新的 Laravel 项目可以默认使用 Pest 测试脚手架。要启用此功能，请在通过 Laravel 安装程序创建新应用程序时提供 `--pest` 标志：\r\n\r\n```shell\r\nlaravel new  example-application  --pest\r\n\r\n```\r\n\r\n<a name=\"generator-cli-prompts\"></a>\r\n\r\n### 生成器 CLI 提示\r\n\r\n_生成器 CLI 提示由 [Jess Archer](https://github.com/jessarcher) 贡献。_\r\n\r\n为了改进框架的开发体验，Laravel 内置的所有 make 命令现在不需要任何输入。如果调用命令时没有输入，你将被提示提供所需的参数：\r\n\r\n```shell\r\nphp artisan  make:controller\r\n\r\n```\r\n\r\n<a name=\"horizon-telescope-facelift\"></a>\r\n\r\n### Horizon / Telescope 界面更新\r\n\r\n[Horizon](https://learnku.com/docs/laravel/10.x/horizonmd/14906) 和 [Telescope](https://learnku.com/docs/laravel/10.x/telescopemd/14917) 已经通过改进版式、间距和设计更新为新的现代外观：\r\n\r\n<img src=\"https://laravel.com/img/docs/horizon-example.png\">","p":"docs/releases.html"},{"t":"upgrade (升级指南)","d":"# 升级指南\r\n\r\n- [从 9.x 升级到 10.0](#upgrade-10.0)\r\n\r\n<a name=\"high-impact-changes\"></a>\r\n## 高影响变化\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [更新依赖项](#updating-dependencies)\r\n- [更新最小稳定性](#updating-minimum-stability)\r\n\r\n</div>\r\n\r\n<a name=\"medium-impact-changes\"></a>\r\n## 中等影响变化\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [数据库表达式](#database-expressions)\r\n- [模型「日期」属性](#model-dates-property)\r\n- [Monolog 3](#monolog-3)\r\n- [Redis缓存标签](#redis-cache-tags)\r\n- [服务模拟](#service-mocking)\r\n- [语言目录](#language-directory)\r\n</div>\r\n\r\n<a name=\"low-impact-changes\"></a>\r\n## 较小影响变化\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [Closure 验证规则消息](#closure-validation-rule-messages)\r\n- [Public 路径绑定](#public-path-binding)\r\n- [Query 异常构造函数](#query-exception-constructor)\r\n- [Rate Limiter 返回值](#rate-limiter-return-values)\r\n- [关系 `getBaseQuery` 方法](#relation-getbasequery-method)\r\n- [`Redirect::home` 方法](#redirect-home)\r\n- [`Bus::dispatchNow` 方法](#dispatch-now)\r\n- [`registerPolicies` 方法](#register-policies)\r\n- [ULID 列](#ulid-columns)\r\n\r\n</div>\r\n\r\n<a name=\"upgrade-10.0\"></a>\r\n## 从 9.x 升级到 10.0\r\n\r\n<a name=\"estimated-upgrade-time-??-minutes\"></a>\r\n#### 预计升级时间：10 分钟\r\n\r\n> **注意**\r\n> 我们试图记录每一个可能的破坏性变更。由于其中一些破坏性变更位于框架的底层部分，因此只有其中一部分变更实际上会影响你的应用程序。想节省时间吗？你可以使用 [Laravel Shift](https://laravelshift.com/) 来帮助自动升级你的应用程序。\r\n\r\n<a name=\"updating-dependencies\"></a>\r\n### 更新依赖项\r\n\r\n**影响可能性：高**\r\n\r\n#### 要求 PHP 8.1.0\r\n\r\nLaravel 现在要求 PHP 8.1.0 或更高版本。\r\n\r\n#### 要求 Composer 2.2.0\r\n\r\nLaravel 现在要求 [Composer](https://getcomposer.org) 2.2.0 或更高版本。\r\n\r\n#### 更新 Composer 依赖项\r\n\r\n你应该在应用程序的 `composer.json` 文件中更新以下依赖项：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `laravel/framework` 更新到 `^10.0`\r\n- `laravel/sanctum` 更新到 `^3.2`\r\n- `doctrine/dbal` 更新到 `^3.0`\r\n- `spatie/laravel-ignition` 更新到 `^2.0`\r\n\r\n</div>\r\n\r\n\r\n\r\n如果你从 2.x 发布系列升级到 Sanctum 3.x，请参考 [Sanctum 升级指南](https://github.com/laravel/sanctum/blob/3.x/UPGRADE.)。\r\n\r\n此外，如果你想使用 [PHPUnit 10](https://phpunit.de/announcements/phpunit-10.html)，则应该从应用程序的 `phpunit.xml` 配置文件的 `<coverage>` 部分中删除 `processUncoveredFiles` 属性。然后，更新应用程序的 `composer.json` 文件中的以下依赖项：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `nunomaduro/collision` 更新到 `^7.0`\r\n- `phpunit/phpunit` 更新到 `^10.0`\r\n\r\n</div>\r\n\r\n最后，检查应用程序使用的任何其他第三方包，并验证你正在使用 Laravel 10 支持的适当版本。\r\n\r\n<a name=\"updating-minimum-stability\"></a>\r\n#### 最小稳定性\r\n\r\n你应该将应用程序的 `composer.json` 文件中的 `minimum-stability` 设置更新为 `stable`：\r\n\r\n```json\r\n\"minimum-stability\": \"stable\",\r\n```\r\n\r\n### 应用程序\r\n\r\n<a name=\"public-path-binding\"></a>\r\n#### 绑定公共路径\r\n\r\n**影响可能性：低**\r\n\r\n如果你的应用程序将通过 `path.public` 绑定到容器来自定义其「公共路径」，则应该更新你的代码以调用 `Illuminate\\Foundation\\Application` 对象提供的 `usePublicPath` 方法：\r\n\r\n```php\r\napp()->usePublicPath(__DIR__.'/public');\r\n```\r\n\r\n### 授权\r\n\r\n<a name=\"register-policies\"></a>\r\n### `registerPolicies` 方法\r\n\r\n**影响可能性：低**\r\n\r\n框架会自动调用 `AuthServiceProvider` 的 `registerPolicies` 方法。因此，你可以从应用程序的 `AuthServiceProvider` 的 `boot` 方法中删除对此方法的调用。\r\n\r\n### 缓存\r\n\r\n<a name=\"redis-cache-tags\"></a>\r\n#### Redis 缓存标签\r\n\r\n**影响可能性：中等**\r\n\r\nRedis 的 [缓存标签](/docs/laravel/10.x/cache#cache-tags) 支持已被重新编写，以提供更好的性能和存储效率。在 Laravel 的之前的版本中，如果使用 Redis 作为应用程序的缓存驱动程序，则会在缓存中累积旧的缓存标签。\r\n\r\n\r\n然而，为了正确地删除过时的缓存标记项，Laravel 新的 `cache:prune-stale-tags` Artisan 命令应该在你的应用程序的 `App\\Console\\Kernel` 类中 [预定](/docs/laravel/10.x/scheduling)：\r\n\r\n```\r\n$schedule->command('cache:prune-stale-tags')->hourly();\r\n\r\n```\r\n\r\n### 数据库\r\n\r\n<a name=\"database-expressions\"></a>\r\n\r\n#### 数据库表达式\r\n\r\n**影响可能性：中等**\r\n\r\nLaravel 10.x 重新编写了数据库「表达式」（通常是通过 `DB::raw` 生成），以便在未来提供额外的功能。需要注意的是，语法的原始字符串值现在必须通过表达式的 `getValue(Grammar $grammar)` 方法检索。现在不再支持将表达式强制转换为字符串使用 `(string)` 。\r\n\r\n**通常，这不会影响最终用户的应用程序**；但是，如果你的应用程序正在手动将数据库表达式强制转换为字符串使用 `(string)` 或直接调用表达式的 `__toString` 方法，则应该更新你的代码以调用 `getValue` 方法：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\DB;\r\n\r\n$expression = DB::raw('select 1');\r\n\r\n$string = $expression->getValue(DB::connection()->getQueryGrammar());\r\n```\r\n\r\n<a name=\"query-exception-constructor\"></a>\r\n\r\n#### 查询异常构造函数\r\n\r\n**影响可能性：非常低**\r\n\r\n`Illuminate\\Database\\QueryException` 构造函数现在接受一个字符串连接名称作为其第一个参数。如果你的应用程序正在手动抛出此异常，则应相应调整你的代码。\r\n\r\n<a name=\"ulid-columns\"></a>\r\n\r\n#### ULID 列\r\n\r\n**影响可能性：低**\r\n\r\n当迁移调用 `ulid` 方法而没有任何参数时，列现在将被命名为 `ulid`。在 Laravel 的以前版本中，调用此方法而没有任何参数会创建一个错误命名为 `uuid` 的列：\r\n\r\n```\r\n$table->ulid();\r\n\r\n```\r\n\r\n在调用 `ulid` 方法时显式指定列名，可以将列名传递给该方法：\r\n\r\n```\r\n$table->ulid('ulid');\r\n```\r\n\r\n### Eloquent\r\n\r\n<a name=\"model-dates-property\"></a>\r\n#### 模型「Dates」属性\r\n\r\n**影响可能性：中等**\r\n\r\n已删除 Eloquent 模型中已过时属性。现在，你的应用程序应该使用`$casts` 属性：\r\n\r\n```php\r\nprotected $casts = [\r\n    'deployed_at' => 'datetime',\r\n];\r\n```\r\n\r\n<a name=\"relation-getbasequery-method\"></a>\r\n\r\n#### 关系 `getBaseQuery` 方法\r\n\r\n**影响可能性：非常低**\r\n\r\n在 `Illuminate\\Database\\Eloquent\\Relations\\Relation` 类中的 `getBaseQuery` 方法已更名为 `toBase`。\r\n\r\n### 本地化\r\n\r\n<a name=\"language-directory\"></a>\r\n\r\n#### 语言目录\r\n\r\n**影响可能性：无**\r\n\r\n虽然不涉及现有应用程序，但 Laravel 应用程序骨架不再默认包含 `lang` 目录。相反，在编写新的 Laravel 应用程序时，可以使用 `lang:publish` Artisan 命令进行发布：\r\n\r\n```shell\r\nphp artisan lang:publish\r\n```\r\n\r\n### 日志\r\n\r\n<a name=\"monolog-3\"></a>\r\n\r\n#### Monolog 3\r\n\r\n**影响可能性：中等**\r\n\r\nLaravel 的 Monolog 依赖项已更新为 Monolog 3.x。如果你正在直接与 Monolog 交互，则应该查看 Monolog 的[升级指南](https://github.com/Seldaek/monolog/blob/main/UPGRADE.)。\r\n\r\n如果你正在使用 BugSnag 或 Rollbar 等第三方日志记录服务，请确保将这些第三方包升级到支持 Monolog 3.x 和 Laravel 10.x 版本的版本。\r\n\r\n### 队列\r\n\r\n<a name=\"dispatch-now\"></a>\r\n\r\n#### `Bus::dispatchNow` 方法\r\n\r\n**影响可能性：低**\r\n\r\n已删除过时的 `Bus::dispatchNow` 和 `dispatch_now` 方法。目前你的应用程序应该分别使用 `Bus::dispatchSync` 和 `dispatch_sync` 方法。\r\n\r\n### 路由\r\n\r\n<a name=\"middleware-aliases\"></a>\r\n\r\n#### 中间件别名\r\n\r\n**影响可能性：非强制**\r\n\r\n在新的 Laravel 应用程序中，`App\\Http\\Kernel` 类的 `$routeMiddleware` 属性已更名为 `$middlewareAliases`，以更好地反映其用途。你可以在现有应用程序中重命名此属性，但不是强制的。\r\n\r\n\r\n<a name=\"rate-limiter-return-values\"></a>\r\n\r\n#### 限速器返回值\r\n\r\n**影响可能性: 低**\r\n\r\n调用 `RateLimiter::attempt` 方法时，该方法现在将返回由提供的闭包返回的值。如果没有返回任何值或返回 `null`，则 `attempt` 方法将返回 `true`：\r\n\r\n```php\r\n$value = RateLimiter::attempt('key', 10, fn () => ['example'], 1);\r\n\r\n$value; // ['example']\r\n```\r\n\r\n<a name=\"redirect-home\"></a>\r\n\r\n#### `Redirect::home` 方法\r\n\r\n**影响可能性: 非常低**\r\n\r\n已删除不推荐使用的 `Redirect::home` 方法。相反，你的应用程序应该重定向到一个明确命名的路由：\r\n\r\n```php\r\nreturn Redirect::route('home');\r\n```\r\n\r\n### 测试\r\n\r\n<a name=\"service-mocking\"></a>\r\n\r\n#### 服务模拟\r\n\r\n**影响可能性: 中等**\r\n\r\n已从框架中删除不推荐使用的 `MocksApplicationServices` 特性。该特性提供了类似于 `expectsEvents`、`expectsJobs` 和 `expectsNotifications` 这样的测试方法。\r\n\r\n如果你的应用程序使用这些方法，我们建议你过渡到 `Event::fake`、`Bus::fake` 和 `Notification::fake`。你可以通过相应组件的文档了解有关模拟的更多信息。\r\n\r\n### 验证\r\n\r\n<a name=\"closure-validation-rule-messages\"></a>\r\n\r\n#### 闭包验证规则消息\r\n\r\n**影响可能性: 非常低**\r\n\r\n当编写基于闭包的自定义验证规则时，调用 `$fail` 回调超过一次，现在会将消息附加到数组中，而不是覆盖先前的消息。通常，这不会影响你的应用程序。\r\n\r\n此外，`$fail` 回调现在返回一个对象。如果你之前对验证闭包的返回类型进行了类型提示，这可能需要你更新你的类型提示：\r\n\r\n```php\r\npublic function rules()\r\n{\r\n    'name' => [\r\n        function ($attribute, $value, $fail) {\r\n            $fail('validation.translation.key')->translate();\r\n        },\r\n    ],\r\n}\r\n```\r\n\r\n<a name=\"miscellaneous\"></a>\r\n### 其他\r\n\r\n我们还鼓励你查看 `laravel/laravel` [GitHub 存储库](https://github.com/laravel/laravel) 中的更改。虽然这些更改中许多都不是必需的，但你可能希望将这些文件与你的应用程序保持同步。本次升级指南将覆盖部分更改，但其他的更改，例如对配置文件或注释的更改，不会被覆盖。\r\n\r\n你可以使用 [GitHub 比较工具](https://github.com/laravel/laravel/compare/9.x...10.x) 轻松查看更改，并选择哪些更新对你重要。但是，GitHub 比较工具显示的许多更改都是由于我们的组织采用了 PHP 本地类型。这些更改是向后兼容的，迁移到 Laravel 10 期间采用它们是可选的。\r\n","p":"docs/upgrade.html"},{"t":"contributions (贡献指南)","d":"# 贡献指南\r\n\r\n- [Bug 报告](#bug-reports)\r\n- [帮助支持](#support-questions)\r\n- [核心发展讨论](#core-development-discussion)\r\n- [哪个分支？](#which-branch)\r\n- [编译资源](#compiled-assets)\r\n- [安全漏洞](#security-vulnerabilities)\r\n- [代码风格](#coding-style)\r\n    - [PHPDoc](#phpdoc)\r\n    - [StyleCI](#styleci)\r\n- [行为准则](#code-of-conduct)\r\n\r\n<a name=\"bug-reports\"></a>\r\n## Bug 报告\r\n\r\n为了鼓励活跃的协作，Laravel 强烈推荐拉取请求，而不仅仅是错误报告。只有标记为「准备好审查」（而不是「草稿」状态）且新功能的所有测试都通过的拉取请求才会进行审核。留在「草稿」状态中未处理的悬而未决、不活跃的拉取请求将在几天后关闭。\r\n\r\n不过，如果你提交了错误报告，你的问题应包含标题和清晰的问题描述。你还应尽可能提供相关信息和演示问题的代码示例。错误报告的目的是使自己和其他人能够轻松地复制错误并开发修复程序。\r\n\r\n请记住，错误报告的创建是希望其他拥有相同问题的人能够与你协作解决问题。不要期望错误报告会自动获得任何活动，或者其他人会迅速修复它。创建错误报告有助于你自己和其他人开始解决问题的路径。如果你想参与，可以通过修复 [我们的问题跟踪器中列出的任何错误](https://github.com/issues?q=is%3Aopen+is%3Aissue+label%3Abug+user%3Alaravel) 来帮助。你必须使用 GitHub 进行身份验证才能查看 Laravel 的所有问题。\r\n\r\n如果你在使用 Laravel 时注意到不正确的 DocBlock、PHPStan 或 IDE 警告，请不要创建 GitHub 问题。相反，请提交拉取请求以解决问题。\r\n\r\nLaravel 的源代码托管在 GitHub 上，每个 Laravel 项目都有一个仓库：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n  - [Laravel Application](https://github.com/laravel/laravel)\r\n    - [Laravel Art](https://github.com/laravel/art)\r\n    - [Laravel Documentation](https://github.com/laravel/docs)\r\n    - [Laravel Dusk](https://github.com/laravel/dusk)\r\n    - [Laravel Cashier Stripe](https://github.com/laravel/cashier)\r\n    - [Laravel Cashier Paddle](https://github.com/laravel/cashier-paddle)\r\n    - [Laravel Echo](https://github.com/laravel/echo)\r\n    - [Laravel Envoy](https://github.com/laravel/envoy)\r\n    - [Laravel Framework](https://github.com/laravel/framework)\r\n    - [Laravel Homestead](https://github.com/laravel/homestead)\r\n    - [Laravel Homestead Build Scripts](https://github.com/laravel/settler)\r\n    - [Laravel Horizon](https://github.com/laravel/horizon)\r\n    - [Laravel Jetstream](https://github.com/laravel/jetstream)\r\n    - [Laravel Passport](https://github.com/laravel/passport)\r\n    - [Laravel Pennant](https://github.com/laravel/pennant)\r\n    - [Laravel Pint](https://github.com/laravel/pint)\r\n    - [Laravel Sail](https://github.com/laravel/sail)\r\n    - [Laravel Sanctum](https://github.com/laravel/sanctum)\r\n    - [Laravel Scout](https://github.com/laravel/scout)\r\n    - [Laravel Socialite](https://github.com/laravel/socialite)\r\n    - [Laravel Telescope](https://github.com/laravel/telescope)\r\n    - [Laravel Website](https://github.com/laravel/laravel.com-next)\r\n\r\n</div>\r\n\r\n<a name=\"support-questions\"></a>\r\n## 帮助支持\r\n\r\nLaravel 的 GitHub 问题跟踪器不适用于提供 Laravel 帮助或支持。请使用以下渠道之一：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n  - [GitHub 讨论](https://github.com/laravel/framework/discussions)\r\n    - [Laracasts 论坛](https://laracasts.com/discuss)\r\n    - [Laravel.io 论坛](https://laravel.io/forum)\r\n    - [StackOverflow](https://stackoverflow.com/questions/tagged/laravel)\r\n    - [Discord](https://discord.gg/laravel)\r\n    - [Larachat](https://larachat.co)\r\n    - [IRC](https://web.libera.chat/?nick=artisan&channels=#laravel)\r\n\r\n</div>\r\n\r\n<a name=\"core-development-discussion\"></a>\r\n## 核心发展讨论\r\n\r\n可以在 Laravel 框架存储库的 [GitHub discussion board](https://github.com/laravel/framework/discussions) 。中提出新功能或改进现有 Laravel 行为。如果提出了新功能，请愿意实现至少一些完成该功能所需的代码。\r\n\r\n关于错误、新功能和现有功能的实现的非正式讨论在 [Laravel Discord server](https://discord.gg/laravel) 的 #internals 频道进行。Laravel 的维护者 Taylor Otwell 通常在周一至周五上午8点至下午5点（UTC-06:00或美国/芝加哥）在频道中出现，并在其他时间不定期出现。\r\n\r\n<a name=\"which-branch\"></a>\r\n## 哪个分支？\r\n\r\n**所有的** Bug 修复应该发送到支持 Bug 修复的最新版本（目前是 `10.x`）。Bug 修复不应该发送到主分支，除非它们仅修复即将发布的版本中存在的功能。\r\n\r\n完全向后兼容当前版本的小型功能可以发送到最新的稳定分支（目前是 `10.x`）。\r\n\r\n具有重大新特性或破坏性更改的功能应该始终发送到主分支，该分支包含即将发布的版本。\r\n\r\n<a name=\"compiled-assets\"></a>\r\n## 编译资源\r\n\r\n如果你正在提交将影响编译文件的更改，例如 laravel/laravel 存储库中的 resources/css 或 resources/js 中的大多数文件，请不要提交编译文件。由于它们的尺寸较大，维护者无法实际审核它们。这可以被利用作为将恶意代码注入 Laravel 的方法。为了防御性地防止这种情况，所有编译文件将由 Laravel 维护者生成和提交。\r\n\r\n<a name=\"security-vulnerabilities\"></a>\r\n## 安全漏洞\r\n\r\n如果你在 Laravel 中发现安全漏洞，请发送电子邮件至 Taylor Otwell <a href=\"mailto:taylor@laravel.com\">taylor@laravel.com</a> 。所有安全漏洞将得到及时处理。\r\n\r\n<a name=\"coding-style\"></a>\r\n## 代码风格\r\n\r\nLaravel 遵循 [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.) 编码标准和 [PSR-4](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.) 自动加载标准。\r\n\r\n<a name=\"phpdoc\"></a>\r\n### PHPDoc\r\n\r\n是一种在 PHP 代码中使用文档块注释的方式，它可以让开发者快速了解代码中的类、方法、属性等信息。下面是一个有效的 Laravel 文档块注释的示例。注意，`@param` 属性后面跟着两个空格、参数类型、两个空格，最后是变量名：\r\n\r\n    /**\r\n    * 容器注册与绑定\r\n    *\r\n    * @param  string|array  $abstract\r\n    * @param  \\Closure|string|null  $concrete\r\n    * @param  bool  $shared\r\n    * @return void\r\n    *\r\n    * @throws \\Exception\r\n    */\r\n    public function bind($abstract, $concrete = null, $shared = false)\r\n    {\r\n        // ...\r\n    }\r\n\r\n如果使用了 PHP 本地类型，则可以删除 @param 或 @return 属性：\r\n\r\n    /**\r\n    * 执行任务\r\n    */\r\n    public function handle(AudioProcessor $processor): void\r\n    {\r\n        //...\r\n    }\r\n\r\n当使用的本地类型是泛型时，请通过使用 @param 或 @return 属性指定泛型类型：\r\n\r\n    /**\r\n    *  获取消息.\r\n    *\r\n    * @return array<int, \\Illuminate\\Mail\\Mailables\\Attachment>\r\n    */\r\n    public function attachments(): array\r\n    {\r\n        return [\r\n            Attachment::fromStorage('/path/to/file'),\r\n        ];\r\n    }\r\n\r\n<a name=\"styleci\"></a>\r\n### StyleCI\r\n\r\n别担心你的代码风格, [StyleCI](https://styleci.io/) 是一个自动化的代码风格工具，它会在拉取请求合并后自动合并代码格式修复。这样我们就可以将重点放在贡献内容上，而不是代码风格上。\r\n\r\n<a name=\"code-of-conduct\"></a>\r\n## 行为准则\r\n\r\nLaravel 的行为准则源自于 Ruby 的行为准则。如果违反了行为准则，可以向 Taylor Otwell（taylor@laravel.com）报告：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- 参与者应尊重不同的观点。\r\n- 参与者必须确保他们的语言和行为没有人身攻击和贬低个人言论。\r\n- 在解释他人的言行时，参与者应始终保持良好的意图。\r\n- 不能容忍可合理视为骚扰的行为。\r\n\r\n</div>","p":"docs/contributions.html"},{"t":"installation (安装)","d":"# 安装\r\n\r\n- [认识 Laravel](#meet-laravel)\r\n   - [为什么选择 Laravel?](#why-laravel)\r\n- [你的第一个 Laravel 项目](#your-first-laravel-project)\r\n- [Laravel & Docker](#laravel-and-docker)\r\n   - [macOS 入门](#getting-started-on-macos)\r\n   - [Windows 入门](#getting-started-on-windows)\r\n   - [Linux 入门](#getting-started-on-linux)\r\n   - [选择 Sail 服务](#choosing-your-sail-services)\r\n- [初始化](#initial-configuration)\r\n   - [基于环境的配置](#environment-based-configuration)\r\n   - [目录配置](#databases-and-migrations)\r\n- [下一步](#next-steps)\r\n   - [将 Laravel 用作全栈框架](#laravel-the-fullstack-framework)\r\n   - [将 Laravel 用作 API 后端](#laravel-the-api-backend)\r\n\r\n<a name=\"meet-laravel\"></a>\r\n## 认识 Laravel\r\nLaravel 是一个 Web 应用框架， 有着表现力强、语法优雅的特点。Web 框架为创建应用提供了一个结构和起点，你只需要专注于创造，我们来为你处理细节。\r\n\r\nLaravel 致力于提供出色的开发体验，同时提供强大的特性，例如完全的依赖注入，富有表现力的数据库抽象层，队列和计划任务，单元和集成测试等等。\r\n\r\n无论你是刚刚接触 PHP 和 Web 框架的新人，亦或是有着多年经验的老手， Laravel 都是一个可以与你一同成长的框架。我们将帮助你迈出成为 Web 开发者的第一步，或是将你的经验提高到下一个等级。我们迫不及待的想看看你的作品。\r\n\r\n<a name=\"why-laravel\"></a>\r\n### 为什么选择 Laravel?\r\n\r\n有非常多的工具和框架可以被用于构建一个 Web 应用。但我们相信 Laravel 是构建现代化、全栈 Web 应用的最佳选择。\r\n\r\n#### 一个渐进式框架\r\n\r\n我们喜欢称 Laravel 是一个「渐进式」框架。意思是 Laravel 将与你一同成长。如果你是首次进入 Web 开发， Laravel 大量的文档、指南和 [视频教程](https://laracasts.com) 将帮助你熟悉使用技巧而不至于不知所措。\r\n\r\n如果你是高级开发人员, Laravel 为你提供了强大的工具用于 [依赖注入](/docs/laravel/10.x/container)、 [单元测试](/docs/laravel/10.x/testing)、 [队列](/docs/laravel/10.x/queues)、 [广播系统](/docs/laravel/10.x/broadcasting) 等等。 Laravel 为构建专业的 Web 应用程序进行了微调，并准备好处理企业工作负载。\r\n\r\n#### 一个可扩展的框架\r\n\r\nLaravel 具有难以置信的可扩展性。由于 PHP 的灵活性以及 Laravel 对 Redis 等快速分布式缓存系统的内置支持，使用 Laravel 进行扩展是轻而易举的事。事实上，Laravel 应用程序已经很容易扩展到每月处理数亿个请求。\r\n\r\n需要节省开发费用吗？ [Laravel Vapor](https://vapor.laravel.com) 允许你在 AWS 最新的无服务器技术上以几乎无限的规模运行 Laravel 应用程序。\r\n\r\n#### 一个社区化的框架\r\n\r\nLaravel 结合了 PHP 生态系统中最好的软件包，提供了最健壮、对开发人员友好的框架。此外，来自世界各地的数千名有才华的开发人员 [为框架做出了贡献](https://github.com/laravel/framework) 。谁知道呢，也许你就是下一个 Laravel 的贡献者。\r\n\r\n## 你的第一个 Laravel 项目\r\n\r\n在创建你的第一个Laravel项目之前, 你应该确保你的本地机器上已经安装了 PHP 和 [Composer](https://getcomposer.org) 。 如果你是在 macOS 上开发， PHP 和 Composer 可以通过 [Homebrew](https://brew.sh/) 来安装。 此外, 我们建议你 [安装 Node 和 NPM](https://nodejs.org)。\r\n\r\n安装 PHP 和 Composer 后，你可以通过`create-project`命令创建一个新的 Laravel 项目：\r\n\r\n```nothing\r\ncomposer create-project laravel/laravel example-app\r\n```\r\n\r\n或者，你可以通过 Laravel 安装器作为全局 Composer 依赖：\r\n\r\n```nothing\r\ncomposer global require laravel/installer\r\n\r\nlaravel new example-app\r\n```\r\n\r\n当应用程序创建完成后，你可以通过 Artisan CLI 的`serve`命令来启动 Laravel 的本地服务：\r\n\r\n```nothing\r\ncd example-app\r\n\r\nphp artisan serve\r\n```\r\n\r\n启动 Artisan 开发服务器后，你便可在 Web 浏览器中通过`http://localhost:8000`访问。 接下来，[你已经准备好开始进入 Laravel 生态系统的下一步](#next-steps)。 当然， 你也可能需要 [配置数据库](#databases-and-migrations)。\r\n\r\n> **技巧**\r\n> 如果你想在开发Laravel应用程序时领先一步， 可以考虑使用我们的 [入门套件](/docs/laravel/10.x/starter-kits)。 Laravel 的入门套件为你的新 Laravel 应用程序提供后端和前端身份验证脚手架。\r\n\r\n<a name=\"laravel-and-docker\"></a>\r\n## Laravel & Docker\r\n\r\n我们希望尽可能轻松地开始使用 Laravel，无论你喜欢哪种操作系统。因此，在本地计算机上开发和运行 Laravel 项目有多种选择。虽然你可能希望稍后探索这些选项，但 Laravel 提供了 [Sail](/docs/laravel/10.x/sail)，这是一个使用 [Docker](https://www.docker.com) 运行 Laravel 项目的内置解决方案。\r\n\r\nDocker 是一种在小型、轻量级「容器」中运行应用程序和服务的工具，不会干扰本地机器上已安装的软件或配置。这意味着你不必担心在本地机器上配置或设置复杂的开发工具，如 Web 服务器和数据库。要开始，你只需要安装 [Docker Desktop](https://www.docker.com/products/docker-desktop).\r\n\r\nLaravel Sail 是一个轻量级的命令行界面，用于与 Laravel 的默认 Docker 配置进行交互。Sail 为使用 PHP、MySQL 和 Redis 构建 Laravel 应用程序提供了一个很好的起点，而无需之前的 Docker 经验。\r\n\r\n> **技巧**\r\n> 已经是 Docker 专家？别担心！关于 Sail 的一切都可以使用 Laravel 附带的文件 `docker-compose.yml` 进行自定义。\r\n\r\n<a name=\"getting-started-on-macos\"></a>\r\n### macOS 入门\r\n\r\n如果你在 Mac 上开发并且已经安装了 [Docker Desktop](https://www.docker.com/products/docker-desktop)，你可以使用一个简单的终端命令来创建一个新的 Laravel 项目。 例如，要在名为「example-app」的目录中创建一个新的 Laravel 应用程序，你可以在终端中运行以下命令：\r\n\r\n```shell\r\ncurl -s \"https://laravel.build/example-app\" | bash\r\n```\r\n\r\n当然，你可以将此 URL 中的「example-app」更改为你喜欢的任何内容。Laravel 应用程序的目录将在你执行命令的目录中创建。\r\n\r\n创建项目后，你可以导航到应用程序目录并启动 Laravel Sail。Laravel Sail 提供了一个简单的命令行界面，用于与 Laravel 的默认 Docker 配置进行交互：\r\n\r\n```shell\r\ncd example-app\r\n\r\n./vendor/bin/sail up\r\n```\r\n\r\n第一次运行 Sail `up` 命令时， Sail 的应用程序容器将在你的机器上构建。这可能需要几分钟。 **不用担心，随后尝试启动 Sail 会快得多。**\r\n\r\n启动应用程序的 Docker 容器后，你可以在 Web 浏览器中访问应用程序： http://localhost 。\r\n\r\n> **技巧**\r\n> 要继续了解有关 Laravel Sail 的更多信息，请查看其 [完整文档](/docs/laravel/10.x/sail)。\r\n\r\n<a name=\"getting-started-on-windows\"></a>\r\n### Windows 入门\r\n\r\n在创建 Laravel 应用前，请确保你的 Windows 电脑已经安装了 [Docker Desktop](https://www.docker.com/products/docker-desktop)。请确保已经安装并启用了适用于 Linux 的 Windows 子系统 2（WSL2），WSL 允许你在 Windows10 上运行 Linux 二进制文件。关于如何安装并启用 WSL2，请参阅微软 [开发者环境文档](https://docs.microsoft.com/en-us/windows/wsl/install-win10)\r\n\r\n> **技巧**\r\n> 安装并启用 WSL2 后，请确保 Docker Desktop 已经 [配置为使用 WSL2 后端](https://docs.docker.com/docker-for-windows/wsl/).\r\n\r\n接下来，准备创建你的第一个 Laravel 项目，启动 Windows Terminal，为 WSL2 Linux 操作系统打开一个终端。之后，你可以使用简单的命令来新建 Laravel 项目。比如，想要在「example-app」文件夹中新建 Laravel 应用，可以在终端中运行以下命令：\r\n\r\n```shell\r\ncurl -s https://laravel.build/example-app | bash\r\n```\r\n\r\n当然，你可以将此 URL 中的「example-app」更改为你喜欢的任何内容，只需确保应用程序名称仅包含字母数字字符、破折号和下划线 Laravel 应用程序的目录将在你执行命令的目录中创建。\r\n\r\nSail 安装可能需要几分钟时间，因为 Sail 的应用程序容器是在你的本地计算机上构建的。\r\n\r\n创建项目后，你可以导航到应用程序目录并启动 Laravel Sail。 Laravel Sail 提供了一个简单的命令行界面来与 Laravel 的默认 Docker 配置进行交互：\r\n\r\n```shell\r\ncd example-app\r\n\r\n./vendor/bin/sail up\r\n```\r\n\r\n一旦应用的 Docker 容器启动了，你便可在 Web 浏览器中通过 localhost 访问你的应用了。\r\n\r\n> **技巧**\r\n> 要继续学习更多关于 Laravel Sail 的知识，请参阅 [详细文档](/docs/laravel/10.x/sail).\r\n\r\n#### 使用 WSL2 进行开发\r\n\r\n当然，你需要能够修改在 WSL2 安装中创建的 Laravel 应用程序文件。我们推荐你使用微软的 [Visual Studio Code](https://code.visualstudio.com) 编辑器并搭配其 [Remote Development](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack) 扩展，它们可以帮助你解决这个问题。\r\n\r\n一旦这些工具成功安装，你可以使用 Windows Terminal 在应用根目录执行 `code .` 命令来打开任何 Laravel 项目。\r\n\r\n<a name=\"getting-started-on-linux\"></a>\r\n### 在 Linux 使用 Laravel Sail\r\n\r\n如果在 Linux 开发，并且已经安装了 [Docker Compose](https://docs.docker.com/compose/install/) 你可以使用简单的终端命令来创建一个新的 Laravel 项目。例如，要在「example-app」目录中创建新的 Laravel 应用，你可以在终端中运行如下命令：\r\n\r\n```shell\r\ncurl -s https://laravel.build/example-app | bash\r\n```\r\n\r\n当然，你可以将 URL 中的「example-app」替换为任何你喜欢的内容。Laravel 应用程序的目录将在执行命令的目录中创建。\r\n\r\n在项目创建完成后，你可以导航至应用目录和启动 Laravel Sail。Laravel Sail 提供了一个简单的命令行接口，用于与 Laravel 的默认 Docker 配置进行交互：\r\n\r\n```shell\r\ncd example-app\r\n\r\n./vendor/bin/sail up\r\n```\r\n在你首次运行 Sail 的 `up` 命令的时候，Sail 的应用容器将会在你的机器上进行编译。这个过程将会花费一段时间。**不要担心，以后就会很快了。**\r\n\r\n一旦应用的 Docker 容器启动了，你便可在 Web 浏览器中通过 http://localhost 访问你的应用了。\r\n\r\n> **技巧**\r\n> 要继续学习更多关于 Laravel Sail 的知识，请参阅 [ 详细文档](/docs/laravel/10.x/sail)。\r\n\r\n<a name=\"choosing-your-sail-services\"></a>\r\n### 选择 Sail 服务\r\n\r\n通过 Sail 创建 Laravel 程序时，可以使用 `with` 查询字符串变量来选择程序的 `docker-compose.yml` 文件配置哪些服务。可用的服务包括 `mysql`, `pgsql`, `mariadb`, `redis`, `memcached`, `meilisearch`, `minio`, `selenium`, 和 `mailpit`:\r\n\r\n```shell\r\ncurl -s \"https://laravel.build/example-app?with=mysql,redis\" | bash\r\n```\r\n\r\n如果不指定配置服务，将使用 `mysql`, `redis`, `meilisearch`, `mailpit`, 和 `selenium` 作为默认配置。\r\n\r\n还可以通过 `devcontainer`参数添加到 URL 来安装默认的 [Devcontainer](/docs/laravel/10.x/sailmd#using-devcontainers):\r\n\r\n```shell\r\ncurl -s \"https://laravel.build/example-app?with=mysql,redis&devcontainer\" | bash\r\n```\r\n\r\n<a name=\"initial-configuration\"></a>\r\n## 安装配置\r\n\r\nLaravel 框架将所有的配置文件都放在 `config` 目录中。每个选项都有一个文件，因此可以浏览文件并熟悉可用的选项。\r\n\r\nLaravel 开箱可用，不需要额外配置，你可以自由的开发！然而，你可能希望查看 `config/app.php` 文件及其文档。它包含几个选项，例如你可能希望根据程序更改 `timezone` 和 `locale`。\r\n\r\n<a name=\"environment-based-configuration\"></a>\r\n### 环境配置\r\n\r\nLaravel 的许多配置选项值可能会根据运行的环境有所不同，因此许多重要的配置选项值是在 `.env` 文件中定义的。\r\n\r\n你的 `.env` 文件不应该提交到应用程序的源代码控制中，因为使用你的应用程序的每个开发者/服务器可能需要不同的环境配置。此外，如果入侵者访问了你的源代码仓库，这将成为安全风险，因为任何敏感数据都会被公开。\r\n\r\n> **注意**\r\n> 若要了解更多关于 `.env` 文件和基于环境的配置的信息，请查看完整的 [配置文档](/docs/laravel/10.x/configurationmd#environment-configuration)。\r\n\r\n<a name=\"databases-and-migrations\"></a>\r\n### 数据库和迁移\r\n\r\n现在，你已经创建了 Laravel 应用程序，可能想在数据库中存储一些数据。默认情况下，你的应用程序的 `.env` 配置文件指定 Laravel 将与 MySQL 数据库交互，并访问 `127.0.0.1` 中的数据库。如果你在 macOS 上开发并需要在本地安装 MySQL、Postgres 或 Redis，则可能会发现使用 [DBngin](https://dbngin.com/) 非常方便。\r\n\r\n如果你不想在本地机器上安装 MySQL 或 Postgres，你总可以使用 [SQLite](https://www.sqlite.org/index.html) 数据库。SQLite 是一个小型、快速、自包含的数据库引擎。要开始使用，只需创建一个空的 SQLite 文件来创建 SQLite 数据库。通常，这个文件将存在于 Laravel 应用程序的 `database` 目录中：\r\n\r\n```shell\r\ntouch database/database.sqlite\r\n```\r\n\r\n接下来，更新你的 `.env` 配置文件以使用 Laravel 的 `sqlite` 数据库驱动程序。你可以删除其他数据库配置选项：\r\n\r\n```ini\r\nDB_CONNECTION=sqlite # [tl! add]\r\nDB_CONNECTION=mysql # [tl! remove]\r\nDB_HOST=127.0.0.1 # [tl! remove]\r\nDB_PORT=3306 # [tl! remove]\r\nDB_DATABASE=laravel # [tl! remove]\r\nDB_USERNAME=root # [tl! remove]\r\nDB_PASSWORD= # [tl! remove]\r\n```\r\n\r\n一旦你配置了 SQLite 数据库，你可以运行你的应用程序的 [数据库迁移](/docs/laravel/10.x/migrations)，这将创建你的应用程序的数据库表：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"next-steps\"></a>\r\n## 下一步\r\n\r\n现在你已经创建了你的 Laravel 项目，你可能在想下一步该学什么。首先，我们强烈建议通过阅读以下文档来了解 Laravel 的工作方式：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n  -   [请求生命周期](/docs/laravel/10.x/lifecycle)\r\n    -   [配置](/docs/laravel/10.x/configuration)\r\n    -   [目录结构](/docs/laravel/10.x/structure)\r\n    -   [前端](/docs/laravel/10.x/frontend)\r\n    -   [服务容器](/docs/laravel/10.x/container)\r\n    -   [门面](/docs/laravel/10.x/facades)\r\n\r\n</div>\r\n\r\n你如何使用 Laravel 也会决定你的下一步。Laravel 有多种使用方式，下面我们将探索框架的两个主要用例。\r\n\r\n> **注意**\r\n> 是第一次使用 Laravel 吗？请查看 [Laravel Bootcamp](https://bootcamp.laravel.com) 可让你实际操作 Laravel 框架并带你构建第一个 Laravel 应用程序。\r\n\r\n<a name=\"laravel-the-fullstack-framework\"></a>\r\n### Laravel 全栈框架\r\n\r\nLaravel 可以作为一个全栈框架。全栈框架意味着你将使用 Laravel 将请求路由到你的应用程序，并通过 [Blade 模板](/docs/laravel/10.x/blade) 或像 [Inertia](https://inertiajs.com) 这样的单页应用混合技术来渲染你的前端。这是使用 Laravel 框架最常见的方式，在我们看来，这也是使用 Laravel 最高效的方式。\r\n\r\n如果你打算使用 Laravel 进行全栈开发，你可能想查看我们的 [前端开发文档](/docs/laravel/10.x/frontend)、[路由文档](/docs/laravel/10.x/routing)、[视图文档](/docs/laravel/10.x/views) 或 [Eloquent ORM](/docs/laravel/10.x/eloquent)。此外，你可能会对学习像 [Livewire](https://laravel-livewire.com) 和 [Inertia](https://inertiajs.com) 这样的社区包感兴趣。这些包允许你将 Laravel 用作全栈框架，同时享受单页 JavaScript 应用程序提供的许多 UI 好处。\r\n\r\n如果你使用 Laravel 作为全栈框架，我们也强烈建议你学习如何使用 [Vite](/docs/laravel/10.x/vite) 编译应用程序的 CSS 和 JavaScript 。\r\n\r\n> 技巧：如果你想尽快构建你的应用程序，请查看我们的官方 [应用程序入门工具包](/docs/laravel/10.x/starter-kits)。\r\n\r\n<a name=\"laravel-the-api-backend\"></a>\r\n### Laravel API 后端\r\n\r\nLaravel 也可以作为 JavaScript 单页应用程序或移动应用程序的 API 后端。例如，你可以使用 Laravel 作为 [Next.js](https://nextjs.org) 应用程序的 API 后端。在这种情况下，你可以使用 Laravel 为你的应用程序提供 [身份验证](/docs/laravel/10.x/sanctum) 和数据存储/检索，同时还可以利用 Laravel 的强大服务，例如队列、电子邮件、通知等。\r\n\r\n如果这是你计划使用 Laravel 的方式，你可能需要查看我们关于 [路由](/docs/laravel/10.x/routing)，[Laravel Sanctum](/docs/laravel/10.x/sanctum) 和 [Eloquent ORM](/docs/laravel/10.x/eloquent) 的文档。\r\n\r\n> 技巧：需要抢先搭建 Laravel 后端和 Next.js 前端的脚手架？Laravel Breeze 提供了 [API 堆栈](/docs/laravel/10.x/starter-kitsmd#breeze-and-next) 以及 [Next.js 前端实现](https://github.com/laravel/breeze-next) ，因此你可以在几分钟内开始使用。","p":"docs/installation.html"},{"t":"configuration (配置信息)","d":"# 配置信息\r\n\r\n- [介绍](#introduction)\r\n- [环境配置](#environment-configuration)\r\n    - [环境变量类型](#environment-variable-types)\r\n    - [检索环境配置](#retrieving-environment-configuration)\r\n    - [确定当前环境](#determining-the-current-environment)\r\n    - [环境文件加密](#encrypting-environment-files)\r\n- [访问配置值](#accessing-configuration-values)\r\n- [缓存配置](#configuration-caching)\r\n- [调试模式](#debug-mode)\r\n- [维护模式](#maintenance-mode)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 框架的所有配置文件都存储在 config 目录中。每个选项都有文档记录，因此请随意查看文件并熟悉可用的选项。\r\n\r\n这些配置文件允许你配置诸如数据库连接信息、邮件服务器信息以及各种其他核心配置值（例如应用程序时区和加密密钥）之类的事项。\r\n\r\n<a name=\"application-overview\"></a>\r\n#### 应用概述\r\n\r\n为了方便你可以通过 about Artisan 命令快速了解应用程序的配置、驱动程序和环境：\r\n\r\n```shell\r\nphp artisan about\r\n```\r\n\r\n如果只对应用程序概述输出的特定部分感兴趣，则可以使用 --only 选项过滤该部分：\r\n\r\n```shell\r\nphp artisan about --only=environment\r\n```\r\n\r\n<a name=\"environment-configuration\"></a>\r\n## 环境配置\r\n\r\n根据应用程序运行的环境设置不同的配置值通常很有方便。例如，可能希望在本地使用不同的缓存驱动程序，而在生产服务器上则使用另一个。\r\n\r\n为了让这变得方便，Laravel 使用了 [DotEnv](https://github.com/vlucas/phpdotenv)库 在全新的 Laravel 安装中，应用程序的根目录将包含一个 .env.example 文件，其中定义了许多常见的环境变量。在 Laravel 安装过程中，此文件将自动复制到 .env。\r\n\r\nLaravel 的默认 .env 文件包含一些常见的配置值，这些值可能会根据你的应用程序是在本地运行还是在生产 Web 服务器上运行而有所不同。 然后使用 Laravel 的 env 函数从 config 目录中的各种 Laravel 配置文件中检索这些值。\r\n\r\n如果你正在与团队一起开发，你可能希望继续在你的应用程序中包含一个 .env.example 文件。 通过将占位符值放入示例配置文件中，你团队中的其他开发人员可以清楚地看到运行你的应用程序需要哪些环境变量。\r\n\r\n> **技巧**\r\n> `.env`文件中的任何变量都可以被外部环境变量覆盖，例如服务器级或系统级环境变量。\r\n\r\n<a name=\"environment-file-security\"></a>\r\n#### 环境文件安全\r\n\r\n你的`.env`文件不应该提交到版本管理器中，首先，使用应用程序的每个开发人员 / 服务器可能需要不同的环境配置。其次，如果入侵者获得了对版本管理器的访问权限，这将成为一个安全风险，他将能看到配置文件中的敏感数据。\r\n\r\n但是，可以使用 Laravel 的内置 [加密环境](#encrypting-environment-files)。加密环境文件可以安全地放置在源代码管理中。\r\n\r\n<a name=\"additional-environment-files\"></a>\r\n#### 附加环境文件\r\n\r\n在加载应用程序的环境变量之前，Laravel 会确定是否已经从外部提供了`APP_ENV`环境变量，或者是否指定了`--env`CLI 参数。如果是这样，Laravel 将尝试加载一个`.env.[APP_ENV]`文件（如果它存在）。 如果它不存在，将加载默认的`.env`文件。\r\n\r\n<a name=\"environment-variable-types\"></a>\r\n### 环境变量类型\r\n\r\n`.env`文件中的所有变量通常都被解析为字符串，因此创建了一些保留值以允许你从`env()`函数返回更广泛的类型：\r\n\r\n| `.env` Value | `env()` Value |\r\n|--------------|---------------|\r\n| true         | (bool) true   |\r\n| (true)       | (bool) true   |\r\n| false        | (bool) false  |\r\n| (false)      | (bool) false  |\r\n| empty        | (string) ''   |\r\n| (empty)      | (string) ''   |\r\n| null         | (null) null   |\r\n| (null)       | (null) null   |\r\n\r\n如果你需要使用包含空格的值定义环境变量，可以通过将值括在双引号中来实现：\r\n\r\n```ini\r\nAPP_NAME=\"My Application\"\r\n```\r\n\r\n<a name=\"retrieving-environment-configuration\"></a>\r\n### 获取环境配置\r\n\r\n当应用程序收到请求时`.env`文件中列出的所有变量将被加载到 PHP 的超级全局变量`$_ENV`中。你可以使用`env`函数检索这些变量的值。实际上，如果你看过 Laravel 的配置文件，就能注意到有数个选项已经使用了这个函数：\r\n\r\n    'debug' => env('APP_DEBUG', false),\r\n\r\n`env`函数的第二个参数是「默认值」。 当没有找到对应环境变量时将返回 「默认值」。\r\n\r\n<a name=\"determining-the-current-environment\"></a>\r\n### 获取当前环境配置\r\n\r\n当前应用的环境配置是从你的`.env`文件中的`APP_ENV`变量配置的。你可以通过`App` [facade](/docs/laravel/10.x/facades) 的`environment`函数获取：\r\n\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $environment = App::environment();\r\n\r\n你还可以将参数传递给`environment` 函数，以确定当前环境是否匹配给定的值。当环境匹配给参数它将返回`true`\r\n\r\n    if (App::environment('local')) {\r\n        // 当前环境是 local\r\n    }\r\n\r\n    if (App::environment(['local', 'staging'])) {\r\n        // 当前环境是 local 或 staging ...\r\n    }\r\n\r\n> **技巧**\r\n> 当前应用程序的环境检测，可以通过定义服务器级`APP_ENV`环境变量来覆盖。\r\n\r\n<a name=\"encrypting-environment-files\"></a>\r\n### 环境文件加密\r\n\r\n未加密的环境文件不应该被存储在源码控制中. 然而, Laravel允许你加密你的环境文件, 这样他们就可以安全地与你的应用程序的其他部分一起被添加到源码控制中.\r\n\r\n<a name=\"encryption\"></a>\r\n#### 加密\r\n\r\n为了加密环境文件，你可以使用`env:encrypt`命令。\r\n\r\n```shell\r\nphp artisan env:encrypt\r\n```\r\n\r\n运行`env:encrypt`命令将加密你的`.env`文件，并将加密的内容放在`.env.encrypted`文件中。解密密钥将出现在命令的输出中，并应存储在一个安全的密码管理器中。如果你想提供你自己的加密密钥，你可以在调用该命令时使用`--key`选项:\r\n\r\n```shell\r\nphp artisan env:encrypt --key=3UVsEgGVK36XN82KKeyLFMhvosbZN1aF\r\n```\r\n\r\n> **注意**  \r\n> 所提供的密钥的长度应该与所使用的加密密码所要求的密钥长度相匹配. 默认情况下, Laravel会使用`AES-256-CBC`密码, 需要一个32个字符的密钥. 你可以自由地使用Laravel的 [encrypter](/docs/laravel/10.x/encryption) 所支持的任何密码，只要在调用该命令时传递`--cipher`选项即可。\r\n\r\n如果你的应用程序有多个环境文件，如`.env`和`.env.staging`，你可以通过`--env`选项提供环境名称来指定应该被加密的环境文件:\r\n\r\n```shell\r\nphp artisan env:encrypt --env=staging\r\n```\r\n\r\n<a name=\"decryption\"></a>\r\n#### 解密\r\n\r\n要解密一个环境文件, 你可以使用`env:decrypt`命令. 这个命令需要一个解密密钥, Laravel会从`LARAVEL_ENV_ENCRYPTION_KEY`环境变量中获取.:\r\n\r\n```shell\r\nphp artisan env:decrypt\r\n```\r\n\r\n或者，密钥也可以通过 --key 选项直接提供给命令：\r\n\r\n```shell\r\nphp artisan env:decrypt --key=3UVsEgGVK36XN82KKeyLFMhvosbZN1aF\r\n```\r\n\r\n当执行 `env:decrypt` 命令时，Laravel 将解密 \t`.env.encrypted` 文件的内容，并将解密后的内容放置在 `.env` 文件中。\r\n\r\n可以通过 `--cipher` 选项提供自定义加密算法的名称给 `env:decrypt` 命令：\r\n\r\n```shell\r\nphp artisan env:decrypt --key=qUWuNRdfuImXcKxZ --cipher=AES-128-CBC\r\n```\r\n\r\n如果你的应用程序有多个环境文件，例如 `.env` 和 \t`.env.staging`，可以通过 `--env` 选项提供环境名称来指定应该解密的环境文件：\r\n\r\n```shell\r\nphp artisan env:decrypt --env=staging\r\n```\r\n\r\n为了覆盖现有的环境文件，可以在 `env:decrypt` 命令中提供 `--force` 选项：\r\n\r\n```shell\r\nphp artisan env:decrypt --force\r\n```\r\n\r\n<a name=\"accessing-configuration-values\"></a>\r\n## 访问配置值\r\n\r\n你可以在应用程序的任何地方使用全局 `config` 函数轻松访问你的配置值。可以使用 \"点\" 语法来访问配置值，其中包括你希望访问的文件和选项的名称。如果配置选项不存在，则可以指定默认值，如果不存在则返回默认值：\r\n\r\n    $value = config('app.timezone');\r\n\r\n    // 如果配置值不存在，则检索默认值...\r\n    $value = config('app.timezone', 'Asia/Seoul');\r\n\r\n要在运行时设置配置值，请将数组传递给 `config` 函数：\r\n\r\n    config(['app.timezone' => 'America/Chicago']);\r\n\r\n<a name=\"configuration-caching\"></a>\r\n## 配置缓存\r\n\r\n为了提高应用程序的速度，你应该使用 `config:cache` Artisan 命令将所有配置文件缓存到一个文件中。 这会将应用程序的所有配置选项组合到一个文件中，框架可以快速加载该文件。\r\n\r\n你通常应该在生产部署过程中运行`php artisan config:cache` 命令。 该命令不应在本地开发期间运行，因为在应用程序开发过程中经常需要更改配置选项。\r\n\r\n一旦配置被缓存，应用程序的。`.env`文件将不会在请求或 Artisan 命令期间被框架加载；因此， `env`函数将只返回外部的系统级环境变量。\r\n\r\n因此，应确保仅从应用程序的配置`config`文件中调用`env`函数。通过检查 Laravel 的默认配置文件，你可以看到许多示例。可以使用`config`函数从应用程序中的任何位置访问配置值 [如上所述](#accessing-configuration-values)。\r\n\r\n> **注意**\r\n> 如果你在部署过程中执行`config:cache`命令，则应确保仅从配置文件中调用`env`函数。一旦配置被缓存，`.env`文件将不会被加载；因此，`env`函数只会返回外部的系统级环境变量。\r\n\r\n<a name=\"debug-mode\"></a>\r\n## 调试模式\r\n\r\n`config/app.php`配置文件中的`debug`选项决定了实际向用户显示的错误信息量。 默认情况下，此选项设置为尊重`APP_DEBUG`环境变量的值，该变量存储在你的`.env`文件中。\r\n\r\n对于本地开发，你应该将`APP_DEBUG`环境变量设置为`true`。 **I在你的生产环境中，此值应始终为`false`。 如果在生产环境中将该变量设置为`true` ，你可能会将敏感的配置值暴露给应用程序的最终用户。**\r\n\r\n<a name=\"maintenance-mode\"></a>\r\n## 维护模式\r\n\r\n当你的应用程序处于维护模式时，将为你的应用程序的所有请求显示一个自定义视图。 这使得在更新或执行维护时可以轻松「禁用」你的应用程序。 维护模式检查包含在应用程序的默认中间件堆栈中。 如果应用程序处于维护模式，则会抛出一个`Symfony\\Component\\HttpKernel\\Exception\\HttpException`实例，状态码为 503。\r\n\r\n要启用维护模式，请执行`down` Artisan 命令：\r\n\r\n```shell\r\nphp artisan down\r\n```\r\n\r\n如果你希望`Refresh` HTTP 标头与所有维护模式响应一起发送，你可以在调用`down`命令时提供`refresh`选项。`Refresh` 标头将指示浏览器在指定秒数后自动刷新页面：\r\n\r\n```shell\r\nphp artisan down --refresh=15\r\n```\r\n\r\n你还可以为`down`命令提供`retry` 选项，该选项将设置为`Retry-After` HTTP 标头的值，尽管浏览器通常会忽略此标头：\r\n\r\n```shell\r\nphp artisan down --retry=60\r\n```\r\n\r\n<a name=\"bypassing-maintenance-mode\"></a>\r\n#### 绕过维护模式\r\n\r\n即使在维护模式下，你也可以使用`secret`选项来指定维护模式绕过令牌：\r\n\r\n```shell\r\nphp artisan down --secret=\"1630542a-246b-4b66-afa1-dd72a4c43515\"\r\n```\r\n\r\n将应用程序置于维护模式后，你可以访问与该令牌匹配的应用程序 URL，Laravel 将为你的浏览器颁发一个维护模式绕过 cookie：\r\n```shell\r\nhttps://example.com/1630542a-246b-4b66-afa1-dd72a4c43515\r\n```\r\n当访问此隐藏路由时，你将被重定向到应用程序的`/`路径。一旦 cookie 被颁发到你的浏览器，你就可以像维护模式不存在一样正常浏览应用程序。\r\n\r\n> **技巧**\r\n> 你的维护模式 secret 通常应由字母数字字符和可选的破折号组成。应避免使用 URL 中具有特殊含义的字符，例如 `?`。\r\n\r\n<a name=\"pre-rendering-the-maintenance-mode-view\"></a>\r\n#### 预渲染维护模式视图\r\n\r\n如果在部署期间中使用 `php artisan down` 命令，当你的 Composer 依赖或其基础组件更新的时候，你的用户也可能遇到偶然性的错误。这是因为 Laravel 框架的重要部分必须启动才能确定应用程序处于维护模式，并使用模板引擎呈现维护模式视图。\r\n\r\n因此，Laravel 允许你预渲染一个维护模式视图，该视图将在请求周期的最开始返回。此视图在加载应用程序的任何依赖项之前呈现。可以使用 `down` 命令的 `render` 选项预渲染所选模板：\r\n\r\n```shell\r\nphp artisan down --render=\"errors::503\"\r\n```\r\n\r\n<a name=\"redirecting-maintenance-mode-requests\"></a>\r\n#### 重定向维护模式请求\r\n\r\n在维护模式下，Laravel 将显示用户试图访问的所有应用程序 url 的维护模式视图。如果你愿意，你可以指示 Laravel 重定向所有请求到一个特定的 URL。这可以使用 `redirect` 选项来实现。例如，你可能希望将所有请求重定向到 `/` URI：\r\n\r\n```shell\r\nphp artisan down --redirect=/\r\n```\r\n\r\n<a name=\"disabling-maintenance-mode\"></a>\r\n#### 禁用维护模式\r\n\r\n要禁用维护模式，请使用 `up` 命令：\r\n\r\n```shell\r\nphp artisan up\r\n```\r\n\r\n> **技巧**\r\n> 你可以通过在 `resources/views/errors/503.blade.php` 中定义自己的维护模式模板。\r\n\r\n<a name=\"maintenance-mode-queues\"></a>\r\n#### 维护模式 & 队列\r\n\r\n当应用程序处于维护模式时，将不会处理任何 [队列任务](/docs/laravel/10.x/queues)。一旦应用程序退出维护模式，像往常一样继续处理。\r\n\r\n<a name=\"alternatives-to-maintenance-mode\"></a>\r\n#### 维护模式的替代方法\r\n\r\n由于维护模式要求你的应用程序有几秒钟的停机时间，因此你可以考虑使用 [Laravel Vapor](https://vapor.laravel.com) 和 [Envoyer](https://envoyer.io) 等替代方案来实现 Laravel 零停机部署。\r\n\r\n","p":"docs/configuration.html"},{"t":"structure (目录结构)","d":"# 目录结构\r\n\r\n-   [介绍](#introduction)\r\n-   [根目录](#the-root-directory)\r\n    -   [`app` 目录](#the-root-app-directory)\r\n    -   [`bootstrap` 目录](#the-bootstrap-directory)\r\n    -   [`config` 目录](#the-config-directory)\r\n    -   [`database` 目录](#the-database-directory)\r\n    -   [`public` 目录](#the-public-directory)\r\n    -   [`resources` 目录](#the-resources-directory)\r\n    -   [`routes` 目录](#the-routes-directory)\r\n    -   [`storage` 目录](#the-storage-directory)\r\n    -   [`tests` 目录](#the-tests-directory)\r\n    -   [`vendor` 目录](#the-vendor-directory)\r\n-   [应用程序目录](#the-app-directory)\r\n    -   [`Broadcasting` 目录](#the-broadcasting-directory)\r\n    -   [`Console` 目录](#the-console-directory)\r\n    -   [`Events` 目录](#the-events-directory)\r\n    -   [`Exceptions` 目录](#the-exceptions-directory)\r\n    -   [`Http` 目录](#the-http-directory)\r\n    -   [`Jobs` 目录](#the-jobs-directory)\r\n    -   [`Listeners` 目录](#the-listeners-directory)\r\n    -   [`Mail` 目录](#the-mail-directory)\r\n    -   [`Models` 目录](#the-models-directory)\r\n    -   [`Notifications` 目录](#the-notifications-directory)\r\n    -   [`Policies` 目录](#the-policies-directory)\r\n    -   [`Providers` 目录](#the-providers-directory)\r\n    -   [`Rules` 目录](#the-rules-directory)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n默认的 Laravel 应用程序结构旨在为大型和小型应用程序提供一个良好的起点。但是你可以自由地组织你的应用程序。Laravel 几乎不会限制任何给定类的位置——只要 Composer 可以自动加载类即可。\r\n\r\n> **注意**\r\n> 初次使用 Laravel？请查看 [Laravel Bootcamp](https://bootcamp.laravel.com) 以获得该框架的实战指南，同时我们将帮助你构建你的第一个 Laravel 应用。\r\n\r\n<a name=\"the-root-directory\"></a>\r\n## 根目录\r\n\r\n<a name=\"the-root-app-directory\"></a>\r\n#### App 目录\r\n\r\n`app` 目录包含应用程序的核心代码。我们很快将详细探讨这个目录；但是，你的应用程序中几乎所有的类都将在此目录中。\r\n\r\n<a name=\"the-bootstrap-directory\"></a>\r\n#### Bootstrap 目录\r\n\r\n`bootstrap` 目录包含 `app.php` 文件，该文件引导框架。此目录还包含一个 `cache` 目录，其中包含框架生成的文件，用于性能优化，例如路由和服务缓存文件。你通常不需要修改此目录中的任何文件。\r\n\r\n<a name=\"the-config-directory\"></a>\r\n#### Config 目录\r\n\r\n`config` 目录，顾名思义，包含所有应用程序的配置文件。建议你阅读所有这些文件并熟悉所有可用选项。\r\n\r\n<a name=\"the-database-directory\"></a>\r\n#### Database 目录\r\n\r\n`database` 目录包含数据库迁移、模型工厂和种子。如果需要，你还可以使用此目录来保存 SQLite 数据库。\r\n\r\n<a name=\"the-public-directory\"></a>\r\n#### Public 目录\r\n\r\n`public` 目录包含 `index.php` 文件，该文件是所有进入应用程序的请求的入口点并配置自动加载。此目录还包含你的资源文件，例如图片、JavaScript 和 CSS。\r\n\r\n<a name=\"the-resources-directory\"></a>\r\n#### Resources 目录\r\n\r\n`resources` 目录包含你的 [视图](/docs/laravel/10.x/views)，以及原始的、未编译的资源文件，例如 CSS 或 JavaScript。\r\n\r\n<a name=\"the-routes-directory\"></a>\r\n#### Routes 目录\r\n\r\n`routes` 目录包含应用程序的所有路由定义。默认情况下，Laravel 包括几个路由文件：`web.php`、`api.php`、`console.php` 和 `channels.php`。\r\n\r\n`web.php` 文件包含 `RouteServiceProvider` 将放置在 `web` 中间件组中的路由，该组提供会话状态、CSRF 保护和 cookie 加密。如果你的应用程序不提供无状态的 RESTful API，则所有路由都很可能在 `web.php` 文件中定义。\r\n\r\n`api.php` 文件包含 `RouteServiceProvider` 将放置在 `api` 中间件组中的路由。这些路由旨在是无状态的，因此通过这些路由进入应用程序的请求旨在通过令牌进行身份验证，并且不会访问会话状态。\r\n\r\n`console.php` 文件是你可以在其中定义基于闭包的控制台命令的位置。每个闭包都绑定到一个命令实例，允许一种简单的方法与每个命令的 IO 方法进行交互。即使此文件不定义 HTTP 路由，它也定义了基于控制台的入口点（路由）进入你的应用程序。\r\n\r\n`channels.php` 文件是你可以在其中注册所有应用程序支持的 [事件广播](/docs/laravel/10.x/broadcasting) 频道的位置。\r\n\r\n<a name=\"the-storage-directory\"></a>\r\n#### Storage 目录\r\n\r\n`storage` 目录包含日志、编译后的 Blade 模板、基于文件的会话、文件缓存和框架生成的其他文件。该目录分为 `app`、`framework` 和 `logs` 目录。`app` 目录可用于存储应用程序生成的任何文件。`framework` 目录用于存储框架生成的文件和缓存。最后，`logs` 目录包含应用程序的日志文件。\r\n\r\n`storage/app/public` 目录可用于存储用户生成的文件，例如个人资料头像，应该是公开可访问的。你应该在 `public/storage` 创建一个符号链接，该符号链接指向此目录。你可以使用 `php artisan storage:link` Artisan 命令创建链接。\r\n\r\n<a name=\"the-tests-directory\"></a>\r\n#### Tests 目录\r\n\r\n`tests` 目录包含你的自动化测试。 开箱即用的示例 [PHPUnit](https://phpunit.de/) 单元测试和功能测试。 每个测试类都应以单词「Test」作为后缀。 你可以使用 `phpunit` 或 `php vendor/bin/phpunit` 命令运行测试。 或者，如果你想要更详细和更漂亮的测试结果表示，你可以使用 `php artisan test` Artisan 命令运行测试\r\n\r\n<a name=\"the-vendor-directory\"></a>\r\n#### Vendor 目录\r\n\r\n`vendor` 目录包含你的 [Composer](https://getcomposer.org/) 依赖项。\r\n\r\n<a name=\"the-app-directory\"></a>\r\n## App 目录\r\n\r\n你的大部分应用程序都位于 `app` 目录中。默认情况下，此目录在 `App` 下命名，并由 Composer 使用 [PSR-4 自动加载标准] ([www.php-fig.org/psr/psr-4/](https://www.php-fig.org/psr/psr-4/)) 自动加载。\r\n\r\n`app` 目录包含各种附加目录，例如 `Console`、`Http` 和 `Providers`。将 `Console` 和 `Http` 目录视为为应用程序核心提供 API。 HTTP 协议和 CLI 都是与应用程序交互的机制，但实际上并不包含应用程序逻辑。换句话说，它们是向你的应用程序发出命令的两种方式。 `Console` 目录包含你的所有 Artisan 命令，而 `Http` 目录包含你的控制器、中间件和请求。\r\n\r\n当你使用 `make` Artisan 命令生成类时，会在 `app` 目录中生成各种其他目录。因此，例如，在你执行 `make:job` Artisan 命令生成作业类之前，`app/Jobs` 目录将不存在。\r\n\r\n> **技巧**  \r\n> `app` 目录中的许多类可以由 Artisan 通过命令生成。 要查看可用命令，请在终端中运行 `php artisan list make` 命令。\r\n\r\n<a name=\"the-broadcasting-directory\"></a>\r\n#### Broadcasting 目录\r\n\r\n`Broadcasting` 目录包含应用程序的所有广播频道类。 这些类是使用 `make:channel` 命令生成的。 此目录默认不存在，但会在你创建第一个频道时为你创建。 要了解有关频道的更多信息，请查看有关 [事件广播](/docs/laravel/10.x/broadcasting) 的文档。\r\n\r\n<a name=\"the-console-directory\"></a>\r\n#### Console 目录\r\n\r\n`Console` 目录包含应用程序的所有自定义 Artisan 命令。 这些命令可以使用 `make:command` 命令生成。 该目录还包含你的控制台内核，这是你注册自定义 Artisan 命令和定义 [计划任务](/docs/laravel/10.x/scheduling) 的地方。\r\n\r\n<a name=\"the-events-directory\"></a>\r\n#### Events 目录\r\n\r\n此目录默认不存在，但会由 `event:generate` 和 `make:event` Artisan 命令为你创建。 `Events` 目录包含 [事件类](/docs/laravel/10.x/events)。 事件可用于提醒应用程序的其他部分发生了给定的操作，从而提供了极大的灵活性和解耦性。\r\n\r\n<a name=\"the-exceptions-directory\"></a>\r\n#### Exceptions 目录\r\n\r\n`Exceptions` 目录包含应用程序的异常处理程序，也是放置应用程序抛出的任何异常的好地方。 如果你想自定义记录或呈现异常的方式，你应该修改此目录中的 `Handler` 类。\r\n\r\n<a name=\"the-http-directory\"></a>\r\n#### Http 目录\r\n\r\n`Http` 目录包含你的控制器、中间件和表单请求。 几乎所有处理进入应用程序的请求的逻辑都将放在这个目录中。\r\n\r\n<a name=\"the-jobs-directory\"></a>\r\n#### Jobs 目录\r\n\r\n该目录默认不存在，但如果你执行 `make:job` Artisan 命令，则会为你创建。 `Jobs` 目录包含你的应用程序的 [队列作业](/docs/laravel/10.x/queues)。 作业可能由你的应用程序排队或在当前请求生命周期内同步运行。 在当前请求期间同步运行的作业有时被称为「命令」，因为它们是 [命令模式](https://en.wikipedia.org/wiki/Command_pattern) 的实现。\r\n\r\n<a name=\"the-listeners-directory\"></a>\r\n#### Listeners 目录\r\n\r\n此目录默认不存在，但如果你执行 `event:generate` 或 `make:listener` Artisan 命令，则会为你创建。 `Listeners` 目录包含处理你的 [events](/docs/laravel/10.x/events) 的类。 事件侦听器接收事件实例并执行逻辑以响应被触发的事件。 例如，`UserRegistered` 事件可能由 `SendWelcomeEmail` 监听器处理。\r\n\r\n<a name=\"the-mail-directory\"></a>\r\n#### Mail 目录\r\n\r\n该目录默认不存在，但如果你执行 `make:mail` Artisan 命令，则会为你创建。 `Mail` 目录包含你的应用程序发送的所有 [代表电子邮件的类](/docs/laravel/10.x/mail)。 Mail 对象允许你将构建电子邮件的所有逻辑封装在一个简单的类中，该类可以使用 `Mail::send` 方法发送。\r\n\r\n<a name=\"the-models-directory\"></a>\r\n#### Models 目录\r\n\r\n`Models` 目录包含所有 [Eloquent 模型类](/docs/laravel/10.x/eloquent)。 Laravel 中包含的 Eloquent ORM 提供了一个漂亮、简单的 ActiveRecord 实现来处理你的数据库。 每个数据库表都有一个相应的「模型」，用于与该表进行交互。 模型允许你查询表中的数据，以及将新记录插入表中\r\n\r\n<a name=\"the-notifications-directory\"></a>\r\n#### Notifications 目录\r\n\r\n默认情况下，此目录不存在，但如果你执行 `make:notification` Artisan 命令时会自动生成。 `Notifications` 目录包含所有你发送给应用程序的「事务性」 [消息通知](/docs/laravel/10.x/notifications) 。例如关于应用程序内发生的事件的简单通知。Laravel 的通知功能抽象了通过各种驱动程序发送的通知，如电子邮件通知、Slack 信息、SMS 短信通知或数据库存储。\r\n\r\n<a name=\"the-policies-directory\"></a>\r\n#### Policies 目录\r\n\r\n默认情况下，此目录不存在，但如果你执行 `make:policy` Artisan 命令会生成。 `Policies` 目录包含应用程序的 [授权策略类](/docs/laravel/10.x/authorization)。这些类用于确定用户是否可以对资源执行给定的操作。\r\n\r\n<a name=\"the-providers-directory\"></a>\r\n#### Providers 目录\r\n\r\n`Providers` 目录包含程序中所有的 [服务提供者](/docs/laravel/10.x/providers)。服务提供者通过在服务容器中绑定服务、注册事件或执行任何其他任务来引导应用程序以应对传入请求。\r\n\r\n在一个新的 Laravel 应用程序中，这个目录已经包含了几个提供者。你可以根据需要将自己的提供程序添加到此目录。\r\n\r\n<a name=\"the-rules-directory\"></a>\r\n#### Rules 目录\r\n\r\n默认情况下，此目录不存在，但如果你执行 `make:rule` Artisan 命令后会生成。 `Rules` 目录包含应用程序用户自定义的验证规则。这些验证规则用于将复杂的验证逻辑封装在一个简单的对象中。有关更多信息，请查看 [表单验证](/docs/laravel/10.x/validation)。","p":"docs/structure.html"},{"t":"frontend (前端)","d":"# 前端\r\n\r\n- [介绍](#introduction)\r\n- [使用 PHP](#using-php)\r\n    - [PHP 和 Blade](#php-and-blade)\r\n    - [Livewire](#livewire)\r\n    - [入门套件](#php-starter-kits)\r\n- [使用 Vue / React](#using-vue-react)\r\n    - [Inertia](#inertia)\r\n    - [入门套件](#inertia-starter-kits)\r\n- [打包资源](#bundling-assets)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 是一个后端框架，提供了构建现代 Web 应用所需的所有功能，例如 [路由](/docs/laravel/10.x/routing)、[验证](/docs/laravel/10.x/validation)、[缓存](/docs/laravel/10.x/cache)、[队列](/docs/laravel/10.x/queues)、[文件存储](/docs/laravel/10.x/filesystem) 等等。然而，我们认为为开发人员提供美观的全栈体验，包括构建应用前端的强大方法，是非常重要的。\r\n\r\n在使用 Laravel 构建应用时，有两种主要的方式来解决前端开发问题，选择哪种方式取决于你是否想通过 PHP 或使用像 Vue 和 React 这样的 JavaScript 框架来构建前端。我们将在下面讨论这两种选项，以便你可以做出有关应用程序前端开发的最佳方法的明智决策。\r\n\r\n<a name=\"using-php\"></a>\r\n## 使用 PHP\r\n\r\n<a name=\"php-and-blade\"></a>\r\n### PHP 和 Blade\r\n\r\n过去，大多数 PHP 应用程序使用简单的 HTML 模板和 PHP `echo` 语句将数据呈现给浏览器，这些语句在请求期间从数据库检索数据：\r\n\r\n```blade\r\n<div>\r\n    <?php foreach ($users as $user): ?>\r\n        Hello, <?php echo $user->name; ?> <br />\r\n    <?php endforeach; ?>\r\n</div>\r\n```\r\n\r\n在 Laravel 中，仍可以使用 视图 和 Blade 来实现呈现 HTML 的这种方法。Blade 是一种非常轻量级的模板语言，提供方便、简短的语法，用于显示数据、迭代数据等：\r\n\r\n```blade\r\n<div>\r\n    @foreach ($users as $user)\r\n        Hello, {{ $user->name }} <br />\r\n    @endforeach\r\n</div>\r\n```\r\n\r\n当使用这种方法构建应用程序时，表单提交和其他页面交互通常会从服务器接收一个全新的 HTML 文档，整个页面将由浏览器重新渲染。即使今天，许多应用程序也可能非常适合使用简单的 Blade 模板构建其前端。\r\n\r\n<a name=\"growing-expectations\"></a>\r\n#### 不断提高的期望\r\n\r\n然而，随着用户对 Web 应用程序的期望不断提高，许多开发人员发现需要构建更具有互动性和更具现代感的动态前端。为此，一些开发人员选择使用诸如 Vue 和 React 等 JavaScript 框架开始构建应用程序的前端。\r\n\r\n其他人则更喜欢使用他们熟悉的后端语言，开发出可利用他们首选的后端语言构建现代 Web 应用程序 UI 的解决方案。例如，在[Rails](https://rubyonrails.org/)生态系统中，这促使了诸如[Turbo](https://turbo.hotwired.dev/)、[Hotwire](https://hotwired.dev/)和[Stimulus](https://stimulus.hotwired.dev/)等库的创建。\r\n\r\n在 Laravel 生态系统中，需要主要使用PHP创建现代动态前端已经导致了[Laravel Livewire](https://laravel-livewire.com/)和[Alpine.js](https://alpinejs.dev/)的创建。\r\n\r\n<a name=\"livewire\"></a>\r\n### Livewire\r\n\r\n[Laravel Livewire](https://laravel-livewire.com/)是一个用于构建 Laravel 前端的框架，具有与使用现代 JavaScript 框架（如 Vue 和 React ）构建的前端一样的动态、现代和生动的感觉。\r\n\r\n在使用 Livewire 时，你将创建 Livewire \"组件\"，这些组件将呈现 UI 的一个离散部分，并公开可以从应用程序的前端调用和互动的方法和数据。例如，一个简单的\"计数器\"组件可能如下所示：\r\n\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Livewire;\r\n\r\n    use Livewire\\Component;\r\n\r\n    class Counter extends Component\r\n    {\r\n        public $count = 0;\r\n\r\n        public function increment()\r\n        {\r\n            $this->count++;\r\n        }\r\n\r\n        public function render()\r\n        {\r\n            return view('livewire.counter');\r\n        }\r\n    }\r\n\r\n对于计数器，相应的模板将会像这样写：\r\n\r\n```blade\r\n<div>\r\n    <button wire:click=\"increment\">+</button>\r\n    <h1>{{ $count }}</h1>\r\n</div>\r\n```\r\n\r\n正如你所见，Livewire 使你能够编写新的 HTML 属性，例如 `wire:click`，以连接 Laravel 应用程序的前端和后端。此外，你可以使用简单的 Blade 表达式呈现组件的当前状态。\r\n\r\n对于许多人来说，Livewire 改变了 Laravel 的前端开发方式，使他们可以在 Laravel 的舒适环境下构建现代、动态的 Web 应用程序。通常，使用 Livewire 的开发人员也会利用 [Alpine.js](https://alpinejs.dev/) 仅在需要时 \"适度地添加\" JavaScript 到他们的前端，比如为了渲染对话框窗口。\r\n\r\n如果你是 Laravel 新手，我们建议你先了解 [views](/docs/laravel/10.x/views) 和 [Blade](/docs/laravel/10.x/blade) 的基本用法。然后，查阅官方的 [Laravel Livewire 文档](https://laravel-livewire.com/docs)，学习如何通过交互式 Livewire 组件将你的应用程序提升到新的水平。\r\n\r\n<a name=\"php-starter-kits\"></a>\r\n### 入门套件\r\n\r\n如果你想使用 PHP 和 Livewire 构建你的前端，你可以利用我们的 Breeze 或 Jetstream [入门套件](/docs/laravel/10.x/starter-kits) 来快速启动你的应用程序开发。这两个入门套件都使用 [Blade](/docs/laravel/10.x/blade) 和 [Tailwind](https://tailwindcss.com/) 构建你的应用程序后端和前端身份验证流程，让你可以轻松开始构建你的下一个大项目。\r\n\r\n<a name=\"using-vue-react\"></a>\r\n## 使用 Vue / React\r\n\r\n尽管使用 Laravel 和 Livewire 可以构建现代的前端，但许多开发人员仍然喜欢利用像 Vue 或 React 这样的 JavaScript 框架的强大功能。这使开发人员能够利用通过 NPM 可用的丰富的 JavaScript 包和工具生态系统。\r\n\r\n然而，如果没有额外的工具支持，将 Laravel 与 Vue 或 React 配对会遇到各种复杂的问题，例如客户端路由、数据注入和身份验证。使用诸如 [Nuxt](https://nuxtjs.org/) 和 [Next](https://nextjs.org/) 等具有观点的 Vue / React 框架可以简化客户端路由；但是，当将类似 Laravel 这样的后端框架与这些前端框架配对时，数据注入和身份验证仍然是复杂而麻烦的问题。\r\n\r\n此外，开发人员需要维护两个单独的代码存储库，通常需要在两个存储库之间协调维护、发布和部署。虽然这些问题并非不可解决，但我们认为这不是开发应用程序的一种有成效或令人愉快的方式。\r\n\r\n<a name=\"inertia\"></a>\r\n### Inertia\r\n\r\n值得庆幸的是，Laravel 提供了两全其美的解决方案。[Inertia](https://inertiajs.com/) 可以桥接你的 Laravel 应用程序和现代 Vue 或 React 前端，使你可以使用 Vue 或 React 构建完整的现代前端，同时利用 Laravel 路由和控制器进行路由、数据注入和身份验证 - 所有这些都在单个代码存储库中完成。使用这种方法，你可以同时享受 Laravel 和 Vue / React 的全部功能，而不会破坏任何一种工具的能力。\r\n\r\n在将 Inertia 安装到你的 Laravel 应用程序后，你将像平常一样编写路由和控制器。但是，你将返回 Inertia 页面而不是从控制器返回 Blade 模板：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\User;\r\n    use Inertia\\Inertia;\r\n    use Inertia\\Response;\r\n\r\n    class UserController extends Controller {\r\n        /**\r\n         * 显示给定用户的个人资料\r\n         */\r\n        public function show(string $id): Response {\r\n            return Inertia::render('Users/Profile', [\r\n                'user' => User::findOrFail($id)\r\n            ]);\r\n        }\r\n    }\r\n\r\nInertia 页面对应于 Vue 或 React 组件，通常存储在应用程序的 `resources/js/Pages` 目录中。通过 `Inertia::render` 方法传递给页面的数据将用于填充页面组件的 \"props\"：\r\n\r\n```vue\r\n<script setup>\r\nimport Layout from '@/Layouts/Authenticated.vue';\r\nimport { Head } from '@inertiajs/inertia-vue3';\r\n\r\nconst props = defineProps(['user']);\r\n</script>\r\n\r\n<template>\r\n    <Head title=\"用户资料\" />\r\n\r\n    <Layout>\r\n        <template #header>\r\n            <h2 class=\"font-semibold text-xl text-gray-800 leading-tight\">\r\n                资料\r\n            </h2>\r\n        </template>\r\n\r\n        <div class=\"py-12\">\r\n            你好，{{ user.name }}\r\n        </div>\r\n    </Layout>\r\n</template>\r\n```\r\n\r\n正如你所看到的，使用 Inertia 可以在构建前端时充分利用 Vue 或 React 的强大功能，同时为 Laravel 驱动的后端和 JavaScript 驱动的前端提供了轻量级的桥梁。\r\n\r\n#### 服务器端渲染\r\n\r\n如果你因为应用程序需要服务器端渲染而担心使用 Inertia，不用担心。Inertia 提供了 [服务器端渲染支持](https://inertiajs.com/server-side-rendering)。并且，在通过 [Laravel Forge](https://forge.laravel.com/) 部署应用程序时，轻松确保 Inertia 的服务器端渲染过程始终运行。\r\n\r\n<a name=\"inertia-starter-kits\"></a>\r\n### 入门套件\r\n\r\n如果你想使用 Inertia 和 Vue / React 构建前端，可以利用我们的 Breeze 或 Jetstream [入门套件](/docs/laravel/10.x/starter-kits) 来加速应用程序的开发。这两个入门套件使用 Inertia、Vue / React、[Tailwind](https://tailwindcss.com/) 和 [Vite](https://vitejs.dev/) 构建应用程序的后端和前端身份验证流程，让你可以开始构建下一个大型项目。\r\n\r\n<a name=\"bundling-assets\"></a>\r\n## 打包资源\r\n\r\n无论你选择使用 Blade 和 Livewire 还是 Vue/React 和 Inertia 来开发你的前端，你都可能需要将你的应用程序的 CSS 打包成生产就绪的资源。当然，如果你选择用 Vue 或 React 来构建你的应用程序的前端，你也需要将你的组件打包成浏览器准备好的 JavaScript 资源。\r\n\r\n默认情况下，Laravel 利用 [Vite](https://vitejs.dev) 来打包你的资源。Vite 在本地开发过程中提供了闪电般的构建时间和接近即时的热模块替换（HMR）。在所有新的 Laravel 应用程序中，包括那些使用我们的 [入门套件](/docs/laravel/10.x/starter-kit)，你会发现一个 `vite.config.js` 文件，加载我们轻量级的 Laravel Vite 插件，使 Vite 在 Laravel 应用程序中使用起来非常愉快。\r\n\r\n开始使用 Laravel 和 Vite 的最快方法是使用 [Laravel Breeze](/docs/laravel/10.x/starter-kitsmd#laravel-breeze) 开始你的应用程序的开发，我们最简单的入门套件，通过提供前端和后端的认证支架来启动你的应用程序。\r\n\r\n> **注意**\r\n> 关于利用 Vite 和 Laravel 的更多详细文档，请看我们的 [关于打包和编译资源的专用文档](/docs/laravel/10.x/vite)。\r\n\r\n","p":"docs/frontend.html"},{"t":"starter-kits (起步套件)","d":"# 起步套件\r\n\r\n- [介绍](#introduction)\r\n- [Laravel Breeze](#laravel-breeze)\r\n    - [安装](#laravel-breeze-installation)\r\n    - [Breeze & Blade](#breeze-and-blade)\r\n    - [Breeze & React / Vue](#breeze-and-inertia)\r\n    - [Breeze & Next.js / API](#breeze-and-next)\r\n- [Laravel Jetstream](#laravel-jetstream)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n为了帮助你快速构建 Laravel 应用，我们很高兴提供认证和应用程序起始套件。这些套件会自动使用所需的路由、控制器和视图来注册和验证应用程序的用户。\r\n\r\n虽然你可以使用这些起始套件，但它们并非必需品。你可以通过安装全新的 Laravel 来从头开始构建自己的应用程序。无论你选择哪种方式，我们相信你都能构建出很棒的应用程序！\r\n\r\n<a name=\"laravel-breeze\"></a>\r\n## Laravel Breeze\r\n\r\n[Laravel Breeze](https://github.com/laravel/breeze) 是 Laravel 的 [认证功能](/docs/laravel/10.x/authentication) 的一种简单、最小实现，包括登录、注册、密码重置、电子邮件验证和密码确认。此外，Breeze 还包括一个简单的「个人资料」页面，用户可以在该页面上更新其姓名、电子邮件地址和密码。\r\n\r\nLaravel Breeze 的默认视图层由简单的 [Blade 模版](/docs/laravel/10.x/blade) 和 [Tailwind CSS](https://tailwindcss.com) 组成。除此之外，Breeze 还可以使用 Vue 或 React 和 [Inertia](https://inertiajs.com) 来构建应用。\r\n\r\nBreeze 为开始全新的 Laravel 应用程序提供了很好的起点，并且对于打算使用 [Laravel Livewire](https://laravel-livewire.com) 将 Blade 模板提升新的水平的项目来说，也是一个不错的选择。\r\n\r\n<img src=\"https://laravel.com/img/docs/breeze-register.png\">\r\n\r\n#### Laravel 训练营\r\n\r\n如果你是 Laravel 的新手，欢迎加入 [Laravel 训练营](https://bootcamp.laravel.com)。 Laravel 训练营将带领你通过使用 Breeze 构建你的第一个 Laravel 应用程序。这是一个很好的方式，让你了解 Laravel 和 Breeze 提供的所有功能。\r\n\r\n<a name=\"laravel-breeze-installation\"></a>\r\n### 安装\r\n\r\n首先，你应该 [创建一个新的 Laravel 应用程序](/docs/laravel/10.x/installation)，配置好数据库并运行 [数据库迁移](/docs/laravel/10.x/migrations)。在创建了一个新的 Laravel 应用程序之后，你可以使用 Composer 来安装 Laravel Breeze：\r\n\r\n```shell\r\ncomposer require laravel/breeze --dev\r\n```\r\n\r\n安装完 Breeze 后，你可以使用下文中提到的 Breeze「栈」来快速构建你的应用程序。\r\n\r\n<a name=\"breeze-and-blade\"></a>\r\n### Breeze & Blade\r\n\r\n在使用 Composer 安装好 Laravel Breeze 之后，你可以运行 `breeze:install` Artisan 命令。这个命令会将身份验证视图、路由、控制器和其他资源复制到你的应用程序中。Laravel Breeze 将其所有代码都复制到你的应用程序中，这样你就可以完全控制和查看其功能和实现。\r\n\r\n默认的 Breeze「栈」是 Blade 栈，它使用简单的 [Blade 模板](/docs/laravel/10.x/blade) 来渲染你的应用程序前端。你可以通过调用 `breeze:install` 命令来安装 Blade 栈，而无需其他额外的参数。在 Breeze 的脚手架安装完后，你还需要编译应用程序的前端资源：\r\n\r\n```shell\r\nphp artisan breeze:install\r\n\r\nphp artisan migrate\r\nnpm install\r\nnpm run dev\r\n```\r\n\r\n接下来，你可以在 Web 浏览器中打开应用程序的 `/login` 或 `/register` 的 URL。所有 Breeze 的路由都定义在 `routes/auth.php` 文件中。\r\n\r\n<a name=\"dark-mode\"></a>\r\n#### 黑暗模式\r\n\r\n如果你希望 Breeze 在构建应用程序前端时支持「黑暗模式」，只需要在执行 `breeze:install` 命令时提供 `--dark` 指令即可：\r\n\r\n```shell\r\nphp artisan breeze:install --dark\r\n```\r\n\r\n> **注意**\r\n> 要了解有关编译应用程序的 CSS 和 JavaScript 的更多信息，请查看 Laravel 的 [Vite 编译 Assets](/docs/laravel/10.x/vitemd#running-vite).\r\n\r\n<a name=\"breeze-and-inertia\"></a>\r\n### Breeze & React / Vue\r\n\r\nLaravel Breeze 还通过 [Inertia](https://inertiajs.com) 前端实现提供 React 和 Vue 脚手架。 Inertia 允许你使用经典的服务器端路由和控制器构建目前流行的单页 React 和 Vue 应用程序。\r\n\r\nInertia 让你享受 React 和 Vue 的前端强大功能以及 Laravel 令人难以置信的后端生产力和快如闪电的 [Vite](https://vitejs.dev) 编译。 如果要指定技术栈，请在执行 `breeze:install` Artisan 命令时指定 `vue` 或 `react` 作为你想要的技术栈。 安装 Breeze 的脚手架后，你就可以安装依赖及运行前端项目：\r\n\r\n```shell\r\nphp artisan breeze:install vue\r\n\r\n# 或者。。。\r\n\r\nphp artisan breeze:install react\r\n\r\nphp artisan migrate\r\nnpm install\r\nnpm run dev\r\n```\r\n\r\n接下来，你就可以在浏览器中访问 `/login` 或 `/register` URL。 Breeze 的所有路由都在 `routes/auth.php` 文件中定义。\r\n\r\n<a name=\"server-side-rendering\"></a>\r\n#### 服务器端渲染\r\n\r\n如果你希望 Breeze 支持 [Inertia SSR](https://inertiajs.com/server-side-rendering)，你可以在调用 `breeze:install` 命令时提供 `ssr` 选项：\r\n\r\n```shell\r\nphp artisan breeze:install vue --ssr\r\nphp artisan breeze:install react --ssr\r\n```\r\n\r\n<a name=\"breeze-and-next\"></a>\r\n\r\n### Breeze & Next.js / API\r\n\r\nLaravel Breeze 还可以生成身份验证 API，可以准备验证现代 JavaScript 应用程序，例如由 [Next](https://nextjs.org/)，[Nuxt](https://nuxtjs.org/) 等驱动的应用。要开始，请在执行 `breeze:install` Artisan 命令时指定 `api` 堆栈作为所需的堆栈：\r\n\r\n```shell\r\nphp artisan breeze:install api\r\n\r\nphp artisan migrate\r\n```\r\n\r\n在安装期间，Breeze 将在应用程序的 `.env` 文件中添加 `FRONTEND_URL` 环境变量。该 URL 应该是你的 JavaScript 应用程序的 URL。在本地开发期间，这通常是 `http://localhost:3000`。另外，你应该确保 `APP_URL` 设置为 `http://localhost:8000`，这是 `serve` Artisan 命令使用的默认 URL。\r\n\r\n<a name=\"next-reference-implementation\"></a>\r\n#### Next.js 参考实现\r\n\r\n最后，你可以将此后端与你选择的前端配对。Breeze 前端的 Next 参考实现在 [在GitHub上提供](https://github.com/laravel/breeze-next)。此前端由 Laravel 维护，并包含与 Breeze 提供的传统 Blade 和 Inertia 堆栈相同的用户界面。\r\n\r\n<a name=\"laravel-jetstream\"></a>\r\n## Laravel Jetstream\r\n\r\n虽然 Laravel Breeze 为构建 Laravel 应用程序提供了简单和最小的起点，但 Jetstream 通过更强大的功能和附加的前端技术栈增强了该功能。**对于全新接触 Laravel 的用户，我们建议使用 Laravel Breeze 学习一段时间后再尝试 Laravel Jetstream。**\r\n\r\nJetstream 为 Laravel 提供了美观的应用程序脚手架，并包括登录、注册、电子邮件验证、双因素身份验证、会话管理、通过 Laravel Sanctum 支持的 API 以及可选的团队管理。Jetstream 使用 [Tailwind CSS](https://tailwindcss.com/) 设计，并提供你选择使用 [Livewire](https://laravel-livewire.com/) 或 [Inertia](https://inertiajs.com/) 驱动的前端脚手架。\r\n\r\n有关安装 Laravel Jetstream 的完整文档，请参阅 [Jetstream 官方文档](https://jetstream.laravel.com/3.x/introduction.html)。\r\n","p":"docs/starter-kits.html"},{"t":"deployment (部署)","d":"# 部署\r\n\r\n- [介绍](#introduction)\r\n- [服务器要求](#server-requirements)\r\n- [服务器配置](#server-configuration)\r\n  - [Nginx](#nginx)\r\n- [优化](#optimization)\r\n  - [优化自动加载器](#autoloader-optimization)\r\n  - [优化配置加载](#optimizing-configuration-loading)\r\n  - [优化路由加载](#optimizing-route-loading)\r\n  - [优化视图加载](#optimizing-view-loading)\r\n- [调试模式](#debug-mode)\r\n- [使用 Forge / Vapor 进行部署](#deploying-with-forge-or-vapor)\r\n\r\n<a name=\"introduction\"></a>\r\n\r\n## 介绍\r\n\r\n当你准备将 Laravel 应用程序部署到生产环境时，你可以做一些重要的事情来确保应用程序尽可能高效地运行。本文将会提供几个范本以使你的 Laravel 应用部署妥当。\r\n\r\n<a name=\"server-requirements\"></a>\r\n\r\n## 服务器要求\r\n\r\nLaravel 框架有一些系统要求。你应该确保你的 Web 服务器具有以下最低 PHP 版本和扩展：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- PHP >= 8.1\r\n- Ctype PHP 扩展\r\n- cURL PHP 扩展\r\n- DOM PHP 扩展\r\n- Fileinfo PHP 扩展\r\n- Filter PHP 扩展\r\n- Hash PHP 扩展\r\n- Mbstring PHP 扩展\r\n- OpenSSL PHP 扩展\r\n- PCRE PHP 扩展\r\n- PDO PHP 扩展\r\n- Session PHP 扩展\r\n- Tokenizer PHP 扩展\r\n- XML PHP 扩展\r\n\r\n</div>\r\n\r\n<a name=\"server-configuration\"></a>\r\n\r\n## 服务器配置\r\n\r\n<a name=\"nginx\"></a>\r\n\r\n### Nginx\r\n\r\n如果你将应用程序部署到运行 Nginx 的服务器上，你可以将以下配置文件作为为你的 Web 服务器配置的起点。最有可能需要根据你的服务器配置自定义此文件。**如果你需要管理服务器，请考虑使用官方的 Laravel 服务器管理和部署服务，如 [Laravel Forge](https://forge.laravel.com)。**\r\n\r\n请确保像以下配置一样，你的 Web 服务器将所有请求指向应用程序的 `public/index.php` 文件。永远不要尝试将 `index.php` 文件移动到项目的根目录，因为从项目根目录为应用提供服务会将许多敏感配置文件暴露到公网。\r\n\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    listen [::]:80;\r\n    server_name example.com;\r\n    root /srv/example.com/public;\r\n\r\n    add_header X-Frame-Options \"SAMEORIGIN\";\r\n    add_header X-Content-Type-Options \"nosniff\";\r\n\r\n    index index.php;\r\n\r\n    charset utf-8;\r\n\r\n    location / {\r\n        try_files $uri $uri/ /index.php?$query_string;\r\n    }\r\n\r\n    location = /favicon.ico { access_log off; log_not_found off; }\r\n    location = /robots.txt  { access_log off; log_not_found off; }\r\n\r\n    error_page 404 /index.php;\r\n\r\n    location ~ \\.php$ {\r\n        fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;\r\n        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;\r\n        include fastcgi_params;\r\n    }\r\n\r\n    location ~ /\\.(?!well-known).* {\r\n        deny all;\r\n    }\r\n}\r\n```\r\n<a name=\"optimization\"></a>\r\n\r\n## 优化\r\n\r\n<a name=\"autoloader-optimization\"></a>\r\n\r\n### 优化自动加载器\r\n\r\n在部署到生产环境时，请确保你正在优化 Composer 的类自动加载器映射，以便 Composer 可以快速找到适合给定类加载的文件：\r\n\r\n```shell\r\ncomposer install --optimize-autoloader --no-dev\r\n```\r\n\r\n> **注意**\r\n> 除了优化自动加载器之外，你还应该始终确保在项目的源代码控制存储库中包括一个 `composer.lock` 文件。存在 `composer.lock` 文件时，可以更快地安装项目的依赖项。\r\n\r\n<a name=\"optimizing-configuration-loading\"></a>\r\n\r\n### 优化配置加载\r\n\r\n在将应用程序部署到生产环境时，你应该确保在部署过中运行 `config:cache` Artisan 命令来提前对一些配置文件做一下缓存：\r\n\r\n```shell\r\nphp artisan config:cache\r\n```\r\n\r\n这个命令将把 Laravel 的所有配置文件合并成一个缓存文件，大大减少框在加载配置值时必须进行的文件系统访问次数。\r\n\r\n> **警告**\r\n> 如果你在部署过程中执行 `config:cache` 命令，应确保仅从配置文件中调用 `env` 函数。一旦配置已被缓存，`.env` 文件将不再被加载，所有对于 `.env` 变量 env 函数的调用将返回 null。\r\n\r\n<a name=\"optimizing-route-loading\"></a>\r\n\r\n### 优化路由加载\r\n\r\n如果你正在构建一个包含许多路由的大型应用程序，你应该确保在部署过程中运行 `route:cache` Artisan 命令：\r\n\r\n```shell\r\nphp artisan route:cache\r\n```\r\n\r\n这个命令将所有路由注册缩减成单个方法调用且放入缓存文件中，提高注册大量路由时的性能。\r\n\r\n<a name=\"optimizing-view-loading\"></a>\r\n\r\n### 优化视图加载\r\n\r\n在将应用程序部署到生产环境时，你应该确保在部署过程中运行 `view:cache` Artisan 命令：\r\n\r\n```shell\r\nphp artisan view:cache\r\n```\r\n\r\n这个命令预编译了所有的 Blade 视图，使它们不再是按需编译，因此可以提高返回视图的每个请求的性能。\r\n\r\n<a name=\"debug-mode\"></a>\r\n\r\n## 调试模式\r\n\r\n在 `config/app.php` 配置文件中，调试选项决定了有多少错误信息实际上会显示给用户。默认情况下，该选项设置为遵守 `APP_DEBUG` 环境变量的值，该值存储在你的应用程序的 `.env` 文件中。\r\n\r\n**在生产环境中，这个值应该永远是 `false`。如果在生产环境中将 `APP_DEBUG` 变量的值设置为 `true`，则存在将敏感配置值暴露给应用程序最终用户的风险。**\r\n\r\n<a name=\"deploying-with-forge-or-vapor\"></a>\r\n\r\n## 使用 Forge / Vapor 部署\r\n\r\n<a name=\"laravel-forge\"></a>\r\n\r\n#### Laravel Forge\r\n\r\n如果你还不准备好管理自己的服务器配置，或者对于配置运行一个强大的 Laravel 应用程序所需的各种服务不太熟悉，那么 [Laravel Forge](https://forge.laravel.com) 是一个非常好的选择。\r\n\r\nLaravel Forge 可以在诸如Linode、AWS 等多种基础设施服务提供商上创建服务器。此外，Forge 还安装和管理构建强大的 Laravel 应用程序所需的所有工具，例如 Nginx、MySQL、Redis、Memcached、Beanstalk 等等。\r\n\r\n> **注意**\r\n> 想获取 Laravel Forge 完整部署指南吗？请查看 [Laravel Bootcamp](https://bootcamp.laravel.com/deploying) 和 [Laracasts 上提供的 Forge 视频系列](https://laracasts.com/series/learn-laravel-forge-2022-edition)。\r\n\r\n<a name=\"laravel-vapor\"></a>\r\n\r\n#### Vapor\r\n\r\n如果你想要一个为 Laravel 调整的完全无服务器、自动扩展的部署平台，请看看 [Laravel Vapor](https://vapor.laravel.com)。Laravel Vapor 是一个由 AWS 提供支持的基于无服务器概念的 Laravel 部署平台。在 Vapor 上启动你的 Laravel 基础架构，并爱上无服务器的可扩展简单性。Laravel Vapor 由 Laravel 的创作者进行了精细调校，以便与框架无缝协作，因此你可以像以前一样继续编写 Laravel 应用程序。\r\n","p":"docs/deployment.html"},{"t":"lifecycle (请求的生命周期)","d":"\n# 请求的生命周期\r\n\r\n- [简介](#introduction)\r\n- [生命周期概述](#lifecycle-overview)\r\n    - [第一步](#first-steps)\r\n    - [HTTP / Console 内核](#http-console-kernels)\r\n    - [服务提供者](#service-providers)\r\n    - [路由](#routing)\r\n    - [请求结束](#finishing-up)\r\n- [关注服务提供者](#focus-on-service-providers)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在「真实世界」中使用任何工具时，如果你了解该工具的工作原理，你会更加自信。应用程序开发也不例外。当您了解开发工具的功能时，你会觉得使用它们更舒服、更自信。\r\n\r\n本文的目的是让您对 Laravel 框架的工作原理有一个良好的、高层次的理解。通过更好地了解整个框架，一切感觉都不那么「神奇」，你将更有信心构建你的应用程序。如果你不明白所有的规则，不要灰心！只要试着对正在发生的事情有一个基本的掌握，你的知识就会随着你探索文档的其他部分而增长。\r\n\r\n<a name=\"lifecycle-overview\"></a>\r\n## 生命周期概述\r\n\r\n<a name=\"first-steps\"></a>\r\n### 第一步\r\n\r\nLaravel 应用程序的所有请求的入口点都是 `public/index.php` 文件。所有请求都由你的 web 服务器（Apache/Nginx）配置定向到此文件。那个 `index.php` 文件不包含太多代码。相反，它是加载框架其余部分的起点。\r\n\r\n`index.php` 文件将加载 Composer 生成的自动加载器定义，然后从 `bootstrap/app.php` 中检索 Laravel 应用程序的实例。Laravel 本身采取的第一个操作是创建应用 / [服务容器](/docs/laravel/10.x/container) 的实例。\r\n\r\n\n\n<a name=\"http-console-kernels\"></a>\r\n### HTTP / Console 内核\r\n\r\n接下来，根据进入应用的请求类型，传入的请求将被发送到 HTTP 内核或者 Console 内核。这两个内核充当所有请求流经的中心位置。现在，我们只关注位于`app/Http/Kernel.php`中的 HTTP 内核。\r\n\r\nHTTP 内核继承了`Illuminate\\Foundation\\Http\\Kernel`类，该类定义了一个将在执行请求之前运行的`bootstrappers` 数组。这些引导程序用来配置异常处理、配置日志、[检测应用程序环境](/docs/laravel/10.x/configuration#environment-configuration)，并执行在实际处理请求之前需要完成的其他任务。通常，这些类处理你无需担心的内部 Laravel 配置。\r\n\r\nHTTP 内核还定义了一个 HTTP [中间件](/docs/laravel/10.x/middleware)列表，所有请求在被应用程序处理之前都必须通过该列表。这些中间件处理读写[HTTP 会话](/docs/laravel/10.x/session) ，确定应用程序是否处于维护模式， [校验 CSRF 令牌](/docs/laravel/10.x/csrf), 等等。我们接下来会做详细的讨论。\r\n\r\nHTTP 内核的`handle`方法的签名非常简单：它接收`Request`接口并返回`Response`接口。把内核想象成一个代表整个应用程序的大黑匣子。向它提供 HTTP 请求，它将返回 HTTP 响应。\r\n\r\n<a name=\"service-providers\"></a>\r\n### 服务提供者\r\n\r\n最重要的内核引导操作之一是为应用程序加载[服务提供者 ](/docs/laravel/10.x/providers)。应用程序的所有服务提供程序都在`config/app.php`文件中的`providers` 数组。\r\n\r\n\n\nLaravel 将遍历这个提供者列表并实例化它们中的每一个。实例化提供程序后，将在所有提供程序上调用`register`方法。然后，一旦所有的提供者都被注册了，就会对每个提供程序调用`boot`方法。服务提供者可能依赖于在执行`boot`方法时注册并可用的每个容器绑定。\r\n\r\n服务提供者负责引导框架的所有不同组件，如数据库、队列、验证和路由组件。基本上，Laravel 提供的每个主要功能都是由服务提供商引导和配置的。由于它们引导和配置框架提供的许多特性，服务提供者是整个 Laravel 引导过程中最重要的部分。\r\n\r\n<a name=\"routing\"></a>\r\n### 路由\r\n\r\n应用程序中最重要的服务提供者之一是`App\\Providers\\RouteServiceProvider`。此服务提供者加载应用程序的`routes`目录中包含的路由文件。继续，打开`RouteServiceProvider`代码，看看它是如何工作的！\r\n\r\n一旦应用程序被引导并且所有服务提供者都被注册，`Request`将被传递给路由器进行调度。路由器将请求发送到路由或控制器，并运行任何路由特定的中间件。\r\n\r\n中间件为过滤或检查进入应用程序的 HTTP 请求提供了一种方便的机制。例如，Laravel 包含一个这样的中间件，用于验证应用程序的用户是否经过身份验证。如果用户未通过身份验证，中间件将用户重定向到登录页。但是，如果用户经过身份验证，中间件将允许请求进一步进入应用程序。一些中间件被分配给应用程序中的所有路由，比如那些在 HTTP 内核的`$middleware`属性中定义的路由，而一些只被分配给特定的路由或路由组。你可以通过阅读完整的[中间件文档](/docs/laravel/10.x/middleware)来了解关于中间件的信息。\r\n\n\n如果请求通过了所有匹配路由分配的中间件，则执行路由或控制器方法，并通过路由的中间件链路返回路由或控制器方法的响应。\r\n\r\n<a name=\"finishing-up\"></a>\r\n### 最后\r\n\r\n一旦路由或控制器方法返回一个响应，该响应将通过路由的中间件返回，从而使应用程序有机会修改或检查传出的响应。\r\n\r\n最后，一旦响应通过中间件返回，HTTP 内核的`handle`方法将返回响应对象，并且`index.php`文件在返回的响应上调用`send`方法。`send`方法将响应内容发送到用户的 Web 浏览器。至此，我们已经完成了整个 Laravel 请求生命周期的旅程！\r\n\r\n<a name=\"focus-on-service-providers\"></a>\r\n## 关注服务提供者\r\n\r\n服务提供者确实是引导 Laravel 应用程序的关键。创建应用程序实例，注册服务提供者，并将请求传递给引导应用程序。就这么简单！\r\n\r\n牢牢掌握服务提供者的构建和其对 Laravel 应用处理机制的原理是非常有价值的。你的应用的默认服务提供会存放在`app/Providers`目录下面。\r\n\r\n默认情况下，`AppServiceProvider`是空白的。这里是用于你添加应用自身的引导处理和服务容器绑定的一个非常棒的地方。在大型项目中，你可能希望创建多个服务提供者，每个服务提供者都为应用程序使用的特定服务提供更细粒度的引导。\r\n\n","p":"docs/lifecycle.html"},{"t":"container (服务容器)","d":"# 服务容器\r\n\r\n- [简介](#introduction)\r\n    - [零配置解决方案](#zero-configuration-resolution)\r\n    - [何时使用容器](#when-to-use-the-container)\r\n- [绑定](#binding)\r\n    - [绑定基础](#binding-basics)\r\n    - [接口到实现的绑定](#binding-interfaces-to-implementations)\r\n    - [上下文绑定](#contextual-binding)\r\n    - [绑定原语](#binding-primitives)\r\n    - [绑定变长参数类型](#binding-typed-variadics)\r\n    - [标签](#tagging)\r\n    - [继承绑定](#extending-bindings)\r\n- [解析](#resolving)\r\n    - [Make 方法](#the-make-method)\r\n    - [自动注入](#automatic-injection)\r\n- [方法调用 & 注入](#method-invocation-and-injection)\r\n- [容器事件](#container-events)\r\n- [PSR-11](#psr-11)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 服务容器是一个用于管理类依赖以及实现依赖注入的强有力工具。依赖注入这个名词表面看起来花哨，实质上是指：通过构造函数，或者某些情况下通过「setter」方法将类依赖「注入」到类中。\r\n\r\n我们来看一个简单的例子：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Repositories\\UserRepository;\r\n    use App\\Models\\User;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 创建一个新的控制器实例\r\n         */\r\n        public function __construct(\r\n            protected UserRepository $users,\r\n        ) {}\r\n\r\n        /**\r\n         * 展示给定用户的信息\r\n         */\r\n        public function show(string $id): View\r\n        {\r\n            $user = $this->users->find($id);\r\n\r\n            return view('user.profile', ['user' => $user]);\r\n        }\r\n    }\r\n\r\n在此示例中，`UserController` 需要从数据源中检索用户。 因此，我们将 **注入** 一个能够检索用户的服务。 在这种情况下，我们的 `UserRepository` 很可能使用 [Eloquent](/docs/laravel/10.x/eloquent) 从数据库中检索用户信息。 然而，由于存储库是注入的，我们可以很容易地用另一个实现替换它。 这种方式的便利之处也体现在：当需要为应用编写测试的时候，我们也可以很轻松地 「模拟」 或者创建一个 `UserRepository` 的伪实现来操作。\r\n\r\n\r\n\r\n深入理解服务容器，对于构建一个强大的、大型的应用，以及对 Laravel 核心本身的贡献都是至关重要的。\r\n\r\n<a name=\"zero-configuration-resolution\"></a>\r\n### 零配置解决方案\r\n\r\n如果一个类没有依赖项或只依赖于其他具体类（而不是接口），则不需要指定容器如何解析该类。例如，你可以将以下代码放在 `routes/web.php` 文件中：\r\n\r\n    <?php\r\n\r\n    class Service\r\n    {\r\n        // ...\r\n    }\r\n\r\n    Route::get('/', function (Service $service) {\r\n        die(get_class($service));\r\n    });\r\n\r\n在这个例子中，点击应用程序的 `/` 路由将自动解析 `Service` 类并将其注入到路由的处理程序中。 这是一个有趣的改变。 这意味着你可以开发应用程序并利用依赖注入，而不必担心臃肿的配置文件。\r\n\r\n很荣幸的通知你，在构建 Laravel 应用程序时，你将要编写的许多类都可以通过容器自动接收它们的依赖关系，包括 [控制器](/docs/laravel/10.x/controllers)、 [事件监听器](/docs/laravel/10.x/events)、 [中间件](/docs/laravel/10.x/middleware) 等等。 此外，你可以在 [队列系统](/docs/laravel/10.x/queues) 的 `handle` 方法中键入提示依赖项。 一旦你尝到了自动和零配置依赖注入的力量，你就会觉得没有它是不可以开发的。\r\n\r\n<a name=\"when-to-use-the-container\"></a>\r\n### 何时使用容器\r\n\r\n得益于零配置解决方案，通常情况下，你只需要在路由、控制器、事件侦听器和其他地方键入提示依赖项，而不必手动与容器打交道。例如，可以在路由定义中键入 `Illuminate\\Http\\Request` 对象，以便轻松访问当前请求的 Request 类。尽管我们不必与容器交互来编写此代码，但它在幕后管理着这些依赖项的注入：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/', function (Request $request) {\r\n        // ...\r\n    });\r\n\r\n在许多情况下，由于自动依赖注入和 [facades](/docs/laravel/10.x/facades) ，你在构建 Laravel 应用程序，而无需手动绑定或解析容器中的任何内容。 **那么，你什么时候会手动与容器打交道呢？** 让我们来看看下面两种情况。\r\n\r\n首先，如果你编写了一个实现接口的类，并希望在路由或类的构造函数上键入该接口的提示，则必须 [告诉容器如何解析该接口](#binding-interfaces-to-implementations)。第二，如果你正在 [编写一个 Laravel 包](/docs/laravel/10.x/packages) 计划与其他 Laravel 开发人员共享，那么你可能需要将包的服务绑定到容器中。\r\n\r\n<a name=\"binding\"></a>\r\n## 绑定\r\n\r\n<a name=\"binding-basics\"></a>\r\n### 基础绑定\r\n\r\n<a name=\"simple-bindings\"></a>\r\n#### 简单绑定\r\n\r\n几乎所有的服务容器绑定都会在 [服务提供者](/docs/laravel/10.x/providers) 中注册，下面示例中的大多数将演示如何在该上下文（服务提供者）中使用容器。\r\n\r\n在服务提供者中，你总是可以通过 `$this->app` 属性访问容器。我们可以使用 `bind` 方法注册一个绑定，将我们希望注册的类或接口名称与返回类实例的闭包一起传递:\r\n\r\n    use App\\Services\\Transistor;\r\n    use App\\Services\\PodcastParser;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n    $this->app->bind(Transistor::class, function (Application $app) {\r\n        return new Transistor($app->make(PodcastParser::class));\r\n    });\r\n\r\n注意，我们接受容器本身作为解析器的参数。然后，我们可以使用容器来解析正在构建的对象的子依赖。\r\n\r\n\r\n\r\n如前所述，你通常会在服务提供者内部与容器进行交互；但是，如果你希望在服务提供者外部与容器进行交互，则可以通过 `App` [facade](/docs/laravel/10.x/facades) 进行:\r\n\r\n    use App\\Services\\Transistor;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    App::bind(Transistor::class, function (Application $app) {\r\n        // ...\r\n    });\r\n\r\n> **技巧**\r\n> 如果类不依赖于任何接口，则不需要将它们绑定到容器中。不需要指示容器如何构建这些对象，因为它可以使用反射自动解析这些对象。\r\n\r\n<a name=\"binding-a-singleton\"></a>\r\n#### 单例的绑定\r\n\r\n`singleton` 方法将类或接口绑定到只应解析一次的容器中。解析单例绑定后，后续调用容器时将返回相同的对象实例：\r\n\r\n    use App\\Services\\Transistor;\r\n    use App\\Services\\PodcastParser;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n    $this->app->singleton(Transistor::class, function (Application $app) {\r\n        return new Transistor($app->make(PodcastParser::class));\r\n    });\r\n\r\n<a name=\"binding-scoped\"></a>\r\n#### 绑定作用域单例\r\n\r\n`scoped` 方法将一个类或接口绑定到容器中，该容器只应在给定的 Laravel 请求 / 作业生命周期内解析一次。虽然该方法与 `singleton` 方法类似，但是当 Laravel 应用程序开始一个新的「生命周期」时， 使用 `scoped` 方法注册的实例 将被刷新，例如当 [Laravel Octane](/docs/laravel/10.x/octane) 工作者处理新请求或 Laravel [队列系统](/docs/laravel/10.x/queues)处理新作业时：\r\n\r\n    use App\\Services\\Transistor;\r\n    use App\\Services\\PodcastParser;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n    $this->app->scoped(Transistor::class, function (Application $app) {\r\n        return new Transistor($app->make(PodcastParser::class));\r\n    });\r\n\r\n\r\n\r\n<a name=\"binding-instances\"></a>\r\n#### 绑定实例\r\n\r\n你也可以使 `instance` 方法将一个现有的对象实例绑定到容器中。给定的实例总会在后续对容器的调用中返回:\r\n\r\n    use App\\Services\\Transistor;\r\n    use App\\Services\\PodcastParser;\r\n\r\n    $service = new Transistor(new PodcastParser);\r\n\r\n    $this->app->instance(Transistor::class, $service);\r\n\r\n<a name=\"binding-interfaces-to-implementations\"></a>\r\n### 将接口绑定实例\r\n\r\n服务容器的一个非常强大的特性是它能够将接口绑定到给定的实例。例如，我们假设有一个 `EventPusher` 接口和一个 `RedisEventPusher` 实例。一旦我们编写了这个接口的 `RedisEventPusher` 实例，我们就可以像这样把它注册到服务容器中:\r\n\r\n    use App\\Contracts\\EventPusher;\r\n    use App\\Services\\RedisEventPusher;\r\n\r\n    $this->app->bind(EventPusher::class, RedisEventPusher::class);\r\n\r\n这条语句告诉容器，当类需要 `EventPusher` 的实例时，它应该注入 `RedisEventPusher`。现在我们可以在由容器解析的类的构造函数中输入 `EventPusher` 接口。记住，控制器、事件监听器、中间件和Laravel应用程序中的各种其他类型的类总是使用容器进行解析的:\r\n\r\n    use App\\Contracts\\EventPusher;\r\n\r\n    /**\r\n     * Create a new class instance.\r\n     */\r\n    public function __construct(\r\n        protected EventPusher $pusher\r\n    ) {}\r\n\r\n<a name=\"contextual-binding\"></a>\r\n### 上下文绑定\r\n> 译者注：所谓「上下文绑定」就是根据上下文进行动态的绑定，指依赖的上下文关系。\r\n\r\n有时你可能有两个类使用相同的接口，但是你希望将不同的实现分别注入到各自的类中。例如，两个控制器可能依赖于 `Illuminate\\Contracts\\Filesystem\\Filesystem` [契约](/docs/laravel/10.x/contracts) 的不同实现。Laravel 提供了一个简单流畅的方式来定义这种行为：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n    use App\\Http\\Controllers\\UploadController;\r\n    use App\\Http\\Controllers\\VideoController;\r\n    use Illuminate\\Contracts\\Filesystem\\Filesystem;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $this->app->when(PhotoController::class)\r\n              ->needs(Filesystem::class)\r\n              ->give(function () {\r\n                  return Storage::disk('local');\r\n              });\r\n\r\n    $this->app->when([VideoController::class, UploadController::class])\r\n              ->needs(Filesystem::class)\r\n              ->give(function () {\r\n                  return Storage::disk('s3');\r\n              });\r\n\r\n\r\n\r\n<a name=\"binding-primitives\"></a>\r\n### 绑定原语\r\n\r\n有时，你可能有一个接收一些注入类的类，但也需要一个注入的原语值，如整数。你可以很容易地使用上下文绑定来，注入类可能需要的任何值:\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    $this->app->when(UserController::class)\r\n              ->needs('$variableName')\r\n              ->give($value);\r\n\r\n有时，类可能依赖于 [标签](#tagging) 实例的数组。使用 `giveTagged` 方法，你可以很容易地注入所有带有该标签的容器绑定:\r\n\r\n    $this->app->when(ReportAggregator::class)\r\n        ->needs('$reports')\r\n        ->giveTagged('reports');\r\n\r\n如果你需要从应用程序的某个配置文件中注入一个值，你可以使用 `giveConfig` 方法:\r\n\r\n    $this->app->when(ReportAggregator::class)\r\n        ->needs('$timezone')\r\n        ->giveConfig('app.timezone');\r\n\r\n<a name=\"binding-typed-variadics\"></a>\r\n### 绑定变长参数类型\r\n\r\n有时，你可能有一个使用可变构造函数参数接收类型对象数组的类：\r\n\r\n    <?php\r\n\r\n    use App\\Models\\Filter;\r\n    use App\\Services\\Logger;\r\n\r\n    class Firewall\r\n    {\r\n        /**\r\n         * 过滤器实例组\r\n         *\r\n         * @var array\r\n         */\r\n        protected $filters;\r\n\r\n        /**\r\n         * 创建一个类实例\r\n         */\r\n        public function __construct(\r\n            protected Logger $logger,\r\n            Filter ...$filters,\r\n        ) {\r\n            $this->filters = $filters;\r\n        }\r\n    }\r\n\r\n使用上下文绑定，你可以通过提供 `give` 方法一个闭包来解决这个依赖，该闭包返回一个已解析的 `Filter`实例数组：\r\n\r\n    $this->app->when(Firewall::class)\r\n              ->needs(Filter::class)\r\n              ->give(function (Application $app) {\r\n                    return [\r\n                        $app->make(NullFilter::class),\r\n                        $app->make(ProfanityFilter::class),\r\n                        $app->make(TooLongFilter::class),\r\n                    ];\r\n              });\r\n\r\n为方便起见，你也可以只提供一个类名数组，以便在 `Firewall` 需要 `Filter` 实例时由容器解析:\r\n\r\n    $this->app->when(Firewall::class)\r\n              ->needs(Filter::class)\r\n              ->give([\r\n                  NullFilter::class,\r\n                  ProfanityFilter::class,\r\n                  TooLongFilter::class,\r\n              ]);\r\n\r\n\r\n\r\n<a name=\"variadic-tag-dependencies\"></a>\r\n#### 变长参数的关联标签\r\n\r\n有时，一个类可能具有类型提示为给定类的可变依赖项（`Report ...$reports`)）。使用 `needs` 和 `giveTagged` 方法，你可以轻松地为给定依赖项注入所有带有该 [标签](#tagging) 的所有容器绑定：\r\n\r\n    $this->app->when(ReportAggregator::class)\r\n        ->needs(Report::class)\r\n        ->giveTagged('reports');\r\n\r\n<a name=\"tagging\"></a>\r\n### 标签\r\n\r\n有时，你可能需要解决所有特定「类别」的绑定。例如，也许你正在构建一个报告分析器，它接收许多不同的 `Report` 接口实现的数组。注册 `Report` 实现后，你可以使用 `tag` 方法为它们分配标签：\r\n\r\n    $this->app->bind(CpuReport::class, function () {\r\n        // ...\r\n    });\r\n\r\n    $this->app->bind(MemoryReport::class, function () {\r\n        // ...\r\n    });\r\n\r\n    $this->app->tag([CpuReport::class, MemoryReport::class], 'reports');\r\n\r\n一旦服务被打上标签，你就可以通过容器的 `tagged` 方法轻松地解析它们：\r\n\r\n    $this->app->bind(ReportAnalyzer::class, function (Application $app) {\r\n        return new ReportAnalyzer($app->tagged('reports'));\r\n    });\r\n\r\n<a name=\"extending-bindings\"></a>\r\n### 继承绑定\r\n\r\n`extend` 方法允许修改已解析的服务。例如，解析服务时，可以运行其他代码来修饰或配置服务。`extend` 方法接受闭包，该闭包应返回修改后的服务作为其唯一参数。闭包接收正在解析的服务和容器实例：\r\n\r\n    $this->app->extend(Service::class, function (Service $service, Application $app) {\r\n        return new DecoratedService($service);\r\n    });\r\n\r\n<a name=\"resolving\"></a>\r\n## 解析\r\n\r\n<a name=\"the-make-method\"></a>\r\n### `make` 方法\r\n\r\n\r\n\r\n你可以使用 `make` 方法从容器中解析出一个类实例。`make` 方法接受你要解析的类或接口的名称：\r\n\r\n```php\r\nuse App\\Services\\Transistor;\r\n\r\n$transistor = $this->app->make(Transistor::class);\r\n```\r\n\r\n如果你的某些类依赖关系无法通过容器解析，请通过将它们作为关联数组传递到 `makeWith` 方法中来注入它们。例如，我们可以手动传递 `Transistor` 服务所需的 `$id` 构造函数参数：\r\n\r\n```php\r\nuse App\\Services\\Transistor;\r\n\r\n$transistor = $this->app->makeWith(Transistor::class, ['id' => 1]);\r\n```\r\n\r\n如果你不在服务提供程序外部的代码位置中，并且没有访问 `$app` 变量的权限，你可以使用 `App` [facade](/docs/laravel/10.x/facades) 或 `app` [helper](/docs/laravel/10.x/helpersmd#method-app) 来从容器中解析出一个类实例：\r\n\r\n\r\n```php\r\nuse App\\Services\\Transistor;\r\nuse Illuminate\\Support\\Facades\\App;\r\n\r\n$transistor = App::make(Transistor::class);\r\n\r\n$transistor = app(Transistor::class);\r\n```\r\n\r\n如果你想将 Laravel 容器实例本身注入到由容器解析的类中，你可以在你的类的构造函数上进行类型提示，指定 `Illuminate\\Container\\Container` 类型：\r\n\r\n\r\n```php\r\nuse Illuminate\\Container\\Container;\r\n\r\n/**\r\n * 创建一个新的类实例。\r\n */\r\npublic function __construct( protected Container $container ) {}\r\n```\r\n\r\n### 自动注入\r\n\r\n或者，你可以在由容器解析的类的构造函数中类型提示依赖项，包括 [控制器](/docs/laravel/10.x/controllers)、[事件监听器](/docs/laravel/10.x/events)、[中间件](/docs/laravel/10.x/middleware) 等。此外，你可以在 [队列作业](/docs/laravel/10.x/queues) 的 `handle` 方法中类型提示依赖项。在实践中，这是大多数对象应该由容器解析的方式。\r\n\r\n例如，你可以在控制器的构造函数中添加一个 repository 的类型提示，然后这个 repository 将会被自动解析并注入类中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Repositories\\UserRepository;\r\n    use App\\Models\\User;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 创建一个控制器实例\r\n         */\r\n        public function __construct(\r\n            protected UserRepository $users,\r\n        ) {}\r\n\r\n        /**\r\n         * 使用给定的 ID 显示 user\r\n         */\r\n        public function show(string $id): User\r\n        {\r\n            $user = $this->users->findOrFail($id);\r\n\r\n            return $user;\r\n        }\r\n    }\r\n\r\n<a name=\"method-invocation-and-injection\"></a>\r\n## 方法调用和注入\r\n\r\n有时你可能希望调用对象实例上的方法，同时允许容器自动注入该方法的依赖项。例如，给定以下类：\r\n\r\n    <?php\r\n\r\n    namespace App;\r\n\r\n    use App\\Repositories\\UserRepository;\r\n\r\n    class UserReport\r\n    {\r\n        /**\r\n         * 生成新的用户报告\r\n         */\r\n        public function generate(UserRepository $repository): array\r\n        {\r\n            return [\r\n                // ...\r\n            ];\r\n        }\r\n    }\r\n\r\n你可以通过容器调用 `generate` 方法，如下所示：\r\n\r\n    use App\\UserReport;\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $report = App::call([new UserReport, 'generate']);\r\n\r\n`call` 方法接受任何可调用的 PHP 方法。容器的 `call` 方法甚至可以用于调用闭包，同时自动注入其依赖项：\r\n\r\n    use App\\Repositories\\UserRepository;\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $result = App::call(function (UserRepository $repository) {\r\n        // ...\r\n    });\r\n\r\n<a name=\"container-events\"></a>\r\n## 容器事件\r\n\r\n服务容器每次解析对象时都会触发一个事件。你可以使用 `resolving` 方法监听此事件：\r\n\r\n    use App\\Services\\Transistor;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n    $this->app->resolving(Transistor::class, function (Transistor $transistor, Application $app) {\r\n        // 当容器解析「Transistor」类型的对象时调用...\r\n    });\r\n\r\n    $this->app->resolving(function (mixed $object, Application $app) {\r\n        // 当容器解析任何类型的对象时调用...\r\n    });\r\n\r\n\r\n\r\n如你所见，正在解析的对象将被传递给回调，从而允许你在对象提供给其使用者之前设置对象的任何其他属性。\r\n\r\n<a name=\"psr-11\"></a>\r\n## PSR-11\r\n\r\nLaravel 的服务容器实现了 [PSR-11](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.) 接口。因此，你可以添加 PSR-11 容器接口的类型提示来获取 Laravel 容器的实例：\r\n\r\n    use App\\Services\\Transistor;\r\n    use Psr\\Container\\ContainerInterface;\r\n\r\n    Route::get('/', function (ContainerInterface $container) {\r\n        $service = $container->get(Transistor::class);\r\n\r\n        // ...\r\n    });\r\n\r\n如果无法解析给定的标识符，将引发异常。如果标识符从未绑定，则异常将是`Psr\\Container\\NotFoundExceptionInterface` 的实例。如果标识符已绑定但无法解析，则将抛出`Psr\\Container\\ContainerExceptionInterface` 的实例。\r\n\r\n","p":"docs/container.html"},{"t":"providers (服务提供者)","d":"\n# 服务提供者\r\n\r\n- [简介](#introduction)\r\n- [编写服务提供者](#writing-service-providers)\r\n    - [注册方法](#the-register-method)\r\n    - [引导方法](#the-boot-method)\r\n- [注册提供者](#registering-providers)\r\n- [延迟加载提供者](#deferred-providers)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n服务提供者是所有 Laravel 应用程序的引导中心。你的应用程序，以及通过服务器引导的 Laravel 核心服务都是通过服务提供器引导。\r\n\r\n但是，「引导」是什么意思呢？通常，我们可以理解为**注册**，比如注册服务容器绑定，事件监听器，中间件，甚至是路由。服务提供者是配置应用程序的中心。\r\n\r\n当你打开 Laravel 的`config/app.php`  文件时，你会看到 `providers`数组。数组中的内容是应用程序要加载的所有服务提供者的类。当然，其中有很多「延迟」提供者，他们并不会在每次请求的时候都加载，只有他们的服务实际被需要时才会加载。\r\n\r\n本篇你将会学到如何编写自己的服务提供者，并将其注册到你的 Laravel 应用程序中。\r\n\r\n> **技巧 **\r\n> 如果你想了解有关 Laravel 如何处理请求并在内部工作的更多信息，请查看有关 Laravel 的文档 [请求生命周期](/docs/laravel/10.x/lifecycle)。\r\n\r\n<a name=\"writing-service-providers\"></a>\r\n## 编写服务提供者\r\n\r\n所有的服务提供者都会继承`Illuminate\\Support\\ServiceProvider`类。大多服务提供者都包含一个 register 和一个`boot`方法。在`register`方法中，你只需要将服务绑定到 `register` 方法中， 你只需要 **将服务绑定到 [服务容器](/docs/laravel/10.x/container)**。而不要尝试在`register`方法中注册任何监听器，路由，或者其他任何功能。\r\n\r\n\n\n使用 Artisan 命令行工具，通过 `make:provider` 命令可以生成一个新的提供者：\r\n\r\n```shell\r\nphp artisan make:provider RiakServiceProvider\r\n```\r\n\r\n<a name=\"the-register-method\"></a>\r\n### 注册方法\r\n\r\n如上所述，在 `register` 方法中，你只需要将服务绑定到 [服务容器](/docs/laravel/9.x/container) 中。而不要尝试在 `register` 方法中注册任何监听器，路由，或者其他任何功能。否则，你可能会意外地使用到尚未加载的服务提供者提供的服务。\r\n\r\n让我们来看一个基础的服务提供者。在任何服务提供者方法中，你总是通过 $app 属性来访问服务容器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Services\\Riak\\Connection;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class RiakServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册应用服务\r\n         */\r\n        public function register(): void\r\n        {\r\n            $this->app->singleton(Connection::class, function (Application $app) {\r\n                return new Connection(config('riak'));\r\n            });\r\n        }\r\n    }\r\n\r\n这个服务提供者只是定义了一个 `register` 方法，并且使用这个方法在服务容器中定义了一个 `Riak\\Connection` 接口。如果你不理解服务容器的工作原理，请查看其 [文档](/docs/laravel/10.x/container).\r\n\r\n<a name=\"bindings 和 singletons 的特性\"></a>\r\n#### bindings 和 singletons 的特性\r\n\r\n如果你的服务提供器注册了许多简单的绑定，你可能想用 `bindings` 和 `singletons` 属性替代手动注册每个容器绑定。当服务提供器被框架加载时，将自动检查这些属性并注册相应的绑定：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Contracts\\DowntimeNotifier;\r\n    use App\\Contracts\\ServerProvider;\r\n    use App\\Services\\DigitalOceanServerProvider;\r\n    use App\\Services\\PingdomDowntimeNotifier;\r\n    use App\\Services\\ServerToolsProvider;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         *  所有需要注册的容器绑定\r\n         *\r\n         * @var array\r\n         */\r\n        public $bindings = [\r\n            ServerProvider::class => DigitalOceanServerProvider::class,\r\n        ];\r\n\r\n        /**\r\n         * 所有需要注册的容器单例\r\n         *\r\n         * @var array\r\n         */\r\n        public $singletons = [\r\n            DowntimeNotifier::class => PingdomDowntimeNotifier::class,\r\n            ServerProvider::class => ServerToolsProvider::class,\r\n        ];\r\n    }\r\n\r\n\n\n<a name=\"引导方法\"></a>\r\n### 引导方法\r\n\r\n如果我们要在服务提供者中注册一个 [视图合成器](/docs/laravel/10.x/views#view-composers) 该怎么做？这就需要用到 `boot` 方法了。**该方法在所有服务提供者被注册以后才会被调用**，这就是说我们可以在其中访问框架已注册的所有其它服务：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class ComposerServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 启动所有的应用服务\r\n         */\r\n        public function boot(): void\r\n        {\r\n            View::composer('view', function () {\r\n                // ...\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"启动方法的依赖注入\"></a>\r\n#### 启动方法的依赖注入\r\n\r\n你可以为服务提供者的 `boot` 方法设置类型提示。[服务容器](/docs/laravel/10.x/container) 会自动注入你所需要的依赖：\r\n\r\n    use Illuminate\\Contracts\\Routing\\ResponseFactory;\r\n\r\n    /**\r\n     * 引导所有的应用服务\r\n     */\r\n    public function boot(ResponseFactory $response): void\r\n    {\r\n        $response->macro('serialized', function (mixed $value) {\r\n            // ...\r\n        });\r\n    }\r\n\r\n<a name=\"注册服务提供者\"></a>\r\n## 注册服务提供者\r\n\r\n所有服务提供者都是通过配置文件 `config/app.php` 进行注册。该文件包含了一个列出所有服务提供者名字的 `providers` 数组，默认情况下，其中列出了所有核心服务提供者，这些服务提供者启动 Laravel 核心组件，比如邮件、队列、缓存等等。\r\n\r\n要注册提供器，只需要将其添加到数组：\r\n\r\n    'providers' => [\r\n        // 其他服务提供者\r\n\r\n        App\\Providers\\ComposerServiceProvider::class,\r\n    ],\r\n\r\n<a name=\"延迟加载提供者\"></a>\r\n## 延迟加载提供者\r\n\r\n如果你的服务提供者 **只** 在 [服务容器](/docs/laravel/10.x/container)中注册，可以选择延迟加载该绑定直到注册绑定的服务真的需要时再加载，延迟加载这样的一个提供者将会提升应用的性能，因为它不会在每次请求时都从文件系统加载。\r\n\r\n\n\nLaravel 编译并保存延迟服务提供者提供的所有服务的列表，以及其服务提供者类的名称。因此，只有当你在尝试解析其中一项服务时，Laravel 才会加载服务提供者。\r\n\r\n要延迟加载提供者，需要实现 `\\Illuminate\\Contracts\\Support\\DeferrableProvider` 接口并置一个 `provides` 方法。这个 `provides` 方法返回该提供者注册的服务容器绑定：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Services\\Riak\\Connection;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n    use Illuminate\\Contracts\\Support\\DeferrableProvider;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class RiakServiceProvider extends ServiceProvider implements DeferrableProvider\r\n    {\r\n        /**\r\n         * 注册所有的应用服务\r\n         */\r\n        public function register(): void\r\n        {\r\n            $this->app->singleton(Connection::class, function (Application $app) {\r\n                return new Connection($app['config']['riak']);\r\n            });\r\n        }\r\n\r\n        /**\r\n         * 获取服务提供者的服务\r\n         *\r\n         * @return array<int, string>\r\n         */\r\n        public function provides(): array\r\n        {\r\n            return [Connection::class];\r\n        }\r\n    }\r\n\n","p":"docs/providers.html"},{"t":"facades (Facades)","d":"# Facades\r\n\r\n- [简介](#introduction)\r\n- [何时使用 Facades](#when-to-use-facades)\r\n    - [Facades Vs 依赖注入](#facades-vs-dependency-injection)\r\n    - [Facades Vs 助手函数](#facades-vs-helper-functions)\r\n- [Facades 工作原理](#how-facades-work)\r\n- [实时 Facades](#real-time-facades)\r\n- [Facade 参考类](#facade-class-reference)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在整个 Laravel 文档中，你将看到通过 Facades 与 Laravel 特性交互的代码示例。Facades 为应用程序的[服务容器](/docs/laravel/10.x/container)中可用的类提供了「静态代理」。在 Laravel 这艘船上有许多 Facades，提供了几乎所有 Laravel 的特征。\r\n\r\nLaravel Facades 充当服务容器中底层类的「静态代理」，提供简洁、富有表现力的好处，同时保持比传统静态方法更多的可测试性和灵活性。如果你不完全理解引擎盖下的 Facades 是如何工作的，那也没问题，跟着流程走，继续学习 Laravel。\r\n\r\nLaravel 的所有 Facades 都在`Illuminate\\Support\\Facades`命名空间中定义。因此，我们可以很容易地访问这样一个 Facades ：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    Route::get('/cache', function () {\r\n        return Cache::get('key');\r\n    });\r\n\r\n在整个 Laravel 文档中，许多示例将使用 Facades 来演示框架的各种特性。\r\n\r\n<a name=\"helper-functions\"></a>\r\n#### 辅助函数\r\n\r\n为了补充 Facades，Laravel 提供了各种全局 「助手函数」，使它更容易与常见的 Laravel 功能进行交互。可以与之交互的一些常用助手函数有`view`, `response`, `url`, `config`等。Laravel 提供的每个助手函数都有相应的特性；但是，在专用的[辅助函数文档](/docs/laravel/10.x/helpers)中有一个完整的列表。\r\n\r\n\r\n\r\n例如，我们可以使用 `response` 函数而不是 `Illuminate\\Support\\Facades\\Response` Facade 生成 JSON 响应。由于「助手函数」是全局可用的，因此无需导入任何类即可使用它们：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Response;\r\n\r\nRoute::get('/users', function () {\r\n    return Response::json([\r\n        // ...\r\n    ]);\r\n});\r\n\r\nRoute::get('/users', function () {\r\n    return response()->json([\r\n        // ...\r\n    ]);\r\n});\r\n```\r\n\r\n<a name=\"when-to-use-facades\"></a>\r\n\r\n## 何时使用 Facades\r\n\r\nFacades 有很多好处。它们提供了简洁、易记的语法，让你可以使用 Laravel 的功能而不必记住必须手动注入或配置的长类名。此外，由于它们独特地使用了 PHP 的动态方法，因此它们易于测试。\r\n\r\n然而，在使用 Facades 时必须小心。Facades 的主要危险是类的「作用域泄漏」。由于 Facades 如此易于使用并且不需要注入，因此让你的类继续增长并在单个类中使用许多 Facades 可能很容易。使用依赖注入，这种潜在问题通过构造函数变得明显，告诉你的类过于庞大。因此，在使用 Facades 时，需要特别关注类的大小，以便它的责任范围保持狭窄。如果你的类变得太大，请考虑将它拆分成多个较小的类。\r\n\r\n<a name=\"facades-vs-dependency-injection\"></a>\r\n\r\n### Facades 与 依赖注入\r\n\r\n依赖注入的主要好处之一是能够替换注入类的实现。这在测试期间很有用，因为你可以注入一个模拟或存根并断言各种方法是否在存根上调用了。\r\n\r\n通常，真正的静态方法是不可能 mock 或 stub 的。无论如何，由于 Facades 使用动态方法对服务容器中解析出来的对象方法的调用进行了代理， 我们也可以像测试注入类实例一样测试 Facades。比如，像下面的路由：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    Route::get('/cache', function () {\r\n        return Cache::get('key');\r\n    });\r\n\r\n使用 Laravel 的 Facade 测试方法，我们可以编写以下测试用例来验证是否 Cache::get 使用我们期望的参数调用了该方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    /**\r\n     *  一个基础功能的测试用例\r\n     */\r\n    public function test_basic_example(): void\r\n    {\r\n        Cache::shouldReceive('get')\r\n             ->with('key')\r\n             ->andReturn('value');\r\n\r\n        $response = $this->get('/cache');\r\n\r\n        $response->assertSee('value');\r\n    }\r\n\r\n<a name=\"facades-vs-helper-functions\"></a>\r\n### Facades Vs 助手函数\r\n\r\n除了 Facades，Laravel 还包含各种「辅助函数」来实现这些常用功能，比如生成视图、触发事件、任务调度或者发送 HTTP 响应。许多辅助函数都有与之对应的 Facade。例如，下面这个 Facades 和辅助函数的作用是一样的：\r\n\r\n    return Illuminate\\Support\\Facades\\View::make('profile');\r\n\r\n    return view('profile');\r\n\r\nFacades 和辅助函数之间没有实际的区别。 当你使用辅助函数时，你可以像测试相应的 Facade 那样进行测试。例如，下面的路由：\r\n\r\n    Route::get('/cache', function () {\r\n        return cache('key');\r\n    });\r\n\r\n在底层实现，辅助函数 cache 实际是调用 Cache 这个 Facade 的 get 方法。因此，尽管我们使用的是辅助函数，我们依然可以带上我们期望的参数编写下面的测试代码来验证该方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    /**\r\n     * 一个基础功能的测试用例\r\n     */\r\n    public function test_basic_example(): void\r\n    {\r\n        Cache::shouldReceive('get')\r\n             ->with('key')\r\n             ->andReturn('value');\r\n\r\n        $response = $this->get('/cache');\r\n\r\n        $response->assertSee('value');\r\n    }\r\n\r\n\r\n\r\n<a name=\"how-facades-work\"></a>\r\n## Facades 工作原理\r\n\r\n在 Laravel 应用程序中，Facades 是一个提供从容器访问对象的类。完成这项工作的部分属于 `Facade` 类。Laravel 的 Facade、以及你创建的任何自定义 Facade，都继承自 `Illuminate\\Support\\Facades\\Facade` 类。\r\n\r\n`Facade` 基类使用 `__callStatic()` 魔术方法将来自 Facade 的调用推迟到从容器解析出对象后。在下面的示例中，调用了 Laravel 缓存系统。看一眼这段代码，人们可能会假设静态的 `get` 方法正在 `Cache` 类上被调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * Show the profile for the given user.\r\n         */\r\n        public function showProfile(string $id): View\r\n        {\r\n            $user = Cache::get('user:'.$id);\r\n\r\n            return view('profile', ['user' => $user]);\r\n        }\r\n    }\r\n\r\n请注意，在文件顶部附近，我们正在「导入」`Cache` Facade。这个 Facade 作为访问 `Illuminate\\Contracts\\Cache\\Factory` 接口底层实现的代理。我们使用 Facade 进行的任何调用都将传递给 Laravel 缓存服务的底层实例。\r\n\r\n如果我们查看 `Illuminate\\Support\\Facades\\Cache` 类，你会发现没有静态方法 `get`：\r\n\r\n    class Cache extends Facade\r\n    {\r\n        /**\r\n         * Get the registered name of the component.\r\n         */\r\n        protected static function getFacadeAccessor(): string\r\n        {\r\n            return 'cache';\r\n        }\r\n    }\r\n\r\n相反，`Cache` Facade 继承了 `Facade` 基类并定义了 `getFacadeAccessor()` 方法。此方法的工作是返回服务容器绑定的名称。当用户引用 `Cache` Facade 上的任何静态方法时，Laravel 会从 [服务容器](/docs/laravel/10.x/container) 中解析 `cache` 绑定并运行该对象请求的方法（在这个例子中就是 `get` 方法）\r\n\r\n\r\n\r\n<a name=\"real-time-facades\"></a>\r\n## 实时 Facades\r\n\r\n使用实时 Facade, 你可以将应用程序中的任何类视为 Facade。为了说明这是如何使用的， 让我们首先看一下一些不使用实时 Facade 的代码。例如，假设我们的 `Podcast` 模型有一个 `publish 方法`。 但是，为了发布 `Podcast`，我们需要注入一个 `Publisher` 实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Contracts\\Publisher;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Podcast extends Model\r\n    {\r\n        /**\r\n         * Publish the podcast.\r\n         */\r\n        public function publish(Publisher $publisher): void\r\n        {\r\n            $this->update(['publishing' => now()]);\r\n\r\n            $publisher->publish($this);\r\n        }\r\n    }\r\n\r\n将 publisher 的实现注入到该方法中，我们可以轻松地测试这种方法，因为我们可以模拟注入的 publisher 。但是，它要求我们每次调用 `publish` 方法时始终传递一个 publisher 实例。 使用实时的 Facades, 我们可以保持同样的可测试性，而不需要显式地通过 `Publisher` 实例。要生成实时 Facade，请在导入类的名称空间中加上 `Facades`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Facades\\App\\Contracts\\Publisher;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Podcast extends Model\r\n    {\r\n        /**\r\n         * Publish the podcast.\r\n         */\r\n        public function publish(): void\r\n        {\r\n            $this->update(['publishing' => now()]);\r\n\r\n            Publisher::publish($this);\r\n        }\r\n    }\r\n\r\n当使用实时 Facade 时， publisher 实现将通过使用 `Facades` 前缀后出现的接口或类名的部分来解决服务容器的问题。在测试时，我们可以使用 Laravel 的内置 Facade 测试辅助函数来模拟这种方法调用：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Models\\Podcast;\r\n    use Facades\\App\\Contracts\\Publisher;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Tests\\TestCase;\r\n\r\n    class PodcastTest extends TestCase\r\n    {\r\n        use RefreshDatabase;\r\n\r\n        /**\r\n         * A test example.\r\n         */\r\n        public function test_podcast_can_be_published(): void\r\n        {\r\n            $podcast = Podcast::factory()->create();\r\n\r\n            Publisher::shouldReceive('publish')->once()->with($podcast);\r\n\r\n            $podcast->publish();\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"facade-class-reference\"></a>\r\n## Facade 类参考\r\n\r\n在下面你可以找到每个 facade 类及其对应的底层类。这是一个快速查找给定 facade 类的 API 文档的工具。[服务容器绑定](/docs/laravel/10.x/container) 的关键信息也包含在内。\r\n\r\n<div class=\"overflow-auto\">\r\n\r\nFacade  |  Class  |  Service Container Binding|\r\n------------- | ------------- | -------------|\r\nApp  |  [Illuminate\\Foundation\\Application](https://laravel.com/api/10.x/Illuminate/Foundation/Application.html)  |  `app`|\r\nArtisan  |  [Illuminate\\Contracts\\Console\\Kernel](https://laravel.com/api/10.x/Illuminate/Contracts/Console/Kernel.html)  |  `artisan`|\r\nAuth  |  [Illuminate\\Auth\\AuthManager](https://laravel.com/api/10.x/Illuminate/Auth/AuthManager.html)  |  `auth`|\r\nAuth (Instance)  |  [Illuminate\\Contracts\\Auth\\Guard](https://laravel.com/api/10.x/Illuminate/Contracts/Auth/Guard.html)  |  `auth.driver`|\r\nBlade  |  [Illuminate\\View\\Compilers\\BladeCompiler](https://laravel.com/api/10.x/Illuminate/View/Compilers/BladeCompiler.html)  |  `blade.compiler`|\r\nBroadcast  |  [Illuminate\\Contracts\\Broadcasting\\Factory](https://laravel.com/api/10.x/Illuminate/Contracts/Broadcasting/Factory.html)  |  &nbsp;|\r\nBroadcast (Instance)  |  [Illuminate\\Contracts\\Broadcasting\\Broadcaster](https://laravel.com/api/10.x/Illuminate/Contracts/Broadcasting/Broadcaster.html)  |  &nbsp;|\r\nBus  |  [Illuminate\\Contracts\\Bus\\Dispatcher](https://laravel.com/api/10.x/Illuminate/Contracts/Bus/Dispatcher.html)  |  &nbsp;|\r\nCache  |  [Illuminate\\Cache\\CacheManager](https://laravel.com/api/10.x/Illuminate/Cache/CacheManager.html)  |  `cache`|\r\nCache (Instance)  |  [Illuminate\\Cache\\Repository](https://laravel.com/api/10.x/Illuminate/Cache/Repository.html)  |  `cache.store`|\r\nConfig  |  [Illuminate\\Config\\Repository](https://laravel.com/api/10.x/Illuminate/Config/Repository.html)  |  `config`|\r\nCookie  |  [Illuminate\\Cookie\\CookieJar](https://laravel.com/api/10.x/Illuminate/Cookie/CookieJar.html)  |  `cookie`|\r\nCrypt  |  [Illuminate\\Encryption\\Encrypter](https://laravel.com/api/10.x/Illuminate/Encryption/Encrypter.html)  |  `encrypter`|\r\nDate  |  [Illuminate\\Support\\DateFactory](https://laravel.com/api/10.x/Illuminate/Support/DateFactory.html)  |  `date`|\r\nDB  |  [Illuminate\\Database\\DatabaseManager](https://laravel.com/api/10.x/Illuminate/Database/DatabaseManager.html)  |  `db`|\r\nDB (Instance)  |  [Illuminate\\Database\\Connection](https://laravel.com/api/10.x/Illuminate/Database/Connection.html)  |  `db.connection`|\r\nEvent  |  [Illuminate\\Events\\Dispatcher](https://laravel.com/api/10.x/Illuminate/Events/Dispatcher.html)  |  `events`|\r\nFile  |  [Illuminate\\Filesystem\\Filesystem](https://laravel.com/api/10.x/Illuminate/Filesystem/Filesystem.html)  |  `files`|\r\nGate  |  [Illuminate\\Contracts\\Auth\\Access\\Gate](https://laravel.com/api/10.x/Illuminate/Contracts/Auth/Access/Gate.html)  |  &nbsp;|\r\nHash  |  [Illuminate\\Contracts\\Hashing\\Hasher](https://laravel.com/api/10.x/Illuminate/Contracts/Hashing/Hasher.html)  |  `hash`|\r\nHttp  |  [Illuminate\\Http\\Client\\Factory](https://laravel.com/api/10.x/Illuminate/Http/Client/Factory.html)  |  &nbsp;|\r\nLang  |  [Illuminate\\Translation\\Translator](https://laravel.com/api/10.x/Illuminate/Translation/Translator.html)  |  `translator`|\r\nLog  |  [Illuminate\\Log\\LogManager](https://laravel.com/api/10.x/Illuminate/Log/LogManager.html)  |  `log`|\r\nMail  |  [Illuminate\\Mail\\Mailer](https://laravel.com/api/10.x/Illuminate/Mail/Mailer.html)  |  `mailer`|\r\nNotification  |  [Illuminate\\Notifications\\ChannelManager](https://laravel.com/api/10.x/Illuminate/Notifications/ChannelManager.html)  |  &nbsp;|\r\nPassword  |  [Illuminate\\Auth\\Passwords\\PasswordBrokerManager](https://laravel.com/api/10.x/Illuminate/Auth/Passwords/PasswordBrokerManager.html)  |  `auth.password`|\r\nPassword (Instance)  |  [Illuminate\\Auth\\Passwords\\PasswordBroker](https://laravel.com/api/10.x/Illuminate/Auth/Passwords/PasswordBroker.html)  |  `auth.password.broker`|\r\nPipeline (Instance)  |  [Illuminate\\Pipeline\\Pipeline](https://laravel.com/api/10.x/Illuminate/Pipeline/Pipeline.html)  |  &nbsp;|\r\nQueue  |  [Illuminate\\Queue\\QueueManager](https://laravel.com/api/10.x/Illuminate/Queue/QueueManager.html)  |  `queue`|\r\nQueue (Instance)  |  [Illuminate\\Contracts\\Queue\\Queue](https://laravel.com/api/10.x/Illuminate/Contracts/Queue/Queue.html)  |  `queue.connection`|\r\nQueue (Base Class)  |  [Illuminate\\Queue\\Queue](https://laravel.com/api/10.x/Illuminate/Queue/Queue.html)  |  &nbsp;|\r\nRedirect  |  [Illuminate\\Routing\\Redirector](https://laravel.com/api/10.x/Illuminate/Routing/Redirector.html)  |  `redirect`|\r\nRedis  |  [Illuminate\\Redis\\RedisManager](https://laravel.com/api/10.x/Illuminate/Redis/RedisManager.html)  |  `redis`|\r\nRedis (Instance)  |  [Illuminate\\Redis\\Connections\\Connection](https://laravel.com/api/10.x/Illuminate/Redis/Connections/Connection.html)  |  `redis.connection`|\r\nRequest  |  [Illuminate\\Http\\Request](https://laravel.com/api/10.x/Illuminate/Http/Request.html)  |  `request`|\r\nResponse  |  [Illuminate\\Contracts\\Routing\\ResponseFactory](https://laravel.com/api/10.x/Illuminate/Contracts/Routing/ResponseFactory.html)  |  &nbsp;|\r\nResponse (Instance)  |  [Illuminate\\Http\\Response](https://laravel.com/api/10.x/Illuminate/Http/Response.html)  |  &nbsp;|\r\nRoute  |  [Illuminate\\Routing\\Router](https://laravel.com/api/10.x/Illuminate/Routing/Router.html)  |  `router`|\r\nSchema  |  [Illuminate\\Database\\Schema\\Builder](https://laravel.com/api/10.x/Illuminate/Database/Schema/Builder.html)  |  &nbsp;|\r\nSession  |  [Illuminate\\Session\\SessionManager](https://laravel.com/api/10.x/Illuminate/Session/SessionManager.html)  |  `session`|\r\nSession (Instance)  |  [Illuminate\\Session\\Store](https://laravel.com/api/10.x/Illuminate/Session/Store.html)  |  `session.store`|\r\nStorage  |  [Illuminate\\Filesystem\\FilesystemManager](https://laravel.com/api/10.x/Illuminate/Filesystem/FilesystemManager.html)  |  `filesystem`|\r\nStorage (Instance)  |  [Illuminate\\Contracts\\Filesystem\\Filesystem](https://laravel.com/api/10.x/Illuminate/Contracts/Filesystem/Filesystem.html)  |  `filesystem.disk`|\r\nURL  |  [Illuminate\\Routing\\UrlGenerator](https://laravel.com/api/10.x/Illuminate/Routing/UrlGenerator.html)  |  `url`|\r\nValidator  |  [Illuminate\\Validation\\Factory](https://laravel.com/api/10.x/Illuminate/Validation/Factory.html)  |  `validator`|\r\nValidator (Instance)  |  [Illuminate\\Validation\\Validator](https://laravel.com/api/10.x/Illuminate/Validation/Validator.html)  |  &nbsp;|\r\nView  |  [Illuminate\\View\\Factory](https://laravel.com/api/10.x/Illuminate/View/Factory.html)  |  `view`|\r\nView (Instance)  |  [Illuminate\\View\\View](https://laravel.com/api/10.x/Illuminate/View/View.html)  |  &nbsp;|\r\nVite  |  [Illuminate\\Foundation\\Vite](https://laravel.com/api/10.x/Illuminate/Foundation/Vite.html)  |  &nbsp;|\r\n\r\n</div>\r\n\r\n","p":"docs/facades.html"},{"t":"routing (路由)","d":"# 路由\r\n\r\n- [基本路由](#basic-routing)\r\n    - [路由重定向](#redirect-routes)\r\n    - [路由视图](#view-routes)\r\n    - [route:list 命令](#the-route-list)\r\n- [路由参数](#route-parameters)\r\n    - [必选参数](#required-parameters)\r\n    - [可选参数](#parameters-optional-parameters)\r\n    - [正则约束](#parameters-regular-expression-constraints)\r\n- [路由命名](#named-routes)\r\n- [路由分组](#route-groups)\r\n    - [中间件](#route-group-middleware)\r\n    - [Controllers](#route-group-controllers)\r\n    - [子域名路由](#route-group-subdomain-routing)\r\n    - [路由前缀](#route-group-prefixes)\r\n    - [路由前缀命名](#route-group-name-prefixes)\r\n- [路由模型绑定](#route-model-binding)\r\n    - [隐式绑定](#implicit-binding)\r\n    - [隐式枚举绑定](#implicit-enum-binding)\r\n    - [显式绑定](#explicit-binding)\r\n- [回退路由](#fallback-routes)\r\n- [限流](#rate-limiting)\r\n    - [定义限流器](#defining-rate-limiters)\r\n    - [独立访客和认证用户的限流](#attaching-rate-limiters-to-routes)\r\n- [伪造表单方法](#form-method-spoofing)\r\n- [访问当前路由](#accessing-the-current-route)\r\n- [跨源资源共享 (CORS)](#cors)\r\n- [路由缓存](#route-caching)\r\n\r\n<a name=\"basic-routing\"></a>\r\n## 基本路由\r\n\r\n最基本的 Laravel 路由接受一个 URI 和一个闭包，提供了一个简单优雅的方法来定义路由和行为，而不需要复杂的路由配置文件：\r\n\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    Route::get('/greeting', function () {\r\n        return 'Hello World';\r\n    });\r\n\r\n<a name=\"the-default-route-files\"></a>\r\n#### 默认路由文件\r\n\r\n所有 Laravel 路由都定义在你的路由文件中，它位于 `routes` 目录。这些文件会被你的应用程序中的 `App\\Providers\\RouteServiceProvider` 自动加载。`routes/web.php` 文件用于定义 web 界面的路由。这些路由被分配给 `web` 中间件组，它提供了 会话状态和 CSRF 保护等功能。定义在 `routes/api.php` 中的路由都是无状态的，并且被分配了 `api` 中间件组。\r\n\r\n对于大多数应用程序，都是以在 `routes/web.php` 文件定义路由开始的。可以通过在浏览器中输入定义的路由 URL 来访问 `routes/web.php` 中定义的路由。例如，你可以在浏览器中输入 `http://example.com/user` 来访问以下路由：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    Route::get('/user', [UserController::class, 'index']);\r\n\r\n\r\n\r\n定义在 `routes/api.php` 文件中的路由是被 `RouteServiceProvider` 嵌套在一个路由组内。 在这个路由组内，将自动应用 `/api` URI 前缀，所以你无需手动将其应用于文件中的每个路由。你可以通过修改 `RouteServiceProvider` 类来修改前缀和其他路由组选项。\r\n\r\n<a name=\"available-router-methods\"></a>\r\n#### 可用的路由方法\r\n\r\n路由器允许你注册能响应任何 HTTP 请求的路由\r\n\r\n    Route::get($uri, $callback);\r\n    Route::post($uri, $callback);\r\n    Route::put($uri, $callback);\r\n    Route::patch($uri, $callback);\r\n    Route::delete($uri, $callback);\r\n    Route::options($uri, $callback);\r\n\r\n有的时候你可能需要注册一个可响应多个 HTTP 请求的路由，这时你可以使用 `match` 方法，也可以使用 `any` 方法注册一个实现响应所有 HTTP 请求的路由：\r\n\r\n    Route::match(['get', 'post'], '/', function () {\r\n        // ...\r\n    });\r\n\r\n    Route::any('/', function () {\r\n        // ...\r\n    });\r\n\r\n> **技巧**\r\n> 当定义多个相同路由时，使用 `get`， `post`， `put`， `patch`， `delete`， 和 `options` 方法的路由应该在使用 `any`， `match`， 和 `redirect` 方法的路由之前定义，这样可以确保请求与正确的路由匹配。\r\n\r\n<a name=\"dependency-injection\"></a>\r\n#### 依赖注入\r\n\r\n你可以在路由的回调方法中，以形参的方式声明路由所需要的任何依赖项。这些依赖会被 Laravel 的 [容器](/docs/laravel/10.x/container) 自动解析并注入。 例如，你可以在闭包中声明 `Illuminate\\Http\\Request` 类， 让当前的 HTTP 请求自动注入依赖到你的路由回调中：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/users', function (Request $request) {\r\n        // ...\r\n    });\r\n\r\n\r\n\r\n<a name=\"csrf-protection\"></a>\r\n#### CSRF 保护\r\n\r\n请记住，任何指向`POST`、`PUT`、`PATCH` 或 `DELETE` 路由(在 `web` 路由文件中定义)的 HTML 表单都应该包含 CSRF 令牌字，否则请求会被拒绝。更多 CSRF 保护的相关信息请阅读[CSRF 文档](/docs/laravel/10.x/csrf)：\r\n\r\n    <form method=\"POST\" action=\"/profile\">\r\n        @csrf\r\n        ...\r\n    </form>\r\n\r\n<a name=\"redirect-routes\"></a>\r\n### 重定向路由\r\n\r\n如果要定义一个重定向到另一个 URI 的路由，可以使用 `Route::redirect` 方法。这个方法可以快速的实现重定向，而不再需要去定义完整的路由或者控制器：\r\n\r\n    Route::redirect('/here', '/there');\r\n\r\n默认情况下，`Route::redirect` 返回 `302` 状态码。你可以使用可选的第三个参数自定义状态码：\r\n\r\n    Route::redirect('/here', '/there', 301);\r\n\r\n或者，你也可以使用 `Route::permanentRedirect` 方法返回 `301`状态码：\r\n\r\n    Route::permanentRedirect('/here', '/there');\r\n\r\n> **警告**  \r\n> 在重定向路由中使用路由参数时，以下参数由 Laravel 保留，不能使用：`destination` 和 `status`。\r\n\r\n<a name=\"view-routes\"></a>\r\n### 视图路由\r\n\r\n如果你的路由只需返回一个[视图](/docs/laravel/10.x/views)，你可以使用 `Route::view` 方法。就像 `redirect` 方法，该方法提供了一个让你不必定义完整路由或控制器的便捷操作。这个`view`方法的第一个参数是URI，第二个参数为视图名称。此外，你也可以在可选的第三个参数中传入数组，将数组的数据传递给视图：\r\n\r\n    Route::view('/welcome', 'welcome');\r\n\r\n    Route::view('/welcome', 'welcome', ['name' => 'Taylor']);\r\n\r\n> **警告**  \r\n> 在视图路由中使用参数时，下列参数由 Laravel 保留，不能使用：`view`、`data`, `status` 及 `headers`。\r\n\r\n\r\n<a name=\"the-route-list\"></a>\r\n### route:list 命令\r\n\r\n使用 `route:list` Artisan命令可以轻松提供应用程序定义的所有路线的概述：\r\n\r\n```shell\r\nphp artisan route:list\r\n```\r\n\r\n正常情况下，`route:list`不会显示分配给路由的中间件信息；但是你可以通过在命令中添加 `-v` 选项 来显示路由中的中间件信息：\r\n\r\n```shell\r\nphp artisan route:list -v\r\n```\r\n\r\n你也可以通过 `--path` 来显示指定的 URL 开头的路由：\r\n\r\n```shell\r\nphp artisan route:list --path=api\r\n```\r\n\r\n此外，在执行 `route:list` 命令时，可以通过提供 `--except vendor` 选项来隐藏由第三方包定义的任何路由：\r\n\r\n```shell\r\nphp artisan route:list --except-vendor\r\n```\r\n\r\n同理，也可以通过在执行 `route:list` 命令时提供 `--only vendor` 选项来显示由第三方包定义的路由：\r\n\r\n```shell\r\nphp artisan route:list --only-vendor\r\n```\r\n\r\n<a name=\"route-parameters\"></a>\r\n## 路由参数\r\n\r\n<a name=\"required-parameters\"></a>\r\n### 必需参数\r\n\r\n有时你将需要捕获路由内的 URI 段。例如，你可能需要从 URL 中捕获用户的 ID。你可以通过定义路由参数来做到这一点：\r\n\r\n    Route::get('/user/{id}', function (string $id) {\r\n        return 'User '.$id;\r\n    });\r\n\r\n也可以根据你的需要在路由中定义多个参数：\r\n\r\n    Route::get('/posts/{post}/comments/{comment}', function (string $postId, string $commentId) {\r\n        // ...\r\n    });\r\n\r\n路由的参数通常都会被放在 `{}` ，并且参数名只能为字母。下划线 (`_`) 也可以用于路由参数名中。路由参数会按路由定义的顺序依次注入到路由回调或者控制器中，而不受回调或者控制器的参数名称的影响。\r\n\r\n\r\n\r\n<a name=\"parameters-and-dependency-injection\"></a>\r\n#### 必填参数\r\n\r\n如果你的路由具有依赖关系，而你希望 Laravel 服务容器自动注入到路由的回调中，则应在依赖关系之后列出路由参数：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/{id}', function (Request $request, string $id) {\r\n        return 'User '.$id;\r\n    });\r\n\r\n<a name=\"parameters-optional-parameters\"></a>\r\n### 可选参数\r\n\r\n有时，你可能需要指定一个路由参数，但你希望这个参数是可选的。你可以在参数后面加上 `?` 标记来实现，但前提是要确保路由的相应变量有默认值：\r\n\r\n    Route::get('/user/{name?}', function (string $name = null) {\r\n        return $name;\r\n    });\r\n\r\n    Route::get('/user/{name?}', function (string $name = 'John') {\r\n        return $name;\r\n    });\r\n\r\n<a name=\"parameters-regular-expression-constraints\"></a>\r\n### 正则表达式约束\r\n\r\n你可以使用路由实例上的 `where` 方法来限制路由参数的格式。 `where` 方法接受参数的名称和定义如何约束参数的正则表达式：\r\n\r\n    Route::get('/user/{name}', function (string $name) {\r\n        // ...\r\n    })->where('name', '[A-Za-z]+');\r\n\r\n    Route::get('/user/{id}', function (string $id) {\r\n        // ...\r\n    })->where('id', '[0-9]+');\r\n\r\n    Route::get('/user/{id}/{name}', function (string $id, string $name) {\r\n        // ...\r\n    })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);\r\n\r\n为方便起见，一些常用的正则表达式模式具有帮助方法，可让你快速将模式约束添加到路由：\r\n\r\n    Route::get('/user/{id}/{name}', function (string $id, string $name) {\r\n        // ...\r\n    })->whereNumber('id')->whereAlpha('name');\r\n\r\n    Route::get('/user/{name}', function (string $name) {\r\n        // ...\r\n    })->whereAlphaNumeric('name');\r\n\r\n    Route::get('/user/{id}', function (string $id) {\r\n        // ...\r\n    })->whereUuid('id');\r\n\r\n    Route::get('/user/{id}', function (string $id) {\r\n        //\r\n    })->whereUlid('id');\r\n\r\n    Route::get('/category/{category}', function (string $category) {\r\n        // ...\r\n    })->whereIn('category', ['movie', 'song', 'painting']);\r\n\r\n\r\n\r\n如果传入请求与路由模式约束不匹配，将返回 404 HTTP 响应。\r\n\r\n<a name=\"parameters-global-constraints\"></a>\r\n#### 全局约束\r\n\r\n如果你希望路由参数始终受给定正则表达式的约束，你可以使用 `pattern` 方法。 你应该在 `App\\Providers\\RouteServiceProvider` 类的 `boot` 方法中定义这些模式：\r\n\r\n    /**\r\n     * 定义路由模型绑定、模式筛选器等。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Route::pattern('id', '[0-9]+');\r\n    }\r\n\r\n一旦定义了模式，它就会自动应用到使用该参数名称的所有路由：\r\n\r\n    Route::get('/user/{id}', function (string $id) {\r\n        // 仅当 {id} 是数字时执行。。。\r\n    });\r\n\r\n<a name=\"parameters-encoded-forward-slashes\"></a>\r\n#### 编码正斜杠\r\n\r\nLaravel 路由组件允许除 `/` 之外的所有字符出现在路由参数值中。 你必须使用 `where` 条件正则表达式明确允许 `/` 成为占位符的一部分：\r\n\r\n    Route::get('/search/{search}', function (string $search) {\r\n        return $search;\r\n    })->where('search', '.*');\r\n\r\n> 注意：仅在最后一个路由段中支持编码的正斜杠。\r\n\r\n<a name=\"named-routes\"></a>\r\n## 命名路由\r\n\r\n命名路由允许为特定路由方便地生成 URL 或重定向。通过将 `name` 方法链接到路由定义上，可以指定路由的名称：\r\n\r\n    Route::get('/user/profile', function () {\r\n        // ...\r\n    })->name('profile');\r\n\r\n你还可以为控制器操作指定路由名称：\r\n\r\n    Route::get(\r\n        '/user/profile',\r\n        [UserProfileController::class, 'show']\r\n    )->name('profile');\r\n\r\n> 注意：路由名称应始终是唯一的。\r\n\r\n<a name=\"generating-urls-to-named-routes\"></a>\r\n\r\n\r\n#### 生成命名路由的 URL\r\n\r\n一旦你为给定的路由分配了一个名字，你可以在通过 Laravel 的 `route` 和 `redirect` 辅助函数生成 URL 或重定向时使用该路由的名称：\r\n\r\n    // 生成URL。。。\r\n    $url = route('profile');\r\n\r\n    // 生成重定向。。。\r\n    return redirect()->route('profile');\r\n\r\n    return to_route('profile');\r\n\r\n如果命名路由定义了参数，你可以将参数作为第二个参数传递给 `route` 函数。 给定的参数将自动插入到生成的 URL 的正确位置：\r\n\r\n    Route::get('/user/{id}/profile', function (string $id) {\r\n        // ...\r\n    })->name('profile');\r\n\r\n    $url = route('profile', ['id' => 1]);\r\n\r\n如果你在数组中传递其他参数，这些键 / 值对将自动添加到生成的 URL 的查询字符串中：\r\n\r\n    Route::get('/user/{id}/profile', function (string $id) {\r\n        // ...\r\n    })->name('profile');\r\n\r\n    $url = route('profile', ['id' => 1, 'photos' => 'yes']);\r\n\r\n    // /user/1/profile?photos=yes\r\n\r\n> 技巧：有时，你可能希望为 URL 参数指定请求范围的默认值，例如当前语言环境。 为此，你可以使用 [`URL::defaults` 方法](/docs/laravel/10.x/urlsmd/14854#default-values).\r\n\r\n<a name=\"inspecting-the-current-route\"></a>\r\n#### 检查当前路由\r\n\r\n如果你想确定当前请求是否路由到给定的命名路由，你可以在 Route 实例上使用 `named` 方法。 例如，你可以从路由中间件检查当前路由名称：\r\n\r\n\r\n    /**\r\n     * 处理传入请求。\r\n      * @param  \\Illuminate\\Http\\Request  $request\r\n      * @param  \\Closure  $next\r\n      * @return mixed\r\n\t */\r\n    public function handle(Request $request, Closure $next): Response\r\n    {\r\n        if ($request->route()->named('profile')) {\r\n            // ...\r\n        }\r\n\r\n        return $next($request);\r\n    }\r\n\r\n\r\n\r\n<a name=\"route-groups\"></a>\r\n## 路由组\r\n\r\n路由组允许你共享路由属性，例如中间件，而无需在每个单独的路由上定义这些属性。\r\n\r\n嵌套组尝试智能地将属性与其父组 \"合并\"。中间件和 `where` 条件合并，同时附加名称和前缀。 URI 前缀中的命名空间分隔符和斜杠会在适当的地方自动添加。\r\n\r\n<a name=\"route-group-middleware\"></a>\r\n### 路由中间件\r\n\r\n要将 [中间件](/docs/laravel/10.x/middleware) 分配给组内的所有路由，你可以在定义组之前使用 `middleware` 方法。 中间件按照它们在数组中列出的顺序执行：\r\n\r\n    Route::middleware(['first', 'second'])->group(function () {\r\n        Route::get('/', function () {\r\n            // 使用第一个和第二个中间件。。。\r\n        });\r\n\r\n        Route::get('/user/profile', function () {\r\n            // 使用第一个和第二个中间件。。。\r\n        });\r\n    });\r\n\r\n<a name=\"route-group-controllers\"></a>\r\n### 控制器\r\n\r\n如果一组路由都使用相同的 [控制器](/docs/laravel/10.x/controllers), 你可以使用 `controller` 方法为组内的所有路由定义公共控制器。然后，在定义路由时，你只需要提供它们调用的控制器方法：\r\n\r\n    use App\\Http\\Controllers\\OrderController;\r\n\r\n    Route::controller(OrderController::class)->group(function () {\r\n        Route::get('/orders/{id}', 'show');\r\n        Route::post('/orders', 'store');\r\n    });\r\n\r\n<a name=\"route-group-subdomain-routing\"></a>\r\n### 子域路由\r\n\r\n路由组也可以用来处理子域路由。子域可以像路由 uri 一样被分配路由参数，允许你捕获子域的一部分以便在路由或控制器中使用。子域可以在定义组之前调用 `domain` 方法来指定:\r\n\r\n    Route::domain('{account}.example.com')->group(function () {\r\n        Route::get('user/{id}', function (string $account, string $id) {\r\n            // ...\r\n        });\r\n    });\r\n\r\n> 注意：为了确保子域路由是可以访问的，你应该在注册根域路由之前注册子域路由。这将防止根域路由覆盖具有相同 URI 路径的子域路由。\r\n\r\n\r\n\r\n<a name=\"route-group-prefixes\"></a>\r\n### 路由前缀\r\n\r\n`prefix` 方法可以用给定的 URI 为组中的每个路由做前缀。例如，你可能想要在组内的所有路由 uri 前面加上 `admin` 前缀：\r\n\r\n    Route::prefix('admin')->group(function () {\r\n        Route::get('/users', function () {\r\n            // 对应 \"/admin/users\" 的 URL\r\n        });\r\n    });\r\n\r\n<a name=\"route-group-name-prefixes\"></a>\r\n### 路由名称前缀\r\n\r\n`name` 方法可以用给定字符串作为组中的每个路由名的前缀。例如，你可能想要用 `admin` 作为所有分组路由的前缀。因为给定字符串的前缀与指定的路由名完全一致，所以我们一定要提供末尾 `.` 字符在前缀中：\r\n\r\n    Route::name('admin.')->group(function () {\r\n        Route::get('/users', function () {\r\n            // 被分配的路由名为：\"admin.users\"\r\n        })->name('users');\r\n    });\r\n\r\n<a name=\"route-model-binding\"></a>\r\n## 路由模型绑定\r\n\r\n将模型 ID 注入到路由或控制器操作时，你通常会查询数据库以检索与该 ID 对应的模型。Laravel 路由模型绑定提供了一种方便的方法来自动将模型实例直接注入到你的路由中。例如，你可以注入与给定 ID 匹配的整个 `User` 模型实例，而不是注入用户的 ID。\r\n\r\n<a name=\"implicit-binding\"></a>\r\n### 隐式绑定\r\n\r\nLaravel 自动解析定义在路由或控制器操作中的 Eloquent 模型，其类型提示的变量名称与路由段名称匹配。例如：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}', function (User $user) {\r\n        return $user->email;\r\n    });\r\n\r\n\r\n\r\n由于 `$user` 变量被类型提示为 `App\\Models\\User` Eloquent 模型，并且变量名称与 `{user}` URI 段匹配，Laravel 将自动注入 ID 匹配相应的模型实例 来自请求 URI 的值。如果在数据库中没有找到匹配的模型实例，将自动生成 404 HTTP 响应。\r\n\r\n当然，使用控制器方法时也可以使用隐式绑定。同样，请注意 `{user}` URI 段与控制器中的 `$user` 变量匹配，该变量包含 `App\\Models\\User` 类型提示：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n    use App\\Models\\User;\r\n\r\n    // 路由定义。。。\r\n    Route::get('/users/{user}', [UserController::class, 'show']);\r\n\r\n    // 定义控制器方法。。。\r\n    public function show(User $user)\r\n    {\r\n        return view('user.profile', ['user' => $user]);\r\n    }\r\n\r\n<a name=\"implicit-soft-deleted-models\"></a>\r\n#### 软删除模型\r\n\r\n通常，隐式模型绑定不会检索已 [软删除](/docs/laravel/10.x/eloquent#soft-deleting) 的模型。但是，你可以通过将 `withTrashed` 方法链接到你的路由定义来指示隐式绑定来检索这些模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}', function (User $user) {\r\n        return $user->email;\r\n    })->withTrashed();\r\n\r\n<a name=\"customizing-the-key\"></a>\r\n<a name=\"customizing-the-default-key-name\"></a>\r\n#### 自定义密钥\r\n\r\n有时你可能希望使用 `id` 外的列来解析 Eloquent 模型。为此，你可以在路由参数定义中指定列：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    Route::get('/posts/{post:slug}', function (Post $post) {\r\n        return $post;\r\n    });\r\n\r\n如果你希望模型绑定在检索给定模型类时始终使用 `id` 以外的数据库列，则可以覆盖 Eloquent 模型上的 `getRouteKeyName` 方法：\r\n\r\n    /**\r\n     * 获取模型的路线密钥。\r\n     */\r\n    public function getRouteKeyName(): string\r\n    {\r\n        return 'slug';\r\n    }\r\n\r\n<a name=\"implicit-model-binding-scoping\"></a>\r\n#### 自定义键和范围\r\n\r\n当在单个路由定义中隐式绑定多个 Eloquent 模型时，你可能希望限定第二个 Eloquent 模型的范围，使其必须是前一个 Eloquent 模型的子模型。例如，考虑这个通过 slug 为特定用户检索博客文章的路由定义：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {\r\n        return $post;\r\n    });\r\n\r\n当使用自定义键控隐式绑定作为嵌套路由参数时，Laravel 将自动限定查询范围以通过其父级检索嵌套模型，使用约定来猜测父级上的关系名称。 在这种情况下，假设 `User` 模型有一个名为 `posts` 的关系（路由参数名称的复数形式），可用于检索 `Post` 模型。\r\n\r\n如果你愿意，即使未提供自定义键，你也可以指示 Laravel 限定「子」绑定的范围。为此，你可以在定义路由时调用 `scopeBindings` 方法：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\r\n        return $post;\r\n    })->scopeBindings();\r\n\r\n或者，你可以指示整个路由定义组使用范围绑定：\r\n\r\n    Route::scopeBindings()->group(function () {\r\n        Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\r\n            return $post;\r\n        });\r\n    });\r\n\r\n类似地，你可以通过调用 `withoutScopedBindings` 方法来明确的指示 Laravel 不做作用域绑定：\r\n\r\n    Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {\r\n        return $post;\r\n    })->withoutScopedBindings();\r\n\r\n<a name=\"customizing-missing-model-behavior\"></a>\r\n#### 自定义缺失模型行为\r\n\r\n通常，如果未找到隐式绑定模型，则会生成 404 HTTP 响应。但是，你可以通过在定义路由时调用 `missing` 方法来自定义此行为。`missing` 方法接受一个闭包，如果找不到隐式绑定模型，则将调用该闭包：\r\n\r\n    use App\\Http\\Controllers\\LocationsController;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Redirect;\r\n\r\n    Route::get('/locations/{location:slug}', [LocationsController::class, 'show'])\r\n            ->name('locations.view')\r\n            ->missing(function (Request $request) {\r\n                return Redirect::route('locations.index');\r\n            });\r\n\r\n<a name=\"implicit-enum-binding\"></a>\r\n### 隐式枚举绑定\r\n\r\nPHP 8.1 引入了对 [Enums](https://www.php.net/manual/en/language.enumerations.backed.php). 的支持。为了补充这个特性，Laravel 允许你在你的路由定义中键入一个 [Enums](https://www.php.net/manual/en/language.enumerations.backed.php) 并且 Laravel 只会在该路由段对应于一个有效的 Enum 值时调用该路由。否则，将自动返回 404 HTTP 响应。例如，给定以下枚举：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Enums;\r\n\r\nenum Category: string\r\n{\r\n    case Fruits = 'fruits';\r\n    case People = 'people';\r\n}\r\n```\r\n\r\n你可以定义一个只有在 `{category}` 路由段是 `fruits` 或 `people` 时才会被调用的路由。 否则，Laravel 将返回 404 HTTP 响应：\r\n\r\n```php\r\nuse App\\Enums\\Category;\r\nuse Illuminate\\Support\\Facades\\Route;\r\n\r\nRoute::get('/categories/{category}', function (Category $category) {\r\n    return $category->value;\r\n});\r\n```\r\n\r\n<a name=\"explicit-binding\"></a>\r\n### 显式绑定\r\n\r\n不需要使用 Laravel 隐式的、基于约定的模型解析来使用模型绑定。你还可以显式定义路由参数与模型的对应方式。要注册显式绑定，请使用路由器的 `model` 方法为给定参数指定类。在 `RouteServiceProvider` 类的 `boot` 方法的开头定义显式模型绑定：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    /**\r\n     * 定义路由模型绑定、模式筛选器等。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Route::model('user', User::class);\r\n\r\n        // ...\r\n    }\r\n\r\n接下来，定义一个包含 `{user}` 参数的路由：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users/{user}', function (User $user) {\r\n        // ...\r\n    });\r\n\r\n由于我们已将所有 `{user}` 参数绑定到 `App\\Models\\User` 模型，该类的一个实例将被注入到路由中。因此，例如，对 `users/1` 的请求将从 ID 为 `1` 的数据库中注入 `User` 实例。\r\n\r\n如果在数据库中没有找到匹配的模型实例，则会自动生成 404 HTTP 响应。\r\n\r\n<a name=\"customizing-the-resolution-logic\"></a>\r\n#### 自定义解析逻辑\r\n\r\n如果你想定义你自己的模型绑定解析逻辑，你可以使用 `Route::bind` 方法。传递给 `bind` 方法的闭包将接收 URI 段的值，并应返回应注入路由的类的实例。同样，这种定制应该在应用程序的 `RouteServiceProvider` 的 `boot` 方法中进行：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    /**\r\n     * 定义路由模型绑定、模式筛选器等。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Route::bind('user', function (string $value) {\r\n            return User::where('name', $value)->firstOrFail();\r\n        });\r\n\r\n        // ...\r\n    }\r\n\r\n或者，你可以覆盖 Eloquent 模型上的 `resolveRouteBinding` 方法。此方法将接收 URI 段的值，并应返回应注入路由的类的实例：\r\n\r\n    /**\r\n     * 检索绑定值的模型。\r\n     *\r\n     * @param  mixed  $value\r\n     * @param  string|null  $field\r\n     * @return \\Illuminate\\Database\\Eloquent\\Model|null\r\n     */\r\n    public function resolveRouteBinding($value, $field = null)\r\n    {\r\n        return $this->where('name', $value)->firstOrFail();\r\n    }\r\n\r\n如果路由正在使用 [implicit binding scoping](#implicit-model-binding-scoping), 则 `resolveChildRouteBinding` 方法将用于解析父模型的子绑定：\r\n\r\n    /**\r\n     * 检索绑定值的子模型。\r\n     *\r\n     * @param  string  $childType\r\n     * @param  mixed  $value\r\n     * @param  string|null  $field\r\n     * @return \\Illuminate\\Database\\Eloquent\\Model|null\r\n     */\r\n    public function resolveChildRouteBinding($childType, $value, $field)\r\n    {\r\n        return parent::resolveChildRouteBinding($childType, $value, $field);\r\n    }\r\n\r\n<a name=\"fallback-routes\"></a>\r\n## Fallback 路由\r\n\r\n使用 `Route::fallback` 方法，你可以定义一个在没有其他路由匹配传入请求时将执行的路由。通常，未处理的请求将通过应用程序的异常处理程序自动呈现「404」页面。但是，由于你通常会在 `routes/web.php` 文件中定义 fallback 路由，因此 web 中间件组中的所有中间件都将应用于该路由。你可以根据需要随意向此路由添加额外的中间件：\r\n\r\n    Route::fallback(function () {\r\n        // ...\r\n    });\r\n\r\n> 注意：Fallback 路由应该始终是你的应用程序注册的最后一个路由。\r\n\r\n<a name=\"rate-limiting\"></a>\r\n## 速率限制\r\n\r\n<a name=\"defining-rate-limiters\"></a>\r\n### 定义速率限制器\r\n\r\nLaravel 包括功能强大且可定制的限速服务，你可以利用这些服务来限制给定路线或一组路线的流量。首先，你应该定义满足应用程序需求的速率限制器配置。通常，这应该在应用程序的 `App\\Providers\\RouteServiceProvider` 类的 `configureRateLimiting` 方法中完成，该类已经包含了一个速率限制器定义，该定义应用于应用程序 `routes/api.php` 文件中的路由：\r\n\r\n```php\r\nuse Illuminate\\Cache\\RateLimiting\\Limit;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n/**\r\n * 为应用程序配置速率限制器。\r\n */\r\nprotected function boot(): void\r\n{\r\n    RateLimiter::for('api', function (Request $request) {\r\n        return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n速率限制器是使用 `RateLimiter` 外观的 `for` 方法定义的。for 方法接受一个速率限制器名称和一个闭包，该闭包返回应该应用于分配给速率限制器的路由的限制配置。限制配置是 `Illuminate\\Cache\\RateLimiting\\Limit` 类的实例。此类包含有用的「构建器」方法，以便你可以快速定义限制。速率限制器名称可以是你希望的任何字符串：\r\n\r\n```php\r\nuse Illuminate\\Cache\\RateLimiting\\Limit;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n/**\r\n * 为应用程序配置速率限制器。\r\n */\r\nprotected function boot(): void\r\n{\r\n    RateLimiter::for('global', function (Request $request) {\r\n        return Limit::perMinute(1000);\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n如果传入的请求超过指定的速率限制，Laravel 将自动返回一个带有 429 HTTP 状态码的响应。如果你想定义自己的响应，应该由速率限制返回，你可以使用 `response` 方法：\r\n\r\n    RateLimiter::for('global', function (Request $request) {\r\n        return Limit::perMinute(1000)->response(function (Request $request, array $headers) {\r\n            return response('Custom response...', 429, $headers);\r\n        });\r\n    });\r\n\r\n由于速率限制器回调接收传入的 HTTP 请求实例，你可以根据传入的请求或经过身份验证的用户动态构建适当的速率限制：\r\n\r\n    RateLimiter::for('uploads', function (Request $request) {\r\n        return $request->user()->vipCustomer()\r\n                    ? Limit::none()\r\n                    : Limit::perMinute(100);\r\n    });\r\n\r\n<a name=\"segmenting-rate-limits\"></a>\r\n#### 分段速率限制\r\n\r\n有时你可能希望按某个任意值对速率限制进行分段。例如，你可能希望每个 IP 地址每分钟允许用户访问给定路由 100 次。为此，你可以在构建速率限制时使用 `by` 方法：\r\n\r\n    RateLimiter::for('uploads', function (Request $request) {\r\n        return $request->user()->vipCustomer()\r\n                    ? Limit::none()\r\n                    : Limit::perMinute(100)->by($request->ip());\r\n    });\r\n\r\n为了使用另一个示例来说明此功能，我们可以将每个经过身份验证的用户 ID 的路由访问限制为每分钟 100 次，或者对于访客来说，每个 IP 地址每分钟访问 10 次：\r\n\r\n    RateLimiter::for('uploads', function (Request $request) {\r\n        return $request->user()\r\n                    ? Limit::perMinute(100)->by($request->user()->id)\r\n                    : Limit::perMinute(10)->by($request->ip());\r\n    });\r\n\r\n<a name=\"multiple-rate-limits\"></a>\r\n#### 多个速率限制\r\n\r\n如果需要，你可以返回给定速率限制器配置的速率限制数组。将根据路由在数组中的放置顺序评估每个速率限制：\r\n\r\n    RateLimiter::for('login', function (Request $request) {\r\n        return [\r\n            Limit::perMinute(500),\r\n            Limit::perMinute(3)->by($request->input('email')),\r\n        ];\r\n    });\r\n\r\n<a name=\"attaching-rate-limiters-to-routes\"></a>\r\n### 将速率限制器附加到路由\r\n\r\n可以使用 `throttle` [middleware](/docs/laravel/10.x/middleware)。 将速率限制器附加到路由或路由组。路由中间件接受你希望分配给路由的速率限制器的名称：\r\n\r\n    Route::middleware(['throttle:uploads'])->group(function () {\r\n        Route::post('/audio', function () {\r\n            // ...\r\n        });\r\n\r\n        Route::post('/video', function () {\r\n            // ...\r\n        });\r\n    });\r\n\r\n<a name=\"throttling-with-redis\"></a>\r\n#### 使用 Redis 节流\r\n\r\n通常，`throttle` 中间件映射到 `Illuminate\\Routing\\Middleware\\ThrottleRequests` 类。此映射在应用程序的 HTTP 内核 (App\\Http\\Kernel) 中定义。但是，如果你使用 Redis 作为应用程序的缓存驱动程序，你可能希望更改此映射以使用 `Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis` 类。这个类在使用 Redis 管理速率限制方面更有效：\r\n\r\n    'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis::class,\r\n\r\n<a name=\"form-method-spoofing\"></a>\r\n## 伪造表单方法\r\n\r\nHTML 表单不支持 `PUT` ， `PATCH` 或 `DELETE` 请求。所以，当定义 `PUT` ， `PATCH` 或 `DELETE` 路由用在 HTML 表单时，你将需要一个隐藏的加 `_method` 字段在表单中。该 `_method` 字段的值将会与 HTTP 请求一起发送。\r\n\r\n    <form action=\"/example\" method=\"POST\">\r\n        <input type=\"hidden\" name=\"_method\" value=\"PUT\">\r\n        <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\">\r\n    </form>\r\n\r\n为方便起见，你可以使用 `@method` [Blade 指令](/docs/laravel/10.x/blade) 生成 `_method` 输入字段：\r\n\r\n    <form action=\"/example\" method=\"POST\">\r\n        @method('PUT')\r\n        @csrf\r\n    </form>\r\n\r\n<a name=\"accessing-the-current-route\"></a>\r\n## 访问当前路由\r\n\r\n你可以使用 `Route Facade` 的 `current`、`currentRouteName` 和 `currentRouteAction` 方法来访问有关处理传入请求的路由的信息：\r\n\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    $route = Route::current(); // Illuminate\\Routing\\Route\r\n    $name = Route::currentRouteName(); // string\r\n    $action = Route::currentRouteAction(); // string\r\n\r\n你可以参考 [Route facade 的底层类](https://laravel.com/api/laravel/10.x/Illuminate/Routing/Router.html) 和 [Route 实例](https://laravel.com/api/laravel/10.x/Illuminate/Routing/Route.html) 的 API 文档查看路由器和路由类上可用的所有方法。\r\n\r\n<a name=\"cors\"></a>\r\n## 跨域资源共享 (CORS)\r\n\r\nLaravel 可以使用你配置的值自动响应 CORS `OPTIONS` HTTP 请求。所有 CORS 设置都可以在应用程序的 `config/cors.php` 配置文件中进行配置。OPTIONS 请求将由默认包含在全局中间件堆栈中的 HandleCors [middleware](/docs/laravel/10.x/middleware) 自动处理。你的全局中间件堆栈位于应用程序的 HTTP 内核 (`App\\Http\\Kernel`) 中。\r\n\r\n> 技巧：有关 CORS 和 CORS 标头的更多信息，请参阅 [MDN 关于 CORS 的 Web 文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers)。\r\n\r\n<a name=\"route-caching\"></a>\r\n## 路由缓存\r\n\r\n在将应用程序部署到生产环境时，你应该利用 Laravel 的路由缓存。使用路由缓存将大大减少注册所有应用程序路由所需的时间。要生成路由缓存，请执行 `route:cache` Artisan 命令：\r\n\r\n```shell\r\nphp artisan route:cache\r\n```\r\n\r\n运行此命令后，你的缓存路由文件将在每个请求上加载。请记住，如果你添加任何新路线，你将需要生成新的路线缓存。因此，你应该只在项目部署期间运行 `route:cache` 命令。\r\n\r\n你可以使用 `route:clear` 命令清除路由缓存：\r\n\r\n```shell\r\nphp artisan route:clear\r\n```\r\n\r\n\r\n<a name=\"自定义秘钥\"></a>\r\n<a name=\"自定义键和范围\"></a>\r\n","p":"docs/routing.html"},{"t":"middleware (中间件)","d":"# 中间件\r\n\r\n- [介绍](#introduction)\r\n- [定义中间件](#defining-middleware)\r\n- [注册中间件](#registering-middleware)\r\n    - [全局中间件](#global-middleware)\r\n    - [将中间件分配给路由](#assigning-middleware-to-routes)\r\n    - [中间件组](#middleware-groups)\r\n    - [排序中间件](#sorting-middleware)\r\n- [中间件参数](#middleware-parameters)\r\n- [可终止的中间件](#terminable-middleware)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n中间件提供了一种方便的机制来检查和过滤进入应用程序的 HTTP 请求。例如，Laravel 包含一个中间件，用于验证应用程序的用户是否经过身份验证。如果用户未通过身份验证，中间件会将用户重定向到应用程序的登录屏幕。 但是，如果用户通过了身份验证，中间件将允许请求进一步进入应用程序。\r\n\r\n除了身份验证之外，还可以编写其他中间件来执行各种任务。例如，日志中间件可能会将所有传入请求记录到你的应用程序。Laravel 框架中包含了几个中间件，包括用于身份验证和 CSRF 保护的中间件。所有这些中间件都位于 `app/Http/Middleware` 目录中。\r\n\r\n<a name=\"defining-middleware\"></a>\r\n## 定义中间件\r\n\r\n要创建新的中间件，请使用 `make:middleware` Artisan 命令：\r\n\r\n```shell\r\nphp artisan make:middleware EnsureTokenIsValid\r\n```\r\n\r\n此命令将在你的 `app/Http/Middleware` 目录中放置一个新的 `EnsureTokenIsValid` 类。在这个中间件中，如果提供的 `token` 输入匹配指定的值，我们将只允许访问路由。否则，我们会将用户重定向回 `home` URI：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class EnsureTokenIsValid\r\n    {\r\n        /**\r\n         * 处理传入请求。\r\n         *\r\n         * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n         */\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            if ($request->input('token') !== 'my-secret-token') {\r\n                return redirect('home');\r\n            }\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n\r\n\r\n如你所见，如果给定的 `token` 与我们的秘密令牌不匹配，中间件将向客户端返回 HTTP 重定向； 否则，请求将被进一步传递到应用程序中。要将请求更深入地传递到应用程序中（允许中间件「通过」），你应该使用 `$request` 调用 `$next` 回调。\r\n\r\n最好将中间件设想为一系列「层」HTTP 请求在到达你的应用程序之前必须通过。每一层都可以检查请求，甚至完全拒绝它。\r\n\r\n>技巧：所有中间件都通过 [服务容器](/docs/laravel/10.x/container) 解析，因此你可以在中间件的构造函数中键入提示你需要的任何依赖项。\r\n\r\n<a name=\"before-after-middleware\"></a>\r\n<a name=\"middleware-and-responses\"></a>\r\n#### 中间件和响应\r\n\r\n当然，中间件可以在将请求更深入地传递到应用程序之前或之后执行任务。例如，以下中间件将在应用程序处理__请求之前__执行一些任务：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class BeforeMiddleware\r\n    {\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            // 执行操作\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n但是，此中间件将在应用程序处理__请求之后__执行其任务：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class AfterMiddleware\r\n    {\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            $response = $next($request);\r\n\r\n            // 执行操作\r\n\r\n            return $response;\r\n        }\r\n    }\r\n\r\n<a name=\"registering-middleware\"></a>\r\n## 注册中间件\r\n\r\n<a name=\"global-middleware\"></a>\r\n### 全局中间件\r\n\r\n如果你希望在对应用程序的每个 HTTP 请求期间运行中间件，请在 `app/Http/Kernel.php` 类的 `$middleware` 属性中列出中间件类。\r\n\r\n<a name=\"assigning-middleware-to-routes\"></a>\r\n### 将中间件分配给路由\r\n\r\n如果要将中间件分配给特定路由，可以在定义路由时调用 `middleware` 方法：\r\n\r\n\r\n    use App\\Http\\Middleware\\Authenticate;\r\n\r\n    Route::get('/profile', function () {\r\n        // ...\r\n    })->middleware(Authenticate::class);\r\n\r\n通过向 `middleware` 方法传递一组中间件名称，可以为路由分配多个中间件：\r\n\r\n    Route::get('/', function () {\r\n        // ...\r\n    })->middleware([First::class, Second::class]);\r\n\r\n为了方便起见，可以在应用程序的`app/Http/Kernel.php`文件中为中间件分配别名。默认情况下，此类的 `$middlewareAliases` 属性包含Laravel中包含的中间件的条目。你可以将自己的中间件添加到此列表中，并为其分配选择的别名：\r\n\r\n    // 在App\\Http\\Kernel类中。。。\r\n\r\n    protected $middlewareAliases = [\r\n        'auth' => \\App\\Http\\Middleware\\Authenticate::class,\r\n        'auth.basic' => \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\r\n        'bindings' => \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n        'cache.headers' => \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class,\r\n        'can' => \\Illuminate\\Auth\\Middleware\\Authorize::class,\r\n        'guest' => \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\r\n        'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,\r\n        'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\r\n        'verified' => \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,\r\n    ];\r\n\r\n一旦在HTTP内核中定义了中间件别名，就可以在将中间件分配给路由时使用该别名：\r\n\r\n    Route::get('/profile', function () {\r\n        // ...\r\n    })->middleware('auth');\r\n\r\n<a name=\"excluding-middleware\"></a>\r\n#### 排除中间件\r\n\r\n当将中间件分配给一组路由时，可能偶尔需要防止中间件应用于组内的单个路由。可以使用 `withoutMiddleware` 方法完成此操作：\r\n\r\n    use App\\Http\\Middleware\\EnsureTokenIsValid;\r\n\r\n    Route::middleware([EnsureTokenIsValid::class])->group(function () {\r\n        Route::get('/', function () {\r\n            // ...\r\n        });\r\n\r\n        Route::get('/profile', function () {\r\n            // ...\r\n        })->withoutMiddleware([EnsureTokenIsValid::class]);\r\n    });\r\n\r\n还可以从整个 [组](/docs/laravel/10.x/routing#route-groups) 路由定义中排除一组给定的中间件：\r\n\r\n    use App\\Http\\Middleware\\EnsureTokenIsValid;\r\n\r\n    Route::withoutMiddleware([EnsureTokenIsValid::class])->group(function () {\r\n        Route::get('/profile', function () {\r\n            // ...\r\n        });\r\n    });\r\n\r\n「withoutMiddleware」方法只能删除路由中间件，不适用于 [全局中间件](#global-middleware)。\r\n\r\n<a name=\"middleware-groups\"></a>\r\n### 中间件组\r\n\r\n有时，你可能希望将多个中间件组合在一个键下，以使它们更容易分配给路由。你可以使用 HTTP 内核的 `$middlewareGroups` 属性来完成此操作。\r\n\r\nLaravel 包括预定义 带有 `web` 和 `api` 中间件组，其中包含你可能希望应用于 Web 和 API 路由的常见中间件。请记住，这些中间件组会由应用程序的 `App\\Providers\\RouteServiceProvider` 服务提供者自动应用于相应的 `web` 和 `api` 路由文件中的路由：\r\n\r\n    /**\r\n     * 应用程序的路由中间件组。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $middlewareGroups = [\r\n        'web' => [\r\n            \\App\\Http\\Middleware\\EncryptCookies::class,\r\n            \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class,\r\n            \\Illuminate\\Session\\Middleware\\StartSession::class,\r\n            \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\r\n            \\App\\Http\\Middleware\\VerifyCsrfToken::class,\r\n            \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n        ],\r\n\r\n        'api' => [\r\n            \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class.':api',\r\n            \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n        ],\r\n    ];\r\n\r\n中间件组可以使用与单个中间件相同的语法分配给路由和控制器动作。同理，中间件组使一次将多个中间件分配给一个路由更加方便：\r\n\r\n    Route::get('/', function () {\r\n        // ...\r\n    })->middleware('web');\r\n\r\n    Route::middleware(['web'])->group(function () {\r\n        // ...\r\n    });\r\n\r\n>技巧：开箱即用，`web` 和 `api` 中间件组会通过  `App\\Providers\\RouteServiceProvider` 自动应用于应用程序对应的 `routes/web.php` 和 `routes/api.php` 文件。\r\n\r\n<a name=\"sorting-middleware\"></a>\r\n### 排序中间件\r\n\r\n在特定情况下，可能需要中间件以特定的顺序执行，但当它们被分配到路由时，是无法控制它们的顺序的。在这种情况下，可以使用到 `app/Http/Kernel.php` 文件的 `$middlewarePriority` 属性指定中间件优先级。默认情况下，HTTP内核中可能不存在此属性。如果它不存在，你可以复制下面的默认定义：\r\n\r\n    /**\r\n     * 中间件的优先级排序列表。\r\n     *\r\n     * 这迫使非全局中间件始终处于给定的顺序。\r\n     *\r\n     * @var string[]\r\n     */\r\n    protected $middlewarePriority = [\r\n        \\Illuminate\\Foundation\\Http\\Middleware\\HandlePrecognitiveRequests::class,\r\n        \\Illuminate\\Cookie\\Middleware\\EncryptCookies::class,\r\n        \\Illuminate\\Session\\Middleware\\StartSession::class,\r\n        \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\r\n        \\Illuminate\\Contracts\\Auth\\Middleware\\AuthenticatesRequests::class,\r\n        \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\r\n        \\Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis::class,\r\n        \\Illuminate\\Contracts\\Session\\Middleware\\AuthenticatesSessions::class,\r\n        \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n        \\Illuminate\\Auth\\Middleware\\Authorize::class,\r\n    ];\r\n\r\n<a name=\"middleware-parameters\"></a>\r\n## 中间件参数\r\n\r\n中间件也可以接收额外的参数。例如，如果你的应用程序需要在执行给定操作之前验证经过身份验证的用户是否具有给定的「角色」，你可以创建一个 `EnsureUserHasRole` 中间件，该中间件接收角色名称作为附加参数。\r\n\r\n额外的中间件参数将在 `$next` 参数之后传递给中间件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class EnsureUserHasRole\r\n    {\r\n        /**\r\n         * 处理传入请求。\r\n         *\r\n         * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n         */\r\n        public function handle(Request $request, Closure $next, string $role): Response\r\n        {\r\n            if (! $request->user()->hasRole($role)) {\r\n                // 重定向。。。\r\n            }\r\n\r\n            return $next($request);\r\n        }\r\n\r\n    }\r\n\r\n在定义路由时，可以指定中间件参数，方法是使用 `:` 分隔中间件名称和参数。多个参数应以逗号分隔：\r\n\r\n    Route::put('/post/{id}', function (string $id) {\r\n        // ...\r\n    })->middleware('role:editor');\r\n\r\n<a name=\"terminable-middleware\"></a>\r\n## 可终止的中间件\r\n\r\n部分情况下，在将 HTTP 响应发送到浏览器之后，中间件可能需要做一些工作。如果你在中间件上定义了一个 `terminate` 方法，并且你的 Web 服务器使用 FastCGI，则在将响应发送到浏览器后会自动调用 `terminate` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Illuminate\\Session\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class TerminatingMiddleware\r\n    {\r\n        /**\r\n         * 处理传入的请求。\r\n         *\r\n         * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n         */\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            return $next($request);\r\n        }\r\n\r\n        /**\r\n         * 在响应发送到浏览器后处理任务。\r\n         */\r\n        public function terminate(Request $request, Response $response): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n`terminate` 方法应该同时接收请求和响应。一旦你定义了一个可终止的中间件，你应该将它添加到 `app/Http/Kernel.php` 文件中的路由或全局中间件列表中。\r\n\r\n当在中间件上调用 `terminate` 方法时，Laravel 会从 [服务容器](/docs/laravel/10.x/container) 解析一个新的中间件实例。如果你想在调用 `handle` 和 `terminate` 方法时使用相同的中间件实例，请使用容器的 `singleton` 方法向容器注册中间件。 通常这应该在你的 `AppServiceProvider` 的 `register` 方法中完成：\r\n\r\n    use App\\Http\\Middleware\\TerminatingMiddleware;\r\n\r\n    /**\r\n     * 注册任何应用程序服务。\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->app->singleton(TerminatingMiddleware::class);\r\n    }\r\n\r\n\r\n<a name=\"前后中间件\"></a>\r\n<a name=\"中间件和响应\"></a>\r\n","p":"docs/middleware.html"},{"t":"csrf (CSRF 保护)","d":"\n# CSRF 保护\r\n\r\n- [简介](#csrf-introduction)\r\n- [阻止 CSRF 请求](#preventing-csrf-requests)\r\n    - [排除 URLS](#csrf-excluding-uris)\r\n- [X-CSRF-Token](#csrf-x-csrf-token)\r\n- [X-XSRF-Token](#csrf-x-xsrf-token)\r\n\r\n<a name=\"csrf-introduction\"></a>\r\n## 简介\r\n\r\n跨站点请求伪造是一种恶意利用，利用这种手段，代表经过身份验证的用户执行未经授权的命令。值得庆幸的是，Laravel 可以轻松保护您的应用程序免受[跨站点请求伪造](https://en.wikipedia.org/wiki/Cross-site_request_forgery)（CSRF）攻击。\r\n\r\n<a name=\"csrf-explanation\"></a>\r\n#### 漏洞的解释\r\n\r\n如果你不熟悉跨站点请求伪造，我们讨论一个利用此漏洞的示例。假设您的应用程序有一个 `/user/email` 路由，它接受 POST 请求来更改经过身份验证用户的电子邮件地址。最有可能的情况是，此路由希望 `email` 输入字段包含用户希望开始使用的电子邮件地址。\r\n\r\n没有 CSRF 保护，恶意网站可能会创建一个 HTML 表单，指向您的应用程序 `/user/email` 路由，并提交恶意用户自己的电子邮件地址：\r\n\r\n```html\r\n<form action=\"https://your-application.com/user/email\" method=\"POST\">\r\n    <input type=\"email\" value=\"malicious-email@example.com\">\r\n</form>\r\n\r\n<script>\r\n    document.forms[0].submit();\r\n</script>\r\n```\r\n\r\n 如果恶意网站在页面加载时自动提交了表单，则恶意用户只需要诱使您的应用程序的一个毫无戒心的用户访问他们的网站，他们的电子邮件地址就会在您的应用程序中更改。\r\n\r\n 为了防止这种漏洞，我们需要检查每一个传入的 `POST`，`PUT`，`PATCH` 或 `DELETE` 请求以获取恶意应用程序无法访问的秘密会话值。\r\n\r\n\n\n<a name=\"preventing-csrf-requests\"></a>\r\n## 阻止 CSRF 请求\r\n\r\nLaravel 为应用程序管理的每个活动 [用户会话](/docs/laravel/10.x/session) 自动生成 CSRF 「令牌」。此令牌用于验证经过身份验证的用户是实际向应用程序发出请求的人。由于此令牌存储在用户的会话中，并且每次重新生成会话时都会更改，因此恶意应用程序将无法访问它。\r\n\r\n当前会话的 CSRF 令牌可以通过请求的会话或通过 `csrf_token` 辅助函数进行访问：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/token', function (Request $request) {\r\n        $token = $request->session()->token();\r\n\r\n        $token = csrf_token();\r\n\r\n        // ...\r\n    });\r\n\r\n无论何时在应用程序中定义 `POST` 、`PUT` 、`PATCH` 或 `DELETE` HTML表单，都应在表单中包含隐藏的CSRF `_token` 字段，以便CSRF保护中间件可以验证请求。为方便起见，可以使用 `@csrf` Blade指令生成隐藏的令牌输入字段：\r\n\r\n```html\r\n<form method=\"POST\" action=\"/profile\">\r\n    @csrf\r\n\r\n    <!-- 相当于。。。 -->\r\n    <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\" />\r\n</form>\r\n```\r\n\r\n默认情况下包含在 `web` 中间件组中的`App\\Http\\Middleware\\VerifyCsrfToken` [中间件](/docs/laravel/10.x/middleware)将自动验证请求输入中的令牌是否与会话中存储的令牌匹配。当这两个令牌匹配时，我们知道身份验证的用户是发起请求的用户。\r\n\r\n<a name=\"csrf-tokens-and-spas\"></a>\r\n### CSRF Tokens & SPAs\r\n\r\n如果你正在构建一个将 Laravel 用作 API 后端的 SPA，你应该查阅 [Laravel Sanctum 文档](/docs/laravel/10.x/sanctum)，以获取有关使用 API 进行身份验证和防范 CSRF 漏洞的信息。\r\n\r\n\n\n<a name=\"csrf-excluding-uris\"></a>\r\n### 从 CSRF 保护中排除 URI\r\n\r\n有时你可能希望从 CSRF 保护中排除一组 URIs。例如，如果你使用  [Stripe](https://stripe.com)  处理付款并使用他们的 webhook 系统，则需要将你的 Stripe webhook 处理程序路由从 CSRF 保护中排除，因为 Stripe 不会知道要向您的路由发送什么 CSRF 令牌。\r\n\r\n通常，你应该将这些类型的路由放在 `App\\Providers\\RouteServiceProvider` 应用于 routes/web.php 文件中的所有路由的 `web` 中间件组之外。但是，现在也可以通过将路由的 URIs 添加到 `VerifyCsrfToken` 中间件的 `$except` 属性来排除路由：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware;\r\n\r\n    class VerifyCsrfToken extends Middleware\r\n    {\r\n        /**\r\n         * 从 CSRF 验证中排除的 URIs。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $except = [\r\n            'stripe/*',\r\n            'http://example.com/foo/bar',\r\n            'http://example.com/foo/*',\r\n        ];\r\n    }\r\n\r\n>技巧：为方便起见，[运行测试](/docs/laravel/10.x/testing).时自动禁用所有路由的 CSRF 中间件。\r\n\r\n<a name=\"csrf-x-csrf-token\"></a>\r\n## X-CSRF-TOKEN\r\n\r\n除了检查 CSRF 令牌作为 POST 参数外， `App\\Http\\Middleware\\VerifyCsrfToken` 中间件还将检查 `X-CSRF-TOKEN` 请求标头。 例如，你可以将令牌存储在 HTML 的  `meta` 标签中：\r\n\r\n```blade\r\n<meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\r\n```\r\n\r\n然后，你可以指示 jQuery 之类的库自动将令牌添加到所有请求标头。 这为使用传统 JavaScript 技术的基于 AJAX 的应用程序提供了简单、方便的 CSRF 保护：\r\n\r\n```js\r\n$.ajaxSetup({\r\n    headers: {\r\n        'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\r\n    }\r\n});\r\n```\r\n\r\n\n\n<a name=\"csrf-x-xsrf-token\"></a>\r\n## X-XSRF-TOKEN\r\n\r\nLaravel 将当前CSRF令牌存储在加密的 `XSRF-TOKEN` cookie 中，该 cookie 包含在框架生成的每个响应中。您可以使用 cookie 值设置 `X-XSRF-TOKEN` 请求标头。\r\n\r\n由于一些 JavaScript 框架和库（如 Angular 和 Axios ）会自动将其值放置在同一源请求的 `X-XSRF-TOKEN` 标头中，因此发送此 cookie 主要是为了方便开发人员。\r\n\r\n> 技巧：默认情况下，`resources/js/bootstrap.js` 文件包含 Axios HTTP 库，它会自动为您发送 `X-XSRF-TOKEN` 标头。\r\n\n","p":"docs/csrf.html"},{"t":"controllers (控制器)","d":"# 控制器\r\n\r\n- [介绍](#introduction)\r\n- [编写控制器](#writing-controllers)\r\n    - [基本控制器](#basic-controllers)\r\n    - [单动作控制器](#single-action-controllers)\r\n- [控制器中间件](#controller-middleware)\r\n- [资源控制器](#resource-controllers)\r\n    - [部分资源路由](#restful-partial-resource-routes)\r\n    - [嵌套资源](#restful-nested-resources)\r\n    - [命名资源路由](#restful-naming-resource-routes)\r\n    - [命名资源路由参数](#restful-naming-resource-route-parameters)\r\n    - [范围资源路由](#restful-scoping-resource-routes)\r\n    - [本地化资源 URI](#restful-localizing-resource-uris)\r\n    - [补充资源控制器](#restful-supplementing-resource-controllers)\r\n    - [单例资源控制器](#singleton-resource-controllers)\r\n- [依赖注入和控制器](#dependency-injection-and-controllers)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n你可能希望使用「controller」类来组织此行为，而不是将所有请求处理逻辑定义为路由文件中的闭包。控制器可以将相关的请求处理逻辑分组到一个类中。 例如，一个 `UserController` 类可能会处理所有与用户相关的传入请求，包括显示、创建、更新和删除用户。 默认情况下，控制器存储在 `app/Http/Controllers` 目录中。\r\n\r\n<a name=\"writing-controllers\"></a>\r\n## 编写控制器\r\n\r\n<a name=\"basic-controllers\"></a>\r\n### 基本控制器\r\n\r\n如果要快速生成新控制器，可以使用 `make:controller` Artisan 命令。默认情况下，应用程序的所有控制器都存储在`app/Http/Controllers` 目录中：\r\n\r\n```shell\r\nphp artisan make:controller UserController\r\n```\r\n\r\n让我们来看一个基本控制器的示例。控制器可以有任意数量的公共方法来响应传入的HTTP请求：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n    \r\n    use App\\Models\\User;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示给定用户的配置文件。\r\n         */\r\n        public function show(string $id): View\r\n        {\r\n            return view('user.profile', [\r\n                'user' => User::findOrFail($id)\r\n            ]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n编写控制器类和方法后，可以定义到控制器方法的路由，如下所示：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    Route::get('/user/{id}', [UserController::class, 'show']);\r\n\r\n当传入的请求与指定的路由 URI 匹配时，将调用 `App\\Http\\Controllers\\UserController` 类的 `show` 方法，并将路由参数传递给该方法。\r\n\r\n>技巧：控制器并不是 **必需** 继承基础类。如果控制器没有继承基础类，你将无法使用一些便捷的功能，比如 `middleware` 和 `authorize` 方法。\r\n\r\n<a name=\"single-action-controllers\"></a>\r\n### 单动作控制器\r\n\r\n如果控制器动作特别复杂，你可能会发现将整个控制器类专用于该单个动作很方便。为此，您可以在控制器中定义一个 `__invoke` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n    \r\n    use App\\Models\\User;\r\n    use Illuminate\\Http\\Response;\r\n\r\n    class ProvisionServer extends Controller\r\n    {\r\n        /**\r\n         * 设置新的web服务器。\r\n         */\r\n        public function __invoke()\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n为单动作控制器注册路由时，不需要指定控制器方法。相反，你可以简单地将控制器的名称传递给路由器：\r\n\r\n    use App\\Http\\Controllers\\ProvisionServer;\r\n\r\n    Route::post('/server', ProvisionServer::class);\r\n\r\n你可以使用 `make:controller` Artisan 命令的 `--invokable` 选项生成可调用控制器：\r\n\r\n```shell\r\nphp artisan make:controller ProvisionServer --invokable\r\n```\r\n\r\n>技巧：可以使用 [stub 定制](/docs/laravel/10.x/artisan#stub-customization) 自定义控制器模板。\r\n\r\n<a name=\"controller-middleware\"></a>\r\n## 控制器中间件\r\n\r\n[中间件](/docs/laravel/10.x/middleware) 可以在你的路由文件中分配给控制器的路由：\r\n\r\n    Route::get('profile', [UserController::class, 'show'])->middleware('auth');\r\n\r\n\r\n\r\n或者，你可能会发现在控制器的构造函数中指定中间件很方便。使用控制器构造函数中的 `middleware` 方法，你可以将中间件分配给控制器的操作：\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * Instantiate a new controller instance.\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->middleware('auth');\r\n            $this->middleware('log')->only('index');\r\n            $this->middleware('subscribed')->except('store');\r\n        }\r\n    }\r\n\r\n控制器还允许你使用闭包注册中间件。这提供了一种方便的方法来为单个控制器定义内联中间件，而无需定义整个中间件类：\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    $this->middleware(function (Request $request, Closure $next) {\r\n        return $next($request);\r\n    });\r\n\r\n<a name=\"resource-controllers\"></a>\r\n## 资源型控制器\r\n\r\n如果你将应用程序中的每个 Eloquent 模型都视为资源，那么通常对应用程序中的每个资源都执行相同的操作。例如，假设你的应用程序中包含一个 `Photo` 模型和一个 `Movie` 模型。用户可能可以创建，读取，更新或者删除这些资源。\r\n\r\nLaravel 的资源路由通过单行代码即可将典型的增删改查（“CURD”）路由分配给控制器。首先，我们可以使用 Artisan 命令 `make:controller` 的 `--resource` 选项来快速创建一个控制器:\r\n\r\n```shell\r\nphp artisan make:controller PhotoController --resource\r\n```\r\n\r\n这个命令将会生成一个控制器 `app/Http/Controllers/PhotoController.php`。其中包括每个可用资源操作的方法。接下来，你可以给控制器注册一个资源路由：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::resource('photos', PhotoController::class);\r\n\r\n\r\n\r\n这个单一的路由声明创建了多个路由来处理资源上的各种行为。生成的控制器为每个行为保留了方法，而且你可以通过运行 Artisan 命令 `route:list` 来快速了解你的应用程序。\r\n\r\n你可以通过将数组传参到 `resources` 方法中的方式来一次性的创建多个资源控制器：\r\n\r\n    Route::resources([\r\n        'photos' => PhotoController::class,\r\n        'posts' => PostController::class,\r\n    ]);\r\n\r\n<a name=\"actions-handled-by-resource-controller\"></a>\r\n#### 资源控制器操作处理\r\n\r\n|请求方式      | 请求URI                    | 行为       | 路由名称\r\n----------|------------------------|--------------|---------------------\r\nGET       | `/photos`              | index        | photos.index\r\nGET       | `/photos/create`       | create       | photos.create\r\nPOST      | `/photos`              | store        | photos.store\r\nGET       | `/photos/{photo}`      | show         | photos.show\r\nGET       | `/photos/{photo}/edit` | edit         | photos.edit\r\nPUT/PATCH | `/photos/{photo}`      | update       | photos.update\r\nDELETE    | `/photos/{photo}`      | destroy      | photos.destroy\r\n\r\n<a name=\"customizing-missing-model-behavior\"></a>\r\n#### 自定义缺失模型行为\r\n\r\n通常，如果未找到隐式绑定的资源模型，则会生成状态码为 404 的 HTTP 响应。 但是，你可以通过在定义资源路由时调用 `missing` 的方法来自定义该行为。`missing` 方法接受一个闭包，如果对于任何资源的路由都找不到隐式绑定模型，则将调用该闭包：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Redirect;\r\n\r\n    Route::resource('photos', PhotoController::class)\r\n            ->missing(function (Request $request) {\r\n                return Redirect::route('photos.index');\r\n            });\r\n\r\n<a name=\"soft-deleted-models\"></a>\r\n#### 软删除模型\r\n\r\n通常情况下，隐式模型绑定将不会检索已经进行了 [软删除](/docs/laravel/10.x/eloquent#soft-deleting) 的模型，并且会返回一个 404 HTTP 响应。但是，你可以在定义资源路由时调用 `withTrashed` 方法来告诉框架允许软删除的模型：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::resource('photos', PhotoController::class)->withTrashed();\r\n\r\n\r\n\r\n当不传递参数调用 `withTrashed` 时，将在 `show`、`edit` 和 `update` 资源路由中允许软删除的模型。你可以通过一个数组指定这些路由的子集传递给 `withTrashed` 方法：\r\n\r\n    Route::resource('photos', PhotoController::class)->withTrashed(['show']);\r\n\r\n<a name=\"specifying-the-resource-model\"></a>\r\n#### 指定资源模型\r\n\r\n如果你使用了路由模型的绑定 [路由模型绑定](/docs/laravel/10.x/routing#route-model-binding) 并且想在资源控制器的方法中使用类型提示，你可以在生成控制器的时候使用 `--model` 选项：\r\n\r\n```shell\r\nphp artisan make:controller PhotoController --model=Photo --resource\r\n```\r\n\r\n<a name=\"generating-form-requests\"></a>\r\n#### 生成表单请求\r\n\r\n你可以在生成资源控制器时提供 `--requests`  选项来让 Artisan 为控制器的 storage 和 update 方法生成 [表单请求类](/docs/laravel/10.x/validation#form-request-validation)：\r\n\r\n```shell\r\nphp artisan make:controller PhotoController --model=Photo --resource --requests\r\n```\r\n\r\n<a name=\"restful-partial-resource-routes\"></a>\r\n### 部分资源路由\r\n\r\n当声明资源路由时，你可以指定控制器处理的部分行为，而不是所有默认的行为：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::resource('photos', PhotoController::class)->only([\r\n        'index', 'show'\r\n    ]);\r\n\r\n    Route::resource('photos', PhotoController::class)->except([\r\n        'create', 'store', 'update', 'destroy'\r\n    ]);\r\n\r\n<a name=\"api-resource-routes\"></a>\r\n#### API 资源路由\r\n\r\n当声明用于 API 的资源路由时，通常需要排除显示 HTML 模板的路由，例如 `create` 和 `edit`。为了方便，你可以使用 `apiResource` 方法来排除这两个路由：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::apiResource('photos', PhotoController::class);\r\n\r\n\r\n\r\n你也可以传递一个数组给 `apiResources` 方法来同时注册多个 API 资源控制器：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n    use App\\Http\\Controllers\\PostController;\r\n\r\n    Route::apiResources([\r\n        'photos' => PhotoController::class,\r\n        'posts' => PostController::class,\r\n    ]);\r\n\r\n要快速生成不包含 `create` 或 `edit` 方法的 API 资源控制器，你可以在执行 `make:controller` 命令时使用 `--api` 参数：\r\n\r\n```shell\r\nphp artisan make:controller PhotoController --api\r\n```\r\n\r\n<a name=\"restful-nested-resources\"></a>\r\n### 嵌套资源\r\n\r\n有时可能需要定义一个嵌套的资源型路由。例如，照片资源可能被添加了多个评论。那么可以在路由中使用 `.` 符号来声明资源型控制器：\r\n\r\n    use App\\Http\\Controllers\\PhotoCommentController;\r\n\r\n    Route::resource('photos.comments', PhotoCommentController::class);\r\n\r\n该路由会注册一个嵌套资源，可以使用如下 URI 访问：\r\n\r\n    /photos/{photo}/comments/{comment}\r\n\r\n<a name=\"scoping-nested-resources\"></a>\r\n#### 限定嵌套资源的范围\r\n\r\nLaravel 的 [隐式模型绑定](/docs/laravel/10.x/routing#implicit-model-binding-scoping) 特性可以自动限定嵌套绑定的范围，以便确认已解析的子模型会自动属于父模型。定义嵌套路由时，使用 scoped 方法，可以开启自动范围限定，也可以指定 Laravel 应该按照哪个字段检索子模型资源，有关如何完成此操作的更多信息，请参见有关 [范围资源路由](#restful-scoping-resource-routes) 的文档。\r\n\r\n<a name=\"shallow-nesting\"></a>\r\n#### 浅层嵌套\r\n\r\n通常，并不是在所有情况下都需要在 URI 中同时拥有父 ID 和子 ID，因为子 ID 已经是唯一的标识符。当使用唯一标识符（如自动递增的主键）来标识 URL 中的模型时，可以选择使用「浅嵌套」的方式定义路由：\r\n\r\n    use App\\Http\\Controllers\\CommentController;\r\n\r\n    Route::resource('photos.comments', CommentController::class)->shallow();\r\n\r\n\r\n\r\n上面的路由定义方式会定义以下路由：\r\n\r\n|请求方式       | 请求URI                               | 行为       | 路由名称\r\n----------|-----------------------------------|--------------|---------------------\r\nGET       | `/photos/{photo}/comments`        | index        | photos.comments.index\r\nGET       | `/photos/{photo}/comments/create` | create       | photos.comments.create\r\nPOST      | `/photos/{photo}/comments`        | store        | photos.comments.store\r\nGET       | `/comments/{comment}`             | show         | comments.show\r\nGET       | `/comments/{comment}/edit`        | edit         | comments.edit\r\nPUT/PATCH | `/comments/{comment}`             | update       | comments.update\r\nDELETE    | `/comments/{comment}`             | destroy      | comments.destroy\r\n\r\n<a name=\"restful-naming-resource-routes\"></a>\r\n### 命名资源路由\r\n\r\n默认情况下，所有的资源控制器行为都有一个路由名称。你可以传入 `names` 数组来覆盖这些名称：\r\n\r\n    use App\\Http\\Controllers\\PhotoController;\r\n\r\n    Route::resource('photos', PhotoController::class)->names([\r\n        'create' => 'photos.build'\r\n    ]);\r\n\r\n<a name=\"restful-naming-resource-route-parameters\"></a>\r\n### 命名资源路由参数\r\n\r\n默认情况下，`Route::resource` 会根据资源名称的「单数」形式创建资源路由的路由参数。你可以使用 `parameters` 方法来轻松地覆盖资源路由名称。传入 `parameters` 方法应该是资源名称和参数名称的关联数组：\r\n\r\n    use App\\Http\\Controllers\\AdminUserController;\r\n\r\n    Route::resource('users', AdminUserController::class)->parameters([\r\n        'users' => 'admin_user'\r\n    ]);\r\n\r\n上面的示例将会为资源的 `show` 路由生成以下的 URL：\r\n\r\n    /users/{admin_user}\r\n\r\n<a name=\"restful-scoping-resource-routes\"></a>\r\n### 限定范围的资源路由\r\n\r\nLaravel 的 [作用域隐式模型绑定](/docs/laravel/10.x/routing#implicit-model-binding-scoping) 功能可以自动确定嵌套绑定的范围，以便确认已解析的子模型属于父模型。通过在定义嵌套资源时使用 `scoped` 方法，你可以启用自动范围界定，并指示 Laravel 应该通过以下方式来检索子资源的哪个字段：\r\n\r\n    use App\\Http\\Controllers\\PhotoCommentController;\r\n\r\n    Route::resource('photos.comments', PhotoCommentController::class)->scoped([\r\n        'comment' => 'slug',\r\n    ]);\r\n\r\n\r\n\r\n此路由将注册一个有范围的嵌套资源，该资源可以通过以下 URI 进行访问：\r\n\r\n    /photos/{photo}/comments/{comment:slug}\r\n\r\n当使用一个自定义键的隐式绑定作为嵌套路由参数时，Laravel 会自动限定查询范围，按照约定的命名方式去父类中查找关联方法，然后检索到对应的嵌套模型。在这种情况下，将假定 `Photo` 模型有一个叫 `comments` （路由参数名的复数）的关联方法，通过这个方法可以检索到 `Comment` 模型。\r\n\r\n<a name=\"restful-localizing-resource-uris\"></a>\r\n### 本地化资源 URIs\r\n\r\n默认情况下，`Route::resource` 将会用英文动词创建资源 URIs。如果需要自定义 `create` 和 `edit` 行为的动名词，你可以在 `App\\Providers\\RouteServiceProvider` 的 `boot` 方法中使用 `Route::resourceVerbs` 方法实现：\r\n\r\n    /**\r\n     * 定义你的路由模型绑定，模式过滤器等\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Route::resourceVerbs([\r\n            'create' => 'crear',\r\n            'edit' => 'editar',\r\n        ]);\r\n\r\n        // ...\r\n    }\r\n\r\nLaravel 的复数器支持[配置几种不同的语言](/docs/laravel/10.x/localization#pluralization-language)。自定义动词和复数语言后，诸如 `Route::resource('publicacion', PublicacionController::class)` 之类的资源路由注册将生成以下URI：\r\n\r\n    /publicacion/crear\r\n\r\n    /publicacion/{publicaciones}/editar\r\n\r\n<a name=\"restful-supplementing-resource-controllers\"></a>\r\n### 补充资源控制器\r\n\r\n如果你需要向资源控制器添加超出默认资源路由集的其他路由，则应在调用 `Route::resource` 方法之前定义这些路由；否则，由 `resource` 方法定义的路由可能会无意中优先于您的补充路由：\r\n单例资源\r\n    use App\\Http\\Controller\\PhotoController;\r\n\r\n    Route::get('/photos/popular', [PhotoController::class, 'popular']);\r\n    Route::resource('photos', PhotoController::class);\r\n\r\n> 技巧：请记住让你的控制器保持集中。如果你发现自己经常需要典型资源操作集之外的方法，请考虑将控制器拆分为两个更小的控制器。\r\n\r\n\r\n\r\n<a name=\"singleton-resource-controllers\"></a>\r\n### 单例资源控制器\r\n\r\n有时候，应用中的资源可能只有一个实例。比如，用户「个人资料」可被编辑或更新，但是一个用户只会有一份「个人资料」。同样，一张图片也只有一个「缩略图」。这些资源就是所谓「单例资源」，这意味着该资源有且只能有一个实例存在。这种情况下，你可以注册成单例(signleton)资源控制器:\r\n\r\n```php\r\nuse App\\Http\\Controllers\\ProfileController;\r\nuse Illuminate\\Support\\Facades\\Route;\r\n\r\nRoute::singleton('profile', ProfileController::class);\r\n```\r\n\r\n上例中定义的单例资源会注册如下所示的路由。如你所见，单例资源中「新建」路由没有被注册；并且注册的路由不接收路由参数，因为该资源中只有一个实例存在：\r\n\r\n|请求方式      | 请求 URI                               | 行为       | 路由名称\r\n----------|-----------------------------------|--------------|---------------------\r\nGET       | `/profile`                        | show         | profile.show\r\nGET       | `/profile/edit`                   | edit         | profile.edit\r\nPUT/PATCH | `/profile`                        | update       | profile.update\r\n\r\n单例资源也可以在标准资源内嵌套使用：\r\n\r\n```php\r\nRoute::singleton('photos.thumbnail', ThumbnailController::class);\r\n```\r\n\r\n上例中， `photo` 资源将接收所有的[标准资源路由](#actions-handled-by-resource-controller)；不过，`thumbnail` 资源将会是个单例资源，它的路由如下所示：\r\n\r\n| 请求方式      | 请求 URI                              | 行为  | 路由名称               |\r\n|-----------|----------------------------------|---------|--------------------------|\r\n| GET       | `/photos/{photo}/thumbnail`      | show    | photos.thumbnail.show    |\r\n| GET       | `/photos/{photo}/thumbnail/edit` | edit    | photos.thumbnail.edit    |\r\n| PUT/PATCH | `/photos/{photo}/thumbnail`      | update  | photos.thumbnail.update  |\r\n\r\n<a name=\"creatable-singleton-resources\"></a>\r\n#### Creatable 单例资源\r\n\r\n有时，你可能需要为单例资源定义 create 和 storage 路由。要实现这一功能，你可以在注册单例资源路由时，调用 `creatable` 方法：\r\n\r\n```php\r\nRoute::singleton('photos.thumbnail', ThumbnailController::class)->creatable();\r\n```\r\n\r\n\r\n\r\n如下所示，将注册以下路由。还为可创建的单例资源注册 `DELETE` 路由：\r\n\r\n| Verb      | URI                                | Action  | Route Name               |\r\n|-----------|------------------------------------|---------|--------------------------|\r\n| GET       | `/photos/{photo}/thumbnail/create` | create  | photos.thumbnail.create  |\r\n| POST      | `/photos/{photo}/thumbnail`        | store   | photos.thumbnail.store   |\r\n| GET       | `/photos/{photo}/thumbnail`        | show    | photos.thumbnail.show    |\r\n| GET       | `/photos/{photo}/thumbnail/edit`   | edit    | photos.thumbnail.edit    |\r\n| PUT/PATCH | `/photos/{photo}/thumbnail`        | update  | photos.thumbnail.update  |\r\n| DELETE    | `/photos/{photo}/thumbnail`        | destroy | photos.thumbnail.destroy |\r\n\r\n如果希望 Laravel 为单个资源注册 `DELETE` 路由，但不注册创建或存储路由，则可以使用 `destroyable` 方法：\r\n\r\n```php\r\nRoute::singleton(...)->destroyable();\r\n```\r\n\r\n<a name=\"api-singleton-resources\"></a>\r\n#### API 单例资源\r\n\r\n`apiSingleton` 方法可用于注册将通过API操作的单例资源，从而不需要 `create` 和 `edit`  路由：\r\n\r\n```php\r\nRoute::apiSingleton('profile', ProfileController::class);\r\n```\r\n\r\n当然， API 单例资源也可以是 `可创建的` ，它将注册 `store` 和 `destroy` 资源路由：\r\n\r\n```php\r\nRoute::apiSingleton('photos.thumbnail', ProfileController::class)->creatable();\r\n```\r\n\r\n<a name=\"dependency-injection-and-controllers\"></a>\r\n## 依赖注入和控制器\r\n\r\n<a name=\"constructor-injection\"></a>\r\n#### 构造函数注入\r\n\r\nLaravel [服务容器](/docs/laravel/10.x/container) 用于解析所有 Laravel 控制器。因此，可以在其构造函数中对控制器可能需要的任何依赖项进行类型提示。声明的依赖项将自动解析并注入到控制器实例中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Repositories\\UserRepository;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 创建新控制器实例。\r\n         */\r\n        public function __construct(\r\n            protected UserRepository $users,\r\n        ) {}\r\n    }\r\n\r\n\r\n\r\n<a name=\"method-injection\"></a>\r\n#### 方法注入\r\n\r\n除了构造函数注入，还可以在控制器的方法上键入提示依赖项。方法注入的一个常见用例是将 `Illuminate\\Http\\Request` 实例注入到控制器方法中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 存储新用户。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $name = $request->name;\r\n\r\n            // 存储用户。。。\r\n\r\n            return redirect('/users');\r\n        }\r\n    }\r\n\r\n如果控制器方法也需要路由参数，那就在其他依赖项之后列出路由参数。例如，路由是这样定义的：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    Route::put('/user/{id}', [UserController::class, 'update']);\r\n\r\n如下所示，你依然可以类型提示 `Illuminate\\Http\\Request` 并通过定义您的控制器方法访问 `id` 参数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 更新给定用户。\r\n         */\r\n        public function update(Request $request, string $id): RedirectResponse\r\n        {\r\n            // 更新用户。。。\r\n\r\n            return redirect('/users');\r\n        }\r\n    }\r\n\r\n","p":"docs/controllers.html"},{"t":"requests (HTTP 请求)","d":"\n# HTTP 请求\r\n\r\n-   [介绍](#introduction)\r\n-   [与请求交互](#interacting-with-the-request)\r\n    -   [访问请求](#accessing-the-request)\r\n    -   [请求路径、主机和方法](#request-path-and-method)\r\n    -   [请求头](#request-headers)\r\n    -   [请求 IP址](#request-ip-address)\r\n    -   [内容协商](#content-negotiation)\r\n    -   [PSR-7 请求](#psr7-requests)\r\n-   [输入](#input)\r\n    -   [检索输入](#retrieving-input)\r\n    -   [确定输入是否存在](#determining-if-input-is-present)\r\n    -   [合并额外的输入](#merging-additional-input)\r\n    -   [旧输入](#old-input)\r\n    -   [Cookies](#cookies)\r\n    -   [输入修剪和规范化](#input-trimming-and-normalization)\r\n-   [文件](#files)\r\n    -   [检索上传的文件](#retrieving-uploaded-files)\r\n    -   [存储上传的文件](#storing-uploaded-files)\r\n-   [配置可信代理](#configuring-trusted-proxies)\r\n-   [配置可信主机](#configuring-trusted-hosts)\r\n\r\n<a name=\"introduction\"></a>\r\n\r\n## 介绍\r\n\r\nLaravel 的 `Illuminate\\Http\\Request` 类提供了一种面向对象的方式来与当前由应用程序处理的 HTTP 请求进行交互，并检索提交请求的输入内容、Cookie 和文件。\r\n\r\n<a name=\"interacting-with-the-request\"></a>\r\n\r\n## 与请求交互\r\n\r\n<a name=\"accessing-the-request\"></a>\r\n\r\n### 访问请求\r\n\r\n要通过依赖注入获取当前的 HTTP 请求实例，您应该在路由闭包或控制器方法中导入 `Illuminate\\Http\\Request` 类。传入的请求实例将由 Laravel  [服务容器](/docs/laravel/10.x/container) 自动注入：\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse Illuminate\\Http\\RedirectResponse;\r\nuse Illuminate\\Http\\Request;\r\n\r\nclass UserController extends Controller\r\n{\r\n    /**\r\n     * 存储新用户。\r\n     */\r\n    public function store(Request $request): RedirectResponse\r\n    {\r\n        $name = $request->input('name');\r\n\r\n        // 存储用户……\r\n\r\n        return redirect('/users');\r\n    }\r\n}\r\n\r\n```\r\n\r\n如上所述，您也可以在路由闭包上导入 `Illuminate\\Http\\Request` 类。服务容器将在执行时自动将传入请求注入闭包中：\r\n\r\n```\r\nuse Illuminate\\Http\\Request;\r\n\r\nRoute::get('/', function (Request $request) {\r\n    // ...\r\n});\r\n```\n\n<a name=\"dependency-injection-route-parameters\"></a>\r\n\r\n#### 依赖注入和路由参数\r\n\r\n如果您的控制器方法还需要从路由参数中获取输入，则应该在其他依赖项之后列出路由参数。例如，如果您的路由定义如下：\r\n\r\n```\r\nuse App\\Http\\Controllers\\UserController;\r\n\r\nRoute::put('/user/{id}', [UserController::class, 'update']);\r\n\r\n```\r\n\r\n您仍然可以在控制器方法中使用类型提示的 `Illuminate\\Http\\Request` 并通过以下方式访问您的 `id` 路由参数来定义您的控制器方法：\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse Illuminate\\Http\\RedirectResponse;\r\nuse Illuminate\\Http\\Request;\r\n\r\nclass UserController extends Controller\r\n{\r\n    /**\r\n     * Update the specified user.\r\n     */\r\n    public function update(Request $request, string $id): RedirectResponse\r\n    {\r\n        // 更新用户...\r\n\r\n        return redirect('/users');\r\n    }\r\n}\r\n\r\n```\r\n\r\n<a name=\"request-path-and-method\"></a>\r\n\r\n### 请求路径、主机和方法\r\n\r\n`Illuminate\\Http\\Request` 实例提供各种方法来检查传入的 HTTP 请求，并扩展了 `Symfony\\Component\\HttpFoundation\\Request` 类。下面我们将讨论一些最重要的方法。\r\n\r\n<a name=\"retrieving-the-request-path\"></a>\r\n\r\n#### 获取请求路径\r\n\r\n`path` 方法返回请求的路径信息。因此，如果传入的请求针对 `http://example.com/foo/bar`，则 `path` 方法将返回 `foo/bar`：\r\n\r\n```\r\n$uri = $request->path();\r\n\r\n```\r\n\r\n<a name=\"inspecting-the-request-path\"></a>\r\n\r\n#### 检查请求路径/路由信息\r\n\r\n`is` 方法允许您验证传入请求路径是否与给定的模式匹配。当使用此方法时，您可以使用 `*` 字符作为通配符：\r\n\r\n```\r\nif ($request->is('admin/*')) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n使用 `routeIs` 方法，您可以确定传入的请求是否与 [命名路由](/docs/laravel/10.x/routing#named-routes) 匹配：\r\n\r\n```\r\nif ($request->routeIs('admin.*')) {\r\n    // ...\r\n}\r\n```\n\n<a name=\"retrieving-the-request-url\"></a>\r\n\r\n#### 获取请求 URL\r\n\r\n要获取传入请求的完整 URL，您可以使用 `url` 或 `fullUrl` 方法。`url` 方法将返回不带查询字符串的 URL，而`fullUrl` 方法将包括查询字符串：\r\n\r\n```\r\n$url = $request->url();\r\n\r\n$urlWithQueryString = $request->fullUrl();\r\n\r\n```\r\n\r\n如果您想将查询字符串数据附加到当前 URL，请调用 `fullUrlWithQuery` 方法。此方法将给定的查询字符串变量数组与当前查询字符串合并：\r\n\r\n```\r\n$request->fullUrlWithQuery(['type' => 'phone']);\r\n\r\n```\r\n\r\n<a name=\"retrieving-the-request-host\"></a>\r\n\r\n#### 获取请求 Host\r\n\r\n您可以通过 `host`、`httpHost` 和 `schemeAndHttpHost` 方法获取传入请求的 「host」：\r\n\r\n```\r\n$request->host();\r\n$request->httpHost();\r\n$request->schemeAndHttpHost();\r\n\r\n```\r\n\r\n<a name=\"retrieving-the-request-method\"></a>\r\n\r\n#### 获取请求方法\r\n\r\n`method` 方法将返回请求的 HTTP 动词。您可以使用 `isMethod` 方法来验证 HTTP 动词是否与给定的字符串匹配：\r\n\r\n```\r\n$method = $request->method();\r\n\r\nif ($request->isMethod('post')) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n<a name=\"request-headers\"></a>\r\n\r\n### 请求头\r\n\r\n您可以使用`header` 方法从 `Illuminate\\Http\\Request` 实例中检索请求标头。如果请求中没有该标头，则返回 `null`。但是，`header` 方法接受两个可选参数，如果该标头在请求中不存在，则返回第二个参数：\r\n\r\n```\r\n$value = $request->header('X-Header-Name');\r\n\r\n$value = $request->header('X-Header-Name', 'default');\r\n\r\n```\r\n\r\n`hasHeader` 方法可用于确定请求是否包含给定的标头：\r\n\r\n```\r\nif ($request->hasHeader('X-Header-Name')) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n为了方便起见，`bearerToken` 方法可用于从 `Authorization` 标头检索授权标记。如果不存在此类标头，将返回一个空字符串：\r\n\r\n```\r\n$token = $request->bearerToken();\r\n```\n\n<a name=\"request-ip-address\"></a>\r\n\r\n### 请求 IP 地址\r\n\r\n`ip` 方法可用于检索向您的应用程序发出请求的客户端的 IP 地址：\r\n\r\n```\r\n$ipAddress = $request->ip();\r\n\r\n```\r\n\r\n<a name=\"content-negotiation\"></a>\r\n\r\n### 内容协商\r\n\r\nLaravel 提供了几种方法，通过 `Accept` 标头检查传入请求的请求内容类型。首先，`getAcceptableContentTypes` 方法将返回包含请求接受的所有内容类型的数组：\r\n\r\n```\r\n$contentTypes = $request->getAcceptableContentTypes();\r\n\r\n```\r\n\r\n`accepts` 方法接受一个内容类型数组，并在请求接受任何内容类型时返回 `true`。否则，将返回 `false`：\r\n\r\n```\r\nif ($request->accepts(['text/html', 'application/json'])) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n您可以使用 `prefers` 方法确定给定内容类型数组中的哪种内容类型由请求最具优势。如果请求未接受任何提供的内容类型，则返回 `null`：\r\n\r\n```\r\n$preferred = $request->prefers(['text/html', 'application/json']);\r\n\r\n```\r\n\r\n由于许多应用程序仅提供 HTML 或 JSON，因此您可以使用 `expectsJson` 方法快速确定传入请求是否期望获得 JSON 响应：\r\n\r\n```\r\nif ($request->expectsJson()) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n<a name=\"psr7-requests\"></a>\r\n\r\n### PSR-7 请求\r\n\r\n[PSR-7 标准](https://www.php-fig.org/psr/psr-7/) 指定了 HTTP 消息的接口，包括请求和响应。如果您想要获取 PSR-7 请求的实例而不是 Laravel 请求，您首先需要安装一些库。Laravel 使用 *Symfony HTTP Message Bridge* 组件将典型的 Laravel 请求和响应转换为 PSR-7 兼容的实现：\r\n\r\n```shell\r\ncomposer require symfony/psr-http-message-bridge\r\ncomposer require nyholm/psr7\r\n```\n\n安装这些库之后，您可以通过在路由闭包或控制器方法上的请求接口进行类型提示来获取 PSR-7 请求：\r\n\r\n```\r\nuse Psr\\Http\\Message\\ServerRequestInterface;\r\n\r\nRoute::get('/', function (ServerRequestInterface $request) {\r\n    // ...\r\n});\r\n\r\n```\r\n\r\n> **注意**\r\n> 如果您从路由或控制器返回 PSR-7 响应实例，它将自动转换回 Laravel 响应实例，并由框架显示。\r\n\r\n<a name=\"input\"></a>\r\n\r\n## 输入\r\n\r\n<a name=\"retrieving-input\"></a>\r\n\r\n### 检索输入\r\n\r\n<a name=\"retrieving-all-input-data\"></a>\r\n\r\n#### 检索所有输入数据\r\n\r\n您可以使用 `all` 方法将所有传入请求的输入数据作为 `array` 检索。无论传入请求是否来自 HTML 表单或 XHR 请求，都可以使用此方法：\r\n\r\n```\r\n$input = $request->all();\r\n\r\n```\r\n\r\n使用 `collect` 方法，您可以将所有传入请求的输入数据作为 [集合](/docs/laravel/10.x/collections) 检索：\r\n\r\n```\r\n$input = $request->collect();\r\n\r\n```\r\n\r\n`collect` 方法还允许您将传入请求的子集作为集合检索：\r\n\r\n```\r\n$request->collect('users')->each(function (string $user) {\r\n    // ...\r\n});\r\n\r\n```\r\n\r\n<a name=\"retrieving-an-input-value\"></a>\r\n\r\n#### 检索输入值\r\n\r\n使用几个简单的方法，无论请求使用了哪种 HTTP 动词，都可以从您的 `Illuminate\\Http\\Request` 实例访问所有用户输入。`input` 方法可用于检索用户输入：\r\n\r\n```\r\n$name = $request->input('name');\r\n\r\n```\r\n\r\n您可以将默认值作为第二个参数传递给 `input` 方法。如果请求中不存在所请求的输入值，则返回此值：\r\n\r\n```\r\n$name = $request->input('name', 'Sally');\r\n```\n\n处理包含数组输入的表单时，请使用「.」符号访问数组：\r\n\r\n```\r\n$name = $request->input('products.0.name');\r\n\r\n$names = $request->input('products.*.name');\r\n\r\n```\r\n\r\n您可以调用不带任何参数的 `input` 方法，以将所有输入值作为关联数组检索出来：\r\n\r\n```\r\n$input = $request->input();\r\n\r\n```\r\n\r\n<a name=\"retrieving-input-from-the-query-string\"></a>\r\n\r\n#### 从查询字符串检索输入\r\n\r\n虽然 `input` 方法从整个请求消息载荷（包括查询字符串）检索值，但 `query` 方法仅从查询字符串检索值：\r\n\r\n```\r\n$name = $request->query('name');\r\n\r\n```\r\n\r\n如果请求的查询字符串值数据不存在，则将返回此方法的第二个参数：\r\n\r\n```\r\n$name = $request->query('name', 'Helen');\r\n\r\n```\r\n\r\n您可以调用不带任何参数的 `query` 方法，以将所有查询字符串值作为关联数组检索出来：\r\n\r\n```\r\n$query = $request->query();\r\n\r\n```\r\n\r\n<a name=\"retrieving-json-input-values\"></a>\r\n\r\n#### 检索 JSON 输入值\r\n\r\n当向您的应用程序发送 JSON 请求时，只要请求的 `Content-Type` 标头正确设置为 `application/json`，您就可以通过 `input` 方法访问 JSON 数据。您甚至可以使用「.」语法来检索嵌套在 JSON 数组/对象中的值：\r\n\r\n```\r\n$name = $request->input('user.name');\r\n\r\n```\r\n\r\n<a name=\"retrieving-stringable-input-values\"></a>\r\n\r\n#### 检索可字符串化的输入值\r\n\r\n您可以使用 `string` 方法将请求的输入数据检索为 [`Illuminate\\Support\\Stringable`](/docs/laravel/10.x/helpers#fluent-strings) 的实例，而不是将其作为基本 `string` 检索：\r\n\r\n```\r\n$name = $request->string('name')->trim();\r\n\r\n```\r\n\r\n<a name=\"retrieving-boolean-input-values\"></a>\n\n#### 检索布尔值输入\r\n\r\n处理类似复选框的 HTML 元素时，您的应用程序可能会接收到实际上是字符串的「true」。例如，「true」或「on」。为了方便起见，您可以使用 `boolean` 方法将这些值作为布尔值检索。`boolean` 方法对于 1，「1」，true，「true」，「on」和「yes」，返回 `true`。所有其他值将返回 `false`：\r\n\r\n```\r\n$archived = $request->boolean('archived');\r\n\r\n```\r\n\r\n<a name=\"retrieving-date-input-values\"></a>\r\n\r\n#### 检索日期输入值\r\n\r\n为了方便起见，包含日期 / 时间的输入值可以使用 `date` 方法检索为 Carbon 实例。如果请求中不包含给定名称的输入值，则返回 `null`：\r\n\r\n```\r\n$birthday = $request->date('birthday');\r\n\r\n```\r\n\r\n`date` 方法可接受的第二个和第三个参数可用于分别指定日期的格式和时区：\r\n\r\n```\r\n$elapsed = $request->date('elapsed', '!H:i', 'Europe/Madrid');\r\n\r\n```\r\n\r\n如果输入值存在但格式无效，则会抛出一个 `InvalidArgumentException` 异常；因此，在调用 `date` 方法之前建议对输入进行验证。\r\n\r\n<a name=\"retrieving-enum-input-values\"></a>\r\n\r\n#### 检索枚举输入值\r\n\r\n还可以从请求中检索对应于 [PHP 枚举](https://www.php.net/manual/en/language.types.enumerations.php) 的输入值。如果请求中不包含给定名称的输入值或枚举没有与输入值匹配的备份值，则返回 `null`。`enum` 方法接受输入值的名称和枚举类作为其第一个和第二个参数：\r\n\r\n```\r\nuse App\\Enums\\Status;\r\n\r\n$status = $request->enum('status', Status::class);\r\n```\n\n<a name=\"retrieving-input-via-dynamic-properties\"></a>\r\n\r\n#### 通过动态属性检索输入\r\n\r\n您也可以使用 `Illuminate\\Http\\Request` 实例上的动态属性访问用户输入。例如，如果您的应用程序的表单之一包含一个 `name` 字段，则可以像这样访问该字段的值：\r\n\r\n```php\r\n$name = $request->name;\r\n\r\n```\r\n\r\n使用动态属性时，Laravel 首先会在请求负载中查找参数的值，如果不存在，则会在匹配路由的参数中搜索该字段。\r\n\r\n<a name=\"retrieving-a-portion-of-the-input-data\"></a>\r\n\r\n#### 检索输入数据的一部分\r\n\r\n如果您需要检索输入数据的子集，则可以使用 `only` 和 `except` 方法。这两个方法都接受一个单一的 `array` 或动态参数列表：\r\n\r\n```php\r\n$input = $request->only(['username', 'password']);\r\n\r\n$input = $request->only('username', 'password');\r\n\r\n$input = $request->except(['credit_card']);\r\n\r\n$input = $request->except('credit_card');\r\n\r\n```\r\n\r\n> **警告**\r\n> `only` 方法返回您请求的所有键 / 值对；但是，它不会返回请求中不存在的键 / 值对。\r\n\r\n<a name=\"determining-if-input-is-present\"></a>\r\n\r\n### 判断输入是否存在\r\n\r\n您可以使用 `has` 方法来确定请求中是否存在某个值。如果请求中存在该值则 `has` 方法返回 `true`：\r\n\r\n```\r\nif ($request->has('name')) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n当给定一个数组时，`has` 方法将确定所有指定的值是否都存在：\r\n\r\n```\r\nif ($request->has(['name', 'email'])) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n`whenHas` 方法将在请求中存在一个值时执行给定的闭包：\r\n\r\n```\r\n$request->whenHas('name', function (string $input) {\r\n    // ...\r\n});\r\n```\n\n可以通过向 `whenHas` 方法传递第二个闭包来执行，在请求中没有指定值的情况下：\r\n\r\n```\r\n$request->whenHas('name', function (string $input) {\r\n    // \"name\" 值存在...\r\n}, function () {\r\n    // \"name\" 值不存在...\r\n});\r\n\r\n```\r\n\r\n`hasAny` 方法返回 `true`，如果任一指定的值存在，则它返回 `true`：\r\n\r\n```\r\nif ($request->hasAny(['name', 'email'])) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n如果您想要确定请求中是否存在一个值且不是一个空字符串，则可以使用 `filled` 方法：\r\n\r\n```\r\nif ($request->filled('name')) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n`whenFilled` 方法将在请求中存在一个值且不是空字符串时执行给定的闭包：\r\n\r\n```\r\n$request->whenFilled('name', function (string $input) {\r\n    // ...\r\n});\r\n\r\n```\r\n\r\n可以通过向 `whenFilled` 方法传递第二个闭包来执行，在请求中没有指定值的情况下：\r\n\r\n```\r\n$request->whenFilled('name', function (string $input) {\r\n    // \"name\" 值已填写...\r\n}, function () {\r\n    // \"name\" 值未填写...\r\n});\r\n\r\n```\r\n\r\n要确定给定的键是否不存在于请求中，可以使用 `missing` 和 `whenMissing` 方法：\r\n\r\n```\r\nif ($request->missing('name')) {\r\n    // ...\r\n}\r\n\r\n$request->whenMissing('name', function (array $input) {\r\n    // \"name\" 值缺失...\r\n}, function () {\r\n    // \"name\" 值存在...\r\n});\r\n\r\n```\r\n\r\n<a name=\"merging-additional-input\"></a>\r\n\r\n### 合并其他输入\r\n\r\n有时，您可能需要手动将其他输入合并到请求的现有输入数据中。为此，可以使用 `merge` 方法。如果给定的输入键已经存在于请求中，它将被提供给 `merge` 方法的数据所覆盖：\r\n\r\n```\r\n$request->merge(['votes' => 0]);\r\n```\n\n如果请求的输入数据中不存在相应的键，则可以使用 `mergeIfMissing` 方法将输入合并到请求中：\r\n\r\n```\r\n$request->mergeIfMissing(['votes' => 0]);\r\n\r\n```\r\n\r\n<a name=\"old-input\"></a>\r\n\r\n### 旧输入\r\n\r\nLaravel 允许你在两次请求之间保留数据。这个特性在检测到验证错误后重新填充表单时特别有用。但是，如果您使用 Laravel 的包含的 [表单验证](/docs/laravel/10.x/validation)，不需要自己手动调用这些方法，因为 Laravel 的一些内置验证功能将自动调用它们。\r\n\r\n<a name=\"flashing-input-to-the-session\"></a>\r\n\r\n#### 闪存输入到 Session\r\n\r\n在 `Illuminate\\Http\\Request` 类上的 `flash` 方法将当前输入闪存到 [session](/docs/laravel/10.x/session)，以便在下一次用户请求应用程序时使用：\r\n\r\n```\r\n$request->flash();\r\n\r\n```\r\n\r\n您还可以使用 `flashOnly` 和 `flashExcept` 方法闪存一部分请求数据到  Session。这些方法对于将敏感信息（如密码）排除在 Session 外的情况下非常有用：\r\n\r\n```\r\n$request->flashOnly(['username', 'email']);\r\n\r\n$request->flashExcept('password');\r\n\r\n```\r\n\r\n<a name=\"flashing-input-then-redirecting\"></a>\r\n\r\n#### 闪存输入后重定向\r\n\r\n由于您通常希望闪存输入到 Session，然后重定向到以前的页面，因此您可以使用 `withInput` 方法轻松地将输入闪存到重定向中：\r\n\r\n```\r\nreturn redirect('form')->withInput();\r\n\r\nreturn redirect()->route('user.create')->withInput();\r\n\r\nreturn redirect('form')->withInput(\r\n    $request->except('password')\r\n);\r\n\r\n```\r\n\r\n<a name=\"retrieving-old-input\"></a>\r\n\r\n#### 检索旧输入值\n\n若要获取上一次请求所保存的旧输入数据，可以在 `Illuminate\\Http\\Request` 的实例上调用 `old` 方法。`old` 方法会从 [session](/docs/laravel/10.x/session) 中检索先前闪存的输入数据：\r\n\r\n```\r\n$username = $request->old('username');\r\n\r\n```\r\n\r\n此外，Laravel 还提供了一个全局辅助函数 `old`。如果您在 [Blade 模板](/docs/laravel/10.x/blade) 中显示旧的输入，则更方便使用 `old` 辅助函数重新填充表单。如果给定字段没有旧输入，则会返回 `null`：\r\n\r\n```\r\n<input type=\"text\" name=\"username\" value=\"{{ old('username') }}\">\r\n\r\n```\r\n\r\n<a name=\"cookies\"></a>\r\n\r\n### Cookies\r\n\r\n<a name=\"retrieving-cookies-from-requests\"></a>\r\n\r\n#### 检索请求中的 Cookies\r\n\r\nLaravel 框架创建的所有 cookies 都经过加密并签名，这意味着如果客户端更改了 cookie 值，则这些 cookie 将被视为无效。要从请求中检索 cookie 值，请在 `Illuminate\\Http\\Request` 实例上使用 `cookie` 方法：\r\n\r\n```\r\n$value = $request->cookie('name');\r\n\r\n```\r\n\r\n<a name=\"input-trimming-and-normalization\"></a>\r\n\r\n## 输入过滤和规范化\r\n\r\n默认情况下，Laravel 在应用程序的全局中间件栈中包含 `App\\Http\\Middleware\\TrimStrings` 和 `Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull` 中间件。这些中间件在 `App\\Http\\Kernel` 类的全局中间件栈中列出。这些中间件将自动修剪请求中的所有字符串字段，并将任何空字符串字段转换为 `null`。这使您不必在路由和控制器中担心这些规范化问题。\r\n\r\n#### 禁用输入规范化\r\n\r\n如果要禁用所有请求的该行为，可以从 `App\\Http\\Kernel` 类的 `$middleware` 属性中删除这两个中间件，从而将它们从应用程序的中间件栈中删除。\n\n如果您想要禁用应用程序的一部分请求的字符串修剪和空字符串转换，可以使用中间件提供的 `skipWhen` 方法。该方法接受一个闭包，该闭包应返回 `true` 或 `false`，以指示是否应跳过输入规范化。通常情况下，需要在应用程序的 `AppServiceProvider` 的 `boot` 方法中调用 `skipWhen` 方法。\r\n\r\n```php\r\nuse App\\Http\\Middleware\\TrimStrings;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull;\r\n\r\n/**\r\n * Bootstrap any application services.\r\n */\r\npublic function boot(): void\r\n{\r\n    TrimStrings::skipWhen(function (Request $request) {\r\n        return $request->is('admin/*');\r\n    });\r\n\r\n    ConvertEmptyStringsToNull::skipWhen(function (Request $request) {\r\n        // ...\r\n    });\r\n}\r\n```\r\n\r\n<a name=\"files\"></a>\r\n\r\n## 文件\r\n\r\n<a name=\"retrieving-uploaded-files\"></a>\r\n\r\n### 检索上传的文件\r\n\r\n您可以使用 `file` 方法或动态属性从 `Illuminate\\Http\\Request` 实例中检索已上传的文件。`file` 方法返回 `Illuminate\\Http\\UploadedFile` 类的实例，该类扩展了 PHP 的 `SplFileInfo` 类，并提供了各种用于与文件交互的方法：\r\n\r\n```php\r\n$file = $request->file('photo');\r\n\r\n$file = $request->photo;\r\n\r\n```\r\n\r\n您可以使用 `hasFile` 方法检查请求中是否存在文件：\r\n\r\n```php\r\nif ($request->hasFile('photo')) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n<a name=\"validating-successful-uploads\"></a>\r\n\r\n#### 验证成功上传的文件\r\n\r\n除了检查文件是否存在之外，您还可以通过 `isValid` 方法验证上传文件时是否存在问题：\r\n\r\n```php\r\nif ($request->file('photo')->isValid()) {\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n<a name=\"file-paths-extensions\"></a>\r\n\r\n#### 文件路径和扩展名\r\n\r\n`UploadedFile` 类还包含访问文件的完全限定路径及其扩展名的方法。`extension` 方法将尝试基于其内容猜测文件的扩展名。此扩展名可能与客户端提供的扩展名不同：\r\n\r\n```php\r\n$path = $request->photo->path();\r\n\r\n$extension = $request->photo->extension();\r\n```\n\n<a name=\"other-file-methods\"></a>\r\n\r\n#### 其他文件方法\r\n\r\n`UploadedFile` 实例有许多其他可用的方法。有关这些方法的更多信息，请查看该类的 [API文档](https://github.com/symfony/symfony/blob/6.0/src/Symfony/Component/HttpFoundation/File/UploadedFile.php) 。\r\n\r\n<a name=\"storing-uploaded-files\"></a>\r\n\r\n### 存储上传的文件\r\n\r\n要存储已上传的文件，通常会使用您配置的一个[文件系统](/docs/laravel/10.x/filesystem) 。`UploadedFile` 类具有一个 `store` 方法，该方法将上传的文件移动到您的磁盘中的一个位置，该位置可以是本地文件系统上的位置，也可以是像 Amazon S3 这样的云存储位置。\r\n\r\n`store` 方法接受存储文件的路径，该路径相对于文件系统的配置根目录。此路径不应包含文件名，因为将自动生成唯一的 ID 作为文件名。\r\n\r\n`store` 方法还接受一个可选的第二个参数，用于指定应用于存储文件的磁盘的名称。该方法将返回相对于磁盘根目录的文件路径：\r\n\r\n```php\r\n$path = $request->photo->store('images');\r\n\r\n$path = $request->photo->store('images', 's3');\r\n\r\n```\r\n\r\n如果您不希望自动生成文件名，则可以使用 `storeAs` 方法，该方法接受路径、文件名和磁盘名称作为其参数：\r\n\r\n```php\r\n$path = $request->photo->storeAs('images', 'filename.jpg');\r\n\r\n$path = $request->photo->storeAs('images', 'filename.jpg', 's3');\r\n\r\n```\r\n\r\n> **注意**\r\n> 有关在 Laravel 中存储文件的更多信息，请查看完整的 [文件存储文档](/docs/laravel/10.x/filesystem) 。\n\n<a name=\"configuring-trusted-proxies\"></a>\r\n\r\n## 配置受信任的代理\r\n\r\n在终止 TLS / SSL 证书的负载平衡器后面运行应用程序时，您可能会注意到，使用 `url` 帮助程序时，应用程序有时不会生成 HTTPS 链接。通常，这是因为正在从端口 `80` 上的负载平衡器转发应用程序的流量，并且不知道它应该生成安全链接。\r\n\r\n为了解决这个问题，您可以使用 `App\\Http\\Middleware\\TrustProxies` 中间件，这个中间件已经包含在 Laravel 应用程序中，它允许您快速定制应用程序应信任的负载均衡器或代理。您信任的代理应该被列在此中间件的 `$proxies` 属性上的数组中。除了配置受信任的代理之外，您还可以配置应该信任的代理 `$headers`：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Http\\Middleware;\r\n\r\nuse Illuminate\\Http\\Middleware\\TrustProxies as Middleware;\r\nuse Illuminate\\Http\\Request;\r\n\r\nclass TrustProxies extends Middleware\r\n{\r\n    /**\r\n     * 此应用程序的受信任代理。\r\n     *\r\n     * @var string|array\r\n     */\r\n    protected $proxies = [\r\n        '192.168.1.1',\r\n        '192.168.1.2',\r\n    ];\r\n\r\n    /**\r\n     * 应用于检测代理的标头。\r\n     *\r\n     * @var int\r\n     */\r\n    protected $headers = Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_HOST | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO;\r\n}\r\n\r\n```\r\n\r\n> **注意**\r\n> 如果您正在使用 AWS 弹性负载平衡，请将 `$headers` 值设置为 `Request::HEADER_X_FORWARDED_AWS_ELB`。有关可在 `$headers` 属性中使用的常量的更多信息，请查看 Symfony 关于 [信任代理](https://symfony.com/doc/current/deployment/proxies.html) 的文档。\r\n\r\n<a name=\"trusting-all-proxies\"></a>\n\n#### 信任所有代理\r\n\r\n如果您使用的是 Amazon AWS 或其他「云」负载均衡器提供商，则可能不知道实际负载均衡器的 IP 地址。在这种情况下，您可以使用 `*` 来信任所有代理：\r\n\r\n```\r\n/**\r\n * 应用所信任的代理。\r\n *\r\n * @var string|array\r\n */\r\nprotected $proxies = '*';\r\n\r\n```\r\n\r\n<a name=\"configuring-trusted-hosts\"></a>\r\n\r\n## 配置可信任的 Host\r\n\r\n默认情况下，Laravel 将响应它接收到的所有请求，而不管 HTTP 请求的 `Host` 标头的内容是什么。此外，在 web 请求期间生成应用程序的绝对 URL 时，将使用 `Host` 头的值。\r\n\r\n通常情况下，您应该配置您的 Web 服务器（如 Nginx 或 Apache）仅向匹配给定主机名的应用程序发送请求。然而，如果您没有直接自定义您的 Web 服务器的能力，需要指示 Laravel 仅响应特定主机名的请求，您可以为您的应用程序启用 `App\\Http\\Middleware\\TrustHosts` 中间件。\r\n\r\n`TrustHosts` 中间件已经包含在应用程序的 `$middleware` 堆栈中；但是，您应该将其取消注释以使其生效。在此中间件的 `hosts` 方法中，您可以指定您的应用程序应该响应的主机名。具有其他 `Host` 值标头的传入请求将被拒绝：\r\n\r\n```\r\n/**\r\n * 获取应被信任的主机模式。\r\n *\r\n * @return array<int, string>\r\n */\r\npublic function hosts(): array\r\n{\r\n    return [\r\n        'laravel.test',\r\n        $this->allSubdomainsOfApplicationUrl(),\r\n    ];\r\n}\r\n\r\n```\r\n\r\n`allSubdomainsOfApplicationUrl` 帮助程序方法将返回与您的应用程序 `app.url` 配置值的所有子域相匹配的正则表达式。在构建利用通配符子域的应用程序时，这个帮助程序提供了一种方便的方法来允许所有应用程序的子域。\n","p":"docs/requests.html"},{"t":"responses (响应)","d":"\n# 响应\r\n\r\n- [创建响应](#creating-responses)\r\n    - [添加响应头](#attaching-headers-to-responses)\r\n    - [添加响应 Cookies](#attaching-cookies-to-responses)\r\n    - [Cookies & 加密](#cookies-and-encryption)\r\n- [重定向](#redirects)\r\n    - [重定向到命名路由](#redirecting-named-routes)\r\n    - [重定向到控制器方法](#redirecting-controller-actions)\r\n    - [重定向到外部域名](#redirecting-external-domains)\r\n    - [重定向并使用闪存的 Session 数据](#redirecting-with-flashed-session-data)\r\n- [其它响应类型](#other-response-types)\r\n    - [视图响应](#view-responses)\r\n    - [JSON 响应](#json-responses)\r\n    - [文件下载](#file-downloads)\r\n    - [文件响应](#file-responses)\r\n- [响应宏](#response-macros)\r\n\r\n<a name=\"creating-responses\"></a>\r\n## 创建响应\r\n\r\n<a name=\"strings-arrays\"></a>\r\n#### 字符串 & 数组\r\n\r\n所有路由和控制器处理完业务逻辑之后都会返回响应到用户的浏览器，Laravel 提供了多种不同的响应方式，其中最基本就是从路由或控制器返回一个简单的字符串，框架会自动将这个字符串转化为一个完整的 HTTP 响应：\r\n\r\n    Route::get('/', function () {\r\n        return 'Hello World';\r\n    });\r\n\r\n除了从路由和控制器返回字符串之外，你还可以返回数组。 框架会自动将数组转换为 JSON 响应：\r\n\r\n    Route::get('/', function () {\r\n        return [1, 2, 3];\r\n    });\r\n\r\n> **技巧**  \r\n> 你知道从路由或控制器还可以返回 [Eloquent 集合](/docs/laravel/10.x/eloquent-collections)吗？他们也会自动转化为 JSON 响应！\r\n\r\n<a name=\"response-objects\"></a>\r\n#### Response 对象\r\n\r\n通常情况下会只返回简单的字符串或数组，大多数时候，需要返回一个完整的`Illuminate\\Http\\Response`实例或是[视图](/docs/laravel/10.x/views).\r\n\r\n返回一个完整的`Response` 实例允许你自定义返回的 HTTP 状态码和返回头信息。`Response`实例继承自`Symfony\\Component\\HttpFoundation\\Response`类，该类提供了各种构建 HTTP 响应的方法：\r\n\r\n    Route::get('/home', function () {\r\n        return response('Hello World', 200)\r\n                      ->header('Content-Type', 'text/plain');\r\n    });\r\n\r\n\n\n<a name=\"eloquent-models-and-collections\"></a>\r\n#### Eloquent 模型 和 集合\r\n\r\n你也可以直接从你的路由和控制器返回 [Eloquent ORM](/docs/laravel/10.x/eloquent) 模型和集合。当你这样做时，Laravel 将自动将模型和集合转换为 JSON 响应，同时遵循模型的 [隐藏属性](/docs/laravel/10.x/eloquent-serialization#hiding-attributes-from-json):\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{user}', function (User $user) {\r\n        return $user;\r\n    });\r\n\r\n<a name=\"attaching-headers-to-responses\"></a>\r\n### 在响应中附加 Header 信息\r\n\r\n请记住，大多数响应方法都是可以链式调用的，它允许你流畅地构建响应实例。例如，在将响应发送回用户之前，可以使用 `header` 方法将一系列头添加到响应中：\r\n\r\n    return response($content)\r\n                ->header('Content-Type', $type)\r\n                ->header('X-Header-One', 'Header Value')\r\n                ->header('X-Header-Two', 'Header Value');\r\n\r\n或者，你可以使用 `withHeaders` 方法指定要添加到响应的标头数组：\r\n\r\n    return response($content)\r\n                ->withHeaders([\r\n                    'Content-Type' => $type,\r\n                    'X-Header-One' => 'Header Value',\r\n                    'X-Header-Two' => 'Header Value',\r\n                ]);\r\n\r\n<a name=\"cache-control-middleware\"></a>\r\n#### 缓存控制中间件\r\n\r\nLaravel 包含一个 `cache.headers` 中间件，可用于快速设置一组路由的 `Cache-Control` 标头。指令应使用相应缓存控制指令的 蛇形命名法 等效项提供，并应以分号分隔。如果在指令列表中指定了 `etag` ，则响应内容的 MD5 哈希将自动设置为 ETag 标识符：\r\n\r\n    Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {\r\n        Route::get('/privacy', function () {\r\n            // ...\r\n        });\r\n\r\n        Route::get('/terms', function () {\r\n            // ...\r\n        });\r\n    });\r\n\r\n\n\n<a name=\"attaching-cookies-to-responses\"></a>\r\n### 在响应中附加 Cookie 信息\r\n\r\n可以使用 `cookie` 方法将 cookie 附加到传出的 `illumize\\Http\\Response` 实例。你应将 cookie 的名称、值和有效分钟数传递给此方法：\r\n\r\n    return response('Hello World')->cookie(\r\n        'name', 'value', $minutes\r\n    );\r\n\r\n`cookie` 方法还接受一些使用频率较低的参数。通常，这些参数的目的和意义与 PHP 的原生 [setcookie](https://secure.php.net/manual/en/function.setcookie.php) 的参数相同\r\n\r\n    return response('Hello World')->cookie(\r\n        'name', 'value', $minutes, $path, $domain, $secure, $httpOnly\r\n    );\r\n\r\n如果你希望确保 cookie 与传出响应一起发送，但你还没有该响应的实例，则可以使用 `Cookie` facade 将 cookie 加入队列，以便在发送响应时附加到响应中。`queue` 方法接受创建 cookie 实例所需的参数。在发送到浏览器之前，这些 cookies 将附加到传出的响应中：\r\n\r\n    use Illuminate\\Support\\Facades\\Cookie;\r\n\r\n    Cookie::queue('name', 'value', $minutes);\r\n\r\n<a name=\"generating-cookie-instances\"></a>\r\n#### 生成 Cookie 实例\r\n\r\n如果要生成一个 `Symfony\\Component\\HttpFoundation\\Cookie` 实例，打算稍后附加到响应实例中，你可以使用全局 `cookie` 助手函数。此 cookie 将不会发送回客户端，除非它被附加到响应实例中：\r\n\r\n    $cookie = cookie('name', 'value', $minutes);\r\n\r\n    return response('Hello World')->cookie($cookie);\r\n\r\n\n\n<a name=\"expiring-cookies-early\"></a>\r\n#### 提前过期 Cookies\r\n\r\n你可以通过响应中的`withoutCookie`方法使 cookie 过期，用于删除 cookie ：\r\n\r\n    return response('Hello World')->withoutCookie('name');\r\n\r\n如果尚未有创建响应的实例，则可以使用`Cookie` facade 中的`expire` 方法使 Cookie 过期：\r\n\r\n    Cookie::expire('name');\r\n\r\n<a name=\"cookies-and-encryption\"></a>\r\n### Cookies 和 加密\r\n\r\n默认情况下，由 Laravel 生成的所有 cookie 都经过了加密和签名，因此客户端无法篡改或读取它们。如果要对应用程序生成的部分 cookie 禁用加密，可以使用`App\\Http\\Middleware\\EncryptCookies`中间件的`$except`属性，该属性位于`app/Http/Middleware`目录中：\r\n\r\n    /**\r\n     * 这个名字的 Cookie 将不会加密。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $except = [\r\n        'cookie_name',\r\n    ];\r\n\r\n<a name=\"redirects\"></a>\r\n## 重定向\r\n\r\n重定向响应是`Illuminate\\Http\\RedirectResponse` 类的实例，包含将用户重定向到另一个 URL 所需的适当 HTTP 头。Laravel 有几种方法可以生成`RedirectResponse`实例。最简单的方法是使用全局`redirect`助手函数：\r\n\r\n    Route::get('/dashboard', function () {\r\n        return redirect('home/dashboard');\r\n    });\r\n\r\n有时你可能希望将用户重定向到以前的位置，例如当提交的表单无效时。你可以使用全局 back 助手函数来执行此操作。由于此功能使用 [session](/docs/laravel/10.x/session)，请确保调用`back` 函数的路由使用的是`web`中间件组：\r\n\r\n    Route::post('/user/profile', function () {\r\n        // 验证请求参数\r\n\r\n        return back()->withInput();\r\n    });\r\n\r\n\n\n<a name=\"redirecting-named-routes\"></a>\r\n### 重定向到指定名称的路由\r\n\r\n当你在没有传递参数的情况下调用 `redirect` 助手函数时，将返回 `Illuminate\\Routing\\Redirector` 的实例，允许你调用 `Redirector` 实例上的任何方法。例如，要对命名路由生成 `RedirectResponse` ，可以使用 `route` 方法：\r\n\r\n    return redirect()->route('login');\r\n\r\n如果路由中有参数，可以将其作为第二个参数传递给 `route` 方法：\r\n\r\n    // 对于具有以下URI的路由: /profile/{id}\r\n\r\n    return redirect()->route('profile', ['id' => 1]);\r\n\r\n<a name=\"populating-parameters-via-eloquent-models\"></a>\r\n#### 通过 Eloquent 模型填充参数\r\n\r\n如果你要重定向到使用从 Eloquent 模型填充 「ID」 参数的路由，可以直接传递模型本身。ID 将会被自动提取：\r\n\r\n    // 对于具有以下URI的路由: /profile/{id}\r\n\r\n    return redirect()->route('profile', [$user]);\r\n\r\n如果你想要自定义路由参数，你可以指定路由参数 (`/profile/{id:slug}`) 或者重写 Eloquent 模型上的 `getRouteKey` 方法：\r\n\r\n    /**\r\n     * 获取模型的路由键值。\r\n     */\r\n    public function getRouteKey(): mixed\r\n    {\r\n        return $this->slug;\r\n    }\r\n\r\n<a name=\"redirecting-controller-actions\"></a>\r\n### 重定向到控制器行为\r\n\r\n也可以生成重定向到 [controller actions](/docs/laravel/10.x/controllers)。只要把控制器和 action 的名称传递给 `action` 方法：\r\n\r\n    use App\\Http\\Controllers\\UserController;\r\n\r\n    return redirect()->action([UserController::class, 'index']);\r\n\r\n如果控制器路由有参数，可以将其作为第二个参数传递给 `action` 方法：\r\n\r\n    return redirect()->action(\r\n        [UserController::class, 'profile'], ['id' => 1]\r\n    );\r\n\r\n\n\n<a name=\"redirecting-external-domains\"></a>\r\n### 重定向到外部域名\r\n\r\n有时候你需要重定向到应用外的域名。可以通过调用`away`方法，它会创建一个不带有任何额外的 URL 编码、有效性校验和检查`RedirectResponse`实例：\r\n\r\n    return redirect()->away('https://www.google.com');\r\n\r\n<a name=\"redirecting-with-flashed-session-data\"></a>\r\n### 重定向并使用闪存的 Session 数据\r\n\r\n重定向到新的 URL 的同时[传送数据给 seesion](/docs/laravel/10.x/session#flash-data) 是很常见的。 通常这是在你将消息发送到 session 后成功执行操作后完成的。为了方便，你可以创建一个`RedirectResponse`实例并在链式方法调用中将数据传送给 session：\r\n\r\n    Route::post('/user/profile', function () {\r\n        // ...\r\n\r\n        return redirect('dashboard')->with('status', 'Profile updated!');\r\n    });\r\n\r\n在用户重定向后，你可以显示 [session](/docs/laravel/10.x/session)。例如，你可以使用[ Blade 模板语法](/docs/laravel/10.x/blade)：\r\n\r\n    @if (session('status'))\r\n        <div class=\"alert alert-success\">\r\n            {{ session('status') }}\r\n        </div>\r\n    @endif\r\n\r\n<a name=\"redirecting-with-input\"></a>\r\n#### 使用输入重定向\r\n\r\n你可以使用`RedirectResponse`实例提供的`withInput`方法将当前请求输入的数据发送到 session ，然后再将用户重定向到新位置。当用户遇到验证错误时，通常会执行此操作。每当输入数据被发送到 session , 你可以很简单的在下一次重新提交的表单请求中[取回它](/docs/laravel/10.x/requests#retrieving-old-input)：\r\n\r\n    return back()->withInput();\r\n\r\n<a name=\"other-response-types\"></a>\r\n\n\n## 其他响应类型\r\n\r\n`response` 助手可用于生成其他类型的响应实例。当不带参数调用 `response` 助手时，会返回 `Illuminate\\Contracts\\Routing\\ResponseFactory` [contract](/docs/laravel/10.x/contracts) 的实现。 该契约提供了几种有用的方法来生成响应。\r\n\r\n<a name=\"view-responses\"></a>\r\n### 响应视图\r\n\r\n如果你需要控制响应的状态和标头，但还需要返回 [view](/docs/laravel/10.x/views) 作为响应的内容，你应该使用 `view` 方法：\r\n\r\n    return response()\r\n                ->view('hello', $data, 200)\r\n                ->header('Content-Type', $type);\r\n\r\n当然，如果你不需要传递自定义 HTTP 状态代码或自定义标头，则可以使用全局 `view` 辅助函数。\r\n\r\n<a name=\"json-responses\"></a>\r\n### JSON Responses\r\n\r\n`json` 方法会自动将 `Content-Type` 标头设置为 `application/json`，并使用 `json_encode` PHP 函数将给定的数组转换为 JSON：\r\n\r\n    return response()->json([\r\n        'name' => 'Abigail',\r\n        'state' => 'CA',\r\n    ]);\r\n\r\n如果你想创建一个 JSONP 响应，你可以结合使用 `json` 方法和 `withCallback` 方法：\r\n\r\n    return response()\r\n                ->json(['name' => 'Abigail', 'state' => 'CA'])\r\n                ->withCallback($request->input('callback'));\r\n\r\n<a name=\"file-downloads\"></a>\r\n### 文件下载\r\n\r\n`download` 方法可用于生成强制用户浏览器在给定路径下载文件的响应。`download` 方法接受文件名作为该方法的第二个参数，这将确定下载文件的用户看到的文件名。 最后，你可以将一组 HTTP 标头作为该方法的第三个参数传递：\r\n\r\n    return response()->download($pathToFile);\r\n\r\n    return response()->download($pathToFile, $name, $headers);\r\n\r\n> 注意：管理文件下载的 Symfony HttpFoundation 要求正在下载的文件具有 ASCII 文件名。\r\n\n\n<a name=\"streamed-downloads\"></a>\r\n#### 流式下载\r\n\r\n有时你可能希望将给定操作的字符串响应转换为可下载的响应，而不必将操作的内容写入磁盘。在这种情况下，你可以使用`streamDownload`方法。此方法接受回调、文件名和可选的标头数组作为其参数：\r\n\r\n    use App\\Services\\GitHub;\r\n\r\n    return response()->streamDownload(function () {\r\n        echo GitHub::api('repo')\r\n                    ->contents()\r\n                    ->readme('laravel', 'laravel')['contents'];\r\n    }, 'laravel-readme.md');\r\n\r\n<a name=\"file-responses\"></a>\r\n### 文件响应\r\n\r\n`file`方法可用于直接在用户的浏览器中显示文件，例如图像或 PDF，而不是启动下载。这个方法接受文件的路径作为它的第一个参数和一个头数组作为它的第二个参数：\r\n\r\n    return response()->file($pathToFile);\r\n\r\n    return response()->file($pathToFile, $headers);\r\n\r\n<a name=\"response-macros\"></a>\r\n## 响应宏\r\n\r\n如果你想定义一个可以在各种路由和控制器中重复使用的自定义响应，你可以使用`Response` facade 上的`macro`方法。通常，你应该从应用程序的[服务提供者](/docs/laravel/10.x/providers)，如`App\\Providers\\AppServiceProvider`服务提供程序的`boot`方法调用此方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Response;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 启动一个应用的服务\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Response::macro('caps', function (string $value) {\r\n                return Response::make(strtoupper($value));\r\n            });\r\n        }\r\n    }\r\n\r\n`macro`函数接受名称作为其第一个参数，并接受闭包作为其第二个参数。当从`ResponseFactory`实现或`response`助手函数调用宏名称时，将执行宏的闭包：\r\n\r\n    return response()->caps('foo');\r\n\n","p":"docs/responses.html"},{"t":"views (视图)","d":"# 视图\r\n\r\n- [介绍](#introduction)\r\n    - [在 React / Vue 中编写视图](#writing-views-in-react-or-vue)\r\n- [创建和渲染视图](#creating-and-rendering-views)\r\n    - [嵌套视图目录](#nested-view-directories)\r\n    - [创建第一个可用视图](#creating-the-first-available-view)\r\n    - [确定视图是否存在](#determining-if-a-view-exists)\r\n- [向视图传递数据](#passing-data-to-views)\r\n    - [与所有视图分享数据](#sharing-data-with-all-views)\r\n- [视图组件](#view-composers)\r\n    - [视图构造器](#view-creators)\r\n- [视图构造器](#optimizing-views)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n当然，直接从路由和控制器返回整个 HTML 文档字符串是不切实际的。值得庆幸的是，视图提供了一种方便的方式来将我们所有的 HTML 放在单独的文件中。\r\n\r\n视图将你的控制器 / 应用程序逻辑与你的表示逻辑分开并存储在 `resources/views` 目录中。一个简单的视图可能看起来像这样：使用 Laravel 时，视图模板通常使用[Blade模板语言](/docs/laravel/10.x/blade) 编写。一个简单的视图如下所示：\r\n\r\n```blade\r\n<!-- 视图存储在 `resources/views/greeting.blade.php` -->\r\n\r\n<html>\r\n    <body>\r\n        <h1>Hello, {{ $name }}</h1>\r\n    </body>\r\n</html>\r\n```\r\n\r\n将上述代码存储到 `resources/views/greeting.blade.php` 后，我们可以使用全局辅助函数 `view` 将其返回，例如：\r\n\r\n    Route::get('/', function () {\r\n        return view('greeting', ['name' => 'James']);\r\n    });\r\n\r\n> 技巧：如果你想了解更多关于如何编写 Blade 模板的更多信息？查看完整的 [Blade 文档](/docs/laravel/10.x/blade) 将是最好的开始。\r\n\r\n<a name=\"writing-views-in-react-or-vue\"></a>\r\n### 在 React / Vue 中编写视图\r\n\r\n许多开发人员已经开始倾向于使用 React 或 Vue 编写模板，而不是通过 Blade 在 PHP 中编写前端模板。Laravel 让这件事不痛不痒，这要归功于 [惯性](https://inertiajs.com/)，这是一个库，可以轻松地将 React / Vue 前端连接到 Laravel 后端，而无需构建 SPA 的典型复杂性。\r\n\r\n\r\n我们的 Breeze 和 Jetstream [starter kits](https://laravel.com/docs/10.x/starter-kits) 为你提供了一个很好的起点，用 Inertia 驱动你的下一个 Laravel 应用程序。此外，[Laravel Bootcamp](https://bootcamp.laravel.com/) 提供了一个完整的演示，展示如何构建一个由 Inertia 驱动的 Laravel 应用程序，包括 Vue 和 React 的示例。\r\n\r\n<a name=\"creating-and-rendering-views\"></a>\r\n\r\n## 创建和渲染视图\r\n\r\n你可以通过在应用程序 `resources/views` 目录中放置具有 `.blade.php` 扩展名的文件来创建视图。该 `.blade.php` 扩展通知框架该文件包含一个 [Blade 模板](/docs/laravel/10.x/blade)。Blade 模板包含 HTML 和 Blade 指令，允许你轻松地回显值、创建「if」语句、迭代数据等。\r\n\r\n创建视图后，可以使用全局 `view` 从应用程序的某个路由或控制器返回视图：\r\n\r\n    Route::get('/', function () {\r\n        return view('greeting', ['name' => 'James']);\r\n    });\r\n\r\n也可以使用 `View` 视图门面（Facade）：\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    return View::make('greeting', ['name' => 'James']);\r\n\r\n如上所示，传递给 `view` 的第一个参数对应于 `resources/views` 目录中视图文件的名称。第二个参数是应该对视图可用的数据数组。在这种情况下，我们传递 name 变量，它使用 [Blade 语法](/docs/laravel/10.x/blade)显示在视图中。\r\n\r\n<a name=\"nested-view-directories\"></a>\r\n### 嵌套视图目录\r\n\r\n视图也可以嵌套在目录 `resources/views` 的子目录中。「.」符号可用于引用嵌套视图。例如，如果视图存储在  `resources/views/admin/profile.blade.php` ，你可以从应用程序的路由或控制器中返回它，如下所示：\r\n\r\n    return view('admin.profile', $data);\r\n\r\n> 注意：查看目录名称不应包含该 . 字符。\r\n\r\n\r\n\r\n<a name=\"creating-the-first-available-view\"></a>\r\n### 创建第一个可用视图\r\n\r\n使用 `View` 门面的 `first` 方法，你可以创建给定数组视图中第一个存在的视图。如果你的应用程序或开发的第三方包允许定制或覆盖视图，这会非常有用：\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    return View::first(['custom.admin', 'admin'], $data);\r\n\r\n<a name=\"determining-if-a-view-exists\"></a>\r\n### 判断视图文件是否存在\r\n\r\n如果需要判断视图文件是否存在，可以使用 `View` 门面。如果视图存在， `exists` 方法会返回 `true`：\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    if (View::exists('emails.customer')) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"passing-data-to-views\"></a>\r\n## 向视图传递数据\r\n\r\n正如您在前面的示例中看到的，您可以将数据数组传递给视图，以使该数据可用于视图：\r\n\r\n    return view('greetings', ['name' => 'Victoria']);\r\n\r\n以这种方式传递信息时，数据应该是带有键 / 值对的数组。向视图提供数据后，您可以使用数据的键访问视图中的每个值，例如 `<?php echo $name; ?>`。\r\n\r\n作为将完整的数据数组传递给 `view` 辅助函数的替代方法，你可以使用该 `with` 方法将单个数据添加到视图中。该 `with` 方法返回视图对象的实例，以便你可以在返回视图之前继续链接方法：\r\n\r\n    return view('greeting')\r\n                ->with('name', 'Victoria')\r\n                ->with('occupation', 'Astronaut');\r\n\r\n<a name=\"sharing-data-with-all-views\"></a>\r\n### 与所有视图共享数据\r\n\r\n有时，你可能需要与应用程序呈现的所有视图共享数据，可以使用 `View` 门面的 `share` 。你可以在服务提供器的 `boot` 方法中调用视图门面（Facade）的 share 。例如，可以将它们添加到 `App\\Providers\\AppServiceProvider` 或者为它们生成一个单独的服务提供器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册应用服务.\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            View::share('key', 'value');\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"view-composers\"></a>\r\n## 查看合成器\r\n\r\n视图合成器是在呈现视图时调用的回调或类方法。如果每次渲染视图时都希望将数据绑定到视图，则视图合成器可以帮助你将逻辑组织到单个位置。如果同一视图由应用程序中的多个路由或控制器返回，并且始终需要特定的数据，视图合成器或许会特别有用。\r\n\r\n通常，视图合成器将在应用程序的一个 [服务提供者](/docs/laravel/10.x/providers) 中注册。在本例中，我们假设我们已经创建了一个新的 `App\\Providers\\ViewServiceProvider` 来容纳此逻辑。\r\n\r\n我们将使用 `View` 门面的 `composer` 方法来注册视图合成器。 Laravel 不包含基于类的视图合成器的默认目录，因此你可以随意组织它们。例如，可以创建一个 `app/View/Composers` 目录来存放应用程序的所有视图合成器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\View\\Composers\\ProfileComposer;\r\n    use Illuminate\\Support\\Facades;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Illuminate\\View\\View;\r\n\r\n    class ViewServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务。\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            // 使用基于类的合成器。。。\r\n            Facades\\View::composer('profile', ProfileComposer::class);\r\n\r\n            // 使用基于闭包的合成器。。。\r\n            Facades\\View::composer('welcome', function (View $view) {\r\n                // ...\r\n            });\r\n\r\n            Facades\\View::composer('dashboard', function (View $view) {\r\n                // ...\r\n            });\r\n        }\r\n    }\r\n\r\n> 注意：请记住，如果创建一个新的服务提供程序来包含视图合成器注册，则需要将服务提供程序添加到 `config/app.php` 配置文件中的 `providers` 数组中。\r\n\r\n\r\n\r\n现在我们注册了视图合成器，每次渲染 `profile` 视图时都会执行 `App\\View\\Composers\\ProfileComposer` 类的 `compose` 方法。接下来看一个视图合成器类的例子：\r\n\r\n    <?php\r\n\r\n    namespace App\\View\\Composers;\r\n\r\n    use App\\Repositories\\UserRepository;\r\n    use Illuminate\\View\\View;\r\n\r\n    class ProfileComposer\r\n    {\r\n        /**\r\n         * 创建新的配置文件合成器。\r\n         */\r\n        public function __construct(\r\n            protected UserRepository $users,\r\n        ) {}\r\n\r\n        /**\r\n         * 将数据绑定到视图。\r\n         */\r\n        public function compose(View $view): void\r\n        {\r\n            $view->with('count', $this->users->count());\r\n        }\r\n    }\r\n\r\n如上所示，所有的视图合成器都会通过 [服务容器](/docs/laravel/10.x/container)进行解析，所以你可以在视图合成器的构造函数中类型提示需要注入的依赖项。\r\n\r\n<a name=\"attaching-a-composer-to-multiple-views\"></a>\r\n#### 将视图合成器添加到多个视图\r\n\r\n你可以通过将视图数组作为第一个参数传递给 `composer` 方法，可以一次添加多个视图到视图合成器中：\r\n\r\n    use App\\Views\\Composers\\MultiComposer;\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    View::composer(\r\n        ['profile', 'dashboard'],\r\n        MultiComposer::class\r\n    );\r\n\r\n该 `composer` 方法同时也接受通配符 `*` ，表示将所有视图添加到视图合成器中：\r\n\r\n    use Illuminate\\Support\\Facades;\r\n    use Illuminate\\View\\View;\r\n\r\n    Facades\\View::composer('*', function (View $view) {\r\n        // ...\r\n    });\r\n\r\n<a name=\"view-creators\"></a>\r\n### 视图构造器\r\n\r\n视图构造器「creators」和视图合成器非常相似。唯一不同之处在于视图构造器在视图实例化之后执行，而视图合成器在视图即将渲染时执行。使用 `creator` 方法注册视图构造器：\r\n\r\n    use App\\View\\Creators\\ProfileCreator;\r\n    use Illuminate\\Support\\Facades\\View;\r\n\r\n    View::creator('profile', ProfileCreator::class);\r\n\r\n\r\n\r\n<a name=\"optimizing-views\"></a>\r\n## 优化视图\r\n\r\n默认情况下，Blade 模板视图是按需编译的。当执行渲染视图的请求时，Laravel 将确定视图的编译版本是否存在。如果文件存在，Laravel 将比较未编译的视图和已编译的视图是否有修改。如果编译后的视图不存在，或者未编译的视图已被修改，Laravel 将重新编译该视图。\r\n\r\n在请求期间编译视图可能会对性能产生小的负面影响，因此 Laravel 提供了 `view:cache` Artisan 命令来预编译应用程序使用的所有视图。为了提高性能，你可能希望在部署过程中运行此命令：\r\n\r\n```shell\r\nphp artisan view:cache\r\n```\r\n\r\n你可以使用 `view:clear` 命令清除视图缓存：\r\n\r\n```shell\r\nphp artisan view:clear\r\n```\r\n\r\n","p":"docs/views.html"},{"t":"blade (Blade 模板)","d":"# Blade 模板\r\n\r\n- [简介](#introduction)\r\n    - [用 Livewire 为 Blade 赋能](#supercharging-blade-with-livewire)\r\n- [数据显示](#displaying-data)\r\n    - [HTML 实体编码](#html-entity-encoding)\r\n    - [Blade 与 JavaScript 框架](#blade-and-javascript-frameworks)\r\n- [Blade 指令](#blade-directives)\r\n    - [If 语句](#if-statements)\r\n    - [Switch 语句](#switch-statements)\r\n    - [循环](#loops)\r\n    - [循环变量](#the-loop-variable)\r\n    - [条件类](#conditional-classes)\r\n    - [附加属性](#additional-attributes)\r\n    - [包括子视图](#including-subviews)\r\n    - [`@once` 指令](#the-once-directive)\r\n    - [原始 PHP 语法](#raw-php)\r\n    - [注释](#comments)\r\n- [组件](#components)\r\n    - [渲染组件](#rendering-components)\r\n    - [组件传参](#passing-data-to-components)\r\n    - [组件属性](#component-attributes)\r\n    - [保留关键字](#reserved-keywords)\r\n    - [插槽](#slots)\r\n    - [内联组件视图](#inline-component-views)\r\n    - [动态组件](#dynamic-components)\r\n    - [手动注册组件](#manually-registering-components)\r\n- [匿名组件](#anonymous-components)\r\n    - [匿名索引组件](#anonymous-index-components)\r\n    - [数据特性/属性](#data-properties-attributes)\r\n    - [访问父级数据](#accessing-parent-data)\r\n    - [匿名组件路径](#anonymous-component-paths)\r\n- [创建布局](#building-layouts)\r\n    - [使用组件的布局](#layouts-using-components)\r\n    - [使用模板继承的布局](#layouts-using-template-inheritance)\r\n- [表单](#forms)\r\n    - [CSRF 字段](#csrf-field)\r\n    - [Method 字段](#method-field)\r\n    - [验证错误](#validation-errors)\r\n- [堆栈](#stacks)\r\n- [服务注入](#service-injection)\r\n- [渲染 Blade 模板](#rendering-blade-templates)\r\n- [Blade 扩展](#extending-blade)\r\n    - [自定义 Echo 处理](#custom-echo-handlers)\r\n    - [自定义 if 语句](#custom-if-statements)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nBlade 是 Laravel 提供的一个简单而又强大的模板引擎。 和其他流行的 PHP 模板引擎不同，Blade 并不限制你在视图中使用原生 PHP 代码。实际上，所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何负担。Blade 模板文件使用 `.blade.php` 作为文件扩展名，被存放在 `resources/views` 目录。\r\n\r\n\r\n\r\nBlade 视图可以使用全局 `view` 函数从 Route 或控制器返回。当然，正如有关 [views](/docs/laravel/10.x/views) 的文档中所描述的，可以使用 `view` 函数的第二个参数将数据传递到 Blade 视图：\r\n\r\n    Route::get('/', function () {\r\n        return view('greeting', ['name' => 'Finn']);\r\n    });\r\n\r\n<a name=\"supercharging-blade-with-livewire\"></a>\r\n### 用 Livewire 为 Blade 赋能\r\n\r\n想让你的 Blade 模板更上一层楼，轻松构建动态界面吗？看看[Laravel Livewire](https://laravel-livewire.com)。Livewire 允许你编写 Blade 组件，这些组件具有动态功能，通常只能通过 React 或 Vue 等前端框架来实现，这提供了一个很好的方法来构建现代，没有复杂前端映射，基于客户端渲染，无须很多的构建步骤的  JavaScript 框架。\r\n\r\n\r\n<a name=\"displaying-data\"></a>\r\n## 显示数据\r\n\r\n你可以把变量置于花括号中以在视图中显示数据。例如，给定下方的路由：\r\n\r\n    Route::get('/', function () {\r\n        return view('welcome', ['name' => 'Samantha']);\r\n    });\r\n\r\n你可以像如下这样显示 `name` 变量的内容：\r\n\r\n```blade\r\nHello, {{ $name }}.\r\n```\r\n\r\n> **技巧**：Blade 的 `{{ }}` 语句将被 PHP 的 `htmlspecialchars` 函数自动转义以防范 XSS 攻击。\r\n\r\n你不仅限于显示传递给视图的变量的内容。你也可以回显任何 PHP 函数的结果。实际上，你可以将所需的任何 PHP 代码放入 Blade echo 语句中：\r\n\r\n```blade\r\nThe current UNIX timestamp is {{ time() }}.\r\n```\r\n\r\n<a name=\"html-entity-encoding\"></a>\r\n### HTML 实体编码\r\n\r\n\r\n\r\n默认情况下，Blade（和 Laravel `e` 助手）将对 HTML 实体进行双重编码。如果你想禁用双重编码，请从 `AppServiceProvider` 的 `boot` 方法调用 `Blade::withoutDoubleEncoding` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * Bootstrap any application services.\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Blade::withoutDoubleEncoding();\r\n        }\r\n    }\r\n\r\n<a name=\"displaying-unescaped-data\"></a>\r\n#### 展示非转义数据\r\n\r\n默认情况下， Blade `{{ }}` 语句将被 PHP 的 `htmlspecialchars` 函数自动转义以防范 XSS 攻击。如果不想你的数据被转义，那么你可使用如下的语法：\r\n\r\n```blade\r\nHello, {!! $name !!}.\r\n```\r\n\r\n> **注意：**在应用中显示用户提供的数据时请格外小心，请尽可能的使用转义和双引号语法来防范 XSS 攻击。\r\n\r\n<a name=\"blade-and-javascript-frameworks\"></a>\r\n### Blade & JavaScript 框架\r\n\r\n由于许多 JavaScript 框架也使用「花括号」来标识将显示在浏览器中的表达式，因此，你可以使用 `@` 符号来表示 Blade 渲染引擎应当保持不变。例如：\r\n\r\n```blade\r\n<h1>Laravel</h1>\r\n\r\nHello, @{{ name }}.\r\n```\r\n\r\n在这个例子中， `@` 符号将被 Blade 移除；当然，Blade 将不会修改 `{{ name }}` 表达式，取而代之的是 JavaScript 模板来对其进行渲染。\r\n\r\n`@` 符号也用于转义 Blade 指令：\r\n\r\n```blade\r\n{{-- Blade template --}}\r\n@@if()\r\n\r\n<!-- HTML output -->\r\n@if()\r\n```\r\n\r\n<a name=\"rendering-json\"></a>\r\n#### 渲染 JSON\r\n\r\n有时，你可能会将数组传递给视图，以将其呈现为 JSON，以便初始化 JavaScript 变量。 例如：\r\n\r\n```blade\r\n<script>\r\n    var app = <?php echo json_encode($array); ?>;\r\n</script>\r\n```\r\n\r\n\r\n\r\n或者，你可以使用 `Illuminate\\Support\\Js::from` 方法指令，而不是手动调用 `json_encode`。 `from` 方法接受与 PHP 的 `json_encode` 函数相同的参数；但是，它将确保正确转义生成的 JSON 以包含在 HTML 引号中。 `from` 方法将返回一个字符串 `JSON.parse` JavaScript 语句，它将给定对象或数组转换为有效的 JavaScript 对象：\r\n\r\n```blade\r\n<script>\r\n    var app = {{ Illuminate\\Support\\Js::from($array) }};\r\n</script>\r\n```\r\n\r\nLaravel 框架的最新版本包括一个 `Js` 门面，它提供了在 Blade 模板中方便地访问此功能：\r\n\r\n```blade\r\n<script>\r\n    var app = {{ Js::from($array) }};\r\n</script>\r\n```\r\n\r\n> **注意：**你应该只使用 `Js::from` 渲染已经存在的变量为 JSON。 Blade 模板基于正则表达式，如果尝试将复杂表达式传递给 `Js::from` 可能会导致无法预测的错误。\r\n\r\n<a name=\"the-at-verbatim-directive\"></a>\r\n#### `@verbatim` 指令\r\n\r\n如果你在模板中显示很大一部分 JavaScript 变量，你可以将 HTML 嵌入到 `@verbatim` 指令中，这样，你就不需要在每一个 Blade 回显语句前添加 `@` 符号：\r\n\r\n```blade\r\n@verbatim\r\n    <div class=\"container\">\r\n        Hello, {{ name }}.\r\n    </div>\r\n@endverbatim\r\n```\r\n\r\n<a name=\"blade-directives\"></a>\r\n## Blade 指令\r\n\r\n除了模板继承和显示数据以外， Blade 还为常见的 PHP 控制结构提供了便捷的快捷方式，例如条件语句和循环。这些快捷方式为 PHP 控制结构提供了一个非常清晰、简洁的书写方式，同时，还与 PHP 中的控制结构保持了相似的语法特性。\r\n\r\n\r\n\r\n<a name=\"if-statements\"></a>\r\n### If 语句\r\n\r\n你可以使用 `@if` ， `@elseif` ， `@else` 和 `@endif` 指令构造 `if` 语句。这些指令功能与它们所对应的 PHP 语句完全一致：\r\n\r\n```blade\r\n@if (count($records) === 1)\r\n    有一条记录\r\n@elseif (count($records) > 1)\r\n    有多条记录\r\n@else\r\n    没有记录\r\n@endif\r\n```\r\n\r\n为了方便， Blade 还提供了一个 `@unless` 指令：\r\n\r\n```blade\r\n@unless (Auth::check())\r\n    你还没有登录\r\n@endunless\r\n```\r\n\r\n> 译注：相当于 `@if (! Auth::check()) @endif`\r\n\r\n除了上面所说条件指令外， `@isset` 和 `@empty` 指令亦可作为它们所对应的 PHP 函数的快捷方式：\r\n\r\n```blade\r\n@isset($records)\r\n    // $records 已经被定义且不为 null ……\r\n@endisset\r\n\r\n@empty($records)\r\n    // $records 为「空」……\r\n@endempty\r\n```\r\n\r\n<a name=\"authentication-directives\"></a>\r\n#### 授权指令\r\n\r\n`@auth` 和 `@guest` 指令可用于快速判断当前用户是否已经获得 [授权](/docs/laravel/10.x/authentication) 或是游客：\r\n\r\n```blade\r\n@auth\r\n    // 用户已经通过认证……\r\n@endauth\r\n\r\n@guest\r\n    // 用户没有通过认证……\r\n@endguest\r\n```\r\n\r\n如有需要，你亦可在使用 `@auth` 和 `@guest` 指令时指定 [认证守卫](https://learnku.com/docs/laravel/10.x/authentication \"认证守卫\")：\r\n\r\n```blade\r\n@auth('admin')\r\n    // 用户已经通过认证...\r\n@endauth\r\n\r\n@guest('admin')\r\n    // 用户没有通过认证...\r\n@endguest\r\n```\r\n\r\n<a name=\"environment-directives\"></a>\r\n#### 环境指令\r\n\r\n你可以使用 `@production` 指令来判断应用是否处于生产环境：\r\n\r\n```blade\r\n@production\r\n    // 生产环境特定内容...\r\n@endproduction\r\n```\r\n\r\n或者，你可以使用 `@env` 指令来判断应用是否运行于指定的环境：\r\n\r\n```blade\r\n@env('staging')\r\n    //  应用运行于「staging」环境...\r\n@endenv\r\n\r\n@env(['staging', 'production'])\r\n    // 应用运行于 「staging」或 [生产] 环境...\r\n@endenv\r\n```\r\n\r\n\r\n\r\n<a name=\"section-directives\"></a>\r\n#### 区块指令\r\n\r\n你可以使用 `@hasSection` 指令来判断区块是否有内容：\r\n\r\n```blade\r\n@hasSection('navigation')\r\n    <div class=\"pull-right\">\r\n        @yield('navigation')\r\n    </div>\r\n\r\n    <div class=\"clearfix\"></div>\r\n@endif\r\n```\r\n\r\n你可以使用 `sectionMissing` 指令来判断区块是否没有内容：\r\n\r\n```blade\r\n@sectionMissing('navigation')\r\n    <div class=\"pull-right\">\r\n        @include('default-navigation')\r\n    </div>\r\n@endif\r\n```\r\n\r\n<a name=\"switch-statements\"></a>\r\n### Switch 语句\r\n\r\n你可使用 `@switch` ， `@case` ， `@break` ， `@default` 和 `@endswitch` 语句来构造 Switch 语句：\r\n\r\n```blade\r\n@switch($i)\r\n    @case(1)\r\n        First case...\r\n        @break\r\n\r\n    @case(2)\r\n        Second case...\r\n        @break\r\n\r\n    @default\r\n        Default case...\r\n@endswitch\r\n```\r\n\r\n<a name=\"loops\"></a>\r\n### 循环\r\n\r\n除了条件语句， Blade 还提供了与 PHP 循环结构功能相同的指令。同样，这些语句的功能和它们所对应的 PHP 语法一致：\r\n\r\n```blade\r\n@for ($i = 0; $i < 10; $i++)\r\n    The current value is {{ $i }}\r\n@endfor\r\n\r\n@foreach ($users as $user)\r\n    <p>This is user {{ $user->id }}</p>\r\n@endforeach\r\n\r\n@forelse ($users as $user)\r\n    <li>{{ $user->name }}</li>\r\n@empty\r\n    <p>No users</p>\r\n@endforelse\r\n\r\n@while (true)\r\n    <p>I'm looping forever.</p>\r\n@endwhile\r\n```\r\n\r\n> **技巧：**在遍历 `foreach` 循环时，你可以使用 [循环变量](#the-loop-variable) 去获取有关循环的有价值的信息，例如，你处于循环的第一个迭代亦或是处于最后一个迭代。\r\n\r\n使用循环时，还可以使用 `@continue` 和 `@break` 循环或跳过当前迭代：\r\n\r\n```blade\r\n@foreach ($users as $user)\r\n    @if ($user->type == 1)\r\n        @continue\r\n    @endif\r\n\r\n    <li>{{ $user->name }}</li>\r\n\r\n    @if ($user->number == 5)\r\n        @break\r\n    @endif\r\n@endforeach\r\n```\r\n\r\n你还可以在指令声明中包含继续或中断条件：\r\n\r\n```blade\r\n@foreach ($users as $user)\r\n    @continue($user->type == 1)\r\n\r\n    <li>{{ $user->name }}</li>\r\n\r\n    @break($user->number == 5)\r\n@endforeach\r\n```\r\n\r\n\r\n\r\n<a name=\"the-loop-variable\"></a>\r\n### Loop 变量\r\n\r\n在遍历 `foreach` 循环时，循环内部可以使用 `$loop` 变量。该变量提供了访问一些诸如当前的循环索引和此次迭代是首次或是末次这样的信息的方式：\r\n\r\n```blade\r\n@foreach ($users as $user)\r\n    @if ($loop->first)\r\n        This is the first iteration.\r\n    @endif\r\n\r\n    @if ($loop->last)\r\n        This is the last iteration.\r\n    @endif\r\n\r\n    <p>This is user {{ $user->id }}</p>\r\n@endforeach\r\n```\r\n\r\n如果你处于嵌套循环中，你可以使用循环的 `$loop` 变量的 `parent` 属性访问父级循环：\r\n\r\n```blade\r\n@foreach ($users as $user)\r\n    @foreach ($user->posts as $post)\r\n        @if ($loop->parent->first)\r\n            This is the first iteration of the parent loop.\r\n        @endif\r\n    @endforeach\r\n@endforeach\r\n```\r\n\r\n该 `$loop` 变量还包含各种各样有用的属性：\r\n\r\n属性  | 描述\r\n------------- | -------------\r\n`$loop->index`  |  当前迭代的索引（从 0 开始）。\r\n`$loop->iteration`  |  当前循环的迭代次数（从 1 开始）。\r\n`$loop->remaining`  |  循环剩余的迭代次数。\r\n`$loop->count`  |  被迭代的数组的元素个数。\r\n`$loop->first`  |  当前迭代是否是循环的首次迭代。\r\n`$loop->last`  |  当前迭代是否是循环的末次迭代。\r\n`$loop->even`  |  当前循环的迭代次数是否是偶数。\r\n`$loop->odd`  |  当前循环的迭代次数是否是奇数。\r\n`$loop->depth`  |  当前循环的嵌套深度。\r\n`$loop->parent`  |  嵌套循环中的父级循环。\r\n\r\n<a name=\"conditional-classes\"></a>\r\n### 有条件地编译 class 样式\r\n\r\n\r\n\r\n该 `@class` 指令有条件地编译 CSS class 样式。该指令接收一个数组，其中数组的键包含你希望添加的一个或多个样式的类名，而值是一个布尔表达式。如果数组元素有一个数值的键，它将始终包含在呈现的 class 列表中：\r\n\r\n```blade\r\n@php\r\n    $isActive = false;\r\n    $hasError = true;\r\n@endphp\r\n\r\n<span @class([\r\n    'p-4',\r\n    'font-bold' => $isActive,\r\n    'text-gray-500' => ! $isActive,\r\n    'bg-red' => $hasError,\r\n])></span>\r\n\r\n<span class=\"p-4 text-gray-500 bg-red\"></span>\r\n```\r\n\r\n同样，`@style` 指令可用于有条件地将内联 CSS 样式添加到一个 HTML 元素中。\r\n\r\n```blade\r\n@php\r\n    $isActive = true;\r\n@endphp\r\n\r\n<span @style([\r\n    'background-color: red',\r\n    'font-weight: bold' => $isActive,\r\n])></span>\r\n\r\n<span style=\"background-color: red; font-weight: bold;\"></span>\r\n```\r\n\r\n<a name=\"additional-attributes\"></a>\r\n### 附加属性\r\n\r\n为方便起见，你可以使用该 `@checked` 指令轻松判断给定的 HTML 复选框输入是否被「选中（checked）」。如果提供的条件判断为 `true` ，则此指令将回显 `checked`：\r\n\r\n```blade\r\n<input type=\"checkbox\"\r\n        name=\"active\"\r\n        value=\"active\"\r\n        @checked(old('active', $user->active)) />\r\n```\r\n\r\n同样，该 `@selected` 指令可用于判断给定的选项是否被「选中（selected）」：\r\n\r\n```blade\r\n<select name=\"version\">\r\n    @foreach ($product->versions as $version)\r\n        <option value=\"{{ $version }}\" @selected(old('version') == $version)>\r\n            {{ $version }}\r\n        </option>\r\n    @endforeach\r\n</select>\r\n```\r\n\r\n此外，该 `@disabled` 指令可用于判断给定元素是否为「禁用（disabled）」:\r\n\r\n```blade\r\n<button type=\"submit\" @disabled($errors->isNotEmpty())>Submit</button>\r\n```\r\n\r\n此外，`@readonly` 指令可以用来指示某个元素是否应该是「只读 （readonly）」的。\r\n\r\n```blade\r\n<input type=\"email\"\r\n        name=\"email\"\r\n        value=\"email@laravel.com\"\r\n        @readonly($user->isNotAdmin()) />\r\n```\r\n\r\n\r\n\r\n此外，`@required` 指令可以用来指示一个给定的元素是否应该是「必需的（required）」。\r\n\r\n```blade\r\n<input type=\"text\"\r\n        name=\"title\"\r\n        value=\"title\"\r\n        @required($user->isAdmin()) />\r\n```\r\n\r\n<a name=\"including-subviews\"></a>\r\n### 包含子视图\r\n\r\n> **技巧：**虽然你可以自由使用该 `@include` 指令，但是 Blade [组件](#components) 提供了类似的功能，并提供了优于该 `@include` 指令的功能，如数据和属性绑定。\r\n\r\nBlade 的 `@include` 指令允许你从一个视图中包含另外一个 Blade 视图。父视图中的所有变量在子视图中都可以使用：\r\n\r\n```blade\r\n<div>\r\n    @include('shared.errors')\r\n\r\n    <form>\r\n        <!-- Form Contents -->\r\n    </form>\r\n</div>\r\n```\r\n\r\n尽管子视图可以继承父视图中所有可以使用的数据，但是你也可以传递一个额外的数组，这个数组在子视图中也可以使用:\r\n\r\n```blade\r\n@include('view.name', ['status' => 'complete'])\r\n```\r\n\r\n如果你想要使用 `@include` 包含一个不存在的视图，Laravel 将会抛出一个错误。如果你想要包含一个可能存在也可能不存在的视图，那么你应该使用 `@includeIf` 指令:\r\n\r\n```blade\r\n@includeIf('view.name', ['status' => 'complete'])\r\n```\r\n\r\n如果想要使用 `@include`  包含一个给定值为 `true` 或 `false`的布尔表达式的视图，那么你可以使用 `@includeWhen` 和 `@includeUnless` 指令:\r\n\r\n```blade\r\n@includeWhen($boolean, 'view.name', ['status' => 'complete'])\r\n\r\n@includeUnless($boolean, 'view.name', ['status' => 'complete'])\r\n```\r\n\r\n如果想要包含一个视图数组中第一个存在的视图，你可以使用 `includeFirst` 指令:\r\n\r\n```blade\r\n@includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])\r\n```\r\n\r\n> **注意：**在视图中，你应该避免使用 `__DIR__` 和 `__FILE__` 这些常量，因为他们将引用已缓存的和已编译的视图。\r\n\r\n\r\n\r\n<a name=\"rendering-views-for-collections\"></a>\r\n#### 为集合渲染视图\r\n\r\n你可以使用 Blade 的 `@each` 指令将循环合并在一行内：\r\n\r\n```blade\r\n@each('view.name', $jobs, 'job')\r\n```\r\n\r\n该 `@each` 指令的第一个参数是数组或集合中的元素的要渲染的视图片段。第二个参数是你想要迭代的数组或集合，当第三个参数是一个表示当前迭代的视图的变量名。因此，如果你遍历一个名为 `jobs` 的数组，通常会在视图片段中使用 `job` 变量来访问每一个 job （jobs 数组的元素）。在你的视图片段中，可以使用 `key` 变量来访问当前迭代的键。\r\n\r\n你亦可传递第四个参数给 `@each` 指令。当给定的数组为空时，将会渲染该参数所对应的视图。\r\n\r\n```blade\r\n@each('view.name', $jobs, 'job', 'view.empty')\r\n```\r\n\r\n> **注意：**通过 `@each` 指令渲染的视图不会继承父视图的变量。如果子视图需要使用这些变量，你可以使用 `@foreach` 和 `@include` 来代替它。\r\n\r\n<a name=\"the-once-directive\"></a>\r\n### `@once` 指令\r\n\r\n该 `@once` 指令允许你定义模板的一部分内容，这部分内容在每一个渲染周期中只会被计算一次。该指令在使用 [堆栈](#stacks) 推送一段特定的 JavaScript 代码到页面的头部环境下是很有用的。例如，如果你想要在循环中渲染一个特定的 [组件](#components) ，你可能希望仅在组件渲染的首次推送 JavaScript 代码到头部：\r\n\r\n```blade\r\n@once\r\n    @push('scripts')\r\n        <script>\r\n            // 你自定义的 JavaScript 代码...\r\n        </script>\r\n    @endpush\r\n@endonce\r\n```\r\n\r\n\r\n\r\n由于该 `@once` 指令经常与 `@push` 或 `@prepend` 指令一起使用，为了使用方便，我们提供了 `@pushOnce` 和 `@prependOnce` 指令：\r\n\r\n```blade\r\n@pushOnce('scripts')\r\n    <script>\r\n        // 你自定义的 JavaScript 代码...\r\n    </script>\r\n@endPushOnce\r\n```\r\n\r\n<a name=\"raw-php\"></a>\r\n### 原始 PHP 语法\r\n\r\n在许多情况下，嵌入 PHP 代码到你的视图中是很有用的。你可以在模板中使用 Blade 的 `@php` 指令执行原生的 PHP 代码块：\r\n\r\n```blade\r\n@php\r\n    $counter = 1;\r\n@endphp\r\n```\r\n\r\n如果只需要写一条 PHP 语句，可以在 `@php` 指令中包含该语句。\r\n\r\n```blade\r\n@php($counter = 1)\r\n```\r\n\r\n<a name=\"comments\"></a>\r\n### 注释\r\n\r\nBlade 也允许你在视图中定义注释。但是，和 HTML 注释不同， Blade 注释不会被包含在应用返回的 HTML 中：\r\n\r\n```blade\r\n{{-- 这个注释将不会出现在渲染的HTML中。 --}}\r\n```\r\n\r\n<a name=\"components\"></a>\r\n## 组件\r\n\r\n组件和插槽的作用与区块和布局的作用一致；不过，有些人可能觉着组件和插槽更易于理解。有两种书写组件的方法：基于类的组件和匿名组件。\r\n\r\n你可以使用 `make:component` Artisan 命令来创建一个基于类的组件。我们将会创建一个简单的  `Alert` 组件用于说明如何使用组件。该 `make:component` 命令将会把组件置于 `App\\View\\Components` 目录中：\r\n\r\n```shell\r\nphp artisan make:component Alert\r\n```\r\n\r\n该 `make:component` 命令将会为组件创建一个视图模板。创建的视图被置于 `resources/views/components` 目录中。在为自己的应用程序编写组件时，会在 `app/View/Components` 目录和 `resources/views/components` 目录中自动发现组件，因此通常不需要进一步的组件注册。\r\n\r\n\r\n\r\n你还可以在子目录中创建组件：\r\n\r\n```shell\r\nphp artisan make:component Forms/Input\r\n```\r\n\r\n上面的命令将在目录中创建一个 `Input` 组件， `App\\View\\Components\\Forms` 视图将放置在 `resources/views/components/forms` 目录中。\r\n\r\n如果你想创建一个匿名组件（一个只有 Blade 模板并且没有类的组件），你可以在调用命令  `make:component` 使用该 `--view` 标志：\r\n\r\n```shell\r\nphp artisan make:component forms.input --view\r\n```\r\n\r\n上面的命令将在 `resources/views/components/forms/input.blade.php`创建一个 Blade 文件，该文件中可以通过 `<x-forms.input />`作为组件呈现。\r\n\r\n<a name=\"manually-registering-package-components\"></a>\r\n#### 手动注册包组件\r\n\r\n当为你自己的应用编写组件的时候，Laravel 将会自动发现位于 `app/View/Components` 目录和 `resources/views/components` 目录中的组件。\r\n\r\n当然，如果你使用 Blade 组件编译一个包，你可能需要手动注册组件类及其 HTML 标签别名。你应该在包的服务提供者的 `boot` 方法中注册你的组件：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * 注册你的包的服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::component('package-alert', Alert::class);\r\n    }\r\n\r\n当组件注册完成后，便可使用标签别名来对其进行渲染。\r\n\r\n```blade\r\n<x-package-alert/>\r\n```\r\n\r\n或者，你可以使用该 `componentNamespace` 方法按照约定自动加载组件类。例如，一个 `Nightshade` 包可能有 `Calendar` 和 `ColorPicker` 组件驻留在 `Package\\Views\\Components` 命名空间中：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * 注册你的包的服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::componentNamespace('Nightshade\\\\Views\\\\Components', 'nightshade');\r\n    }\r\n\r\n\r\n\r\n这将允许他们的供应商命名空间使用包组件，使用以下 `package-name::` 语法：\r\n\r\n```blade\r\n<x-nightshade::calendar />\r\n<x-nightshade::color-picker />\r\n```\r\n\r\nBlade 将自动检测链接到该组件的类，通过对组件名称进行帕斯卡大小写。使用「点」表示法也支持子目录。\r\n\r\n<a name=\"rendering-components\"></a>\r\n### 显示组件\r\n\r\n要显示一个组件，你可以在 Blade 模板中使用 Blade 组件标签。 Blade 组件以  `x-` 字符串开始，其后紧接组件类 kebab case 形式的名称（即单词与单词之间使用短横线 `-` 进行连接）：\r\n\r\n```blade\r\n<x-alert/>\r\n\r\n<x-user-profile/>\r\n```\r\n\r\n如果组件位于 `App\\View\\Components` 目录的子目录中，你可以使用 `.` 字符来指定目录层级。例如，假设我们有一个组件位于 `App\\View\\Components\\Inputs\\Button.php`，那么我们可以像这样渲染它：\r\n\r\n```blade\r\n<x-inputs.button/>\r\n```\r\n\r\n如果你想有条件地渲染你的组件，你可以在你的组件类上定义一个 `shouldRender` 方法。如果 `shouldRender` 方法返回 `false`，该组件将不会被渲染。\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    /**\r\n     * 该组件是否应该被渲染\r\n     */\r\n    public function shouldRender(): bool\r\n    {\r\n        return Str::length($this->message) > 0;\r\n    }\r\n\r\n<a name=\"passing-data-to-components\"></a>\r\n### 传递数据到组件中\r\n\r\n你可以使用 HTML 属性传递数据到 Blade 组件中。普通的值可以通过简单的 HTML 属性来传递给组件。PHP 表达式和变量应该通过以 `:` 字符作为前缀的变量来进行传递：\r\n\r\n```blade\r\n<x-alert type=\"error\" :message=\"$message\"/>\r\n```\r\n\r\n你应该在类的构造器中定义组件的必要数据。在组件的视图中，组件的所有 public 类型的属性都是可用的。不必通过组件类的 `render` 方法传递：\r\n\r\n    <?php\r\n\r\n    namespace App\\View\\Components;\r\n\r\n    use Illuminate\\View\\Component;\r\n    use Illuminate\\View\\View;\r\n\r\n    class Alert extends Component\r\n    {\r\n        /**\r\n         * 创建组件实例。\r\n         */\r\n        public function __construct(\r\n            public string $type,\r\n            public string $message,\r\n        ) {}\r\n\r\n        /**\r\n         * 获取代表该组件的视图/内容\r\n         */\r\n        public function render(): View\r\n        {\r\n            return view('components.alert');\r\n        }\r\n    }\r\n\r\n\r\n\r\n渲染组件时，你可以回显变量名来显示组件的 public 变量的内容：\r\n\r\n```blade\r\n<div class=\"alert alert-{{ $type }}\">\r\n    {{ $message }}\r\n</div>\r\n```\r\n\r\n<a name=\"casing\"></a>\r\n#### 命名方式（Casing）\r\n\r\n组件的构造器的参数应该使用 `驼峰式` 类型，在 HTML 属性中引用参数名时应该使用 `短横线隔开式 kebab-case ：单词与单词之间使用短横线 - 进行连接）` 。例如，给定如下的组件构造器：\r\n\r\n    /**\r\n     * 创建一个组件实例\r\n     */\r\n    public function __construct(\r\n        public string $alertType,\r\n    ) {}\r\n\r\n`$alertType`  参数可以像这样使用：\r\n\r\n```blade\r\n<x-alert alert-type=\"danger\" />\r\n```\r\n\r\n<a name=\"short-attribute-syntax\"></a>\r\n#### 短属性语法/省略属性语法\r\n\r\n当向组件传递属性时，你也可以使用「短属性语法/省略属性语法」（省略属性书写）。这通常很方便，因为属性名称经常与它们对应的变量名称相匹配。\r\n\r\n```blade\r\n{{-- 短属性语法/省略属性语法... --}}\r\n<x-profile :$userId :$name />\r\n\r\n{{-- 等价于... --}}\r\n<x-profile :user-id=\"$userId\" :name=\"$name\" />\r\n```\r\n\r\n<a name=\"escaping-attribute-rendering\"></a>\r\n#### 转义属性渲染\r\n\r\n因为一些 JavaScript 框架，例如 Alpine.js 还可以使用冒号前缀属性，你可以使用双冒号 (`::`) 前缀通知 Blade 属性不是 PHP 表达式。例如，给定以下组件：\r\n\r\n```blade\r\n<x-button ::class=\"{ danger: isDeleting }\">\r\n    Submit\r\n</x-button>\r\n```\r\n\r\nBlade 将渲染出以下 HTML 内容：\r\n\r\n```blade\r\n<button :class=\"{ danger: isDeleting }\">\r\n    Submit\r\n</button>\r\n```\r\n\r\n<a name=\"component-methods\"></a>\r\n#### #### 组件方法\r\n\r\n除了组件模板可用的公共变量外，还可以调用组件上的任何公共方法。例如，假设一个组件有一个 `isSelected` 方法：\r\n\r\n    /**\r\n     * 确定给定选项是否为当前选定的选项。\r\n     */\r\n    public function isSelected(string $option): bool\r\n    {\r\n        return $option === $this->selected;\r\n    }\r\n\r\n\r\n\r\n你可以通过调用与方法名称匹配的变量，从组件模板执行此方法：\r\n\r\n```blade\r\n<option {{ $isSelected($value) ? 'selected' : '' }} value=\"{{ $value }}\">\r\n    {{ $label }}\r\n</option>\r\n```\r\n\r\n<a name=\"using-attributes-slots-within-component-class\"></a>\r\n#### 访问组件类中的属性和插槽\r\n\r\nBlade 组件还允许你访问类的 render 方法中的组件名称、属性和插槽。但是，为了访问这些数据，应该从组件的 `render` 方法返回闭包。闭包将接收一个  `$data` 数组作为它的唯一参数。此数组将包含几个元素，这些元素提供有关组件的信息：\r\n\r\n    use Closure;\r\n\r\n    /**\r\n     * 获取表示组件的视图 / 内容\r\n     */\r\n    public function render(): Closure\r\n    {\r\n        return function (array $data) {\r\n            // $data['componentName'];\r\n            // $data['attributes'];\r\n            // $data['slot'];\r\n\r\n            return '<div>Components content</div>';\r\n        };\r\n    }\r\n\r\n`componentName` 等于 `x-` 前缀后面的 HTML 标记中使用的名称。所以 `<x-alert />` 的 `componentName` 将是 `alert` 。 `attributes` 元素将包含 HTML 标记上的所有属性。 `slot` 元素是一个 `Illuminate\\Support\\HtmlString`实例，包含组件的插槽内容。\r\n\r\n闭包应该返回一个字符串。如果返回的字符串与现有视图相对应，则将呈现该视图；否则，返回的字符串将作为内联 Blade 视图进行计算。\r\n\r\n<a name=\"additional-dependencies\"></a>\r\n#### 附加依赖项\r\n\r\n如果你的组件需要引入来自 Laravel 的 [服务容器](/docs/laravel/10.x/container)的依赖项，你可以在组件的任何数据属性之前列出这些依赖项，这些依赖项将由容器自动注入：\r\n\r\n```php\r\nuse App\\Services\\AlertCreator;\r\n\r\n/**\r\n * 创建组件实例\r\n */\r\npublic function __construct(\r\n    public AlertCreator $creator,\r\n    public string $type,\r\n    public string $message,\r\n) {}\r\n```\r\n\r\n\r\n\r\n<a name=\"hiding-attributes-and-methods\"></a>\r\n#### 隐藏属性/方法\r\n\r\n如果要防止某些公共方法或属性作为变量公开给组件模板，可以将它们添加到组件的 `$except` 数组属性中：\r\n\r\n    <?php\r\n\r\n    namespace App\\View\\Components;\r\n\r\n    use Illuminate\\View\\Component;\r\n\r\n    class Alert extends Component\r\n    {\r\n        /**\r\n         * 不应向组件模板公开的属性/方法。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $except = ['type'];\r\n\r\n        /**\r\n         * Create the component instance.\r\n         */\r\n        public function __construct(\r\n            public string $type,\r\n        ) {}\r\n    }\r\n\r\n<a name=\"component-attributes\"></a>\r\n### 组件属性\r\n\r\n我们已经研究了如何将数据属性传递给组件；但是，有时你可能需要指定额外的 HTML 属性，例如  `class`，这些属性不是组件运行所需的数据的一部分。通常，你希望将这些附加属性向下传递到组件模板的根元素。例如，假设我们要呈现一个 `alert` 组件，如下所示：\r\n\r\n```blade\r\n<x-alert type=\"error\" :message=\"$message\" class=\"mt-4\"/>\r\n```\r\n\r\n所有不属于组件的构造器的属性都将被自动添加到组件的「属性包」中。该属性包将通过 `$attributes` 变量自动传递给组件。你可以通过回显这个变量来渲染所有的属性：\r\n\r\n```blade\r\n<div {{ $attributes }}>\r\n    <!-- 组件内容 -->\r\n</div>\r\n```\r\n\r\n> **注意：**此时不支持在组件中使用诸如 `@env` 这样的指令。例如， `<x-alert :live=\"@env('production')\"/>` 不会被编译。\r\n\r\n<a name=\"default-merged-attributes\"></a>\r\n#### 默认 / 合并属性\r\n\r\n某些时候，你可能需要指定属性的默认值，或将其他值合并到组件的某些属性中。为此，你可以使用属性包的 `merge`方法。 此方法对于定义一组应始终应用于组件的默认 CSS 类特别有用：\r\n\r\n```blade\r\n<div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>\r\n    {{ $message }}\r\n</div>\r\n```\r\n\r\n\r\n\r\n假设我们如下方所示使用该组件：\r\n\r\n```blade\r\n<x-alert type=\"error\" :message=\"$message\" class=\"mb-4\"/>\r\n```\r\n\r\n最终呈现的组件 HTML 将如下所示：\r\n\r\n```blade\r\n<div class=\"alert alert-error mb-4\">\r\n    <!-- Contents of the $message variable -->\r\n</div>\r\n```\r\n\r\n<a name=\"conditionally-merge-classes\"></a>\r\n#### 有条件地合并类\r\n\r\n有时你可能希望在给定条件为 `true` 时合并类。 你可以通过该 `class` 方法完成此操作，该方法接受一个类数组，其中数组键包含你希望添加的一个或多个类，而值是一个布尔表达式。如果数组元素有一个数字键，它将始终包含在呈现的类列表中：\r\n\r\n```blade\r\n<div {{ $attributes->class(['p-4', 'bg-red' => $hasError]) }}>\r\n    {{ $message }}\r\n</div>\r\n```\r\n\r\n如果需要将其他属性合并到组件中，可以将 `merge` 方法链接到 `class` 方法中：\r\n\r\n```blade\r\n<button {{ $attributes->class(['p-4'])->merge(['type' => 'button']) }}>\r\n    {{ $slot }}\r\n</button>\r\n```\r\n\r\n> **技巧：**如果你需要有条件地编译不应接收合并属性的其他 HTML 元素上的类，你可以使用 [`@class` 指令](#conditional-classes)。\r\n\r\n<a name=\"non-class-attribute-merging\"></a>\r\n#### 非 class 属性的合并\r\n\r\n当合并非 `class` 属性的属性时，提供给 `merge` 方法的值将被视为该属性的「default」值。但是，与 `class` 属性不同，这些属性不会与注入的属性值合并。相反，它们将被覆盖。例如， `button` 组件的实现可能如下所示：\r\n\r\n```blade\r\n<button {{ $attributes->merge(['type' => 'button']) }}>\r\n    {{ $slot }}\r\n</button>\r\n```\r\n\r\n\r\n\r\n若要使用自定义 `type` 呈现按钮组件，可以在使用该组件时指定它。如果未指定 `type`，则将使用 `button` 作为 type 值：\r\n\r\n```blade\r\n<x-button type=\"submit\">\r\n    Submit\r\n</x-button>\r\n```\r\n\r\n本例中 `button` 组件渲染的 HTML 为：\r\n\r\n```blade\r\n<button type=\"submit\">\r\n    Submit\r\n</button>\r\n```\r\n\r\n如果希望 `class` 以外的属性将其默认值和注入值连接在一起，可以使用 `prepends` 方法。在本例中， `data-controller` 属性始终以 `profile-controller` 开头，并且任何其他注入 `data-controller` 的值都将放在该默认值之后：\r\n\r\n```blade\r\n<div {{ $attributes->merge(['data-controller' => $attributes->prepends('profile-controller')]) }}>\r\n    {{ $slot }}\r\n</div>\r\n```\r\n\r\n<a name=\"filtering-attributes\"></a>\r\n#### 保留属性 / 过滤属性\r\n\r\n可以使用 `filter` 方法筛选属性。如果希望在属性包中保留属性，此方法接受应返回 `true` 的闭包：\r\n\r\n```blade\r\n{{ $attributes->filter(fn (string $value, string $key) => $key == 'foo') }}\r\n```\r\n\r\n为了方便起见，你可以使用 `whereStartsWith` 方法检索其键以给定字符串开头的所有属性：\r\n\r\n```blade\r\n{{ $attributes->whereStartsWith('wire:model') }}\r\n```\r\n\r\n相反，该 `whereDoesntStartWith` 方法可用于排除键以给定字符串开头的所有属性：\r\n\r\n```blade\r\n{{ $attributes->whereDoesntStartWith('wire:model') }}\r\n```\r\n\r\n使用 `first` 方法，可以呈现给定属性包中的第一个属性：\r\n\r\n```blade\r\n{{ $attributes->whereStartsWith('wire:model')->first() }}\r\n```\r\n\r\n如果要检查组件上是否存在属性，可以使用 `has` 方法。此方法接受属性名称作为其唯一参数，并返回一个布尔值，指示该属性是否存在：\r\n\r\n```blade\r\n@if ($attributes->has('class'))\r\n    <div>Class attribute is present</div>\r\n@endif\r\n```\r\n\r\n\r\n\r\n你可以使用 `get` 方法检索特定属性的值：\r\n\r\n```blade\r\n{{ $attributes->get('class') }}\r\n```\r\n\r\n<a name=\"reserved-keywords\"></a>\r\n### 保留关键字\r\n\r\n默认情况下，为了渲染组件，会保留一些关键字供 Blade 内部使用。以下关键字不能定义为组件中的公共属性或方法名称：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `data`\r\n- `render`\r\n- `resolveView`\r\n- `shouldRender`\r\n- `view`\r\n- `withAttributes`\r\n- `withName`\r\n\r\n</div>\r\n\r\n<a name=\"slots\"></a>\r\n### 插槽\r\n\r\n你通常需要通过「插槽」将其他内容传递给组件。通过回显 `$slot` 变量来呈现组件插槽。为了探索这个概念，我们假设 `alert` 组件具有以下内容：\r\n\r\n```blade\r\n<!-- /resources/views/components/alert.blade.php -->\r\n\r\n<div class=\"alert alert-danger\">\r\n    {{ $slot }}\r\n</div>\r\n```\r\n\r\n我们可以通过向组件中注入内容将内容传递到 `slot` ：\r\n\r\n```blade\r\n<x-alert>\r\n    <strong>Whoops!</strong> Something went wrong!\r\n</x-alert>\r\n```\r\n\r\n有时候一个组件可能需要在它内部的不同位置放置多个不同的插槽。我们来修改一下 alert 组件，使其允许注入 「title」:\r\n\r\n```blade\r\n<!-- /resources/views/components/alert.blade.php -->\r\n\r\n<span class=\"alert-title\">{{ $title }}</span>\r\n\r\n<div class=\"alert alert-danger\">\r\n    {{ $slot }}\r\n</div>\r\n```\r\n\r\n你可以使用 `x-slot` 标签来定义命名插槽的内容。任何没有在 `x-slot` 标签中的内容都将传递给  `$slot` 变量中的组件：\r\n\r\n```xml\r\n<x-alert>\r\n    <x-slot:title>\r\n        Server Error\r\n    </x-slot>\r\n\r\n    <strong>Whoops!</strong> Something went wrong!\r\n</x-alert>\r\n```\r\n\r\n<a name=\"scoped-slots\"></a>\r\n#### 作用域插槽\r\n\r\n如果你使用诸如 Vue 这样的 JavaScript 框架，那么你应该很熟悉「作用域插槽」，它允许你从插槽中的组件访问数据或者方法。 Laravel 中也有类似的用法，只需在你的组件中定义 public 方法或属性，并且使用 `$component` 变量来访问插槽中的组件。在此示例中，我们将假设组件在其组件类上定义了 `x-alert` 一个公共方法： `formatAlert`\r\n\r\n```blade\r\n<x-alert>\r\n    <x-slot:title>\r\n        {{ $component->formatAlert('Server Error') }}\r\n    </x-slot>\r\n\r\n    <strong>Whoops!</strong> Something went wrong!\r\n</x-alert>\r\n```\r\n\r\n\r\n\r\n<a name=\"slot-attributes\"></a>\r\n#### 插槽属性\r\n\r\n像 Blade 组件一样，你可以为插槽分配额外的 [属性](#component-attributes) ，例如 CSS 类名：\r\n\r\n```xml\r\n<x-card class=\"shadow-sm\">\r\n    <x-slot:heading class=\"font-bold\">\r\n        Heading\r\n    </x-slot>\r\n\r\n    Content\r\n\r\n    <x-slot:footer class=\"text-sm\">\r\n        Footer\r\n    </x-slot>\r\n</x-card>\r\n```\r\n\r\n要与插槽属性交互，你可以访问 `attributes` 插槽变量的属性。有关如何与属性交互的更多信息，请参阅有关 [组件属性](#component-attributes) 的文档：\r\n\r\n```blade\r\n@props([\r\n    'heading',\r\n    'footer',\r\n])\r\n\r\n<div {{ $attributes->class(['border']) }}>\r\n    <h1 {{ $heading->attributes->class(['text-lg']) }}>\r\n        {{ $heading }}\r\n    </h1>\r\n\r\n    {{ $slot }}\r\n\r\n    <footer {{ $footer->attributes->class(['text-gray-700']) }}>\r\n        {{ $footer }}\r\n    </footer>\r\n</div>\r\n```\r\n\r\n<a name=\"inline-component-views\"></a>\r\n### 内联组件视图\r\n\r\n对于小型组件而言，管理组件类和组件视图模板可能会很麻烦。因此，你可以从 `render` 方法中返回组件的内容：\r\n\r\n    /**\r\n     * 获取组件的视图 / 内容。\r\n     */\r\n    public function render(): string\r\n    {\r\n        return <<<'blade'\r\n            <div class=\"alert alert-danger\">\r\n                {{ $slot }}\r\n            </div>\r\n        blade;\r\n    }\r\n\r\n<a name=\"generating-inline-view-components\"></a>\r\n#### 生成内联视图组件\r\n\r\n要创建一个渲染内联视图的组件，你可以在运行 `make:component` 命令时使用  `inline` ：\r\n\r\n```shell\r\nphp artisan make:component Alert --inline\r\n```\r\n\r\n<a name=\"dynamic-components\"></a>\r\n### 动态组件\r\n\r\n有时你可能需要渲染一个组件，但直到运行时才知道应该渲染哪个组件。在这种情况下, 你可以使用 Laravel 内置的 `dynamic-component` 组件, 根据运行时的值或变量来渲染组件:\r\n\r\n```blade\r\n<x-dynamic-component :component=\"$componentName\" class=\"mt-4\" />\r\n```\r\n\r\n<a name=\"manually-registering-components\"></a>\r\n### 手动注册组件\r\n\r\n> **注意：**以下关于手动注册组件的文档主要适用于那些正在编写包含视图组件的 Laravel 包的用户。如果你不是在写包，这一部分的组件文档可能与你无关。\r\n\r\n\r\n\r\n当为自己的应用程序编写组件时，组件会在`app/View/Components`目录和`resources/views/components`目录下被自动发现。\r\n\r\n但是，如果你正在建立一个利用 Blade 组件的包，或者将组件放在非传统的目录中，你将需要手动注册你的组件类和它的 HTML 标签别名，以便 Laravel 知道在哪里可以找到这个组件。你通常应该在你的包的服务提供者的`boot`方法中注册你的组件：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use VendorPackage\\View\\Components\\AlertComponent;\r\n\r\n    /**\r\n     * 注册你的包的服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::component('package-alert', AlertComponent::class);\r\n    }\r\n\r\n一旦你的组件被注册，它就可以使用它的标签别名进行渲染。\r\n\r\n```blade\r\n<x-package-alert/>\r\n```\r\n\r\n#### 自动加载包组件\r\n\r\n另外，你可以使用`componentNamespace`方法来自动加载组件类。例如，一个`Nightshade`包可能有`Calendar`和`ColorPicker`组件，它们位于`PackageViews\\Components`命名空间中。\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * 注册你的包的服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::componentNamespace('Nightshade\\\\Views\\\\Components', 'nightshade');\r\n    }\r\n\r\n这将允许使用`package-name::`语法的供应商名称空间来使用包的组件。\r\n\r\n```blade\r\n<x-nightshade::calendar />\r\n<x-nightshade::color-picker />\r\n```\r\n\r\nBlade 将通过组件名称的驼峰式大小写 (pascal-casing) 自动检测与该组件链接的类。也支持使用 \"点 \"符号的子目录。\r\n\r\n<a name=\"anonymous-components\"></a>\r\n### 匿名组件\r\n\r\n与行内组件相同，匿名组件提供了一个通过单个文件管理组件的机制。然而，匿名组件使用的是一个没有关联类的单一视图文件。要定义一个匿名组件，你只需将 Blade 模板置于 `resources/views/components` 目录下。例如，假设你在 `resources/views/components/alert.blade.php`中定义了一个组件：\r\n\r\n```blade\r\n<x-alert/>\r\n```\r\n\r\n\r\n如果组件在 `components` 目录的子目录中，你可以使用 `.` 字符来指定其路径。例如，假设组件被定义在 `resources/views/components/inputs/button.blade.php` 中，你可以像这样渲染它：\r\n\r\n```blade\r\n<x-inputs.button/>\r\n```\r\n\r\n<a name=\"anonymous-index-components\"></a>\r\n#### 匿名索引组件\r\n\r\n有时，当一个组件由许多 Blade 模板组成时，你可能希望将给定组件的模板分组到一个目录中。例如，想象一个具有以下目录结构的「可折叠」组件：\r\n\r\n```none\r\n/resources/views/components/accordion.blade.php\r\n/resources/views/components/accordion/item.blade.php\r\n```\r\n\r\n此目录结构允许你像这样呈现组件及其项目：\r\n\r\n```blade\r\n<x-accordion>\r\n    <x-accordion.item>\r\n        ...\r\n    </x-accordion.item>\r\n</x-accordion>\r\n```\r\n\r\n然而，为了通过 `x-accordion` 渲染组件， 我们被迫将「索引」组件模板放置在 `resources/views/components` 目录中，而不是与其他相关的模板嵌套在 `accordion` 目录中。\r\n\r\n幸运的是，Blade 允许你 `index.blade.php` 在组件的模板目录中放置文件。当 `index.blade.php` 组件存在模板时，它将被呈现为组件的「根」节点。因此，我们可以继续使用上面示例中给出的相同 Blade 语法；但是，我们将像这样调整目录结构：\r\n\r\n```none\r\n/resources/views/components/accordion/index.blade.php\r\n/resources/views/components/accordion/item.blade.php\r\n```\r\n\r\n<a name=\"data-properties-attributes\"></a>\r\n#### 数据 / 属性\r\n\r\n由于匿名组件没有任何关联类，你可能想要区分哪些数据应该被作为变量传递给组件，而哪些属性应该被存放于 [属性包](#component-attributes)中。\r\n\r\n\r\n\r\n你可以在组件的 Blade 模板的顶层使用 `@props` 指令来指定哪些属性应该作为数据变量。组件中的其他属性都将通过属性包的形式提供。如果你想要为某个数据变量指定一个默认值，你可以将属性名作为数组键，默认值作为数组值来实现：\r\n\r\n```blade\r\n<!-- /resources/views/components/alert.blade.php -->\r\n\r\n@props(['type' => 'info', 'message'])\r\n\r\n<div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>\r\n    {{ $message }}\r\n</div>\r\n```\r\n\r\n给定上面的组件定义，我们可以像这样渲染组件：\r\n\r\n```blade\r\n<x-alert type=\"error\" :message=\"$message\" class=\"mb-4\"/>\r\n```\r\n\r\n<a name=\"accessing-parent-data\"></a>\r\n#### 访问父组件数据\r\n\r\n有时你可能希望从子组件中的父组件访问数据。在这些情况下，你可以使用该 `@aware` 指令。例如，假设我们正在构建一个由父 `<x-menu>` 和 子组成的复杂菜单组件 `<x-menu.item>`：\r\n\r\n```blade\r\n<x-menu color=\"purple\">\r\n    <x-menu.item>...</x-menu.item>\r\n    <x-menu.item>...</x-menu.item>\r\n</x-menu>\r\n```\r\n\r\n该 `<x-menu>` 组件可能具有如下实现：\r\n\r\n```blade\r\n<!-- /resources/views/components/menu/index.blade.php -->\r\n\r\n@props(['color' => 'gray'])\r\n\r\n<ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}>\r\n    {{ $slot }}\r\n</ul>\r\n```\r\n\r\n因为 `color` 只被传递到父级 (`<x-menu>`)中，所以 `<x-menu.item>` 在内部是不可用的。但是，如果我们使用该 `@aware` 指令，我们也可以使其在内部可用 `<x-menu.item>` ：\r\n\r\n```blade\r\n<!-- /resources/views/components/menu/item.blade.php -->\r\n\r\n@aware(['color' => 'gray'])\r\n\r\n<li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}>\r\n    {{ $slot }}\r\n</li>\r\n```\r\n\r\n> **注意：**该 `@aware` 指令无法访问未通过 HTML 属性显式传递给父组件的父数据。`@aware` 指令 不能访问未显式传递给父组件的默认值 `@props` 。\r\n\r\n\r\n<a name=\"anonymous-component-paths\"></a>\r\n### 匿名组件路径\r\n\r\n如前所述，匿名组件通常是通过在你的`resources/views/components`目录下放置一个 Blade 模板来定义的。然而，你可能偶尔想在 Laravel 注册其他匿名组件的路径，除了默认路径。\r\n\r\n`anonymousComponentPath`方法接受匿名组件位置的「路径」作为它的第一个参数，并接受一个可选的「命名空间」作为它的第二个参数，组件应该被放在这个命名空间下。通常，这个方法应该从你的应用程序的一个[服务提供者](/docs/laravel/10.x/providers) 的`boot`方法中调用。\r\n\r\n    /**\r\n     * 引导任何应用服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::anonymousComponentPath(__DIR__.'/../components');\r\n    }\r\n\r\n当组件路径被注册而没有指定前缀时，就像上面的例子一样，它们在你的 Blade 组件中可能也没有相应的前缀。例如，如果一个`panel.blade.php`组件存在于上面注册的路径中，它可能会被呈现为这样。\r\n\r\n```blade\r\n<x-panel />\r\n```\r\n\r\n前缀「命名空间」可以作为第二个参数提供给`anonymousComponentPath`方法。\r\n\r\n    Blade::anonymousComponentPath(__DIR__.'/../components', 'dashboard');\r\n\r\n当提供一个前缀时，在该「命名空间」内的组件可以在渲染时将该组件的命名空间前缀到该组件的名称。\r\n\r\n```blade\r\n<x-dashboard::panel />\r\n```\r\n\r\n<a name=\"building-layouts\"></a>\r\n## 构建布局\r\n\r\n<a name=\"layouts-using-components\"></a>\r\n### 使用组件布局\r\n\r\n大多数 web 应用程序在不同的页面上有相同的总体布局。如果我们必须在创建的每个视图中重复整个布局 HTML，那么维护我们的应用程序将变得非常麻烦和困难。谢天谢地，将此布局定义为单个 [Blade 组件](#components) 并在整个应用程序中非常方便地使用它。\r\n\r\n\r\n<a name=\"defining-the-layout-component\"></a>\r\n#### 定义布局组件\r\n\r\n例如，假设我们正在构建一个「todo list」应用程序。我们可以定义如下所示的 `layout` 组件：\r\n\r\n```blade\r\n<!-- resources/views/components/layout.blade.php -->\r\n\r\n<html>\r\n    <head>\r\n        <title>{{ $title ?? 'Todo Manager' }}</title>\r\n    </head>\r\n    <body>\r\n        <h1>Todos</h1>\r\n        <hr/>\r\n        {{ $slot }}\r\n    </body>\r\n</html>\r\n```\r\n\r\n<a name=\"applying-the-layout-component\"></a>\r\n#### 应用布局组件\r\n\r\n一旦定义了 `layout` 组件，我们就可以创建一个使用该组件的 Blade 视图。在本例中，我们将定义一个显示任务列表的简单视图：\r\n\r\n```blade\r\n<!-- resources/views/tasks.blade.php -->\r\n\r\n<x-layout>\r\n    @foreach ($tasks as $task)\r\n        {{ $task }}\r\n    @endforeach\r\n</x-layout>\r\n```\r\n\r\n请记住，注入到组件中的内容将提供给 `layout` 组件中的默认 `$slot` 变量。正如你可能已经注意到的，如果提供了 `$title` 插槽，那么我们的 `layout` 也会尊从该插槽；否则，将显示默认的标题。我们可以使用组件文档中讨论的标准槽语法从任务列表视图中插入自定义标题。 我们可以使用[组件文档](#components)中讨论的标准插槽语法从任务列表视图中注入自定义标题：\r\n\r\n```blade\r\n<!-- resources/views/tasks.blade.php -->\r\n\r\n<x-layout>\r\n    <x-slot:title>\r\n        Custom Title\r\n    </x-slot>\r\n\r\n    @foreach ($tasks as $task)\r\n        {{ $task }}\r\n    @endforeach\r\n</x-layout>\r\n```\r\n\r\n现在我们已经定义了布局和任务列表视图，我们只需要从路由中返回 `task` 视图即可：\r\n\r\n    use App\\Models\\Task;\r\n\r\n    Route::get('/tasks', function () {\r\n        return view('tasks', ['tasks' => Task::all()]);\r\n    });\r\n\r\n<a name=\"layouts-using-template-inheritance\"></a>\r\n### 使用模板继承进行布局\r\n\r\n<a name=\"defining-a-layout\"></a>\r\n#### 定义一个布局\r\n\r\n布局也可以通过 「模板继承」 创建。在引入 [组件](#components) 之前，这是构建应用程序的主要方法。\r\n\r\n\r\n\r\n让我们看一个简单的例子做开头。首先，我们将检查页面布局。由于大多数 web 应用程序在不同的页面上保持相同的总体布局，因此将此布局定义为单一视图非常方便：\r\n\r\n```blade\r\n<!-- resources/views/layouts/app.blade.php -->\r\n\r\n<html>\r\n    <head>\r\n        <title>App Name - @yield('title')</title>\r\n    </head>\r\n    <body>\r\n        @section('sidebar')\r\n            这是一个主要的侧边栏\r\n        @show\r\n\r\n        <div class=\"container\">\r\n            @yield('content')\r\n        </div>\r\n    </body>\r\n</html>\r\n```\r\n\r\n如你所见，此文件包含经典的 HTML 标记。但是，请注意 `@section` 和 `@yield` 指令。顾名思义， `@section` 指令定义内容的一部分，而 `@yield` 指令用于显示给定部分的内容。\r\n\r\n现在我们已经为应用程序定义了一个布局，让我们定义一个继承该布局的子页面。\r\n\r\n<a name=\"extending-a-layout\"></a>\r\n#### 继承布局\r\n\r\n定义子视图时，请使用 `@extends` Blade 指令指定子视图应「继承」的布局。扩展 Blade 布局的视图可以使用 `@section` 指令将内容注入布局的节点中。请记住，如上面的示例所示，这些部分的内容将使用 `@yield` 显示在布局中：\r\n\r\n```blade\r\n<!-- resources/views/child.blade.php -->\r\n\r\n@extends('layouts.app')\r\n\r\n@section('title', 'Page Title')\r\n\r\n@section('sidebar')\r\n    @parent\r\n\r\n    <p>This is appended to the master sidebar.</p>\r\n@endsection\r\n\r\n@section('content')\r\n    <p>This is my body content.</p>\r\n@endsection\r\n```\r\n\r\n在本例中，`sidebar` 部分使用 `@parent`  指令将内容追加（而不是覆盖）到局部的侧栏位置。在呈现视图时， `@parent` 指令将被布局的内容替换。\r\n\r\n> **技巧：**与前面的示例相反，本 `sidebar` 节以 `@endsection` 结束，而不是以 `@show` 结束。 `@endsection` 指令将只定义一个节，`@show` 将定义并 **立即 yield** 该节。\r\n\r\n\r\n该 `@yield` 指令还接受默认值作为其第二个参数。如果要生成的节点未定义，则将呈现此内容：\r\n\r\n```blade\r\n@yield('content', 'Default content')\r\n```\r\n\r\n<a name=\"forms\"></a>\r\n## 表单\r\n\r\n<a name=\"csrf-field\"></a>\r\n### CSRF 字段\r\n\r\n无论何时在应用程序中定义 HTML 表单，都应该在表单中包含一个隐藏的 CSRF 令牌字段，以便 [CSRF 保护中间件](/docs/laravel/10.x/csrf) 可以验证请求。你可以使用 `@csrf` Blade 指令生成令牌字段：\r\n\r\n```blade\r\n<form method=\"POST\" action=\"/profile\">\r\n    @csrf\r\n\r\n    ...\r\n</form>\r\n```\r\n\r\n<a name=\"method-field\"></a>\r\n### Method 字段\r\n\r\n由于 HTML 表单不能发出 `PUT`、`PATCH`或 `DELETE` 请求，因此需要添加一个隐藏的 `_method` 字段来欺骗这些 HTTP 动词。 `@method` Blade 指令可以为你创建此字段：\r\n\r\n```blade\r\n<form action=\"/foo/bar\" method=\"POST\">\r\n    @method('PUT')\r\n\r\n    ...\r\n</form>\r\n```\r\n\r\n<a name=\"validation-errors\"></a>\r\n### 表单校验错误\r\n\r\n该 `@error` 指令可用于快速检查给定属性是否存在 [验证错误消息](/docs/laravel/10.x/validation#quick-displaying-the-validation-errors) 。在 `@error` 指令中，可以回显 `$message` 变量以显示错误消息：\r\n\r\n```blade\r\n<!-- /resources/views/post/create.blade.php -->\r\n\r\n<label for=\"title\">Post Title</label>\r\n\r\n<input id=\"title\"\r\n    type=\"text\"\r\n    class=\"@error('title') is-invalid @enderror\">\r\n\r\n@error('title')\r\n    <div class=\"alert alert-danger\">{{ $message }}</div>\r\n@enderror\r\n```\r\n\r\n由于该 `@error` 指令编译为「if」语句，因此你可以在 `@else` 属性没有错误时使用该指令来呈现内容：\r\n\r\n```blade\r\n<!-- /resources/views/auth.blade.php -->\r\n\r\n<label for=\"email\">Email address</label>\r\n\r\n<input id=\"email\"\r\n    type=\"email\"\r\n    class=\"@error('email') is-invalid @else is-valid @enderror\">\r\n```\r\n\r\n\r\n\r\n你可以将 [特定错误包的名称](/docs/laravel/10.x/validation#named-error-bags) 作为第二个参数传递给 `@error` 指令，以便在包含多个表单的页面上检索验证错误消息：\r\n\r\n```blade\r\n<!-- /resources/views/auth.blade.php -->\r\n\r\n<label for=\"email\">Email address</label>\r\n\r\n<input id=\"email\"\r\n    type=\"email\"\r\n    class=\"@error('email', 'login') is-invalid @enderror\">\r\n\r\n@error('email', 'login')\r\n    <div class=\"alert alert-danger\">{{ $message }}</div>\r\n@enderror\r\n```\r\n\r\n<a name=\"stacks\"></a>\r\n## 堆栈\r\n\r\nBlade 允许你推送到可以在其他视图或布局中的其他地方渲染的命名堆栈。这对于指定子视图所需的任何 JavaScript 库特别有用：\r\n\r\n```blade\r\n@push('scripts')\r\n    <script src=\"/example.js\"></script>\r\n@endpush\r\n```\r\n\r\n如果你想在给定的布尔表达式评估为 `true` 时 `@push` 内容，你可以使用 `@pushIf` 指令。\r\n\r\n```blade\r\n@pushIf($shouldPush, 'scripts')\r\n    <script src=\"/example.js\"></script>\r\n@endPushIf\r\n```\r\n\r\n你可以根据需要多次推入堆栈。要呈现完整的堆栈内容，请将堆栈的名称传递给 `@stack` 指令：\r\n\r\n```blade\r\n<head>\r\n    <!-- Head Contents -->\r\n\r\n    @stack('scripts')\r\n</head>\r\n```\r\n\r\n如果要将内容前置到堆栈的开头，应使用 `@prepend` 指令：\r\n\r\n```blade\r\n@push('scripts')\r\n    This will be second...\r\n@endpush\r\n\r\n// Later...\r\n\r\n@prepend('scripts')\r\n    This will be first...\r\n@endprepend\r\n```\r\n\r\n<a name=\"service-injection\"></a>\r\n## 服务注入\r\n\r\n该 `@inject` 指令可用于从 Laravel [服务容器](/docs/laravel/10.x/container)中检索服务。传递给 `@inject` 的第一个参数是要将服务放入的变量的名称，而第二个参数是要解析的服务的类或接口名称：\r\n\r\n```blade\r\n@inject('metrics', 'App\\Services\\MetricsService')\r\n\r\n<div>\r\n    Monthly Revenue: {{ $metrics->monthlyRevenue() }}.\r\n</div>\r\n```\r\n\r\n\r\n\r\n<a name=\"rendering-inline-blade-templates\"></a>\r\n## 渲染内联 Blade 模板\r\n\r\n有时你可能需要将原始 Blade 模板字符串转换为有效的 HTML。你可以使用 `Blade` 门面提供的 `render` 方法来完成此操作。该 `render` 方法接受 Blade 模板字符串和提供给模板的可选数据数组：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Blade;\r\n\r\nreturn Blade::render('Hello, {{ $name }}', ['name' => 'Julian Bashir']);\r\n```\r\n\r\nLaravel 通过将内联 Blade 模板写入 `storage/framework/views` 目录来呈现它们。如果你希望 Laravel 在渲染 Blade 模板后删除这些临时文件，你可以为 `deleteCachedView` 方法提供参数：\r\n\r\n```php\r\nreturn Blade::render(\r\n    'Hello, {{ $name }}',\r\n    ['name' => 'Julian Bashir'],\r\n    deleteCachedView: true\r\n);\r\n```\r\n\r\n<a name=\"rendering-blade-fragments\"></a>\r\n## 渲染 Blade 片段\r\n\r\n当使用 [Turbo](https://turbo.hotwired.dev/) 和 [htmx](https://htmx.org/) 等前端框架时，你可能偶尔需要在你的HTTP响应中只返回Blade模板的一个部分。Blade「片段（fragment）」允许你这样做。要开始，将你的Blade模板的一部分放在`@fragment`和`@endfragment`指令中。\r\n\r\n```blade\r\n@fragment('user-list')\r\n    <ul>\r\n        @foreach ($users as $user)\r\n            <li>{{ $user->name }}</li>\r\n        @endforeach\r\n    </ul>\r\n@endfragment\r\n```\r\n\r\n然后，在渲染使用该模板的视图时，你可以调用 `fragment` 方法来指定只有指定的片段应该被包含在传出的 HTTP 响应中。\r\n\r\n```php\r\nreturn view('dashboard', ['users' => $users])->fragment('user-list');\r\n```\r\n\r\n`fragmentIf` 方法允许你根据一个给定的条件有条件地返回一个视图的片段。否则，整个视图将被返回。\r\n\r\n```php\r\nreturn view('dashboard', ['users' => $users])\r\n    ->fragmentIf($request->hasHeader('HX-Request'), 'user-list');\r\n```\r\n\r\n\r\n\r\n`fragments` 和 `fragmentsIf` 方法允许你在响应中返回多个视图片段。这些片段将被串联起来。\r\n\r\n```php\r\nview('dashboard', ['users' => $users])\r\n    ->fragments(['user-list', 'comment-list']);\r\n\r\nview('dashboard', ['users' => $users])\r\n    ->fragmentsIf(\r\n        $request->hasHeader('HX-Request'),\r\n        ['user-list', 'comment-list']\r\n    );\r\n```\r\n\r\n<a name=\"extending-blade\"></a>\r\n## 扩展 Blade\r\n\r\nBlade 允许你使用 `directive` 方法定义自己的自定义指令。当 Blade 编译器遇到自定义指令时，它将使用该指令包含的表达式调用提供的回调。\r\n\r\n下面的示例创建了一个 `@datetime($var)` 指令，该指令格式化给定的 `$var`，它应该是 `DateTime` 的一个实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册应用的服务\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * Bootstrap any application services.\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Blade::directive('datetime', function (string $expression) {\r\n                return \"<?php echo ($expression)->format('m/d/Y H:i'); ?>\";\r\n            });\r\n        }\r\n    }\r\n\r\n正如你所见，我们将 `format` 方法应用到传递给指令中的任何表达式上。因此，在本例中，此指令生成的最终 PHP 将是：\r\n\r\n    <?php echo ($var)->format('m/d/Y H:i'); ?>\r\n\r\n> **注意：**更新 Blade 指令的逻辑后，需要删除所有缓存的 Blade 视图。可以使用 `view:clear` Artisan 命令。\r\n\r\n<a name=\"custom-echo-handlers\"></a>\r\n### 自定义回显处理程序\r\n\r\n如果你试图使用 Blade 来「回显」一个对象， 该对象的 `__toString` 方法将被调用。该[`__toString`](https://www.php.net/manual/en/language.oop5.magic.php#object.tostring) 方法是 PHP 内置的「魔术方法」之一。但是，有时你可能无法控制 `__toString` 给定类的方法，例如当你与之交互的类属于第三方库时。\r\n\r\n在这些情况下，Blade 允许您为该特定类型的对象注册自定义回显处理程序。为此，您应该调用 Blade 的 `stringable` 方法。该 `stringable` 方法接受一个闭包。这个闭包类型应该提示它负责呈现的对象的类型。通常，应该在应用程序的 `AppServiceProvider` 类的 `boot` 方法中调用该 `stringable` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use Money\\Money;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::stringable(function (Money $money) {\r\n            return $money->formatTo('en_GB');\r\n        });\r\n    }\r\n\r\n定义自定义回显处理程序后，您可以简单地回显 Blade 模板中的对象：\r\n\r\n```blade\r\nCost: {{ $money }}\r\n```\r\n\r\n<a name=\"custom-if-statements\"></a>\r\n### 自定义 if 声明\r\n\r\n在定义简单的自定义条件语句时，编写自定义指令通常比较复杂。因此，Blade 提供了一个 Blade::if 方法，允许你使用闭包快速定义自定义条件指令。例如，让我们定义一个自定义条件来检查为应用程序配置的默认 「存储」。我们可以在 AppServiceProvider 的 boot 方法中执行此操作：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::if('disk', function (string $value) {\r\n            return config('filesystems.default') === $value;\r\n        });\r\n    }\r\n\r\n一旦定义了自定义条件，就可以在模板中使用它:\r\n\r\n```blade\r\n@disk('local')\r\n    <!-- The application is using the local disk... -->\r\n@elsedisk('s3')\r\n    <!-- The application is using the s3 disk... -->\r\n@else\r\n    <!-- The application is using some other disk... -->\r\n@enddisk\r\n\r\n@unlessdisk('local')\r\n    <!-- The application is not using the local disk... -->\r\n@enddisk\r\n```\r\n\r\n","p":"docs/blade.html"},{"t":"vite (资源绑定（Vite）)","d":"# 资源绑定（Vite）\r\n\r\n-   [介绍](#introduction)\r\n-   [安装和设置](#installation)\r\n    -   [安装 Node](#installing-node)\r\n    -   [安装 Vite 和 Laravel 插件](#installing-vite-and-laravel-plugin)\r\n    -   [配置 Vite](#configuring-vite)\r\n    -   [加载你的脚本和样式](#loading-your-scripts-and-styles)\r\n-   [运行 Vite](#running-vite)\r\n-   [使用 JavaScript](#working-with-scripts)\r\n    -   [别名](#aliases)\r\n    -   [Vue](#vue)\r\n    -   [React](#react)\r\n    -   [Inertia](#inertia)\r\n    -   [URL 处理](#url-processing)\r\n-   [使用样式表](#working-with-stylesheets)\r\n-   [使用 Blade 和路由](#working-with-blade-and-routes)\r\n    -   [使用 Vite 处理静态资源](#blade-processing-static-assets)\r\n    -   [保存后刷新](#blade-refreshing-on-save)\r\n    -   [别名](#blade-aliases)\r\n-   [自定义基础 URL](#custom-base-urls)\r\n-   [环境变量](#environment-variables)\r\n-   [在测试中禁用 Vite](#disabling-vite-in-tests)\r\n-   [服务器端渲染（SSR）](#ssr)\r\n-   [脚本和样式标记属性](#script-and-style-attributes)\r\n    -   [内容安全策略（CSP）随机数](#content-security-policy-csp-nonce)\r\n    -   [子资源完整性（SRI）](#subresource-integrity-sri)\r\n    -   [任意属性](#arbitrary-attributes)\r\n-   [高级定制](#advanced-customization)\r\n    -   [更正开发服务器 URL](#correcting-dev-server-urls)\r\n\r\n<a name=\"introduction\"></a>\r\n\r\n## 介绍\r\n\r\n[Vite](https://vitejs.dev/) 是一款现代前端构建工具，提供极快的开发环境并将你的代码捆绑到生产准备的资源中。在使用 Laravel 构建应用程序时，通常会使用 Vite 将你的应用程序的 CSS 和 JavaScript 文件绑定到生产环境的资源中。\r\n\r\nLaravel 通过提供官方插件和 Blade 指令，与 Vite 完美集成，以加载你的资源进行开发和生产。\r\n\r\n>注意：你正在运行 Laravel Mix 吗？在新的 Laravel 安装中，Vite 已经取代了 Laravel Mix 。有关 Mix 的文档，请访问 [Laravel Mix](https://laravel-mix.com/) 网站。如果你想切换到 Vite，请参阅我们的 [迁移指南](https://github.com/laravel/vite-plugin/blob/main/UPGRADE.md#migrating-from-laravel-mix-to-vite)。\r\n\r\n#### 选择 Vite 还是 Laravel Mix\r\n\r\n在转向 Vite 之前，新的 Laravel 应用程序在打包资产时通常使用 [Mix](https://laravel-mix.com/)，它由 [webpack](https://webpack.js.org/) 支持。Vite 专注于在构建丰富的 JavaScript 应用程序时提供更快、更高效的开发体验。如果你正在开发单页面应用程序（SPA），包括使用 [Inertia](https://inertiajs.com/) 工具开发的应用程序，则 Vite 是完美选择。\r\n\r\nVite 也适用于具有 JavaScript “sprinkles” 的传统服务器端渲染应用程序，包括使用 [Livewire](https://laravel-livewire.com/) 的应用程序。但是，它缺少 Laravel Mix 支持的某些功能，例如将没有直接在 JavaScript 应用程序中引用的任意资产复制到构建中的能力。\r\n\r\n#### 切换回 Mix\r\n\r\n如果你使用我们的 Vite 脚手架创建了一个新的 Laravel 应用程序，但需要切换回 Laravel Mix 和 webpack，那么也没有问题。请参阅我们的[从 Vite 切换到 Mix 的官方指南](https://github.com/laravel/vite-plugin/blob/main/UPGRADE.md#migrating-from-vite-to-laravel-mix)。\r\n\r\n## 安装和设置\r\n\r\n> **注意**\r\n> 以下文档讨论如何手动安装和配置 Laravel Vite 插件。但是，Laravel 的[起始套件](/docs/laravel/10.x/starter-kits)已经包含了所有的脚手架，并且是使用 Laravel 和 Vite 开始最快的方式。\r\n\r\n### 安装 Node\r\n\r\n在运行 Vite 和 Laravel 插件之前，你必须确保已安装 Node.js（16+）和 NPM：\r\n\r\n\r\n`node -v\r\nnpm -v` \r\n\r\n你可以通过[官方 Node 网站](https://nodejs.org/en/download/)的简单图形安装程序轻松安装最新版本的 Node 和 NPM。或者，如果你使用的是 [Laravel Sail](/docs/laravel/10.x/sail)，可以通过 Sail 调用 Node 和 NPM：\r\n\r\n\r\n`./vendor/bin/sail node -v\r\n./vendor/bin/sail npm -v`\r\n\r\n<a name=\"installing-vite-and-laravel-plugin\"></a>\r\n### 安装 Vite 和 Laravel 插件\r\n\r\n在 Laravel 的全新安装中，你会在应用程序目录结构的根目录下找到一个 package.json 文件。默认的 package.json 文件已经包含了你开始使用 Vite 和 Laravel 插件所需的一切。你可以通过 NPM 安装应用程序的前端依赖：\r\n\r\n```sh\r\nnpm install\r\n```\r\n\r\n<a name=\"configuring-vite\"></a>\r\n### 配置 Vite\r\n\r\nVite 通过项目根目录中的 `vite.config.js` 文件进行配置。你可以根据自己的需要自定义此文件，也可以安装任何其他插件，例如 `@vitejs/plugin-vue` 或 `@vitejs/plugin-react`。\r\n\r\nLaravel Vite 插件需要你指定应用程序的入口点。这些入口点可以是 JavaScript 或 CSS 文件，并包括预处理语言，例如 TypeScript、JSX、TSX 和 Sass。\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel([\r\n            'resources/css/app.css',\r\n            'resources/js/app.js',\r\n        ]),\r\n    ],\r\n});\r\n```\r\n\r\n如果你正在构建一个单页应用程序，包括使用 Inertia 构建的应用程序，则最好不要使用 CSS 入口点：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel([\r\n            'resources/css/app.css', // [tl! remove]\r\n            'resources/js/app.js',\r\n        ]),\r\n    ],\r\n});\r\n```\r\n\r\n相反，你应该通过 JavaScript 导入你的 CSS。通常，这将在应用程序的 resources/js/app.js 文件中完成：\r\n\r\n```js\r\nimport './bootstrap';\r\nimport '../css/app.css'; // [tl! add]\r\n```\r\n\r\nLaravel 插件还支持多个入口点和高级配置选项，例如[SSR 入口点](#ssr)。\r\n\r\n\r\n\r\n<a name=\"working-with-a-secure-development-server\"></a>\r\n#### 使用安全的开发服务器\r\n\r\n如果你的本地开发 Web 服务器通过 HTTPS 提供应用程序服务，则可能会遇到连接到 Vite 开发服务器的问题。\r\n\r\n如果你在本地开发中使用 [Laravel Valet](/docs/laravel/10.x/valet) 并已针对你的应用程序运行 [secure 命令](/docs/laravel/10.x/valetmd#securing-sites)，则可以配置 Vite 开发服务器自动使用 Valet 生成的 TLS 证书：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            // ...\r\n            valetTls: 'my-app.test', // [tl! add]\r\n        }),\r\n    ],\r\n});\r\n```\r\n当使用其他 Web 服务器时，你应生成一个受信任的证书并手动配置 Vite 使用生成的证书：\r\n\r\n```js\r\n// ...\r\nimport fs from 'fs'; // [tl! add]\r\n\r\nconst host = 'my-app.test'; // [tl! add]\r\n\r\nexport default defineConfig({\r\n    // ...\r\n    server: { // [tl! add]\r\n        host, // [tl! add]\r\n        hmr: { host }, // [tl! add]\r\n        https: { // [tl! add]\r\n            key: fs.readFileSync(`/path/to/${host}.key`), // [tl! add]\r\n            cert: fs.readFileSync(`/path/to/${host}.crt`), // [tl! add]\r\n        }, // [tl! add]\r\n    }, // [tl! add]\r\n});\r\n```\r\n\r\n如果你无法为系统生成可信证书，则可以安装并配置 [`@vitejs/plugin-basic-ssl` 插件](https://github.com/vitejs/vite-plugin-basic-ssl)。使用不受信任的证书时，你需要通过在运行 `npm run dev` 命令时按照控制台中的“Local”链接接受 Vite 开发服务器的证书警告。\r\n\r\n\r\n<a name=\"loading-your-scripts-and-styles\"></a>\r\n### 加载你的脚本和样式\r\n\r\n配置了 Vite 入口点后，你只需要在应用程序根模板的 `<head>` 中添加一个 `@vite()` Blade 指令引用它们即可：\r\n\r\n```blade\r\n<!doctype html>\r\n<head>\r\n    {{-- ... --}}\r\n\r\n    @vite(['resources/css/app.css', 'resources/js/app.js'])\r\n</head>\r\n```\r\n\r\n\r\n\r\n如果你通过 JavaScript 导入你的 CSS 文件，你只需要包含 JavaScript 的入口点：\r\n\r\n```blade\r\n<!doctype html>\r\n<head>\r\n    {{-- ... --}}\r\n\r\n    @vite('resources/js/app.js')\r\n</head>\r\n```\r\n\r\n`@vite` 指令会自动检测 Vite 开发服务器并注入 Vite 客户端以启用热模块替换。在构建模式下，该指令将加载已编译和版本化的资产，包括任何导入的 CSS 文件。\r\n\r\n如果需要，在调用 `@vite` 指令时，你还可以指定已编译资产的构建路径：\r\n\r\n```blade\r\n<!doctype html>\r\n<head>\r\n    {{-- Given build path is relative to public path. --}}\r\n\r\n    @vite('resources/js/app.js', 'vendor/courier/build')\r\n</head>\r\n```\r\n\r\n<a name=\"running-vite\"></a>\r\n## 运行 Vite\r\n\r\n你可以通过两种方式运行 Vite。你可以通过 `dev` 命令运行开发服务器，在本地开发时非常有用。开发服务器会自动检测文件的更改，并立即在任何打开的浏览器窗口中反映这些更改。\r\n\r\n或者，运行 `build` 命令将版本化并打包应用程序的资产，并准备好部署到生产环境：\r\n\r\nOr, running the `build` command will version and bundle your application's assets and get them ready for you to deploy to production:\r\n\r\n```shell\r\n# Run the Vite development server...\r\nnpm run dev\r\n\r\n# Build and version the assets for production...\r\nnpm run build\r\n```\r\n\r\n<a name=\"working-with-scripts\"></a>\r\n## 使用 JavaScript\r\n\r\n<a name=\"aliases\"></a>\r\n### 别名\r\n\r\n默认情况下，Laravel 插件提供一个常用的别名，以帮助你快速开始并方便地导入你的应用程序的资产：\r\n\r\n```js\r\n{\r\n    '@' => '/resources/js'\r\n}\r\n```\r\n\r\n你可以通过添加自己的别名到 `vite.config.js` 配置文件中，覆盖 `'@'` 别名：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel(['resources/ts/app.tsx']),\r\n    ],\r\n    resolve: {\r\n        alias: {\r\n            '@': '/resources/ts',\r\n        },\r\n    },\r\n});\r\n```\r\n\r\n\r\n\r\n<a name=\"vue\"></a>\r\n### Vue\r\n\r\n如果你想要使用 [Vue](https://vuejs.org/) 框架构建前端，那么你还需要安装 `@vitejs/plugin-vue` 插件：\r\n\r\n```sh\r\nnpm install --save-dev @vitejs/plugin-vue\r\n```\r\n\r\n然后你可以在 `vite.config.js` 配置文件中包含该插件。当使用 Laravel 和 Vue 插件时，还需要一些附加选项：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\nimport vue from '@vitejs/plugin-vue';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel(['resources/js/app.js']),\r\n        vue({\r\n            template: {\r\n                transformAssetUrls: {\r\n                    // Vue 插件会重新编写资产 URL，以便在单文件组件中引用时，指向 Laravel web 服务器。\r\n                    // 将其设置为 `null`，则 Laravel 插件会将资产 URL 重新编写为指向 Vite 服务器。\r\n                    base: null,\r\n\r\n                    // Vue 插件将解析绝对 URL 并将其视为磁盘上文件的绝对路径。\r\n                    // 将其设置为 `false`，将保留绝对 URL 不变，以便可以像预期那样引用公共目录中的资源。\r\n                    includeAbsolute: false,\r\n                },\r\n            },\r\n        }),\r\n    ],\r\n});\r\n```\r\n\r\n**注意**\r\nLaravel 的 [起步套件](/docs/laravel/10.x/starter-kits) 已经包含了适当的 Laravel、Vue 和 Vite 配置。请查看 [Laravel Breeze](/docs/laravel/10.x/starter-kitsmd#breeze-and-inertia) 以了解使用 Laravel、Vue 和 Vite 快速入门的最快方法。\r\n\r\n<a name=\"react\"></a>\r\n### React\r\n\r\n如果你想要使用 [React](https://reactjs.org/) 框架构建前端，那么你还需要安装 `@vitejs/plugin-react` 插件：\r\n\r\n```sh\r\nnpm install --save-dev @vitejs/plugin-react\r\n```\r\n\r\n你可以在 `vite.config.js` 配置文件中包含该插件：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\nimport react from '@vitejs/plugin-react';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel(['resources/js/app.jsx']),\r\n        react(),\r\n    ],\r\n});\r\n```\r\n\r\n\r\n\r\n当使用 Vite 和 React 时，你将需要确保任何包含 JSX 的文件都有一个 .jsx 和 .tsx 扩展，记住更新入口文件，如果需要 [如上所示](#configuring-vite)。你还需要在现有的 `@vite` 指令旁边包含额外的 `@viteReactRefresh` Blade 指令。\r\n\r\n```blade\r\n@viteReactRefresh\r\n@vite('resources/js/app.jsx')\r\n```\r\n\r\n`@viteReactRefresh` 指令必须在 `@vite` 指令之前调用 。\r\n\r\n> **注意**  \r\n> Laravel 的 [起步套件](/docs/laravel/10.x/starter-kits) 已经包含了适合的 Laravel、React 和 Vite 配置。查看 [Laravel Breeze](/docs/laravel/10.x/starter-kitsmd#breeze-and-inertia) 以最快的方式开始学习 Laravel、React 和 Vite。\r\n\r\n<a name=\"inertia\"></a>\r\n### Inertia\r\n\r\nLaravel Vite 插件提供了一个方便的 `resolvePageComponent` 函数，帮助你解决 Inertia 页面组件。以下是使用 Vue 3 的助手示例；然而，你也可以在其他框架中使用该函数，例如 React：\r\n\r\n```js\r\nimport { createApp, h } from 'vue';\r\nimport { createInertiaApp } from '@inertiajs/vue3';\r\nimport { resolvePageComponent } from 'laravel-vite-plugin/inertia-helpers';\r\n\r\ncreateInertiaApp({\r\n  resolve: (name) => resolvePageComponent(`./Pages/${name}.vue`, import.meta.glob('./Pages/**/*.vue')),\r\n  setup({ el, App, props, plugin }) {\r\n    return createApp({ render: () => h(App, props) })\r\n      .use(plugin)\r\n      .mount(el)\r\n  },\r\n});\r\n```\r\n\r\n> **注意**  \r\n> Laravel 的 [起步套件](/docs/laravel/10.x/starter-kits) 已经包含了适合的 Laravel、Inertia 和 Vite 配置。查看 [Laravel Breeze](/docs/laravel/10.x/starter-kitsmd#breeze-and-inertia) 以最快的方式开始学习 Laravel、Inertia 和 Vite。\r\n\r\n<a name=\"url-processing\"></a>\r\n### URL 处理\r\n\r\n当使用 Vite 并在你的应用程序的 HTML，CSS 和 JS 中引用资源时，有几件事情需要考虑。首先，如果你使用绝对路径引用资源，Vite 将不会在构建中包含资源；因此，你需要确认资源在你的公共目录中是可用的。\r\n\r\n\r\n\r\n在引用相对路径的资源时，你应该记住这些路径是相对于它们被引用的文件的路径。通过相对路径引用的所有资源都将被 Vite 重写、版本化和打包。\r\n\r\n参考以下项目结构：\r\n\r\n```\r\npublic/\r\n  taylor.png\r\nresources/\r\n  js/\r\n    Pages/\r\n      Welcome.vue\r\n  images/\r\n    abigail.png\r\n``` \r\n\r\n以下示例演示了 Vite 如何处理相对路径和绝对 URL：\r\n\r\n```\r\n<!-- 这个资源不被 Vite 处理，不会被包含在构建中 -->\r\n<img src=\"/taylor.png\">\r\n\r\n<!-- 这个资源将由 Vite 重写、版本化和打包 -->\r\n<img src=\"../../images/abigail.png\">` \r\n```\r\n\r\n<a name=\"working-with-stylesheets\"></a>\r\n\r\n## 使用样式表\r\n\r\n你可以在 [Vite 文档](https://vitejs.dev/guide/features.html#css) 中了解有关 Vite 的 CSS 支持更多的信息。如果你使用 PostCSS 插件，如 [Tailwind](https://tailwindcss.com/)，你可以在项目的根目录中创建一个 `postcss.config.js` 文件，Vite 会自动应用它：\r\n\r\n```\r\nmodule.exports = {\r\n    plugins: {\r\n        tailwindcss: {},\r\n        autoprefixer: {},\r\n    },\r\n};\r\n```\r\n> **注意** Laravel 的 [起始套件](/docs/laravel/10.x/starter-kits) 已经包含了正确的 Tailwind、PostCSS 和 Vite 配置。或者，如果你想在不使用我们的起始套件的情况下使用 Tailwind 和 Laravel，请查看 [Tailwind 的 Laravel 安装指南](https://tailwindcss.com/docs/guides/laravel)。\r\n\r\n<a name=\"working-with-blade-and-routes\"></a>\r\n\r\n## 使用 Blade 和 路由\r\n\r\n<a name=\"blade-processing-static-assets\"></a>\r\n\r\n### 通过 Vite 处理静态资源\r\n\r\n在你的 JavaScript 或 CSS 中引用资源时，Vite 会自动处理和版本化它们。此外，在构建基于 Blade 的应用程序时，Vite 还可以处理和版本化你仅在 Blade 模板中引用的静态资源。\r\n\r\n然而，要实现这一点，你需要通过将静态资源导入到应用程序的入口点来让 Vite 了解你的资源。例如，如果你想处理和版本化存储在 `resources/images` 中的所有图像和存储在 `resources/fonts` 中的所有字体，你应该在应用程序的 `resources/js/app.js` 入口点中添加以下内容：\r\n\r\n```js\r\nimport.meta.glob([\r\n  '../images/**',\r\n  '../fonts/**',\r\n]);\r\n```\r\n\r\n这些资源将在运行 `npm run build` 时由 Vite 处理。然后，你可以在 Blade 模板中使用 `Vite::asset` 方法引用这些资源，该方法将返回给定资源的版本化 URL：\r\n\r\n```blade\r\n<img src=\"{{ Vite::asset('resources/images/logo.png') }}\">\r\n```\r\n\r\n<a name=\"blade-refreshing-on-save\"></a>\r\n### 保存刷新\r\n\r\n当你的应用程序使用传统的服务器端渲染 Blade 构建时，Vite 可以通过在你的应用程序中更改视图文件时自动刷新浏览器来提高你的开发工作流程。要开始，你可以简单地将 `refresh` 选项指定为 `true`。\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            // ...\r\n            refresh: true,\r\n        }),\r\n    ],\r\n});\r\n```\r\n\r\n当 `refresh` 选项为 `true` 时，保存以下目录中的文件将在你运行 `npm run dev` 时触发浏览器进行全面的页面刷新：\r\n\r\n- `app/View/Components/**`\r\n- `lang/**`\r\n- `resources/lang/**`\r\n- `resources/views/**`\r\n- `routes/**`\r\n\r\n监听 `routes/**` 目录对于在应用程序前端中利用 [Ziggy](https://github.com/tighten/ziggy) 生成路由链接非常有用。\r\n\r\n\r\n\r\n如果这些默认路径不符合你的需求，你可以指定自己的路径列表：\r\n\r\n```\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            // ...\r\n            refresh: ['resources/views/**'],\r\n        }),\r\n    ],\r\n});\r\n``` \r\n\r\n在后台，Laravel Vite 插件使用了 [`vite-plugin-full-reload`](https://github.com/ElMassimo/vite-plugin-full-reload) 包，该包提供了一些高级配置选项，可微调此功能的行为。如果你需要这种级别的自定义，可以提供一个 `config` 定义：\r\n\r\n```\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            // ...\r\n            refresh: [{\r\n                paths: ['path/to/watch/**'],\r\n                config: { delay: 300 }\r\n            }],\r\n        }),\r\n    ],\r\n});\r\n``` \r\n\r\n### 别名\r\n\r\n在 JavaScript 应用程序中创建别名来引用常用目录是很常见的。但是，你也可以通过在 `Illuminate\\Support\\Facades\\Vite` 类上使用 `macro` 方法来创建在 Blade 中使用的别名。通常，“宏”应在 [服务提供商](/docs/laravel/10.x/providers) 的 `boot` 方法中定义：\r\n\r\n```\r\n/**\r\n * Bootstrap any application services.\r\n */\r\npublic function boot(): void {\r\n    Vite::macro('image', fn (string $asset) => $this->asset(\"resources/images/{$asset}\"));\r\n}\r\n``` \r\n\r\n定义了宏之后，可以在模板中调用它。例如，我们可以使用上面定义的 `image` 宏来引用位于 `resources/images/logo.png` 的资源：\r\n\r\n```\r\n<img src=\"{{ Vite::image('logo.png') }}\" alt=\"Laravel Logo\">\r\n``` \r\n\r\n### 自定义 base URL\r\n\r\n如果你的 Vite 编译的资产部署到与应用程序不同的域（例如通过 CDN），必须在应用程序的 `.env` 文件中指定 `ASSET_URL` 环境变量：\r\n\r\n```\r\nASSET_URL=https://cdn.example.com\r\n```\r\n\r\n在配置了资源 URL 之后，所有重写的 URL 都将以配置的值为前缀：\r\n\r\n```\r\nhttps://cdn.example.com/build/assets/app.9dce8d17.js\r\n``` \r\n\r\n请记住，[绝对路径的 URL 不会被 Vite 重新编写](/#url-processing)，因此它们不会被添加前缀。\r\n\r\n### 环境变量\r\n\r\n你可以在应用程序的 `.env` 文件中以 `VITE_` 为前缀注入环境变量以在 JavaScript 中使用：\r\n\r\n```\r\nVITE_SENTRY_DSN_PUBLIC=http://example.com\r\n``` \r\n\r\n你可以通过 `import.meta.env` 对象访问注入的环境变量：\r\n\r\n```\r\nimport.meta.env.VITE_SENTRY_DSN_PUBLIC\r\n``` \r\n\r\n### 在测试中禁用 Vite\r\n\r\nLaravel 的 Vite 集成将在运行测试时尝试解析你的资产，这需要你运行 Vite 开发服务器或构建你的资产。\r\n\r\n如果你希望在测试中模拟 Vite，你可以调用 `withoutVite` 方法，该方法对任何扩展 Laravel 的 `TestCase` 类的测试都可用：\r\n\r\n```\r\nuse Tests\\TestCase;\r\n\r\nclass ExampleTest extends TestCase {\r\n    public function test_without_vite_example(): void {\r\n        $this->withoutVite();\r\n\r\n        // ...\r\n    }\r\n}\r\n``` \r\n\r\n如果你想在所有测试中禁用 Vite，可以在基本的 `TestCase` 类上的 `setUp` 方法中调用 `withoutVite` 方法：\r\n\r\n```\r\n<?php\r\n\r\nnamespace Tests;\r\n\r\nuse Illuminate\\Foundation\\Testing\\TestCase as BaseTestCase;\r\n\r\nabstract class TestCase extends BaseTestCase {\r\n    use CreatesApplication;\r\n\r\n    protected function setUp(): void// [tl! add:start] {\r\n        parent::setUp();\r\n\r\n        $this->withoutVite();\r\n    }// [tl! add:end]\r\n}\r\n``` \r\n\r\n### 服务器端渲染\r\n\r\nLaravel Vite 插件可以轻松地设置与 Vite 的服务器端渲染。要开始使用，请在 `resources/js` 中创建一个 SSR（Server-Side Rendering）入口点，并通过将配置选项传递给 Laravel 插件来指定入口点：\r\n\r\n```\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            input: 'resources/js/app.js',\r\n            ssr: 'resources/js/ssr.js',\r\n        }),\r\n    ],\r\n});\r\n```\r\n\r\n为确保不遗漏重建 SSR 入口点，我们建议增加应用程序的 `package.json` 中的 「build」 脚本来创建 SSR 构建：\r\n\r\n```\r\n\"scripts\": {\r\n     \"dev\": \"vite\",\r\n     \"build\": \"vite build\" // [tl! remove]\r\n     \"build\": \"vite build && vite build --ssr\" // [tl! add]\r\n}\r\n``` \r\n\r\n然后，要构建和启动 SSR 服务器，你可以运行以下命令：\r\n\r\n```\r\nnpm run build\r\nnode bootstrap/ssr/ssr.mjs\r\n``` \r\n\r\n> **注意** Laravel 的 [starter kits](/docs/laravel/10.x/starter-kits) 已经包含了适当的 Laravel、Inertia SSR 和 Vite 配置。查看 [Laravel Breeze](/docs/laravel/10.x/starter-kitsmd#breeze-and-inertia) ，以获得使用 Laravel、Inertia SSR 和 Vite 的最快速的方法。\r\n\r\n## Script & Style 标签的属性\r\n\r\n### Content Security Policy (CSP) Nonce\r\n\r\n如果你希望在你的脚本和样式标签中包含 [`nonce` 属性](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce)，作为你的 [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) 的一部分，你可以使用自定义 [middleware](/docs/laravel/10.x/middleware) 中的 `useCspNonce` 方法生成或指定一个 nonce：\r\n\r\nCopy code\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Http\\Middleware;\r\n\r\nuse Closure;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Facades\\Vite;\r\nuse Symfony\\Component\\HttpFoundation\\Response;\r\n\r\nclass AddContentSecurityPolicyHeaders {\r\n    /**\r\n     * Handle an incoming request.\r\n     *\r\n     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n     */\r\n    public function handle(Request $request, Closure $next, string $role): Response {\r\n        Vite::useCspNonce();\r\n\r\n        return $next($request)->withHeaders([\r\n            'Content-Security-Policy' => \"script-src 'nonce-\".Vite::cspNonce().\"'\",\r\n        ]);\r\n    }\r\n}\r\n``` \r\n\r\n调用了 `useCspNonce` 方法后，Laravel 将自动在所有生成的脚本和样式标签上包含 `nonce` 属性。\r\n\r\n如果你需要在其他地方指定 nonce，包括 Laravel 的 starter kits 中带有的 [Ziggy `@route` directive](https://github.com/tighten/ziggy#using-routes-with-a-content-security-policy) 指令，你可以使用 `cspNonce` 方法来检索它：\r\n\r\n```\r\n@routes(nonce: Vite::cspNonce())\r\n```\r\n如果你已经有了一个 nonce，想要告诉 Laravel 使用它，你可以通过将 nonce 传递给 `useCspNonce` 方法来实现：\r\n\r\n```\r\nVite::useCspNonce($nonce);\r\n```\r\n<a name=\"subresource-integrity-sri\"></a>\r\n###子资源完整性 (SRI)\r\n如果你的 `Vite manifest` 中包括资源的完整性哈希，则 Laravel 将自动向其生成的任何脚本和样式标签中添加 `integrity` 属性，以执行 子资源完整性。默认情况下，Vite 不包括其清单中的 `integrity` 哈希，但是你可以通过安装 `vite-plugin-manifest-sri` NPM 插件来启用它：\r\n\r\n```shell\r\nnpm install --save-dev vite-plugin-manifest-sri\r\n```\r\n然后，在你的 `vite.config.js` 文件中启用此插件：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\nimport manifestSRI from 'vite-plugin-manifest-sri';// [tl! add]\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            // ...\r\n        }),\r\n        manifestSRI(),// [tl! add]\r\n    ],\r\n});\r\n```\r\n如果需要，你也可以自定义清单中的完整性哈希键：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Vite;\r\n\r\nVite::useIntegrityKey('custom-integrity-key');\r\n```\r\n\r\n如果你想完全禁用这个自动检测，你可以将 `false` 传递给 `useIntegrityKey` 方法：\r\n\r\n```\r\nVite::useIntegrityKey(false);\r\n```\r\n<a name=\"arbitrary-attributes\"></a>\r\n### 任意属性\r\n如果你需要在脚本和样式标签中包含其他属性，例如 `data-turbo-track` 属性，你可以通过 `useScriptTagAttributes` 和 `useStyleTagAttributes` 方法指定它们。通常，这些方法应从一个服务提供程序中调用：\r\n\r\n```\r\nuse Illuminate\\Support\\Facades\\Vite;\r\n\r\nVite::useScriptTagAttributes([\r\n    'data-turbo-track' => 'reload', // 为属性指定一个值...\r\n    'async' => true, // 在不使用值的情况下指定属性...\r\n    'integrity' => false, // 排除一个将被包含的属性...\r\n]);\r\n\r\nVite::useStyleTagAttributes([\r\n    'data-turbo-track' => 'reload',\r\n]);\r\n```\r\n\r\n如果你需要有条件地添加属性，你可以传递一个回调函数，它将接收到资产源路径、它的URL、它的清单块和整个清单：\r\n\r\n```\r\nuse Illuminate\\Support\\Facades\\Vite;\r\n\r\nVite::useScriptTagAttributes(fn (string $src, string $url, array|null $chunk, array|null $manifest) => [\r\n    'data-turbo-track' => $src === 'resources/js/app.js' ? 'reload' : false,\r\n]);\r\n\r\nVite::useStyleTagAttributes(fn (string $src, string $url, array|null $chunk, array|null $manifest) => [\r\n    'data-turbo-track' => $chunk && $chunk['isEntry'] ? 'reload' : false,\r\n]);\r\n``` \r\n\r\n> **警告**\r\n> 在 Vite 开发服务器运行时，`$chunk` 和 `$manifest` 参数将为 `null`。\r\n\r\n<a name=\"advanced-customization\"></a>\r\n\r\n## 高级定制\r\n\r\n默认情况下，Laravel 的 Vite 插件使用合理的约定，适用于大多数应用，但是有时你可能需要自定义 Vite 的行为。为了启用额外的自定义选项，我们提供了以下方法和选项，可以用于替代 `@vite` Blade 指令：\r\n\r\n```\r\n<!doctype html>\r\n<head>\r\n    {{-- ... --}}\r\n\r\n    {{\r\n        Vite::useHotFile(storage_path('vite.hot')) // 自定义 \"hot\" 文件...\r\n            ->useBuildDirectory('bundle') // 自定义构建目录...\r\n            ->useManifestFilename('assets.json') // 自定义清单文件名...\r\n            ->withEntryPoints(['resources/js/app.js']) // 指定入口点...\r\n    }}\r\n</head>\r\n``` \r\n\r\n然后，在 `vite.config.js` 文件中，你应该指定相同的配置：\r\n\r\n```\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            hotFile: 'storage/vite.hot', // 自定义 \"hot\" 文件...\r\n            buildDirectory: 'bundle', // 自定义构建目录...\r\n            input: ['resources/js/app.js'], // 指定入口点...\r\n        }),\r\n    ],\r\n    build: {\r\n      manifest: 'assets.json', // 自定义清单文件名...\r\n    },\r\n});\r\n``` \r\n\r\n<a name=\"correcting-dev-server-urls\"></a>\r\n\r\n### 修正开发服务器 URL\r\n\r\nVite 生态系统中的某些插件默认假设以正斜杠开头的 URL 始终指向 Vite 开发服务器。然而，由于 Laravel 集成的性质，实际情况并非如此。\r\n\r\n例如，`vite-imagetools` 插件在 Vite 服务时，你的资产时会输出以下类似的 URL：\r\n\r\n```\r\n<img src=\"/@imagetools/f0b2f404b13f052c604e632f2fb60381bf61a520\">\r\n``` \r\n\r\n`vite-imagetools` 插件期望输出URL将被 Vite 拦截，并且插件可以处理所有以 `/@imagetools` 开头的 URL。如果你正在使用期望此行为的插件，则需要手动纠正 URL。你可以在 `vite.config.js` 文件中使用 `transformOnServe` 选项来实现。\r\n\r\n在这个例子中，我们将在生成的代码中的所有 `/@imagetools` 钱加上开发服务器的 URL：\r\n\r\n```\r\nimport { defineConfig } from 'vite';\r\nimport laravel from 'laravel-vite-plugin';\r\nimport { imagetools } from 'vite-imagetools';\r\n\r\nexport default defineConfig({\r\n    plugins: [\r\n        laravel({\r\n            // ...\r\n            transformOnServe: (code, devServerUrl) => code.replaceAll('/@imagetools', devServerUrl+'/@imagetools'),\r\n        }),\r\n        imagetools(),\r\n    ],\r\n});\r\n``` \r\n\r\n现在，在 Vite 提供资产服务时，它会输出URL指向 Vite 开发服务器：\r\n\r\n```\r\n- <img src=\"/@imagetools/f0b2f404b13f052c604e632f2fb60381bf61a520\"><!-- [tl! remove] -->\r\n+ <img src=\"http://[::1]:5173/@imagetools/f0b2f404b13f052c604e632f2fb60381bf61a520\"><!-- [tl! add] -->\r\n```\r\n","p":"docs/vite.html"},{"t":"urls (生成 URL)","d":"\n# 生成 URL\r\n\r\n- [简介](#introduction)\r\n- [基础](#the-basics)\r\n    - [生成基础 URLs](#generating-urls)\r\n    - [访问当前 URL](#accessing-the-current-url)\r\n- [命名路由的 URLs](#urls-for-named-routes)\r\n    - [签名 URLs](#signed-urls)\r\n- [控制器行为的 URLs](#urls-for-controller-actions)\r\n- [默认值](#default-values)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 提供了几个辅助函数来为应用程序生成 URL。主要用于在模板和 API 响应中构建 URL 或者在应用程序的其它部分生成重定向响应。\r\n\r\n<a name=\"the-basics\"></a>\r\n## 基础\r\n\r\n<a name=\"generating-urls\"></a>\r\n### 生成基础 URLs\r\n\r\n辅助函数 `url` 可以用于应用的任何一个 URL。生成的 URL 将自动使用当前请求中的方案 (HTTP 或 HTTPS) 和主机：\r\n\r\n    $post = App\\Models\\Post::find(1);\r\n\r\n    echo url(\"/posts/{$post->id}\");\r\n\r\n    // http://example.com/posts/1\r\n\r\n<a name=\"accessing-the-current-url\"></a>\r\n### 访问当前 URL\r\n\r\n如果没有给辅助函数 `url` 提供路径，则会返回一个 `Illuminate\\Routing\\UrlGenerator` 实例，来允许你访问有关当前 URL 的信息：\r\n\r\n    // 获取当前 URL 没有 query string...\r\n    echo url()->current();\r\n\r\n    // 获取当前 URL 包括 query string...\r\n    echo url()->full();\r\n\r\n    // 获取上个请求 URL\r\n    echo url()->previous();\r\n\r\n上面的这些方法都可以通过 `URL` [facade](/docs/laravel/10.x/facades) 访问:\r\n\r\n    use Illuminate\\Support\\Facades\\URL;\r\n\r\n    echo URL::current();\r\n\r\n<a name=\"urls-for-named-routes\"></a>\r\n## 命名路由的 URLs\r\n\r\n辅助函数 `route` 可以用于生成指定 [命名路由](/docs/laravel/10.x/routing#named-routes) 的URLs。 命名路由生成的 URLs 不与路由上定义的 URL 相耦合。因此，就算路由的 URL 有任何改变，都不需要对 `route` 函数调用进行任何更改。例如，假设你的应用程序包含以下路由：\r\n\r\n    Route::get('/post/{post}', function (Post $post) {\r\n        // ...\r\n    })->name('post.show');\r\n\r\n\n\n要生成此路由的 URL ，可以像这样使用辅助函数 `route` ：\r\n\r\n    echo route('post.show', ['post' => 1]);\r\n\r\n    // http://example.com/post/1\r\n\r\n当然，辅助函数 `route` 也可以用于为具有多个参数的路由生成 URL：\r\n\r\n    Route::get('/post/{post}/comment/{comment}', function (Post $post, Comment $comment) {\r\n        // ...\r\n    })->name('comment.show');\r\n\r\n    echo route('comment.show', ['post' => 1, 'comment' => 3]);\r\n\r\n    // http://example.com/post/1/comment/3\r\n\r\n任何与路由定义参数对应不上的附加数组元素都将添加到 URL 的查询字符串中：\r\n\r\n    echo route('post.show', ['post' => 1, 'search' => 'rocket']);\r\n\r\n    // http://example.com/post/1?search=rocket\r\n\r\n<a name=\"eloquent-models\"></a>\r\n#### Eloquent Models\r\n\r\n你通常使用 [Eloquent 模型](/docs/laravel/10.x/eloquent) 的主键生成 URL。因此，您可以将 Eloquent 模型作为参数值传递。 `route` 辅助函数将自动提取模型的主键：\r\n\r\n    echo route('post.show', ['post' => $post]);\r\n\r\n<a name=\"signed-urls\"></a>\r\n### 签名 URLs\r\n\r\nLaravel 允许你轻松地为命名路径创建「签名」 URLs，这些 URLs 在查询字符串后附加了「签名」哈希，允许 Laravel 验证 URL 自创建以来未被修改过。 签名 URLs 对于可公开访问但需要一层防止 URL 操作的路由特别有用。\r\n\r\n例如，你可以使用签名 URLs 来实现通过电子邮件发送给客户的公共「取消订阅」链接。要创建指向路径的签名 URL ，请使用  `URL` facade 的 `signedRoute` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\URL;\r\n\r\n    return URL::signedRoute('unsubscribe', ['user' => 1]);\r\n\r\n\n\n如果要生成具有有效期的临时签名路由 URL，可以使用以下 `temporarySignedRoute` 方法，当 Laravel 验证一个临时的签名路由 URL 时，它会确保编码到签名 URL 中的过期时间戳没有过期：\r\n\r\n    use Illuminate\\Support\\Facades\\URL;\r\n\r\n    return URL::temporarySignedRoute(\r\n        'unsubscribe', now()->addMinutes(30), ['user' => 1]\r\n    );\r\n\r\n<a name=\"validating-signed-route-requests\"></a>\r\n#### 验证签名路由请求\r\n\r\n要验证传入请求是否具有有效签名，你应该对传入的 `Illuminate\\Http\\Request` 实例中调用 `hasValidSignature` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/unsubscribe/{user}', function (Request $request) {\r\n        if (! $request->hasValidSignature()) {\r\n            abort(401);\r\n        }\r\n\r\n        // ...\r\n    })->name('unsubscribe');\r\n\r\n有时，你可能需要允许你的应用程序前端将数据附加到签名 URL，例如在执行客户端分页时。因此，你可以指定在使用 `hasValidSignatureWhileIgnoring` 方法验证签名 URL 时应忽略的请求查询参数。请记住，忽略参数将允许任何人根据请求修改这些参数：\r\n\r\n    if (! $request->hasValidSignatureWhileIgnoring(['page', 'order'])) {\r\n        abort(401);\r\n    }\r\n\r\n或者，你可以将 `Illuminate\\Routing\\Middleware\\ValidateSignature` [中间件](/docs/laravel/10.x/middleware) 分配给路由。如果它不存在，则应该在 HTTP 内核的 `$middlewareAliases` 数组中为此中间件分配一个键：\r\n\r\n    /**\r\n     * The application's middleware aliases.\r\n     *\r\n     * Aliases may be used to conveniently assign middleware to routes and groups.\r\n     *\r\n     * @var array<string, class-string|string>\r\n     */\r\n    protected $middlewareAliases = [\r\n        'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,\r\n    ];\r\n\r\n一旦在内核中注册了中间件，就可以将其附加到路由。如果传入的请求没有有效的签名，中间件将自动返回 `403` HTTP 响应：\r\n\r\n    Route::post('/unsubscribe/{user}', function (Request $request) {\r\n        // ...\r\n    })->name('unsubscribe')->middleware('signed');\r\n\r\n\n\n<a name=\"responding-to-invalid-signed-routes\"></a>\r\n#### 响应无效的签名路由\r\n\r\n当有人访问已过期的签名 URL 时，他们将收到一个通用的错误页面，显示 `403` HTTP 状态代码。然而，你可以通过在异常处理程序中为 `InvalidSignatureException` 异常定义自定义 “可渲染” 闭包来自定义此行为。这个闭包应该返回一个 HTTP 响应：\r\n\r\n    use Illuminate\\Routing\\Exceptions\\InvalidSignatureException;\r\n\r\n    /**\r\n     * 为应用程序注册异常处理回调\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->renderable(function (InvalidSignatureException $e) {\r\n            return response()->view('error.link-expired', [], 403);\r\n        });\r\n    }\r\n\r\n<a name=\"urls-for-controller-actions\"></a>\r\n## 控制器行为的 URL\r\n\r\n`action` 功能可以为给定的控制器行为生成 URL。\r\n\r\n    use App\\Http\\Controllers\\HomeController;\r\n\r\n    $url = action([HomeController::class, 'index']);\r\n\r\n如果控制器方法接收路由参数，你可以通过第二个参数传递：\r\n\r\n    $url = action([UserController::class, 'profile'], ['id' => 1]);\r\n\r\n<a name=\"default-values\"></a>\r\n## 默认值\r\n\r\n对于某些应用程序，你可能希望为某些 URL 参数的请求范围指定默认值。例如，假设有些路由定义了 `{locale}` 参数：\r\n\r\n    Route::get('/{locale}/posts', function () {\r\n        // ...\r\n    })->name('post.index');\r\n\r\n每次都通过 `locale` 来调用辅助函数 `route` 也是一件很麻烦的事情。因此，使用 `URL::defaults` 方法定义这个参数的默认值，可以让该参数始终存在当前请求中。然后就能从 [路由中间件](/docs/laravel/10.x/middleware#assigning-middleware-to-routes) 调用此方法来访问当前请求：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\URL;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class SetDefaultLocaleForUrls\r\n    {\r\n        /**\r\n         * 处理传入的请求\r\n         *\r\n         * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n         */\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            URL::defaults(['locale' => $request->user()->locale]);\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n\n\n一旦设置了 `locale` 参数的默认值，你就不再需要通过辅助函数 `route` 生成 URL 时传递它的值。\r\n\r\n<a name=\"url-defaults-middleware-priority\"></a>\r\n#### 默认 URL & 中间件优先级\r\n\r\n设置 URL 的默认值会影响 Laravel 对隐式模型绑定的处理。因此，你应该通过[设置中间件优先级](/docs/laravel/10.x/middleware#sorting-middleware)来确保在 Laravel 自己的 `SubstituteBindings` 中间件执行之前设置 URL 的默认值。你可以通过在你的应用的 HTTP kernel 文件中的 `$middlewarePriority` 属性里把你的中间件放在 `SubstituteBindings` 中间件之前。\r\n\r\n`$middlewarePriority` 这个属性在 `Illuminate\\Foundation\\Http\\Kernel` 这个基类里。你可以复制一份到你的应用程序的 HTTP kernel 文件中以便做修改:\r\n\r\n    /**\r\n     * 根据优先级排序的中间件列表\r\n     *\r\n     * 这将保证非全局中间件按照既定顺序排序\r\n     *\r\n     * @var array\r\n     */\r\n    protected $middlewarePriority = [\r\n        // ...\r\n         \\App\\Http\\Middleware\\SetDefaultLocaleForUrls::class,\r\n         \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n         // ...\r\n    ];\r\n\n","p":"docs/urls.html"},{"t":"session (HTTP 会话机制)","d":"\n# HTTP 会话机制\r\n\r\n- [简介](#introduction)\r\n    - [配置](#configuration)\r\n    - [驱动程序先决条件](#driver-prerequisites)\r\n- [使用 Session](#interacting-with-the-session)\r\n    - [获取数据](#retrieving-data)\r\n    - [存储数据](#storing-data)\r\n    - [闪存数据](#flash-data)\r\n    - [删除数据](#deleting-data)\r\n    - [重新生成 Session ID](#regenerating-the-session-id)\r\n- [Session Blocking](#session-blocking)\r\n- [添加自定义 Session 驱动](#adding-custom-session-drivers)\r\n    - [实现驱动](#implementing-the-driver)\r\n    - [注册驱动](#registering-the-driver)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n由于 HTTP 驱动的应用程序是无状态的，Session 提供了一种在多个请求之间存储有关用户信息的方法，这类信息一般都存储在后续请求可以访问的持久存储 / 后端中。\r\n\r\nLaravel 通过同一个可读性强的 API 处理各种自带的后台驱动程序。支持诸如比较热门的[Memcached](https://memcached.org)、 [Redis](https://redis.io)和数据库。\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\nSession 的配置文件存储在`config/session.php`文件中。请务必查看此文件中对于你而言可用的选项。默认情况下，Laravel 为绝大多数应用程序配置的 Session 驱动为`file` 驱动，它适用于大多数程序。如果你的应用程序需要在多个 Web 服务器之间进行负载平衡，你应该选择一个所有服务器都可以访问的集中式存储，例如 Redis 或数据库。\r\n\r\nSession`driver`的配置预设了每个请求存储 Session 数据的位置。Laravel 自带了几个不错而且开箱即用的驱动：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `file` - Sessions 存储在`storage/framework/sessions`。\r\n- `cookie` - Sessions 被存储在安全加密的 cookie 中。\r\n- `database` - Sessions 被存储在关系型数据库中。\r\n- `memcached` / `redis` - Sessions 被存储在基于高速缓存的存储系统中。\r\n- `dynamodb` - Sessions 被存储在 AWS DynamoDB 中。\r\n- `array` - Sessions 存储在 PHP 数组中，但不会被持久化。\r\n\r\n</div>\r\n\r\n> **技巧**  \r\n> 数组驱动一般用于[测试](/docs/laravel/10.x/testing)并且防止存储在 Session 中的数据被持久化。\r\n\r\n\n\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动先决条件\r\n\r\n<a name=\"database\"></a>\r\n#### 数据库\r\n\r\n使用`database`Session 驱动时，你需要创建一个记录 Session 的表。下面是`Schema`的声明示例：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::create('sessions', function (Blueprint $table) {\r\n        $table->string('id')->primary();\r\n        $table->foreignId('user_id')->nullable()->index();\r\n        $table->string('ip_address', 45)->nullable();\r\n        $table->text('user_agent')->nullable();\r\n        $table->text('payload');\r\n        $table->integer('last_activity')->index();\r\n    });\r\n\r\n你可以使用 Artisan 命令`session:table`生成这个迁移。了解更多数据库迁移，请查看完整的文档[迁移文档](/docs/laravel/10.x/migrations):\r\n\r\n```shell\r\nphp artisan session:table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"redis\"></a>\r\n#### Redis\r\n\r\n在 Laravel 使用 Redis Session 驱动前，你需要安装 PhpRedis PHP 扩展，可以通过 PECL 或者 通过 Composer 安装这个`predis/predis`包 (~1.0)。更多关于 Redis 配置信息，查询 Laravel 的 [Redis 文档](/docs/laravel/10.x/redis#configuration).\r\n\r\n> **技巧**  \r\n> 在`session`配置文件里，`connection`选项可以用来设置 Session 使用 Redis 连接方式。\r\n\r\n<a name=\"interacting-with-the-session\"></a>\r\n## 使用 Session\r\n\r\n<a name=\"retrieving-data\"></a>\r\n### 获取数据\r\n\r\n在 Laravel 中有两种基本的 Session 使用方式：全局`session`助手函数和通过`Request`实例。首先看下通过`Request`实例访问 Session , 它可以隐式绑定路由闭包或者控制器方法。记住，Laravel 会自动注入控制器方法的依赖。[服务容器](/docs/laravel/10.x/container)：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示指定用户个人资料。\r\n         */\r\n        public function show(Request $request, string $id): View\r\n        {\r\n            $value = $request->session()->get('key');\r\n\r\n            // ...\r\n\r\n            $user = $this->users->find($id);\r\n\r\n            return view('user.profile', ['user' => $user]);\r\n        }\r\n    }\r\n\r\n\n\n当你从 Session 获取数据时，你也可以在`get`方法第二个参数里传递一个 default 默认值，如果 Session 里不存在键值对 key 的数据结果，这个默认值就会返回。如果你传递给`get`方法一个闭包作为默认值，这个闭包会被执行并且返回结果：\r\n\r\n    $value = $request->session()->get('key', 'default');\r\n\r\n    $value = $request->session()->get('key', function () {\r\n        return 'default';\r\n    });\r\n\r\n<a name=\"the-global-session-helper\"></a>\r\n#### 全局 Session 助手函数\r\n\r\n你也可以在 Session 里使用 PHP 全局`session`函数获取和储存数据。当这个`session`函数以一个单独的字符串形式被调用时，它将会返回这个 Session 键值对的结果。当函数以 key / value 数组形式被调用时，这些值会被存储在 Session 里：\r\n\r\n    Route::get('/home', function () {\r\n        // 从 Session 获取数据 ...\r\n        $value = session('key');\r\n\r\n        // 设置默认值...\r\n        $value = session('key', 'default');\r\n\r\n        // 在Session 里存储一段数据 ...\r\n        session(['key' => 'value']);\r\n    });\r\n\r\n> **技巧**  \r\n> 通过 HTTP 请求实例与通过`session`助手函数方式使用 Session 之间没有实际区别。两种方式都是[可的测试](/docs/laravel/10.x/testing)，你所有的测试用例中都可以通过 `assertSessionHas`方法进行断言。\r\n\r\n<a name=\"retrieving-all-session-data\"></a>\r\n#### 获取所有 Session 数据\r\n\r\n如果你想要从 Session 里获取所有数据，你可以使用`all`方法：\r\n\r\n    $data = $request->session()->all();\r\n\r\n\n\n<a name=\"determining-if-an-item-exists-in-the-session\"></a>\r\n#### 判断 Session 里是否存在条目\r\n\r\n判断 Session 里是否存在一个条目，你可以使用`has`方法。如果条目存在`has`，方法返回`true`不存在则返回`null`：\r\n\r\n    if ($request->session()->has('users')) {\r\n        // ...\r\n    }\r\n\r\n判断 Session 里是否存在一个即使结果值为`null`的条目，你可以使用`exists`方法：\r\n\r\n    if ($request->session()->exists('users')) {\r\n        // ...\r\n    }\r\n\r\n要确定某个条目是否在会话中不存在，你可以使用 `missing`方法。如果条目不存在，`missing`方法返回`true`：\r\n\r\n    if ($request->session()->missing('users')) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"storing-data\"></a>\r\n### 存储数据\r\n\r\nSession 里存储数据，你通常将使用 Request 实例中的`put`方法或者`session`助手函数：\r\n\r\n    // 通过 Request 实例存储 ...\r\n    $request->session()->put('key', 'value');\r\n\r\n    // 通过全局 Session 助手函数存储 ...\r\n    session(['key' => 'value']);\r\n\r\n<a name=\"pushing-to-array-session-values\"></a>\r\n#### Session 存储数组\r\n\r\n`push`方法可以把一个新值推入到以数组形式存储的 session 值里。例如：如果`user.teams`键值对有一个关于团队名字的数组，你可以推入一个新值到这个数组里：\r\n\r\n    $request->session()->push('user.teams', 'developers');\r\n\r\n<a name=\"retrieving-deleting-an-item\"></a>\r\n#### 获取 & 删除条目\r\n\r\n`pull`方法会从 Session 里获取并且删除一个条目，只需要一步如下：\r\n\r\n    $value = $request->session()->pull('key', 'default');\r\n\r\n<a name=\"#incrementing-and-decrementing-session-values\"></a>\r\n#### 递增 / 递减会话值\r\n\r\n\n\n如果你的 Session 数据里有整形你希望进行加减操作，可以使用`increment`和`decrement`方法：\r\n\r\n    $request->session()->increment('count');\r\n\r\n    $request->session()->increment('count', $incrementBy = 2);\r\n\r\n    $request->session()->decrement('count');\r\n\r\n    $request->session()->decrement('count', $decrementBy = 2);\r\n\r\n<a name=\"flash-data\"></a>\r\n### 闪存数据\r\n\r\n有时你可能想在 Session 里为下次请求存储一些条目。你可以使用`flash`方法。使用这个方法，存储在 Session 的数据将立即可用并且会保留到下一个 HTTP 请求期间，之后会被删除。闪存数据主要用于短期的状态消息：\r\n\r\n    $request->session()->flash('status', 'Task was successful!');\r\n\r\n如果你需要为多次请求持久化闪存数据，可以使用`reflash`方法，它会为一个额外的请求保持住所有的闪存数据，如果你仅需要保持特定的闪存数据，可以使用`keep`方法：\r\n\r\n    $request->session()->reflash();\r\n\r\n    $request->session()->keep(['username', 'email']);\r\n\r\n如果你仅为了当前的请求持久化闪存数据，可以使用`now` 方法：\r\n\r\n    $request->session()->now('status', 'Task was successful!');\r\n\r\n<a name=\"deleting-data\"></a>\r\n### 删除数据\r\n\r\n`forget`方法会从 Session 删除一些数据。如果你想删除所有 Session 数据，可以使用`flush`方法：\r\n\r\n    // 删除一个单独的键值对 ...\r\n    $request->session()->forget('name');\r\n\r\n    // 删除多个 键值对 ...\r\n    $request->session()->forget(['name', 'status']);\r\n\r\n    $request->session()->flush();\r\n\r\n\n\n<a name=\"regenerating-the-session-id\"></a>\r\n### 重新生成 Session ID\r\n\r\n重新生成 Session ID 经常被用来阻止恶意用户使用 [session fixation](https://owasp.org/www-community/attacks/Session_fixation) 攻击你的应用。\r\n\r\n如果你正在使用[入门套件](/docs/laravel/10.x/starter-kits)或 [Laravel Fortify](/docs/laravel/10.x/fortify)中的任意一种， Laravel 会在认证阶段自动生成 Session ID；然而如果你需要手动重新生成 Session ID ，可以使用`regenerate`方法：\r\n\r\n    $request->session()->regenerate();\r\n\r\n如果你需要重新生成 Session ID 并同时删除所有 Session 里的数据，可以使用`invalidate`方法：\r\n\r\n    $request->session()->invalidate();\r\n\r\n<a name=\"session-blocking\"></a>\r\n## Session 阻塞\r\n\r\n> **注意**  \r\n> 应用 Session 阻塞功能，你的应用必须使用一个支持[原子锁 ](/docs/laravel/10.x/cache#atomic-locks)的缓存驱动。目前，可用的缓存驱动有`memcached`、 `dynamodb`、 `redis`和`database`等。另外，你可能不会使用`cookie` Session 驱动。\r\n\r\n默认情况下，Laravel 允许使用同一 Session 的请求并发地执行，举例来说，如果你使用一个 JavaScript HTTP 库向你的应用执行两次 HTTP 请求，它们将同时执行。对多数应用这不是问题，然而 在一小部分应用中可能出现 Session 数据丢失，这些应用会向两个不同的应用端并发请求，并同时写入数据到 Session。\r\n\r\n为了解决这个问题，Laravel 允许你限制指定 Session 的并发请求。首先，你可以在路由定义时使用`block`链式方法。在这个示例中，一个到`/profile`的路由请求会拿到一把 Session 锁。当它处在锁定状态时，任何使用相同 Session ID 的到`/profile`或`/order`的路由请求都必须等待，直到第一个请求处理完成后再继续执行：\r\n\r\n    Route::post('/profile', function () {\r\n        // ...\r\n    })->block($lockSeconds = 10, $waitSeconds = 10)\r\n\r\n    Route::post('/order', function () {\r\n        // ...\r\n    })->block($lockSeconds = 10, $waitSeconds = 10)\r\n\r\n\n\n`block`方法接受两个可选参数。`block`方法接受的第一个参数是 Session 锁释放前应该持有的最大秒数。当然，如果请求在此时间之前完成执行，锁将提前释放。\r\n\r\n`block`方法接受的第二个参数是请求在试图获得 Session 锁时应该等待的秒数。如果请求在给定的秒数内无法获得会话锁，将抛出`Illuminate\\Contracts\\Cache\\LockTimeoutException`异常。\r\n\r\n如果不传参，那么 Session 锁默认锁定最大时间是 10 秒，请求锁最大的等待时间也是 10 秒：\r\n\r\n    Route::post('/profile', function () {\r\n        // ...\r\n    })->block()\r\n\r\n<a name=\"adding-custom-session-drivers\"></a>\r\n## 添加自定义 Session 驱动\r\n\r\n<a name=\"implementing-the-driver\"></a>\r\n#### 实现驱动\r\n\r\n如果现存的 Session 驱动不能满足你的需求，Laravel 允许你自定义 Session Handler。你的自定义驱动应实现 PHP 内置的`SessionHandlerInterface`。这个接口仅包含几个方法。以下是 MongoDB 驱动实现的代码片段：\r\n\r\n    <?php\r\n\r\n    namespace App\\Extensions;\r\n\r\n    class MongoSessionHandler implements \\SessionHandlerInterface\r\n    {\r\n        public function open($savePath, $sessionName) {}\r\n        public function close() {}\r\n        public function read($sessionId) {}\r\n        public function write($sessionId, $data) {}\r\n        public function destroy($sessionId) {}\r\n        public function gc($lifetime) {}\r\n    }\r\n\r\n> **技巧**  \r\n> Laravel 没有内置存放扩展的目录，你可以放置在任意目录下，这个示例里，我们创建了一个`Extensions`目录存放`MongoSessionHandler`。\r\n\r\n\n\n由于这些方法的含义并非通俗易懂，因此我们快速浏览下每个方法：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `open`方法通常用于基于文件的 Session 存储系统。因为 Laravel 附带了一个`file`  Session 驱动。你无须在里面写任何代码。可以简单地忽略掉。\r\n- `close`方法跟`open`方法很像，通常也可以忽略掉。对大多数驱动来说，它不是必须的。\r\n- `read` 方法应返回与给定的`$sessionId`关联的 Session 数据的字符串格式。在你的驱动中获取或存储 Session 数据时，无须作任何序列化和编码的操作，Laravel 会自动为你执行序列化。\r\n- `write`方法将与`$sessionId`关联的给定的`$data`字符串写入到一些持久化存储系统，如 MongoDB 或者其他你选择的存储系统。再次，你无须进行任何序列化操作，Laravel 会自动为你处理。\r\n- `destroy`方法应可以从持久化存储中删除与`$sessionId`相关联的数据。\r\n- `gc`方法应可以销毁给定的`$lifetime`（UNIX 时间戳格式 ）之前的所有 Session 数据。对于像 Memcached 和 Redis 这类拥有过期机制的系统来说，本方法可以置空。\r\n\r\n</div>\r\n\r\n<a name=\"registering-the-driver\"></a>\r\n#### 注册驱动\r\n\r\n一旦你的驱动实现了，需要注册到 Laravel 。在 Laravel 中添加额外的驱动到 Session 后端 ，你可以使用`Session` [Facade](/docs/laravel/10.x/facades) 提供的`extend`方法。你应该在[服务提供者](/docs/laravel/10.x/providers)中的`boot`方法中调用`extend`方法。可以通过已有的`App\\Providers\\AppServiceProvider`或创建一个全新的服务提供者执行此操作：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Extensions\\MongoSessionHandler;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n    use Illuminate\\Support\\Facades\\Session;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class SessionServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用服务。\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 启动任意应用服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Session::extend('mongo', function (Application $app) {\r\n                // 返回一个 SessionHandlerInterface 接口的实现 ...\r\n                return new MongoSessionHandler;\r\n            });\r\n        }\r\n    }\r\n\r\n\n\n一旦 Session 驱动注册完成，就可以在`config/session.php`配置文件选择使用`mongo` 驱动。\r\n\n","p":"docs/session.html"},{"t":"validation (表单验证)","d":"# 表单验证\r\n\r\n- [简介](#introduction)\r\n- [快速开始](#validation-quickstart)\r\n    - [定义路由](#quick-defining-the-routes)\r\n    - [创建控制器](#quick-creating-the-controller)\r\n    - [编写验证逻辑](#quick-writing-the-validation-logic)\r\n    - [显示验证错误信息](#quick-displaying-the-validation-errors)\r\n    - [回填表单](#repopulating-forms)\r\n    - [可选字段的注意事项](#a-note-on-optional-fields)\r\n    - [验证错误响应的格式化](#validation-error-response-format)\r\n- [表单请求验证](#form-request-validation)\r\n    - [创建表单请求类](#creating-form-requests)\r\n    - [表单请求授权验证](#authorizing-form-requests)\r\n    - [自定义错误消息](#customizing-the-error-messages)\r\n    - [表单输入预处理](#preparing-input-for-validation)\r\n- [手动创建验证器](#manually-creating-validators)\r\n    - [自动重定向](#automatic-redirection)\r\n    - [命名错误包](#named-error-bags)\r\n    - [自定义错误消息](#manual-customizing-the-error-messages)\r\n    - [验证后的钩子](#after-validation-hook)\r\n- [使用验证后的表单输入](#working-with-validated-input)\r\n- [使用验证错误信息](#working-with-error-messages)\r\n    - [在本地化文件中指定自定义消息](#specifying-custom-messages-in-language-files)\r\n    - [在本地化文件中指定属性](#specifying-attribute-in-language-files)\r\n    - [在本地化文件中指定值](#specifying-values-in-language-files)\r\n- [可用的验证规则](#available-validation-rules)\r\n- [按条件添加验证规则](#conditionally-adding-rules)\r\n- [验证数组](#validating-arrays)\r\n    - [验证多维数组](#validating-nested-array-input)\r\n    - [错误消息的索引和定位](#error-message-indexes-and-positions)\r\n- [验证文件](#validating-files)\r\n- [验证密码](#validating-passwords)\r\n- [自定义验证规则](#custom-validation-rules)\r\n    - [使用 Rule 对象](#using-rule-objects)\r\n    - [使用闭包函数](#using-closures)\r\n    - [隐式规则](#implicit-rules)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 提供了几种不同的方法来验证传入应用程序的数据。最常见的做法是在所有传入的 HTTP 请求中使用 `validate` 方法。同时，我们还将讨论其他验证方法。\r\n\r\nLaravel 包含了各种方便的验证规则，你可以将它们应用于数据，甚至可以验证给定数据库表中的值是否唯一。我们将详细介绍每个验证规则，以便你熟悉 Laravel 的所有验证功能。\r\n\r\n<a name=\"validation-quickstart\"></a>\r\n## 快速开始\r\n\r\n为了了解 Laravel 强大的验证功能，我们来看一个表单验证并将错误消息展示给用户的完整示例。通过阅读概述，这将会对你如何使用 Laravel 验证传入的请求数据有一个很好的理解：\r\n\r\n<a name=\"quick-defining-the-routes\"></a>\r\n### 定义路由\r\n\r\n首先，假设我们在 `routes/web.php` 路由文件中定义了下面这些路由：\r\n\r\n```\r\nuse App\\Http\\Controllers\\PostController; \r\nRoute::get('/post/create', [PostController::class, 'create']);\r\nRoute::post('/post', [PostController::class, 'store']);\r\n```\r\n\r\n`GET` 路由会显示一个供用户创建新博客文章的表单，而 `POST` 路由会将新的博客文章存储到数据库中。\r\n\r\n<a name=\"quick-creating-the-controller\"></a>\r\n### 创建控制器\r\n接下来，让我们一起来看看处理这些路由的简单控制器。我们暂时留空了 store 方法：\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n \r\nuse App\\Http\\Controllers\\Controller;\r\nuse Illuminate\\Http\\RedirectResponse;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\View\\View;\r\n \r\nclass PostController extends Controller\r\n{\r\n    /**\r\n     * 博客的表单视图\r\n     */\r\n    public function create(): View\r\n    {\r\n        return view('post.create');\r\n    }\r\n \r\n    /**\r\n     * 存储博客的 Action\r\n     */\r\n    public function store(Request $request): RedirectResponse\r\n    {\r\n        // 验证并且执行存储逻辑\r\n \r\n        $post = /** ... */\r\n \r\n        return to_route('post.show', ['post' => $post->id]);\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"quick-writing-the-validation-logic\"></a>\r\n### 编写验证逻辑\r\n\r\n现在我们开始在 `store` 方法中编写用来验证新的博客文章的逻辑代码。为此，我们将使用 `Illuminate\\Http\\Request` 类提供的 `validate` 方法。如果验证通过，你的代码会继续正常运行。如果验证失败，则会抛出 `Illuminate\\Validation\\ValidationException` 异常，并自动将对应的错误响应返回给用户。\r\n\r\n如果在传统 HTTP 请求期间验证失败，则会生成对先前 URL 的重定向响应。如果传入的请求是 XHR，将将返回包含验证错误信息的 JSON 响应。\r\n\r\n为了深入理解 `validate`  方法，让我们接着回到 `store` 方法中：\r\n\r\n    /**\r\n     * 存储一篇新的博客文章。\r\n     */\r\n    public function store(Request $request): RedirectResponse\r\n    {\r\n        $validated = $request->validate([\r\n            'title' => 'required|unique:posts|max:255',\r\n            'body' => 'required',\r\n        ]);\r\n\r\n        // 博客文章验证通过...\r\n\r\n        return redirect('/posts');\r\n    }\r\n\r\n如你所见，验证规则被传递到 `validate` 方法中。不用担心——所有可用的验证规则均已 [存档](#available-validation-rules)。 另外再提醒一次，如果验证失败，会自动生成一个对应的响应。如果验证通过，那我们的控制器会继续正常运行。\r\n\r\n另外，验证规则可以使用数组，而不是单个 `|` 分隔的字符串：\r\n\r\n    $validatedData = $request->validate([\r\n        'title' => ['required', 'unique:posts', 'max:255'],\r\n        'body' => ['required'],\r\n    ]);\r\n\r\n此外，你可以使用 `validateWithBag` 方法来验证请求，并将所有错误信息储存在一个 [命名错误信息包](#named-error-bags)：\r\n\r\n    $validatedData = $request->validateWithBag('post', [\r\n        'title' => ['required', 'unique:posts', 'max:255'],\r\n        'body' => ['required'],\r\n    ]);\r\n\r\n<a name=\"stopping-on-first-validation-failure\"></a>\r\n#### 在首次验证失败时停止运行\r\n\r\n有时候我们希望某个字段在第一次验证失败后就停止运行验证规则，只需要将 `bail` 添加到规则中：\r\n\r\n    $request->validate([\r\n        'title' => 'bail|required|unique:posts|max:255',\r\n        'body' => 'required',\r\n    ]);\r\n\r\n在这个例子中，如果 `title` 字段没有通过 `unique` 规则，那么不会继续验证 `max` 规则。规则会按照分配时的顺序来验证。\r\n\r\n\r\n\r\n<a name=\"a-note-on-nested-attributes\"></a>\r\n#### 嵌套字段的说明\r\n\r\n如果传入的 HTTP 请求包含「嵌套」参数，你可以在验证规则中使用`.`语法来指定这些参数：\r\n\r\n```\r\n$request->validate([\r\n\t'title' => 'required|unique:posts|max:255',\r\n\t'author.name' => 'required',\r\n\t'author.description' => 'required',\r\n]);\r\n```\r\n\r\n另外，如果你的字段名称包含点，则可以通过使用反斜杠将点转义，以防止将其解释为`.`语法：\r\n\r\n```\r\n$request->validate([\r\n\t'title' => 'required|unique:posts|max:255',\r\n\t'v1\\.0' => 'required',\r\n]);\r\n```\r\n\r\n<a name=\"quick-displaying-the-validation-errors\"></a>\r\n### 显示验证错误信息\r\n\r\n那么，如果传入的请求字段没有通过验证规则呢？如前所述，Laravel 会自动将用户重定向到之前的位置。此外，所有的验证错误和[请求输入](/docs/laravel/10.x/requests#retrieving-old-input)都会自动存入到[闪存 session](/docs/laravel/10.x/session#flash-data) 中。\r\n\r\n`Illuminate\\View\\Middleware\\ShareErrorsFromSession`中间件与应用程序的所有视图共享一个`$errors`变量，该变量由`web`中间件组提供。当应用该中间件时，`$errors` 变量始终在视图中可用，`$errors` 变量是 `Illuminate\\Support\\MessageBag` 的实例。更多有关使用该对象的信息，[查看文档](#working-with-error-messages)\r\n\r\n因此，在实例中，当验证失败时，用户将重定向到控制器`create`方法，从而在视图中显示错误消息：\r\n\r\n```blade\r\n<!-- /resources/views/post/create.blade.php -->\r\n\r\n<h1>Create Post</h1>\r\n\r\n@if ($errors->any())\r\n    <div class=\"alert alert-danger\">\r\n        <ul>\r\n            @foreach ($errors->all() as $error)\r\n                <li>{{ $error }}</li>\r\n            @endforeach\r\n        </ul>\r\n    </div>\r\n@endif\r\n\r\n<!-- Create Post Form -->\r\n```\r\n\r\n\r\n\r\n<a name=\"quick-customizing-the-error-messages\"></a>\r\n#### 在语言文件中指定自定义消息\r\n\r\nLaravel 的内置验证规则每个都对应一个错误消息，位于应用程序的`lang/en/validation.php`文件中。在此文件中，你将找到每个验证规则的翻译条目。你可以根据应用程序的需求随意更改或修改这些消息。\r\n\r\n此外，你可以将此文件复制到另一个翻译语言目录中，以翻译应用程序语言的消息。要了解有关 Laravel 本地化的更多信息，请查看完整的[本地化文档](/docs/laravel/10.x/localization).\r\n\r\n> **注意**\r\n> 默认，Laravel 应用程序框架不包括`lang`目录。如果你想自定义 Laravel 的语言文件，你可以通过`lang:publish` Artisan 命令发布它们。\r\n\r\n<a name=\"quick-xhr-requests-and-validation\"></a>\r\n#### XHR 请求 & 验证\r\n\r\n在如下示例中，我们使用传统形式将数据发送到应用程序。但是，许多应用程序从 JavaScript 驱动的前端接收 XHR 请求。在 XHR 请求期间使用`validate`方法时，Laravel 将不会生成重定向响应。相反，Laravel生成一个[包含所有验证错误的 JSON 响应](#validation-error-response-format)。该 JSON 响应将以 422 HTTP 状态码发送。\r\n\r\n<a name=\"the-at-error-directive\"></a>\r\n#### `@error`指令\r\n\r\n你亦可使用 `@error` [Blade](/docs/laravel/10.x/blade) 指令方便地检查给定的属性是否存在验证错误信息。在`@error`指令中，你可以输出`$message`变量以显示错误信息：\r\n\r\n```blade\r\n<!-- /resources/views/post/create.blade.php -->\r\n\r\n<label for=\"title\">Post Title</label>\r\n\r\n<input id=\"title\"\r\n    type=\"text\"\r\n    name=\"title\"\r\n    class=\"@error('title') is-invalid @enderror\">\r\n\r\n@error('title')\r\n    <div class=\"alert alert-danger\">{{ $message }}</div>\r\n@enderror\r\n```\r\n\r\n\r\n\r\n如果你使用[命名错误包](#named-error-bags)，你可以将错误包的名称作为第二个参数传递给`@error`指令：\r\n\r\n```blade\r\n<input ... class=\"@error('title', 'post') is-invalid @enderror\">\r\n```\r\n\r\n<a name=\"repopulating-forms\"></a>\r\n### 回填表单\r\n\r\n当 Laravel 由于验证错误而生成重定向响应时，框架将自动[将所有请求的输入闪存到 session 中](/docs/laravel/10.x/session#flash-data)。这样做是为了方便你在下一个请求期间访问输入，并重新填充用户尝试提交的表单。\r\n\r\n要从先前的请求中检索闪存的输入，请在 `Illuminate\\Http\\Request`的实例上调用`old`方法。 `old`方法将从 [session](/docs/laravel/10.x/session) 中提取先前闪存的输入数据：\r\n\r\n    $title = $request->old('title');\r\n\r\nLaravel 还提供了一个全局性的`old`。如果要在 [Blade 模板](/docs/laravel/10.x/blade), 中显示旧输入，则使用`old`来重新填充表单会更加方便。如果给定字段不存在旧输入，则将返回`null`：\r\n\r\n```blade\r\n<input type=\"text\" name=\"title\" value=\"{{ old('title') }}\">\r\n```\r\n\r\n<a name=\"a-note-on-optional-fields\"></a>\r\n### 关于可选字段的注意事项\r\n\r\n默认情况下， 在你的 Laravel 应用的全局中间件堆栈`App\\Http\\Kernel`类中包含了`TrimStrings`和`ConvertEmptyStringsToNull`中间件。因此，如果你不想让`null`被验证器标识为非法的话，你需要将「可选」字段标志为`nullable`。例如：\r\n\r\n    $request->validate([\r\n        'title' => 'required|unique:posts|max:255',\r\n        'body' => 'required',\r\n        'publish_at' => 'nullable|date',\r\n    ]);\r\n\r\n\r\n\r\n在此示例中，我们指定 `publish_at` 字段可以为 `null` 或有效的日期表示。如果没有将 `nullable` 修饰符添加到规则定义中，则验证器会将 `null` 视为无效日期。\r\n\r\n<a name=\"validation-error-response-format\"></a>\r\n### 验证错误响应格式\r\n\r\n当您的应用程序抛出 `Illuminate\\Validation\\ValidationException` 异常，并且传入的 HTTP 请求希望返回 JSON 响应时，Laravel 将自动为您格式化错误消息，并返回 `422 Unprocessable Entity` HTTP 响应。\r\n\r\n下面是验证错误的 JSON 响应格式示例。请注意，嵌套的错误键会被转换为“点”符号格式：\r\n\r\n```json\r\n{\r\n    \"message\": \"The team name must be a string. (and 4 more errors)\",\r\n    \"errors\": {\r\n        \"team_name\": [\r\n            \"The team name must be a string.\",\r\n            \"The team name must be at least 1 characters.\"\r\n        ],\r\n        \"authorization.role\": [\r\n            \"The selected authorization.role is invalid.\"\r\n        ],\r\n        \"users.0.email\": [\r\n            \"The users.0.email field is required.\"\r\n        ],\r\n        \"users.2.email\": [\r\n            \"The users.2.email must be a valid email address.\"\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"form-request-validation\"></a>\r\n## 表单请求验证\r\n\r\n<a name=\"creating-form-requests\"></a>\r\n### 创建表单请求\r\n\r\n对于更复杂的验证场景，您可能希望创建一个“表单请求”。表单请求是自定义请求类，封装了自己的验证和授权逻辑。要创建一个表单请求类，您可以使用 `make:request` Artisan CLI 命令：\r\n\r\n```shell\r\nphp artisan make:request StorePostRequest\r\n```\r\n\r\n生成的表单请求类将被放置在 `app/Http/Requests` 目录中。如果此目录不存在，则在运行 `make:request` 命令时将创建该目录。Laravel 生成的每个表单请求都有两个方法：`authorize` 和 `rules`。\r\n\r\n\r\n\r\n你可能已经猜到了，`authorize` 方法负责确定当前已认证用户是否可以执行请求所代表的操作，而 `rules` 方法返回应用于请求数据的验证规则：\r\n\r\n    /**\r\n     * 获取应用于请求的验证规则。\r\n     *\r\n     * @return array<string, \\Illuminate\\Contracts\\Validation\\Rule|array|string>\r\n     */\r\n    public function rules(): array\r\n    {\r\n        return [\r\n            'title' => 'required|unique:posts|max:255',\r\n            'body' => 'required',\r\n        ];\r\n    }\r\n\r\n> **注意**\r\n> 你可以在 `rules` 方法的签名中指定任何你需要的依赖项类型提示。它们将通过 Laravel 的 [服务容器](/docs/laravel/10.x/container) 自动解析。\r\n\r\n那么，验证规则是如何被评估的呢？你只需要在控制器方法中对请求进行类型提示。在调用控制器方法之前，传入的表单请求将被验证，这意味着你不需要在控制器中添加任何验证逻辑：\r\n\r\n    /**\r\n     * 存储新博客文章。\r\n     */\r\n    public function store(StorePostRequest $request): RedirectResponse\r\n    {\r\n        // 传入的请求有效...\r\n\r\n        // 检索已验证的输入数据...\r\n        $validated = $request->validated();\r\n\r\n        // Retrieve a portion of the validated input data...\r\n        $validated = $request->safe()->only(['name', 'email']);\r\n        $validated = $request->safe()->except(['name', 'email']);\r\n\r\n        // 存储博客文章...\r\n\r\n        return redirect('/posts');\r\n    }\r\n\r\n如果验证失败，将生成重定向响应以将用户发送回其先前的位置。错误也将被闪存到会话中，以便进行显示。如果请求是 XHR 请求，则会向用户返回带有 422 状态代码的 HTTP 响应，其中包含[JSON 格式的验证错误表示](#validation-error-response-format)。\r\n\r\n\r\n<a name=\"adding-after-hooks-to-form-requests\"></a>\r\n#### 在表单请求后添加钩子\r\n\r\n如果您想在表单请求「之后」添加验证钩子，可以使用 `withValidator` 方法。这个方法接收一个完整的验证构造器，允许你在验证结果返回之前调用任何方法：\r\n\r\n    use Illuminate\\Validation\\Validator;\r\n\r\n    /**\r\n     * 配置验证实例。\r\n     */\r\n    public function withValidator(Validator $validator): void\r\n    {\r\n        $validator->after(function (Validator $validator) {\r\n            if ($this->somethingElseIsInvalid()) {\r\n                $validator->errors()->add('field', 'Something is wrong with this field!');\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n<a name=\"request-stopping-on-first-validation-rule-failure\"></a>\r\n#### 单个验证规则失败后停止\r\n\r\n通过向您的请求类添加 `stopOnFirstFailure` 属性，您可以通知验证器一旦发生单个验证失败后，停止验证所有规则。\r\n\r\n    /**\r\n     * 表示验证器是否应在第一个规则失败时停止。\r\n     *\r\n     * @var bool\r\n     */\r\n    protected $stopOnFirstFailure = true;\r\n\r\n<a name=\"customizing-the-redirect-location\"></a>\r\n#### 自定义重定向\r\n\r\n如前所述，当表单请求验证失败时，将会生成一个让用户返回到先前位置的重定向响应。当然，您也可以自由定义此行为。如果您要这样做，可以在表单请求中定义一个 `$redirect` 属性：\r\n\r\n    /**\r\n     * 如果验证失败，用户应重定向到的 URI。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $redirect = '/dashboard';\r\n\r\n或者，如果你想将用户重定向到一个命名路由，你可以定义一个 `$redirectRoute` 属性来代替：\r\n\r\n    /**\r\n     * 如果验证失败，用户应该重定向到的路由。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $redirectRoute = 'dashboard';\r\n\r\n<a name=\"authorizing-form-requests\"></a>\r\n### 表单请求授权验证\r\n\r\n表单请求类内也包含了 `authorize` 方法。在这个方法中，您可以检查经过身份验证的用户确定其是否具有更新给定资源的权限。例如，您可以判断用户是否拥有更新文章评论的权限。最有可能的是，您将通过以下方法与你的 [授权与策略](/docs/laravel/10.x/authorization) 进行交互：\r\n\r\n    use App\\Models\\Comment;\r\n\r\n    /**\r\n     * 确定用户是否有请求权限。\r\n     */\r\n    public function authorize(): bool\r\n    {\r\n        $comment = Comment::find($this->route('comment'));\r\n\r\n        return $comment && $this->user()->can('update', $comment);\r\n    }\r\n\r\n\r\n\r\n由于所有的表单请求都是继承了 Laravel 中的请求基类，所以我们可以使用 `user` 方法去获取当前认证登录的用户。同时请注意上述例子中对 `route` 方法的调用。这个方法允许你在被调用的路由上获取其定义的 URI 参数，譬如下面例子中的 `{comment}` 参数：\r\n\r\n    Route::post('/comment/{comment}');\r\n\r\n因此，如果您的应用程序正在使用 [路由模型绑定](/docs/laravel/10.x/routing#route-model-binding)，则可以通过将解析的模型作为请求从而让您的代码更加简洁：\r\n\r\n    return $this->user()->can('update', $this->comment);\r\n\r\n如果 `authorize` 方法返回 `false`，则会自动返回一个包含 403 状态码的 HTTP 响应，也不会运行控制器的方法。\r\n\r\n如果您打算在应用程序的其它部分处理请求的授权逻辑，只需从 `authorize` 方法返回 `true`：\r\n\r\n    /**\r\n     * 判断用户是否有请求权限。\r\n     */\r\n    public function authorize(): bool\r\n    {\r\n        return true;\r\n    }\r\n\r\n> **注意**\r\n> 你可以向 `authorize` 方法传入所需的任何依赖项。它们会自动被 Laravel 提供的 [服务容器](/docs/laravel/10.x/container) 自动解析。\r\n\r\n<a name=\"customizing-the-error-messages\"></a>\r\n### 自定义错误消息\r\n\r\n你可以通过重写表单请求的 `messages` 方法来自定义错误消息。此方法应返回属性 / 规则对及其对应错误消息的数组：\r\n\r\n    /**\r\n     * 获取已定义验证规则的错误消息。\r\n     *\r\n     * @return array<string, string>\r\n     */\r\n    public function messages(): array\r\n    {\r\n        return [\r\n            'title.required' => 'A title is required',\r\n            'body.required' => 'A message is required',\r\n        ];\r\n    }\r\n\r\n\r\n\r\n<a name=\"customizing-the-validation-attributes\"></a>\r\n#### 自定义验证属性\r\n\r\nLaravel 的许多内置验证规则错误消息都包含 `:attribute` 占位符。如果您希望将验证消息的 `:attribute` 部分替换为自定义属性名称，则可以重写 `attributes` 方法来指定自定义名称。此方法应返回属性 / 名称对的数组：\r\n\r\n    /**\r\n     * 获取验证错误的自定义属性\r\n     *\r\n     * @return array<string, string>\r\n     */\r\n    public function attributes(): array\r\n    {\r\n        return [\r\n            'email' => 'email address',\r\n        ];\r\n    }\r\n\r\n<a name=\"preparing-input-for-validation\"></a>\r\n### 准备验证输入\r\n\r\n如果您需要在应用验证规则之前修改或清理请求中的任何数据，您可以使用 `prepareForValidation` 方法：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    /**\r\n     * 准备验证数据。\r\n     */\r\n    protected function prepareForValidation(): void\r\n    {\r\n        $this->merge([\r\n            'slug' => Str::slug($this->slug),\r\n        ]);\r\n    }\r\n\r\n同样地，如果您需要在验证完成后对任何请求数据进行规范化，您可以使用 `passedValidation` 方法：\r\n\r\n    use Illuminate\\Support\\Str;\r\n\r\n    /**\r\n     * Handle a passed validation attempt.\r\n     */\r\n    protected function passedValidation(): void\r\n    {\r\n        $this->replace(['name' => 'Taylor']);\r\n    }\r\n\r\n<a name=\"manually-creating-validators\"></a>\r\n## 手动创建验证器\r\n\r\n如果您不想在请求上使用 `validate` 方法，可以使用 `Validator`  [门面](/laravel/10.x/facades) 手动创建一个验证器实例。门面上的 `make` 方法会生成一个新的验证器实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 存储新的博客文章。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $validator = Validator::make($request->all(), [\r\n                'title' => 'required|unique:posts|max:255',\r\n                'body' => 'required',\r\n            ]);\r\n\r\n            if ($validator->fails()) {\r\n                return redirect('post/create')\r\n                            ->withErrors($validator)\r\n                            ->withInput();\r\n            }\r\n\r\n            // 获取验证后的输入...\r\n            $validated = $validator->validated();\r\n\r\n            // 获取验证后输入的一部分...\r\n            $validated = $validator->safe()->only(['name', 'email']);\r\n            $validated = $validator->safe()->except(['name', 'email']);\r\n\r\n            // 存储博客文章...\r\n\r\n            return redirect('/posts');\r\n        }\r\n    }\r\n\r\n\r\n\r\n第一个参数传递给`make`方法的是要验证的数据。第二个参数是一个应用于数据的验证规则的数组。\r\n\r\n在确定请求验证是否失败之后，您可以使用`withErrors`方法将错误消息闪存到会话中。使用此方法后，`$errors`变量将自动在重定向后与您的视图共享，从而可以轻松地将其显示回用户。`withErrors`方法接受验证器、`MessageBag`或PHP数组。\r\n\r\n#### 单个验证规则失败后停止\r\n\r\n通过向您的请求类添加 `stopOnFirstFailure` 属性，您可以通知验证器一旦发生单个验证失败后，停止验证所有规则。\r\n\r\n    if ($validator->stopOnFirstFailure()->fails()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"automatic-redirection\"></a>\r\n### 自动重定向\r\n\r\n如果您想手动创建验证器实例，但仍要利用HTTP请求的`validate`方法提供的自动重定向，可以在现有验证器实例上调用`validate`方法。如果验证失败，则会自动重定向用户，或者在XHR请求的情况下，将返回一个[JSON响应](#validation-error-response-format)\r\n\r\n    Validator::make($request->all(), [\r\n        'title' => 'required|unique:posts|max:255',\r\n        'body' => 'required',\r\n    ])->validate();\r\n\r\n如果验证失败，您可以使用`validateWithBag`方法将错误消息存储在[命名错误包](#named-error-bags)中：\r\n\r\n    Validator::make($request->all(), [\r\n        'title' => 'required|unique:posts|max:255',\r\n        'body' => 'required',\r\n    ])->validateWithBag('post');\r\n\r\n<a name=\"named-error-bags\"></a>\r\n### 命名的错误包\r\n\r\n如果您在同一页上有多个表单，您可能希望为包含验证错误的`MessageBag`命名，以便检索特定表单的错误消息。为此，将名称作为第二个参数传递给`withErrors`：\r\n\r\n    return redirect('register')->withErrors($validator, 'login');\r\n\r\n\r\n\r\n你可以通过 `$errors` 变量访问命名后的 `MessageBag` 实例：\r\n\r\n```blade\r\n{{ $errors->login->first('email') }}\r\n```\r\n\r\n<a name=\"manual-customizing-the-error-messages\"></a>\r\n### 自定义错误消息\r\n\r\n如果需要，你可以提供验证程序实例使用的自定义错误消息，而不是 Laravel 提供的默认错误消息。有几种指定自定义消息的方法。首先，您可以将自定义消息作为第三个参数传递给 `Validator::make` 方法：\r\n\r\n    $validator = Validator::make($input, $rules, $messages = [\r\n        'required' => 'The :attribute field is required.',\r\n    ]);\r\n\r\n在此示例中，`:attribute` 占位符将被验证中的字段的实际名称替换。您也可以在验证消息中使用其它占位符。例如：\r\n\r\n    $messages = [\r\n        'same' => 'The :attribute and :other must match.',\r\n        'size' => 'The :attribute must be exactly :size.',\r\n        'between' => 'The :attribute value :input is not between :min - :max.',\r\n        'in' => 'The :attribute must be one of the following types: :values',\r\n    ];\r\n\r\n<a name=\"specifying-a-custom-message-for-a-given-attribute\"></a>\r\n#### 为给定属性指定自定义消息\r\n\r\n有时你可能希望只为特定属性指定自定义错误消息。你可以使用 `.` 表示法。首先指定属性名称，然后指定规则：\r\n\r\n    $messages = [\r\n        'email.required' => 'We need to know your email address!',\r\n    ];\r\n\r\n<a name=\"specifying-custom-attribute-values\"></a>\r\n#### 指定自定义属性值\r\n\r\nLaravel 的许多内置错误消息都包含一个 `:attribute` 占位符，该占位符已被验证中的字段或属性的名称替换。为了自定义用于替换特定字段的这些占位符的值，你可以将自定义属性的数组作为第四个参数传递给 `Validator::make` 方法：\r\n\r\n    $validator = Validator::make($input, $rules, $messages, [\r\n        'email' => 'email address',\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"after-validation-hook\"></a>\r\n### 验证后钩子\r\n\r\n验证器允许你在完成验证操作后执行附加的回调。以便你处理下一步的验证，甚至是往信息集合中添加更多的错误信息。你可以在验证器实例上使用 `after` 方法实现：\r\n\r\n    use Illuminate\\Support\\Facades;\r\n    use Illuminate\\Validation\\Validator;\r\n\r\n    $validator = Facades\\Validator::make(/* ... */);\r\n\r\n    $validator->after(function (Validator $validator) {\r\n        if ($this->somethingElseIsInvalid()) {\r\n            $validator->errors()->add(\r\n                'field', 'Something is wrong with this field!'\r\n            );\r\n        }\r\n    });\r\n\r\n    if ($validator->fails()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"working-with-validated-input\"></a>\r\n## 处理验证字段\r\n\r\n在使用表单请求或手动创建的验证器实例验证传入请求数据后，你可能希望检索经过验证的请求数据。 这可以通过多种方式实现。 首先，你可以在表单请求或验证器实例上调用 `validated` 方法。 此方法返回已验证的数据数组：\r\n\r\n    $validated = $request->validated();\r\n\r\n    $validated = $validator->validated();\r\n\r\n或者，你可以在表单请求或验证器实例上调用 `safe` 方法。 此方法返回一个 `Illuminate\\Support\\ValidatedInput`的实例。 该实例对象包含 `only`、`except` 和 `all` 方法来检索已验证数据的子集或整个已验证数据数组：\r\n\r\n    $validated = $request->safe()->only(['name', 'email']);\r\n\r\n    $validated = $request->safe()->except(['name', 'email']);\r\n\r\n    $validated = $request->safe()->all();\r\n\r\n此外， `Illuminate\\Support\\ValidatedInput` 实例可以像数组一样被迭代和访问：\r\n\r\n    // 迭代验证数据...\r\n    foreach ($request->safe() as $key => $value) {\r\n        // ...\r\n    }\r\n\r\n    // 访问验证数据数组...\r\n    $validated = $request->safe();\r\n\r\n    $email = $validated['email'];\r\n\r\n\r\n\r\n`merge` 方法可以给验证过的数据添加额外的字段：\r\n\r\n    $validated = $request->safe()->merge(['name' => 'Taylor Otwell']);\r\n\r\n`collect` 方法以 [collection](/docs/laravel/10.x/collections) 实例的形式来检索验证的数据：\r\n\r\n    $collection = $request->safe()->collect();\r\n\r\n<a name=\"working-with-error-messages\"></a>\r\n## 使用错误消息\r\n\r\n在调用 `Validator` 实例的 `errors` 方法后，会收到一个 `Illuminate\\Support\\MessageBag` 实例，用于处理错误信息。自动提供给所有视图的 `$errors` 变量也是 `MessageBag` 类的一个实例。\r\n\r\n<a name=\"retrieving-the-first-error-message-for-a-field\"></a>\r\n#### 检索字段的第一条错误消息\r\n\r\n`first` 方法返回给定字段的第一条错误信息：\r\n\r\n    $errors = $validator->errors();\r\n\r\n    echo $errors->first('email');\r\n\r\n<a name=\"retrieving-all-error-messages-for-a-field\"></a>\r\n#### 检索一个字段的所有错误信息\r\n\r\n`get` 方法用于检索一个给定字段的所有错误信息，返回值类型为数组：\r\n\r\n    foreach ($errors->get('email') as $message) {\r\n        // ...\r\n    }\r\n\r\n对于数组表单字段，可以使用 `*` 来检索每个数组元素的所有错误信息：\r\n\r\n    foreach ($errors->get('attachments.*') as $message) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"retrieving-all-error-messages-for-all-fields\"></a>\r\n#### 检索所有字段的所有错误信息\r\n\r\n`all` 方法用于检索所有字段的所有错误信息，返回值类型为数组：\r\n\r\n    foreach ($errors->all() as $message) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"determining-if-messages-exist-for-a-field\"></a>\r\n#### 判断字段是否存在错误信息\r\n\r\n`has` 方法可用于确定一个给定字段是否存在任何错误信息：\r\n\r\n    if ($errors->has('email')) {\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n<a name=\"specifying-custom-messages-in-language-files\"></a>\r\n### 在语言文件中指定自定义消息\r\n\r\nLaravel 内置的验证规则都有一个错误信息，位于应用程序的 `lang/en/validation.php` 文件中。在这个文件中, 你会发现每个验证规则都有一个翻译条目。可以根据你的应用程序的需要，自由地改变或修改这些信息。\r\n\r\n此外, 你可以把这个文件复制到另一个语言目录，为你的应用程序的语言翻译信息。要了解更多关于Laravel本地化的信息, 请查看完整的 [本地化](/docs/laravel/10.x/localization)。\r\n\r\n> **Warning**\r\n> 默认情况下, Laravel 应用程序的骨架不包括 `lang` 目录. 如果你想定制 Laravel 的语言文件, 可以通过 `lang:publish` Artisan 命令发布它们。\r\n\r\n<a name=\"custom-messages-for-specific-attributes\"></a>\r\n#### 针对特定属性的自定义信息\r\n\r\n可以在应用程序的验证语言文件中自定义用于指定属性和规则组合的错误信息。将自定义信息添加到应用程序的 `lang/xx/validation.php` 语言文件的  `custom` 数组中：\r\n\r\n    'custom' => [\r\n        'email' => [\r\n            'required' => 'We need to know your email address!',\r\n            'max' => 'Your email address is too long!'\r\n        ],\r\n    ],\r\n\r\n<a name=\"specifying-attribute-in-language-files\"></a>\r\n### 在语言文件中指定属性\r\n\r\nLaravel 内置的错误信息包括一个 `:attribute` 占位符，它被替换为验证中的字段或属性的名称。如果你希望你的验证信息中的 `:attribute` 部分被替换成一个自定义的值, 可以在 `lang/xx/validation.php` 文件的 `attributes` 数组中指定自定义属性名称:\r\n\r\n    'attributes' => [\r\n        'email' => 'email address',\r\n    ],\r\n\r\n> **Warning**\r\n> 默认情况下, Laravel 应用程序的骨架不包括 `lang` 目录. 如果你想定制 Laravel 的语言文件, 可以通过 `lang:publish` Artisan 命令发布它们。\r\n\r\n\r\n\r\n<a name=\"specifying-values-in-language-files\"></a>\r\n### 指定语言文件中的值\r\n\r\nLaravel 内置的验证规则错误信息包含一个 `:value` 占位符，它被替换成请求属性的当前值。然而, 你可能偶尔需要在验证信息的 `:value` 部分替换成自定义的值。 例如，如果 `payment_type` 的值为 `cc` 则需要验证信用卡号码:\r\n\r\n    Validator::make($request->all(), [\r\n        'credit_card_number' => 'required_if:payment_type,cc'\r\n    ]);\r\n\r\n如果这个验证规则失败了，它将产生以下错误信息:\r\n\r\n```none\r\nThe credit card number field is required when payment type is cc.\r\n```\r\n\r\n你可以在 `lang/xx/validation.php` 语言文件中通过定义一个 `values` 数组来指定一个更友好的提示，而不是显示 `cc` 作为支付类型值：\r\n\r\n    'values' => [\r\n        'payment_type' => [\r\n            'cc' => 'credit card'\r\n        ],\r\n    ],\r\n\r\n> **Warning**\r\n> 默认情况下, Laravel 应用程序的骨架不包括 `lang` 目录. 如果你想定制 Laravel 的语言文件, 你可以通过 `lang:publish` Artisan 命令发布它们。\r\n\r\n定义这个值后，验证规则将产生以下错误信息：\r\n\r\n```none\r\nThe credit card number field is required when payment type is credit card.\r\n```\r\n<a name=\"available-validation-rules\"></a>\r\n## 可用的验证规则\r\n\r\n下面是所有可用的验证规则及其功能的列表:\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        columns: 10.8em 3; -moz-columns: 10.8em 3; -webkit-columns: 10.8em 3;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[Accepted](#rule-accepted)\r\n[Accepted If](#rule-accepted-if)\r\n[Active URL](#rule-active-url)\r\n[After (Date)](#rule-after)\r\n[After Or Equal (Date)](#rule-after-or-equal)\r\n[Alpha](#rule-alpha)\r\n[Alpha Dash](#rule-alpha-dash)\r\n[Alpha Numeric](#rule-alpha-num)\r\n[Array](#rule-array)\r\n[Ascii](#rule-ascii)\r\n[Bail](#rule-bail)\r\n[Before (Date)](#rule-before)\r\n[Before Or Equal (Date)](#rule-before-or-equal)\r\n[Between](#rule-between)\r\n[Boolean](#rule-boolean)\r\n[Confirmed](#rule-confirmed)\r\n[Current Password](#rule-current-password)\r\n[Date](#rule-date)\r\n[Date Equals](#rule-date-equals)\r\n[Date Format](#rule-date-format)\r\n[Decimal](#rule-decimal)\r\n[Declined](#rule-declined)\r\n[Declined If](#rule-declined-if)\r\n[Different](#rule-different)\r\n[Digits](#rule-digits)\r\n[Digits Between](#rule-digits-between)\r\n[Dimensions (Image Files)](#rule-dimensions)\r\n[Distinct](#rule-distinct)\r\n[Doesnt Start With](#rule-doesnt-start-with)\r\n[Doesnt End With](#rule-doesnt-end-with)\r\n[Email](#rule-email)\r\n[Ends With](#rule-ends-with)\r\n[Enum](#rule-enum)\r\n[Exclude](#rule-exclude)\r\n[Exclude If](#rule-exclude-if)\r\n[Exclude Unless](#rule-exclude-unless)\r\n[Exclude With](#rule-exclude-with)\r\n[Exclude Without](#rule-exclude-without)\r\n[Exists (Database)](#rule-exists)\r\n[File](#rule-file)\r\n[Filled](#rule-filled)\r\n[Greater Than](#rule-gt)\r\n[Greater Than Or Equal](#rule-gte)\r\n[Image (File)](#rule-image)\r\n[In](#rule-in)\r\n[In Array](#rule-in-array)\r\n[Integer](#rule-integer)\r\n[IP Address](#rule-ip)\r\n[JSON](#rule-json)\r\n[Less Than](#rule-lt)\r\n[Less Than Or Equal](#rule-lte)\r\n[Lowercase](#rule-lowercase)\r\n[MAC Address](#rule-mac)\r\n[Max](#rule-max)\r\n[Max Digits](#rule-max-digits)\r\n[MIME Types](#rule-mimetypes)\r\n[MIME Type By File Extension](#rule-mimes)\r\n[Min](#rule-min)\r\n[Min Digits](#rule-min-digits)\r\n[Missing](#rule-missing)\r\n[Missing If](#rule-missing-if)\r\n[Missing Unless](#rule-missing-unless)\r\n[Missing With](#rule-missing-with)\r\n[Missing With All](#rule-missing-with-all)\r\n[Multiple Of](#rule-multiple-of)\r\n[Not In](#rule-not-in)\r\n[Not Regex](#rule-not-regex)\r\n[Nullable](#rule-nullable)\r\n[Numeric](#rule-numeric)\r\n[Password](#rule-password)\r\n[Present](#rule-present)\r\n[Prohibited](#rule-prohibited)\r\n[Prohibited If](#rule-prohibited-if)\r\n[Prohibited Unless](#rule-prohibited-unless)\r\n[Prohibits](#rule-prohibits)\r\n[Regular Expression](#rule-regex)\r\n[Required](#rule-required)\r\n[Required If](#rule-required-if)\r\n[Required Unless](#rule-required-unless)\r\n[Required With](#rule-required-with)\r\n[Required With All](#rule-required-with-all)\r\n[Required Without](#rule-required-without)\r\n[Required Without All](#rule-required-without-all)\r\n[Required Array Keys](#rule-required-array-keys)\r\n[Same](#rule-same)\r\n[Size](#rule-size)\r\n[Sometimes](#validating-when-present)\r\n[Starts With](#rule-starts-with)\r\n[String](#rule-string)\r\n[Timezone](#rule-timezone)\r\n[Unique (Database)](#rule-unique)\r\n[Uppercase](#rule-uppercase)\r\n[URL](#rule-url)\r\n[ULID](#rule-ulid)\r\n[UUID](#rule-uuid)\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"rule-accepted\"></a>\r\n#### accepted\r\n\r\n待验证字段必须是 `「yes」` ，`「on」` ，`1` 或 `true`。这对于验证「服务条款」的接受或类似字段时很有用。\r\n\r\n<a name=\"rule-accepted-if\"></a>\r\n#### accepted_if:anotherfield,value,...\r\n\r\n如果另一个正在验证的字段等于指定的值，则验证中的字段必须为 `「yes」` ，`「on」` ，`1` 或 `true`。 这对于验证「服务条款」接受或类似字段很有用。\r\n\r\n<a name=\"rule-active-url\"></a>\r\n#### active_url\r\n\r\n根据 `dns_get_record` PHP 函数，验证中的字段必须具有有效的 A 或 AAAA 记录。 提供的 URL 的主机名使用 `parse_url` PHP 函数提取，然后传递给 `dns_get_record`。\r\n\r\n<a name=\"rule-after\"></a>\r\n#### after:_date_\r\n\r\n验证中的字段必须是给定日期之后的值。日期将被传递给 `strtotime` PHP 函数中，以便转换为有效的 `DateTime` 实例：\r\n\r\n    'start_date' => 'required|date|after:tomorrow'\r\n\r\n你也可以指定另一个要与日期比较的字段，而不是传递要由 `strtotime` 处理的日期字符串：\r\n\r\n    'finish_date' => 'required|date|after:start_date'\r\n\r\n<a name=\"rule-after-or-equal\"></a>\r\n#### after\\_or\\_equal:_date_\r\n\r\n待验证字段的值对应的日期必须在给定日期之后或与给定的日期相同。可参阅 [after](#rule-after) 规则获取更多信息。\r\n\r\n<a name=\"rule-alpha\"></a>\r\n#### alpha\r\n\r\n待验证字段必须是包含在 [`\\p{L}`](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3AL%3A%5D&g=&i=) 和 [`\\p{M}`](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3AM%3A%5D&g=&i=) 中的Unicode字母字符。\r\n\r\n\r\n\r\n为了将此验证规则限制在 ASCII 范围内的字符（`a-z` 和`A-Z`），你可以为验证规则提供 `ascii` 选项：\r\n\r\n```php\r\n'username' => 'alpha:ascii',\r\n```\r\n\r\n<a name=\"rule-alpha-dash\"></a>\r\n#### alpha_dash\r\n\r\n被验证的字段必须完全是 Unicode 字母数字字符中的 [`\\p{L}`](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3AL%3A%5D&g=&i=)、[`\\p{M}`](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3AM%3A%5D&g=&i=)、[`\\p{N}`](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3AN%3A%5D&g=&i=)，以及 ASCII 破折号（`-`）和 ASCII 下划线（`_`）。\r\n\r\n为了将此验证规则限制在 ASCII 范围内的字符（`a-z` 和`A-Z`），你可以为验证规则提供 `ascii` 选项：\r\n\r\n```php\r\n'username' => 'alpha_dash:ascii',\r\n```\r\n\r\n<a name=\"rule-alpha-num\"></a>\r\n#### alpha_num\r\n\r\n被验证的字段必须完全是 Unicode 字母数字字符中的 [`\\p{L}`](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3AL%3A%5D&g=&i=), [`\\p{M}`](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3AM%3A%5D&g=&i=) 和 [`\\p{N}`](https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3AN%3A%5D&g=&i=)。\r\n\r\n为了将此验证规则限制在 ASCII 范围内的字符（`a-z` 和`A-Z`），你可以为验证规则提供 `ascii` 选项：\r\n\r\n```php\r\n'username' => 'alpha_num:ascii',\r\n```\r\n\r\n<a name=\"rule-array\"></a>\r\n#### array\r\n\r\n待验证字段必须是有效的 PHP `数组`。\r\n\r\n当向 `array`  规则提供附加值时，输入数组中的每个键都必须出现在提供给规则的值列表中。在以下示例中，输入数组中的 `admin` 键无效，因为它不包含在提供给  `array` 规则的值列表中：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $input = [\r\n        'user' => [\r\n            'name' => 'Taylor Otwell',\r\n            'username' => 'taylorotwell',\r\n            'admin' => true,\r\n        ],\r\n    ];\r\n\r\n    Validator::make($input, [\r\n        'user' => 'array:name,username',\r\n    ]);\r\n\r\n\r\n\r\n通常，你应该始终指定允许出现在数组中的数组键。\r\n\r\n#### ascii\r\n\r\n正在验证的字段必须完全是 7 位的 ASCII 字符。\r\n\r\n#### bail\r\n\r\n在首次验证失败后立即终止验证。\r\n\r\n虽然 `bail` 规则只会在遇到验证失败时停止验证特定字段，但 `stopOnFirstFailure` 方法会通知验证器，一旦发生单个验证失败，它应该停止验证所有属性:\r\n\r\n    if ($validator->stopOnFirstFailure()->fails()) {\r\n        // ...\r\n    }\r\n\r\n#### before:_date_\r\n\r\n待验证字段的值对应的日期必须在给定的日期之前。这个日期将被传递给 PHP 函数 `strtotime` 以便转化为有效的 `DateTime` 实例。此外，与 [`after`](#rule-after) 规则一致，可以将另外一个待验证的字段作为 `date` 的值。\r\n\r\n#### before\\_or\\_equal:_date_\r\n\r\n待验证字段的值必须是给定日期之前或等于给定日期的值。这个日期将被传递给 PHP 函数 `strtotime` 以便转化为有效的 `DateTime` 实例。此外，与 [`after`](#rule-after) 规则一致， 可以将另外一个待验证的字段作为 `date` 的值。\r\n\r\n#### between:_min_,_max_\r\n\r\n待验证字段值的大小必须介于给定的最小值和最大值（含）之间。字符串、数字、数组和文件的计算方式都使用 [`size`](#rule-size) 方法。\r\n\r\n\r\n\r\n<a name=\"rule-boolean\"></a>\r\n#### boolean\r\n\r\n验证的字段必须可以转换为 Boolean 类型。 可接受的输入为 `true`, `false`, `1`, `0`, `「1」`, 和 `「0」`。\r\n\r\n<a name=\"rule-confirmed\"></a>\r\n#### confirmed\r\n\r\n验证字段必须与 `{field}_confirmation` 字段匹配。例如，如果验证字段是 `password`，则输入中必须存在相应的 `password_confirmation` 字段。\r\n\r\n<a name=\"rule-current-password\"></a>\r\n#### current_password\r\n\r\n验证字段必须与已认证用户的密码匹配。 您可以使用规则的第一个参数指定 [authentication guard](/docs/laravel/10.x/authentication):\r\n\r\n    'password' => 'current_password:api'\r\n\r\n<a name=\"rule-date\"></a>\r\n#### date\r\n\r\n验证字段必须是 `strtotime` PHP 函数可识别的有效日期。\r\n\r\n<a name=\"rule-date-equals\"></a>\r\n#### date_equals:_date_\r\n\r\n验证字段必须等于给定日期。日期将传递到 PHP `strtotime` 函数中，以转换为有效的 `DateTime` 实例。\r\n\r\n<a name=\"rule-date-format\"></a>\r\n#### date_format:_format_,...\r\n\r\n验证字段必须匹配给定的 *format* 。在验证字段时，您应该只使用 `date` 或 `date_format` 中的**其中一个**，而不是同时使用。该验证规则支持 PHP 的 [DateTime](https://www.php.net/manual/en/class.datetime.php) 类支持的所有格式。\r\n\r\n<a name=\"rule-decimal\"></a>\r\n#### decimal:_min_,_max_\r\n\r\n验证字段必须是数值类型，并且必须包含指定的小数位数：\r\n\r\n    // 必须正好有两位小数（例如 9.99）...\r\n    'price' => 'decimal:2'\r\n\r\n    // 必须有 2 到 4 位小数...\r\n    'price' => 'decimal:2,4'\r\n\r\n<a name=\"rule-declined\"></a>\r\n\r\n\r\n#### declined\r\n\r\n正在验证的字段必须是 `「no」`，`「off」`，`0` 或者 `false`。\r\n\r\n<a name=\"rule-declined-if\"></a>\r\n#### declined_if:anotherfield,value,...\r\n\r\n如果另一个验证字段的值等于指定值，则验证字段的值必须为`「no」`、`「off」`、`0`或`false`。\r\n\r\n<a name=\"rule-different\"></a>\r\n#### different:_field_\r\n\r\n验证的字段值必须与字段 _field_ 的值不同。\r\n\r\n<a name=\"rule-digits\"></a>\r\n#### digits:_value_\r\n\r\n验证的整数必须具有确切长度 _value_ 。\r\n\r\n<a name=\"rule-digits-between\"></a>\r\n#### digits_between:_min_,_max_\r\n\r\n验证的整数长度必须在给定的 _min_ 和 _max_ 之间。\r\n\r\n<a name=\"rule-dimensions\"></a>\r\n#### dimensions\r\n\r\n验证的文件必须是符合规则参数指定尺寸限制的图像：\r\n\r\n    'avatar' => 'dimensions:min_width=100,min_height=200'\r\n\r\n可用的限制条件有: _min\\_width_ , _max\\_width_ , _min\\_height_ , _max\\_height_ , _width_ , _height_ , _ratio_ .\r\n\r\n_ratio_ 约束应该表示为宽度除以高度。 这可以通过像 `3/2` 这样的语句或像 `1.5` 这样的浮点数来指定：\r\n\r\n    'avatar' => 'dimensions:ratio=3/2'\r\n\r\n由于此规则需要多个参数，因此你可以 `Rule::dimensions` 方法来构造可读性高的规则：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'avatar' => [\r\n            'required',\r\n            Rule::dimensions()->maxWidth(1000)->maxHeight(500)->ratio(3 / 2),\r\n        ],\r\n    ]);\r\n\r\n<a name=\"rule-distinct\"></a>\r\n#### distinct\r\n\r\n验证数组时，正在验证的字段不能有任何重复值：\r\n\r\n    'foo.*.id' => 'distinct'\r\n\r\n默认情况下，Distinct 使用松散的变量比较。要使用严格比较，您可以在验证规则定义中添加 `strict` 参数：\r\n\r\n    'foo.*.id' => 'distinct:strict'\r\n\r\n\r\n\r\n你可以在验证规则的参数中添加 `ignore_case` ，以使规则忽略大小写差异：\r\n\r\n    'foo.*.id' => 'distinct:ignore_case'\r\n\r\n<a name=\"rule-doesnt-start-with\"></a>\r\n#### doesnt_start_with:_foo_,_bar_,...\r\n\r\n验证的字段不能以给定值之一开头。\r\n\r\n<a name=\"rule-doesnt-end-with\"></a>\r\n#### doesnt_end_with:_foo_,_bar_,...\r\n\r\n验证的字段不能以给定值之一结尾。\r\n\r\n<a name=\"rule-email\"></a>\r\n#### email\r\n\r\n验证的字段必须符合 `e-mail` 地址格式。当前版本，此种验证规则由 [`egulias/email-validator`](https://github.com/egulias/EmailValidator) 提供支持。默认情况下，使用 `RFCValidation` 验证样式，但你也可以应用其他验证样式：\r\n\r\n    'email' => 'email:rfc,dns'\r\n\r\n上面的示例将应用 `RFCValidation` 和 `DNSCheckValidation` 验证。以下是你可以应用的验证样式的完整列表：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `rfc`: `RFCValidation`\r\n- `strict`: `NoRFCWarningsValidation`\r\n- `dns`: `DNSCheckValidation`\r\n- `spoof`: `SpoofCheckValidation`\r\n- `filter`: `FilterEmailValidation`\r\n- `filter_unicode`: `FilterEmailValidation::unicode()`\r\n\r\n</div>\r\n\r\n`filter` 验证器是 Laravel 内置的一个验证器，它使用 PHP 的 `filter_var` 函数实现。在 Laravel 5.8 版本之前，它是 Laravel 默认的电子邮件验证行为。\r\n\r\n> **注意**  \r\n> `dns` 和 `spoof` 验证器需要 PHP 的 `intl` 扩展。\r\n\r\n<a name=\"rule-ends-with\"></a>\r\n#### ends_with:_foo_,_bar_,...\r\n\r\n被验证的字段必须以给定值之一结尾。\r\n\r\n<a name=\"rule-enum\"></a>\r\n#### enum\r\n\r\n`Enum` 规则是一种基于类的规则，用于验证被验证字段是否包含有效的枚举值。 `Enum` 规则的构造函数只接受枚举的名称作为参数：\r\n\r\n    use App\\Enums\\ServerStatus;\r\n    use Illuminate\\Validation\\Rules\\Enum;\r\n\r\n    $request->validate([\r\n        'status' => [new Enum(ServerStatus::class)],\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"rule-exclude\"></a>\r\n#### exclude\r\n\r\n `validate` 和 `validated` 方法中会排除掉当前验证的字段。\r\n\r\n<a name=\"rule-exclude-if\"></a>\r\n#### exclude_if:_anotherfield_,_value_\r\n\r\n如果 _anotherfield_ 等于 _value_ ，`validate` 和 `validated` 方法中会排除掉当前验证的字段。\r\n\r\n在一些复杂的场景，也可以使用 `Rule::excludeIf` 方法，这个方法需要返回一个布尔值或者一个匿名函数。如果返回的是匿名函数，那么这个函数应该返回 `true` 或 `false`去决定被验证的字段是否应该被排除掉：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($request->all(), [\r\n        'role_id' => Rule::excludeIf($request->user()->is_admin),\r\n    ]);\r\n\r\n    Validator::make($request->all(), [\r\n        'role_id' => Rule::excludeIf(fn () => $request->user()->is_admin),\r\n    ]);\r\n\r\n<a name=\"rule-exclude-unless\"></a>\r\n#### exclude_unless:_anotherfield_,_value_\r\n\r\n除非 *anotherfield* 等于 *value* ，否则 `validate` 和 `validated` 方法中会排除掉当前的字段。如果 *value* 为 `null` （`exclude_unless:name,null`），那么成立的条件就是被比较的字段为 `null` 或者表单中没有该字段。\r\n\r\n<a name=\"rule-exclude-with\"></a>\r\n#### exclude_with:_anotherfield_\r\n\r\n如果表单数据中有 _anotherfield_ ，`validate` 和 `validated` 方法中会排除掉当前的字段。\r\n\r\n<a name=\"rule-exclude-without\"></a>\r\n#### exclude_without:_anotherfield_\r\n\r\n如果表单数据中没有 _anotherfield_ ，`validate` 和 `validated` 方法中会排除掉当前的字段。\r\n\r\n\r\n\r\n<a name=\"rule-exists\"></a>\r\n#### exists:_table_,_column_\r\n\r\n验证的字段值必须存在于指定的表中。\r\n\r\n<a name=\"basic-usage-of-exists-rule\"></a>\r\n#### Exists 规则的基本用法\r\n\r\n    'state' => 'exists:states'\r\n\r\n如果未指定 `column` 选项，则将使用字段名称。因此，在这种情况下，该规则将验证 `states` 数据库表是否包含一条记录，该记录的 `state` 列的值与请求的 `state` 属性值匹配。\r\n\r\n<a name=\"specifying-a-custom-column-name\"></a>\r\n#### 指定自定义列名\r\n\r\n你可以将验证规则使用的数据库列名称指定在数据库表名称之后：\r\n\r\n    'state' => 'exists:states,abbreviation'\r\n\r\n有时候，你或许需要去明确指定一个具体的数据库连接，用于 `exists` 查询。你可以通过在表名前面添加一个连接名称来实现这个效果。\r\n\r\n    'email' => 'exists:connection.staff,email'\r\n\r\n你可以明确指定 Eloquent 模型，而不是直接指定表名：\r\n\r\n    'user_id' => 'exists:App\\Models\\User,id'\r\n\r\n如果你想要自定义一个执行查询的验证规则，你可以使用 `Rule` 类去流畅地定义规则。在这个例子中，我们也将指定验证规则为一个数组，而不再是使用 `|` 分割他们：\r\n\r\n    use Illuminate\\Database\\Query\\Builder;\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'email' => [\r\n            'required',\r\n            Rule::exists('staff')->where(function (Builder $query) {\r\n                return $query->where('account_id', 1);\r\n            }),\r\n        ],\r\n    ]);\r\n\r\n您可以通过将列名作为 `exists` 方法的第二个参数来明确指定 `Rule::exists` 方法生成的 `exists` 规则应该使用的数据库列名：\r\n\r\n    'state' => Rule::exists('states', 'abbreviation'),\r\n\r\n\r\n\r\n<a name=\"rule-file\"></a>\r\n#### file\r\n\r\n要验证的字段必须是一个成功的已经上传的文件。\r\n\r\n<a name=\"rule-filled\"></a>\r\n#### filled\r\n\r\n当字段存在时，要验证的字段必须是一个非空的。\r\n\r\n<a name=\"rule-gt\"></a>\r\n#### gt:_field_\r\n\r\n要验证的字段必须要大于给定的字段。这两个字段必须是同一个类型。字符串、数字、数组和文件都使用 [`size`](#rule-size) 进行相同的评估。\r\n\r\n<a name=\"rule-gte\"></a>\r\n#### gte:_field_\r\n\r\n要验证的字段必须要大于或等于给定的字段。这两个字段必须是同一个类型。字符串、数字、数组和文件都使用 [`size`](#rule-size) 进行相同的评估。\r\n\r\n<a name=\"rule-image\"></a>\r\n#### image\r\n\r\n正在验证的文件必须是图像（jpg、jpeg、png、bmp、gif、svg 或 webp）。\r\n\r\n<a name=\"rule-in\"></a>\r\n#### in:_foo_,_bar_,...\r\n\r\n验证字段必须包含在给定的值列表中。由于此规则通常要求你 `implode` 数组，因此可以使用 `Rule::in` 方法来流畅地构造规则:\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'zones' => [\r\n            'required',\r\n            Rule::in(['first-zone', 'second-zone']),\r\n        ],\r\n    ]);\r\n\r\n当 `in` 规则与 `array` 规则组合使用时，输入数组中的每个值都必须出现在提供给 `in` 规则的值列表中。 在以下示例中，输入数组中的`LAS` 机场代码无效，因为它不包含在提供给 `in` 规则的机场列表中：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    $input = [\r\n        'airports' => ['NYC', 'LAS'],\r\n    ];\r\n\r\n    Validator::make($input, [\r\n        'airports' => [\r\n            'required',\r\n            'array',\r\n        ],\r\n        'airports.*' => Rule::in(['NYC', 'LIT']),\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"rule-in-array\"></a>\r\n#### in_array:_anotherfield_.*\r\n\r\n验证的字段必须存在于_anotherfield_的值中。\r\n\r\n<a name=\"rule-integer\"></a>\r\n#### integer\r\n\r\n验证的字段必须是一个整数。\r\n\r\n**警告**\r\n这个验证规则并不会验证输入是否为\"integer\"变量类型，它只会验证输入是否为 PHP 的 `FILTER_VALIDATE_INT` 规则接受的类型。如果你需要验证输入是否为数字，请结合 [numeric](#rule-numeric) 验证规则使用。\r\n\r\n<a name=\"rule-ip\"></a>\r\n#### ip\r\n\r\n验证的字段必须是一个 IP 地址。\r\n\r\n<a name=\"ipv4\"></a>\r\n#### ipv4\r\n\r\n验证的字段必须是一个 IPv4 地址。\r\n\r\n<a name=\"ipv6\"></a>\r\n#### ipv6\r\n\r\n验证的字段必须是一个 IPv6 地址。\r\n\r\n<a name=\"rule-json\"></a>\r\n#### json\r\n\r\n验证的字段必须是一个有效的 JSON 字符串。\r\n\r\n<a name=\"rule-lt\"></a>\r\n#### lt:_field_\r\n\r\n验证的字段必须小于给定的 *field* 字段。两个字段必须是相同的类型。字符串、数字、数组和文件的处理方式与 [`size`](#rule-size) 规则相同。\r\n\r\n<a name=\"rule-lte\"></a>\r\n#### lte:_field_\r\n\r\n验证的字段必须小于或等于给定的 *field* 字段。两个字段必须是相同的类型。字符串、数字、数组和文件的处理方式与 [`size`](#rule-size) 规则相同。\r\n\r\n<a name=\"rule-lowercase\"></a>\r\n#### lowercase\r\n\r\n验证的字段必须是小写的。\r\n\r\n<a name=\"rule-mac\"></a>\r\n#### mac_address\r\n\r\n验证的字段必须是一个 MAC 地址。\r\n\r\n\r\n\r\n<a name=\"rule-max\"></a>\r\n#### max:_value_\r\n\r\n验证的字段的值必须小于或等于最大值 *value*。字符串、数字、数组和文件的处理方式与 [`size`](#rule-size) 规则相同。\r\n\r\n<a name=\"rule-max-digits\"></a>\r\n#### max_digits:_value_\r\n\r\n验证的整数必须具有最大长度 value。\r\n\r\n<a name=\"rule-mimetypes\"></a>\r\n#### mimetypes:_text/plain_,...\r\n\r\n验证的文件必须匹配给定的 MIME 类型之一：\r\n\r\n    'video' => 'mimetypes:video/avi,video/mpeg,video/quicktime'\r\n\r\n为了确定上传文件的 MIME 类型，将读取文件内容并尝试猜测 MIME 类型，这可能与客户端提供的 MIME 类型不同。\r\n\r\n<a name=\"rule-mimes\"></a>\r\n#### mimes:_foo_,_bar_,...\r\n\r\n验证的文件必须具有与列出的扩展名之一对应的 MIME 类型。\r\n\r\n<a name=\"basic-usage-of-mime-rule\"></a>\r\n#### MIME 规则的基本用法\r\n\r\n    'photo' => 'mimes:jpg,bmp,png'\r\n\r\n尽管您只需要指定扩展名，但该规则实际上通过读取文件内容并猜测其 MIME 类型来验证文件的 MIME 类型。可以在以下位置找到 MIME 类型及其相应扩展名的完整列表：\r\n\r\n[https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types](https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types)\r\n\r\n<a name=\"rule-min\"></a>\r\n#### min:_value_\r\n\r\n验证的字段的值必须大于或等于最小值 *value*。字符串、数字、数组和文件的处理方式与 [`size`](#rule-size) 规则相同。\r\n\r\n\r\n\r\n<a name=\"rule-min-digits\"></a>\r\n#### min_digits:_value_\r\n\r\n 验证的整数必须具有至少_value_位数。\r\n\r\n<a name=\"rule-multiple-of\"></a>\r\n#### multiple_of:_value_\r\n\r\n 验证的字段必须是_value_的倍数。\r\n\r\n<a name=\"rule-missing\"></a>\r\n#### missing\r\n\r\n 验证的字段在输入数据中必须不存在。\r\n\r\n <a name=\"rule-missing-if\"></a>\r\n #### missing_if:_anotherfield_,_value_,...\r\n\r\n 如果_anotherfield_字段等于任何_value_，则验证的字段必须不存在。\r\n\r\n <a name=\"rule-missing-unless\"></a>\r\n #### missing_unless:_anotherfield_,_value_\r\n\r\n 验证的字段必须不存在，除非_anotherfield_字段等于任何_value_。\r\n\r\n <a name=\"rule-missing-with\"></a>\r\n #### missing_with:_foo_,_bar_,...\r\n\r\n 如果任何其他指定的字段存在，则验证的字段必须不存在。\r\n\r\n <a name=\"rule-missing-with-all\"></a>\r\n #### missing_with_all:_foo_,_bar_,...\r\n\r\n 如果所有其他指定的字段都存在，则验证的字段必须不存在。\r\n\r\n<a name=\"rule-not-in\"></a>\r\n#### not_in:_foo_,_bar_,...\r\n\r\n验证的字段不能包含在给定值列表中。可以使用`Rule::notIn`方法流畅地构建规则：\r\n\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'toppings' => [\r\n            'required',\r\n            Rule::notIn(['sprinkles', 'cherries']),\r\n        ],\r\n    ]);\r\n\r\n<a name=\"rule-not-regex\"></a>\r\n#### not_regex:_pattern_\r\n\r\n验证的字段必须不匹配给定的正则表达式。\r\n\r\n在内部，此规则使用PHP的`preg_match`函数。指定的模式应遵守`preg_match`所需的相同格式要求，因此也应包括有效的分隔符。例如：`'email' => 'not_regex:/^.+$/i'`。\r\n\r\n**警告** 使用`regex` / `not_regex`模式时，可能需要使用数组指定验证规则，而不是使用`|`分隔符，特别是如果正则表达式包含`|`字符。\r\n\r\n\r\n\r\n<a name=\"rule-nullable\"></a>\r\n#### nullable\r\n\r\n需要验证的字段可以为 null。\r\n\r\n<a name=\"rule-numeric\"></a>\r\n#### numeric\r\n\r\n需要验证的字段必须是[数字类型](https://www.php.net/manual/en/function.is-numeric.php)。\r\n\r\n<a name=\"rule-password\"></a>\r\n#### password\r\n\r\n需要验证的字段必须与已认证用户的密码相匹配。\r\n\r\n>**警告**\r\n> 这个规则在 Laravel 9 中被重命名为 `current_password` 并计划删除，请改用 [Current Password](#rule-current-password) 规则。\r\n\r\n<a name=\"rule-present\"></a>\r\n#### present\r\n\r\n需要验证的字段必须存在于输入数据中。\r\n\r\n<a name=\"rule-prohibited\"></a>\r\n#### prohibited\r\n\r\n需要验证的字段必须不存在或为空。如果符合以下条件之一，字段将被认为是“空”：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n-   值为 `null`。\r\n-   值为空字符串。\r\n-   值为空数组或空的可计数对象。\r\n-   值为上传文件，但文件路径为空。\r\n\r\n</div>\r\n\r\n<a name=\"rule-prohibited-if\"></a>\r\n#### prohibited_if:_anotherfield_,_value_,...\r\n\r\n如果 anotherfield 字段等于任何 value，则需要验证的字段必须不存在或为空。如果符合以下条件之一，字段将被认为是“空”：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n-   值为 `null`。\r\n-   值为空字符串。\r\n-   值为空数组或空的可计数对象。\r\n-   值为上传文件，但文件路径为空。\r\n\r\n</div>\r\n\r\n如果需要复杂的条件禁止逻辑，则可以使用 `Rule::prohibitedIf` 方法。该方法接受一个布尔值或一个闭包。当给定一个闭包时，闭包应返回 `true` 或 `false`，以指示是否应禁止验证字段：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($request->all(), [\r\n        'role_id' => Rule::prohibitedIf($request->user()->is_admin),\r\n    ]);\r\n\r\n    Validator::make($request->all(), [\r\n        'role_id' => Rule::prohibitedIf(fn () => $request->user()->is_admin),\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"rule-prohibited-unless\"></a>\r\n#### prohibited_unless:_anotherfield_,_value_,...\r\n\r\n在 anotherfield 字段等于任何 value 时，验证的字段必须为空或缺失。如果一个字段符合以下任一标准，则它被认为是“空”的：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n-   值为 `null`。\r\n-   值为空字符串。\r\n-   值为一个空数组或一个空的 `Countable` 对象。\r\n-   值为上传文件且路径为空。\r\n\r\n</div>\r\n\r\n<a name=\"rule-prohibits\"></a>\r\n#### prohibits:_anotherfield_,...\r\n\r\n如果验证的字段不为空或缺失，则 anotherfield 中的所有字段都必须为空或缺失。如果一个字段符合以下任一标准，则它被认为是“空”的：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n-   值为 `null`。\r\n-   值为空字符串。\r\n-   值为一个空数组或一个空的 `Countable` 对象。\r\n-   值为上传文件且路径为空。\r\n\r\n</div>\r\n\r\n<a name=\"rule-regex\"></a>\r\n#### regex:_pattern_\r\n\r\n验证的字段必须匹配给定的正则表达式。\r\n\r\n在内部，此规则使用 PHP 的 `preg_match` 函数。指定的模式应遵循 `preg_match` 所需的相同格式，并且也包括有效的分隔符。例如：`'email' => 'regex:/^.+@.+$/i'`。\r\n\r\n> **警告**\r\n> 当使用 `regex` / `not_regex` 模式时，可能需要使用数组指定规则而不是使用 `|` 分隔符，特别是如果正则表达式包含 `|` 字符。\r\n\r\n<a name=\"rule-required\"></a>\r\n#### required\r\n\r\n验证的字段必须出现在输入数据中且不为空。如果一个字段符合以下任一标准，则它被认为是“空”的：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n-   值为 `null`。\r\n-   值为空字符串。\r\n-   值为一个空数组或一个空的 `Countable` 对象。\r\n-   值为上传文件且路径为空。\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"rule-required-if\"></a>\r\n#### required_if:_anotherfield_,_value_,...\r\n\r\n如果 anotherfield 字段的值等于任何 value 值，则验证的字段必须存在且不为空。\r\n\r\n如果您想要构建更复杂的 `required_if` 规则条件，可以使用 `Rule::requiredIf` 方法。该方法接受一个布尔值或闭包。当传递一个闭包时，闭包应返回 `true` 或 `false` 来指示是否需要验证的字段：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($request->all(), [\r\n        'role_id' => Rule::requiredIf($request->user()->is_admin),\r\n    ]);\r\n\r\n    Validator::make($request->all(), [\r\n        'role_id' => Rule::requiredIf(fn () => $request->user()->is_admin),\r\n    ]);\r\n\r\n<a name=\"rule-required-unless\"></a>\r\n#### required_unless:_anotherfield_,_value_,...\r\n\r\n如果 *anotherfield* 字段的值不等于任何 *value* 值，则验证的字段必须存在且不为空。这也意味着，除非 *anotherfield* 字段等于任何 *value* 值，否则必须在请求数据中包含 *anotherfield* 字段。如果 *value* 的值为 `null` （`required_unless:name,null`），则必须验证该字段，除非比较字段是 `null` 或比较字段不存在于请求数据中。\r\n\r\n<a name=\"rule-required-with\"></a>\r\n#### required_with:_foo_,_bar_,...\r\n\r\n仅当任何其他指定字段存在且不为空时，才需要验证字段存在且不为空。\r\n\r\n<a name=\"rule-required-with-all\"></a>\r\n#### required_with_all:_foo_,_bar_,...\r\n\r\n仅当所有其他指定字段存在且不为空时，才需要验证字段存在且不为空。\r\n\r\n<a name=\"rule-required-without\"></a>\r\n\r\n\r\n#### required_without:_foo_,_bar_,...\r\n\r\n验证的字段仅在任一其他指定字段为空或不存在时，必须存在且不为空。\r\n\r\n<a name=\"rule-required-without-all\"></a>\r\n#### required_without_all:_foo_,_bar_,...\r\n\r\n验证的字段仅在所有其他指定字段为空或不存在时，必须存在且不为空。\r\n\r\n<a name=\"rule-required-array-keys\"></a>\r\n#### required_array_keys:_foo_,_bar_,...\r\n\r\n验证的字段必须是一个数组，并且必须至少包含指定的键。\r\n\r\n<a name=\"rule-same\"></a>\r\n#### same:_field_\r\n\r\n给定的字段必须与验证的字段匹配。\r\n\r\n<a name=\"rule-size\"></a>\r\n#### size:_value_\r\n\r\n验证的字段必须具有与给定的_value相匹配的大小。对于字符串数据，value 对应于字符数。对于数字数据，value 对应于给定的整数值（该属性还必须具有 numeric 或 integer 规则）。对于数组，size 对应于数组的 count。对于文件，size 对应于文件大小（以千字节为单位）。让我们看一些例子：\r\n\r\n    // Validate that a string is exactly 12 characters long...\r\n    'title' => 'size:12';\r\n\r\n    // Validate that a provided integer equals 10...\r\n    'seats' => 'integer|size:10';\r\n\r\n    // Validate that an array has exactly 5 elements...\r\n    'tags' => 'array|size:5';\r\n\r\n    // Validate that an uploaded file is exactly 512 kilobytes...\r\n    'image' => 'file|size:512';\r\n\r\n<a name=\"rule-starts-with\"></a>\r\n#### starts_with:_foo_,_bar_,...\r\n\r\n验证的字段必须以给定值之一开头。\r\n\r\n<a name=\"rule-string\"></a>\r\n#### string\r\n\r\n验证的字段必须是一个字符串。如果您希望允许字段也可以为 `null`，则应将 `nullable` 规则分配给该字段。\r\n\r\n\r\n\r\n<a name=\"rule-timezone\"></a>\r\n#### 时区\r\n\r\n验证字段必须是一个有效的时区标识符，符合 `timezone_identifiers_list` PHP 函数的要求。\r\n\r\n<a name=\"rule-unique\"></a>\r\n#### unique:_table_,_column_\r\n\r\n验证字段在给定的数据库表中必须不存在。\r\n\r\n**指定自定义表/列名:**\r\n\r\n可以指定应使用哪个 Eloquent 模型来确定表名，而不是直接指定表名：\r\n\r\n    'email' => 'unique:App\\Models\\User,email_address'\r\n\r\n`column` 选项可用于指定字段对应的数据库列。如果未指定 `column` 选项，则使用验证字段的名称。\r\n\r\n    'email' => 'unique:users,email_address'\r\n\r\n**指定自定义数据库连接**\r\n\r\n有时，您可能需要为 Validator 执行的数据库查询设置自定义连接。为此，可以在表名之前添加连接名称：\r\n\r\n    'email' => 'unique:connection.users,email_address'\r\n\r\n**强制唯一规则忽略给定的 ID:**\r\n\r\n有时，您可能希望在唯一验证期间忽略给定的 ID。例如，考虑一个“更新个人资料”屏幕，其中包括用户的姓名、电子邮件地址和位置。您可能希望验证电子邮件地址是否唯一。但是，如果用户仅更改了名称字段而未更改电子邮件字段，则不希望因为用户已经拥有相关电子邮件地址而抛出验证错误。\r\n\r\n要指示验证器忽略用户的 ID，我们将使用 `Rule` 类来流畅地定义规则。在此示例中，我们还将指定验证规则作为数组，而不是使用 `|` 字符来分隔规则：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    Validator::make($data, [\r\n        'email' => [\r\n            'required',\r\n            Rule::unique('users')->ignore($user->id),\r\n        ],\r\n    ]);\r\n\r\n> **警告**\r\n> 您不应将任何用户控制的请求输入传递到 `ignore` 方法中。相反，您应仅传递系统生成的唯一 ID，例如 Eloquent 模型实例的自增 ID 或 UUID。否则，您的应用程序将容易受到 SQL 注入攻击。\r\n\r\n\r\n\r\n不需要将模型键的值传递给 `ignore` 方法，您也可以传递整个模型实例。Laravel 将自动从模型中提取键：\r\n\r\n    Rule::unique('users')->ignore($user)\r\n\r\n如果您的表使用的是除 `id` 以外的主键列名，可以在调用 `ignore` 方法时指定列的名称：\r\n\r\n    Rule::unique('users')->ignore($user->id, 'user_id')\r\n\r\n默认情况下，`unique` 规则将检查与正在验证的属性名称匹配的列的唯一性。但是，您可以将不同的列名称作为第二个参数传递给 `unique` 方法：\r\n\r\n    Rule::unique('users', 'email_address')->ignore($user->id)\r\n\r\n**添加额外的查询条件：**\r\n\r\n您可以通过自定义查询并使用 `where` 方法来指定其他查询条件。例如，让我们添加一个查询条件，将查询范围限定为仅搜索具有 `account_id` 列值为 `1` 的记录：\r\n\r\n    'email' => Rule::unique('users')->where(fn (Builder $query) => $query->where('account_id', 1))\r\n\r\n<a name=\"rule-uppercase\"></a>\r\n#### uppercase\r\n\r\n验证字段必须为大写。\r\n\r\n<a name=\"rule-url\"></a>\r\n#### url\r\n\r\n验证字段必须为有效的 URL。\r\n\r\n<a name=\"rule-ulid\"></a>\r\n#### ulid\r\n\r\n验证字段必须为有效的[通用唯一词典排序标识符](https://github.com/ulid/spec)（ULID）。\r\n\r\n<a name=\"rule-uuid\"></a>\r\n#### uuid\r\n\r\n验证字段必须为有效的 RFC 4122（版本1、3、4或5）通用唯一标识符（UUID）。\r\n\r\n<a name=\"conditionally-adding-rules\"></a>\r\n## 有条件添加规则\r\n\r\n<a name=\"skipping-validation-when-fields-have-certain-values\"></a>\r\n#### 当字段具有特定值时跳过验证\r\n\r\n\r\n\r\n有时，您可能希望在给定字段具有特定值时不验证另一个字段。您可以使用`exclude_if`验证规则来实现这一点。在下面的示例中，如果`has_appointment`字段的值为`false`，则不会验证`appointment_date`和`doctor_name`字段：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $validator = Validator::make($data, [\r\n        'has_appointment' => 'required|boolean',\r\n        'appointment_date' => 'exclude_if:has_appointment,false|required|date',\r\n        'doctor_name' => 'exclude_if:has_appointment,false|required|string',\r\n    ]);\r\n\r\n或者，您可以使用`exclude_unless`规则，除非另一个字段具有给定值，否则不验证给定字段：\r\n\r\n    $validator = Validator::make($data, [\r\n        'has_appointment' => 'required|boolean',\r\n        'appointment_date' => 'exclude_unless:has_appointment,true|required|date',\r\n        'doctor_name' => 'exclude_unless:has_appointment,true|required|string',\r\n    ]);\r\n\r\n<a name=\"validating-when-present\"></a>\r\n#### 仅在字段存在时验证\r\n\r\n在某些情况下，您可能希望仅在验证数据中存在该字段时才对该字段运行验证检查。要快速实现此操作，请将`sometimes`规则添加到您的规则列表中：\r\n\r\n    $v = Validator::make($data, [\r\n        'email' => 'sometimes|required|email',\r\n    ]);\r\n\r\n在上面的示例中，如果`$data`数组中存在`email`字段，则仅对其进行验证。\r\n\r\n> **注意**\r\n> 如果您尝试验证始终应存在但可能为空的字段，请查看[有关可选字段的说明](#a-note-on-optional-fields)。\r\n\r\n<a name=\"complex-conditional-validation\"></a>\r\n#### 复杂条件验证\r\n\r\n有时，您可能希望根据更复杂的条件逻辑添加验证规则。例如，您可能只希望在另一个字段的值大于100时要求给定字段。或者，只有在存在另一个字段时，两个字段才需要具有给定值。添加这些验证规则不必是痛苦的。首先，使用永不改变的静态规则创建一个`Validator`实例：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'email' => 'required|email',\r\n        'games' => 'required|numeric',\r\n    ]);\r\n\r\n\r\n\r\n假设我们的 Web 应用是给游戏收藏家使用的。如果一个游戏收藏家在我们的应用上注册，并且他们拥有超过 100 个游戏，我们想要让他们解释为什么拥有这么多游戏。例如，也许他们经营着一家游戏转售店，或者他们只是喜欢收集游戏。为了有条件地添加这个要求，我们可以在 `Validator` 实例上使用 `sometimes` 方法。\r\n\r\n    use Illuminate\\Support\\Fluent;\r\n\r\n    $validator->sometimes('reason', 'required|max:500', function (Fluent $input) {\r\n        return $input->games >= 100;\r\n    });\r\n\r\n传递给 `sometimes` 方法的第一个参数是我们有条件验证的字段的名称。第二个参数是我们想要添加的规则列表。如果传递作为第三个参数的闭包返回 `true`，这些规则将被添加。使用此方法可以轻松构建复杂的条件验证。您甚至可以同时为多个字段添加条件验证：\r\n\r\n    $validator->sometimes(['reason', 'cost'], 'required', function (Fluent $input) {\r\n        return $input->games >= 100;\r\n    });\r\n\r\n> **注意**\r\n> 传递给您的闭包的 `$input` 参数将是 `Illuminate\\Support\\Fluent` 的一个实例，可用于访问您正在验证的输入和文件。\r\n\r\n<a name=\"complex-conditional-array-validation\"></a>\r\n#### 复杂条件数组验证\r\n\r\n有时，您可能想要基于同一嵌套数组中的另一个字段验证一个字段，而您不知道其索引。在这种情况下，您可以允许您的闭包接收第二个参数，该参数将是正在验证的当前个体数组项：\r\n\r\n    $input = [\r\n        'channels' => [\r\n            [\r\n                'type' => 'email',\r\n                'address' => 'abigail@example.com',\r\n            ],\r\n            [\r\n                'type' => 'url',\r\n                'address' => 'https://example.com',\r\n            ],\r\n        ],\r\n    ];\r\n\r\n    $validator->sometimes('channels.*.address', 'email', function (Fluent $input, Fluent $item) {\r\n        return $item->type === 'email';\r\n    });\r\n\r\n    $validator->sometimes('channels.*.address', 'url', function (Fluent $input, Fluent $item) {\r\n        return $item->type !== 'email';\r\n    });\r\n\r\n\r\n\r\n像传递给闭包的 `$input` 参数一样，当属性数据是数组时，`$item` 参数是 `Illuminate\\Support\\Fluent` 的实例；否则，它是一个字符串。\r\n\r\n<a name=\"validating-arrays\"></a>\r\n## 验证数组\r\n\r\n正如在 [`array` 验证规则文档](#rule-array) 中讨论的那样，`array` 规则接受允许的数组键列表。如果数组中存在任何额外的键，则验证将失败：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $input = [\r\n        'user' => [\r\n            'name' => 'Taylor Otwell',\r\n            'username' => 'taylorotwell',\r\n            'admin' => true,\r\n        ],\r\n    ];\r\n\r\n    Validator::make($input, [\r\n        'user' => 'array:username,locale',\r\n    ]);\r\n\r\n通常情况下，您应该始终指定允许出现在数组中的键。否则，验证器的 `validate` 和 `validated` 方法将返回所有经过验证的数据，包括数组及其所有键，即使这些键没有通过其他嵌套数组验证规则进行验证。\r\n\r\n<a name=\"validating-nested-array-input\"></a>\r\n### 验证嵌套数组输入\r\n\r\n验证基于嵌套数组的表单输入字段并不需要很痛苦。您可以使用 \"点符号\" 来验证数组中的属性。例如，如果传入的 HTTP 请求包含一个 `photos[profile]` 字段，您可以像这样验证它：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'photos.profile' => 'required|image',\r\n    ]);\r\n\r\n您还可以验证数组中的每个元素。例如，要验证给定数组输入字段中的每个电子邮件是否唯一，可以执行以下操作：\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'person.*.email' => 'email|unique:users',\r\n        'person.*.first_name' => 'required_with:person.*.last_name',\r\n    ]);\r\n\r\n\r\n\r\n同样，您可以在语言文件中指定[自定义验证消息](#custom-messages-for-specific-attributes)时使用 `*` 字符，使得针对基于数组的字段使用单个验证消息变得非常简单：\r\n\r\n    'custom' => [\r\n        'person.*.email' => [\r\n            'unique' => 'Each person must have a unique email address',\r\n        ]\r\n    ],\r\n\r\n<a name=\"accessing-nested-array-data\"></a>\r\n#### 访问嵌套数组数据\r\n\r\n有时，当为属性分配验证规则时，您可能需要访问给定嵌套数组元素的值。您可以使用 `Rule::forEach` 方法来实现此目的。`forEach` 方法接受一个闭包，在验证数组属性的每次迭代中调用该闭包，并接收属性的值和显式的完全展开的属性名称。闭包应该返回要分配给数组元素的规则数组：\r\n\r\n    use App\\Rules\\HasPermission;\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rule;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'companies.*.id' => Rule::forEach(function (string|null $value, string $attribute) {\r\n            return [\r\n                Rule::exists(Company::class, 'id'),\r\n                new HasPermission('manage-company', $value),\r\n            ];\r\n        }),\r\n    ]);\r\n\r\n<a name=\"error-message-indexes-and-positions\"></a>\r\n### 错误消息索引和位置\r\n\r\n在验证数组时，您可能希望在应用程序显示的错误消息中引用失败验证的特定项的索引或位置。为了实现这一点，您可以在[自定义验证消息](#manual-customizing-the-error-messages)中包含 `:index`（从 `0` 开始）和 `:position`（从 `1` 开始）占位符：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $input = [\r\n        'photos' => [\r\n            [\r\n                'name' => 'BeachVacation.jpg',\r\n                'description' => '我的海滩假期照片！',\r\n            ],\r\n            [\r\n                'name' => 'GrandCanyon.jpg',\r\n                'description' => '',\r\n            ],\r\n        ],\r\n    ];\r\n\r\n    Validator::validate($input, [\r\n        'photos.*.description' => 'required',\r\n    ], [\r\n        'photos.*.description.required' => '请描述第 :position 张照片。',\r\n    ]);\r\n\r\n\r\n\r\n上述示例将验证失败，并且用户会看到以下错误：“请描述第 2 张照片。”\r\n\r\n<a name=\"validating-files\"></a>\r\n## 验证文件\r\n\r\nLaravel提供了多种上传文件的验证规则，如`mimes`、`image`、`min`和`max`。虽然你可以在验证文件时单独指定这些规则，但Laravel还是提供了一个流畅的文件验证规则生成器，你可能会觉得更方便：\r\n\r\n```\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rules\\File;\r\n\r\n    Validator::validate($input, [\r\n        'attachment' => [\r\n            'required',\r\n            File::types(['mp3', 'wav'])\r\n                ->min(1024)\r\n                ->max(12 * 1024),\r\n        ],\r\n    ]);\r\n```\r\n\r\n如果你的程序允许用户上传图片，那么可以使用`File` 规则的 `image` 构造方法来指定上传的文件应该是图片。另外， `dimensions` 规则可用于限制图片的尺寸：\r\n\r\n```\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rules\\File;\r\n\r\n    Validator::validate($input, [\r\n        'photo' => [\r\n            'required',\r\n            File::image()\r\n                ->min(1024)\r\n                ->max(12 * 1024)\r\n                ->dimensions(Rule::dimensions()->maxWidth(1000)->maxHeight(500)),\r\n        ],\r\n    ]);\r\n```\r\n\r\n> **技巧**\r\n> 更多验证图片尺寸的信息，请参见[尺寸规则文档](#rule-dimensions)。\r\n\r\n<a name=\"validating-files-file-types\"></a>\r\n#### 文件类型\r\n\r\n尽管在调用 `types` 方法时只需要指定扩展名，但该方法实际上是通过读取文件的内容并猜测其MIME类型来验证文件的MIME类型的。MIME类型及其相应扩展的完整列表可以在以下链接中找到：\r\n\r\n[https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types](https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types)\r\n\r\n\r\n\r\n<a name=\"validating-passwords\"></a>\r\n## 验证密码\r\n\r\n为确保密码具有足够的复杂性，你可以使用 Laravel 的 `password` 规则对象：\r\n\r\n```\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n    use Illuminate\\Validation\\Rules\\Password;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'password' => ['required', 'confirmed', Password::min(8)],\r\n    ]);\r\n```\r\n\r\n`Password` 规则对象允许你轻松自定义应用程序的密码复杂性要求，例如指定密码至少需要一个字母、数字、符号或混合大小写的字符：\r\n\r\n```\r\n    // 至少需要 8 个字符...\r\n    Password::min(8)\r\n\r\n    // 至少需要一个字母...\r\n    Password::min(8)->letters()\r\n\r\n    // 至少需要一个大写字母和一个小写字母...\r\n    Password::min(8)->mixedCase()\r\n\r\n    // 至少需要一个数字...\r\n    Password::min(8)->numbers()\r\n\r\n    // 至少需要一个符号...\r\n    Password::min(8)->symbols()\r\n```\r\n\r\n此外，你可以使用 `uncompromised` 方法确保密码没有在公共密码数据泄露事件中被泄露：\r\n\r\n```\r\n    Password::min(8)->uncompromised()\r\n```\r\n\r\n在内部，`Password` 规则对象使用 [k-Anonymity](https://en.wikipedia.org/wiki/K-anonymity) 模型来确定密码是否已通过 [haveibeenpwned.com](https://haveibeenpwned.com)  服务而不牺牲用户的隐私或安全。\r\n\r\n默认情况下，如果密码在数据泄露中至少出现一次，则会被视为已泄露。你可以使用 `uncompromised` 方法的第一个参数自定义此阈值\r\n\r\n```\r\n    // Ensure the password appears less than 3 times in the same data leak...\r\n    Password::min(8)->uncompromised(3);\r\n```\r\n\r\n当然，你可以将上面示例中的所有方法链接起来：\r\n\r\n```\r\n    Password::min(8)\r\n        ->letters()\r\n        ->mixedCase()\r\n        ->numbers()\r\n        ->symbols()\r\n        ->uncompromised()\r\n```\r\n\r\n\r\n<a name=\"defining-default-password-rules\"></a>\r\n#### 定义默认密码规则\r\n\r\n你可能会发现在应用程序的单个位置指定密码的默认验证规则很方便。你可以使用接受闭包的 `Password::defaults` 方法轻松完成此操作。给 `defaults` 方法的闭包应该返回密码规则的默认配置。通常，应该在应用程序服务提供者之一的 `boot` 方法中调用 `defaults` 规则：\r\n\r\n```php\r\nuse Illuminate\\Validation\\Rules\\Password;\r\n\r\n/**\r\n * 引导任何应用程序服务\r\n */\r\npublic function boot(): void\r\n{\r\n    Password::defaults(function () {\r\n        $rule = Password::min(8);\r\n\r\n        return $this->app->isProduction()\r\n                    ? $rule->mixedCase()->uncompromised()\r\n                    : $rule;\r\n    });\r\n}\r\n```\r\n\r\n然后，当你想将默认规则应用于正在验证的特定密码时，你可以调用不带参数的 `defaults` 方法：\r\n\r\n    'password' => ['required', Password::defaults()],\r\n\r\n有时，你可能希望将其他验证规则附加到默认密码验证规则。 你可以使用 `rules` 方法来完成此操作：\r\n\r\n    use App\\Rules\\ZxcvbnRule;\r\n\r\n    Password::defaults(function () {\r\n        $rule = Password::min(8)->rules([new ZxcvbnRule]);\r\n\r\n        // ...\r\n    });\r\n\r\n<a name=\"custom-validation-rules\"></a>\r\n## 自定义验证规则\r\n\r\n<a name=\"using-rule-objects\"></a>\r\n### 使用规则对象\r\n\r\nLaravel 提供了各种有用的验证规则；但是，你可能希望指定一些你自己的。 注册自定义验证规则的一种方法是使用规则对象。 要生成新的规则对象，你可以使用 `make:rule` Artisan 命令。 让我们使用这个命令生成一个规则来验证字符串是否为大写。 Laravel 会将新规则放在 `app/Rules` 目录中。 如果这个目录不存在，Laravel 会在你执行 Artisan 命令创建规则时创建它：\r\n\r\n```shell\r\nphp artisan make:rule Uppercase\r\n```\r\n\r\n\r\n\r\n一旦规则被创建，我们就可以定义其行为。一个规则对象包含一个单一的方法：`validate`。该方法接收属性名、其值和一个回调函数，如果验证失败应该调用该回调函数并传入验证错误消息：\r\n\r\n    <?php\r\n\r\n    namespace App\\Rules;\r\n\r\n    use Closure;\r\n    use Illuminate\\Contracts\\Validation\\ValidationRule;\r\n\r\n    class Uppercase implements ValidationRule\r\n    {\r\n        /**\r\n         * Run the validation rule.\r\n         */\r\n        public function validate(string $attribute, mixed $value, Closure $fail): void\r\n        {\r\n            if (strtoupper($value) !== $value) {\r\n                $fail('The :attribute must be uppercase.');\r\n            }\r\n        }\r\n    }\r\n\r\n一旦定义了规则，您可以通过将规则对象的实例与其他验证规则一起传递来将其附加到验证器：\r\n\r\n    use App\\Rules\\Uppercase;\r\n\r\n    $request->validate([\r\n        'name' => ['required', 'string', new Uppercase],\r\n    ]);\r\n\r\n#### 验证消息\r\n\r\n您可以不提供 `$fail` 闭包的字面错误消息，而是提供一个[翻译字符串键](https://chat.openai.com/docs/laravel/10.x/localization)，并指示 Laravel 翻译错误消息：\r\n\r\n    if (strtoupper($value) !== $value) {\r\n        $fail('validation.uppercase')->translate();\r\n    }\r\n\r\n如有必要，您可以通过第一个和第二个参数分别提供占位符替换和首选语言来调用 `translate` 方法：\r\n\r\n    $fail('validation.location')->translate([\r\n        'value' => $this->value,\r\n    ], 'fr')\r\n\r\n#### 访问额外数据\r\n\r\n如果您的自定义验证规则类需要访问正在验证的所有其他数据，则规则类可以实现 `Illuminate\\Contracts\\Validation\\DataAwareRule` 接口。此接口要求您的类定义一个 `setData` 方法。Laravel 会自动调用此方法（在验证继续之前）并传入所有正在验证的数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Rules;\r\n\r\n    use Illuminate\\Contracts\\Validation\\DataAwareRule;\r\n    use Illuminate\\Contracts\\Validation\\ValidationRule;\r\n\r\n    class Uppercase implements DataAwareRule, ValidationRule\r\n    {\r\n        /**\r\n         * 正在验证的所有数据。\r\n         *\r\n         * @var array<string, mixed>\r\n         */\r\n        protected $data = [];\r\n\r\n        // ...\r\n\r\n        /**\r\n         * 设置正在验证的数据。\r\n         *\r\n         * @param  array<string, mixed>  $data\r\n         */\r\n        public function setData(array $data): static\r\n        {\r\n            $this->data = $data;\r\n\r\n            return $this;\r\n        }\r\n    }\r\n\r\n\r\n\r\n或者，如果您的验证规则需要访问执行验证的验证器实例，则可以实现`ValidatorAwareRule`接口：\r\n\r\n    <?php\r\n\r\n    namespace App\\Rules;\r\n\r\n    use Illuminate\\Contracts\\Validation\\ValidationRule;\r\n    use Illuminate\\Contracts\\Validation\\ValidatorAwareRule;\r\n    use Illuminate\\Validation\\Validator;\r\n\r\n    class Uppercase implements ValidationRule, ValidatorAwareRule\r\n    {\r\n        /**\r\n         * 验证器实例.\r\n         *\r\n         * @var \\Illuminate\\Validation\\Validator\r\n         */\r\n        protected $validator;\r\n\r\n        // ...\r\n\r\n        /**\r\n         * 设置当前验证器.\r\n         */\r\n        public function setValidator(Validator $validator): static\r\n        {\r\n            $this->validator = $validator;\r\n\r\n            return $this;\r\n        }\r\n    }\r\n\r\n<a name=\"using-closures\"></a>\r\n### 使用闭包函数\r\n\r\n如果您只需要在应用程序中一次使用自定义规则的功能，可以使用闭包函数而不是规则对象。闭包函数接收属性名称、属性值和 $fail 回调函数，如果验证失败，应该调用该函数：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $validator = Validator::make($request->all(), [\r\n        'title' => [\r\n            'required',\r\n            'max:255',\r\n            function (string $attribute, mixed $value, Closure $fail) {\r\n                if ($value === 'foo') {\r\n                    $fail(\"The {$attribute} is invalid.\");\r\n                }\r\n            },\r\n        ],\r\n    ]);\r\n\r\n<a name=\"implicit-rules\"></a>\r\n### 隐式规则\r\n\r\n默认情况下，当要验证的属性不存在或包含空字符串时，正常的验证规则，包括自定义规则，都不会执行。例如，[`unique`](#rule-unique) 规则不会针对空字符串运行：\r\n\r\n    use Illuminate\\Support\\Facades\\Validator;\r\n\r\n    $rules = ['name' => 'unique:users,name'];\r\n\r\n    $input = ['name' => ''];\r\n\r\n    Validator::make($input, $rules)->passes(); // true\r\n\r\n为了使自定义规则在属性为空时也运行，规则必须暗示该属性是必需的。您可以使用 make:rule Artisan 命令的 --implicit 选项快速生成新的隐式规则对象：\r\n\r\n```shell\r\nphp artisan make:rule Uppercase --implicit\r\n```\r\n\r\n> **警告 **  \r\n> 隐式规则仅 暗示 该属性是必需的。实际上，缺少或空属性是否无效取决于您。\r\n\r\n","p":"docs/validation.html"},{"t":"errors (错误处理)","d":"# 错误处理\r\n\r\n- [简介](#introduction)\r\n- [配置](#configuration)\r\n- [异常处理](#the-exception-handler)\r\n    - [报告异常](#reporting-exceptions)\r\n    - [异常日志级别](#exception-log-levels)\r\n    - [忽略指定类型异常](#ignoring-exceptions-by-type)\r\n    - [渲染异常](#rendering-exceptions)\r\n    - [Reportable & Renderable 异常](#renderable-exceptions)\r\n- [HTTP 异常](#http-exceptions)\r\n    - [自定义 HTTP 错误页面](#custom-http-error-pages)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 默认已经为我们配置好了错误和异常处理，我们在 App\\Exceptions\\Handler 类中触发异常并将响应返回给用户。在本文档中我们将深入探讨这个类。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n配置文件 config/app.php 中的 debug 配置项控制浏览器显示的错误信息数量。默认情况下，该配置项通过 .env 文件中的环境变量 APP_DEBUG 进行设置。\r\n\r\n对本地开发而言，你应该设置环境变量 APP_DEBUG 值为 true。在生产环境，该值应该被设置为 false。如果在生产环境被设置为 true，就有可能将一些敏感的配置值暴露给终端用户。\r\n\r\n<a name=\"the-exception-handler\"></a>\r\n## 异常处理器\r\n\r\n<a name=\"reporting-exceptions\"></a>\r\n### 报告异常\r\n\r\n所有异常都由 App\\Exceptions\\Handler 类处理。这个类包含了一个 register 方法用于注册自定义的异常报告器和渲染器回调，接下来我们会详细介绍这些概念。我们可以通过异常报告记录异常或者将它们发送给外部服务，比如 Flare、Bugsnag 以及 Sentry。默认情况下，会基于日志配置记录异常，不过，你也可以按照自己期望的方式进行自定义。\r\n\r\n例如，如果你需要以不同方式报告不同类型的异常，可以使用 reportable 方法注册一个闭包，该闭包会在给定类型异常需要被报告时执行。Laravel 会通过检查闭包的参数类型提示推断该闭包报告的异常类型：\r\n\r\n\r\n\r\n# 错误处理\r\n\r\n- [介绍](#introduction)\r\n- [配置](#configuration)\r\n- [异常处理](#the-exception-handler)\r\n    - [异常报告](#reporting-exceptions)\r\n    - [异常日志级别](#exception-log-levels)\r\n    - [忽略指定类型异常](#ignoring-exceptions-by-type)\r\n    - [渲染异常](#rendering-exceptions)\r\n    - [Reportable & Renderable 异常](#renderable-exceptions)\r\n- [HTTP 异常](#http-exceptions)\r\n    - [自定义 HTTP 错误页面](#custom-http-error-pages)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n当你开始一个新的 Laravel 项目时，它已经为你配置了错误和异常处理。`App\\Exceptions\\Handler`类用于记录应用程序触发的所有异常，然后将其呈现回用户。我们将在本文中深入讨论这个类。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n你的`config/app.php`配置文件中的`debug`选项决定了对于一个错误实际上将显示多少信息给用户。默认情况下，该选项的设置将遵照存储在`.env`文件中的`APP_DEBUG`环境变量的值。\r\n\r\n对于本地开发，你应该将`APP_DEBUG`环境变量的值设置为`true`。 **在生产环境中，该值应始终为`false`。如果在生产中将该值设置为`true`，则可能会将敏感配置值暴露给应用程序的终端用户。**\r\n\r\n<a name=\"the-exception-handler\"></a>\r\n## 异常处理\r\n\r\n<a name=\"reporting-exceptions\"></a>\r\n### 异常报告\r\n\r\n所有异常都是由`App\\Exceptions\\Handler`类处理。此类包含一个`register`方法，可以在其中注册自定义异常报告程序和渲染器回调。我们将详细研究每个概念。异常报告用于记录异常或将其发送到如  [Flare](https://flareapp.io)、 [Bugsnag](https://bugsnag.com) 或 [Sentry](https://github.com/getsentry/sentry-laravel) 等外部服务。默认情况下，将根据你的[日志](/docs/laravel/10.x/logging)配置来记录异常。不过，你可以用任何自己喜欢的方式来记录异常。\r\n\r\n\r\n\r\n例如，如果您需要以不同的方式报告不同类型的异常，您可以使用 <code>reportable</code> 方法注册一个闭包，当需要报告给定的异常的时候便会执行它。 Laravel 将通过检查闭包的类型提示来判断闭包报告的异常类型：\r\n\r\n    use App\\Exceptions\\InvalidOrderException;\r\n\r\n    /**\r\n     * 为应用程序注册异常处理回调\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->reportable(function (InvalidOrderException $e) {\r\n            // ...\r\n        });\r\n    }\r\n\r\n当您使用 <code>reportable</code> 方法注册一个自定义异常报告回调时， Laravel 依然会使用默认的日志配置记录下应用异常。 如果您想要在默认的日志堆栈中停止这个行为，您可以在定义报告回调时使用 stop 方法或者从回调函数中返回 <code>false</code>：\r\n\r\n\r\n    $this->reportable(function (InvalidOrderException $e) {\r\n        // ...\r\n    })->stop();\r\n\r\n    $this->reportable(function (InvalidOrderException $e) {\r\n        return false;\r\n    });\r\n\r\n> **技巧**  \r\n> 要为给定的异常自定义异常报告，您可以使用 [可报告异常](/docs/laravel/10.x/errors#renderable-exceptions).\r\n\r\n<a name=\"global-log-context\"></a>\r\n#### 全局日志上下文\r\n\r\n在可用的情况下， Laravel 会自动将当前用户的编号作为数据添加到每一条异常日志信息中。您可以通过重写 <code>App\\Exceptions\\Handler</code> 类中的 <code>context</code> 方法来定义您自己的全局上下文数据（环境变量）。此后，每一条异常日志信息都将包含这个信息：\r\n\r\n    /**\r\n     * 获取默认日志的上下文变量。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    protected function context(): array\r\n    {\r\n        return array_merge(parent::context(), [\r\n            'foo' => 'bar',\r\n        ]);\r\n    }\r\n\r\n<a name=\"exception-log-context\"></a>\r\n\r\n\r\n#### 异常日志上下文\r\n\r\n尽管将上下文添加到每个日志消息中可能很有用，但有时特定的异常可能具有您想要包含在日志中的唯一上下文。通过在应用程序的自定义异常中定义`context`方法，您可以指定与该异常相关的任何数据，应将其添加到异常的日志条目中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Exceptions;\r\n\r\n    use Exception;\r\n\r\n    class InvalidOrderException extends Exception\r\n    {\r\n        // ...\r\n\r\n        /**\r\n         * 获取异常上下文信息\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function context(): array\r\n        {\r\n            return ['order_id' => $this->orderId];\r\n        }\r\n    }\r\n\r\n<a name=\"the-report-helper\"></a>\r\n#### `report` 助手\r\n\r\n有时，您可能需要报告异常，但继续处理当前请求。`report`助手函数允许您通过异常处理程序快速报告异常，而无需向用户呈现错误页面：\r\n\r\n    public function isValid(string $value): bool\r\n    {\r\n        try {\r\n            // Validate the value...\r\n        } catch (Throwable $e) {\r\n            report($e);\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n<a name=\"exception-log-levels\"></a>\r\n### 异常日志级别\r\n\r\n当消息被写入应用程序的[日志](/docs/laravel/10.x/logging)时，消息将以指定的[日志级别](/docs/laravel/10.x/logging#log-levels)写入，该级别指示正在记录的消息的严重性或重要性。\r\n\r\n如上所述，即使使用`reportable`方法注册自定义异常报告回调，Laravel仍将使用应用程序的默认日志记录配置记录异常；但是，由于日志级别有时会影响消息记录的通道，因此您可能希望配置某些异常记录的日志级别。\r\n\r\n\r\n\r\n为了实现这个目标，您可以在应用程序的异常处理程序的`$levels`属性中定义一个异常类型数组以及它们关联的日志级别：\r\n\r\n    use PDOException;\r\n    use Psr\\Log\\LogLevel;\r\n\r\n    /**\r\n     * 包含其对应自定义日志级别的异常类型列表。\r\n     *\r\n     * @var array<class-string<\\Throwable>, \\Psr\\Log\\LogLevel::*>\r\n     */\r\n    protected $levels = [\r\n        PDOException::class => LogLevel::CRITICAL,\r\n    ];\r\n\r\n<a name=\"ignoring-exceptions-by-type\"></a>\r\n### 按类型忽略异常\r\n\r\n在构建应用程序时，您可能希望忽略某些类型的异常并永远不报告它们。应用程序的异常处理程序包含一个\t`$dontReport` 属性，该属性初始化为空数组。您添加到此属性的任何类都将不会被报告；但是它们仍然可能具有自定义渲染逻辑：\r\n\r\n    use App\\Exceptions\\InvalidOrderException;\r\n\r\n    /**\r\n     * 不会被报告的异常类型列表。\r\n     *\r\n     * @var array<int, class-string<\\Throwable>>\r\n     */\r\n    protected $dontReport = [\r\n        InvalidOrderException::class,\r\n    ];\r\n\r\n在内部，Laravel已经为您忽略了一些类型的错误，例如由404 HTTP错误或由无效CSRF令牌生成的419 HTTP响应引起的异常。如果您想指示Laravel停止忽略给定类型的异常，您可以在异常处理程序的`register`方法中调用`stopIgnoring`方法：\r\n\r\n    use Symfony\\Component\\HttpKernel\\Exception\\HttpException;\r\n\r\n    /**\r\n     * 为应用程序注册异常处理回调函数。\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->stopIgnoring(HttpException::class);\r\n\r\n        // ...\r\n    }\r\n\r\n<a name=\"rendering-exceptions\"></a>\r\n### 渲染异常\r\n\r\n默认情况下，Laravel 异常处理程序会将异常转换为 HTTP 响应。但是，您可以自由地为给定类型的异常注册自定义渲染闭包。您可以通过在异常处理程序中调用`renderable`方法来实现这一点。\r\n\r\n\r\n\r\n传递给 `renderable` 方法的闭包应该返回一个 `Illuminate\\Http\\Response` 实例，该实例可以通过 `response` 助手生成。 Laravel 将通过检查闭包的类型提示来推断闭包呈现的异常类型：\r\n\r\n    use App\\Exceptions\\InvalidOrderException;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    /**\r\n     * Register the exception handling callbacks for the application.\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->renderable(function (InvalidOrderException $e, Request $request) {\r\n            return response()->view('errors.invalid-order', [], 500);\r\n        });\r\n    }\r\n\r\n您还可以使用 `renderable` 方法来覆盖内置的Laravel或Symfony异常的呈现行为，例如 `NotFoundHttpException`。如果传递给 `renderable` 方法的闭包没有返回值，则将使用Laravel的默认异常呈现：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\r\n\r\n    /**\r\n     * Register the exception handling callbacks for the application.\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->renderable(function (NotFoundHttpException $e, Request $request) {\r\n            if ($request->is('api/*')) {\r\n                return response()->json([\r\n                    'message' => 'Record not found.'\r\n                ], 404);\r\n            }\r\n        });\r\n    }\r\n\r\n<a name=\"renderable-exceptions\"></a>\r\n### Reportable & Renderable 异常\r\n\r\n您可以直接在自定义异常类中定义 `report` 和 `render` 方法，而不是在异常处理程序的 `register` 方法中定义自定义报告和呈现行为。当存在这些方法时，框架将自动调用它们：\r\n\r\n    <?php\r\n\r\n    namespace App\\Exceptions;\r\n\r\n    use Exception;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Http\\Response;\r\n\r\n    class InvalidOrderException extends Exception\r\n    {\r\n        /**\r\n         * Report the exception.\r\n         */\r\n        public function report(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * Render the exception into an HTTP response.\r\n         */\r\n        public function render(Request $request): Response\r\n        {\r\n            return response(/* ... */);\r\n        }\r\n    }\r\n\r\n如果您的异常扩展了已经可呈现的异常，例如内置的Laravel或Symfony异常，则可以从异常的 `render` 方法中返回`false`，以呈现异常的默认HTTP响应：\r\n\r\n    /**\r\n     * Render the exception into an HTTP response.\r\n     */\r\n    public function render(Request $request): Response|bool\r\n    {\r\n        if (/** Determine if the exception needs custom rendering */) {\r\n\r\n            return response(/* ... */);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n如果你的异常包含了只在特定条件下才需要使用的自定义报告逻辑，那么你可能需要指示 Laravel 有时使用默认的异常处理配置来报告异常。为了实现这一点，你可以从异常的 `report` 方法中返回 `false`：\r\n\r\n    /**\r\n     * Report the exception.\r\n     */\r\n    public function report(): bool\r\n    {\r\n        if (/** 确定异常是否需要自定义报告 */) {\r\n\r\n            // ...\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n> **注意**\r\n> 你可以在 `report` 方法中类型提示任何所需的依赖项，它们将自动被 Laravel 的[服务容器](/docs/laravel/10.x/container)注入该方法中。\r\n\r\n<a name=\"http-exceptions\"></a>\r\n## HTTP 异常\r\n\r\n有些异常描述了服务器返回的 HTTP 错误代码。例如，这可能是一个 \"页面未找到\" 错误（404），一个 \"未经授权错误\"（401）或甚至是一个由开发者生成的 500 错误。为了从应用程序的任何地方生成这样的响应，你可以使用 `abort` 帮助函数：\r\n\r\n    abort(404);\r\n\r\n<a name=\"custom-http-error-pages\"></a>\r\n### 自定义 HTTP 错误页面\r\n\r\nLaravel 使得为各种 HTTP 状态码显示自定义错误页面变得很容易。例如，如果你想自定义 404 HTTP 状态码的错误页面，请创建一个 `resources/views/errors/404.blade.php` 视图模板。这个视图将会被渲染在应用程序生成的所有 404 错误上。这个目录中的视图应该被命名为它们对应的 HTTP 状态码。`abort` 函数引发的 `Symfony\\Component\\HttpKernel\\Exception\\HttpException` 实例将会以 `$exception` 变量的形式传递给视图：\r\n\r\n    <h2>{{ $exception->getMessage() }}</h2>\r\n\r\n你可以使用 `vendor:publish` Artisan 命令发布 Laravel 的默认错误页面模板。一旦模板被发布，你可以根据自己的喜好进行自定义：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-errors\r\n```\r\n\r\n<a name=\"fallback-http-error-pages\"></a>\r\n#### 回退 HTTP 错误页面\r\n\r\n你也可以为给定系列的 HTTP 状态码定义一个“回退”错误页面。如果没有针对发生的具体 HTTP 状态码相应的页面，就会呈现此页面。为了实现这一点，在你应用程序的 `resources/views/errors` 目录中定义一个 `4xx.blade.php` 模板和一个 `5xx.blade.php` 模板。\r\n\r\n","p":"docs/errors.html"},{"t":"logging (Logging)","d":"# Logging\r\n\r\n- [介绍](#introduction)\r\n- [配置](#configuration)\r\n    - [可用通道驱动](#available-channel-driver)\r\n    - [通道先决条件](#available-channel-driver)\r\n    - [记录弃用警告](#logging-deprecation-warnings)\r\n- [构建日志堆栈](#building-log-stacks)\r\n- [写日志消息](#writing-log-messages)\r\n    - [上下文信息](#contextual-information)\r\n    - [写入到指定通道](#writing-to-specific-channels)\r\n- [Monolog 通道自定义](#monolog-channel-customization)\r\n    - [为通道自定义 Monolog](#customizing-monolog-for-channels)\r\n    - [创建 Monolog 处理器通道](#creating-monolog-handler-channels)\r\n    - [创建 Monolog 处理器通道](#creating-custom-channels-via-factories)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n为了帮助您更多地了解应用程序中发生的事情，Laravel 提供了强大的日志记录服务，允许您将日志记录到文件、系统错误日志，甚至记录到 Slack 以通知您的整个团队。\r\n\r\nLaravel 日志基于「 通道 」。 每个通道代表一种写入日志信息的特定方式。 例如，`single` 通道是将日志写入到单个日志文件中。而 `slack` 通道是将日志发送到 Slack 上。 基于它们的重要程度，日志可以被写入到多个通道中去。\r\n\r\n在底层，Laravel 利用 [Monolog](https://github.com/Seldaek/monolog) 库，它为各种强大的日志处理程序提供了支持。 Laravel 使配置这些处理程序变得轻而易举，允许您混合和匹配它们，以自定义应用程序的方式完成日志处理。\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n所有应用程序的日志行为配置选项都位于 `config/logging.php` 配置文件中。 该文件允许您配置应用程序的日志通道，因此请务必查看每个可用通道及其选项。 我们将在下面回顾一些常见的选项。\r\n\r\n\r\n\r\n默认情况下，Laravel 在记录日志消息时使用 `stack` 频道。`stack` 频道用于将多个日志频道聚合到一个频道中。有关构建堆栈的更多信息，请查看下面的[文档](https://chat.openai.com/chat#building-log-stacks)。\r\n\r\n<a name=\"configuring-the-channel-name\"></a>\r\n#### 配置频道名称\r\n\r\n默认情况下，Monolog 使用与当前环境相匹配的“频道名称”（例如 `production` 或 `local`）进行实例化。要更改此值，请向频道的配置中添加一个 `name` 选项：\r\n\r\n    'stack' => [\r\n        'driver' => 'stack',\r\n        'name' => 'channel-name',\r\n        'channels' => ['single', 'slack'],\r\n    ],\r\n\r\n<a name=\"available-channel-drivers\"></a>\r\n### 可用频道驱动程序\r\n\r\n每个日志频道都由一个“驱动程序”驱动。驱动程序确定实际记录日志消息的方式和位置。以下日志频道驱动程序在每个 Laravel 应用程序中都可用。大多数这些驱动程序的条目已经在应用程序的 `config/logging.php` 配置文件中存在，因此请务必查看此文件以熟悉其内容：\r\n\r\n<div class=\"overflow-auto\">\r\n\r\n| 名称 | 描述 |\r\n| --- | --- |\r\n| `custom` | 调用指定工厂创建频道的驱动程序 |\r\n| `daily` | 基于 `RotatingFileHandler` 的 Monolog 驱动程序，每天轮换一次日志文件 |\r\n| `errorlog` | 基于 `ErrorLogHandler` 的 Monolog 驱动程序 |\r\n| `monolog` | 可使用任何支持的 Monolog 处理程序的 Monolog 工厂驱动程序 |\r\n| `null` | 丢弃所有日志消息的驱动程序 |\r\n| `papertrail` | 基于 `SyslogUdpHandler` 的 Monolog 驱动程序 |\r\n| `single` | 单个文件或路径为基础的记录器频道（`StreamHandler`） |\r\n| `slack` | 基于 `SlackWebhookHandler` 的 Monolog 驱动程序 |\r\n| `stack` | 包装器，用于方便地创建“多通道”频道 |\r\n| `syslog` | 基于 `SyslogHandler` 的 Monolog 驱动程序 |\r\n\r\n</div>\r\n\r\n> **注意**\r\n> 查看 [高级频道自定义](/chat#monolog-channel-customization) 文档，了解有关 `monolog` 和 `custom` 驱动程序的更多信息。\r\n\r\n\r\n### 频道前提条件\r\n\r\n#### 配置单一和日志频道\r\n\r\n在处理消息时，`single`和 `daily` 频道有三个可选配置选项：`bubble`，`permission` 和`locking`。\r\n\r\n<div class=\"overflow-auto\">\r\n\r\n| 名称 | 描述 | 默认值 |\r\n| --- | --- | --- |\r\n| `bubble` | 表示是否在处理后将消息传递到其他频道 | `true` |\r\n| `locking` | 在写入日志文件之前尝试锁定日志文件 | `false` |\r\n| `permission` | 日志文件的权限 | `0644` |</div>\r\n\r\n另外，可以通过 `days` 选项配置 `daily` 频道的保留策略：\r\n\r\n<div class=\"overflow-auto\">\r\n\r\n| 名称 | 描述 | 默认值 |\r\n| --- | --- | --- |\r\n| `days` | 保留每日日志文件的天数 | `7` |</div>\r\n\r\n#### 配置 Papertrail 频道\r\n\r\n`papertrail` 频道需要 `host` 和 `port` 配置选项。您可以从[Papertrail](https://help.papertrailapp.com/kb/configuration/configuring-centralized-logging-from-php-apps/#send-events-from-php-app)获取这些值。\r\n\r\n#### 配置Slack频道\r\n\r\n`slack` 频道需要一个 `url` 配置选项。此URL应该与您为Slack团队配置的[incoming webhook](https://slack.com/apps/A0F7XDUAZ-incoming-webhooks)的URL匹配。\r\n\r\n默认情况下，Slack仅会接收 `critical` 级别及以上的日志；但是，您可以通过修改 `config/logging.php` 配置文件中您的Slack日志频道配置数组中的 `level` 配置选项来调整此设置。\r\n\r\n### 记录弃用警告\r\n\r\nPHP、Laravel和其他库通常会通知其用户，一些功能已被弃用，将在未来版本中删除。如果您想记录这些弃用警告，可以在应用程序的 `config/logging.php` 配置文件中指定您首选的 `deprecations` 日志频道：\r\n\r\n    'deprecations' => env('LOG_DEPRECATIONS_CHANNEL', 'null'),\r\n\r\n    'channels' => [\r\n        ...\r\n    ]\r\n\r\n\r\n\r\n或者，您可以定义一个名为 `deprecations` 的日志通道。如果存在此名称的日志通道，则始终将其用于记录弃用：\r\n\r\n    'channels' => [\r\n        'deprecations' => [\r\n            'driver' => 'single',\r\n            'path' => storage_path('logs/php-deprecation-warnings.log'),\r\n        ],\r\n    ],\r\n\r\n<a name=\"building-log-stacks\"></a>\r\n## 构建日志堆栈\r\n\r\n如前所述，`stack` 驱动程序允许您将多个通道组合成一个方便的日志通道。为了说明如何使用日志堆栈，让我们看一个您可能在生产应用程序中看到的示例配置：\r\n\r\n    'channels' => [\r\n        'stack' => [\r\n            'driver' => 'stack',\r\n            'channels' => ['syslog', 'slack'],\r\n        ],\r\n\r\n        'syslog' => [\r\n            'driver' => 'syslog',\r\n            'level' => 'debug',\r\n        ],\r\n\r\n        'slack' => [\r\n            'driver' => 'slack',\r\n            'url' => env('LOG_SLACK_WEBHOOK_URL'),\r\n            'username' => 'Laravel Log',\r\n            'emoji' => ':boom:',\r\n            'level' => 'critical',\r\n        ],\r\n    ],\r\n\r\n让我们分解一下这个配置。首先，请注意我们的 `stack` 通道通过其 `channels` 选项聚合了两个其他通道：`syslog` 和 `slack`。因此，在记录消息时，这两个通道都有机会记录消息。但是，正如我们将在下面看到的那样，这些通道是否实际记录消息可能取决于消息的严重程度/\"级别\"。\r\n\r\n<a name=\"log-levels\"></a>\r\n#### 日志级别\r\n\r\n请注意上面示例中 `syslog` 和 `slack` 通道配置中存在的 `level` 配置选项。此选项确定必须记录消息的最小“级别”。Laravel的日志服务采用Monolog，提供[RFC 5424规范](https://tools.ietf.org/html/rfc5424)中定义的所有日志级别。按严重程度递减的顺序，这些日志级别是：**emergency**，**alert**，**critical**，**error**，**warning**，**notice**，**info**和**debug**。\r\n\r\n\r\n\r\n在我们的配置中，如果我们使用 `debug` 方法记录消息：\r\n\r\n    Log::debug('An informational message.');\r\n\r\n根据我们的配置，`syslog` 渠道将把消息写入系统日志；但由于错误消息不是 `critical` 或以上级别，它不会被发送到 Slack。然而，如果我们记录一个 `emergency` 级别的消息，则会发送到系统日志和 Slack，因为 `emergency` 级别高于我们两个渠道的最小级别阈值：\r\n\r\n    Log::emergency('The system is down!');\r\n\r\n<a name=\"writing-log-messages\"></a>\r\n## 写入日志消息\r\n\r\n您可以使用 `Log`  [facade](/docs/laravel/10.x/facades) 向日志写入信息。正如之前提到的，日志记录器提供了 [RFC 5424 规范](https://tools.ietf.org/html/rfc5424) 中定义的八个日志级别：**emergency**、**alert**、**critical**、**error**、**warning**、**notice**、**info** 和 **debug**：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    Log::emergency($message);\r\n    Log::alert($message);\r\n    Log::critical($message);\r\n    Log::error($message);\r\n    Log::warning($message);\r\n    Log::notice($message);\r\n    Log::info($message);\r\n    Log::debug($message);\r\n\r\n您可以调用其中任何一个方法来记录相应级别的消息。默认情况下，该消息将根据您的 `logging` 配置文件配置的默认日志渠道进行写入：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Log;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * Show the profile for the given user.\r\n         */\r\n        public function show(string $id): View\r\n        {\r\n            Log::info('Showing the user profile for user: '.$id);\r\n\r\n            return view('user.profile', [\r\n                'user' => User::findOrFail($id)\r\n            ]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"contextual-information\"></a>\r\n### 上下文信息\r\n\r\n可以向日志方法传递一组上下文数据。这些上下文数据将与日志消息一起格式化和显示：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    Log::info('User failed to login.', ['id' => $user->id]);\r\n\r\n偶尔，您可能希望指定一些上下文信息，这些信息应包含在特定频道中所有随后的日志条目中。例如，您可能希望记录与应用程序的每个传入请求相关联的请求ID。为了实现这一目的，您可以调用 `Log` 门面的 `withContext` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Log;\r\n    use Illuminate\\Support\\Str;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class AssignRequestId\r\n    {\r\n        /**\r\n         * Handle an incoming request.\r\n         *\r\n         * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n         */\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            $requestId = (string) Str::uuid();\r\n\r\n            Log::withContext([\r\n                'request-id' => $requestId\r\n            ]);\r\n\r\n            return $next($request)->header('Request-Id', $requestId);\r\n        }\r\n    }\r\n\r\n如果要在_所有_日志频道之间共享上下文信息，则可以调用 `Log::shareContext()` 方法。此方法将向所有已创建的频道提供上下文信息，以及随后创建的任何频道。通常，`shareContext` 方法应从应用程序服务提供程序的 `boot` 方法中调用：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    class AppServiceProvider\r\n    {\r\n        /**\r\n         * 启动任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Log::shareContext([\r\n                'invocation-id' => (string) Str::uuid(),\r\n            ]);\r\n        }\r\n    }\r\n\r\n<a name=\"writing-to-specific-channels\"></a>\r\n### 写入特定频道\r\n\r\n有时，您可能希望将消息记录到应用程序默认频道以外的频道。您可以使用 `Log` 门面上的 `channel` 方法来检索并记录配置文件中定义的任何频道：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    Log::channel('slack')->info('Something happened!');\r\n\r\n\r\n\r\n如果你想创建一个由多个通道组成的按需记录堆栈，可以使用 `stack` 方法：\r\n\r\n    Log::stack(['single', 'slack'])->info('Something happened!');\r\n\r\n<a name=\"on-demand-channels\"></a>\r\n#### 按需通道\r\n\r\n还可以创建一个按需通道，方法是在运行时提供配置而无需将该配置包含在应用程序的 `logging` 配置文件中。为此，可以将配置数组传递给 `Log` 门面的 `build` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    Log::build([\r\n      'driver' => 'single',\r\n      'path' => storage_path('logs/custom.log'),\r\n    ])->info('Something happened!');\r\n\r\n您可能还希望在按需记录堆栈中包含一个按需通道。可以通过将按需通道实例包含在传递给 `stack` 方法的数组中来实现：\r\n\r\n    use Illuminate\\Support\\Facades\\Log;\r\n\r\n    $channel = Log::build([\r\n      'driver' => 'single',\r\n      'path' => storage_path('logs/custom.log'),\r\n    ]);\r\n\r\n    Log::stack(['slack', $channel])->info('Something happened!');\r\n\r\n<a name=\"monolog-channel-customization\"></a>\r\n## Monolog 通道定制\r\n\r\n<a name=\"customizing-monolog-for-channels\"></a>\r\n### 为通道定制 Monolog\r\n\r\n有时，您可能需要完全控制 Monolog 如何配置现有通道。例如，您可能希望为 Laravel 内置的 `single` 通道配置自定义的 Monolog `FormatterInterface` 实现。\r\n\r\n要开始，请在通道配置中定义 `tap` 数组。`tap` 数组应包含一系列类，这些类在创建 Monolog 实例后应有机会自定义（或“tap”）它。没有这些类应放置在何处的惯例位置，因此您可以在应用程序中创建一个目录以包含这些类：\r\n\r\n    'single' => [\r\n        'driver' => 'single',\r\n        'tap' => [App\\Logging\\CustomizeFormatter::class],\r\n        'path' => storage_path('logs/laravel.log'),\r\n        'level' => 'debug',\r\n    ],\r\n\r\n\r\n\r\n一旦你在通道上配置了 `tap` 选项，你就可以定义一个类来自定义你的 Monolog 实例。这个类只需要一个方法：`__invoke`，它接收一个 `Illuminate\\Log\\Logger` 实例。`Illuminate\\Log\\Logger` 实例代理所有方法调用到底层的 Monolog 实例：\r\n\r\n\r\n    <?php\r\n\r\n    namespace App\\Logging;\r\n\r\n    use Illuminate\\Log\\Logger;\r\n    use Monolog\\Formatter\\LineFormatter;\r\n\r\n    class CustomizeFormatter\r\n    {\r\n        /**\r\n         * 自定义给定的日志记录器实例。\r\n         */\r\n        public function __invoke(Logger $logger): void\r\n        {\r\n            foreach ($logger->getHandlers() as $handler) {\r\n                $handler->setFormatter(new LineFormatter(\r\n                    '[%datetime%] %channel%.%level_name%: %message% %context% %extra%'\r\n                ));\r\n            }\r\n        }\r\n    }\r\n\r\n> **注意**\r\n> 所有的 “tap” 类都由 [服务容器](/docs/laravel/10.x/container) 解析，因此它们所需的任何构造函数依赖关系都将自动注入。\r\n\r\n<a name=\"creating-monolog-handler-channels\"></a>\r\n\r\n### 创建 Monolog 处理程序通道\r\n\r\nMonolog 有多种 [可用的处理程序](https://github.com/Seldaek/monolog/tree/main/src/Monolog/Handler)，而 Laravel 并没有为每个处理程序内置通道。在某些情况下，你可能希望创建一个自定义通道，它仅是一个特定的 Monolog 处理程序实例，该处理程序没有相应的 Laravel 日志驱动程序。这些通道可以使用 `monolog` 驱动程序轻松创建。\r\n\r\n使用 `monolog` 驱动程序时，`handler` 配置选项用于指定将实例化哪个处理程序。可选地，可以使用 `with` 配置选项指定处理程序需要的任何构造函数参数：\r\n\r\n    'logentries' => [\r\n        'driver'  => 'monolog',\r\n        'handler' => Monolog\\Handler\\SyslogUdpHandler::class,\r\n        'with' => [\r\n            'host' => 'my.logentries.internal.datahubhost.company.com',\r\n            'port' => '10000',\r\n        ],\r\n    ],\r\n\r\n<a name=\"monolog-formatters\"></a>\r\n\r\n#### Monolog 格式化程序\r\n\r\n使用 `monolog` 驱动程序时，Monolog `LineFormatter` 将用作默认格式化程序。但是，你可以使用 `formatter` 和 `formatter_with` 配置选项自定义传递给处理程序的格式化程序类型：\r\n\r\n    'browser' => [\r\n        'driver' => 'monolog',\r\n        'handler' => Monolog\\Handler\\BrowserConsoleHandler::class,\r\n        'formatter' => Monolog\\Formatter\\HtmlFormatter::class,\r\n        'formatter_with' => [\r\n            'dateFormat' => 'Y-m-d',\r\n        ],\r\n    ],\r\n\r\n如果你使用的是能够提供自己的格式化程序的 Monolog 处理程序，你可以将 `formatter` 配置选项的值设置为 `default`：\r\n\r\n    'newrelic' => [\r\n        'driver' => 'monolog',\r\n        'handler' => Monolog\\Handler\\NewRelicHandler::class,\r\n        'formatter' => 'default',\r\n    ],\r\n\r\n\r\n <a name=\"monolog-processors\"></a>\r\n#### Monolog 处理器\r\n\r\nMonolog 也可以在记录消息之前对其进行处理。你可以创建你自己的处理器或使用 [Monolog提供的现有处理器](https://github.com/Seldaek/monolog/tree/main/src/Monolog/Processor)。\r\n\r\n 如果你想为 `monolog` 驱动定制处理器，请在通道的配置中加入`processors` 配置值。\r\n\r\n     'memory' => [\r\n         'driver' => 'monolog',\r\n         'handler' => Monolog\\Handler\\StreamHandler::class,\r\n         'with' => [\r\n             'stream' => 'php://stderr',\r\n         ],\r\n         'processors' => [\r\n             // Simple syntax...\r\n             Monolog\\Processor\\MemoryUsageProcessor::class,\r\n\r\n             // With options...\r\n             [\r\n                'processor' => Monolog\\Processor\\PsrLogMessageProcessor::class,\r\n                'with' => ['removeUsedContextFields' => true],\r\n            ],\r\n         ],\r\n     ],\r\n\r\n\r\n<a name=\"creating-custom-channels-via-factories\"></a>\r\n### 通过工厂创建通道\r\n\r\n如果你想定义一个完全自定义的通道，你可以在其中完全控制 Monolog 的实例化和配置，你可以在 `config/logging.php` 配置文件中指定`custom` 驱动程序类型。你的配置应该包括一个 `via` 选项，其中包含将被调用以创建 Monolog 实例的工厂类的名称：\r\n\r\n    'channels' => [\r\n        'example-custom-channel' => [\r\n            'driver' => 'custom',\r\n            'via' => App\\Logging\\CreateCustomLogger::class,\r\n        ],\r\n    ],\r\n\r\n一旦你配置了 `custom` 驱动程序通道，你就可以定义将创建你的 Monolog 实例的类。这个类只需要一个 __invoke 方法，它应该返回 Monolog 记录器实例。 该方法将接收通道配置数组作为其唯一参数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Logging;\r\n\r\n    use Monolog\\Logger;\r\n\r\n    class CreateCustomLogger\r\n    {\r\n        /**\r\n         * 创建一个自定义 Monolog 实例。\r\n         */\r\n        public function __invoke(array $config): Logger\r\n        {\r\n            return new Logger(/* ... */);\r\n        }\r\n    }\r\n\r\n","p":"docs/logging.html"},{"t":"artisan (Artisan 命令行)","d":"# Artisan 命令行\r\n\r\n- [介绍](#introduction)\r\n    - [Tinker 命令 (REPL)](#tinker)\r\n- [编写命令](#writing-commands)\r\n    - [生成命令](#generating-commands)\r\n    - [命令结构](#command-structure)\r\n    - [闭包命令](#closure-commands)\r\n    - [单例命令](#isolatable-commands)\r\n- [定义输入期望值](#defining-input-expectations)\r\n    - [参数](#arguments)\r\n    - [选项](#options)\r\n    - [输入数组](#input-arrays)\r\n    - [输入说明](#input-descriptions)\r\n- [I/O 命令](#command-io)\r\n    - [检索输入](#retrieving-input)\r\n    - [输入提示](#prompting-for-input)\r\n    - [编写输出](#writing-output)\r\n- [注册命令](#registering-commands)\r\n- [在程序中执行命令](#programmatically-executing-commands)\r\n    - [从其他命令调用命令](#calling-commands-from-other-commands)\r\n- [信号处理](#signal-handling)\r\n- [Stub 自定义](#stub-customization)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nArtisan 是 Laravel 中自带的命令行接口。Artisan 以 `artisan ` 脚本的方式存在于应用的根目录中，提供了许多有用的命令，帮助开发者创建应用。使用 `list` 命令可以查看所有可用的Artisan 命令：\r\n\r\n```shell\r\nphp artisan list\r\n```\r\n\r\n每个命令都与 \"help\" 帮助界面，它能显示和描述该命令可用的参数和选项。要查看帮助界面，请在命令前加上 `help` 即可：\r\n\r\n```shell\r\nphp artisan help migrate\r\n```\r\n\r\n<a name=\"laravel-sail\"></a>\r\n#### Laravel Sail\r\n\r\n如果你使用 [Laravel Sail](/docs/laravel/10.x/sail) 作为本地开发环境，记得使用 `sail` 命令行来调用 Artisan 命令。Sail 会在应用的 Docker容器中执行 Artisan 命令：\r\n\r\n```shell\r\n./vendor/bin/sail artisan list\r\n```\r\n\r\n<a name=\"tinker\"></a>\r\n### Tinker (REPL)\r\n\r\nLaravel Tinker 是为 Laravel 提供的强大的 REPL（交互式解释器），由 PsySH(https://github.com/bobthecow/psysh) 驱动支持。\r\n\r\n\r\n\r\n<a name=\"installation\"></a>\r\n#### 安装\r\n\r\n所有的 Laravel 应用默认都自带 Tinker。不过，如果你此前删除了它，你可以使用 Composer 安装：\r\n\r\n```shell\r\ncomposer require laravel/tinker\r\n```\r\n\r\n> **注意**  \r\n> 需要能与 Laravel 交互的图形用户界面吗？试试 [Tinkerwell](https://tinkerwell.app)!\r\n\r\n<a name=\"usage\"></a>\r\n#### 使用\r\n\r\nTinker 允许你在命令行中和整个 Laravel 应用交互，包括 Eloquent 模型、队列、事件等等。要进入 Tinker 环境，只需运行 `tinker` Artisan 命令：\r\n\r\n```shell\r\nphp artisan tinker\r\n```\r\n\r\n你可以使用 `vendor:publish` 命令发布 Tinker 的配置文件：\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Tinker\\TinkerServiceProvider\"\r\n```\r\n\r\n> **警告**  \r\n> `dispatch` 辅助函数及 `Dispatchable` 类中 `dispatch` 方法依赖于垃圾回收将任务放置到队列中。因此，使用 tinker 时，请使用 `Bus::dispath` 或 `Queue::push` 来分发任务。\r\n\r\n<a name=\"command-allow-list\"></a>\r\n#### 命令白名单\r\n\r\nTinker 使用白名单来确定哪些 Artisan 命令可以在其 Shell 中运行。默认情况下，你可以运行 `clear-compiled`、`down`、`env`、`inspire`、`migrate`、`optimize` 和 `up` 命令。如果你想允许更多命令，你可以将它们添加到 `tinker.php` 配置文件的 `commands` 数组中：\r\n\r\n    'commands' => [\r\n        // App\\Console\\Commands\\ExampleCommand::class,\r\n    ],\r\n\r\n<a name=\"classes-that-should-not-be-aliased\"></a>\r\n#### 别名黑名单\r\n\r\n一般而言，Tinker 会在你引入类时自动为其添加别名。不过，你可能不希望为某些类添加别名。你可以在 `tinker.php` 配置文件的 `dont_alias` 数组中列举这些类来完成此操作：\r\n\r\n    'dont_alias' => [\r\n        App\\Models\\User::class,\r\n    ],\r\n\r\n\r\n\r\n<a name=\"writing-commands\"></a>\r\n## 编写命令\r\n\r\n除了 Artisan 提供的命令之外，你可以创建自定义命令。一般而言，命令保存在 `app/Console/Commands` 目录；不过，你可以自由选择命令的存储位置，只要它能够被 Composer 加载即可。\r\n\r\n<a name=\"generating-commands\"></a>\r\n### 生成命令\r\n\r\n要创建新命令，可以使用 `make:command` Artisan 命令。该命令会在 `app/Console/Commands` 目录下创建一个新的命令类。如果该目录不存在，也无需担心 - 它会在第一次运行 `make:command` Artisan 命令的时候自动创建：\r\n\r\n```shell\r\nphp artisan make:command SendEmails\r\n```\r\n\r\n<a name=\"command-structure\"></a>\r\n### 命令结构\r\n\r\n生成命令后，应该为该类的 `signature` 和 `description` 属性设置设当的值。当在 list 屏幕上显示命令时，将使用这些属性。`signature` 属性也会让你定义[命令输入预期值](#defining-input-expectations)。`handle` 方法会在命令执行时被调用。你可以在该方法中编写命令逻辑。\r\n\r\n让我们看一个示例命令。请注意，我们能够通过命令的 `handle` 方法引入我们需要的任何依赖项。Laravel [服务容器](https://learnku.com/docs/laravel/9.x/container) 将自动注入此方法签名中带有类型提示的所有依赖项：\r\n\r\n    <?php\r\n\r\n    namespace App\\Console\\Commands;\r\n\r\n    use App\\Models\\User;\r\n    use App\\Support\\DripEmailer;\r\n    use Illuminate\\Console\\Command;\r\n\r\n    class SendEmails extends Command\r\n    {\r\n        /**\r\n         * 控制台命令的名称和签名\r\n         *\r\n         * @var string\r\n         */\r\n        protected $signature = 'mail:send {user}';\r\n\r\n        /**\r\n         * 命令描述\r\n         *\r\n         * @var string\r\n         */\r\n        protected $description = 'Send a marketing email to a user';\r\n\r\n        /**\r\n         * 执行命令\r\n         */\r\n        public function handle(DripEmailer $drip): void\r\n        {\r\n            $drip->send(User::find($this->argument('user')));\r\n        }\r\n    }\r\n\r\n> **注意**\r\n> 为了更好地复用代码，请尽量让你的命令类保持轻量并且能够延迟到应用服务中完成。上例中，我们注入了一个服务类来进行发送电子邮件的「繁重工作」。\r\n\r\n\r\n\r\n<a name=\"closure-commands\"></a>\r\n### 闭包命令\r\n\r\n基于闭包的命令为将控制台命令定义为类提供了一种替代方法。与路由闭包可以替代控制器一样，可以将命令闭包视为命令类的替代。在 `app/Console/Kernel.php` 文件的  `commands` 方法中 ，Laravel 加载 `routes/console.php` 文件：\r\n\r\n    /**\r\n     * 注册闭包命令\r\n     */\r\n    protected function commands(): void\r\n    {\r\n        require base_path('routes/console.php');\r\n    }\r\n\r\n尽管该文件没有定义 HTTP 路由，但它定义了进入应用程序的基于控制台的入口 (routes) 。在这个文件中，你可以使用 `Artisan::command` 方法定义所有的闭包路由。 `command` 方法接受两个参数： [命令名称](#defining-input-expectations) 和可调用的闭包，闭包接收命令的参数和选项：\r\n\r\n    Artisan::command('mail:send {user}', function (string $user) {\r\n        $this->info(\"Sending email to: {$user}!\");\r\n    });\r\n\r\n该闭包绑定到基础命令实例，因此你可以完全访问通常可以在完整命令类上访问的所有辅助方法。\r\n\r\n<a name=\"type-hinting-dependencies\"></a>\r\n#### Type-Hinting Dependencies\r\n\r\n除了接受命令参数及选项外，命令闭包也可以使用类型约束从 [服务容器](/docs/laravel/10.x/container) 中解析其他的依赖关系：\r\n\r\n    use App\\Models\\User;\r\n    use App\\Support\\DripEmailer;\r\n\r\n    Artisan::command('mail:send {user}', function (DripEmailer $drip, string $user) {\r\n        $drip->send(User::find($user));\r\n    });\r\n\r\n<a name=\"closure-command-descriptions\"></a>\r\n#### 闭包命令说明\r\n\r\n在定义基于闭包的命令时，可以使用 `purpose` 方法向命令添加描述。当你运行 `php artisan list` 或 `php artisan help` 命令时，将显示以下描述：\r\n\r\n    Artisan::command('mail:send {user}', function (string $user) {\r\n        // ...\r\n    })->purpose('Send a marketing email to a user');\r\n\r\n\r\n\r\n<a name=\"isolatable-commands\"></a>\r\n### 单例命令\r\n\r\n> **警告**\r\n> 要使用该特性，应用必须使用 `memcached`、`redis`、`dynamodb`、`database`、`file` 或 `array` 作为默认的缓存驱动。另外，所有的服务器必须与同一个中央缓存服务器通信。\r\n\r\n有时您可能希望确保一次只能运行一个命令实例。为此，你可以在命令类上实现 `Illuminate\\Contracts\\Console\\Isolatable` 接口：\r\n\r\n    <?php\r\n\r\n    namespace App\\Console\\Commands;\r\n\r\n    use Illuminate\\Console\\Command;\r\n    use Illuminate\\Contracts\\Console\\Isolatable;\r\n\r\n    class SendEmails extends Command implements Isolatable\r\n    {\r\n        // ...\r\n    }\r\n\r\n当命令被标记为 `Isolatable` 时，Laravel 会自动为该命令添加 `--isolated` 选项。当命令中使用这一选项时，Laravel 会确保不会有该命令的其他实例同时运行。Laravel 通过在应用的默认缓存驱动中使用原子锁来实现这一功能。如果这一命令有其他实例在运行，则该命令不会执行；不过，该命令仍然会使用成功退出状态码退出：\r\n\r\n```shell\r\nphp artisan mail:send 1 --isolated\r\n```\r\n\r\n如果你想自己指定命令无法执行时返回的退出状态码，你可用通过 `isolated` 选项提供：\r\n\r\n```shell\r\nphp artisan mail:send 1 --isolated=12\r\n```\r\n\r\n<a name=\"lock-expiration-time\"></a>\r\n#### 原子锁到期时间\r\n\r\n默认情况下，单例锁会在命令完成后过期。或者如果命令被打断且无法完成的话，锁会在一小时后过期。不过你也可以通过定义命令的 `isolationLockExpiresAt` 方法来调整过期时间：\r\n\r\n```php\r\nuse DateTimeInterface;\r\nuse DateInterval;\r\n\r\n/**\r\n * 定义单例锁的到期时间\r\n */\r\npublic function isolationLockExpiresAt(): DateTimeInterface|DateInterval\r\n{\r\n    return now()->addMinutes(5);\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"defining-input-expectations\"></a>\r\n## 定义输入期望\r\n\r\n在编写控制台命令时，通常是通过参数和选项来收集用户输入的。 Laravel 让你可以非常方便地在 `signature` 属性中定义你期望用户输入的内容。`signature` 属性允许使用单一且可读性高，类似路由的语法来定义命令的名称、参数和选项。\r\n\r\n<a name=\"arguments\"></a>\r\n### 参数\r\n\r\n用户提供的所有参数和选项都用花括号括起来。在下面的示例中，该命令定义了一个必需的参数 `user`:\r\n\r\n    /**\r\n     * 命令的名称及其标识\r\n     *\r\n     * @var string\r\n     */\r\n    protected $signature = 'mail:send {user}';\r\n\r\n你亦可创建可选参数或为参数定义默认值：\r\n\r\n    // 可选参数...\r\n    'mail:send {user?}'\r\n\r\n    // 带有默认值的可选参数...\r\n    'mail:send {user=foo}'\r\n\r\n<a name=\"options\"></a>\r\n### 选项\r\n\r\n选项类似于参数，是用户输入的另一种形式。在命令行中指定选项的时候，它们以两个短横线 (`--`) 作为前缀。这有两种类型的选项：接收值和不接受值。不接收值的选项就像是一个布尔「开关」。我们来看一下这种类型的选项的示例：\r\n\r\n    /**\r\n     * 命令的名称及其标识\r\n     *\r\n     * @var string\r\n     */\r\n    protected $signature = 'mail:send {user} {--queue}';\r\n\r\n在这个例子中，在调用 Artisan 命令时可以指定 `--queue` 的开关。如果传递了 `--queue` 选项，该选项的值将会是 `true`。否则，其值将会是 `false`：\r\n\r\n```shell\r\nphp artisan mail:send 1 --queue\r\n```\r\n\r\n\r\n\r\n<a name=\"options-with-values\"></a>\r\n#### 带值的选项\r\n\r\n接下来，我们来看一下需要带值的选项。如果用户需要为一个选项指定一个值，则需要在选项名称的末尾追加一个 `=` 号：\r\n\r\n    /**\r\n     * 命令名称及标识\r\n     *\r\n     * @var string\r\n     */\r\n    protected $signature = 'mail:send {user} {--queue=}';\r\n\r\n在这个例子中，用户可以像如下所时的方式传递该选项的值。如果在调用命令时未指定该选项，则其值为 `null`：\r\n\r\n```shell\r\nphp artisan mail:send 1 --queue=default\r\n```\r\n\r\n你还可以在选项名称后指定其默认值。如果用户没有传递值给选项，将使用默认的值：\r\n\r\n    'mail:send {user} {--queue=default}'\r\n\r\n<a name=\"option-shortcuts\"></a>\r\n#### 选项简写\r\n\r\n要在定义选项的时候指定一个简写，你可以在选项名前面使用 `|` 隔符将选项名称与其简写分隔开来：\r\n\r\n    'mail:send {user} {--Q|queue}'\r\n\r\n在终端上调用命令时，选项简写的前缀只用一个连字符，在为选项指定值时不应该包括`=`字符。\r\n\r\n```shell\r\nphp artisan mail:send 1 -Qdefault\r\n```\r\n\r\n<a name=\"input-arrays\"></a>\r\n### 输入数组\r\n\r\n如果你想要接收数组数组的参数或者选项，你可以使用 `*` 字符。首先，让我们看一下指定了一个数组参数的例子：\r\n\r\n    'mail:send {user*}'\r\n\r\n当调用这个方法的时候，`user` 参数的输入参数将按顺序传递给命令。例如，以下命令将会设置 `user` 的值为 `foo` 和 `bar` ：\r\n\r\n```shell\r\nphp artisan mail:send 1 2\r\n```\r\n\r\n\r\n\r\n `*` 字符可以与可选的参数结合使用，允许您定义零个或多个参数实例：\r\n\r\n    'mail:send {user?*}'\r\n\r\n<a name=\"option-arrays\"></a>\r\n#### 选项数组\r\n\r\n当定义需要多个输入值的选项时，传递给命令的每个选项值都应以选项名称作为前缀：\r\n\r\n    'mail:send {--id=*}'\r\n\r\n这样的命令可以通过传递多个 `--id` 参数来调用：\r\n\r\n```shell\r\nphp artisan mail:send --id=1 --id=2\r\n```\r\n\r\n<a name=\"input-descriptions\"></a>\r\n### 输入说明\r\n\r\n你可以通过使用冒号将参数名称与描述分隔来为输入参数和选项指定说明。如果你需要一些额外的空间来定义命令，可以将它自由的定义在多行中：\r\n\r\n    /**\r\n     * 控制台命令的名称和签名。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $signature = 'mail:send\r\n                            {user : The ID of the user}\r\n                            {--queue : Whether the job should be queued}';\r\n\r\n<a name=\"command-io\"></a>\r\n## 命令 I/O\r\n\r\n<a name=\"retrieving-input\"></a>\r\n### 检索输入\r\n\r\n当命令在执行时，你可能需要访问命令所接受的参数和选项的值。为此，你可以使用 `argument` 和 `option` 方法。如果选项或参数不存在，将会返回`null`：\r\n\r\n    /**\r\n     * 执行控制台命令。\r\n     */\r\n    public function handle(): void\r\n    {\r\n        $userId = $this->argument('user');\r\n    }\r\n\r\n如果你需要检索所有的参数做为 `array`，请调用 `arguments` 方法：\r\n\r\n    $arguments = $this->arguments();\r\n\r\n选项的检索与参数一样容易，使用 `option` 方法即可。如果要检索所有的选项做为数组，请调用 `options` 方法：\r\n\r\n    // 检索一个指定的选项...\r\n    $queueName = $this->option('queue');\r\n\r\n    // 检索所有选项做为数组...\r\n    $options = $this->options();\r\n\r\n\r\n\r\n<a name=\"prompting-for-input\"></a>\r\n### 交互式输入\r\n\r\n除了显示输出以外，你还可以要求用户在执行命令期间提供输入。`ask` 方法将询问用户指定的问题来接收用户输入，然后用户输入将会传到你的命令中：\r\n\r\n    /**\r\n     * 执行命令指令\r\n     */\r\n    public function handle(): void\r\n    {\r\n        $name = $this->ask('What is your name?');\r\n\r\n        // ...\r\n    }\r\n\r\n`secret` 方法与 `ask` 相似，区别在于用户的输入将不可见。这个方法在需要输入一些诸如密码之类的敏感信息时是非常有用的：\r\n\r\n    $password = $this->secret('What is the password?');\r\n\r\n<a name=\"asking-for-confirmation\"></a>\r\n#### 请求确认\r\n\r\n如果你需要请求用户进行一个简单的确认，可以使用 `confirm` 方法来实现。默认情况下，这个方法会返回 `false`。当然，如果用户输入 `y` 或 `yes`，这个方法将会返回 `true`。\r\n\r\n    if ($this->confirm('Do you wish to continue?')) {\r\n        // ...\r\n    }\r\n\r\n如有必要，你可以通过将 `true` 作为第二个参数传递给 `confirm` 方法，这样就可以在默认情况下返回 `true`：\r\n\r\n    if ($this->confirm('Do you wish to continue?', true)) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"auto-completion\"></a>\r\n#### 自动补全\r\n\r\n`anticipate` 方法可用于为可能的选项提供自动补全功能。用户依然可以忽略自动补全的提示，进行任意回答：\r\n\r\n    $name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);\r\n\r\n或者，你可以将一个闭包作为第二个参数传递给 `anticipate` 方法。每当用户键入字符时，闭包函数都会被调用。闭包函数应该接受一个包含用户输入的字符串形式的参数，并返回一个可供自动补全的选项的数组：\r\n\r\n    $name = $this->anticipate('What is your address?', function (string $input) {\r\n        // 返回自动完成配置...\r\n    });\r\n\r\n\r\n\r\n<a name=\"multiple-choice-questions\"></a>\r\n#### 多选择问题\r\n\r\n当询问问题时，如果你需要给用户一个预定义的选择，你可以使用 `choice` 方法。如果没有选项被选择，你可以设置数组索引的默认值去返回，通过这个方法的第三个参数去传入索引：\r\n\r\n    $name = $this->choice(\r\n        'What is your name?',\r\n        ['Taylor', 'Dayle'],\r\n        $defaultIndex\r\n    );\r\n\r\n此外， `choice` 方法接受第四和第五可选参数 ，用于确定选择有效响应的最大尝试次数以及是否允许多次选择：\r\n\r\n    $name = $this->choice(\r\n        'What is your name?',\r\n        ['Taylor', 'Dayle'],\r\n        $defaultIndex,\r\n        $maxAttempts = null,\r\n        $allowMultipleSelections = false\r\n    );\r\n\r\n<a name=\"writing-output\"></a>\r\n### 文字输出\r\n\r\n你可以使用 `line`，`info`，`comment`，`question` 和 `error` 方法，发送输出到控制台。 这些方法中的每一个都会使用合适的 ANSI 颜色以展示不同的用途。例如，我们要为用户展示一些常规信息。通常，`info` 将会以绿色文本在控制台展示。\r\n\r\n    /**\r\n     * Execute the console command.\r\n     */\r\n    public function handle(): void\r\n    {\r\n        // ...\r\n\r\n        $this->info('The command was successful!');\r\n    }\r\n\r\n输出错误信息，使用 `error` 方法。错误信息通常使用红色字体显示：\r\n\r\n    $this->error('Something went wrong!');\r\n\r\n你可以使用 `line` 方法输出无色文本：\r\n\r\n    $this->line('Display this on the screen');\r\n\r\n你可以使用 `newLine` 方法输出空白行：\r\n\r\n    // 输出单行空白...\r\n    $this->newLine();\r\n\r\n    // 输出三行空白...\r\n    $this->newLine(3);\r\n\r\n\r\n\r\n<a name=\"tables\"></a>\r\n#### 表格\r\n\r\n`table` 方法可以轻松正确地格式化多行/多列数据。你需要做的就是提供表的列名和数据，Laravel 会自动为你计算合适的表格宽度和高度：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $this->table(\r\n        ['Name', 'Email'],\r\n        User::all(['name', 'email'])->toArray()\r\n    );\r\n\r\n<a name=\"progress-bars\"></a>\r\n#### 进度条\r\n\r\n对于长时间运行的任务，显示一个进度条来告知用户任务的完成情况会很有帮助。使用 `withProgressBar` 方法，Laravel 将显示一个进度条，并在给定的可迭代值上推进每次迭代的进度：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = $this->withProgressBar(User::all(), function (User $user) {\r\n        $this->performTask($user);\r\n    });\r\n\r\n有时，你可能需要更多手动控制进度条的前进方式。首先，定义流程将迭代的步骤总数。然后，在处理完每个项目后推进进度条：\r\n\r\n    $users = App\\Models\\User::all();\r\n\r\n    $bar = $this->output->createProgressBar(count($users));\r\n\r\n    $bar->start();\r\n\r\n    foreach ($users as $user) {\r\n        $this->performTask($user);\r\n\r\n        $bar->advance();\r\n    }\r\n\r\n    $bar->finish();\r\n\r\n> **技巧：**有关更多高级选项，请查看 [Symfony 进度条组件文档](https://symfony.com/doc/current/components/console/helpers/progressbar.html).\r\n\r\n<a name=\"registering-commands\"></a>\r\n## 注册命令\r\n\r\n你的所有控制台命令都在您的应用程序的 `App\\Console\\Kernel` 类中注册，这是你的应用程序的「控制台内核」。在此类的 `commands` 方法中，你将看到对内核的 `load` 方法的调用。 `load` 方法将扫描 `app/Console/Commands` 目录并自动将其中包含的每个命令注册到 Artisan。 你甚至可以自由地调用 `load` 方法来扫描其他目录以查找 Artisan 命令：\r\n\r\n    /**\r\n     * Register the commands for the application.\r\n     */\r\n    protected function commands(): void\r\n    {\r\n        $this->load(__DIR__.'/Commands');\r\n        $this->load(__DIR__.'/../Domain/Orders/Commands');\r\n\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n如有必要，你可以通过将命令的类名添加到 `App\\Console\\Kernel` 类中的 `$commands` 属性来手动注册命令。如果你的内核上尚未定义此属性，则应手动定义它。当 Artisan 启动时，此属性中列出的所有命令将由 [服务容器](/docs/laravel/10.x/container) 解析并注册到 Artisan：\r\n\r\n    protected $commands = [\r\n        Commands\\SendEmails::class\r\n    ];\r\n\r\n<a name=\"programmatically-executing-commands\"></a>\r\n## 以编程方式执行命令\r\n\r\n有时你可能希望在 CLI 之外执行 Artisan 命令。例如，你可能希望从路由或控制器执行 Artisan 命令。你可以使用 `Artisan` 外观上的 `call` 方法来完成此操作。 `call` 方法接受命令的签名名称或类名作为其第一个参数，以及一个命令参数数组作为第二个参数。将返回退出代码：\r\n\r\n    use Illuminate\\Support\\Facades\\Artisan;\r\n\r\n    Route::post('/user/{user}/mail', function (string $user) {\r\n        $exitCode = Artisan::call('mail:send', [\r\n            'user' => $user, '--queue' => 'default'\r\n        ]);\r\n\r\n        // ...\r\n    });\r\n\r\n或者，你可以将整个 Artisan 命令作为字符串传递给 `call` 方法：\r\n\r\n    Artisan::call('mail:send 1 --queue=default');\r\n\r\n<a name=\"passing-array-values\"></a>\r\n#### 传递数组值\r\n\r\n如果你的命令定义了一个接受数组的选项，你可以将一组值传递给该选项：\r\n\r\n    use Illuminate\\Support\\Facades\\Artisan;\r\n\r\n    Route::post('/mail', function () {\r\n        $exitCode = Artisan::call('mail:send', [\r\n            '--id' => [5, 13]\r\n        ]);\r\n    });\r\n\r\n<a name=\"passing-boolean-values\"></a>\r\n#### 传递布尔值\r\n\r\n如果你需要指定不接受字符串值的选项的值，例如 `migrate:refresh` 命令上的 `--force` 标志，则应传递 `true` 或 `false` 作为 选项：\r\n\r\n    $exitCode = Artisan::call('migrate:refresh', [\r\n        '--force' => true,\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"queueing-artisan-commands\"></a>\r\n#### 队列 Artisan 命令\r\n\r\n使用 `Artisan` 门面的 `queue` 方法，你甚至可以对 Artisan 命令进行排队，以便你的 [队列工作者](/docs/laravel/10.x/queues) 在后台处理它们。在使用此方法之前，请确保你已配置队列并正在运行队列侦听器：\r\n\r\n    use Illuminate\\Support\\Facades\\Artisan;\r\n\r\n    Route::post('/user/{user}/mail', function (string $user) {\r\n        Artisan::queue('mail:send', [\r\n            'user' => $user, '--queue' => 'default'\r\n        ]);\r\n\r\n        // ...\r\n    });\r\n\r\n使用 `onConnection` 和 `onQueue` 方法，你可以指定 Artisan 命令应分派到的连接或队列：\r\n\r\n    Artisan::queue('mail:send', [\r\n        'user' => 1, '--queue' => 'default'\r\n    ])->onConnection('redis')->onQueue('commands');\r\n\r\n<a name=\"calling-commands-from-other-commands\"></a>\r\n### 从其他命令调用命令\r\n\r\n有时你可能希望从现有的 Artisan 命令调用其他命令。你可以使用 `call` 方法来执行此操作。这个 `call` 方法接受命令名称和命令参数/选项数组：\r\n\r\n    /**\r\n     * Execute the console command.\r\n     */\r\n    public function handle(): void\r\n    {\r\n        $this->call('mail:send', [\r\n            'user' => 1, '--queue' => 'default'\r\n        ]);\r\n\r\n        // ...\r\n    }\r\n\r\n如果你想调用另一个控制台命令并禁止其所有输出，你可以使用 `callSilently` 方法。 `callSilently` 方法与 `call` 方法具有相同的签名：\r\n\r\n    $this->callSilently('mail:send', [\r\n        'user' => 1, '--queue' => 'default'\r\n    ]);\r\n\r\n<a name=\"signal-handling\"></a>\r\n## 信号处理\r\n\r\n正如你可能知道的，操作系统允许向运行中的进程发送信号。例如，「SIGTERM」信号是操作系统要求程序终止的方式。如果你想在 Artisan 控制台命令中监听信号，并在信号发生时执行代码，你可以使用 `trap` 方法。\r\n\r\n    /**\r\n     * 执行控制台命令。\r\n     */\r\n    public function handle(): void\r\n    {\r\n        $this->trap(SIGTERM, fn () => $this->shouldKeepRunning = false);\r\n\r\n        while ($this->shouldKeepRunning) {\r\n            // ...\r\n        }\r\n    }\r\n\r\n\r\n\r\n为了一次监听多个信号，你可以向 `trap` 方法提供一个信号数组。\r\n\r\n    $this->trap([SIGTERM, SIGQUIT], function (int $signal) {\r\n        $this->shouldKeepRunning = false;\r\n\r\n        dump($signal); // SIGTERM / SIGQUIT\r\n    });\r\n\r\n<a name=\"stub-customization\"></a>\r\n## Stub 定制\r\n\r\nArtisan 控制台的 `make` 命令用于创建各种类，例如控制器、作业、迁移和测试。这些类是使用「stub」文件生成的，这些文件中会根据你的输入填充值。但是，你可能需要对 Artisan 生成的文件进行少量更改。为此，你可以使用以下 `stub:publish` 命令将最常见的 Stub 命令发布到你的应用程序中，以便可以自定义它们：\r\n\r\n```shell\r\nphp artisan stub:publish\r\n```\r\n\r\n已发布的 stub 将存放于你的应用根目录下的 `stubs` 目录中。对这些 stub 进行任何改动都将在你使用 Artisan `make` 命令生成相应的类的时候反映出来。\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\nArtisan 在运行命令时会调度三个事件： `Illuminate\\Console\\Events\\ArtisanStarting`，`Illuminate\\Console\\Events\\CommandStarting` 和  `Illuminate\\Console\\Events\\CommandFinished`。当 Artisan 开始运行时，会立即调度 `ArtisanStarting` 事件。接下来，在命令运行之前立即调度  `CommandStarting` 事件。最后，一旦命令执行完毕，就会调度  `CommandFinished` 事件。\r\n\r\n","p":"docs/artisan.html"},{"t":"broadcasting (广播)","d":"# 广播\r\n\r\n-   [介绍](#introduction)\r\n-   [服务器端安装](#server-side-installation)\r\n    -   [配置](#configuration)\r\n    -   [Pusher Channels](#pusher-channels)\r\n    -   [Ably](#ably)\r\n    -   [开源替代品](#open-source-alternatives)\r\n-   [客户端安装](#client-side-installation)\r\n    -   [Pusher Channels](#client-pusher-channels)\r\n    -   [Ably](#client-ably)\r\n-   [概念概述](#concept-overview)\r\n    -   [使用示例应用程序](#using-example-application)\r\n-   [定义广播事件](#defining-broadcast-events)\r\n    -   [广播名称](#broadcast-name)\r\n    -   [广播数据](#broadcast-data)\r\n    -   [广播队列](#broadcast-queue)\r\n    -   [广播条件](#broadcast-conditions)\r\n    -   [广播和数据库事务](#broadcasting-and-database-transactions)\r\n-   [授权频道](#authorizing-channels)\r\n    -   [定义授权路由](#defining-authorization-routes)\r\n    -   [定义授权回调](#defining-authorization-callbacks)\r\n    -   [定义频道类](#defining-channel-classes)\r\n-   [广播事件](#broadcasting-events)\r\n    -   [仅发送给其他人](#only-to-others)\r\n    -   [自定义连接](#customizing-the-connection)\r\n-   [接收广播](#receiving-broadcasts)\r\n    -   [监听事件](#listening-for-events)\r\n    -   [离开频道](#leaving-a-channel)\r\n    -   [命名空间](#namespaces)\r\n-   [在场频道](#presence-channels)\r\n    -   [授权在场频道](#authorizing-presence-channels)\r\n    -   [加入在场频道](#joining-presence-channels)\r\n    -   [广播到在场频道](#broadcasting-to-presence-channels)\r\n-   [模型广播](#model-broadcasting)\r\n    -   [模型广播约定](#model-broadcasting-conventions)\r\n    -   [监听模型广播](#listening-for-model-broadcasts)\r\n-   [客户端事件](#client-events)\r\n-   [通知](#notifications)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n在许多现代 Web 应用程序中，WebSockets 用于实现实时的、实时更新的用户界面。当服务器上的某些数据更新时，通常会发送一条消息到 WebSocket 连接，以由客户端处理。WebSockets 提供了一种更有效的替代方法，可以连续轮询应用程序服务器以反映 UI 中应该反映的数据更改。\r\n\r\n举个例子，假设你的应用程序能够将用户的数据导出为 CSV 文件并通过电子邮件发送给他们。但是，创建这个 CSV 文件需要几分钟的时间，因此你选择在[队列任务](/docs/laravel/10.x/queues)中创建和发送 CSV。当 CSV 文件已经创建并发送给用户后，我们可以使用事件广播来分发 `App\\Events\\UserDataExported` 事件，该事件由我们应用程序的 JavaScript 接收。一旦接收到事件，我们可以向用户显示消息，告诉他们他们的 CSV 已通过电子邮件发送给他们，而无需刷新页面。\r\n\r\n\r\n\r\n为了帮助你构建此类特性，Laravel使得在WebSocket连接上“广播”你的服务端[Laravel事件](/docs/laravel/10.x/events)变得简单。广播你的Laravel事件允许你在你的服务端Laravel应用和客户端JavaScript应用之间共享相同的事件名称和数据。\r\n\r\n广播背后的核心概念很简单：客户端在前端连接到命名通道，而你的Laravel应用在后端向这些通道广播事件。这些事件可以包含任何你想要向前端提供的其他数据。\r\n\r\n<a name=\"supported-drivers\"></a>\r\n#### 支持的驱动程序\r\n\r\n默认情况下，Laravel为你提供了两个服务端广播驱动程序可供选择：[Pusher Channels](https://pusher.com/channels) 和 [Ably](https://ably.com/)。但是，社区驱动的包，如 [laravel-websockets](https://beyondco.de/docs/laravel-websockets/getting-started/introduction) 和 [soketi](https://docs.soketi.app/) 提供了不需要商业广播提供者的其他广播驱动程序。\r\n\r\n> **注意**\r\n> 在深入了解事件广播之前，请确保已阅读Laravel的[事件和侦听器](/docs/laravel/10.x/events)文档。\r\n\r\n<a name=\"server-side-installation\"></a>\r\n## 服务端安装\r\n\r\n为了开始使用Laravel的事件广播，我们需要在Laravel应用程序中进行一些配置，并安装一些包。\r\n\r\n事件广播是通过服务端广播驱动程序实现的，该驱动程序广播你的Laravel事件，以便Laravel Echo（一个JavaScript库）可以在浏览器客户端中接收它们。不用担心 - 我们将逐步介绍安装过程的每个部分。\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\n所有应用程序的事件广播配置都存储在`config/broadcasting.php`配置文件中。Laravel支持多个广播驱动程序：[Pusher Channels](https://pusher.com/channels)、[Redis](/docs/laravel/10.x/redis)和用于本地开发和调试的`log`驱动程序。此外，还包括一个`null`驱动程序，它允许你在测试期间完全禁用广播。`config/broadcasting.php`配置文件中包含每个驱动程序的配置示例。\r\n\r\n\r\n\r\n<a name=\"broadcast-service-provider\"></a>\r\n#### 广播服务提供商\r\n\r\n在广播任何事件之前，您首先需要注册 `App\\Providers\\BroadcastServiceProvider`。在新的 Laravel 应用程序中，您只需要在 `config/app.php` 配置文件的 `providers` 数组中取消注释此提供程序即可。这个 `BroadcastServiceProvider` 包含了注册广播授权路由和回调所需的代码。\r\n\r\n<a name=\"queue-configuration\"></a>\r\n#### 队列配置\r\n\r\n您还需要配置和运行一个[队列工作者](/docs/laravel/10.x/queues)。所有事件广播都是通过排队的作业完成的，以确保您的应用程序的响应时间不会受到广播事件的影响。\r\n\r\n<a name=\"pusher-channels\"></a>\r\n### Pusher Channels\r\n\r\n如果您计划使用[Pusher Channels](https://pusher.com/channels)广播您的事件，您应该使用 Composer 包管理器安装 Pusher Channels PHP SDK：\r\n\r\n```shell\r\ncomposer require pusher/pusher-php-server\r\n```\r\n\r\n接下来，您应该在 `config/broadcasting.php` 配置文件中配置 Pusher Channels 凭据。此文件中已经包含了一个示例 Pusher Channels 配置，让您可以快速指定您的密钥、密钥、应用程序 ID。通常，这些值应该通过 `PUSHER_APP_KEY`、`PUSHER_APP_SECRET` 和 `PUSHER_APP_ID`  [环境变量](/docs/laravel/10.x/configuration#environment-configuration) 设置：\r\n\r\n```ini\r\nPUSHER_APP_ID=your-pusher-app-id\r\nPUSHER_APP_KEY=your-pusher-key\r\nPUSHER_APP_SECRET=your-pusher-secret\r\nPUSHER_APP_CLUSTER=mt1\r\n```\r\n\r\n`config/broadcasting.php` 文件的 `pusher` 配置还允许您指定 Channels 支持的其他 `options`，例如集群。\r\n\r\n接下来，您需要在您的 `.env` 文件中将广播驱动程序更改为 `pusher`：\r\n\r\n```ini\r\nBROADCAST_DRIVER=pusher\r\n```\r\n\r\n\r\n\r\n最后，您已经准备好安装和配置[Laravel Echo](#client-side-installation)，它将在客户端接收广播事件。\r\n\r\n<a name=\"pusher-compatible-open-source-alternatives\"></a>\r\n#### 开源的Pusher替代品\r\n\r\n[laravel-websockets](https://github.com/beyondcode/laravel-websockets)和[soketi](https://docs.soketi.app/)软件包提供了适用于Laravel的Pusher兼容的WebSocket服务器。这些软件包允许您利用Laravel广播的全部功能，而无需商业WebSocket提供程序。有关安装和使用这些软件包的更多信息，请参阅我们的[开源替代品文档](#open-source-alternatives)。\r\n\r\n<a name=\"ably\"></a>\r\n### Ably\r\n\r\n>**注意** 下面的文档介绍了如何在“Pusher兼容”模式下使用Ably。然而，Ably团队推荐并维护一个广播器和Echo客户端，能够利用Ably提供的独特功能。有关使用Ably维护的驱动程序的更多信息，请[参阅Ably的Laravel广播器文档](https://github.com/ably/laravel-broadcaster)。\r\n\r\n如果您计划使用[Ably](https://ably.com/)广播您的事件，则应使用Composer软件包管理器安装Ably PHP SDK：\r\n\r\n```shell\r\ncomposer require ably/ably-php\r\n```\r\n\r\n接下来，您应该在`config/broadcasting.php`配置文件中配置您的Ably凭据。该文件已经包含了一个示例Ably配置，允许您快速指定您的密钥。通常，此值应通过`ABLY_KEY`[环境变量](/docs/laravel/10.x/configuration#environment-configuration)进行设置：\r\n\r\n```ini\r\nABLY_KEY=your-ably-key\r\n```\r\n\r\nNext, you will need to change your broadcast driver to `ably` in your `.env` file:\r\n\r\n```ini\r\nBROADCAST_DRIVER=ably\r\n```\r\n\r\n接下来，您需要在`.env`文件中将广播驱动程序更改为`ably`：\r\n\r\n\r\n\r\n<a name=\"open-source-alternatives\"></a>\r\n### 开源替代方案\r\n\r\n<a name=\"open-source-alternatives-php\"></a>\r\n#### PHP\r\n\r\n[laravel-websockets](https://github.com/beyondcode/laravel-websockets) 是一个纯 PHP 的，与 Pusher 兼容的 Laravel WebSocket 包。该包允许您充分利用 Laravel 广播的功能，而无需商业 WebSocket 提供商。有关安装和使用此包的更多信息，请参阅其[官方文档](https://beyondco.de/docs/laravel-websockets)。\r\n\r\n<a name=\"open-source-alternatives-node\"></a>\r\n#### Node\r\n\r\n[Soketi](https://github.com/soketi/soketi) 是一个基于 Node 的，与 Pusher 兼容的 Laravel WebSocket 服务器。在幕后，Soketi 利用 µWebSockets.js 来实现极端的可扩展性和速度。该包允许您充分利用 Laravel 广播的功能，而无需商业 WebSocket 提供商。有关安装和使用此包的更多信息，请参阅其[官方文档](https://docs.soketi.app/)。\r\n\r\n<a name=\"client-side-installation\"></a>\r\n## 客户端安装\r\n\r\n<a name=\"client-pusher-channels\"></a>\r\n### Pusher Channels\r\n\r\n[Laravel Echo](https://github.com/laravel/echo) 是一个 JavaScript 库，可以轻松订阅通道并监听由服务器端广播驱动程序广播的事件。您可以通过 NPM 包管理器安装 Echo。在此示例中，我们还将安装 `pusher-js` 包，因为我们将使用 Pusher Channels 广播器：\r\n\r\n```shell\r\nnpm install --save-dev laravel-echo pusher-js\r\n```\r\n\r\n安装 Echo 后，您可以在应用程序的 JavaScript 中创建一个新的 Echo 实例。一个很好的地方是在 Laravel 框架附带的 `resources/js/bootstrap.js` 文件的底部创建它。默认情况下，该文件中已包含一个示例 Echo 配置 - 您只需取消注释即可：\r\n\r\n```js\r\nimport Echo from 'laravel-echo';\r\nimport Pusher from 'pusher-js';\r\n\r\nwindow.Pusher = Pusher;\r\n\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    key: import.meta.env.VITE_PUSHER_APP_KEY,\r\n    cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,\r\n    forceTLS: true\r\n});\r\n```\r\n\r\n\r\n\r\n一旦您根据自己的需求取消注释并调整了 Echo 配置，就可以编译应用程序的资产：\r\n\r\n```shell\r\nnpm run dev\r\n```\r\n\r\n> **注意** \r\n> 要了解有关编译应用程序的 JavaScript 资产的更多信息，请参阅 [Vite](/docs/laravel/10.x/vite) 上的文档。\r\n\r\n<a name=\"using-an-existing-client-instance\"></a>\r\n#### 使用现有的客户端实例\r\n\r\n如果您已经有一个预配置的 Pusher Channels 客户端实例，并希望 Echo 利用它，您可以通过 `client` 配置选项将其传递给 Echo：\r\n\r\n```js\r\nimport Echo from 'laravel-echo';\r\nimport Pusher from 'pusher-js';\r\n\r\nconst options = {\r\n    broadcaster: 'pusher',\r\n    key: 'your-pusher-channels-key'\r\n}\r\n\r\nwindow.Echo = new Echo({\r\n    ...options,\r\n    client: new Pusher(options.key, options)\r\n});\r\n```\r\n\r\n<a name=\"client-ably\"></a>\r\n### Ably\r\n\r\n> **注意** \r\n> 下面的文档讨论如何在“Pusher 兼容性”模式下使用 Ably。但是，Ably 团队推荐和维护了一个广播器和 Echo 客户端，可以利用 Ably 提供的独特功能。有关使用由 Ably 维护的驱动程序的更多信息，请[查看 Ably 的 Laravel 广播器文档](https://github.com/ably/laravel-broadcaster)。\r\n\r\n[Laravel Echo](https://github.com/laravel/echo) 是一个 JavaScript 库，可以轻松订阅通道并侦听服务器端广播驱动程序广播的事件。您可以通过 NPM 包管理器安装 Echo。在本示例中，我们还将安装 `pusher-js` 包。\r\n\r\n您可能会想为什么我们要安装 `pusher-js` JavaScript 库，即使我们使用 Ably 来广播事件。幸运的是，Ably 包括 Pusher 兼容性模式，让我们可以在客户端应用程序中使用 Pusher 协议来侦听事件：\r\n\r\n```shell\r\nnpm install --save-dev laravel-echo pusher-js\r\n```\r\n\r\n\r\n\r\n**在继续之前，你应该在你的 Ably 应用设置中启用 Pusher 协议支持。你可以在你的 Ably 应用设置仪表板的“协议适配器设置”部分中启用此功能。**\r\n\r\n安装 Echo 后，你可以在应用的 JavaScript 中创建一个新的 Echo 实例。一个很好的地方是在 Laravel 框架附带的 `resources/js/bootstrap.js` 文件底部。默认情况下，此文件中已包含一个示例 Echo 配置；但是，`bootstrap.js` 文件中的默认配置是为 Pusher 设计的。你可以复制以下配置来将配置转换为 Ably：\r\n\r\n```js\r\nimport Echo from 'laravel-echo';\r\nimport Pusher from 'pusher-js';\r\n\r\nwindow.Pusher = Pusher;\r\n\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    key: import.meta.env.VITE_ABLY_PUBLIC_KEY,\r\n    wsHost: 'realtime-pusher.ably.io',\r\n    wsPort: 443,\r\n    disableStats: true,\r\n    encrypted: true,\r\n});\r\n```\r\n\r\n请注意，我们的 Ably Echo 配置引用了一个 `VITE_ABLY_PUBLIC_KEY` 环境变量。该变量的值应该是你的 Ably 公钥。你的公钥是出现在 Ably 密钥的 `:` 字符之前的部分。\r\n\r\n一旦你根据需要取消注释并调整 Echo 配置，你可以编译应用的资产：\r\n\r\n```shell\r\nnpm run dev\r\n```\r\n> **注意**\r\n> 要了解有关编译应用程序的 JavaScript 资产的更多信息，请参阅 [Vite](/docs/laravel/10.x/vite) 的文档。\r\n\r\n<a name=\"concept-overview\"></a>\r\n## 概念概述\r\n\r\nLaravel 的事件广播允许你使用基于驱动程序的 WebSocket 方法，将服务器端 Laravel 事件广播到客户端的 JavaScript 应用程序。目前，Laravel 附带了 [Pusher Channels](https://pusher.com/channels) 和 [Ably](https://ably.com/) 驱动程序。可以使用 [Laravel Echo](#client-side-installation) JavaScript 包轻松地在客户端消耗这些事件。\r\n\r\n\r\n\r\n事件通过“通道”广播，可以指定为公共或私有。任何访问您的应用程序的用户都可以订阅公共频道，无需进行身份验证或授权；但是，要订阅私有频道，用户必须经过身份验证和授权以便监听该频道。\r\n\r\n\r\n> **注意**  \r\n> 如果您想探索 Pusher 的开源替代品，请查看[开源替代品](#open-source-alternatives)。\r\n\r\n<a name=\"using-example-application\"></a>\r\n### 使用示例应用程序\r\n\r\n在深入了解事件广播的每个组件之前，让我们使用电子商务店铺作为示例进行高级概述。\r\n\r\n在我们的应用程序中，假设我们有一个页面，允许用户查看其订单的发货状态。假设在应用程序处理发货状态更新时，将触发一个 `OrderShipmentStatusUpdated` 事件：\r\n\r\n    use App\\Events\\OrderShipmentStatusUpdated;\r\n\r\n    OrderShipmentStatusUpdated::dispatch($order);\r\n\r\n<a name=\"the-shouldbroadcast-interface\"></a>\r\n#### ShouldBroadcast 接口\r\n\r\n当用户查看其订单之一时，我们不希望他们必须刷新页面才能查看状态更新。相反，我们希望在创建更新时将更新广播到应用程序。因此，我们需要使用 `ShouldBroadcast` 接口标记 `OrderShipmentStatusUpdated` 事件。这将指示 Laravel 在触发事件时广播该事件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Broadcasting\\Channel;\r\n    use Illuminate\\Broadcasting\\InteractsWithSockets;\r\n    use Illuminate\\Broadcasting\\PresenceChannel;\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipmentStatusUpdated implements ShouldBroadcast\r\n    {\r\n        /**\r\n         * The order instance.\r\n         *\r\n         * @var \\App\\Order\r\n         */\r\n        public $order;\r\n    }\r\n\r\n\r\n\r\n`ShouldBroadcast`接口要求我们的事件定义一个`broadcastOn`方法。该方法负责返回事件应广播到的频道。在生成的事件类中已经定义了这个方法的空桩，所以我们只需要填写它的细节即可。我们只希望订单的创建者能够查看状态更新，因此我们将事件广播到与订单相关的私有频道上：\r\n\r\n    use Illuminate\\Broadcasting\\Channel;\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n\r\n    /**\r\n     * 获取事件应该广播到的频道。\r\n     */\r\n    public function broadcastOn(): Channel\r\n    {\r\n        return new PrivateChannel('orders.'.$this->order->id);\r\n    }\r\n\r\n如果你希望事件广播到多个频道，可以返回一个`array`：\r\n\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n\r\n    /**\r\n     * 获取事件应该广播到的频道。\r\n     *\r\n     * @return array<int, \\Illuminate\\Broadcasting\\Channel>\r\n     */\r\n    public function broadcastOn(): array\r\n    {\r\n        return [\r\n            new PrivateChannel('orders.'.$this->order->id),\r\n            // ...\r\n        ];\r\n    }\r\n\r\n<a name=\"example-application-authorizing-channels\"></a>\r\n#### 授权频道\r\n\r\n记住，用户必须被授权才能监听私有频道。我们可以在应用程序的`routes/channels.php`文件中定义频道授权规则。在这个例子中，我们需要验证任何试图监听私有`orders.1`频道的用户是否实际上是订单的创建者：\r\n\r\n    use App\\Models\\Order;\r\n    use App\\Models\\User;\r\n\r\n    Broadcast::channel('orders.{orderId}', function (User $user, int $orderId) {\r\n        return $user->id === Order::findOrNew($orderId)->user_id;\r\n    });\r\n\r\n`channel`方法接受两个参数：频道名称和一个回调函数，该函数返回`true`或`false`，表示用户是否被授权监听该频道。\r\n\r\n\r\n\r\n所有授权回调函数的第一个参数是当前认证的用户，其余的通配符参数是它们的后续参数。在此示例中，我们使用`{orderId}`占位符来指示频道名称的“ID”部分是通配符。\r\n\r\n<a name=\"listening-for-event-broadcasts\"></a>\r\n#### 监听事件广播\r\n\r\n接下来，我们只需要在JavaScript应用程序中监听事件即可。我们可以使用[Laravel Echo](#client-side-installation)来完成这个过程。首先，我们使用`private`方法订阅私有频道。然后，我们可以使用`listen`方法来监听`OrderShipmentStatusUpdated`事件。默认情况下，广播事件的所有公共属性将被包括在广播事件中：\r\n\r\n```js\r\nEcho.private(`orders.${orderId}`)\r\n    .listen('OrderShipmentStatusUpdated', (e) => {\r\n        console.log(e.order);\r\n    });\r\n```\r\n\r\n<a name=\"defining-broadcast-events\"></a>\r\n## 定义广播事件\r\n\r\n要通知 Laravel 给定事件应该被广播，您必须在事件类上实现`Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast`接口。该接口已经被框架生成的所有事件类导入，因此您可以轻松地将其添加到任何事件中。\r\n\r\n`ShouldBroadcast`接口要求您实现一个单独的方法:`broadcastOn`。`broadcastOn`方法应该返回一个频道或频道数组，事件应该在这些频道上广播。这些频道应该是`Channel`、`PrivateChannel`或`PresenceChannel`的实例。`Channel`的实例表示任何用户都可以订阅的公共频道，而`PrivateChannel`和`PresenceChannel`表示需要[频道授权](#authorizing-channels)的私有频道：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Broadcasting\\Channel;\r\n    use Illuminate\\Broadcasting\\InteractsWithSockets;\r\n    use Illuminate\\Broadcasting\\PresenceChannel;\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ServerCreated implements ShouldBroadcast\r\n    {\r\n        use SerializesModels;\r\n\r\n        /**\r\n         * 创建一个新的事件实例。\r\n         */\r\n        public function __construct(\r\n            public User $user,\r\n        ) {}\r\n\r\n        /**\r\n         * 获取事件应该广播到哪些频道。\r\n         *\r\n         * @return array<int, \\Illuminate\\Broadcasting\\Channel>\r\n         */\r\n        public function broadcastOn(): array\r\n        {\r\n            return [\r\n                new PrivateChannel('user.'.$this->user->id),\r\n            ];\r\n        }\r\n    }\r\n\r\n\r\n\r\n实现 `ShouldBroadcast` 接口后，您只需要像平常一样[触发事件](/docs/laravel/10.x/events)。一旦事件被触发，一个[队列任务](/docs/laravel/10.x/queues)将自动使用指定的广播驱动程序广播该事件。\r\n\r\n<a name=\"broadcast-name\"></a>\r\n### 广播名称\r\n\r\n默认情况下，Laravel将使用事件类名广播事件。但是，您可以通过在事件上定义 `broadcastAs` 方法来自定义广播名称：\r\n\r\n    /**\r\n     * 活动的广播名称\r\n     */\r\n    public function broadcastAs(): string\r\n    {\r\n        return 'server.created';\r\n    }\r\n\r\n如果您使用 `broadcastAs` 方法自定义广播名称，则应确保使用前导“.”字符注册您的侦听器。这将指示 Echo 不将应用程序的命名空间添加到事件中：\r\n\r\n    .listen('.server.created', function (e) {\r\n        ....\r\n    });\r\n\r\n<a name=\"broadcast-data\"></a>\r\n### 广播数据\r\n\r\n当广播事件时，所有 `public` 属性都将自动序列化并广播为事件负载，使您能够从 JavaScript 应用程序中访问其任何公共数据。例如，如果您的事件具有单个公共 `$user` 属性，其中包含 Eloquent 模型，则事件的广播负载将是：\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"id\": 1,\r\n        \"name\": \"Patrick Stewart\"\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\n但是，如果您希望更精细地控制广播负载，则可以向事件中添加 `broadcastWith` 方法。该方法应该返回您希望作为事件负载广播的数据数组：\r\n\r\n    /**\r\n     * 获取要广播的数据。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function broadcastWith(): array\r\n    {\r\n        return ['id' => $this->user->id];\r\n    }\r\n\r\n<a name=\"broadcast-queue\"></a>\r\n\r\n\r\n### 广播队列\r\n\r\n默认情况下，每个广播事件都会被放置在您在 `queue.php` 配置文件中指定的默认队列连接的默认队列上。您可以通过在事件类上定义 `connection` 和 `queue` 属性来自定义广播器使用的队列连接和名称：\r\n\r\n    /**\r\n     * 广播事件时要使用的队列连接的名称。\r\n     *\r\n     * @var string\r\n     */\r\n    public $connection = 'redis';\r\n\r\n    /**\r\n     * 广播作业要放置在哪个队列上的名称。\r\n     *\r\n     * @var string\r\n     */\r\n    public $queue = 'default';\r\n\r\n或者，您可以通过在事件上定义一个 `broadcastQueue` 方法来自定义队列名称：\r\n\r\n    /**\r\n     * 广播作业放置在其上的队列的名称。\r\n     */\r\n    public function broadcastQueue(): string\r\n    {\r\n        return 'default';\r\n    }\r\n\r\n如果您想要使用 `sync` 队列而不是默认的队列驱动程序来广播事件，您可以实现 `ShouldBroadcastNow` 接口而不是 `ShouldBroadcast` 接口：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow;\r\n\r\n    class OrderShipmentStatusUpdated implements ShouldBroadcastNow\r\n    {\r\n        // ...\r\n    }\r\n\r\n<a name=\"broadcast-conditions\"></a>\r\n### 广播条件\r\n\r\n有时候您只想在给定条件为真时才广播事件。您可以通过在事件类中添加一个 `broadcastWhen` 方法来定义这些条件：\r\n\r\n    /**\r\n     * 确定此事件是否应该广播。\r\n     */\r\n    public function broadcastWhen(): bool\r\n    {\r\n        return $this->order->value > 100;\r\n    }\r\n\r\n<a name=\"broadcasting-and-database-transactions\"></a>\r\n#### 广播和数据库事务\r\n\r\n当在数据库事务中分派广播事件时，它们可能会在数据库事务提交之前被队列处理。当这种情况发生时，在数据库中对模型或数据库记录所做的任何更新可能尚未反映在数据库中。此外，在事务中创建的任何模型或数据库记录可能不存在于数据库中。如果您的事件依赖于这些模型，则在处理广播事件的作业时可能会出现意外错误。\r\n\r\n\r\n\r\n如果您的队列连接的`after_commit`配置选项设置为`false`，您仍然可以通过在事件类上定义`$afterCommit`属性来指示特定的广播事件在所有打开的数据库事务提交后被调度：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ServerCreated implements ShouldBroadcast\r\n    {\r\n        use SerializesModels;\r\n\r\n        public $afterCommit = true;\r\n    }\r\n\r\n> **注意**\r\n> 要了解更多有关解决这些问题的信息，请查阅有关[队列作业和数据库事务](https://chat.openai.com/docs/laravel/10.x/queues#jobs-and-database-transactions)的文档。\r\n\r\n<a name=\"authorizing-channels\"></a>\r\n## 授权频道\r\n\r\n私有频道需要您授权当前已验证的用户是否实际上可以监听该频道。这可以通过向您的 Laravel 应用程序发送带有频道名称的 HTTP 请求来完成，并允许您的应用程序确定用户是否可以在该频道上监听。当使用[Laravel Echo](#client-side-installation)时，将自动进行授权订阅私有频道的 HTTP 请求；但是，您需要定义正确的路由来响应这些请求。\r\n\r\n<a name=\"defining-authorization-routes\"></a>\r\n### 定义授权路由\r\n\r\n幸运的是，Laravel 可以轻松定义用于响应频道授权请求的路由。在您的 Laravel 应用程序中包含的`App\\Providers\\BroadcastServiceProvider`中，您将看到对`Broadcast::routes`方法的调用。此方法将注册`/broadcasting/auth`路由以处理授权请求：\r\n\r\n    Broadcast::routes();\r\n\r\n`Broadcast::routes`方法将自动将其路由放置在`web`中间件组中；但是，如果您想自定义分配的属性，则可以将路由属性数组传递给该方法：\r\n\r\n    Broadcast::routes($attributes);\r\n\r\n\r\n\r\n<a name=\"customizing-the-authorization-endpoint\"></a>\r\n#### 自定义授权终点\r\n\r\n默认情况下，Echo 将使用 `/broadcasting/auth` 终点来授权频道访问。但是，您可以通过将 `authEndpoint` 配置选项传递给 Echo 实例来指定自己的授权终点：\r\n\r\n```js\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    // ...\r\n    authEndpoint: '/custom/endpoint/auth'\r\n});\r\n```\r\n\r\n<a name=\"customizing-the-authorization-request\"></a>\r\n#### 自定义授权请求\r\n\r\n您可以在初始化 Echo 时提供自定义授权器来自定义 Laravel Echo 如何执行授权请求：\r\n\r\n```js\r\nwindow.Echo = new Echo({\r\n    // ...\r\n    authorizer: (channel, options) => {\r\n        return {\r\n            authorize: (socketId, callback) => {\r\n                axios.post('/api/broadcasting/auth', {\r\n                    socket_id: socketId,\r\n                    channel_name: channel.name\r\n                })\r\n                .then(response => {\r\n                    callback(null, response.data);\r\n                })\r\n                .catch(error => {\r\n                    callback(error);\r\n                });\r\n            }\r\n        };\r\n    },\r\n})\r\n```\r\n\r\n<a name=\"defining-authorization-callbacks\"></a>\r\n### 定义授权回调函数\r\n\r\n接下来，我们需要定义实际确定当前认证用户是否可以收听给定频道的逻辑。这是在您的应用程序中包含的 `routes/channels.php` 文件中完成的。在该文件中，您可以使用 `Broadcast::channel` 方法来注册频道授权回调函数：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Broadcast::channel('orders.{orderId}', function (User $user, int $orderId) {\r\n        return $user->id === Order::findOrNew($orderId)->user_id;\r\n    });\r\n\r\n`channel` 方法接受两个参数：频道名称和一个回调函数，该回调函数返回 `true` 或 `false`，指示用户是否有权限在频道上收听。\r\n\r\n所有授权回调函数都接收当前认证用户作为其第一个参数，任何其他通配符参数作为其后续参数。在此示例中，我们使用 `{orderId}` 占位符来指示频道名称的 \"ID\" 部分是通配符。\r\n\r\n\r\n\r\n您可以使用`channel:list` Artisan命令查看应用程序的广播授权回调列表：\r\n\r\n```shell\r\nphp artisan channel:list\r\n```\r\n\r\n<a name=\"authorization-callback-model-binding\"></a>\r\n#### 授权回调模型绑定\r\n\r\n与HTTP路由一样，频道路由也可以利用隐式和显式的[路由模型绑定](/docs/laravel/10.x/routing#route-model-binding)。例如，您可以请求一个实际的 `Order` 模型实例，而不是接收一个字符串或数字订单ID：\r\n\r\n    use App\\Models\\Order;\r\n    use App\\Models\\User;\r\n\r\n    Broadcast::channel('orders.{order}', function (User $user, Order $order) {\r\n        return $user->id === $order->user_id;\r\n    });\r\n\r\n> **警告**\r\n> 与HTTP路由模型绑定不同，频道模型绑定不支持自动[隐式模型绑定范围](/docs/laravel/10.x/routing#implicit-model-binding-scoping)。但是，这很少是问题，因为大多数频道可以基于单个模型的唯一主键进行范围限制。\r\n\r\n<a name=\"authorization-callback-authentication\"></a>\r\n#### 授权回调身份验证\r\n\r\n私有和存在广播频道会通过您的应用程序的默认身份验证保护当前用户。如果用户未经过身份验证，则频道授权将自动被拒绝，并且不会执行授权回调。但是，您可以分配多个自定义守卫，以根据需要对传入请求进行身份验证：\r\n\r\n    Broadcast::channel('channel', function () {\r\n        // ...\r\n    }, ['guards' => ['web', 'admin']]);\r\n\r\n<a name=\"defining-channel-classes\"></a>\r\n### 定义频道类\r\n\r\n如果您的应用程序正在消耗许多不同的频道，则您的 `routes/channels.php` 文件可能会变得臃肿。因此，您可以使用频道类而不是使用闭包来授权频道。要生成一个频道类，请使用 `make:channel` Artisan命令。该命令将在 `App/Broadcasting` 目录中放置一个新的频道类。\r\n\r\n```shell\r\nphp artisan make:channel OrderChannel\r\n```\r\n\r\n\r\n\r\n接下来，在您的 `routes/channels.php` 文件中注册您的频道：\r\n\r\n    use App\\Broadcasting\\OrderChannel;\r\n\r\n    Broadcast::channel('orders.{order}', OrderChannel::class);\r\n\r\n最后，您可以将频道授权逻辑放在频道类的 `join` 方法中。这个 `join` 方法将包含您通常放置在频道授权闭包中的相同逻辑。您还可以利用频道模型绑定：\r\n\r\n    <?php\r\n\r\n    namespace App\\Broadcasting;\r\n\r\n    use App\\Models\\Order;\r\n    use App\\Models\\User;\r\n\r\n    class OrderChannel\r\n    {\r\n        /**\r\n         * 创建一个新的频道实例。\r\n         */\r\n        public function __construct()\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 验证用户对频道的访问权限。\r\n         */\r\n        public function join(User $user, Order $order): array|bool\r\n        {\r\n            return $user->id === $order->user_id;\r\n        }\r\n    }\r\n\r\n> **注意**\r\n> 像 Laravel 中的许多其他类一样，频道类将自动由[服务容器](/docs/laravel/10.x/container)解析。因此，您可以在其构造函数中声明频道所需的任何依赖关系。\r\n\r\n<a name=\"broadcasting-events\"></a>\r\n## 广播事件\r\n\r\n一旦您定义了一个事件并使用 `ShouldBroadcast` 接口标记了它，您只需要使用事件的 `dispatch` 方法来触发事件。事件调度程序会注意到该事件已标记为 `ShouldBroadcast` 接口，并将该事件排队进行广播：\r\n\r\n    use App\\Events\\OrderShipmentStatusUpdated;\r\n\r\n    OrderShipmentStatusUpdated::dispatch($order);\r\n\r\n<a name=\"only-to-others\"></a>\r\n### 只发给其他人\r\n\r\n在构建使用事件广播的应用程序时，您可能需要将事件广播给给定频道的所有订阅者，除了当前用户。您可以使用 `broadcast` 帮助器和 `toOthers` 方法来实现：\r\n\r\n    use App\\Events\\OrderShipmentStatusUpdated;\r\n\r\n    broadcast(new OrderShipmentStatusUpdated($update))->toOthers();\r\n\r\n\r\n\r\n为了更好地理解何时需要使用`toOthers`方法，让我们想象一个任务列表应用程序，用户可以通过输入任务名称来创建新任务。为了创建任务，您的应用程序可能会向`/task` URL发出请求，该请求广播任务的创建并返回新任务的JSON表示。当JavaScript应用程序从端点接收到响应时，它可能会直接将新任务插入到其任务列表中，如下所示：\r\n\r\n```js\r\naxios.post('/task', task)\r\n    .then((response) => {\r\n        this.tasks.push(response.data);\r\n    });\r\n```\r\n\r\n然而，请记住，我们也会广播任务的创建。如果JavaScript应用程序也在监听此事件以便将任务添加到任务列表中，那么您的列表中将有重复的任务：一个来自端点，一个来自广播。您可以使用`toOthers`方法来解决这个问题，指示广播器不要向当前用户广播事件。\r\n\r\n> **警告**\r\n> 您的事件必须使用`Illuminate\\Broadcasting\\InteractsWithSockets`特性才能调用`toOthers`方法。\r\n\r\n<a name=\"only-to-others-configuration\"></a>\r\n#### 配置\r\n\r\n当您初始化一个Laravel Echo实例时，将为连接分配一个套接字ID。如果您正在使用全局的[Axios](https://github.com/mzabriskie/axios)实例从JavaScript应用程序发出HTTP请求，则套接字ID将自动附加到每个传出请求作为`X-Socket-ID`头。然后，当您调用`toOthers`方法时，Laravel将从标头中提取套接字ID，并指示广播器不向具有该套接字ID的任何连接广播。\r\n\r\n\r\n\r\n如果您没有使用全局的 Axios 实例，您需要手动配置 JavaScript 应用程序，以在所有传出请求中发送 `X-Socket-ID` 标头。您可以使用 `Echo.socketId` 方法检索 socket ID：\r\n\r\n```js\r\nvar socketId = Echo.socketId();\r\n```\r\n\r\n<a name=\"customizing-the-connection\"></a>\r\n### 定制连接\r\n\r\n如果您的应用程序与多个广播连接交互，并且您想使用除默认之外的广播器广播事件，则可以使用 `via` 方法指定要将事件推送到哪个连接：\r\n\r\n    use App\\Events\\OrderShipmentStatusUpdated;\r\n\r\n    broadcast(new OrderShipmentStatusUpdated($update))->via('pusher');\r\n\r\n或者，您可以在事件的构造函数中调用 `broadcastVia` 方法指定事件的广播连接。不过，在这样做之前，您应该确保事件类使用了 `InteractsWithBroadcasting` trait：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use Illuminate\\Broadcasting\\Channel;\r\n    use Illuminate\\Broadcasting\\InteractsWithBroadcasting;\r\n    use Illuminate\\Broadcasting\\InteractsWithSockets;\r\n    use Illuminate\\Broadcasting\\PresenceChannel;\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n    use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipmentStatusUpdated implements ShouldBroadcast\r\n    {\r\n        use InteractsWithBroadcasting;\r\n\r\n        /**\r\n         * 创建一个新的事件实例。\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->broadcastVia('pusher');\r\n        }\r\n    }\r\n\r\n<a name=\"receiving-broadcasts\"></a>\r\n## 接收广播\r\n\r\n<a name=\"listening-for-events\"></a>\r\n### 监听事件\r\n\r\n一旦您 [安装并实例化了 Laravel Echo](#client-side-installation)，您就可以开始监听从 Laravel 应用程序广播的事件。首先使用 `channel` 方法检索通道实例，然后调用 `listen` 方法来监听指定的事件：\r\n\r\n```js\r\nEcho.channel(`orders.${this.order.id}`)\r\n    .listen('OrderShipmentStatusUpdated', (e) => {\r\n        console.log(e.order.name);\r\n    });\r\n```\r\n\r\n\r\n\r\n如需在私有频道上监听事件，请改用`private`方法。您可以继续链式调用`listen`方法以侦听单个频道上的多个事件：\r\n\r\n```js\r\nEcho.private(`orders.${this.order.id}`)\r\n    .listen(/* ... */)\r\n    .listen(/* ... */)\r\n    .listen(/* ... */);\r\n```\r\n\r\n<a name=\"stop-listening-for-events\"></a>\r\n#### 停止监听事件\r\n\r\n如果您想停止侦听给定事件而不离开频道，可以使用`stopListening`方法：\r\n\r\n```js\r\nEcho.private(`orders.${this.order.id}`)\r\n    .stopListening('OrderShipmentStatusUpdated')\r\n```\r\n\r\n<a name=\"leaving-a-channel\"></a>\r\n### 离开频道\r\n\r\n要离开频道，请在Echo实例上调用`leaveChannel`方法：\r\n\r\n```js\r\nEcho.leaveChannel(`orders.${this.order.id}`);\r\n```\r\n\r\n如果您想离开频道以及其关联的私有和预​​sence频道，则可以调用`leave`方法：\r\n\r\n```js\r\nEcho.leave(`orders.${this.order.id}`);\r\n```\r\n<a name=\"namespaces\"></a>\r\n### 命名空间\r\n\r\n您可能已经注意到在上面的示例中，我们没有指定事件类的完整`App\\Events`命名空间。这是因为Echo将自动假定事件位于`App\\Events`命名空间中。但是，您可以在实例化Echo时通过传递`namespace`配置选项来配置根命名空间：\r\n\r\n```js\r\nwindow.Echo = new Echo({\r\n    broadcaster: 'pusher',\r\n    // ...\r\n    namespace: 'App.Other.Namespace'\r\n});\r\n```\r\n\r\n或者，您可以在使用Echo订阅时使用`。`前缀为事件类添加前缀。这将允许您始终指定完全限定的类名：\r\n```js\r\nEcho.channel('orders')\r\n    .listen('.Namespace\\\\Event\\\\Class', (e) => {\r\n        // ...\r\n    });\r\n```\r\n\r\n<a name=\"presence-channels\"></a>\r\n\r\n\r\n## 存在频道\r\n\r\n存在频道基于私有频道的安全性，并公开了订阅频道用户的附加功能。这使得构建强大的协作应用程序功能变得容易，例如在另一个用户正在查看同一页面时通知用户，或者列出聊天室的用户。\r\n\r\n<a name=\"authorizing-presence-channels\"></a>\r\n### 授权存在频道\r\n\r\n所有存在频道也都是私有频道，因此用户必须获得[访问权限](#authorizing-channels)。但是，在为存在频道定义授权回调时，如果用户被授权加入该频道，您将不会返回`true`。相反，您应该返回有关用户的数据数组。\r\n\r\n授权回调返回的数据将在JavaScript应用程序中的存在频道事件侦听器中可用。如果用户没有被授权加入存在频道，则应返回`false`或`null`：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Broadcast::channel('chat.{roomId}', function (User $user, int $roomId) {\r\n        if ($user->canJoinRoom($roomId)) {\r\n            return ['id' => $user->id, 'name' => $user->name];\r\n        }\r\n    });\r\n\r\n<a name=\"joining-presence-channels\"></a>\r\n### 加入存在频道\r\n\r\n要加入存在频道，您可以使用Echo的`join`方法。`join`方法将返回一个`PresenceChannel`实现，除了公开`listen`方法外，还允许您订阅`here`，`joining`和`leaving`事件。\r\n\r\n```js\r\nEcho.join(`chat.${roomId}`)\r\n    .here((users) => {\r\n        // ...\r\n    })\r\n    .joining((user) => {\r\n        console.log(user.name);\r\n    })\r\n    .leaving((user) => {\r\n        console.log(user.name);\r\n    })\r\n    .error((error) => {\r\n        console.error(error);\r\n    });\r\n```\r\n\r\n成功加入频道后，`here`回调将立即执行，并接收一个包含所有当前订阅频道用户信息的数组。`joining`方法将在新用户加入频道时执行，而`leaving`方法将在用户离开频道时执行。当认证端点返回HTTP状态码200以外的代码或存在解析返回的JSON时，将执行`error`方法。\r\n\r\n\r\n\r\n<a name=\"broadcasting-to-presence-channels\"></a>\r\n### 向 Presence 频道广播\r\n\r\nPresence 频道可以像公共频道或私有频道一样接收事件。以聊天室为例，我们可能希望将 `NewMessage` 事件广播到聊天室的 Presence 频道中。为此，我们将从事件的 `broadcastOn` 方法返回一个 `PresenceChannel` 实例：\r\n\r\n    /**\r\n     * Get the channels the event should broadcast on.\r\n     *\r\n     * @return array<int, \\Illuminate\\Broadcasting\\Channel>\r\n     */\r\n    public function broadcastOn(): array\r\n    {\r\n        return [\r\n            new PresenceChannel('room.'.$this->message->room_id),\r\n        ];\r\n    }\r\n\r\n与其他事件一样，您可以使用 `broadcast` 助手和 `toOthers` 方法来排除当前用户接收广播：\r\n\r\n    broadcast(new NewMessage($message));\r\n\r\n    broadcast(new NewMessage($message))->toOthers();\r\n\r\n与其他类型的事件一样，您可以使用 Echo 的 `listen` 方法来监听发送到 Presence 频道的事件：\r\n\r\n```js\r\nEcho.join(`chat.${roomId}`)\r\n    .here(/* ... */)\r\n    .joining(/* ... */)\r\n    .leaving(/* ... */)\r\n    .listen('NewMessage', (e) => {\r\n        // ...\r\n    });\r\n```\r\n\r\n<a name=\"model-broadcasting\"></a>\r\n## 模型广播\r\n\r\n> **警告**\r\n> 在阅读有关模型广播的以下文档之前，我们建议您熟悉 Laravel 模型广播服务的一般概念以及如何手动创建和监听广播事件。\r\n\r\n当创建、更新或删除应用程序的[Eloquent 模型](/docs/laravel/10.x/eloquent)时，通常会广播事件。当然，这可以通过手动[定义用于 Eloquent 模型状态更改的自定义事件](/docs/laravel/10.x/eloquent#events)并将这些事件标记为 `ShouldBroadcast` 接口来轻松完成。\r\n\r\n但是，如果您没有在应用程序中使用这些事件进行任何其他用途，则为仅广播它们的目的创建事件类可能会很麻烦。为解决这个问题，Laravel 允许您指示一个 Eloquent 模型应自动广播其状态更改。\r\n\r\n\r\n\r\n开始之前，你的Eloquent模型应该使用`Illuminate\\Database\\Eloquent\\BroadcastsEvents` trait。此外，模型应该定义一个`broadcastOn`方法，该方法将返回一个数组，该数组包含模型事件应该广播到的频道：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Broadcasting\\Channel;\r\nuse Illuminate\\Broadcasting\\PrivateChannel;\r\nuse Illuminate\\Database\\Eloquent\\BroadcastsEvents;\r\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\nuse Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\r\n\r\nclass Post extends Model\r\n{\r\n    use BroadcastsEvents, HasFactory;\r\n\r\n    /**\r\n     * 获取发帖用户\r\n     */\r\n    public function user(): BelongsTo\r\n    {\r\n        return $this->belongsTo(User::class);\r\n    }\r\n\r\n    /**\r\n     * 获取模型事件应该广播到的频道\r\n     *\r\n     * @return array<int, \\Illuminate\\Broadcasting\\Channel|\\Illuminate\\Database\\Eloquent\\Model>\r\n     */\r\n    public function broadcastOn(string $event): array\r\n    {\r\n        return [$this, $this->user];\r\n    }\r\n}\r\n```\r\n\r\n一旦你的模型包含了这个trait并定义了它的广播频道，当模型实例被创建、更新、删除、移到回收站或还原时，它将自动开始广播事件。\r\n\r\n另外，你可能已经注意到`broadcastOn`方法接收一个字符串`$event`参数。这个参数包含了在模型上发生的事件类型，将具有`created`、`updated`、`deleted`、`trashed`或`restored`的值。通过检查这个变量的值，你可以确定模型在特定事件上应该广播到哪些频道（如果有）：\r\n\r\n```php\r\n/**\r\n * 获取模型事件应该广播到的频道\r\n *\r\n * @return array<string, array<int, \\Illuminate\\Broadcasting\\Channel|\\Illuminate\\Database\\Eloquent\\Model>>\r\n */\r\npublic function broadcastOn(string $event): array\r\n{\r\n    return match ($event) {\r\n        'deleted' => [],\r\n        default => [$this, $this->user],\r\n    };\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"customizing-model-broadcasting-event-creation\"></a>\r\n#### 自定义模型广播事件创建\r\n\r\n有时候，您可能希望自定义 Laravel 创建底层模型广播事件的方式。您可以通过在您的 Eloquent 模型上定义一个 `newBroadcastableEvent` 方法来实现。这个方法应该返回一个 `Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred` 实例：\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred;\r\n\r\n/**\r\n * 为模型创建一个新的可广播模型事件。\r\n */\r\nprotected function newBroadcastableEvent(string $event): BroadcastableModelEventOccurred\r\n{\r\n    return (new BroadcastableModelEventOccurred(\r\n        $this, $event\r\n    ))->dontBroadcastToCurrentUser();\r\n}\r\n```\r\n\r\n<a name=\"model-broadcasting-conventions\"></a>\r\n### 模型广播约定\r\n\r\n<a name=\"model-broadcasting-channel-conventions\"></a>\r\n#### 频道约定\r\n\r\n您可能已经注意到，在上面的模型示例中，`broadcastOn` 方法没有返回 `Channel` 实例。相反，它直接返回了 Eloquent 模型。如果您的模型的 `broadcastOn` 方法返回了 Eloquent 模型实例（或者包含在方法返回的数组中），Laravel 将自动使用模型的类名和主键标识符作为频道名称为模型实例实例化一个私有频道实例。\r\n\r\n因此，`App\\Models\\User` 模型的 `id` 为 `1` 将被转换为一个名称为 `App.Models.User.1` 的 `Illuminate\\Broadcasting\\PrivateChannel` 实例。当然，除了从模型的 `broadcastOn` 方法返回 Eloquent 模型实例之外，您还可以返回完整的 `Channel` 实例，以完全控制模型的频道名称：\r\n\r\n```php\r\nuse Illuminate\\Broadcasting\\PrivateChannel;\r\n\r\n/**\r\n * 获取模型事件应该广播到的频道。\r\n *\r\n * @return array<int, \\Illuminate\\Broadcasting\\Channel>\r\n */\r\npublic function broadcastOn(string $event): array\r\n{\r\n    return [\r\n        new PrivateChannel('user.'.$this->id)\r\n    ];\r\n}\r\n```\r\n\r\n如果您打算从模型的 `broadcastOn` 方法中明确返回一个频道实例，您可以将一个 Eloquent 模型实例传递给频道的构造函数。这样做时，Laravel 将使用上面讨论的模型频道约定将 Eloquent 模型转换为频道名称字符串：\r\n\r\n```php\r\nreturn [new Channel($this->user)];\r\n```\r\n\r\n\r\n\r\n如果您需要确定模型的频道名称，可以在任何模型实例上调用`broadcastChannel`方法。例如，对于一个 `App\\Models\\User` 模型，它的 `id` 为 `1`，这个方法将返回字符串 `App.Models.User.1`：\r\n\r\n```php\r\n$user->broadcastChannel()\r\n```\r\n\r\n<a name=\"model-broadcasting-event-conventions\"></a>\r\n#### 事件约定\r\n\r\n由于模型广播事件与应用程序的 `App\\Events` 目录中的“实际”事件没有关联，它们会根据约定分配名称和负载。 Laravel 的约定是使用模型的类名（不包括命名空间）和触发广播的模型事件的名称来广播事件。\r\n\r\n例如，对 `App\\Models\\Post` 模型进行更新会将事件广播到您的客户端应用程序中，名称为 `PostUpdated`，负载如下：\r\n\r\n```json\r\n{\r\n    \"model\": {\r\n        \"id\": 1,\r\n        \"title\": \"My first post\"\r\n        ...\r\n    },\r\n    ...\r\n    \"socket\": \"someSocketId\",\r\n}\r\n```\r\n\r\n删除 `App\\Models\\User` 模型将广播名为 `UserDeleted` 的事件。\r\n\r\n如果需要，您可以通过在模型中添加 `broadcastAs` 和 `broadcastWith` 方法来定义自定义广播名称和负载。这些方法接收正在发生的模型事件/操作的名称，允许您为每个模型操作自定义事件的名称和负载。如果从 `broadcastAs` 方法返回 `null`，则 Laravel 将在广播事件时使用上述讨论的模型广播事件名称约定：\r\n\r\n```php\r\n/**\r\n * 模型事件的广播名称。\r\n */\r\npublic function broadcastAs(string $event): string|null\r\n{\r\n    return match ($event) {\r\n        'created' => 'post.created',\r\n        default => null,\r\n    };\r\n}\r\n\r\n/**\r\n * 获取要广播到模型的数据。\r\n *\r\n * @return array<string, mixed>\r\n */\r\npublic function broadcastWith(string $event): array\r\n{\r\n    return match ($event) {\r\n        'created' => ['title' => $this->title],\r\n        default => ['model' => $this],\r\n    };\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"listening-for-model-broadcasts\"></a>\r\n### 监听模型广播\r\n\r\n一旦您将`BroadcastsEvents` trait添加到您的模型中并定义了模型的`broadcastOn`方法，您就可以开始在客户端应用程序中监听广播的模型事件。在开始之前，您可能希望查阅完整的[事件监听文档](#listening-for-events)。\r\n\r\n首先，使用`private`方法获取一个通道实例，然后调用`listen`方法来监听指定的事件。通常，传递给`private`方法的通道名称应该对应于Laravel的[模型广播规则](#model-broadcasting-conventions)。\r\n\r\n获取通道实例后，您可以使用`listen`方法来监听特定事件。由于模型广播事件与应用程序的`App\\Events`目录中的\"实际\"事件不相关联，因此必须在事件名称前加上`.`以表示它不属于特定的命名空间。每个模型广播事件都有一个`model`属性，其中包含模型的所有可广播属性：\r\n\r\n```js\r\nEcho.private(`App.Models.User.${this.user.id}`)\r\n    .listen('.PostUpdated', (e) => {\r\n        console.log(e.model);\r\n    });\r\n```\r\n\r\n<a name=\"client-events\"></a>\r\n## 客户端事件\r\n\r\n> **注意**\r\n> 当使用[Pusher Channels](https://pusher.com/channels)时，您必须在[应用程序仪表板](https://dashboard.pusher.com/)的\"应用程序设置\"部分中启用\"客户端事件\"选项，以便发送客户端事件。\r\n\r\n有时您可能希望将事件广播给其他连接的客户端，而根本不会触发您的Laravel应用程序。这对于诸如\"正在输入\"通知非常有用，其中您希望向应用程序的用户通知另一个用户正在给定屏幕上输入消息。\r\n\r\n\r\n\r\n要广播客户端事件，你可以使用 Echo 的 `whisper` 方法：\r\n\r\n```js\r\nEcho.private(`chat.${roomId}`)\r\n    .whisper('typing', {\r\n        name: this.user.name\r\n    });\r\n```\r\n\r\n要监听客户端事件，你可以使用 `listenForWhisper` 方法：\r\n\r\n```js\r\nEcho.private(`chat.${roomId}`)\r\n    .listenForWhisper('typing', (e) => {\r\n        console.log(e.name);\r\n    });\r\n```\r\n\r\n<a name=\"notifications\"></a>\r\n## 通知\r\n\r\n通过将事件广播与 [notifications](/docs/laravel/10.x/notifications) 配对，你的 JavaScript 应用程序可以在新通知发生时接收它们，而无需刷新页面。在开始之前，请务必阅读有关使用 [广播通知频道](/docs/laravel/10.x/notifications#broadcast-notifications) 的文档。\r\n\r\n一旦你配置了一个使用广播频道的通知，你就可以使用 Echo 的 `notification` 方法来监听广播事件。请记住，通道名称应与接收通知的实体的类名称匹配：\r\n\r\n```js\r\nEcho.private(`App.Models.User.${userId}`)\r\n    .notification((notification) => {\r\n        console.log(notification.type);\r\n    });\r\n```\r\n\r\n在这个例子中，所有通过 `broadcast` 通道发送到 `App\\Models\\User` 实例的通知都会被回调接收。 `App.Models.User.{id}` 频道的频道授权回调包含在 Laravel 框架附带的默认` BroadcastServiceProvider` 中。\r\n\r\n","p":"docs/broadcasting.html"},{"t":"cache (缓存系统)","d":"# 缓存系统\r\n\r\n- [简介](#introduction)\r\n- [配置](#configuration)\r\n    - [驱动的前提条件](#driver-prerequisites)\r\n- [缓存使用](#cache-usage)\r\n    - [获取缓存实例](#obtaining-a-cache-instance)\r\n    - [从缓存获取数据](#retrieving-items-from-the-cache)\r\n    - [向缓存存储数据](#storing-items-in-the-cache)\r\n    - [从缓存删除数据](#removing-items-from-the-cache)\r\n    - [Cache 辅助函数](#the-cache-helper)\r\n- [缓存标记](#cache-tags)\r\n    - [存储被标记的缓存数据](#storing-tagged-cache-items)\r\n    - [访问被标记的缓存数据](#accessing-tagged-cache-items)\r\n    - [删除被标记的缓存数据](#removing-tagged-cache-items)\r\n    - [清理过期的缓存标记](#pruning-stale-cache-tags)\r\n- [原子锁](#atomic-locks)\r\n    - [驱动的前提条件](#lock-driver-prerequisites)\r\n    - [管理锁](#managing-locks)\r\n    - [跨进程管理锁](#managing-locks-across-processes)\r\n- [添加自定义缓存驱动](#adding-custom-cache-drivers)\r\n    - [编写驱动](#writing-the-driver)\r\n    - [注册驱动](#registering-the-driver)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在某些应用中，一些查询数据或处理任务的操作会在某段时间里短时间内大量进行，或是一个操作花费好几秒钟。当出现这种情况时，通常会将检索到的数据缓存起来，从而为后面请求同一数据的请求迅速返回结果。这些缓存数据通常会储存在极快的存储系统中，例如 [Memcached](https://memcached.org) 和 [Redis](https://redis.io)。\r\n\r\nLaravel 为各种缓存后端提供了富有表现力且统一的 API，以便你利用它们极快的查询数据来加快你的应用。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n缓存配置文件位于 `config/cache.php`。在这个文件中，你可以指定应用默认使用哪个缓存驱动。Laravel 支持的缓存后端包括 [Memcached](https://memcached.org)、[Redis](https://redis.io)、[DynamoDB](https://aws.amazon.com/dynamodb)，以及现成的关系型数据库。此外，还支持基于文件的缓存驱动，以及方便自动化测试的缓存驱动 `array` 和 `null` 。\r\n\r\n缓存配置文件还包含文件中记录的各种其他选项，因此请务必阅读这些选项。 默认情况下，Laravel 配置为使用 `file` 缓存驱动，它将序列化的缓存对象存储在服务器的文件系统中。 对于较大的应用程序，建议你使用更强大的驱动，例如 Memcached 或 Redis。 你甚至可以为同一个驱动配置多个缓存配置。\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动先决条件\r\n\r\n<a name=\"prerequisites-database\"></a>\r\n#### Database\r\n\r\n使用 `database` 缓存驱动时，你需要设置一个表来包含缓存项。你将在下表中找到 `Schema` 声明的示例：\r\n\r\n    Schema::create('cache', function (Blueprint $table) {\r\n        $table->string('key')->unique();\r\n        $table->text('value');\r\n        $table->integer('expiration');\r\n    });\r\n\r\n> **注意**\r\n> 你还可以使用 `php artisan cache:table` Artisan 命令生成具有适当模式的迁移。\r\n\r\n<a name=\"memcached\"></a>\r\n#### Memcached\r\n\r\n使用 Memcached 驱动程序需要安装 [Memcached PECL 包](https://pecl.php.net/package/memcached)。你可以在  `config/cache.php` 配置文件中列出所有的 Memcached 服务器。该文件已经包含一个 `memcached.servers` 来帮助你入门：\r\n\r\n    'memcached' => [\r\n        'servers' => [\r\n            [\r\n                'host' => env('MEMCACHED_HOST', '127.0.0.1'),\r\n                'port' => env('MEMCACHED_PORT', 11211),\r\n                'weight' => 100,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n如果需要，你可以将 `host` 选项设置为 UNIX socket path。 如果这样做， `port` 选项应设置为 `0`：\r\n\r\n    'memcached' => [\r\n        [\r\n            'host' => '/var/run/memcached/memcached.sock',\r\n            'port' => 0,\r\n            'weight' => 100\r\n        ],\r\n    ],\r\n\r\n<a name=\"redis\"></a>\r\n#### Redis\r\n\r\n在将 Redis 缓存与 Laravel 一起使用之前，您需要通过 PECL 安装 PhpRedis PHP 扩展或通过 Composer 安装 `predis/predis` 包（~1.0）。[Laravel Sail](/docs/laravel/10.x/sail) 已经包含了这个扩展。另外，Laravel 官方部署平台如 [Laravel Forge](https://forge.laravel.com) 和 [Laravel Vapor](https://vapor.laravel.com) 也默认安装了 PhpRedis 扩展。\r\n\r\n有关配置 Redis 的更多信息，请参阅其 [Laravel documentation page](/docs/laravel/10.x/redis#configuration).\r\n\r\n<a name=\"dynamodb\"></a>\r\n#### DynamoDB\r\n\r\n在使用 [DynamoDB](https://aws.amazon.com/dynamodb)  缓存驱动程序之前，您必须创建一个 DynamoDB 表来存储所有缓存的数据。通常，此表应命名为`cache`。但是，您应该根据应用程序的缓存配置文件中的 `stores.dynamodb.table` 配置值来命名表。\r\n\r\n该表还应该有一个字符串分区键，其名称对应于应用程序的缓存配置文件中的 `stores.dynamodb.attributes.key` 配置项的值。 默认情况下，分区键应命名为 `key`。\r\n\r\n<a name=\"cache-usage\"></a>\r\n## 缓存用法\r\n\r\n<a name=\"obtaining-a-cache-instance\"></a>\r\n### 获取缓存实例\r\n\r\n要获取缓存存储实例，您可以使用 `Cache` 门面类，我们将在本文档中使用它。`Cache` 门面类提供了对 Laravel 缓存底层实现的方便、简单的访问：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示应用程序所有用户的列表。\r\n         */\r\n        public function index(): array\r\n        {\r\n            $value = Cache::get('key');\r\n\r\n            return [\r\n                // ...\r\n            ];\r\n        }\r\n    }\r\n\r\n<a name=\"accessing-multiple-cache-stores\"></a>\r\n#### 访问多个缓存存储\r\n\r\n使用 `Cache` 门面类, 您可以通过 `store` 方法访问各种缓存存储。传递给 `store` 方法的键应该对应于 `cache` 配置文件中的 `stores` 配置数组中列出的存储之一：\r\n\r\n    $value = Cache::store('file')->get('foo');\r\n\r\n    Cache::store('redis')->put('bar', 'baz', 600); // 10 分钟\r\n\r\n<a name=\"retrieving-items-from-the-cache\"></a>\r\n### 从缓存中检索项目\r\n\r\n`Cache` 门面的 `get` 方法用于从缓存中检索项目。如果缓存中不存在该项目，则将返回 `null`。如果您愿意，您可以将第二个参数传递给 `get` 方法，指定您希望在项目不存在时返回的默认值：\r\n\r\n    $value = Cache::get('key');\r\n\r\n    $value = Cache::get('key', 'default');\r\n\r\n您甚至可以将闭包作为默认值传递。如果指定的项在缓存中不存在，则返回闭包的结果。传递闭包允许您推迟从数据库或其他外部服务中检索默认值：\r\n\r\n    $value = Cache::get('key', function () {\r\n        return DB::table(/* ... */)->get();\r\n    });\r\n\r\n<a name=\"checking-for-item-existence\"></a>\r\n#### 检查项目是否存在\r\n\r\n`has` 方法可用于确定缓存中是否存在项目。如果项目存在但其值为 `null`，此方法也将返回 `false`：\r\n\r\n    if (Cache::has('key')) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"incrementing-decrementing-values\"></a>\r\n#### 递增 / 递减值\r\n\r\n`increment` 和 `decrement` 方法可用于调整缓存中整数项的值。这两种方法都接受一个可选的第二个参数，指示增加或减少项目值的数量：\r\n\r\n    Cache::increment('key');\r\n    Cache::increment('key', $amount);\r\n    Cache::decrement('key');\r\n    Cache::decrement('key', $amount);\r\n\r\n<a name=\"retrieve-store\"></a>\r\n#### 检索和存储\r\n\r\n有时你可能希望从缓存中检索一个项目，但如果请求的项目不存在，则存储一个默认值。 例如， 你可能希望从缓存中检索所有用户，如果用户不存在，则从数据库中检索并将它们添加到缓存中。 你可以使用 `Cache::remember` 方法执行此操作：\r\n\r\n    $value = Cache::remember('users', $seconds, function () {\r\n        return DB::table('users')->get();\r\n    });\r\n\r\n如果该项不存在于缓存中，将执行传递给 `remember` 方法的闭包，并将其结果放入缓存中。\r\n\r\n你可以使用 `rememberForever` 方法从缓存中检索一个项目，如果它不存在则永久存储它：\r\n\r\n    $value = Cache::rememberForever('users', function () {\r\n        return DB::table('users')->get();\r\n    });\r\n\r\n<a name=\"retrieve-delete\"></a>\r\n#### 检索和删除\r\n\r\n如果你需要从缓存中检索一项后并删除该项，你可以使用 `pull` 方法。 与 `get` 方法一样，如果该项不存在于缓存中，将返回 `null`：\r\n\r\n    $value = Cache::pull('key');\r\n\r\n<a name=\"storing-items-in-the-cache\"></a>\r\n### 在缓存中存储项目\r\n\r\n你可以使用 `Cache` Facade上的 `put` 方法将项目存储在缓存中：\r\n\r\n    Cache::put('key', 'value', $seconds = 10);\r\n\r\n如果存储时间没有传递给 `put` 方法，则该项目将无限期存储：\r\n\r\n    Cache::put('key', 'value');\r\n\r\n除了将秒数作为整数传递之外，你还可以传递一个代表缓存项所需过期时间的 `DateTime` 实例：\r\n\r\n    Cache::put('key', 'value', now()->addMinutes(10));\r\n\r\n<a name=\"store-if-not-present\"></a>\r\n#### 如果不存在则存储\r\n\r\n`add` 方法只会将缓存存储中不存在的项目添加到缓存中。如果项目实际添加到缓存中，该方法将返回 `true`。 否则，该方法将返回 `false`。 `add` 方法是一个原子操作：\r\n\r\n    Cache::add('key', 'value', $seconds);\r\n\r\n<a name=\"storing-items-forever\"></a>\r\n#### 永久存储\r\n\r\n`forever` 方法可用于将项目永久存储在缓存中。由于这些项目不会过期，因此必须使用 `forget` 方法手动将它们从缓存中删除：\r\n\r\n    Cache::forever('key', 'value');\r\n\r\n> **注意**\r\n> 如果您使用的是 Memcached 驱动程序，则当缓存达到其大小限制时，可能会删除「永久」存储的项目。\r\n\r\n<a name=\"removing-items-from-the-cache\"></a>\r\n### 从缓存中删除项目\r\n\r\n您可以使用 `forget` 方法从缓存中删除项目：\r\n\r\n    Cache::forget('key');\r\n\r\n您还可以通过提供零或负数的过期秒数来删除项目：\r\n\r\n    Cache::put('key', 'value', 0);\r\n\r\n    Cache::put('key', 'value', -5);\r\n\r\n您可以使用 `flush` 方法清除整个缓存：\r\n\r\n    Cache::flush();\r\n\r\n> **注意**\r\n> 刷新缓存不会考虑您配置的缓存「前缀，并且会从缓存中删除所有条目。在清除由其他应用程序共享的缓存时，请考虑到这一点。\r\n\r\n<a name=\"the-cache-helper\"></a>\r\n### 缓存助手函数\r\n\r\n除了使用 `Cache` 门面之外，您还可以使用全局 `cache` 函数通过缓存检索和存储数据。当使用单个字符串参数调用 `cache` 函数时，它将返回给定键的值：\r\n\r\n    $value = cache('key');\r\n\r\n如果您向函数提供键 / 值对数组和过期时间，它将在指定的持续时间内将值存储在缓存中：\r\n\r\n    cache(['key' => 'value'], $seconds);\r\n\r\n    cache(['key' => 'value'], now()->addMinutes(10));\r\n\r\n当不带任何参数调用 cache 函数时，它会返回 Illuminate\\Contracts\\Cache\\Factory 实现的实例，允许您调用其他缓存方法：\r\n\r\n    cache()->remember('users', $seconds, function () {\r\n        return DB::table('users')->get();\r\n    });\r\n\r\n> **技巧**\r\n> 在测试对全局 `cache` 函数的调用时，您可以使用 `Cache::shouldReceive` 方法，就像 [testing the facade](/docs/laravel/10.x/mocking#mocking-facades).\r\n<a name=\"cache-tags\"></a>\r\n\r\n## 缓存标签\r\n\r\n> **注意**\r\n> 使用 `file`, `dynamodb` 或 `database` 存驱动程序时不支持缓存标记。 此外，当使用带有「永久」存储的缓存的多个标签时，使用诸如「memcached」之类的驱动程序会获得最佳性能，它会自动清除陈旧的记录。\r\n<a name=\"storing-tagged-cache-items\"></a>\r\n\r\n### 存储缓存标签\r\n\r\n缓存标签允许您在缓存中标记相关项目，然后刷新所有已分配给定标签的缓存值。您可以通过传入标记名称的有序数组来访问标记缓存。例如，让我们访问一个标记的缓存并将一个值`put`缓存中：\r\n\r\n    Cache::tags(['people', 'artists'])->put('John', $john, $seconds);\r\n\r\n    Cache::tags(['people', 'authors'])->put('Anne', $anne, $seconds);\r\n\r\n<a name=\"accessing-tagged-cache-items\"></a>\r\n\r\n### 访问缓存标签\r\n\r\n要检索标记的缓存项，请将相同的有序标签列表传递给 tags 方法，然后使用您要检索的键调用 `get` 方法：\r\n\r\n    $john = Cache::tags(['people', 'artists'])->get('John');\r\n\r\n    $anne = Cache::tags(['people', 'authors'])->get('Anne');\r\n\r\n<a name=\"removing-tagged-cache-items\"></a>\r\n### 删除被标记的缓存数据\r\n\r\n你可以刷新所有分配了标签或标签列表的项目。 例如，此语句将删除所有标记有 `people`, `authors`或两者的缓存。因此，`Anne` 和 `John` 都将从缓存中删除：\r\n\r\n    Cache::tags(['people', 'authors'])->flush();\r\n\r\n相反，此语句将仅删除带有 `authors` 标记的缓存，因此将删除 `Anne`，但不会删除 `John`：\r\n\r\n    Cache::tags('authors')->flush();\r\n\r\n<a name=\"pruning-stale-cache-tags\"></a>\r\n### 清理过期的缓存标记\r\n\r\n> **注意**\r\n> 仅在使用 Redis 作为应用程序的缓存驱动程序时，才需要清理过期的缓存标记。\r\n\r\n为了在使用 Redis 缓存驱动程序时正确清理过期的缓存标记，Laravel 的 Artisan 命令 `cache:prune-stale-tags` 应该被添加到 [任务调度](/docs/laravel/10.x/scheduling) 中，在应用程序的 `App\\Console\\Kernel` 类里：\r\n\r\n    $schedule->command('cache:prune-stale-tags')->hourly();\r\n\r\n<a name=\"atomic-locks\"></a>\r\n## 原子锁\r\n\r\n> **注意**\r\n> 要使用此功能，您的应用程序必须使用`memcached`、`redis`、`dynamicodb`、`database`、`file`或`array`缓存驱动程序作为应用程序的默认缓存驱动程序。\r\n此外，所有服务器都必须与同一中央缓存服务器通信。\r\n\r\n<a name=\"lock-driver-prerequisites\"></a>\r\n### 驱动程序先决条件\r\n\r\n<a name=\"atomic-locks-prerequisites-database\"></a>\r\n#### 数据库\r\n\r\n使用“数据库”缓存驱动程序时，您需要设置一个表来包含应用程序的缓存锁。您将在下表中找到一个示例 `Schema` 声明：\r\n\r\n    Schema::create('cache_locks', function (Blueprint $table) {\r\n        $table->string('key')->primary();\r\n        $table->string('owner');\r\n        $table->integer('expiration');\r\n    });\r\n\r\n<a name=\"managing-locks\"></a>\r\n### 管理锁\r\n\r\n原子锁允许操作分布式锁而不用担心竞争条件。例如，[Laravel Forge](https://forge.laravel.com) 使用原子锁来确保服务器上一次只执行一个远程任务。您可以使用 `Cache::lock` 方法创建和管理锁：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    $lock = Cache::lock('foo', 10);\r\n\r\n    if ($lock->get()) {\r\n        // 锁定 10 秒…\r\n\r\n        $lock->release();\r\n    }\r\n\r\n`get` 方法也接受一个闭包。闭包执行后，Laravel 会自动释放锁：\r\n\r\n    Cache::lock('foo', 10)->get(function () {\r\n        // 锁定 10 秒并自动释放...\r\n    });\r\n\r\n如果在您请求时锁不可用，您可以指示 Laravel 等待指定的秒数。如果在指定的时间限制内无法获取锁，则会抛出 Illuminate\\Contracts\\Cache\\LockTimeoutException：\r\n\r\n    use Illuminate\\Contracts\\Cache\\LockTimeoutException;\r\n\r\n    $lock = Cache::lock('foo', 10);\r\n\r\n    try {\r\n        $lock->block(5);\r\n\r\n        // 等待最多 5 秒后获得的锁...\r\n    } catch (LockTimeoutException $e) {\r\n        // 无法获取锁…\r\n    } finally {\r\n        $lock?->release();\r\n    }\r\n\r\n上面的例子可以通过将闭包传递给 `block` 方法来简化。当一个闭包被传递给这个方法时，Laravel 将尝试在指定的秒数内获取锁，并在闭包执行后自动释放锁：\r\n\r\n    Cache::lock('foo', 10)->block(5, function () {\r\n        // 等待最多 5 秒后获得的锁...\r\n    });\r\n\r\n<a name=\"managing-locks-across-processes\"></a>\r\n### 跨进程管理锁\r\n\r\n有时，您可能希望在一个进程中获取锁并在另一个进程中释放它。例如，您可能在 Web 请求期间获取锁，并希望在由该请求触发的排队作业结束时释放锁。在这种情况下，您应该将锁的作用域`owner token`传递给排队的作业，以便作业可以使用给定的令牌重新实例化锁。\r\n\r\n在下面的示例中，如果成功获取锁，我们将调度一个排队的作业。 此外，我们将通过锁的`owner`方法将锁的所有者令牌传递给排队的作业：\r\n\r\n    $podcast = Podcast::find($id);\r\n\r\n    $lock = Cache::lock('processing', 120);\r\n\r\n    if ($lock->get()) {\r\n        ProcessPodcast::dispatch($podcast, $lock->owner());\r\n    }\r\n\r\n在我们应用程序的`ProcessPodcast`作业中，我们可以使用所有者令牌恢复和释放锁：\r\n\r\n    Cache::restoreLock('processing', $this->owner)->release();\r\n\r\n如果你想释放一个锁而不考虑它的当前所有者，你可以使用`forceRelease`方法：\r\n\r\n    Cache::lock('processing')->forceRelease();\r\n\r\n<a name=\"adding-custom-cache-drivers\"></a>\r\n## 添加自定义缓存驱动\r\n\r\n<a name=\"writing-the-driver\"></a>\r\n### 编写驱动\r\n\r\n要创建我们的自定义缓存驱动程序，我们首先需要实现`Illuminate\\Contracts\\Cache\\Store` [contract](/docs/laravel/10.x/contracts)。 因此，MongoDB 缓存实现可能如下所示：\r\n\r\n    <?php\r\n\r\n    namespace App\\Extensions;\r\n\r\n    use Illuminate\\Contracts\\Cache\\Store;\r\n\r\n    class MongoStore implements Store\r\n    {\r\n        public function get($key) {}\r\n        public function many(array $keys) {}\r\n        public function put($key, $value, $seconds) {}\r\n        public function putMany(array $values, $seconds) {}\r\n        public function increment($key, $value = 1) {}\r\n        public function decrement($key, $value = 1) {}\r\n        public function forever($key, $value) {}\r\n        public function forget($key) {}\r\n        public function flush() {}\r\n        public function getPrefix() {}\r\n    }\r\n\r\n我们只需要使用 MongoDB 连接来实现这些方法中的每一个。有关如何实现这些方法的示例，请查看 [Laravel 框架源代码](https://github.com/laravel/framework)中的`Illuminate\\Cache\\MemcachedStore`。 一旦我们的实现完成，我们可以通过调用`Cache` 门面的`extend`方法来完成我们的自定义驱动程序注册：\r\n\r\n    Cache::extend('mongo', function (Application $app) {\r\n        return Cache::repository(new MongoStore);\r\n    });\r\n\r\n> **技巧**\r\n> 如果你想知道将自定义缓存驱动程序代码放在哪里，可以在你的`app`目录中创建一个`Extensions`命名空间。 但是请记住，Laravel 没有严格的应用程序结构，你可以根据自己的喜好自由组织应用程序。\r\n\r\n<a name=\"registering-the-driver\"></a>\r\n### 注册驱动\r\n\r\n要向 Laravel 注册自定义缓存驱动程序，我们将使用`Cache`门面的`extend`方法。 由于其他服务提供者可能会尝试在他们的`boot`方法中读取缓存值，我们将在`booting`回调中注册我们的自定义驱动程序。 通过使用`booting`回调，我们可以确保在应用程序的服务提供者调用`boot`方法之前但在所有服务提供者调用`register`方法之后注册自定义驱动程序。 我们将在应用程序的`App\\Providers\\AppServiceProvider`类的`register`方法中注册我们的`booting`回调：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Extensions\\MongoStore;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class CacheServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务。\r\n         */\r\n        public function register(): void\r\n        {\r\n            $this->app->booting(function () {\r\n                 Cache::extend('mongo', function (Application $app) {\r\n                     return Cache::repository(new MongoStore);\r\n                 });\r\n             });\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n传递给`extend`方法的第一个参数是驱动程序的名称。这将对应于`config/cache.php`配置文件中的 `driver`选项。 第二个参数是一个闭包，它应该返回一个`Illuminate\\Cache\\Repository`实例。闭包将传递一个`$app`实例，它是[服务容器](/docs/laravel/10.x/container)的一个实例。\r\n\r\n注册扩展程序后，将`config/cache.php`配置文件的`driver`选项更新为扩展程序的名称。\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\n要在每个缓存操作上执行代码，你可以侦听缓存触发的 [events](/docs/laravel/10.x/events) 。 通常，你应该将这些事件侦听器放在应用程序的`App\\Providers\\EventServiceProvider`类中：\r\n    \r\n    use App\\Listeners\\LogCacheHit;\r\n    use App\\Listeners\\LogCacheMissed;\r\n    use App\\Listeners\\LogKeyForgotten;\r\n    use App\\Listeners\\LogKeyWritten;\r\n    use Illuminate\\Cache\\Events\\CacheHit;\r\n    use Illuminate\\Cache\\Events\\CacheMissed;\r\n    use Illuminate\\Cache\\Events\\KeyForgotten;\r\n    use Illuminate\\Cache\\Events\\KeyWritten;\r\n    \r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        CacheHit::class => [\r\n            LogCacheHit::class,\r\n        ],\r\n\r\n        CacheMissed::class => [\r\n            LogCacheMissed::class,\r\n        ],\r\n\r\n        KeyForgotten::class => [\r\n            LogKeyForgotten::class,\r\n        ],\r\n\r\n        KeyWritten::class => [\r\n            LogKeyWritten::class,\r\n        ],\r\n    ];\r\n\r\n","p":"docs/cache.html"},{"t":"collections (集合)","d":"# 集合\r\n\r\n- [介绍](#introduction)\r\n     - [创建集合](#creating-collections)\r\n     - [扩展集合](#extending-collections)\r\n- [可用方法](#available-methods)\r\n- [高阶消息](#higher-order-messages)\r\n- [惰性集合](#lazy-collections)\r\n     - [介绍](#lazy-collection-introduction)\r\n     - [创建惰性集合](#creating-lazy-collections)\r\n     - [枚举契约](#the-enumerable-contract)\r\n     - [惰性集合方法](#lazy-collection-methods)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n`Illuminate\\Support\\Collection` 类为处理数据数组提供了一个流畅、方便的包装器。 例如，查看以下代码。 我们将使用 `collect` 助手从数组中创建一个新的集合实例，对每个元素运行 `strtoupper` 函数，然后删除所有空元素：\r\n\r\n    $collection = collect(['taylor', 'abigail', null])->map(function (string $name) {\r\n        return strtoupper($name);\r\n    })->reject(function (string $name) {\r\n        return empty($name);\r\n    });\r\n\r\n如你所见，`Collection` 类允许你链接其方法以执行流畅的映射和减少底层数组。一般来说，集合是不可变的，这意味着每个 `Collection` 方法都会返回一个全新的 `Collection` 实例。\r\n\r\n<a name=\"creating-collections\"></a>\r\n### 创建集合\r\n\r\n如上所述，`collect` 帮助器为给定数组返回一个新的 `Illuminate\\Support\\Collection` 实例。因此，创建一个集合非常简单：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n> **技巧：**[Eloquent](/docs/laravel/10.x/eloquent) 查询的结果总是作为 `Collection` 实例返回。\r\n\r\n<a name=\"extending-collections\"></a>\r\n### 扩展集合\r\n\r\n集合是「可宏化的」，它允许你在运行时向 `Collection` 类添加其他方法。 `Illuminate\\Support\\Collection` 类的 `macro` 方法接受一个闭包，该闭包将在调用宏时执行。宏闭包可以通过 `$this` 访问集合的其他方法，就像它是集合类的真实方法一样。例如，以下代码在 `Collection` 类中添加了 `toUpper` 方法：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    Collection::macro('toUpper', function () {\r\n        return $this->map(function (string $value) {\r\n            return Str::upper($value);\r\n        });\r\n    });\r\n\r\n    $collection = collect(['first', 'second']);\r\n\r\n    $upper = $collection->toUpper();\r\n\r\n    // ['FIRST', 'SECOND']\r\n\r\n\r\n\r\n通常，你应该在[服务提供者](/docs/laravel/10.x/providers)的 `boot` 方法中声明集合宏。\r\n\r\n<a name=\"macro-arguments\"></a>\r\n#### 宏参数\r\n\r\n如有必要，可以定义接受其他参数的宏：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n    use Illuminate\\Support\\Facades\\Lang;\r\n\r\n    Collection::macro('toLocale', function (string $locale) {\r\n        return $this->map(function (string $value) use ($locale) {\r\n            return Lang::get($value, [], $locale);\r\n        });\r\n    });\r\n\r\n    $collection = collect(['first', 'second']);\r\n\r\n    $translated = $collection->toLocale('es');\r\n\r\n<a name=\"available-methods\"></a>\r\n## 可用的方法\r\n\r\n对于剩余的大部分集合文档，我们将讨论 `Collection` 类中可用的每个方法。请记住，所有这些方法都可以链式调用，以便流畅地操作底层数组。此外，几乎每个方法都会返回一个新的 `Collection` 实例，允许你在必要时保留集合的原始副本：\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        columns: 10.8em 3; -moz-columns: 10.8em 3; -webkit-columns: 10.8em 3;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[all](#method-all)\r\n[average](#method-average)\r\n[avg](#method-avg)\r\n[chunk](#method-chunk)\r\n[chunkWhile](#method-chunkwhile)\r\n[collapse](#method-collapse)\r\n[collect](#method-collect)\r\n[combine](#method-combine)\r\n[concat](#method-concat)\r\n[contains](#method-contains)\r\n[containsOneItem](#method-containsoneitem)\r\n[containsStrict](#method-containsstrict)\r\n[count](#method-count)\r\n[countBy](#method-countBy)\r\n[crossJoin](#method-crossjoin)\r\n[dd](#method-dd)\r\n[diff](#method-diff)\r\n[diffAssoc](#method-diffassoc)\r\n[diffKeys](#method-diffkeys)\r\n[doesntContain](#method-doesntcontain)\r\n[dump](#method-dump)\r\n[duplicates](#method-duplicates)\r\n[duplicatesStrict](#method-duplicatesstrict)\r\n[each](#method-each)\r\n[eachSpread](#method-eachspread)\r\n[every](#method-every)\r\n[except](#method-except)\r\n[filter](#method-filter)\r\n[first](#method-first)\r\n[firstOrFail](#method-first-or-fail)\r\n[firstWhere](#method-first-where)\r\n[flatMap](#method-flatmap)\r\n[flatten](#method-flatten)\r\n[flip](#method-flip)\r\n[forget](#method-forget)\r\n[forPage](#method-forpage)\r\n[get](#method-get)\r\n[groupBy](#method-groupby)\r\n[has](#method-has)\r\n[hasAny](#method-hasany)\r\n[implode](#method-implode)\r\n[intersect](#method-intersect)\r\n[intersectAssoc](#method-intersectAssoc)\r\n[intersectByKeys](#method-intersectbykeys)\r\n[isEmpty](#method-isempty)\r\n[isNotEmpty](#method-isnotempty)\r\n[join](#method-join)\r\n[keyBy](#method-keyby)\r\n[keys](#method-keys)\r\n[last](#method-last)\r\n[lazy](#method-lazy)\r\n[macro](#method-macro)\r\n[make](#method-make)\r\n[map](#method-map)\r\n[mapInto](#method-mapinto)\r\n[mapSpread](#method-mapspread)\r\n[mapToGroups](#method-maptogroups)\r\n[mapWithKeys](#method-mapwithkeys)\r\n[max](#method-max)\r\n[median](#method-median)\r\n[merge](#method-merge)\r\n[mergeRecursive](#method-mergerecursive)\r\n[min](#method-min)\r\n[mode](#method-mode)\r\n[nth](#method-nth)\r\n[only](#method-only)\r\n[pad](#method-pad)\r\n[partition](#method-partition)\r\n[pipe](#method-pipe)\r\n[pipeInto](#method-pipeinto)\r\n[pipeThrough](#method-pipethrough)\r\n[pluck](#method-pluck)\r\n[pop](#method-pop)\r\n[prepend](#method-prepend)\r\n[pull](#method-pull)\r\n[push](#method-push)\r\n[put](#method-put)\r\n[random](#method-random)\r\n[range](#method-range)\r\n[reduce](#method-reduce)\r\n[reduceSpread](#method-reduce-spread)\r\n[reject](#method-reject)\r\n[replace](#method-replace)\r\n[replaceRecursive](#method-replacerecursive)\r\n[reverse](#method-reverse)\r\n[search](#method-search)\r\n[shift](#method-shift)\r\n[shuffle](#method-shuffle)\r\n[skip](#method-skip)\r\n[skipUntil](#method-skipuntil)\r\n[skipWhile](#method-skipwhile)\r\n[slice](#method-slice)\r\n[sliding](#method-sliding)\r\n[sole](#method-sole)\r\n[some](#method-some)\r\n[sort](#method-sort)\r\n[sortBy](#method-sortby)\r\n[sortByDesc](#method-sortbydesc)\r\n[sortDesc](#method-sortdesc)\r\n[sortKeys](#method-sortkeys)\r\n[sortKeysDesc](#method-sortkeysdesc)\r\n[sortKeysUsing](#method-sortkeysusing)\r\n[splice](#method-splice)\r\n[split](#method-split)\r\n[splitIn](#method-splitin)\r\n[sum](#method-sum)\r\n[take](#method-take)\r\n[takeUntil](#method-takeuntil)\r\n[takeWhile](#method-takewhile)\r\n[tap](#method-tap)\r\n[times](#method-times)\r\n[toArray](#method-toarray)\r\n[toJson](#method-tojson)\r\n[transform](#method-transform)\r\n[undot](#method-undot)\r\n[union](#method-union)\r\n[unique](#method-unique)\r\n[uniqueStrict](#method-uniquestrict)\r\n[unless](#method-unless)\r\n[unlessEmpty](#method-unlessempty)\r\n[unlessNotEmpty](#method-unlessnotempty)\r\n[unwrap](#method-unwrap)\r\n[value](#method-value)\r\n[values](#method-values)\r\n[when](#method-when)\r\n[whenEmpty](#method-whenempty)\r\n[whenNotEmpty](#method-whennotempty)\r\n[where](#method-where)\r\n[whereStrict](#method-wherestrict)\r\n[whereBetween](#method-wherebetween)\r\n[whereIn](#method-wherein)\r\n[whereInStrict](#method-whereinstrict)\r\n[whereInstanceOf](#method-whereinstanceof)\r\n[whereNotBetween](#method-wherenotbetween)\r\n[whereNotIn](#method-wherenotin)\r\n[whereNotInStrict](#method-wherenotinstrict)\r\n[whereNotNull](#method-wherenotnull)\r\n[whereNull](#method-wherenull)\r\n[wrap](#method-wrap)\r\n[zip](#method-zip)\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"method-listing\"></a>\r\n## 方法列表\r\n\r\n<style>\r\n    .collection-method code {\r\n        font-size: 14px;\r\n    }\r\n\r\n    .collection-method:not(.first-collection-method) {\r\n        margin-top: 50px;\r\n    }\r\n</style>\r\n\r\n<a name=\"method-all\"></a>\r\n#### `all()` {.collection-method .first-collection-method}\r\n\r\n`all` 方法返回由集合表示的底层数组：\r\n\r\n    collect([1, 2, 3])->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n<a name=\"method-average\"></a>\r\n#### `average()` {.collection-method}\r\n\r\n[`avg`](#method-avg) 方法的别名。\r\n\r\n<a name=\"method-avg\"></a>\r\n#### `avg()` {.collection-method}\r\n\r\n`avg` 方法返回给定键的 [平均值](https://en.wikipedia.org/wiki/Average)：\r\n\r\n    $average = collect([\r\n        ['foo' => 10],\r\n        ['foo' => 10],\r\n        ['foo' => 20],\r\n        ['foo' => 40]\r\n    ])->avg('foo');\r\n\r\n    // 20\r\n\r\n    $average = collect([1, 1, 2, 4])->avg();\r\n\r\n    // 2\r\n\r\n<a name=\"method-chunk\"></a>\r\n#### `chunk()` {.collection-method}\r\n\r\n`chunk` 方法将集合分成多个给定大小的较小集合：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7]);\r\n\r\n    $chunks = $collection->chunk(4);\r\n\r\n    $chunks->all();\r\n\r\n    // [[1, 2, 3, 4], [5, 6, 7]]\r\n\r\n当使用诸如 [Bootstrap](https://getbootstrap.com/docs/4.1/layout/grid/) 之类的网格系统时，此方法在 [views](/docs/laravel/10.x/views) 中特别有用。例如，假设你有一组 [Eloquent](/docs/laravel/10.x/eloquent) 模型要在网格中显示：\r\n\r\n```blade\r\n@foreach ($products->chunk(3) as $chunk)\r\n    <div class=\"row\">\r\n        @foreach ($chunk as $product)\r\n            <div class=\"col-xs-4\">{{ $product->name }}</div>\r\n        @endforeach\r\n    </div>\r\n@endforeach\r\n```\r\n\r\n<a name=\"method-chunkwhile\"></a>\r\n#### `chunkWhile()` {.collection-method}\r\n\r\n`chunkWhile` 方法根据给定回调的评估将集合分成多个更小的集合。传递给闭包的 `$chunk` 变量可用于检查前一个元素：\r\n\r\n    $collection = collect(str_split('AABBCCCD'));\r\n\r\n    $chunks = $collection->chunkWhile(function (string $value, int $key, Collection $chunk) {\r\n        return $value === $chunk->last();\r\n    });\r\n\r\n    $chunks->all();\r\n\r\n    // [['A', 'A'], ['B', 'B'], ['C', 'C', 'C'], ['D']]\r\n\r\n<a name=\"method-collapse\"></a>\r\n\r\n\r\n#### `collapse()` {.collection-method}\r\n\r\n`collapse` 方法将数组集合折叠成一个单一的平面集合：\r\n\r\n    $collection = collect([\r\n        [1, 2, 3],\r\n        [4, 5, 6],\r\n        [7, 8, 9],\r\n    ]);\r\n\r\n    $collapsed = $collection->collapse();\r\n\r\n    $collapsed->all();\r\n\r\n    // [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\r\n<a name=\"method-collect\"></a>\r\n#### `collect()` {.collection-method}\r\n\r\n`collect` 方法返回一个新的 `Collection` 实例，其中包含当前集合中的项目：\r\n\r\n    $collectionA = collect([1, 2, 3]);\r\n\r\n    $collectionB = $collectionA->collect();\r\n\r\n    $collectionB->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n`collect` 方法主要用于将 [惰性集合](#lazy-collections) 转换为标准的 `Collection` 实例：\r\n\r\n    $lazyCollection = LazyCollection::make(function () {\r\n        yield 1;\r\n        yield 2;\r\n        yield 3;\r\n    });\r\n\r\n    $collection = $lazyCollection->collect();\r\n\r\n    get_class($collection);\r\n\r\n    // 'Illuminate\\Support\\Collection'\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n> **技巧：**当你有一个 `Enumerable` 的实例并且需要一个非惰性集合实例时，`collect` 方法特别有用。由于 `collect()` 是 `Enumerable` 合约的一部分，你可以安全地使用它来获取 `Collection` 实例。\r\n\r\n<a name=\"method-combine\"></a>\r\n#### `combine()` {.collection-method}\r\n\r\n`combine` 方法将集合的值作为键与另一个数组或集合的值组合：\r\n\r\n    $collection = collect(['name', 'age']);\r\n\r\n    $combined = $collection->combine(['George', 29]);\r\n\r\n    $combined->all();\r\n\r\n    // ['name' => 'George', 'age' => 29]\r\n\r\n<a name=\"method-concat\"></a>\r\n#### `concat()` {.collection-method}\r\n\r\n`concat` 方法将给定的 `array` 或集合的值附加到另一个集合的末尾：\r\n\r\n    $collection = collect(['John Doe']);\r\n\r\n    $concatenated = $collection->concat(['Jane Doe'])->concat(['name' => 'Johnny Doe']);\r\n\r\n    $concatenated->all();\r\n\r\n    // ['John Doe', 'Jane Doe', 'Johnny Doe']\r\n\r\n`concat` 方法在数字上重新索引连接到原始集合上的项目的键。要维护关联集合中的键，请参阅 [merge](#method-merge) 方法。\r\n\r\n<a name=\"method-contains\"></a>\r\n#### `contains()` {.collection-method}\r\n\r\n`contains` 方法确定集合是否包含给定项目。你可以将闭包传递给 `contains` 方法，以确定集合中是否存在与给定真值测试匹配的元素：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->contains(function (int $value, int $key) {\r\n        return $value > 5;\r\n    });\r\n\r\n    // false\r\n\r\n\r\n\r\n或者，你可以将字符串传递给 `contains` 方法，以确定集合是否包含给定的项目值：\r\n\r\n    $collection = collect(['name' => 'Desk', 'price' => 100]);\r\n\r\n    $collection->contains('Desk');\r\n\r\n    // true\r\n\r\n    $collection->contains('New York');\r\n\r\n    // false\r\n\r\n你还可以将键/值对传递给 `contains` 方法，该方法将确定给定对是否存在于集合中：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n    ]);\r\n\r\n    $collection->contains('product', 'Bookcase');\r\n\r\n    // false\r\n\r\n`contains` 方法在检查项目值时使用“松散”比较，这意味着具有整数值的字符串将被视为等于具有相同值的整数。使用 [`containsStrict`](#method-containsstrict) 方法使用“严格”比较进行过滤。\r\n\r\n对于 `contains` 的逆操作，请参见 [doesntContain](#method-doesntcontain) 方法。\r\n\r\n<a name=\"method-containsoneitem\"></a>\r\n#### `containsOneItem()` {.collection-method}\r\n\r\n`containsOneItem` 方法决定了集合是否包含一个项目。\r\n\r\n    collect([])->containsOneItem();\r\n\r\n    // false\r\n\r\n    collect(['1'])->containsOneItem();\r\n\r\n    // true\r\n\r\n    collect(['1', '2'])->containsOneItem();\r\n\r\n    // false\r\n\r\n<a name=\"method-containsstrict\"></a>\r\n#### `containsStrict()` {.collection-method}\r\n\r\n此方法与 [`contains`](#method-contains) 方法具有相同的签名；但是，所有值都使用「严格」比较进行比较。\r\n\r\n> **技巧：**使用 [Eloquent Collections](/docs/laravel/10.x/eloquent-collections#method-contains) 时会修改此方法的行为。\r\n\r\n<a name=\"method-count\"></a>\r\n#### `count()` {.collection-method}\r\n\r\n`count` 方法返回集合中的项目总数：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $collection->count();\r\n\r\n    // 4\r\n\r\n<a name=\"method-countBy\"></a>\r\n#### `countBy()` {.collection-method}\r\n\r\n`countBy` 方法计算集合中值的出现次数。默认情况下，该方法计算每个元素的出现次数，允许你计算集合中元素的某些“类型”：\r\n\r\n    $collection = collect([1, 2, 2, 2, 3]);\r\n\r\n    $counted = $collection->countBy();\r\n\r\n    $counted->all();\r\n\r\n    // [1 => 1, 2 => 3, 3 => 1]\r\n\r\n\r\n\r\n你将闭包传递给 `countBy` 方法以按自定义值计算所有项目：\r\n\r\n    $collection = collect(['alice@gmail.com', 'bob@yahoo.com', 'carlos@gmail.com']);\r\n\r\n    $counted = $collection->countBy(function (string $email) {\r\n        return substr(strrchr($email, \"@\"), 1);\r\n    });\r\n\r\n    $counted->all();\r\n\r\n    // ['gmail.com' => 2, 'yahoo.com' => 1]\r\n\r\n<a name=\"method-crossjoin\"></a>\r\n#### `crossJoin()` {.collection-method}\r\n\r\n`crossJoin` 方法在给定的数组或集合中交叉连接集合的值，返回具有所有可能排列的笛卡尔积：\r\n\r\n    $collection = collect([1, 2]);\r\n\r\n    $matrix = $collection->crossJoin(['a', 'b']);\r\n\r\n    $matrix->all();\r\n\r\n    /*\r\n        [\r\n            [1, 'a'],\r\n            [1, 'b'],\r\n            [2, 'a'],\r\n            [2, 'b'],\r\n        ]\r\n    */\r\n\r\n    $collection = collect([1, 2]);\r\n\r\n    $matrix = $collection->crossJoin(['a', 'b'], ['I', 'II']);\r\n\r\n    $matrix->all();\r\n\r\n    /*\r\n        [\r\n            [1, 'a', 'I'],\r\n            [1, 'a', 'II'],\r\n            [1, 'b', 'I'],\r\n            [1, 'b', 'II'],\r\n            [2, 'a', 'I'],\r\n            [2, 'a', 'II'],\r\n            [2, 'b', 'I'],\r\n            [2, 'b', 'II'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-dd\"></a>\r\n#### `dd()` {.collection-method}\r\n\r\n`dd` 方法转储集合的项目并结束脚本的执行：\r\n\r\n    $collection = collect(['John Doe', 'Jane Doe']);\r\n\r\n    $collection->dd();\r\n\r\n    /*\r\n        Collection {\r\n            #items: array:2 [\r\n                0 => \"John Doe\"\r\n                1 => \"Jane Doe\"\r\n            ]\r\n        }\r\n    */\r\n\r\n如果你不想停止执行脚本，请改用 [`dump`](#method-dump) 方法。\r\n\r\n<a name=\"method-diff\"></a>\r\n#### `diff()` {.collection-method}\r\n\r\n`diff` 方法根据集合的值将集合与另一个集合或普通 PHP `array` 进行比较。此方法将返回给定集合中不存在的原始集合中的值：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $diff = $collection->diff([2, 4, 6, 8]);\r\n\r\n    $diff->all();\r\n\r\n    // [1, 3, 5]\r\n\r\n> **技巧：**此方法的行为在使用 [Eloquent Collections](/docs/laravel/10.x/eloquent-collections#method-diff) 时被修改。\r\n\r\n<a name=\"method-diffassoc\"></a>\r\n#### `diffAssoc()` {.collection-method}\r\n\r\n`diffAssoc` 方法根据其键和值将集合与另一个集合或普通 PHP `array` 进行比较。此方法将返回给定集合中不存在的原始集合中的键/值对：\r\n\r\n    $collection = collect([\r\n        'color' => 'orange',\r\n        'type' => 'fruit',\r\n        'remain' => 6,\r\n    ]);\r\n\r\n    $diff = $collection->diffAssoc([\r\n        'color' => 'yellow',\r\n        'type' => 'fruit',\r\n        'remain' => 3,\r\n        'used' => 6,\r\n    ]);\r\n\r\n    $diff->all();\r\n\r\n    // ['color' => 'orange', 'remain' => 6]\r\n\r\n\r\n\r\n<a name=\"method-diffkeys\"></a>\r\n#### `diffKeys()` {.collection-method}\r\n\r\n`diffKeys` 方法将集合与另一个集合或基于其键的普通 PHP `array` 进行比较。此方法将返回给定集合中不存在的原始集合中的键/值对：\r\n\r\n    $collection = collect([\r\n        'one' => 10,\r\n        'two' => 20,\r\n        'three' => 30,\r\n        'four' => 40,\r\n        'five' => 50,\r\n    ]);\r\n\r\n    $diff = $collection->diffKeys([\r\n        'two' => 2,\r\n        'four' => 4,\r\n        'six' => 6,\r\n        'eight' => 8,\r\n    ]);\r\n\r\n    $diff->all();\r\n\r\n    // ['one' => 10, 'three' => 30, 'five' => 50]\r\n\r\n<a name=\"method-doesntcontain\"></a>\r\n#### `doesntContain()` {.collection-method}\r\n\r\n`doesntContain` 方法确定集合是否不包含给定项目。你可以将闭包传递给 `doesntContain` 方法，以确定集合中是否不存在与给定真值测试匹配的元素：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->doesntContain(function (int $value, int $key) {\r\n        return $value < 5;\r\n    });\r\n\r\n    // false\r\n\r\n或者，你可以将字符串传递给 `doesntContain` 方法，以确定集合是否不包含给定的项目值：\r\n\r\n    $collection = collect(['name' => 'Desk', 'price' => 100]);\r\n\r\n    $collection->doesntContain('Table');\r\n\r\n    // true\r\n\r\n    $collection->doesntContain('Desk');\r\n\r\n    // false\r\n\r\n你还可以将键/值对传递给 `doesntContain` 方法，该方法将确定给定对是否不存在于集合中：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n    ]);\r\n\r\n    $collection->doesntContain('product', 'Bookcase');\r\n\r\n    // true\r\n\r\n`doesntContain` 方法在检查项目值时使用「松散」比较，这意味着具有整数值的字符串将被视为等于具有相同值的整数。\r\n\r\n<a name=\"method-dump\"></a>\r\n#### `dump()` {.collection-method}\r\n\r\n`dump` 方法转储集合的项目：\r\n\r\n    $collection = collect(['John Doe', 'Jane Doe']);\r\n\r\n    $collection->dump();\r\n\r\n    /*\r\n        Collection {\r\n            #items: array:2 [\r\n                0 => \"John Doe\"\r\n                1 => \"Jane Doe\"\r\n            ]\r\n        }\r\n    */\r\n\r\n如果要在转储集合后停止执行脚本，请改用 [`dd`](#method-dd) 方法。\r\n\r\n\r\n\r\n<a name=\"method-duplicates\"></a>\r\n#### `duplicates()` {.collection-method}\r\n\r\n`duplicates` 方法从集合中检索并返回重复值：\r\n\r\n    $collection = collect(['a', 'b', 'a', 'c', 'b']);\r\n\r\n    $collection->duplicates();\r\n\r\n    // [2 => 'a', 4 => 'b']\r\n\r\n如果集合包含数组或对象，你可以传递要检查重复值的属性的键：\r\n\r\n    $employees = collect([\r\n        ['email' => 'abigail@example.com', 'position' => 'Developer'],\r\n        ['email' => 'james@example.com', 'position' => 'Designer'],\r\n        ['email' => 'victoria@example.com', 'position' => 'Developer'],\r\n    ]);\r\n\r\n    $employees->duplicates('position');\r\n\r\n    // [2 => 'Developer']\r\n\r\n<a name=\"method-duplicatesstrict\"></a>\r\n#### `duplicatesStrict()` {.collection-method}\r\n\r\n此方法与 [`duplicates`](#method-duplicates) 方法具有相同的签名；但是，所有值都使用「严格」比较进行比较。\r\n\r\n<a name=\"method-each\"></a>\r\n#### `each()` {.collection-method}\r\n\r\n`each` 方法遍历集合中的项目并将每个项目传递给闭包：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $collection->each(function (int $item, int $key) {\r\n        // ...\r\n    });\r\n\r\n如果你想停止遍历这些项目，你可以从你的闭包中返回 `false`：\r\n\r\n    $collection->each(function (int $item, int $key) {\r\n        if (/* condition */) {\r\n            return false;\r\n        }\r\n    });\r\n\r\n<a name=\"method-eachspread\"></a>\r\n#### `eachSpread()` {.collection-method}\r\n\r\n`eachSpread` 方法迭代集合的项目，将每个嵌套项目值传递给给定的回调：\r\n\r\n    $collection = collect([['John Doe', 35], ['Jane Doe', 33]]);\r\n\r\n    $collection->eachSpread(function (string $name, int $age) {\r\n        // ...\r\n    });\r\n\r\n你可以通过从回调中返回 `false` 来停止遍历项目：\r\n\r\n    $collection->eachSpread(function (string $name, int $age) {\r\n        return false;\r\n    });\r\n\r\n<a name=\"method-every\"></a>\r\n#### `every()` {.collection-method}\r\n\r\n`every` 方法可用于验证集合的所有元素是否通过给定的真值测试：\r\n\r\n    collect([1, 2, 3, 4])->every(function (int $value, int $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    // false\r\n\r\n\r\n\r\n如果集合为空，`every` 方法将返回 true：\r\n\r\n    $collection = collect([]);\r\n\r\n    $collection->every(function (int $value, int $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    // true\r\n\r\n<a name=\"method-except\"></a>\r\n#### `except()` {.collection-method}\r\n\r\n`except` 方法返回集合中的所有项目，除了具有指定键的项目：\r\n\r\n    $collection = collect(['product_id' => 1, 'price' => 100, 'discount' => false]);\r\n\r\n    $filtered = $collection->except(['price', 'discount']);\r\n\r\n    $filtered->all();\r\n\r\n    // ['product_id' => 1]\r\n\r\n对于 `except` 的反义词，请参见 [only](#method-only) 方法。\r\n\r\n> 技巧：此方法的行为在使用 [Eloquent Collections](/docs/laravel/10.x/eloquent-collections#method-except) 时被修改。\r\n\r\n<a name=\"method-filter\"></a>\r\n#### `filter()` {.collection-method}\r\n\r\n`filter` 方法使用给定的回调过滤集合，只保留那些通过给定真值测试的项目：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $filtered = $collection->filter(function (int $value, int $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    $filtered->all();\r\n\r\n    // [3, 4]\r\n\r\n如果没有提供回调，则集合中所有相当于 `false` 的条目都将被删除：\r\n\r\n    $collection = collect([1, 2, 3, null, false, '', 0, []]);\r\n\r\n    $collection->filter()->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n对于 `filter` 的逆操作，请参见 [reject](#method-reject) 方法。\r\n\r\n<a name=\"method-first\"></a>\r\n#### `first()` {.collection-method}\r\n\r\n`first` 方法返回集合中通过给定真值测试的第一个元素：\r\n\r\n    collect([1, 2, 3, 4])->first(function (int $value, int $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    // 3\r\n\r\n你也可以调用不带参数的 `first` 方法来获取集合中的第一个元素。如果集合为空，则返回 `null`：\r\n\r\n    collect([1, 2, 3, 4])->first();\r\n\r\n    // 1\r\n\r\n<a name=\"method-first-or-fail\"></a>\r\n#### `firstOrFail()` {.collection-method}\r\n\r\n`firstOrFail` 方法与 `first` 方法相同；但是，如果没有找到结果，将抛出 `Illuminate/Support/ItemNotFoundException` 异常。\r\n\r\n    collect([1, 2, 3, 4])->firstOrFail(function (int $value, int $key) {\r\n        return $value > 5;\r\n    });\r\n\r\n    // Throws ItemNotFoundException...\r\n\r\n\r\n\r\n你也可以调用 `firstOrFail` 方法，没有参数，以获得集合中的第一个元素。如果集合是空的，将抛出一个 `Illuminate\\Support\\ItemNotFoundException` 异常。\r\n\r\n    collect([])->firstOrFail();\r\n\r\n    // Throws ItemNotFoundException...\r\n\r\n<a name=\"method-first-where\"></a>\r\n#### `firstWhere()` {.collection-method}\r\n\r\n`firstWhere` 方法返回集合中具有给定键/值对的第一个元素：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Regena', 'age' => null],\r\n        ['name' => 'Linda', 'age' => 14],\r\n        ['name' => 'Diego', 'age' => 23],\r\n        ['name' => 'Linda', 'age' => 84],\r\n    ]);\r\n\r\n    $collection->firstWhere('name', 'Linda');\r\n\r\n    // ['name' => 'Linda', 'age' => 14]\r\n\r\n你还可以使用比较运算符调用 `firstWhere` 方法：\r\n\r\n    $collection->firstWhere('age', '>=', 18);\r\n\r\n    // ['name' => 'Diego', 'age' => 23]\r\n\r\n与 [where](#method-where) 方法一样，你可以将一个参数传递给 `firstWhere` 方法。在这种情况下，`firstWhere` 方法将返回给定项目键值为「真」的第一个项目：\r\n\r\n    $collection->firstWhere('age');\r\n\r\n    // ['name' => 'Linda', 'age' => 14]\r\n\r\n<a name=\"method-flatmap\"></a>\r\n#### `flatMap()` {.collection-method}\r\n\r\n`flatMap` 方法遍历集合并将每个值传递给给定的闭包。闭包可以自由修改项目并将其返回，从而形成一个新的修改项目集合。然后，数组被展平一层：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Sally'],\r\n        ['school' => 'Arkansas'],\r\n        ['age' => 28]\r\n    ]);\r\n\r\n    $flattened = $collection->flatMap(function (array $values) {\r\n        return array_map('strtoupper', $values);\r\n    });\r\n\r\n    $flattened->all();\r\n\r\n    // ['name' => 'SALLY', 'school' => 'ARKANSAS', 'age' => '28'];\r\n\r\n<a name=\"method-flatten\"></a>\r\n#### `flatten()` {.collection-method}\r\n\r\n`flatten` 方法将多维集合展平为一维：\r\n\r\n    $collection = collect([\r\n        'name' => 'taylor',\r\n        'languages' => [\r\n            'php', 'javascript'\r\n        ]\r\n    ]);\r\n\r\n    $flattened = $collection->flatten();\r\n\r\n    $flattened->all();\r\n\r\n    // ['taylor', 'php', 'javascript'];\r\n\r\n如有必要，你可以向 `flatten` 方法传递一个「深度」参数：\r\n\r\n    $collection = collect([\r\n        'Apple' => [\r\n            [\r\n                'name' => 'iPhone 6S',\r\n                'brand' => 'Apple'\r\n            ],\r\n        ],\r\n        'Samsung' => [\r\n            [\r\n                'name' => 'Galaxy S7',\r\n                'brand' => 'Samsung'\r\n            ],\r\n        ],\r\n    ]);\r\n\r\n    $products = $collection->flatten(1);\r\n\r\n    $products->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'iPhone 6S', 'brand' => 'Apple'],\r\n            ['name' => 'Galaxy S7', 'brand' => 'Samsung'],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n在此示例中，调用 `flatten` 而不提供深度也会使嵌套数组变平，从而导致 `['iPhone 6S', 'Apple', 'Galaxy S7', 'Samsung']`。提供深度允许你指定嵌套数组将被展平的级别数。\r\n\r\n<a name=\"method-flip\"></a>\r\n#### `flip()` {.collection-method}\r\n\r\n`flip` 方法将集合的键与其对应的值交换：\r\n\r\n    $collection = collect(['name' => 'taylor', 'framework' => 'laravel']);\r\n\r\n    $flipped = $collection->flip();\r\n\r\n    $flipped->all();\r\n\r\n    // ['taylor' => 'name', 'laravel' => 'framework']\r\n\r\n<a name=\"method-forget\"></a>\r\n#### `forget()` {.collection-method}\r\n\r\n该 `forget` 方法将通过指定的键来移除集合中对应的元素：\r\n\r\n    $collection = collect(['name' => 'taylor', 'framework' => 'laravel']);\r\n\r\n    $collection->forget('name');\r\n\r\n    $collection->all();\r\n\r\n    // ['framework' => 'laravel']\r\n\r\n> **注意：**与大多数集合的方法不同的是， `forget` 不会返回修改后的新集合；它会直接修改原集合。\r\n\r\n<a name=\"method-forpage\"></a>\r\n#### `forPage()` {.collection-method}\r\n\r\n该 `forPage` 方法返回一个含有指定页码数集合项的新集合。这个方法接受页码数作为其第一个参数，每页显示的项数作为其第二个参数：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n\r\n    $chunk = $collection->forPage(2, 3);\r\n\r\n    $chunk->all();\r\n\r\n    // [4, 5, 6]\r\n\r\n<a name=\"method-get\"></a>\r\n#### `get()` {.collection-method}\r\n\r\n该 `get` 方法返回指定键的集合项，如果该键在集合中不存在，则返回 null：\r\n\r\n    $collection = collect(['name' => 'taylor', 'framework' => 'laravel']);\r\n\r\n    $value = $collection->get('name');\r\n\r\n    // taylor\r\n\r\n你可以任选一个默认值作为第二个参数传递：\r\n\r\n    $collection = collect(['name' => 'taylor', 'framework' => 'laravel']);\r\n\r\n    $value = $collection->get('age', 34);\r\n\r\n    // 34\r\n\r\n你甚至可以将一个回调函数作为默认值传递。如果指定的键不存在，就会返回回调函数的结果：\r\n\r\n    $collection->get('email', function () {\r\n        return 'taylor@example.com';\r\n    });\r\n\r\n    // taylor@example.com\r\n\r\n\r\n\r\n<a name=\"method-groupby\"></a>\r\n#### `groupBy()` {.collection-method}\r\n\r\n该 `groupBy` 方法根据指定键对集合项进行分组：\r\n\r\n    $collection = collect([\r\n        ['account_id' => 'account-x10', 'product' => 'Chair'],\r\n        ['account_id' => 'account-x10', 'product' => 'Bookcase'],\r\n        ['account_id' => 'account-x11', 'product' => 'Desk'],\r\n    ]);\r\n\r\n    $grouped = $collection->groupBy('account_id');\r\n\r\n    $grouped->all();\r\n\r\n    /*\r\n        [\r\n            'account-x10' => [\r\n                ['account_id' => 'account-x10', 'product' => 'Chair'],\r\n                ['account_id' => 'account-x10', 'product' => 'Bookcase'],\r\n            ],\r\n            'account-x11' => [\r\n                ['account_id' => 'account-x11', 'product' => 'Desk'],\r\n            ],\r\n        ]\r\n    */\r\n\r\n你可以传递回调，而不是传递字符串 `key`。回调应返回你希望通过以下方式键入组的值：\r\n\r\n    $grouped = $collection->groupBy(function (array $item, int $key) {\r\n        return substr($item['account_id'], -3);\r\n    });\r\n\r\n    $grouped->all();\r\n\r\n    /*\r\n        [\r\n            'x10' => [\r\n                ['account_id' => 'account-x10', 'product' => 'Chair'],\r\n                ['account_id' => 'account-x10', 'product' => 'Bookcase'],\r\n            ],\r\n            'x11' => [\r\n                ['account_id' => 'account-x11', 'product' => 'Desk'],\r\n            ],\r\n        ]\r\n    */\r\n\r\n多个分组标准可以作为数组传递。每个数组元素将应用于多维数组中的相应级别：\r\n\r\n    $data = new Collection([\r\n        10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],\r\n        20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],\r\n        30 => ['user' => 3, 'skill' => 2, 'roles' => ['Role_1']],\r\n        40 => ['user' => 4, 'skill' => 2, 'roles' => ['Role_2']],\r\n    ]);\r\n\r\n    $result = $data->groupBy(['skill', function (array $item) {\r\n        return $item['roles'];\r\n    }], preserveKeys: true);\r\n\r\n    /*\r\n    [\r\n        1 => [\r\n            'Role_1' => [\r\n                10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],\r\n                20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],\r\n            ],\r\n            'Role_2' => [\r\n                20 => ['user' => 2, 'skill' => 1, 'roles' => ['Role_1', 'Role_2']],\r\n            ],\r\n            'Role_3' => [\r\n                10 => ['user' => 1, 'skill' => 1, 'roles' => ['Role_1', 'Role_3']],\r\n            ],\r\n        ],\r\n        2 => [\r\n            'Role_1' => [\r\n                30 => ['user' => 3, 'skill' => 2, 'roles' => ['Role_1']],\r\n            ],\r\n            'Role_2' => [\r\n                40 => ['user' => 4, 'skill' => 2, 'roles' => ['Role_2']],\r\n            ],\r\n        ],\r\n    ];\r\n    */\r\n\r\n<a name=\"method-has\"></a>\r\n#### `has()` {.collection-method}\r\n\r\n`has` 方法确定集合中是否存在给定键：\r\n\r\n    $collection = collect(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]);\r\n\r\n    $collection->has('product');\r\n\r\n    // true\r\n\r\n    $collection->has(['product', 'amount']);\r\n\r\n    // true\r\n\r\n    $collection->has(['amount', 'price']);\r\n\r\n    // false\r\n\r\n\r\n\r\n<a name=\"method-hasany\"></a>\r\n#### `hasAny()` {.collection-method}\r\n\r\n`hasAny` 方法确定在集合中是否存在任何给定的键。\r\n\r\n    $collection = collect(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]);\r\n\r\n    $collection->hasAny(['product', 'price']);\r\n\r\n    // true\r\n\r\n    $collection->hasAny(['name', 'price']);\r\n\r\n    // false\r\n\r\n<a name=\"method-implode\"></a>\r\n#### `implode()` {.collection-method}\r\n\r\n`implode` 方法连接集合中的项目。它的参数取决于集合中项目的类型。如果集合包含数组或对象，你应该传递你希望加入的属性的键，以及你希望放置在值之间的「胶水」字符串：\r\n\r\n    $collection = collect([\r\n        ['account_id' => 1, 'product' => 'Desk'],\r\n        ['account_id' => 2, 'product' => 'Chair'],\r\n    ]);\r\n\r\n    $collection->implode('product', ', ');\r\n\r\n    // Desk, Chair\r\n\r\n如果集合包含简单的字符串或数值，则应将「胶水」作为唯一参数传递给该方法：\r\n\r\n    collect([1, 2, 3, 4, 5])->implode('-');\r\n\r\n    // '1-2-3-4-5'\r\n\r\n如果你想对被内部处理的值进行格式化，你可以给 `implode` 方法传递一个闭包。\r\n\r\n    $collection->implode(function (array $item, int $key) {\r\n        return strtoupper($item['product']);\r\n    }, ', ');\r\n\r\n    // DESK, CHAIR\r\n\r\n<a name=\"method-intersect\"></a>\r\n#### `intersect()` {.collection-method}\r\n\r\n`intersect` 方法从原始集合中删除任何不存在于给定 `array` 或集合中的值。生成的集合将保留原始集合的键：\r\n\r\n    $collection = collect(['Desk', 'Sofa', 'Chair']);\r\n\r\n    $intersect = $collection->intersect(['Desk', 'Chair', 'Bookcase']);\r\n\r\n    $intersect->all();\r\n\r\n    // [0 => 'Desk', 2 => 'Chair']\r\n\r\n> 技巧：使用 [Eloquent Collections](/docs/laravel/10.x/eloquent-collections#method-intersect) 时会修改此方法的行为。\r\n\r\n<a name=\"method-intersectAssoc\"></a>\r\n#### `intersectAssoc()` {.collection-method}\r\n\r\n`intersectAssoc` 方法将原始集合与另一个集合或`array`进行比较，返回所有给定集合中存在的键/值对:\r\n\r\n    $collection = collect([\r\n        'color' => 'red',\r\n        'size' => 'M',\r\n        'material' => 'cotton'\r\n    ]);\r\n\r\n    $intersect = $collection->intersectAssoc([\r\n        'color' => 'blue',\r\n        'size' => 'M',\r\n        'material' => 'polyester'\r\n    ]);\r\n\r\n    $intersect->all();\r\n\r\n    // ['size' => 'M']\r\n\r\n\r\n\r\n<a name=\"method-intersectbykeys\"></a>\r\n#### `intersectByKeys()` {.collection-method}\r\n\r\n`intersectByKeys` 方法删除了原始集合中不存在于给定的 `array` 或集合中的任何键和其相应的值。\r\n\r\n    $collection = collect([\r\n        'serial' => 'UX301', 'type' => 'screen', 'year' => 2009,\r\n    ]);\r\n\r\n    $intersect = $collection->intersectByKeys([\r\n        'reference' => 'UX404', 'type' => 'tab', 'year' => 2011,\r\n    ]);\r\n\r\n    $intersect->all();\r\n\r\n    // ['type' => 'screen', 'year' => 2009]\r\n\r\n<a name=\"method-isempty\"></a>\r\n#### `isEmpty()` {.collection-method}\r\n\r\n如果集合为空，`isEmpty` 方法返回 `true`；否则，返回 `false`：\r\n\r\n    collect([])->isEmpty();\r\n\r\n    // true\r\n\r\n<a name=\"method-isnotempty\"></a>\r\n#### `isNotEmpty()` {.collection-method}\r\n\r\n如果集合不为空，`isNotEmpty` 方法返回 `true`；否则，返回 `false`：\r\n\r\n    collect([])->isNotEmpty();\r\n\r\n    // false\r\n\r\n<a name=\"method-join\"></a>\r\n#### `join()` {.collection-method}\r\n\r\n`join` 方法将集合的值与字符串连接起来。使用此方法的第二个参数，你还可以指定最终元素应如何附加到字符串：\r\n\r\n    collect(['a', 'b', 'c'])->join(', '); // 'a, b, c'\r\n    collect(['a', 'b', 'c'])->join(', ', ', and '); // 'a, b, and c'\r\n    collect(['a', 'b'])->join(', ', ' and '); // 'a and b'\r\n    collect(['a'])->join(', ', ' and '); // 'a'\r\n    collect([])->join(', ', ' and '); // ''\r\n\r\n<a name=\"method-keyby\"></a>\r\n#### `keyBy()` {.collection-method}\r\n\r\n`keyBy` 方法通过给定键对集合进行键控。如果多个项目具有相同的键，则只有最后一个会出现在新集合中：\r\n\r\n    $collection = collect([\r\n        ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n        ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n    ]);\r\n\r\n    $keyed = $collection->keyBy('product_id');\r\n\r\n    $keyed->all();\r\n\r\n    /*\r\n        [\r\n            'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n            'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n你也可以将回调传递给该方法。回调应通过以下方式返回值以作为集合的键：\r\n\r\n    $keyed = $collection->keyBy(function (array $item, int $key) {\r\n        return strtoupper($item['product_id']);\r\n    });\r\n\r\n    $keyed->all();\r\n\r\n    /*\r\n        [\r\n            'PROD-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n            'PROD-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-keys\"></a>\r\n#### `keys()` {.collection-method}\r\n\r\n`keys` 方法返回集合的所有键：\r\n\r\n    $collection = collect([\r\n        'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n        'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n    ]);\r\n\r\n    $keys = $collection->keys();\r\n\r\n    $keys->all();\r\n\r\n    // ['prod-100', 'prod-200']\r\n\r\n<a name=\"method-last\"></a>\r\n#### `last()` {.collection-method}\r\n\r\n`last` 方法返回集合中通过给定真值测试的最后一个元素：\r\n\r\n    collect([1, 2, 3, 4])->last(function (int $value, int $key) {\r\n        return $value < 3;\r\n    });\r\n\r\n    // 2\r\n\r\n你也可以调用不带参数的`last`方法来获取集合中的最后一个元素。如果集合为空，则返回 `null`：\r\n\r\n    collect([1, 2, 3, 4])->last();\r\n\r\n    // 4\r\n\r\n<a name=\"method-lazy\"></a>\r\n#### `lazy()` {.collection-method}\r\n\r\n\r\n`lazy` 方法从底层的项目数组中返回一个新的 [`LazyCollection`](#lazy-collections) 实例。\r\n\r\n    $lazyCollection = collect([1, 2, 3, 4])->lazy();\r\n\r\n    get_class($lazyCollection);\r\n\r\n    // Illuminate\\Support\\LazyCollection\r\n\r\n    $lazyCollection->all();\r\n\r\n    // [1, 2, 3, 4]\r\n\r\n当你需要对一个包含许多项目的巨大 `Collection` 进行转换时，这一点特别有用。\r\n\r\n    $count = $hugeCollection\r\n        ->lazy()\r\n        ->where('country', 'FR')\r\n        ->where('balance', '>', '100')\r\n        ->count();\r\n\r\n通过将集合转换为 `LazyCollection`，我们避免了分配大量的额外内存。虽然原始集合仍然在内存中保留 _它的_ 值，但后续的过滤器不会。因此，在过滤集合的结果时，几乎没有额外的内存被分配。\r\n\r\n\r\n\r\n<a name=\"method-macro\"></a>\r\n#### `macro()` {.collection-method}\r\n\r\n静态`macro()`方法允许你在运行时向「集合」类添加方法。有关详细信息，请参阅有关 [扩展集合](#extending-collections) 的文档。\r\n\r\n<a name=\"method-make\"></a>\r\n#### `make()` {.collection-method}\r\n\r\n静态 `make` 方法可以创建一个新的集合实例。请参照 [创建集合](#creating-collections) 部分。\r\n\r\n<a name=\"method-map\"></a>\r\n#### `map()` {.collection-method}\r\n\r\n静态 `make` 方法可以创建一个新的集合实例。请参照 [创建集合](#creating-collections) 部分。\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $multiplied = $collection->map(function (int $item, int $key) {\r\n        return $item * 2;\r\n    });\r\n\r\n    $multiplied->all();\r\n\r\n    // [2, 4, 6, 8, 10]\r\n\r\n> **注意：**与其他大多数集合方法一样， `map` 会返回一个新的集合实例；它不会修改原集合。如果你想修改原集合，请使用 [`transform`](#method-transform) 方法。\r\n\r\n<a name=\"method-mapinto\"></a>\r\n#### `mapInto()` {.collection-method}\r\n\r\n该 `mapInto()` 方法可以迭代集合，通过将值传递给构造函数来创建给定类的新实例：\r\n\r\n    class Currency\r\n    {\r\n        /**\r\n         * Create a new currency instance.\r\n         */\r\n        function __construct(\r\n            public string $code\r\n        ) {}\r\n    }\r\n\r\n    $collection = collect(['USD', 'EUR', 'GBP']);\r\n\r\n    $currencies = $collection->mapInto(Currency::class);\r\n\r\n    $currencies->all();\r\n\r\n    // [Currency('USD'), Currency('EUR'), Currency('GBP')]\r\n\r\n<a name=\"method-mapspread\"></a>\r\n#### `mapSpread()` {.collection-method}\r\n\r\n该 `mapSpread` 方法可以迭代集合，将每个嵌套项值给指定的回调函数。该回调函数可以自由修改该集合项并返回，从而生成被修改过集合项的新集合：\r\n\r\n    $collection = collect([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n\r\n    $chunks = $collection->chunk(2);\r\n\r\n    $sequence = $chunks->mapSpread(function (int $even, int $odd) {\r\n        return $even + $odd;\r\n    });\r\n\r\n    $sequence->all();\r\n\r\n    // [1, 5, 9, 13, 17]\r\n\r\n\r\n\r\n<a name=\"method-maptogroups\"></a>\r\n#### `mapToGroups()` {.collection-method}\r\n\r\n该 `mapToGroups` 方法通过给定的回调函数对集合项进行分组。该回调函数应该返回一个包含单个键 / 值对的关联数组，从而生成一个分组值的新集合：\r\n\r\n    $collection = collect([\r\n        [\r\n            'name' => 'John Doe',\r\n            'department' => 'Sales',\r\n        ],\r\n        [\r\n            'name' => 'Jane Doe',\r\n            'department' => 'Sales',\r\n        ],\r\n        [\r\n            'name' => 'Johnny Doe',\r\n            'department' => 'Marketing',\r\n        ]\r\n    ]);\r\n\r\n    $grouped = $collection->mapToGroups(function (array $item, int $key) {\r\n        return [$item['department'] => $item['name']];\r\n    });\r\n\r\n    $grouped->all();\r\n\r\n    /*\r\n        [\r\n            'Sales' => ['John Doe', 'Jane Doe'],\r\n            'Marketing' => ['Johnny Doe'],\r\n        ]\r\n    */\r\n\r\n    $grouped->get('Sales')->all();\r\n\r\n    // ['John Doe', 'Jane Doe']\r\n\r\n<a name=\"method-mapwithkeys\"></a>\r\n#### `mapWithKeys()` {.collection-method}\r\n\r\n`mapWithKeys` 方法遍历集合并将每个值传递给给定的回调。回调应返回包含单个键/值对的关联数组：\r\n\r\n    $collection = collect([\r\n        [\r\n            'name' => 'John',\r\n            'department' => 'Sales',\r\n            'email' => 'john@example.com',\r\n        ],\r\n        [\r\n            'name' => 'Jane',\r\n            'department' => 'Marketing',\r\n            'email' => 'jane@example.com',\r\n        ]\r\n    ]);\r\n\r\n    $keyed = $collection->mapWithKeys(function (array $item, int $key) {\r\n        return [$item['email'] => $item['name']];\r\n    });\r\n\r\n    $keyed->all();\r\n\r\n    /*\r\n        [\r\n            'john@example.com' => 'John',\r\n            'jane@example.com' => 'Jane',\r\n        ]\r\n    */\r\n\r\n<a name=\"method-max\"></a>\r\n#### `max()` {.collection-method}\r\n\r\n`max` 方法返回给定键的最大值：\r\n\r\n    $max = collect([\r\n        ['foo' => 10],\r\n        ['foo' => 20]\r\n    ])->max('foo');\r\n\r\n    // 20\r\n\r\n    $max = collect([1, 2, 3, 4, 5])->max();\r\n\r\n    // 5\r\n\r\n<a name=\"method-median\"></a>\r\n#### `median()` {.collection-method}\r\n\r\n`median` 方法返回给定键的 [中值](https://en.wikipedia.org/wiki/Median)：\r\n\r\n    $median = collect([\r\n        ['foo' => 10],\r\n        ['foo' => 10],\r\n        ['foo' => 20],\r\n        ['foo' => 40]\r\n    ])->median('foo');\r\n\r\n    // 15\r\n\r\n    $median = collect([1, 1, 2, 4])->median();\r\n\r\n    // 1.5\r\n\r\n<a name=\"method-merge\"></a>\r\n#### `merge()` {.collection-method}\r\n\r\n`merge` 方法将给定的数组或集合与原始集合合并。如果给定项目中的字符串键与原始集合中的字符串键匹配，则给定项目的值将覆盖原始集合中的值：\r\n\r\n    $collection = collect(['product_id' => 1, 'price' => 100]);\r\n\r\n    $merged = $collection->merge(['price' => 200, 'discount' => false]);\r\n\r\n    $merged->all();\r\n\r\n    // ['product_id' => 1, 'price' => 200, 'discount' => false]\r\n\r\n\r\n\r\n如果给定项目的键是数字，则值将附加到集合的末尾：\r\n\r\n    $collection = collect(['Desk', 'Chair']);\r\n\r\n    $merged = $collection->merge(['Bookcase', 'Door']);\r\n\r\n    $merged->all();\r\n\r\n    // ['Desk', 'Chair', 'Bookcase', 'Door']\r\n\r\n<a name=\"method-mergerecursive\"></a>\r\n#### `mergeRecursive()` {.collection-method}\r\n\r\n`mergeRecursive` 方法将给定的数组或集合递归地与原始集合合并。如果给定项目中的字符串键与原始集合中的字符串键匹配，则这些键的值将合并到一个数组中，这是递归完成的：\r\n\r\n    $collection = collect(['product_id' => 1, 'price' => 100]);\r\n\r\n    $merged = $collection->mergeRecursive([\r\n        'product_id' => 2,\r\n        'price' => 200,\r\n        'discount' => false\r\n    ]);\r\n\r\n    $merged->all();\r\n\r\n    // ['product_id' => [1, 2], 'price' => [100, 200], 'discount' => false]\r\n\r\n<a name=\"method-min\"></a>\r\n#### `min()` {.collection-method}\r\n\r\n`min` 方法返回给定键的最小值：\r\n\r\n    $min = collect([['foo' => 10], ['foo' => 20]])->min('foo');\r\n\r\n    // 10\r\n\r\n    $min = collect([1, 2, 3, 4, 5])->min();\r\n\r\n    // 1\r\n\r\n<a name=\"method-mode\"></a>\r\n#### `mode()` {.collection-method}\r\n\r\n`mode` 方法返回给定键的 [mode 值](https://en.wikipedia.org/wiki/Mode_(statistics))：\r\n\r\n    $mode = collect([\r\n        ['foo' => 10],\r\n        ['foo' => 10],\r\n        ['foo' => 20],\r\n        ['foo' => 40]\r\n    ])->mode('foo');\r\n\r\n    // [10]\r\n\r\n    $mode = collect([1, 1, 2, 4])->mode();\r\n\r\n    // [1]\r\n\r\n    $mode = collect([1, 1, 2, 2])->mode();\r\n\r\n    // [1, 2]\r\n\r\n<a name=\"method-nth\"></a>\r\n#### `nth()` {.collection-method}\r\n\r\n`nth` 方法创建一个由每个第 n 个元素组成的新集合：\r\n\r\n    $collection = collect(['a', 'b', 'c', 'd', 'e', 'f']);\r\n\r\n    $collection->nth(4);\r\n\r\n    // ['a', 'e']\r\n\r\n你可以选择将起始偏移量作为第二个参数传递：\r\n\r\n    $collection->nth(4, 1);\r\n\r\n    // ['b', 'f']\r\n\r\n<a name=\"method-only\"></a>\r\n#### `only()` {.collection-method}\r\n\r\n`only` 方法返回集合中具有指定键的项目：\r\n\r\n    $collection = collect([\r\n        'product_id' => 1,\r\n        'name' => 'Desk',\r\n        'price' => 100,\r\n        'discount' => false\r\n    ]);\r\n\r\n    $filtered = $collection->only(['product_id', 'name']);\r\n\r\n    $filtered->all();\r\n\r\n    // ['product_id' => 1, 'name' => 'Desk']\r\n\r\n\r\n\r\n关于 `only` 的反义词，见[except](#method-except) 方法。\r\n\r\n> **技巧：**使用 [Eloquent Collections](/docs/laravel/9.x/eloquent-collections#method-only) 时会修改此方法的行为。\r\n\r\n<a name=\"method-pad\"></a>\r\n#### `pad()` {.collection-method}\r\n\r\n`pad` 方法将用给定的值填充数组，直到数组达到指定的大小。此方法的行为类似于 [array_pad](https://secure.php.net/manual/en/function.array-pad.php) PHP 函数。\r\n\r\n要向左填充，你应该指定一个负尺寸。如果给定大小的绝对值小于或等于数组的长度，则不会发生填充：\r\n\r\n    $collection = collect(['A', 'B', 'C']);\r\n\r\n    $filtered = $collection->pad(5, 0);\r\n\r\n    $filtered->all();\r\n\r\n    // ['A', 'B', 'C', 0, 0]\r\n\r\n    $filtered = $collection->pad(-5, 0);\r\n\r\n    $filtered->all();\r\n\r\n    // [0, 0, 'A', 'B', 'C']\r\n\r\n<a name=\"method-partition\"></a>\r\n#### `partition()` {.collection-method}\r\n\r\n该 `partition` 方法可以与 PHP 数组解构相结合，以将通过给定真值测试的元素与未通过的元素分开：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6]);\r\n\r\n    [$underThree, $equalOrAboveThree] = $collection->partition(function (int $i) {\r\n        return $i < 3;\r\n    });\r\n\r\n    $underThree->all();\r\n\r\n    // [1, 2]\r\n\r\n    $equalOrAboveThree->all();\r\n\r\n    // [3, 4, 5, 6]\r\n\r\n<a name=\"method-pipe\"></a>\r\n#### `pipe()` {.collection-method}\r\n\r\n该 `pipe` 可以把集合放到回调参数中并返回回调的结果：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $piped = $collection->pipe(function (Collection $collection) {\r\n        return $collection->sum();\r\n    });\r\n\r\n    // 6\r\n\r\n<a name=\"method-pipeinto\"></a>\r\n#### `pipeInto()` {.collection-method}\r\n\r\n该 `pipeInto` 方法创建一个给定类的新实例，并将集合传递给构造函数：\r\n\r\n    class ResourceCollection\r\n    {\r\n        /**\r\n         * Create a new ResourceCollection instance.\r\n         */\r\n        public function __construct(\r\n          public Collection $collection,\r\n        ) {}\r\n    }\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $resource = $collection->pipeInto(ResourceCollection::class);\r\n\r\n    $resource->collection->all();\r\n\r\n    // [1, 2, 3]\r\n\r\n<a name=\"method-pipethrough\"></a>\r\n\r\n\r\n#### `pipeThrough()` {.collection-method}\r\n\r\n该 `pipeThrough` 方法将集合传递给给定的闭包数组并返回执行的闭包的结果：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $result = $collection->pipeThrough([\r\n        function (Collection $collection) {\r\n            return $collection->merge([4, 5]);\r\n        },\r\n        function (Collection $collection) {\r\n            return $collection->sum();\r\n        },\r\n    ]);\r\n\r\n    // 15\r\n\r\n<a name=\"method-pluck\"></a>\r\n#### `pluck()` {.collection-method}\r\n\r\n该 `pluck` 可以获取集合中指定键对应的所有值：\r\n\r\n    $collection = collect([\r\n        ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n        ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n    ]);\r\n\r\n    $plucked = $collection->pluck('name');\r\n\r\n    $plucked->all();\r\n\r\n    // ['Desk', 'Chair']\r\n\r\n你也可以通过传入第二个参数来指定生成集合的 key（键）：\r\n\r\n    $plucked = $collection->pluck('name', 'product_id');\r\n\r\n    $plucked->all();\r\n\r\n    // ['prod-100' => 'Desk', 'prod-200' => 'Chair']\r\n\r\n该 `pluck` 也支持利用「.」标记的方法取出多维数组的键值：\r\n\r\n    $collection = collect([\r\n        [\r\n            'name' => 'Laracon',\r\n            'speakers' => [\r\n                'first_day' => ['Rosa', 'Judith'],\r\n            ],\r\n        ],\r\n        [\r\n            'name' => 'VueConf',\r\n            'speakers' => [\r\n                'first_day' => ['Abigail', 'Joey'],\r\n            ],\r\n        ],\r\n    ]);\r\n\r\n    $plucked = $collection->pluck('speakers.first_day');\r\n\r\n    $plucked->all();\r\n\r\n    // [['Rosa', 'Judith'], ['Abigail', 'Joey']]\r\n\r\n如果存在重复键，则将最后一个匹配元素插入到 plucked 集合中：\r\n\r\n    $collection = collect([\r\n        ['brand' => 'Tesla',  'color' => 'red'],\r\n        ['brand' => 'Pagani', 'color' => 'white'],\r\n        ['brand' => 'Tesla',  'color' => 'black'],\r\n        ['brand' => 'Pagani', 'color' => 'orange'],\r\n    ]);\r\n\r\n    $plucked = $collection->pluck('color', 'brand');\r\n\r\n    $plucked->all();\r\n\r\n    // ['Tesla' => 'black', 'Pagani' => 'orange']\r\n\r\n<a name=\"method-pop\"></a>\r\n#### `pop()` {.collection-method}\r\n\r\n`pop` 方法删除并返回集合中的最后一项：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->pop();\r\n\r\n    // 5\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 4]\r\n\r\n你可以将整数传递给 `pop` 方法以从集合末尾删除并返回多个项目：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->pop(3);\r\n\r\n    // collect([5, 4, 3])\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2]\r\n\r\n<a name=\"method-prepend\"></a>\r\n#### `prepend()` {.collection-method}\r\n\r\n\r\n\r\n`prepend` 方法将一个项目添加到集合的开头：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->prepend(0);\r\n\r\n    $collection->all();\r\n\r\n    // [0, 1, 2, 3, 4, 5]\r\n\r\n你还可以传递第二个参数来指定前置项的键：\r\n\r\n    $collection = collect(['one' => 1, 'two' => 2]);\r\n\r\n    $collection->prepend(0, 'zero');\r\n\r\n    $collection->all();\r\n\r\n    // ['zero' => 0, 'one' => 1, 'two' => 2]\r\n\r\n<a name=\"method-pull\"></a>\r\n#### `pull()` {.collection-method}\r\n\r\n`pull` 方法通过它的键从集合中移除并返回一个项目：\r\n\r\n    $collection = collect(['product_id' => 'prod-100', 'name' => 'Desk']);\r\n\r\n    $collection->pull('name');\r\n\r\n    // 'Desk'\r\n\r\n    $collection->all();\r\n\r\n    // ['product_id' => 'prod-100']\r\n\r\n<a name=\"method-push\"></a>\r\n#### `push()` {.collection-method}\r\n\r\n`push` 方法将一个项目附加到集合的末尾：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $collection->push(5);\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 4, 5]\r\n\r\n<a name=\"method-put\"></a>\r\n#### `put()` {.collection-method}\r\n\r\n`put` 方法在集合中设置给定的键和值：\r\n\r\n    $collection = collect(['product_id' => 1, 'name' => 'Desk']);\r\n\r\n    $collection->put('price', 100);\r\n\r\n    $collection->all();\r\n\r\n    // ['product_id' => 1, 'name' => 'Desk', 'price' => 100]\r\n\r\n<a name=\"method-random\"></a>\r\n#### `random()` {.collection-method}\r\n\r\n`random` 方法从集合中返回一个随机项：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->random();\r\n\r\n    // 4 - (retrieved randomly)\r\n\r\n你可以将一个整数传递给 `random`，以指定要随机检索的项目数。当明确传递你希望接收的项目数时，始终返回项目集合：\r\n\r\n    $random = $collection->random(3);\r\n\r\n    $random->all();\r\n\r\n    // [2, 4, 5] - (retrieved randomly)\r\n\r\n如果集合实例的项目少于请求的项目，则 `random` 方法将抛出 `InvalidArgumentException`。\r\n\r\n`random` 方法也接受一个闭包，它将接收当前集合实例。\r\n\r\n    use Illuminate\\Support\\Collection;\r\n\r\n    $random = $collection->random(fn (Collection $items) => min(10, count($items)));\r\n\r\n    $random->all();\r\n\r\n    // [1, 2, 3, 4, 5] - (retrieved randomly)\r\n\r\n\r\n\r\n<a name=\"method-range\"></a>\r\n#### `range()` {.collection-method}\r\n\r\n`range` 方法返回一个包含指定范围之间整数的集合：\r\n\r\n    $collection = collect()->range(3, 6);\r\n\r\n    $collection->all();\r\n\r\n    // [3, 4, 5, 6]\r\n\r\n<a name=\"method-reduce\"></a>\r\n#### `reduce()` {.collection-method}\r\n\r\n`reduce` 方法将集合减少为单个值，将每次迭代的结果传递给后续迭代：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $total = $collection->reduce(function (int $carry, int $item) {\r\n        return $carry + $item;\r\n    });\r\n\r\n    // 6\r\n\r\n`$carry` 在第一次迭代时的值为 `null`；但是，你可以通过将第二个参数传递给 `reduce` 来指定其初始值：\r\n\r\n    $collection->reduce(function (int $carry, int $item) {\r\n        return $carry + $item;\r\n    }, 4);\r\n\r\n    // 10\r\n\r\n`reduce` 方法还将关联集合中的数组键传递给给定的回调：\r\n\r\n    $collection = collect([\r\n        'usd' => 1400,\r\n        'gbp' => 1200,\r\n        'eur' => 1000,\r\n    ]);\r\n\r\n    $ratio = [\r\n        'usd' => 1,\r\n        'gbp' => 1.37,\r\n        'eur' => 1.22,\r\n    ];\r\n\r\n    $collection->reduce(function (int $carry, int $value, int $key) use ($ratio) {\r\n        return $carry + ($value * $ratio[$key]);\r\n    });\r\n\r\n    // 4264\r\n\r\n<a name=\"method-reduce-spread\"></a>\r\n#### `reduceSpread()` {.collection-method}\r\n\r\n`reduceSpread` 方法将集合缩减为一个值数组，将每次迭代的结果传递给后续迭代。此方法类似于 `reduce` 方法；但是，它可以接受多个初始值：\r\n\r\n    [$creditsRemaining, $batch] = Image::where('status', 'unprocessed')\r\n        ->get()\r\n        ->reduceSpread(function (int $creditsRemaining, Collection $batch, Image $image) {\r\n            if ($creditsRemaining >= $image->creditsRequired()) {\r\n                $batch->push($image);\r\n\r\n                $creditsRemaining -= $image->creditsRequired();\r\n            }\r\n\r\n            return [$creditsRemaining, $batch];\r\n        }, $creditsAvailable, collect());\r\n\r\n<a name=\"method-reject\"></a>\r\n#### `reject()` {.collection-method}\r\n\r\n`reject` 方法使用给定的闭包过滤集合。如果应从结果集合中删除项目，则闭包应返回 `true`：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $filtered = $collection->reject(function (int $value, int $key) {\r\n        return $value > 2;\r\n    });\r\n\r\n    $filtered->all();\r\n\r\n    // [1, 2]\r\n\r\n\r\n\r\n对于 `reject` 方法的逆操作，请参见 [`filter`](#method-filter) 方法。\r\n\r\n<a name=\"method-replace\"></a>\r\n#### `replace()` {.collection-method}\r\n\r\n\r\n\r\n    $collection = collect(['Taylor', 'Abigail', 'James']);\r\n\r\n    $replaced = $collection->replace([1 => 'Victoria', 3 => 'Finn']);\r\n\r\n    $replaced->all();\r\n\r\n    // ['Taylor', 'Victoria', 'James', 'Finn']\r\n\r\n<a name=\"method-replacerecursive\"></a>\r\n#### `replaceRecursive()` {.collection-method}\r\n\r\n此方法的工作方式类似于 `replace`，但它会重复出现在数组中并对内部值应用相同的替换过程：\r\n\r\n    $collection = collect([\r\n        'Taylor',\r\n        'Abigail',\r\n        [\r\n            'James',\r\n            'Victoria',\r\n            'Finn'\r\n        ]\r\n    ]);\r\n\r\n    $replaced = $collection->replaceRecursive([\r\n        'Charlie',\r\n        2 => [1 => 'King']\r\n    ]);\r\n\r\n    $replaced->all();\r\n\r\n    // ['Charlie', 'Abigail', ['James', 'King', 'Finn']]\r\n\r\n<a name=\"method-reverse\"></a>\r\n#### `reverse()` {.collection-method}\r\n\r\n`reverse` 方法反转集合项的顺序，保留原始键：\r\n\r\n    $collection = collect(['a', 'b', 'c', 'd', 'e']);\r\n\r\n    $reversed = $collection->reverse();\r\n\r\n    $reversed->all();\r\n\r\n    /*\r\n        [\r\n            4 => 'e',\r\n            3 => 'd',\r\n            2 => 'c',\r\n            1 => 'b',\r\n            0 => 'a',\r\n        ]\r\n    */\r\n\r\n<a name=\"method-search\"></a>\r\n#### `search()` {.collection-method}\r\n\r\n`search` 方法在集合中搜索给定值，如果找到则返回其键。如果未找到该项目，则返回 `false`：\r\n\r\n    $collection = collect([2, 4, 6, 8]);\r\n\r\n    $collection->search(4);\r\n\r\n    // 1\r\n\r\n搜索是使用「松散」比较完成的，这意味着具有整数值的字符串将被视为等于具有相同值的整数。要使用「严格」比较，请将 `true` 作为第二个参数传递给方法：\r\n\r\n    collect([2, 4, 6, 8])->search('4', $strict = true);\r\n\r\n    // false\r\n\r\n或者，你可以提供自己的闭包来搜索通过给定真值测试的第一个项目：\r\n\r\n    collect([2, 4, 6, 8])->search(function (int $item, int $key) {\r\n        return $item > 5;\r\n    });\r\n\r\n    // 2\r\n\r\n\r\n\r\n<a name=\"method-shift\"></a>\r\n#### `shift()` {.collection-method}\r\n\r\n`shift` 方法从集合中移除并返回第一项：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->shift();\r\n\r\n    // 1\r\n\r\n    $collection->all();\r\n\r\n    // [2, 3, 4, 5]\r\n\r\n你可以将整数传递给 `shift` 方法以从集合的开头删除并返回多个项目：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->shift(3);\r\n\r\n    // collect([1, 2, 3])\r\n\r\n    $collection->all();\r\n\r\n    // [4, 5]\r\n\r\n<a name=\"method-shuffle\"></a>\r\n#### `shuffle()` {.collection-method}\r\n\r\n`shuffle` 方法随机打乱集合中的项目：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $shuffled = $collection->shuffle();\r\n\r\n    $shuffled->all();\r\n\r\n    // [3, 2, 5, 1, 4] - (generated randomly)\r\n\r\n<a name=\"method-skip\"></a>\r\n#### `skip()` {.collection-method}\r\n\r\n`skip` 方法返回一个新的集合，并从集合的开始删除指定数量的元素。\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n\r\n    $collection = $collection->skip(4);\r\n\r\n    $collection->all();\r\n\r\n    // [5, 6, 7, 8, 9, 10]\r\n\r\n<a name=\"method-skipuntil\"></a>\r\n#### `skipUntil()` {.collection-method}\r\n\r\n`skipUntil` 方法跳过集合中的项目，直到给定的回调返回 `true`，然后将集合中的剩余项目作为新的集合实例返回：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->skipUntil(function (int $item) {\r\n        return $item >= 3;\r\n    });\r\n\r\n    $subset->all();\r\n\r\n    // [3, 4]\r\n\r\n你还可以将一个简单的值传递给 `skipUntil` 方法以跳过所有项目，直到找到给定值：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->skipUntil(3);\r\n\r\n    $subset->all();\r\n\r\n    // [3, 4]\r\n\r\n> **注意：**如果没有找到给定的值或者回调从未返回 `true`，`skipUntil` 方法将返回一个空集合。\r\n\r\n<a name=\"method-skipwhile\"></a>\r\n#### `skipWhile()` {.collection-method}\r\n\r\n`skipWhile` 方法在给定回调返回 `true` 时跳过集合中的项目，然后将集合中的剩余项目作为新集合返回：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->skipWhile(function (int $item) {\r\n        return $item <= 3;\r\n    });\r\n\r\n    $subset->all();\r\n\r\n    // [4]\r\n\r\n> **注意：**如果回调从未返回 `false`，`skipWhile` 方法将返回一个空集合。\r\n\r\n\r\n\r\n<a name=\"method-slice\"></a>\r\n#### `slice()` {.collection-method}\r\n\r\n`slice` 方法返回从给定索引开始的集合的一个片断。\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n\r\n    $slice = $collection->slice(4);\r\n\r\n    $slice->all();\r\n\r\n    // [5, 6, 7, 8, 9, 10]\r\n\r\n如果你想限制返回切片的大小，请将所需的大小作为第二个参数传给该方法。\r\n\r\n    $slice = $collection->slice(4, 2);\r\n\r\n    $slice->all();\r\n\r\n    // [5, 6]\r\n\r\n返回的切片将默认保留键值。如果你不希望保留原始键，你可以使用 [`values`](#method-values) 方法来重新索引它们。\r\n\r\n<a name=\"method-sliding\"></a>\r\n#### `sliding()` {.collection-method}\r\n\r\n`sliding` 方法返回一个新的块集合，表示集合中项目的「滑动窗口」视图：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunks = $collection->sliding(2);\r\n\r\n    $chunks->toArray();\r\n\r\n    // [[1, 2], [2, 3], [3, 4], [4, 5]]\r\n\r\n这与 [`eachSpread`](#method-eachspread) 方法结合使用特别有用：\r\n\r\n    $transactions->sliding(2)->eachSpread(function (Collection $previous, Collection $current) {\r\n        $current->total = $previous->total + $current->amount;\r\n    });\r\n\r\n你可以选择传递第二个「步长」值，该值确定每个块的第一项之间的距离：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunks = $collection->sliding(3, step: 2);\r\n\r\n    $chunks->toArray();\r\n\r\n    // [[1, 2, 3], [3, 4, 5]]\r\n\r\n<a name=\"method-sole\"></a>\r\n#### `sole()` {.collection-method}\r\n\r\n`sole` 方法返回集合中第一个通过给定真值测试的元素，但只有在真值测试正好匹配一个元素的情况下。\r\n\r\n    collect([1, 2, 3, 4])->sole(function (int $value, int $key) {\r\n        return $value === 2;\r\n    });\r\n\r\n    // 2\r\n\r\n你也可以向 `sole` 方法传递一个键/值对，它将返回集合中第一个与给定对相匹配的元素，但只有当它正好有一个元素相匹配时。\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n    ]);\r\n\r\n    $collection->sole('product', 'Chair');\r\n\r\n    // ['product' => 'Chair', 'price' => 100]\r\n\r\n\r\n\r\n另外，如果只有一个元素，你也可以调用没有参数的 `sole` 方法来获得集合中的第一个元素。\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n    ]);\r\n\r\n    $collection->sole();\r\n\r\n    // ['product' => 'Desk', 'price' => 200]\r\n\r\n如果集合中没有应该由 `sole` 方法返回的元素，则会抛出 `\\Illuminate\\Collections\\ItemNotFoundException` 异常。如果应该返回多个元素，则会抛出 `\\Illuminate\\Collections\\MultipleItemsFoundException`。\r\n\r\n<a name=\"method-some\"></a>\r\n#### `some()` {.collection-method}\r\n\r\n[`contains`](#method-contains) 方法的别名。\r\n\r\n<a name=\"method-sort\"></a>\r\n#### `sort()` {.collection-method}\r\n\r\n`sort` 方法对集合进行排序。排序后的集合保留了原始数组键，因此在下面的示例中，我们将使用 [`values`](#method-values) 方法将键重置为连续编号的索引：\r\n\r\n    $collection = collect([5, 3, 1, 2, 4]);\r\n\r\n    $sorted = $collection->sort();\r\n\r\n    $sorted->values()->all();\r\n\r\n    // [1, 2, 3, 4, 5]\r\n\r\n如果你的排序需求更高级，你可以使用自己的算法将回调传递给「排序」。参考 PHP 文档[`uasort`](https://secure.php.net/manual/en/function.uasort.php#refsect1-function.uasort-parameters)，就是集合的`sort`方法 调用内部使用。\r\n\r\n> **技巧：**如果你需要对嵌套数组或对象的集合进行排序，请参阅 [`sortBy`](#method-sortby) 和 [`sortByDesc`](#method-sortbydesc) 方法。\r\n\r\n<a name=\"method-sortby\"></a>\r\n#### `sortBy()` {.collection-method}\r\n\r\n`sortBy` 方法按给定键对集合进行排序。排序后的集合保留了原始数组键，因此在下面的示例中，我们将使用 [`values`](#method-values) 方法将键重置为连续编号的索引：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Desk', 'price' => 200],\r\n        ['name' => 'Chair', 'price' => 100],\r\n        ['name' => 'Bookcase', 'price' => 150],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy('price');\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Chair', 'price' => 100],\r\n            ['name' => 'Bookcase', 'price' => 150],\r\n            ['name' => 'Desk', 'price' => 200],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n`sortBy` 方法接受 [sort flags](https://www.php.net/manual/en/function.sort.php) 作为其第二个参数：\r\n\r\n    $collection = collect([\r\n        ['title' => 'Item 1'],\r\n        ['title' => 'Item 12'],\r\n        ['title' => 'Item 3'],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy('title', SORT_NATURAL);\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['title' => 'Item 1'],\r\n            ['title' => 'Item 3'],\r\n            ['title' => 'Item 12'],\r\n        ]\r\n    */\r\n\r\n或者，你可以传递自己的闭包来确定如何对集合的值进行排序：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],\r\n        ['name' => 'Chair', 'colors' => ['Black']],\r\n        ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy(function (array $product, int $key) {\r\n        return count($product['colors']);\r\n    });\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Chair', 'colors' => ['Black']],\r\n            ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],\r\n            ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],\r\n        ]\r\n    */\r\n\r\n如果你想按多个属性对集合进行排序，可以将排序操作数组传递给 `sortBy` 方法。每个排序操作都应该是一个数组，由你希望排序的属性和所需排序的方向组成：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Taylor Otwell', 'age' => 34],\r\n        ['name' => 'Abigail Otwell', 'age' => 30],\r\n        ['name' => 'Taylor Otwell', 'age' => 36],\r\n        ['name' => 'Abigail Otwell', 'age' => 32],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy([\r\n        ['name', 'asc'],\r\n        ['age', 'desc'],\r\n    ]);\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Abigail Otwell', 'age' => 32],\r\n            ['name' => 'Abigail Otwell', 'age' => 30],\r\n            ['name' => 'Taylor Otwell', 'age' => 36],\r\n            ['name' => 'Taylor Otwell', 'age' => 34],\r\n        ]\r\n    */\r\n\r\n当按多个属性对集合进行排序时，你还可以提供定义每个排序操作的闭包：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Taylor Otwell', 'age' => 34],\r\n        ['name' => 'Abigail Otwell', 'age' => 30],\r\n        ['name' => 'Taylor Otwell', 'age' => 36],\r\n        ['name' => 'Abigail Otwell', 'age' => 32],\r\n    ]);\r\n\r\n    $sorted = $collection->sortBy([\r\n        fn (array $a, array $b) => $a['name'] <=> $b['name'],\r\n        fn (array $a, array $b) => $b['age'] <=> $a['age'],\r\n    ]);\r\n\r\n    $sorted->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Abigail Otwell', 'age' => 32],\r\n            ['name' => 'Abigail Otwell', 'age' => 30],\r\n            ['name' => 'Taylor Otwell', 'age' => 36],\r\n            ['name' => 'Taylor Otwell', 'age' => 34],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n<a name=\"method-sortbydesc\"></a>\r\n#### `sortByDesc()` {.collection-method}\r\n\r\n此方法与 [`sortBy`](#method-sortby) 方法具有相同的签名，但将以相反的顺序对集合进行排序。\r\n\r\n<a name=\"method-sortdesc\"></a>\r\n#### `sortDesc()` {.collection-method}\r\n\r\n此方法将按照与 [`sort`](#method-sort) 方法相反的顺序对集合进行排序：\r\n\r\n    $collection = collect([5, 3, 1, 2, 4]);\r\n\r\n    $sorted = $collection->sortDesc();\r\n\r\n    $sorted->values()->all();\r\n\r\n    // [5, 4, 3, 2, 1]\r\n\r\n与 `sort` 不同，你不能将闭包传递给 `sortDesc`。相反，你应该使用 [`sort`](#method-sort) 方法并反转比较。\r\n\r\n<a name=\"method-sortkeys\"></a>\r\n#### `sortKeys()` {.collection-method}\r\n\r\n`sortKeys` 方法通过底层关联数组的键对集合进行排序：\r\n\r\n    $collection = collect([\r\n        'id' => 22345,\r\n        'first' => 'John',\r\n        'last' => 'Doe',\r\n    ]);\r\n\r\n    $sorted = $collection->sortKeys();\r\n\r\n    $sorted->all();\r\n\r\n    /*\r\n        [\r\n            'first' => 'John',\r\n            'id' => 22345,\r\n            'last' => 'Doe',\r\n        ]\r\n    */\r\n\r\n<a name=\"method-sortkeysdesc\"></a>\r\n#### `sortKeysDesc()` {.collection-method}\r\n\r\n此方法与 [`sortKeys`](#method-sortkeys) 方法具有相同的签名，但将以相反的顺序对集合进行排序。\r\n\r\n<a name=\"method-sortkeysusing\"></a>\r\n#### `sortKeysUsing()` {.collection-method}\r\n\r\n`sortKeysUsing` 方法使用回调通过底层关联数组的键对集合进行排序：\r\n\r\n    $collection = collect([\r\n        'ID' => 22345,\r\n        'first' => 'John',\r\n        'last' => 'Doe',\r\n    ]);\r\n\r\n    $sorted = $collection->sortKeysUsing('strnatcasecmp');\r\n\r\n    $sorted->all();\r\n\r\n    /*\r\n        [\r\n            'first' => 'John',\r\n            'ID' => 22345,\r\n            'last' => 'Doe',\r\n        ]\r\n    */\r\n\r\n回调必须是返回小于、等于或大于零的整数的比较函数。有关更多信息，请参阅 [`uksort`](https://www.php.net/manual/en/function.uksort.php#refsect1-function.uksort-parameters) 上的 PHP 文档，这是 PHP 函数 `sortKeysUsing` 方法在内部使用。\r\n\r\n<a name=\"method-splice\"></a>\r\n#### `splice()` {.collection-method}\r\n\r\n`splice` 方法删除并返回从指定索引开始的项目切片：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->splice(2);\r\n\r\n    $chunk->all();\r\n\r\n    // [3, 4, 5]\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2]\r\n\r\n\r\n\r\n你可以传递第二个参数来限制结果集合的大小：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->splice(2, 1);\r\n\r\n    $chunk->all();\r\n\r\n    // [3]\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 4, 5]\r\n\r\n此外，你可以传递包含新项目的第三个参数来替换从集合中删除的项目：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->splice(2, 1, [10, 11]);\r\n\r\n    $chunk->all();\r\n\r\n    // [3]\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 10, 11, 4, 5]\r\n\r\n<a name=\"method-split\"></a>\r\n#### `split()` {.collection-method}\r\n\r\n`split` 方法将集合分成给定数量的组：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $groups = $collection->split(3);\r\n\r\n    $groups->all();\r\n\r\n    // [[1, 2], [3, 4], [5]]\r\n\r\n<a name=\"method-splitin\"></a>\r\n#### `splitIn()` {.collection-method}\r\n\r\n`splitIn` 方法将集合分成给定数量的组，在将剩余部分分配给最终组之前完全填充非终端组：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\r\n\r\n    $groups = $collection->splitIn(3);\r\n\r\n    $groups->all();\r\n\r\n    // [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]\r\n\r\n<a name=\"method-sum\"></a>\r\n#### `sum()` {.collection-method}\r\n\r\n`sum` 方法返回集合中所有项目的总和：\r\n\r\n    collect([1, 2, 3, 4, 5])->sum();\r\n\r\n    // 15\r\n\r\n如果集合包含嵌套数组或对象，则应传递一个键，用于确定要对哪些值求和：\r\n\r\n    $collection = collect([\r\n        ['name' => 'JavaScript: The Good Parts', 'pages' => 176],\r\n        ['name' => 'JavaScript: The Definitive Guide', 'pages' => 1096],\r\n    ]);\r\n\r\n    $collection->sum('pages');\r\n\r\n    // 1272\r\n\r\n此外，你可以传递自己的闭包来确定要对集合的哪些值求和：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Chair', 'colors' => ['Black']],\r\n        ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']],\r\n        ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']],\r\n    ]);\r\n\r\n    $collection->sum(function (array $product) {\r\n        return count($product['colors']);\r\n    });\r\n\r\n    // 6\r\n\r\n<a name=\"method-take\"></a>\r\n#### `take()` {.collection-method}\r\n\r\n`take` 方法返回一个具有指定数量项目的新集合：\r\n\r\n    $collection = collect([0, 1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->take(3);\r\n\r\n    $chunk->all();\r\n\r\n    // [0, 1, 2]\r\n\r\n你还可以传递一个负整数以从集合末尾获取指定数量的项目：\r\n\r\n    $collection = collect([0, 1, 2, 3, 4, 5]);\r\n\r\n    $chunk = $collection->take(-2);\r\n\r\n    $chunk->all();\r\n\r\n    // [4, 5]\r\n\r\n\r\n\r\n<a name=\"method-takeuntil\"></a>\r\n#### `takeUntil()` {.collection-method}\r\n\r\n`takeUntil` 方法返回集合中的项目，直到给定的回调返回 `true`：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->takeUntil(function (int $item) {\r\n        return $item >= 3;\r\n    });\r\n\r\n    $subset->all();\r\n\r\n    // [1, 2]\r\n\r\n你还可以将一个简单的值传递给 `takeUntil` 方法以获取项目，直到找到给定值：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->takeUntil(3);\r\n\r\n    $subset->all();\r\n\r\n    // [1, 2]\r\n\r\n> **注意：**如果未找到给定值或回调从未返回 `true`，则 `takeUntil` 方法将返回集合中的所有项目。\r\n\r\n<a name=\"method-takewhile\"></a>\r\n#### `takeWhile()` {.collection-method}\r\n\r\n`takeWhile` 方法返回集合中的项目，直到给定的回调返回 `false`：\r\n\r\n    $collection = collect([1, 2, 3, 4]);\r\n\r\n    $subset = $collection->takeWhile(function (int $item) {\r\n        return $item < 3;\r\n    });\r\n\r\n    $subset->all();\r\n\r\n    // [1, 2]\r\n\r\n> **注意：**如果回调从不返回 `false`，则 `takeWhile` 方法将返回集合中的所有项目。\r\n\r\n<a name=\"method-tap\"></a>\r\n#### `tap()` {.collection-method}\r\n\r\n`tap` 方法将集合传递给给定的回调，允许你在特定点「点击」到集合中并在不影响集合本身的情况下对项目执行某些操作。然后集合由 `tap` 方法返回：\r\n\r\n    collect([2, 4, 3, 1, 5])\r\n        ->sort()\r\n        ->tap(function (Collection $collection) {\r\n            Log::debug('Values after sorting', $collection->values()->all());\r\n        })\r\n        ->shift();\r\n\r\n    // 1\r\n\r\n<a name=\"method-times\"></a>\r\n#### `times()` {.collection-method}\r\n\r\n静态 `times` 方法通过调用给定次数的回调函数来创建新集合：\r\n\r\n    $collection = Collection::times(10, function (int $number) {\r\n        return $number * 9;\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]\r\n\r\n<a name=\"method-toarray\"></a>\r\n#### `toArray()` {.collection-method}\r\n\r\n该 `toArray` 方法将集合转换成 PHP `array`。如果集合的值是 [Eloquent](/docs/laravel/10.x/eloquent) 模型，那也会被转换成数组：\r\n\r\n    $collection = collect(['name' => 'Desk', 'price' => 200]);\r\n\r\n    $collection->toArray();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Desk', 'price' => 200],\r\n        ]\r\n    */\r\n\r\n> **注意：**`toArray` 也会将 `Arrayable` 的实例、所有集合的嵌套对象转换为数组。如果你想获取原数组，可以使用 [`all`](#method-all) 方法。\r\n\r\n\r\n<a name=\"method-tojson\"></a>\r\n#### `toJson()` {.collection-method}\r\n\r\n该 `toJson` 方法将集合转换成 JSON 字符串：\r\n\r\n    $collection = collect(['name' => 'Desk', 'price' => 200]);\r\n\r\n    $collection->toJson();\r\n\r\n    // '{\"name\":\"Desk\", \"price\":200}'\r\n\r\n<a name=\"method-transform\"></a>\r\n#### `transform()` {.collection-method}\r\n\r\n该 `transform` 方法会遍历整个集合，并对集合中的每个元素都会调用其回调函数。集合中的元素将被替换为回调函数返回的值：\r\n\r\n    $collection = collect([1, 2, 3, 4, 5]);\r\n\r\n    $collection->transform(function (int $item, int $key) {\r\n        return $item * 2;\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [2, 4, 6, 8, 10]\r\n\r\n> **注意：**与大多数集合方法不同，`transform` 会修改集合本身。如果你想创建新集合，可以使用 [`map`](#method-map) 方法。\r\n\r\n<a name=\"method-undot\"></a>\r\n#### `undot()` {.collection-method}\r\n\r\n`undot()` 方法将使用「点」表示法的一维集合扩展为多维集合：\r\n\r\n    $person = collect([\r\n        'name.first_name' => 'Marie',\r\n        'name.last_name' => 'Valentine',\r\n        'address.line_1' => '2992 Eagle Drive',\r\n        'address.line_2' => '',\r\n        'address.suburb' => 'Detroit',\r\n        'address.state' => 'MI',\r\n        'address.postcode' => '48219'\r\n    ]);\r\n\r\n    $person = $person->undot();\r\n\r\n    $person->toArray();\r\n\r\n    /*\r\n        [\r\n            \"name\" => [\r\n                \"first_name\" => \"Marie\",\r\n                \"last_name\" => \"Valentine\",\r\n            ],\r\n            \"address\" => [\r\n                \"line_1\" => \"2992 Eagle Drive\",\r\n                \"line_2\" => \"\",\r\n                \"suburb\" => \"Detroit\",\r\n                \"state\" => \"MI\",\r\n                \"postcode\" => \"48219\",\r\n            ],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-union\"></a>\r\n#### `union()` {.collection-method}\r\n\r\n该 `union` 方法将给定数组添加到集合中。如果给定的数组含有与原集合一样的键，则首选原始集合的值：\r\n\r\n    $collection = collect([1 => ['a'], 2 => ['b']]);\r\n\r\n    $union = $collection->union([3 => ['c'], 1 => ['d']]);\r\n\r\n    $union->all();\r\n\r\n    // [1 => ['a'], 2 => ['b'], 3 => ['c']]\r\n\r\n<a name=\"method-unique\"></a>\r\n#### `unique()` {.collection-method}\r\n\r\n该 `unique` 方法返回集合中所有唯一项。返回的集合保留着原数组的键，所以在这个例子中，我们使用 [`values`](#method-values) 方法把键重置为连续编号的索引：\r\n\r\n    $collection = collect([1, 1, 2, 2, 3, 4, 2]);\r\n\r\n    $unique = $collection->unique();\r\n\r\n    $unique->values()->all();\r\n\r\n    // [1, 2, 3, 4]\r\n\r\n\r\n\r\n当处理嵌套数组或对象时，你可以指定用于确定唯一性的键：\r\n\r\n    $collection = collect([\r\n        ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],\r\n        ['name' => 'iPhone 5', 'brand' => 'Apple', 'type' => 'phone'],\r\n        ['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'],\r\n        ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],\r\n        ['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'],\r\n    ]);\r\n\r\n    $unique = $collection->unique('brand');\r\n\r\n    $unique->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],\r\n            ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],\r\n        ]\r\n    */\r\n\r\n最后，你还可以将自己的闭包传递给该 `unique` 方法，以指定哪个值应确定项目的唯一性：\r\n\r\n    $unique = $collection->unique(function (array $item) {\r\n        return $item['brand'].$item['type'];\r\n    });\r\n\r\n    $unique->values()->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'],\r\n            ['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'],\r\n            ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'],\r\n            ['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'],\r\n        ]\r\n    */\r\n\r\n该 `unique` 方法在检查项目值时使用「宽松」模式比较，意味着具有整数值的字符串将被视为等于相同值的整数。你可以使用  [`uniqueStrict`](#method-uniquestrict)  方法做「严格」模式比较。\r\n\r\n> **技巧：**这个方法的行为在使用 [Eloquent 集合](/docs/laravel/10.x/eloquent-collections#method-unique) 时被修改。\r\n\r\n<a name=\"method-uniquestrict\"></a>\r\n#### `uniqueStrict()` {.collection-method}\r\n\r\n这个方法与 [`unique`](#method-unique) 方法一样，然而，所有的值是用「严格」模式来比较的。\r\n\r\n<a name=\"method-unless\"></a>\r\n#### `unless()` {.collection-method}\r\n\r\n该 `unless` 方法当传入的第一个参数不为 `true` 的时候，将执行给定的回调函数：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $collection->unless(true, function (Collection $collection) {\r\n        return $collection->push(4);\r\n    });\r\n\r\n    $collection->unless(false, function (Collection $collection) {\r\n        return $collection->push(5);\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 5]\r\n\r\n\r\n\r\n可以将第二个回调传递给该 `unless` 方法。 `unless` 当给方法的第一个参数计算结果为时，将执行第二个回调 `true`:\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $collection->unless(true, function (Collection $collection) {\r\n        return $collection->push(4);\r\n    }, function (Collection $collection) {\r\n        return $collection->push(5);\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 5]\r\n\r\n与 `unless` 相反的，请参见 [`when`](#method-when) 方法。\r\n\r\n<a name=\"method-unlessempty\"></a>\r\n#### `unlessEmpty()` {.collection-method}\r\n\r\n[`whenNotEmpty`](#method-whennotempty) 的别名方法。\r\n\r\n<a name=\"method-unlessnotempty\"></a>\r\n#### `unlessNotEmpty()` {.collection-method}\r\n\r\n[`whenEmpty`](#method-whenempty) 的别名方法。\r\n\r\n<a name=\"method-unwrap\"></a>\r\n#### `unwrap()` {.collection-method}\r\n\r\n静态 `unwrap` 方法返回集合内部的可用元素：\r\n\r\n    Collection::unwrap(collect('John Doe'));\r\n\r\n    // ['John Doe']\r\n\r\n    Collection::unwrap(['John Doe']);\r\n\r\n    // ['John Doe']\r\n\r\n    Collection::unwrap('John Doe');\r\n\r\n    // 'John Doe'\r\n\r\n<a name=\"method-value\"></a>\r\n#### `value()` {.collection-method}\r\n\r\n`value` 方法从集合的第一个元素中检索一个给定的值。\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Speaker', 'price' => 400],\r\n    ]);\r\n\r\n    $value = $collection->value('price');\r\n\r\n    // 200\r\n\r\n<a name=\"method-values\"></a>\r\n#### `values()` {.collection-method}\r\n\r\n该 `values` 方法返回键被重置为连续编号的新集合：\r\n\r\n    $collection = collect([\r\n        10 => ['product' => 'Desk', 'price' => 200],\r\n        11 => ['product' => 'Desk', 'price' => 200],\r\n    ]);\r\n\r\n    $values = $collection->values();\r\n\r\n    $values->all();\r\n\r\n    /*\r\n        [\r\n            0 => ['product' => 'Desk', 'price' => 200],\r\n            1 => ['product' => 'Desk', 'price' => 200],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-when\"></a>\r\n#### `when()` {.collection-method}\r\n\r\n当 `when` 方法的第一个参数传入为 `true` 时，将执行给定的回调函数。\r\n集合实例和给到 `when` 方法的第一个参数将被提供给闭包。\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $collection->when(true, function (Collection $collection, int $value) {\r\n        return $collection->push(4);\r\n    });\r\n\r\n    $collection->when(false, function (Collection $collection, int $value) {\r\n        return $collection->push(5);\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 4]\r\n\r\n\r\n\r\n可以将第二个回调传递给该 `when` 方法。当给 `when` 方法的第一个参数计算结果为 `false` 时，将执行第二个回调：\r\n\r\n    $collection = collect([1, 2, 3]);\r\n\r\n    $collection->when(false, function (Collection $collection, int $value) {\r\n        return $collection->push(4);\r\n    }, function (Collection $collection) {\r\n        return $collection->push(5);\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // [1, 2, 3, 5]\r\n\r\n与 `when` 相反的方法，请查看 [`unless`](#method-unless) 方法。\r\n\r\n<a name=\"method-whenempty\"></a>\r\n#### `whenEmpty()` {.collection-method}\r\n\r\n该 `whenEmpty` 方法是当集合为空时，将执行给定的回调函数：\r\n\r\n    $collection = collect(['Michael', 'Tom']);\r\n\r\n    $collection->whenEmpty(function (Collection $collection) {\r\n        return $collection->push('Adam');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['Michael', 'Tom']\r\n\r\n\r\n    $collection = collect();\r\n\r\n    $collection->whenEmpty(function (Collection $collection) {\r\n        return $collection->push('Adam');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['Adam']\r\n\r\n当集合不为空时，可以将第二个闭包传递给 `whenEmpty` 将要执行的方法：\r\n\r\n    $collection = collect(['Michael', 'Tom']);\r\n\r\n    $collection->whenEmpty(function (Collection $collection) {\r\n        return $collection->push('Adam');\r\n    }, function (Collection $collection) {\r\n        return $collection->push('Taylor');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['Michael', 'Tom', 'Taylor']\r\n\r\n与 `whenEmpty` 相反的方法，请查看 [`whenNotEmpty`](#method-whennotempty) 方法。\r\n\r\n<a name=\"method-whennotempty\"></a>\r\n#### `whenNotEmpty()` {.collection-method}\r\n\r\n该 `whenNotEmpty` 方法当集合不为空时，将执行给定的回调函数：\r\n\r\n    $collection = collect(['michael', 'tom']);\r\n\r\n    $collection->whenNotEmpty(function (Collection $collection) {\r\n        return $collection->push('adam');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['michael', 'tom', 'adam']\r\n\r\n\r\n    $collection = collect();\r\n\r\n    $collection->whenNotEmpty(function (Collection $collection) {\r\n        return $collection->push('adam');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // []\r\n\r\n可以将第二个闭包传递给 `whenNotEmpty` 将在集合为空时执行的方法：\r\n\r\n    $collection = collect();\r\n\r\n    $collection->whenNotEmpty(function (Collection $collection) {\r\n        return $collection->push('adam');\r\n    }, function (Collection $collection) {\r\n        return $collection->push('taylor');\r\n    });\r\n\r\n    $collection->all();\r\n\r\n    // ['taylor']\r\n\r\n\r\n\r\n与 `whenNotEmpty` 相反的方法，请查看 [`whenEmpty`](#method-whenempty) 方法。\r\n\r\n<a name=\"method-where\"></a>\r\n#### `where()` {.collection-method}\r\n\r\n该 `where` 方法通过给定的键 / 值对查询过滤集合的结果：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->where('price', 100);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Chair', 'price' => 100],\r\n            ['product' => 'Door', 'price' => 100],\r\n        ]\r\n    */\r\n\r\n该 `where` 方法在检查集合项值时使用「宽松」模式比较，这意味着具有整数值的字符串会被认为等于相同值的整数。你可以使用 [`whereStrict`](#method-wherestrict) 方法进行「严格」模式比较。\r\n\r\n而且，你还可以将一个比较运算符作为第二个参数传递。\r\n支持的运算符是有 '===', '！==', '！=', '==', '=', '<>', '>', '<', '>=', 和 '<='。\r\n\r\n    $collection = collect([\r\n        ['name' => 'Jim', 'deleted_at' => '2019-01-01 00:00:00'],\r\n        ['name' => 'Sally', 'deleted_at' => '2019-01-02 00:00:00'],\r\n        ['name' => 'Sue', 'deleted_at' => null],\r\n    ]);\r\n\r\n    $filtered = $collection->where('deleted_at', '!=', null);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Jim', 'deleted_at' => '2019-01-01 00:00:00'],\r\n            ['name' => 'Sally', 'deleted_at' => '2019-01-02 00:00:00'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-wherestrict\"></a>\r\n#### `whereStrict()` {.collection-method}\r\n\r\n此方法和 [`where`](#method-where) 方法使用相似；但是它是「严格」模式去匹配值和类型。\r\n\r\n<a name=\"method-wherebetween\"></a>\r\n#### `whereBetween()` {.collection-method}\r\n\r\n该 `whereBetween` 方法会筛选给定范围的集合：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 80],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Pencil', 'price' => 30],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->whereBetween('price', [100, 200]);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Desk', 'price' => 200],\r\n            ['product' => 'Bookcase', 'price' => 150],\r\n            ['product' => 'Door', 'price' => 100],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n<a name=\"method-wherein\"></a>\r\n#### `whereIn()` {.collection-method}\r\n\r\n该 `whereIn` 方法会根据包含给定数组的键 / 值对来过滤集合：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->whereIn('price', [150, 200]);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Desk', 'price' => 200],\r\n            ['product' => 'Bookcase', 'price' => 150],\r\n        ]\r\n    */\r\n\r\n`whereIn` 方法在检查项目值时使用 \"loose\" 比较，这意味着具有整数值的字符串将被视为等于相同值的整数。使用 [`whereInStrict`](#method-whereinstrict) 方法使用「strict」比较进行过滤。\r\n\r\n<a name=\"method-whereinstrict\"></a>\r\n#### `whereInStrict()` {.collection-method}\r\n\r\n此方法与 [`whereIn`](#method-wherein) 方法具有相同的签名；但是，所有值都使用「strict」比较进行比较。\r\n\r\n<a name=\"method-whereinstanceof\"></a>\r\n#### `whereInstanceOf()` {.collection-method}\r\n\r\n`whereInstanceOf` 方法按给定的类类型过滤集合：\r\n\r\n    use App\\Models\\User;\r\n    use App\\Models\\Post;\r\n\r\n    $collection = collect([\r\n        new User,\r\n        new User,\r\n        new Post,\r\n    ]);\r\n\r\n    $filtered = $collection->whereInstanceOf(User::class);\r\n\r\n    $filtered->all();\r\n\r\n    // [App\\Models\\User, App\\Models\\User]\r\n\r\n<a name=\"method-wherenotbetween\"></a>\r\n#### `whereNotBetween()` {.collection-method}\r\n\r\n`whereNotBetween` 方法通过确定指定项的值是否超出给定范围来过滤集合：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 80],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Pencil', 'price' => 30],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->whereNotBetween('price', [100, 200]);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Chair', 'price' => 80],\r\n            ['product' => 'Pencil', 'price' => 30],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-wherenotin\"></a>\r\n#### `whereNotIn()` {.collection-method}\r\n\r\n`whereNotIn` 方法从集合中删除具有给定数组中包含的指定项值的元素：\r\n\r\n    $collection = collect([\r\n        ['product' => 'Desk', 'price' => 200],\r\n        ['product' => 'Chair', 'price' => 100],\r\n        ['product' => 'Bookcase', 'price' => 150],\r\n        ['product' => 'Door', 'price' => 100],\r\n    ]);\r\n\r\n    $filtered = $collection->whereNotIn('price', [150, 200]);\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['product' => 'Chair', 'price' => 100],\r\n            ['product' => 'Door', 'price' => 100],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n`whereNotIn` 方法在检查项目值时使用「loose」比较，这意味着具有整数值的字符串将被视为等于具有相同值的整数。使用 [`whereNotInStrict`](#method-wherenotinstrict) 方法使用「strict」比较进行过滤。\r\n\r\n<a name=\"method-wherenotinstrict\"></a>\r\n#### `whereNotInStrict()` {.collection-method}\r\n\r\n这个方法与 [`whereNotIn`](#method-wherenotin) 方法类似；不同的是会使用「严格」模式比较。\r\n\r\n<a name=\"method-wherenotnull\"></a>\r\n#### `whereNotNull()` {.collection-method}\r\n\r\n该 `whereNotNull` 方法筛选给定键不为 `null`的项：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Desk'],\r\n        ['name' => null],\r\n        ['name' => 'Bookcase'],\r\n    ]);\r\n\r\n    $filtered = $collection->whereNotNull('name');\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => 'Desk'],\r\n            ['name' => 'Bookcase'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-wherenull\"></a>\r\n#### `whereNull()` {.collection-method}\r\n\r\n该 `whereNull` 方法筛选给定键为 `null`的项：\r\n\r\n    $collection = collect([\r\n        ['name' => 'Desk'],\r\n        ['name' => null],\r\n        ['name' => 'Bookcase'],\r\n    ]);\r\n\r\n    $filtered = $collection->whereNull('name');\r\n\r\n    $filtered->all();\r\n\r\n    /*\r\n        [\r\n            ['name' => null],\r\n        ]\r\n    */\r\n\r\n\r\n<a name=\"method-wrap\"></a>\r\n#### `wrap()` {.collection-method}\r\n\r\n静态 `wrap` 方法会将给定值封装到集合中：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n\r\n    $collection = Collection::wrap('John Doe');\r\n\r\n    $collection->all();\r\n\r\n    // ['John Doe']\r\n\r\n    $collection = Collection::wrap(['John Doe']);\r\n\r\n    $collection->all();\r\n\r\n    // ['John Doe']\r\n\r\n    $collection = Collection::wrap(collect('John Doe'));\r\n\r\n    $collection->all();\r\n\r\n    // ['John Doe']\r\n\r\n<a name=\"method-zip\"></a>\r\n#### `zip()` {.collection-method}\r\n\r\n该 `zip` 方法在与集合的值对应的索引处合并给定数组的值：\r\n\r\n    $collection = collect(['Chair', 'Desk']);\r\n\r\n    $zipped = $collection->zip([100, 200]);\r\n\r\n    $zipped->all();\r\n\r\n    // [['Chair', 100], ['Desk', 200]]\r\n\r\n<a name=\"higher-order-messages\"></a>\r\n## Higher Order Messages\r\n\r\n集合也提供对「高阶消息传递」的支持，即集合常见操作的快捷方式。支持高阶消息传递的集合方法有： [`average`](#method-average)、[`avg`](#method-avg)、[`contains`](#method-contains)、[`each`](#method-each)、[`every`](#method-every)、[`filter`](#method-filter)、[`first`](#method-first)、[`flatMap`](#method-flatmap)、[`groupBy`](#method-groupby)、[`keyBy`](#method-keyby)、[`map`](#method-map)、[`max`](#method-max)、[`min`](#method-min)、[`partition`](#method-partition)、[`reject`](#method-reject)、[`skipUntil`](#method-skipuntil)、[`skipWhile`](#method-skipwhile)、[`some`](#method-some)、[`sortBy`](#method-sortby)、[`sortByDesc`](#method-sortbydesc)、[`sum`](#method-sum)、[`takeUntil`](#method-takeuntil)、[`takeWhile`](#method-takeewhile) 和 [`unique`](#method-unique)。\r\n\r\n\r\n每个高阶消息都可以作为集合实例上的动态属性进行访问。例如，让我们使用 `each` 高阶消息来调用集合中每个对象的方法：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where('votes', '>', 500)->get();\r\n\r\n    $users->each->markAsVip();\r\n\r\n同样，我们可以使用 `sum` 高阶消息来收集用户集合的「votes」总数：\r\n\r\n    $users = User::where('group', 'Development')->get();\r\n\r\n    return $users->sum->votes;\r\n\r\n<a name=\"lazy-collections\"></a>\r\n## 惰性集合\r\n\r\n<a name=\"lazy-collection-introduction\"></a>\r\n### 介绍\r\n\r\n> **注意：**在进一步了解 Laravel 的惰性集合之前，花点时间熟悉一下 [PHP 生成器](https://www.php.net/manual/en/language.generators.overview.php).\r\n\r\n为了补充已经强大的 `Collection` 类，`LazyCollection` 类利用 PHP 的 [generators](https://www.php.net/manual/en/language.generators.overview.php) 允许你使用非常 大型数据集，同时保持较低的内存使用率。\r\n\r\n例如，假设你的应用程序需要处理数 GB 的日志文件，同时利用 Laravel 的集合方法来解析日志。可以使用惰性集合在给定时间仅将文件的一小部分保留在内存中，而不是一次将整个文件读入内存：\r\n\r\n    use App\\Models\\LogEntry;\r\n    use Illuminate\\Support\\LazyCollection;\r\n\r\n    LazyCollection::make(function () {\r\n        $handle = fopen('log.txt', 'r');\r\n\r\n        while (($line = fgets($handle)) !== false) {\r\n            yield $line;\r\n        }\r\n    })->chunk(4)->map(function (array $lines) {\r\n        return LogEntry::fromLines($lines);\r\n    })->each(function (LogEntry $logEntry) {\r\n        // Process the log entry...\r\n    });\r\n\r\n\r\n\r\n或者，假设你需要遍历 10,000 个 Eloquent 模型。使用传统 Laravel 集合时，所有 10,000 个 Eloquent 模型必须同时加载到内存中：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::all()->filter(function (User $user) {\r\n        return $user->id > 500;\r\n    });\r\n\r\n但是，查询构建器的 `cursor` 方法返回一个 `LazyCollection` 实例。这允许你仍然只对数据库运行一个查询，而且一次只在内存中加载一个 Eloquent 模型。在这个例子中，`filter` 回调在我们实际单独遍历每个用户之前不会执行，从而可以大幅减少内存使用量：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::cursor()->filter(function (User $user) {\r\n        return $user->id > 500;\r\n    });\r\n\r\n    foreach ($users as $user) {\r\n        echo $user->id;\r\n    }\r\n\r\n<a name=\"creating-lazy-collections\"></a>\r\n### 创建惰性集合\r\n\r\n要创建惰性集合实例，你应该将 PHP 生成器函数传递给集合的 `make` 方法：\r\n\r\n    use Illuminate\\Support\\LazyCollection;\r\n\r\n    LazyCollection::make(function () {\r\n        $handle = fopen('log.txt', 'r');\r\n\r\n        while (($line = fgets($handle)) !== false) {\r\n            yield $line;\r\n        }\r\n    });\r\n\r\n<a name=\"the-enumerable-contract\"></a>\r\n### 枚举契约\r\n\r\n`Collection` 类上几乎所有可用的方法也可以在 `LazyCollection` 类上使用。这两个类都实现了 `Illuminate\\Support\\Enumerable` 契约，它定义了以下方法：\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        columns: 10.8em 3; -moz-columns: 10.8em 3; -webkit-columns: 10.8em 3;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[all](#method-all)\r\n[average](#method-average)\r\n[avg](#method-avg)\r\n[chunk](#method-chunk)\r\n[chunkWhile](#method-chunkwhile)\r\n[collapse](#method-collapse)\r\n[collect](#method-collect)\r\n[combine](#method-combine)\r\n[concat](#method-concat)\r\n[contains](#method-contains)\r\n[containsStrict](#method-containsstrict)\r\n[count](#method-count)\r\n[countBy](#method-countBy)\r\n[crossJoin](#method-crossjoin)\r\n[dd](#method-dd)\r\n[diff](#method-diff)\r\n[diffAssoc](#method-diffassoc)\r\n[diffKeys](#method-diffkeys)\r\n[dump](#method-dump)\r\n[duplicates](#method-duplicates)\r\n[duplicatesStrict](#method-duplicatesstrict)\r\n[each](#method-each)\r\n[eachSpread](#method-eachspread)\r\n[every](#method-every)\r\n[except](#method-except)\r\n[filter](#method-filter)\r\n[first](#method-first)\r\n[firstOrFail](#method-first-or-fail)\r\n[firstWhere](#method-first-where)\r\n[flatMap](#method-flatmap)\r\n[flatten](#method-flatten)\r\n[flip](#method-flip)\r\n[forPage](#method-forpage)\r\n[get](#method-get)\r\n[groupBy](#method-groupby)\r\n[has](#method-has)\r\n[implode](#method-implode)\r\n[intersect](#method-intersect)\r\n[intersectAssoc](#method-intersectAssoc)\r\n[intersectByKeys](#method-intersectbykeys)\r\n[isEmpty](#method-isempty)\r\n[isNotEmpty](#method-isnotempty)\r\n[join](#method-join)\r\n[keyBy](#method-keyby)\r\n[keys](#method-keys)\r\n[last](#method-last)\r\n[macro](#method-macro)\r\n[make](#method-make)\r\n[map](#method-map)\r\n[mapInto](#method-mapinto)\r\n[mapSpread](#method-mapspread)\r\n[mapToGroups](#method-maptogroups)\r\n[mapWithKeys](#method-mapwithkeys)\r\n[max](#method-max)\r\n[median](#method-median)\r\n[merge](#method-merge)\r\n[mergeRecursive](#method-mergerecursive)\r\n[min](#method-min)\r\n[mode](#method-mode)\r\n[nth](#method-nth)\r\n[only](#method-only)\r\n[pad](#method-pad)\r\n[partition](#method-partition)\r\n[pipe](#method-pipe)\r\n[pluck](#method-pluck)\r\n[random](#method-random)\r\n[reduce](#method-reduce)\r\n[reject](#method-reject)\r\n[replace](#method-replace)\r\n[replaceRecursive](#method-replacerecursive)\r\n[reverse](#method-reverse)\r\n[search](#method-search)\r\n[shuffle](#method-shuffle)\r\n[skip](#method-skip)\r\n[slice](#method-slice)\r\n[sole](#method-sole)\r\n[some](#method-some)\r\n[sort](#method-sort)\r\n[sortBy](#method-sortby)\r\n[sortByDesc](#method-sortbydesc)\r\n[sortKeys](#method-sortkeys)\r\n[sortKeysDesc](#method-sortkeysdesc)\r\n[split](#method-split)\r\n[sum](#method-sum)\r\n[take](#method-take)\r\n[tap](#method-tap)\r\n[times](#method-times)\r\n[toArray](#method-toarray)\r\n[toJson](#method-tojson)\r\n[union](#method-union)\r\n[unique](#method-unique)\r\n[uniqueStrict](#method-uniquestrict)\r\n[unless](#method-unless)\r\n[unlessEmpty](#method-unlessempty)\r\n[unlessNotEmpty](#method-unlessnotempty)\r\n[unwrap](#method-unwrap)\r\n[values](#method-values)\r\n[when](#method-when)\r\n[whenEmpty](#method-whenempty)\r\n[whenNotEmpty](#method-whennotempty)\r\n[where](#method-where)\r\n[whereStrict](#method-wherestrict)\r\n[whereBetween](#method-wherebetween)\r\n[whereIn](#method-wherein)\r\n[whereInStrict](#method-whereinstrict)\r\n[whereInstanceOf](#method-whereinstanceof)\r\n[whereNotBetween](#method-wherenotbetween)\r\n[whereNotIn](#method-wherenotin)\r\n[whereNotInStrict](#method-wherenotinstrict)\r\n[wrap](#method-wrap)\r\n[zip](#method-zip)\r\n\r\n</div>\r\n\r\n> **注意：**改变集合的方法（例如 `shift`、`pop`、`prepend` 等）在 `LazyCollection` 类中**不**可用。\r\n\r\n\r\n<a name=\"lazy-collection-methods\"></a>\r\n### 惰性集合方法\r\n\r\n除了在 `Enumerable` 契约中定义的方法外， `LazyCollection` 类还包含以下方法：\r\n\r\n<a name=\"method-takeUntilTimeout\"></a>\r\n#### `takeUntilTimeout()` {.collection-method}\r\n\r\n`takeUntilTimeout` 方法返回新的惰性集合，它会在给定时间前去枚举集合值，之后集合将停止枚举：\r\n\r\n    $lazyCollection = LazyCollection::times(INF)\r\n        ->takeUntilTimeout(now()->addMinute());\r\n\r\n    $lazyCollection->each(function (int $number) {\r\n        dump($number);\r\n\r\n        sleep(1);\r\n    });\r\n\r\n    // 1\r\n    // 2\r\n    // ...\r\n    // 58\r\n    // 59\r\n\r\n为了具体阐述此方法，请设想一个使用游标从数据库提交发票的例子。你可以定义一个 [计划任务](/docs/laravel/10.x/scheduling)，它每十五分钟执行一次，并且只执行发票提交操作的最大时间是 14 分钟：\r\n\r\n    use App\\Models\\Invoice;\r\n    use Illuminate\\Support\\Carbon;\r\n\r\n    Invoice::pending()->cursor()\r\n        ->takeUntilTimeout(\r\n            Carbon::createFromTimestamp(LARAVEL_START)->add(14, 'minutes')\r\n        )\r\n        ->each(fn (Invoice $invoice) => $invoice->submit());\r\n\r\n<a name=\"method-tapEach\"></a>\r\n#### `tapEach()` {.collection-method}\r\n\r\n当 `each` 方法为集合中每一个元素调用给定回调时， `tapEach` 方法仅调用给定回调，因为这些元素正在逐个从列表中拉出：\r\n\r\n    // 没有任何输出\r\n    $lazyCollection = LazyCollection::times(INF)->tapEach(function (int $value) {\r\n        dump($value);\r\n    });\r\n\r\n    // 打印出三条数据\r\n    $array = $lazyCollection->take(3)->all();\r\n\r\n    // 1\r\n    // 2\r\n    // 3\r\n\r\n<a name=\"method-remember\"></a>\r\n#### `remember()` {.collection-method}\r\n\r\n`remember` 方法返回一个新的惰性集合，这个集合已经记住（缓存）已枚举的所有值，当再次枚举该集合时不会获取它们：\r\n\r\n    // 没执行任何查询\r\n    $users = User::cursor()->remember();\r\n\r\n    //  执行了查询操作\r\n    // The first 5 users are hydrated from the database...\r\n    $users->take(5)->all();\r\n\r\n    // 前 5 个用户数据从缓存中获取\r\n    // The rest are hydrated from the database...\r\n    $users->take(20)->all();\r\n\r\n","p":"docs/collections.html"},{"t":"contracts (契约（Contract）)","d":"\n# 契约（Contract）\r\n\r\n- [简介](#introduction)\r\n    - [Contract 对比 Facade](#contracts-vs-facades)\r\n- [何时使用 Contract](#when-to-use-contracts)\r\n- [如何使用 Contract](#how-to-use-contracts)\r\n- [Contract 参考](#contract-reference)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 的「契约（Contract）」是一组接口，它们定义由框架提供的核心服务。例如，`illuste\\Contracts\\Queue\\Queue` Contract 定义了队列所需的方法，而 `illuste\\Contracts\\Mail\\Mailer` Contract 定义了发送邮件所需的方法。\r\n\r\n每个契约都有由框架提供的相应实现。例如，Laravel 提供了一个支持各种驱动的队列实现，还有一个由 [SwiftMailer](https://symfony.com/doc/6.0/mailer.html) 提供支持的邮件程序实现等等。\r\n\r\n所有的 Laravel Contract 都存在于它们各自的 [GitHub 仓库](https://github.com/illuminate/contracts)。这为所有可用的契约提供了一个快速的参考点，以及一个可以被包开发人员使用的独立的包。\r\n\r\n<a name=\"contracts-vs-facades\"></a>\r\n### Contract 对比 Facade\r\n\r\nLaravel 的 [Facade](/docs/laravel/10.x/facades) 和辅助函数提供了一种利用 Laravel 服务的简单方法，无需类型提示并可以从服务容器中解析 Contract。在大多数情况下，每个 Facade 都有一个等效的 Contract。\r\n\r\n和 Facade（不需要在构造函数中引入）不同，Contract 允许你为类定义显式依赖关系。一些开发者更喜欢以这种方式显式定义其依赖项，所以更喜欢使用 Contract，而其他开发者则享受 Facade 带来的便利。**通常，大多数应用都可以在开发过程中使用 Facade。**\r\n\n\n<a name=\"when-to-use-contracts\"></a>\r\n## 何时使用 Contract\r\n\r\n使用 Contract 或 Facades 取决于个人喜好和开发团队的喜好。Contract 和 Facade 均可用于创建功能强大且经过良好测试的 Laravel 应用。Contract 和 Facade 并不是一道单选题，你可以在同一个应用内同时使用 Contract 和 Facade。只要聚焦在类的职责应该单一上，你会发现 Contract 和 Facade 的实际差异其实很小。\r\n\r\n通常情况下，大部分使用 Facade 的应用都不会在开发中遇到问题。但如果你在建立一个可以由多个 PHP 框架使用的扩展包，你可能会希望使用 `illuminate/contracts` 扩展包来定义该包和 Laravel 集成，而不需要引入完整的 Laravel 实现（不需要在 `composer.json` 中具体显式引入 Laravel 框架来实现）。\r\n\r\n<a name=\"how-to-use-contracts\"></a>\r\n## 如何使用 Contract\r\n\r\n那么，如何实现契约呢？它其实很简单。\r\n\r\nLaravel 中的许多类都是通过 [服务容器](https://learnku.com/docs/Laravel/10.x/container) 解析的，包括控制器、事件侦听器、中间件、队列任务，甚至路由闭包。因此，要实现契约，你只需要在被解析的类的构造函数中「类型提示」接口。\r\n\r\n例如，看看下面的这个事件监听器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderWasPlaced;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Contracts\\Redis\\Factory;\r\n\r\n    class CacheOrderInformation\r\n    {\r\n        /**\r\n         * 创建一个新的事件监听器实例\r\n         */\r\n        public function __construct(\r\n            protected Factory $redis,\r\n        ) {}\r\n\r\n        /**\r\n         * 处理该事件。\r\n         */\r\n        public function handle(OrderWasPlaced $event): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n\n\n当解析事件监听器时，服务容器将读取构造函数上的类型提示，并注入适当的值。 要了解更多有关在服务容器中注册内容的信息，请查看 [其文档](/docs/laravel/10.x/container)。\r\n\r\n<a name=\"contract-reference\"></a>\r\n## Contract 参考\r\n\r\n下表提供了所有 Laravel Contract 及对应的 Facade 的快速参考：\r\n\r\n| Contract                                                                                                                                               | 对应的 Facade               |\r\n|--------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------|\r\n| [Illuminate\\Contracts\\Auth\\Access\\Authorizable](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/Access/Authorizable.php)                 |  &nbsp;                   |\r\n| [Illuminate\\Contracts\\Auth\\Access\\Gate](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/Access/Gate.php)                                 | `Gate`                    |\r\n| [Illuminate\\Contracts\\Auth\\Authenticatable](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/Authenticatable.php)                         |  &nbsp;                   |\r\n| [Illuminate\\Contracts\\Auth\\CanResetPassword](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/CanResetPassword.php)                       | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Auth\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/Factory.php)                                         | `Auth`                    |\r\n| [Illuminate\\Contracts\\Auth\\Guard](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/Guard.php)                                             | `Auth::guard()`           |\r\n| [Illuminate\\Contracts\\Auth\\PasswordBroker](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/PasswordBroker.php)                           | `Password::broker()`      |\r\n| [Illuminate\\Contracts\\Auth\\PasswordBrokerFactory](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/PasswordBrokerFactory.php)             | `Password`                |\r\n| [Illuminate\\Contracts\\Auth\\StatefulGuard](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/StatefulGuard.php)                             | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Auth\\SupportsBasicAuth](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/SupportsBasicAuth.php)                     | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Auth\\UserProvider](https://github.com/illuminate/contracts/blob/laravel/10.x/Auth/UserProvider.php)                               | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Bus\\Dispatcher](https://github.com/illuminate/contracts/blob/laravel/10.x/Bus/Dispatcher.php)                                     | `Bus`                     |\r\n| [Illuminate\\Contracts\\Bus\\QueueingDispatcher](https://github.com/illuminate/contracts/blob/laravel/10.x/Bus/QueueingDispatcher.php)                     | `Bus::dispatchToQueue()`  |\r\n| [Illuminate\\Contracts\\Broadcasting\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Broadcasting/Factory.php)                         | `Broadcast`               |\r\n| [Illuminate\\Contracts\\Broadcasting\\Broadcaster](https://github.com/illuminate/contracts/blob/laravel/10.x/Broadcasting/Broadcaster.php)                 | `Broadcast::connection()` |\r\n| [Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast](https://github.com/illuminate/contracts/blob/laravel/10.x/Broadcasting/ShouldBroadcast.php)         | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow](https://github.com/illuminate/contracts/blob/laravel/10.x/Broadcasting/ShouldBroadcastNow.php)   | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Cache\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Cache/Factory.php)                                       | `Cache`                   |\r\n| [Illuminate\\Contracts\\Cache\\Lock](https://github.com/illuminate/contracts/blob/laravel/10.x/Cache/Lock.php)                                             | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Cache\\LockProvider](https://github.com/illuminate/contracts/blob/laravel/10.x/Cache/LockProvider.php)                             | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Cache\\Repository](https://github.com/illuminate/contracts/blob/laravel/10.x/Cache/Repository.php)                                 | `Cache::driver()`         |\r\n| [Illuminate\\Contracts\\Cache\\Store](https://github.com/illuminate/contracts/blob/laravel/10.x/Cache/Store.php)                                           | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Config\\Repository](https://github.com/illuminate/contracts/blob/laravel/10.x/Config/Repository.php)                               | `Config`                  |\r\n| [Illuminate\\Contracts\\Console\\Application](https://github.com/illuminate/contracts/blob/laravel/10.x/Console/Application.php)                           | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Console\\Kernel](https://github.com/illuminate/contracts/blob/laravel/10.x/Console/Kernel.php)                                     | `Artisan`                 |\r\n| [Illuminate\\Contracts\\Container\\Container](https://github.com/illuminate/contracts/blob/laravel/10.x/Container/Container.php)                           | `App`                     |\r\n| [Illuminate\\Contracts\\Cookie\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Cookie/Factory.php)                                     | `Cookie`                  |\r\n| [Illuminate\\Contracts\\Cookie\\QueueingFactory](https://github.com/illuminate/contracts/blob/laravel/10.x/Cookie/QueueingFactory.php)                     | `Cookie::queue()`         |\r\n| [Illuminate\\Contracts\\Database\\ModelIdentifier](https://github.com/illuminate/contracts/blob/laravel/10.x/Database/ModelIdentifier.php)                 | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Debug\\ExceptionHandler](https://github.com/illuminate/contracts/blob/laravel/10.x/Debug/ExceptionHandler.php)                     | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Encryption\\Encrypter](https://github.com/illuminate/contracts/blob/laravel/10.x/Encryption/Encrypter.php)                         | `Crypt`                   |\r\n| [Illuminate\\Contracts\\Events\\Dispatcher](https://github.com/illuminate/contracts/blob/laravel/10.x/Events/Dispatcher.php)                               | `Event`                   |\r\n| [Illuminate\\Contracts\\Filesystem\\Cloud](https://github.com/illuminate/contracts/blob/laravel/10.x/Filesystem/Cloud.php)                                 | `Storage::cloud()`        |\r\n| [Illuminate\\Contracts\\Filesystem\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Filesystem/Factory.php)                             | `Storage`                 |\r\n| [Illuminate\\Contracts\\Filesystem\\Filesystem](https://github.com/illuminate/contracts/blob/laravel/10.x/Filesystem/Filesystem.php)                       | `Storage::disk()`         |\r\n| [Illuminate\\Contracts\\Foundation\\Application](https://github.com/illuminate/contracts/blob/laravel/10.x/Foundation/Application.php)                     | `App`                     |\r\n| [Illuminate\\Contracts\\Hashing\\Hasher](https://github.com/illuminate/contracts/blob/laravel/10.x/Hashing/Hasher.php)                                     | `Hash`                    |\r\n| [Illuminate\\Contracts\\Http\\Kernel](https://github.com/illuminate/contracts/blob/laravel/10.x/Http/Kernel.php)                                           | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Mail\\MailQueue](https://github.com/illuminate/contracts/blob/laravel/10.x/Mail/MailQueue.php)                                     | `Mail::queue()`           |\r\n| [Illuminate\\Contracts\\Mail\\Mailable](https://github.com/illuminate/contracts/blob/laravel/10.x/Mail/Mailable.php)                                       | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Mail\\Mailer](https://github.com/illuminate/contracts/blob/laravel/10.x/Mail/Mailer.php)                                           | `Mail`                    |\r\n| [Illuminate\\Contracts\\Notifications\\Dispatcher](https://github.com/illuminate/contracts/blob/laravel/10.x/Notifications/Dispatcher.php)                 | `Notification`            |\r\n| [Illuminate\\Contracts\\Notifications\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Notifications/Factory.php)                       | `Notification`            |\r\n| [Illuminate\\Contracts\\Pagination\\LengthAwarePaginator](https://github.com/illuminate/contracts/blob/laravel/10.x/Pagination/LengthAwarePaginator.php)   | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Pagination\\Paginator](https://github.com/illuminate/contracts/blob/laravel/10.x/Pagination/Paginator.php)                         | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Pipeline\\Hub](https://github.com/illuminate/contracts/blob/laravel/10.x/Pipeline/Hub.php)                                         | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Pipeline\\Pipeline](https://github.com/illuminate/contracts/blob/laravel/10.x/Pipeline/Pipeline.php)                               | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Queue\\EntityResolver](https://github.com/illuminate/contracts/blob/laravel/10.x/Queue/EntityResolver.php)                         | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Queue\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Queue/Factory.php)                                       | `Queue`                   |\r\n| [Illuminate\\Contracts\\Queue\\Job](https://github.com/illuminate/contracts/blob/laravel/10.x/Queue/Job.php)                                               | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Queue\\Monitor](https://github.com/illuminate/contracts/blob/laravel/10.x/Queue/Monitor.php)                                       | `Queue`                   |\r\n| [Illuminate\\Contracts\\Queue\\Queue](https://github.com/illuminate/contracts/blob/laravel/10.x/Queue/Queue.php)                                           | `Queue::connection()`     |\r\n| [Illuminate\\Contracts\\Queue\\QueueableCollection](https://github.com/illuminate/contracts/blob/laravel/10.x/Queue/QueueableCollection.php)               | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Queue\\QueueableEntity](https://github.com/illuminate/contracts/blob/laravel/10.x/Queue/QueueableEntity.php)                       | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Queue\\ShouldQueue](https://github.com/illuminate/contracts/blob/laravel/10.x/Queue/ShouldQueue.php)                               | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Redis\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Redis/Factory.php)                                       | `Redis`                   |\r\n| [Illuminate\\Contracts\\Routing\\BindingRegistrar](https://github.com/illuminate/contracts/blob/laravel/10.x/Routing/BindingRegistrar.php)                 | `Route`                   |\r\n| [Illuminate\\Contracts\\Routing\\Registrar](https://github.com/illuminate/contracts/blob/laravel/10.x/Routing/Registrar.php)                               | `Route`                   |\r\n| [Illuminate\\Contracts\\Routing\\ResponseFactory](https://github.com/illuminate/contracts/blob/laravel/10.x/Routing/ResponseFactory.php)                   | `Response`                |\r\n| [Illuminate\\Contracts\\Routing\\UrlGenerator](https://github.com/illuminate/contracts/blob/laravel/10.x/Routing/UrlGenerator.php)                         | `URL`                     |\r\n| [Illuminate\\Contracts\\Routing\\UrlRoutable](https://github.com/illuminate/contracts/blob/laravel/10.x/Routing/UrlRoutable.php)                           | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Session\\Session](https://github.com/illuminate/contracts/blob/laravel/10.x/Session/Session.php)                                   | `Session::driver()`       |\r\n| [Illuminate\\Contracts\\Support\\Arrayable](https://github.com/illuminate/contracts/blob/laravel/10.x/Support/Arrayable.php)                               | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Support\\Htmlable](https://github.com/illuminate/contracts/blob/laravel/10.x/Support/Htmlable.php)                                 | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Support\\Jsonable](https://github.com/illuminate/contracts/blob/laravel/10.x/Support/Jsonable.php)                                 | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Support\\MessageBag](https://github.com/illuminate/contracts/blob/laravel/10.x/Support/MessageBag.php)                             | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Support\\MessageProvider](https://github.com/illuminate/contracts/blob/laravel/10.x/Support/MessageProvider.php)                   | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Support\\Renderable](https://github.com/illuminate/contracts/blob/laravel/10.x/Support/Renderable.php)                             | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Support\\Responsable](https://github.com/illuminate/contracts/blob/laravel/10.x/Support/Responsable.php)                           | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Translation\\Loader](https://github.com/illuminate/contracts/blob/laravel/10.x/Translation/Loader.php)                             | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Translation\\Translator](https://github.com/illuminate/contracts/blob/laravel/10.x/Translation/Translator.php)                     | `Lang`                    |\r\n| [Illuminate\\Contracts\\Validation\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/Validation/Factory.php)                             | `Validator`               |\r\n| [Illuminate\\Contracts\\Validation\\ImplicitRule](https://github.com/illuminate/contracts/blob/laravel/10.x/Validation/ImplicitRule.php)                   | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Validation\\Rule](https://github.com/illuminate/contracts/blob/laravel/10.x/Validation/Rule.php)                                   | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Validation\\ValidatesWhenResolved](https://github.com/illuminate/contracts/blob/laravel/10.x/Validation/ValidatesWhenResolved.php) | &nbsp;                    |\r\n| [Illuminate\\Contracts\\Validation\\Validator](https://github.com/illuminate/contracts/blob/laravel/10.x/Validation/Validator.php)                         | `Validator::make()`       |\r\n| [Illuminate\\Contracts\\View\\Engine](https://github.com/illuminate/contracts/blob/laravel/10.x/View/Engine.php)                                           | &nbsp;                    |\r\n| [Illuminate\\Contracts\\View\\Factory](https://github.com/illuminate/contracts/blob/laravel/10.x/View/Factory.php)                                         | `View`                    |\r\n| [Illuminate\\Contracts\\View\\View](https://github.com/illuminate/contracts/blob/laravel/10.x/View/View.php)                                               | `View::make()`            |\r\n\n","p":"docs/contracts.html"},{"t":"events (事件系统)","d":"# 事件系统\r\n- [介绍](#introduction)\r\n- [注册事件和监听器](#registering-events-and-listeners)\r\n    - [生成事件和监听器](#generating-events-and-listeners)\r\n    - [手动注册事件](#manually-registering-events)\r\n    - [事件发现](#event-discovery)\r\n- [定义事件](#defining-events)\r\n- [定义监听器](#defining-listeners)\r\n- [队列事件监听器](#queued-event-listeners)\r\n    - [手动与队列交互](#manually-interacting-with-the-queue)\r\n    - [队列事件监听器和数据库事务](#queued-event-listeners-and-database-transactions)\r\n    - [处理失败的队列](#handling-failed-jobs)\r\n- [调度事件](#dispatching-events)\r\n- [事件订阅者](#event-subscribers)\r\n    - [编写事件订阅者](#writing-event-subscribers)\r\n    - [注册事件订阅者](#registering-event-subscribers)\r\n- [测试](#testing)\r\n    - [模拟一部分事件](#faking-a-subset-of-events)\r\n    - [作用域事件模拟](#scoped-event-fakes)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 的事件系统提供了一个简单的观察者模式的实现，允许你能够订阅和监听在你的应用中的发生的各种事件。事件类一般来说存储在 `app/Events` 目录，监听者的类存储在 `app/Listeners` 目录。不要担心在你的应用中没有看到这两个目录，因为通过 Artisan 命令行来创建事件和监听者的时候目录会同时被创建。\r\n\r\n事件系统可以作为一个非常棒的方式来解耦你的系统的方方面面，因为一个事件可以有多个完全不相关的监听者。例如，你希望每当有订单发出的时候都给你发送一个 Slack 通知。你大可不必将你的处理订单的代码和发送 slack 消息的代码放在一起，你只需要触发一个 App\\Events\\OrderShipped 事件，然后事件监听者可以收到这个事件然后发送 slack 通知\r\n\r\n<a name=\"registering-events-and-listeners\"></a>\r\n## 注册事件和监听器\r\n\r\n在系统的服务提供者 `App\\Providers\\EventServiceProvider` 中提供了一个简单的方式来注册你所有的事件监听者。属性 `listen` 包含所有的事件 (作为键) 和对应的监听器 (值)。你可以添加任意多系统需要的监听器在这个数组中，让我们添加一个 `OrderShipped` 事件：\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use App\\Listeners\\SendShipmentNotification;\r\n\r\n    /**\r\n     * 系统中的事件和监听器的对应关系。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        OrderShipped::class => [\r\n            SendShipmentNotification::class,\r\n        ],\r\n    ];\r\n\r\n> **注意**\r\n> 可以使用 `event:list` 命令显示应用程序\r\n\r\n\r\n<a name=\"generating-events-and-listeners\"></a>\r\n### 生成事件和监听器\r\n\r\n当然，为每个事件和监听器手动创建文件是很麻烦的。相反，将监听器和事件添加到 `EventServiceProvider` 并使用 `event:generate` Artisan 命令。此命令将生成 `EventServiceProvider` 中列出的、尚不存在的任何事件或侦听器：\r\n\r\n```shell\r\nphp artisan event:generate\r\n```\r\n\r\n或者，你可以使用 `make:event` 以及 `make:listener` 用于生成单个事件和监听器的 Artisan 命令：\r\n\r\n```shell\r\nphp artisan make:event PodcastProcessed\r\n\r\nphp artisan make:listener SendPodcastNotification --event=PodcastProcessed\r\n```\r\n\r\n<a name=\"manually-registering-events\"></a>\r\n### 手动注册事件\r\n\r\n通常，事件应该通过 `EventServiceProvider` `$listen` 数组注册；但是，你也可以在 `EventServiceProvider` 的 `boot` 方法中手动注册基于类或闭包的事件监听器：\r\n\r\n    use App\\Events\\PodcastProcessed;\r\n    use App\\Listeners\\SendPodcastNotification;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n\r\n    /**\r\n     * 注册任意的其他事件和监听器。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Event::listen(\r\n            PodcastProcessed::class,\r\n            [SendPodcastNotification::class, 'handle']\r\n        );\r\n\r\n        Event::listen(function (PodcastProcessed $event) {\r\n            // ...\r\n        });\r\n    }\r\n\r\n<a name=\"queuable-anonymous-event-listeners\"></a>\r\n#### 可排队匿名事件监听器\r\n\r\n手动注册基于闭包的事件监听器时，可以将监听器闭包包装在 `Illuminate\\Events\\queueable` 函数中，以指示 Laravel 使用 [队列](/docs/laravel/10.x/queues) 执行侦听器：\r\n\r\n    use App\\Events\\PodcastProcessed;\r\n    use function Illuminate\\Events\\queueable;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n\r\n    /**\r\n     * 注册任意的其他事件和监听器。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Event::listen(queueable(function (PodcastProcessed $event) {\r\n            // ...\r\n        }));\r\n    }\r\n\r\n与队列任务一样，可以使用 `onConnection`、`onQueue` 和 `delay` 方法自定义队列监听器的执行：\r\n\r\n    Event::listen(queueable(function (PodcastProcessed $event) {\r\n        // ...\r\n    })->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));\r\n\r\n\r\n\r\n如果你想处理匿名队列监听器失败，你可以在定义 `queueable` 监听器时为 `catch` 方法提供一个闭包。这个闭包将接收导致监听器失败的事件实例和 `Throwable` 实例：\r\n\r\n    use App\\Events\\PodcastProcessed;\r\n    use function Illuminate\\Events\\queueable;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n    use Throwable;\r\n\r\n    Event::listen(queueable(function (PodcastProcessed $event) {\r\n        // ...\r\n    })->catch(function (PodcastProcessed $event, Throwable $e) {\r\n        // 队列监听器失败了\r\n    }));\r\n\r\n<a name=\"wildcard-event-listeners\"></a>\r\n#### 通配符事件监听器\r\n\r\n你甚至可以使用 `*` 作为通配符参数注册监听器，这允许你在同一个监听器上捕获多个事件。通配符监听器接收事件名作为其第一个参数，整个事件数据数组作为其第二个参数：\r\n\r\n    Event::listen('event.*', function (string $eventName, array $data) {\r\n        // ...\r\n    });\r\n\r\n<a name=\"event-discovery\"></a>\r\n### 事件的发现\r\n\r\n你可以启用自动事件发现，而不是在 `EventServiceProvider` 的 `$listen` 数组中手动注册事件和侦听器。当事件发现启用，Laravel 将自动发现和注册你的事件和监听器扫描你的应用程序的 `Listeners` 目录。此外，在 `EventServiceProvider` 中列出的任何显式定义的事件仍将被注册。\r\n\r\nLaravel 通过使用 PHP 的反射服务扫描监听器类来查找事件监听器。当 Laravel 发现任何以 `handle` 或 `__invoke` 开头的监听器类方法时，Laravel 会将这些方法注册为该方法签名中类型暗示的事件的事件监听器：\r\n\r\n    use App\\Events\\PodcastProcessed;\r\n\r\n    class SendPodcastNotification\r\n    {\r\n        /**\r\n         * 处理给定的事件\r\n         */\r\n        public function handle(PodcastProcessed $event): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n\r\n\r\n事件发现在默认情况下是禁用的，但你可以通过重写应用程序的 `EventServiceProvider` 的 `shouldDiscoverEvents` 方法来启用它：\r\n\r\n    /**\r\n     * 确定是否应用自动发现事件和监听器。\r\n     */\r\n    public function shouldDiscoverEvents(): bool\r\n    {\r\n        return true;\r\n    }\r\n\r\n默认情况下，应用程序 `app/listeners` 目录中的所有监听器都将被扫描。如果你想要定义更多的目录来扫描，你可以重写 `EventServiceProvider` 中的 `discoverEventsWithin` 方法：\r\n\r\n    /**\r\n     * 获取应用于发现事件的监听器目录。\r\n     *\r\n     * @return array<int, string>\r\n     */\r\n    protected function discoverEventsWithin(): array\r\n    {\r\n        return [\r\n            $this->app->path('Listeners'),\r\n        ];\r\n    }\r\n\r\n<a name=\"event-discovery-in-production\"></a>\r\n#### 生产中的事件发现\r\n\r\n在生产环境中，框架在每个请求上扫描所有监听器的效率并不高。因此，在你的部署过程中，你应该运行 `event:cache` Artisan 命令来缓存你的应用程序的所有事件和监听器清单。框架将使用该清单来加速事件注册过程。`event:clear` 命令可以用来销毁缓存。\r\n\r\n<a name=\"defining-events\"></a>\r\n## 定义事件\r\n\r\n事件类本质上是一个数据容器，它保存与事件相关的信息。例如，让我们假设一个 `App\\Events\\OrderShipped` 事件接收到一个 [Eloquent ORM](/docs/laravel/10.x/eloquent) 对象：\r\n\r\n    <?php\r\n\r\n    namespace App\\Events;\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Broadcasting\\InteractsWithSockets;\r\n    use Illuminate\\Foundation\\Events\\Dispatchable;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipped\r\n    {\r\n        use Dispatchable, InteractsWithSockets, SerializesModels;\r\n\r\n        /**\r\n         * 创建一个新的事件实例。\r\n         */\r\n        public function __construct(\r\n            public Order $order,\r\n        ) {}\r\n    }\r\n\r\n如你所见，这个事件类不包含逻辑。它是一个被购买的 `App\\Models\\Order` 实例容器。 如果事件对象是使用 PHP 的 `SerializesModels` 函数序列化的，事件使用的 `SerializesModels` trait 将会优雅地序列化任何 Eloquent 模型，比如在使用 [队列侦听器](#queued-event-listeners)。\r\n\r\n\r\n<a name=\"defining-listeners\"></a>\r\n## 定义监听器\r\n\r\n接下来，让我们看一下示例事件的监听器。事件监听器在其 `handle` 方法中接收事件实例。Artisan 命令 `event:generate` 和 `make:listener` 会自动导入正确的事件类，并在 `handle` 方法上对事件进行类型提示。在 `handle` 方法中，你可以执行任何必要的操作来响应事件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n\r\n    class SendShipmentNotification\r\n    {\r\n        /**\r\n         * 创建事件监听器\r\n         */\r\n        public function __construct()\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 处理事件\r\n         */\r\n        public function handle(OrderShipped $event): void\r\n        {\r\n            // 使用 $event->order 来访问订单 ...\r\n        }\r\n    }\r\n\r\n> **技巧**\r\n> 事件监听器还可以在构造函数中加入任何依赖关系的类型提示。所有的事件监听器都是通过 Laravel 的 [服务容器](/docs/laravel/10.x/container) 解析的，因此所有的依赖都将会被自动注入。\r\n\r\n<a name=\"stopping-the-propagation-of-an-event\"></a>\r\n#### 停止事件传播\r\n\r\n有时，你可能希望停止将事件传播到其他监听器。你可以通过从监听器的 `handle` 方法中返回 `false` 来做到这一点。\r\n\r\n<a name=\"queued-event-listeners\"></a>\r\n## 队列事件监听器\r\n\r\n如果你的监听器要执行一个缓慢的任务，如发送电子邮件或进行 HTTP 请求，那么队列化监听器就很有用了。在使用队列监听器之前，请确保 [配置你的队列](/docs/laravel/10.x/queues) 并在你的服务器或本地开发环境中启动一个队列 worker。\r\n\r\n要指定监听器启动队列，请将 `ShouldQueue` 接口添加到监听器类。 由 Artisan 命令 `event:generate` 和 `make:listener` 生成的监听器已经将此接口导入当前命名空间，因此你可以直接使用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n就是这样！ 现在，当此监听器处理的事件被调度时，监听器将使用 Laravel 的 [队列系统](/docs/laravel/10.x/queues) 自动由事件调度器排队。 如果监听器被队列执行时没有抛出异常，队列中的任务处理完成后会自动删除。\r\n\r\n<a name=\"customizing-the-queue-connection-queue-name\"></a>\r\n#### 自定义队列连接和队列名称\r\n\r\n如果你想自定义事件监听器的队列连接、队列名称或队列延迟时间，可以在监听器类上定义 `$connection`、`$queue` 或 `$delay` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        /**\r\n         * 任务发送到的连接的名称。\r\n         *\r\n         * @var string|null\r\n         */\r\n        public $connection = 'sqs';\r\n\r\n        /**\r\n         * 任务发送到的队列的名称。\r\n         *\r\n         * @var string|null\r\n         */\r\n        public $queue = 'listeners';\r\n\r\n        /**\r\n         * 处理作业前的时间（秒）。\r\n         *\r\n         * @var int\r\n         */\r\n        public $delay = 60;\r\n    }\r\n\r\n如果你想在运行时定义监听器的队列连接或队列名称，可以在监听器上定义 `viaConnection` 或 `viaQueue` 方法：\r\n\r\n    /**\r\n     * 获取侦听器的队列连接的名称。\r\n     */\r\n    public function viaConnection(): string\r\n    {\r\n        return 'sqs';\r\n    }\r\n\r\n    /**\r\n     * 获取侦听器队列的名称。\r\n     */\r\n    public function viaQueue(): string\r\n    {\r\n        return 'listeners';\r\n    }\r\n\r\n<a name=\"conditionally-queueing-listeners\"></a>\r\n#### 有条件地队列监听器\r\n\r\n有时，你可能需要根据一些仅在运行时可用的数据来确定是否应将侦听器排队。 为此，可以将「shouldQueue」方法添加到侦听器以确定是否应将侦听器排队。 如果 `shouldQueue` 方法返回 `false`，监听器将不会被执行：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderCreated;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\n    class RewardGiftCard implements ShouldQueue\r\n    {\r\n        /**\r\n         * 奖励客户一张礼品卡。\r\n         */\r\n        public function handle(OrderCreated $event): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 确定侦听器是否应排队。\r\n         */\r\n        public function shouldQueue(OrderCreated $event): bool\r\n        {\r\n            return $event->order->subtotal >= 5000;\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"manually-interacting-with-the-queue\"></a>\r\n### 手动与队列交互\r\n\r\n如果你需要手动访问侦听器的底层队列作业的 delete 和 release 方法，可以使用 `Illuminate\\Queue\\InteractsWithQueue` 特性来实现。 这个 trait 默认导入生成的侦听器并提供对这些方法的访问：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue;\r\n\r\n        /**\r\n         * Handle the event.\r\n         */\r\n        public function handle(OrderShipped $event): void\r\n        {\r\n            if (true) {\r\n                $this->release(30);\r\n            }\r\n        }\r\n    }\r\n\r\n<a name=\"queued-event-listeners-and-database-transactions\"></a>\r\n### 队列事件监听器和数据库事务\r\n\r\n当排队的侦听器在数据库事务中被分派时，它们可能在数据库事务提交之前由队列处理。 发生这种情况时，在数据库事务期间对模型或数据库记录所做的任何更新可能尚未反映在数据库中。 此外，在事务中创建的任何模型或数据库记录可能不存在于数据库中。 如果你的侦听器依赖于这些模型，则在处理调度排队侦听器的作业时可能会发生意外错误。\r\n\r\n如果你的队列连接的 `after_commit` 配置选项设置为 `false`，你仍然可以通过在侦听器类上定义 `$afterCommit` 属性来指示在提交所有打开的数据库事务后应该调度特定的排队侦听器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue;\r\n\r\n        public $afterCommit = true;\r\n    }\r\n\r\n> **注意**\r\n> 要了解有关解决这些问题的更多信息，请查看有关[队列作业和数据库事务](/docs/laravel/10.x/queuesmd#jobs-and-database-transactions) 的文档。\r\n\r\n\r\n\r\n<a name=\"handling-failed-jobs\"></a>\r\n### 处理失败的队列\r\n\r\n有时队列的事件监听器可能会失败。如果排队的监听器超过了队列工作者定义的最大尝试次数，则将对监听器调用 `failed` 方法。`failed` 方法接收导致失败的事件实例和 `Throwable`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Throwable;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue;\r\n\r\n        /**\r\n         * 事件处理。\r\n         */\r\n        public function handle(OrderShipped $event): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 处理失败任务。\r\n         */\r\n        public function failed(OrderShipped $event, Throwable $exception): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n<a name=\"specifying-queued-listener-maximum-attempts\"></a>\r\n#### 指定队列监听器的最大尝试次数\r\n\r\n如果队列中的某个监听器遇到错误，你可能不希望它无限期地重试。因此，Laravel 提供了各种方法来指定监听器的尝试次数或尝试时间。\r\n\r\n你可以在监听器类上定义 `$tries` 属性，以指定监听器在被认为失败之前可能尝试了多少次：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n\r\n    class SendShipmentNotification implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue;\r\n\r\n        /**\r\n         * 尝试队列监听器的次数。\r\n         *\r\n         * @var int\r\n         */\r\n        public $tries = 5;\r\n    }\r\n\r\n作为定义侦听器在失败之前可以尝试多少次的替代方法，你可以定义不再尝试侦听器的时间。这允许在给定的时间范围内尝试多次监听。若要定义不再尝试监听器的时间，请在你的监听器类中添加 `retryUntil` 方法。此方法应返回一个 `DateTime` 实例：\r\n\r\n    use DateTime;\r\n\r\n    /**\r\n     * 确定监听器应该超时的时间。\r\n     */\r\n    public function retryUntil(): DateTime\r\n    {\r\n        return now()->addMinutes(5);\r\n    }\r\n\r\n\r\n\r\n<a name=\"dispatching-events\"></a>\r\n## 调度事件\r\n\r\n要分派一个事件，你可以在事件上调用静态的 `dispatch` 方法。这个方法是通过 `Illuminate\\Foundation\\Events\\Dispatchable` 特性提供给事件的。 传递给 `dispatch` 方法的任何参数都将被传递给事件的构造函数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Events\\OrderShipped;\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class OrderShipmentController extends Controller\r\n    {\r\n        /**\r\n         * 运送给定的订单。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $order = Order::findOrFail($request->order_id);\r\n\r\n            // 订单出货逻辑...\r\n\r\n            OrderShipped::dispatch($order);\r\n\r\n            return redirect('/orders');\r\n        }\r\n    }\r\n\r\n你可以使用 `dispatchIf` 和 `dispatchUnless` 方法根据条件分派事件：\r\n\r\n    OrderShipped::dispatchIf($condition, $order);\r\n\r\n    OrderShipped::dispatchUnless($condition, $order);\r\n\r\n> **提示**  \r\n> 在测试时，断言某些事件是在没有实际触发其侦听器的情况下被分派的，这可能会有所帮助。 Laravel 的 [内置助手](#testing) 让它变得很简单。\r\n\r\n<a name=\"event-subscribers\"></a>\r\n## 事件订阅者\r\n\r\n<a name=\"writing-event-subscribers\"></a>\r\n### 构建事件订阅者\r\n\r\n事件订阅者是可以从订阅者类本身中订阅多个事件的类，允许你在单个类中定义多个事件处理程序。订阅者应该定义一个 `subscribe` 方法，它将被传递一个事件分派器实例。你可以在给定的分派器上调用 `listen` 方法来注册事件监听器：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Illuminate\\Auth\\Events\\Login;\r\n    use Illuminate\\Auth\\Events\\Logout;\r\n    use Illuminate\\Events\\Dispatcher;\r\n\r\n    class UserEventSubscriber\r\n    {\r\n        /**\r\n         * 处理用户登录事件。\r\n         */\r\n        public function handleUserLogin(string $event): void {}\r\n\r\n        /**\r\n         * 处理用户退出事件。\r\n         */\r\n        public function handleUserLogout(string $event): void {}\r\n\r\n        /**\r\n         * 为订阅者注册侦听器。\r\n         */\r\n        public function subscribe(Dispatcher $events): void\r\n        {\r\n            $events->listen(\r\n                Login::class,\r\n                [UserEventSubscriber::class, 'handleUserLogin']\r\n            );\r\n\r\n            $events->listen(\r\n                Logout::class,\r\n                [UserEventSubscriber::class, 'handleUserLogout']\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n\r\n如果你的事件侦听器方法是在订阅者本身中定义的，你可能会发现从订阅者的「订阅」方法返回一组事件和方法名称会更方便。 Laravel 会在注册事件监听器时自动判断订阅者的类名：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Illuminate\\Auth\\Events\\Login;\r\n    use Illuminate\\Auth\\Events\\Logout;\r\n    use Illuminate\\Events\\Dispatcher;\r\n\r\n    class UserEventSubscriber\r\n    {\r\n        /**\r\n         * 处理用户登录事件。\r\n         */\r\n        public function handleUserLogin(string $event): void {}\r\n\r\n        /**\r\n         * 处理用户注销事件。\r\n         */\r\n        public function handleUserLogout(string $event): void {}\r\n\r\n        /**\r\n         * 为订阅者注册监听器。\r\n         *\r\n         * @return array<string, string>\r\n         */\r\n        public function subscribe(Dispatcher $events): array\r\n        {\r\n            return [\r\n                Login::class => 'handleUserLogin',\r\n                Logout::class => 'handleUserLogout',\r\n            ];\r\n        }\r\n    }\r\n\r\n<a name=\"registering-event-subscribers\"></a>\r\n### 注册事件订阅者\r\n\r\n编写订阅者后，你就可以将其注册到事件调度程序。 可以使用 `EventServiceProvider` 上的 `$subscribe` 属性注册订阅者。 例如，让我们将 `UserEventSubscriber` 添加到列表中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Listeners\\UserEventSubscriber;\r\n    use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\n\r\n    class EventServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * The event listener mappings for the application.\r\n         *\r\n         * @var array\r\n         */\r\n        protected $listen = [\r\n            // ...\r\n        ];\r\n\r\n        /**\r\n         * The subscriber classes to register.\r\n         *\r\n         * @var array\r\n         */\r\n        protected $subscribe = [\r\n            UserEventSubscriber::class,\r\n        ];\r\n    }\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n当测试分发事件的代码时，你可能希望指示 Laravel 不要实际执行事件的监听器，因为监听器的代码可以直接和分发相应事件的代码分开测试。 当然，要测试监听器本身，你可以实例化一个监听器实例并直接在测试中调用 handle 方法。\r\n\r\n\r\n\r\n使用 `Event` 门面的 `fake` 方法，你可以阻止侦听器执行，执行测试代码，然后使用 `assertDispatched`、`assertNotDispatched` 和 `assertNothingDispatched` 方法断言你的应用程序分派了哪些事件：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Events\\OrderFailedToShip;\r\n    use App\\Events\\OrderShipped;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 测试订单发货。\r\n         */\r\n        public function test_orders_can_be_shipped(): void\r\n        {\r\n            Event::fake();\r\n\r\n            // 执行订单发货...\r\n\r\n            // 断言事件已发送...\r\n            Event::assertDispatched(OrderShipped::class);\r\n\r\n            // 断言一个事件被发送了两次......\r\n            Event::assertDispatched(OrderShipped::class, 2);\r\n\r\n            // 断言事件未被发送...\r\n            Event::assertNotDispatched(OrderFailedToShip::class);\r\n\r\n            // 断言没有事件被发送...\r\n            Event::assertNothingDispatched();\r\n        }\r\n    }\r\n\r\n你可以将闭包传递给 `assertDispatched` 或 `assertNotDispatched` 方法，以断言已派发的事件通过了给定的「真实性测试」。 如果至少发送了一个通过给定真值测试的事件，则断言将成功：\r\n\r\n    Event::assertDispatched(function (OrderShipped $event) use ($order) {\r\n        return $event->order->id === $order->id;\r\n    });\r\n\r\n如果你只想断言事件侦听器正在侦听给定事件，可以使用 `assertListening` 方法：\r\n\r\n    Event::assertListening(\r\n        OrderShipped::class,\r\n        SendShipmentNotification::class\r\n    );\r\n\r\n> **警告**\r\n> 调用 `Event::fake()` 后，不会执行任何事件侦听器。 因此，如果你的测试使用依赖于事件的模型工厂，例如在模型的「创建」事件期间创建 UUID，则您应该在使用您的工厂**之后**调用“Event::fake()”。\r\n\r\n<a name=\"faking-a-subset-of-events\"></a>\r\n### 伪造一部分事件\r\n\r\n如果你只想为一组特定的事件伪造事件监听器，你可以将它们传递给 `fake` 或 `fakeFor` 方法：\r\n\r\n    /**\r\n     * 测试订单流程。\r\n     */\r\n    public function test_orders_can_be_processed(): void\r\n    {\r\n        Event::fake([\r\n            OrderCreated::class,\r\n        ]);\r\n\r\n        $order = Order::factory()->create();\r\n\r\n        Event::assertDispatched(OrderCreated::class);\r\n\r\n        // 其他事件正常发送...\r\n        $order->update([...]);\r\n    }\r\n\r\n\r\n\r\n你可以使用 `except` 方法排除指定事件：\r\n\r\n    Event::fake()->except([\r\n        OrderCreated::class,\r\n    ]);\r\n\r\n<a name=\"scoped-event-fakes\"></a>\r\n### Fakes 作用域事件\r\n\r\n如果你只想为测试的一部分创建事件侦听器，你可以使用 `fakeFor` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Events\\OrderCreated;\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Support\\Facades\\Event;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 测试订单程序\r\n         */\r\n        public function test_orders_can_be_processed(): void\r\n        {\r\n            $order = Event::fakeFor(function () {\r\n                $order = Order::factory()->create();\r\n\r\n                Event::assertDispatched(OrderCreated::class);\r\n\r\n                return $order;\r\n            });\r\n\r\n            // 事件按正常方式调度，观察者将会运行...\r\n            $order->update([...]);\r\n        }\r\n    }\r\n\r\n","p":"docs/events.html"},{"t":"filesystem (文件存储)","d":"# 文件存储\r\n\r\n- [简介](#introduction)\r\n- [配置](#configuration)\r\n    - [本地驱动](#the-local-driver)\r\n    - [公共磁盘](#the-public-disk)\r\n    - [驱动先决要求](#driver-prerequisites)\r\n    - [分区和只读文件系统](#scoped-and-read-only-filesystems)\r\n    - [Amazon S3 兼容文件系统](#amazon-s3-compatible-filesystems)\r\n- [获取磁盘实例](#obtaining-disk-instances)\r\n    - [按需配置磁盘](#on-demand-disks)\r\n- [检索文件](#retrieving-files)\r\n    - [下载文件](#downloading-files)\r\n    - [文件 URL](#file-urls)\r\n    - [临时 URL](#temporary-urls)\r\n    - [文件元数据](#file-metadata)\r\n- [保存文件](#storing-files)\r\n    - [预置和附加文件](#prepending-appending-to-files)\r\n    - [复制和移动文件](#copying-moving-files)\r\n    - [自动流式传输](#automatic-streaming)\r\n    - [文件上传](#file-uploads)\r\n    - [文件可见性](#file-visibility)\r\n- [删除文件](#deleting-files)\r\n- [目录](#directories)\r\n- [测试](#testing)\r\n- [自定义文件系统](#custom-filesystems)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 提供了一个强大的文件系统抽象，这要感谢 Frank de Jonge 的 [Flysystem](https://github.com/thephpleague/flysystem) PHP 包。Laravel 的 Flysystem 集成提供了 简单的驱动来处理本地文件系统、SFTP 和 Amazon S3。更棒的是，在你的本地开发机器和生产服务器之间切换这些存储选项是非常简单的，因为每个系统的 API 都是一样的。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\nLaravel 的文件系统配置文件位于 `config/filesystems.php`。 在这个文件中，你可以配置你所有的文件系统「磁盘」。每个磁盘代表一个特定的存储驱动器和存储位置。 每种支持的驱动器的配置示例都包含在配置文件中, 因此你可以修改配置以反映你的存储偏好和证书。\r\n\r\n`local` 驱动用于与运行Laravel应用程序的服务器上存储的文件进行交互，而 `s3` 驱动用于写入 Amazon 的 S3 云存储服务。\r\n\r\n> **注意**\r\n> 你可以配置任意数量的磁盘，甚至可以添加多个使用相同驱动的磁盘。\r\n\r\n\r\n\r\n<a name=\"the-local-driver\"></a>\r\n### 本地驱动\r\n\r\n使用  `local` 驱动时，所有文件操作都与 `filesystems` 配置文件中定义的 `root` 目录相关。 默认情况下，此值设置为 `storage/app` 目录。因此，以下方法会把文件存储在 `storage/app/example.txt`中：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::disk('local')->put('example.txt', 'Contents');\r\n\r\n<a name=\"the-public-disk\"></a>\r\n### 公共磁盘\r\n\r\n在 `filesystems` 配置文件中定义的 `public` 磁盘适用于要公开访问的文件。默认情况下， `public` 磁盘使用 `local` 驱动，并且将这些文件存储在 `storage/app/public`目录下。\r\n\r\n要使这些文件可从 web 访问，应创建从 `public/storage` 到 `storage/app/public`的符号链接。这种方式能把可公开访问文件都保留在同一个目录下，以便在使用零停机时间部署系统如 [Envoyer](https://envoyer.io) 的时候，就可以轻松地在不同的部署之间共享这些文件。\r\n\r\n你可以使用 Artisan 命令 `storage:link` 来创建符号链接：\r\n\r\n```shell\r\nphp artisan storage:link\r\n```\r\n\r\n一旦一个文件被存储并且已经创建了符号链接，你就可以使用辅助函数 `asset` 来创建文件的 URL：\r\n\r\n    echo asset('storage/file.txt');\r\n\r\n你可以在 `filesystems` 配置文件中配置额外的符号链接。这些链接将会在运行 `storage:link` 命令时自动创建：\r\n\r\n    'links' => [\r\n        public_path('storage') => storage_path('app/public'),\r\n        public_path('images') => storage_path('app/images'),\r\n    ],\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n\r\n\r\n### 驱动先决要求\r\n\r\n<a name=\"s3-driver-configuration\"></a>\r\n#### S3 驱动配置\r\n\r\n在使用 S3 驱动之前，你需要通过 Composer 包管理器安装 Flysystem S3 软件包：\r\n\r\n```shell\r\ncomposer require league/flysystem-aws-s3-v3 \"^3.0\"\r\n```\r\n\r\nS3 驱动配置信息位于你的 `config/filesystems.php` 配置文件中。该文件包含一个 S3 驱动的示例配置数组。你可以自由使用自己的 S3 配置和凭证修改此数组。为方便起见，这些环境变量与 AWS CLI 使用的命名约定相匹配。\r\n\r\n<a name=\"ftp-driver-configuration\"></a>\r\n#### FTP 驱动配置\r\n\r\n在使用 FTP 驱动之前，你需要通过 Composer 包管理器安装 Flysystem FTP 包：\r\n\r\n```shell\r\ncomposer require league/flysystem-ftp \"^3.0\"\r\n```\r\n\r\nLaravel 的 Flysystem 能与 FTP 很好的适配；然而，框架的默认 `filesystems.php` 配置文件中并未包含示例配置。如果你需要配置 FTP 文件系统，可以使用下面的配置示例：\r\n\r\n    'ftp' => [\r\n        'driver' => 'ftp',\r\n        'host' => env('FTP_HOST'),\r\n        'username' => env('FTP_USERNAME'),\r\n        'password' => env('FTP_PASSWORD'),\r\n\r\n        // 可选的 FTP 设置...\r\n        // 'port' => env('FTP_PORT', 21),\r\n        // 'root' => env('FTP_ROOT'),\r\n        // 'passive' => true,\r\n        // 'ssl' => true,\r\n        // 'timeout' => 30,\r\n    ],\r\n\r\n<a name=\"sftp-driver-configuration\"></a>\r\n#### SFTP 驱动配置\r\n\r\n在使用 SFTP 驱动之前，你需要通过 Composer 包管理器安装 Flysystem SFTP 软件包。\r\n\r\n```shell\r\ncomposer require league/flysystem-sftp-v3 \"^3.0\"\r\n```\r\n\r\nLaravel 的 Flysystem 能与 SFTP 很好的适配；然而，框架默认的 `filesystems.php` 配置文件中并未包含示例配置。如果你需要配置 SFTP 文件系统，可以使用下面的配置示例：\r\n\r\n    'sftp' => [\r\n        'driver' => 'sftp',\r\n        'host' => env('SFTP_HOST'),\r\n\r\n        // 基本认证的设置...\r\n        'username' => env('SFTP_USERNAME'),\r\n        'password' => env('SFTP_PASSWORD'),\r\n\r\n        // 基于SSH密钥的认证与加密密码的设置...\r\n        'privateKey' => env('SFTP_PRIVATE_KEY'),\r\n        'passphrase' => env('SFTP_PASSPHRASE'),\r\n\r\n        // 可选的SFTP设置...\r\n        // 'hostFingerprint' => env('SFTP_HOST_FINGERPRINT'),\r\n        // 'maxTries' => 4,\r\n        // 'passphrase' => env('SFTP_PASSPHRASE'),\r\n        // 'port' => env('SFTP_PORT', 22),\r\n        // 'root' => env('SFTP_ROOT', ''),\r\n        // 'timeout' => 30,\r\n        // 'useAgent' => true,\r\n    ],\r\n\r\n\r\n\r\n### 驱动先决条件\r\n\r\n<a name=\"s3-driver-configuration\"></a>\r\n#### S3 驱动配置\r\n\r\n在使用 S3 驱动之前，你需要通过 Composer 安装 Flysystem S3 包：\r\n\r\n```shell\r\ncomposer require league/flysystem-aws-s3-v3 \"^3.0\"\r\n```\r\n\r\nS3 驱动配置信息位于你的 `config/filesystems.php` 配置文件中。 此文件包含 S3 驱动的示例配置数组。 你可以使用自己的 S3 配置和凭据自由修改此数组。 为方便起见，这些环境变量与 AWS CLI 使用的命名约定相匹配。\r\n\r\n<a name=\"ftp-driver-configuration\"></a>\r\n#### FTP 驱动配置\r\n\r\n在使用 FTP 驱动之前，你需要通过 Composer 安装 Flysystem FTP 包：\r\n\r\n```shell\r\ncomposer require league/flysystem-ftp \"^3.0\"\r\n```\r\n\r\nLaravel 的 Flysystem 集成与 FTP 配合得很好； 但是，框架的默认 `filesystems.php` 配置文件中不包含示例配置。 如果需要配置 FTP 文件系统，可以使用下面的配置示例：\r\n\r\n    'ftp' => [\r\n        'driver' => 'ftp',\r\n        'host' => env('FTP_HOST'),\r\n        'username' => env('FTP_USERNAME'),\r\n        'password' => env('FTP_PASSWORD'),\r\n\r\n        // 可选的 FTP 设置...\r\n        // 'port' => env('FTP_PORT', 21),\r\n        // 'root' => env('FTP_ROOT'),\r\n        // 'passive' => true,\r\n        // 'ssl' => true,\r\n        // 'timeout' => 30,\r\n    ],\r\n\r\n<a name=\"sftp-driver-configuration\"></a>\r\n#### SFTP 驱动配置\r\n\r\n在使用 SFTP 驱动之前，你需要通过 Composer 安装 Flysystem SFTP 包：\r\n\r\n```shell\r\ncomposer require league/flysystem-sftp-v3 \"^3.0\"\r\n```\r\n\r\nLaravel 的 Flysystem 集成与 SFTP 配合得很好； 但是，框架的默认 `filesystems.php` 配置文件中不包含示例配置。 如果你需要配置 SFTP 文件系统，可以使用下面的配置示例：\r\n\r\n    'sftp' => [\r\n        'driver' => 'sftp',\r\n        'host' => env('SFTP_HOST'),\r\n\r\n        // 基本身份验证设置...\r\n        'username' => env('SFTP_USERNAME'),\r\n        'password' => env('SFTP_PASSWORD'),\r\n\r\n        // 基于SSH密钥的加密密码认证设置…\r\n        'privateKey' => env('SFTP_PRIVATE_KEY'),\r\n        'passphrase' => env('SFTP_PASSPHRASE'),\r\n\r\n        // 可选的 SFTP 设置...\r\n        // 'hostFingerprint' => env('SFTP_HOST_FINGERPRINT'),\r\n        // 'maxTries' => 4,\r\n        // 'passphrase' => env('SFTP_PASSPHRASE'),\r\n        // 'port' => env('SFTP_PORT', 22),\r\n        // 'root' => env('SFTP_ROOT', ''),\r\n        // 'timeout' => 30,\r\n        // 'useAgent' => true,\r\n    ],\r\n\r\n\r\n\r\n<a name=\"scoped-and-read-only-filesystems\"></a>\r\n### 分区和只读文件系统\r\n\r\n分区磁盘允许你定义一个文件系统，其中所有的路径都自动带有给定的路径前缀。在创建一个分区文件系统磁盘之前，你需要通过 Composer 包管理器安装一个额外的 Flysystem 包：\r\n\r\n```shell\r\ncomposer require league/flysystem-path-prefixing \"^3.0\"\r\n```\r\n\r\n你可以通过定义一个使用 `scoped` 驱动的磁盘来创建任何现有文件系统磁盘的路径分区实例。例如，你可以创建一个磁盘，它将你现有的 `s3` 磁盘限定在特定的路径前缀上，然后使用你的分区磁盘进行的每个文件操作都将使用指定的前缀：\r\n\r\n```php\r\n's3-videos' => [\r\n    'driver' => 'scoped',\r\n    'disk' => 's3',\r\n    'prefix' => 'path/to/videos',\r\n],\r\n```\r\n\r\n「只读」磁盘允许你创建不允许写入操作的文件系统磁盘。在使用 `read-only` 配置选项之前，你需要通过 Composer 包管理器安装一个额外的 Flysystem 包：\r\n\r\n```shell\r\ncomposer require league/flysystem-read-only \"^3.0\"\r\n```\r\n\r\n接下来，你可以在一个或多个磁盘的配置数组中包含 `read-only` 配置选项：\r\n\r\n```php\r\n's3-videos' => [\r\n    'driver' => 's3',\r\n    // ...\r\n    'read-only' => true,\r\n],\r\n```\r\n\r\n<a name=\"amazon-s3-compatible-filesystems\"></a>\r\n### Amazon S3 兼容文件系统\r\n\r\n默认情况下，你的应用程序的 `filesystems` 配置文件包含一个 `s3` 磁盘的磁盘配置。除了使用此磁盘与 Amazon S3 交互外，你还可以使用它与任何兼容 S3 的文件存储服务（如 [MinIO](https://github.com/minio/minio) 或 [DigitalOcean Spaces](https://www.digitalocean.com/products/spaces/)）进行交互。\r\n\r\n通常，在更新磁盘凭据以匹配你计划使用的服务的凭据后，你只需要更新  `endpoint` 配置选项的值。此选项的值通常通过 `AWS_ENDPOINT` 环境变量定义：\r\n\r\n    'endpoint' => env('AWS_ENDPOINT', 'https://minio:9000'),\r\n\r\n\r\n\r\n<a name=\"minio\"></a>\r\n#### MinIO\r\n\r\n为了让 Laravel 的 Flysystem 集成在使用 MinIO 时生成正确的 URL，你应该定义 `AWS_URL` 环境变量，使其与你的应用程序的本地 URL 匹配，并在 URL 路径中包含存储桶名称：\r\n\r\n```ini\r\nAWS_URL=http://localhost:9000/local\r\n```\r\n\r\n> **警告**\r\n> 当使用 MinIO 时，不支持通过 `temporaryUrl` 方法生成临时存储 URL。\r\n\r\n<a name=\"obtaining-disk-instances\"></a>\r\n## 获取磁盘实例\r\n\r\n`Storage` Facade 可用于与所有已配置的磁盘进行交互。例如，你可以使用 Facade 中的 `put` 方法将头像存储到默认磁盘。如果你在未先调用 `disk` 方法的情况下调用 `Storage` Facade 中的方法，则该方法将自动传递给默认磁盘：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::put('avatars/1', $content);\r\n\r\n如果你的应用与多个磁盘进行交互，可使用 `Storage` Facade 中的 `disk` 方法对特定磁盘上的文件进行操作：\r\n\r\n    Storage::disk('s3')->put('avatars/1', $content);\r\n\r\n<a name=\"on-demand-disks\"></a>\r\n### 按需配置磁盘\r\n\r\n有时你可能希望在运行时使用给定配置创建磁盘，而无需在应用程序的 `filesystems` 配置文件中实际存在该配置。为了实现这一点，你可以将配置数组传递给 `Storage` Facade 的 `build` 方法：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Storage;\r\n\r\n$disk = Storage::build([\r\n    'driver' => 'local',\r\n    'root' => '/path/to/root',\r\n]);\r\n\r\n$disk->put('image.jpg', $content);\r\n```\r\n\r\n<a name=\"retrieving-files\"></a>\r\n## 检索文件\r\n\r\n`get` 方法可用于检索文件的内容。该方法将返回文件的原始字符串内容。切记，所有文件路径的指定都应该相对于该磁盘所配置的「root」目录：\r\n\r\n    $contents = Storage::get('file.jpg');\r\n\r\n\r\n\r\n`exists` 方法可以用来判断一个文件是否存在于磁盘上：\r\n\r\n    if (Storage::disk('s3')->exists('file.jpg')) {\r\n        // ...\r\n    }\r\n\r\n`missing` 方法可以用来判断一个文件是否缺失于磁盘上：\r\n\r\n    if (Storage::disk('s3')->missing('file.jpg')) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"downloading-files\"></a>\r\n### 下载文件\r\n\r\n`download` 方法可以用来生成一个响应，强制用户的浏览器下载给定路径的文件。`download` 方法接受一个文件名作为方法的第二个参数，这将决定用户下载文件时看到的文件名。最后，你可以传递一个 HTTP 头部的数组作为方法的第三个参数：\r\n\r\n    return Storage::download('file.jpg');\r\n\r\n    return Storage::download('file.jpg', $name, $headers);\r\n\r\n<a name=\"file-urls\"></a>\r\n### 文件 URL\r\n\r\n你可以使用 `url` 方法来获取给定文件的 URL。如果你使用的是`local` 驱动，这通常只会在给定路径前加上 `/storage`，并返回一个相对 URL 到文件。如果你使用的是 `s3` 驱动，将返回完全限定的远程 URL：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $url = Storage::url('file.jpg');\r\n\r\n当使用 `local` 驱动时，所有应该公开访问的文件都应放置在 `storage/app/public` 目录中。此外，你应该在 `public/storage` 处 [创建一个符号连接](#the-public-disk) 指向 `storage/app/public` 目录。\r\n\r\n> **警告**\r\n> 当使用 `local` 驱动时，url 的返回值不是 URL 编码的。因此，我们建议始终使用能够创建有效 URL 的名称存储文件。\r\n\r\n\r\n\r\n<a name=\"url-host-customization\"></a>\r\n#### 定制 URL 的 Host\r\n\r\n如果你想预定义使用 `Storage` Facade 生成的 URL 的 Host，则可以在磁盘的配置数组中添加一个 `url` 选项：\r\n\r\n    'public' => [\r\n        'driver' => 'local',\r\n        'root' => storage_path('app/public'),\r\n        'url' => env('APP_URL').'/storage',\r\n        'visibility' => 'public',\r\n    ],\r\n\r\n<a name=\"temporary-urls\"></a>\r\n### 临时 URL\r\n\r\n使用 `temporaryUrl` 方法，你可以为使用 `s3` 驱动存储的文件创建临时 URL。此方法接受一个路径和一个 `DateTime` 实例，指定 URL 的过期时间：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $url = Storage::temporaryUrl(\r\n        'file.jpg', now()->addMinutes(5)\r\n    );\r\n\r\n如果你需要指定额外的 [S3 请求参数](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html#RESTObjectGET-requests)，你可以将请求参数数组作为第三个参数传递给`temporaryUrl` 方法。\r\n\r\n    $url = Storage::temporaryUrl(\r\n        'file.jpg',\r\n        now()->addMinutes(5),\r\n        [\r\n            'ResponseContentType' => 'application/octet-stream',\r\n            'ResponseContentDisposition' => 'attachment; filename=file2.jpg',\r\n        ]\r\n    );\r\n\r\n如果你需要为一个特定的存储磁盘定制临时 URL 的创建方式，可以使用 `buildTemporaryUrlsUsing` 方法。例如，如果你有一个控制器允许你通过不支持临时 URL 的磁盘下载存储的文件，这可能很有用。通常，此方法应从服务提供者的 `boot` 方法中调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use DateTime;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n    use Illuminate\\Support\\Facades\\URL;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 启动任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Storage::disk('local')->buildTemporaryUrlsUsing(\r\n                function (string $path, DateTime $expiration, array $options) {\r\n                    return URL::temporarySignedRoute(\r\n                        'files.download',\r\n                        $expiration,\r\n                        array_merge($options, ['path' => $path])\r\n                    );\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n<a name=\"url-host-customization\"></a>\r\n#### URL Host 自定义\r\n\r\n如果你想为使用 `Storage` Facade 生成的 URL 预定义 Host，可以将 `url` 选项添加到磁盘的配置数组：\r\n\r\n    'public' => [\r\n        'driver' => 'local',\r\n        'root' => storage_path('app/public'),\r\n        'url' => env('APP_URL').'/storage',\r\n        'visibility' => 'public',\r\n    ],\r\n\r\n\r\n<a name=\"temporary-upload-urls\"></a>\r\n#### 临时上传 URL\r\n\r\n> **警告**\r\n> 生成临时上传 URL 的能力仅由 `s3` 驱动支持。\r\n\r\n如果你需要生成一个临时 URL，可以直接从客户端应用程序上传文件，你可以使用 `temporaryUploadUrl` 方法。此方法接受一个路径和一个 `DateTime` 实例，指定 URL 应该在何时过期。`temporaryUploadUrl` 方法返回一个关联数组，可以解构为上传 URL 和应该包含在上传请求中的头部：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    ['url' => $url, 'headers' => $headers] = Storage::temporaryUploadUrl(\r\n        'file.jpg', now()->addMinutes(5)\r\n    );\r\n\r\n此方法主要用于无服务器环境，需要客户端应用程序直接将文件上传到云存储系统（如 Amazon S3）。\r\n\r\n<a name=\"file-metadata\"></a>\r\n### 文件元数据\r\n\r\n除了读写文件，Laravel 还可以提供有关文件本身的信息。例如，`size` 方法可用于获取文件大小（以字节为单位）：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $size = Storage::size('file.jpg');\r\n\r\n`lastModified` 方法返回上次修改文件时的时间戳：\r\n\r\n    $time = Storage::lastModified('file.jpg');\r\n\r\n可以通过 `mimeType` 方法获取给定文件的 MIME 类型：\r\n\r\n    $mime = Storage::mimeType('file.jpg')\r\n\r\n<a name=\"file-paths\"></a>\r\n#### 文件路径\r\n\r\n你可以使用 `path` 方法获取给定文件的路径。如果你使用的是 `local` 驱动，这将返回文件的绝对路径。如果你使用的是 `s3` 驱动，此方法将返回 S3 存储桶中文件的相对路径：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $path = Storage::path('file.jpg');\r\n\r\n<a name=\"storing-files\"></a>\r\n## 保存文件\r\n\r\n可以使用 `put` 方法将文件内容存储在磁盘上。你还可以将 PHP `resource` 传递给 `put` 方法，该方法将使用 Flysystem 的底层流支持。请记住，应相对于为磁盘配置的「根」目录指定所有文件路径：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::put('file.jpg', $contents);\r\n\r\n    Storage::put('file.jpg', $resource);\r\n\r\n<a name=\"failed-writes\"></a>\r\n#### 写入失败\r\n\r\n如果 `put` 方法（或其他「写入」操作）无法将文件写入磁盘，将返回 `false`。\r\n\r\n    if (! Storage::put('file.jpg', $contents)) {\r\n        // 该文件无法写入磁盘...\r\n    }\r\n\r\n你可以在你的文件系统磁盘的配置数组中定义 `throw` 选项。当这个选项被定义为 `true` 时，「写入」的方法如 `put` 将在写入操作失败时抛出一个 `League\\Flysystem\\UnableToWriteFile` 的实例。\r\n\r\n    'public' => [\r\n        'driver' => 'local',\r\n        // ...\r\n        'throw' => true,\r\n    ],\r\n\r\n<a name=\"prepending-appending-to-files\"></a>\r\n### 追加内容到文件开头或结尾\r\n\r\n`prepend` 和 `append` 方法允许你将内容写入文件的开头或结尾：\r\n\r\n    Storage::prepend('file.log', 'Prepended Text');\r\n\r\n    Storage::append('file.log', 'Appended Text');\r\n\r\n<a name=\"copying-moving-files\"></a>\r\n### 复制 / 移动文件\r\n\r\n`copy` 方法可用于将现有文件复制到磁盘上的新位置，而 `move` 方法可用于重命名现有文件或将其移动到新位置：\r\n\r\n    Storage::copy('old/file.jpg', 'new/file.jpg');\r\n\r\n    Storage::move('old/file.jpg', 'new/file.jpg');\r\n\r\n<a name=\"automatic-streaming\"></a>\r\n\r\n\r\n### 自动流式传输\r\n\r\n将文件流式传输到存储位置可显著减少内存使用量。如果你希望 Laravel 自动管理将给定文件流式传输到你的存储位置，你可以使用 `putFile` 或 `putFileAs` 方法。此方法接受一个 `Illuminate\\Http\\File` 或 `Illuminate\\Http\\UploadedFile` 实例，并自动将文件流式传输到你所需的位置：\r\n\r\n    use Illuminate\\Http\\File;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    // 为文件名自动生成一个唯一的 ID...\r\n    $path = Storage::putFile('photos', new File('/path/to/photo'));\r\n\r\n    // 手动指定一个文件名...\r\n    $path = Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg');\r\n\r\n关于 putFile 方法有几点重要的注意事项。注意，我们只指定了目录名称而不是文件名。默认情况下，`putFile` 方法将生成一个唯一的 ID 作为文件名。文件的扩展名将通过检查文件的 MIME 类型来确定。文件的路径将由 `putFile` 方法返回，因此你可以将路径（包括生成的文件名）存储在数据库中。\r\n\r\n`putFile` 和 `putFileAs` 方法还接受一个参数来指定存储文件的「可见性」。如果你将文件存储在云盘（如 Amazon S3）上，并希望文件通过生成的 URL 公开访问，这一点特别有用：\r\n\r\n    Storage::putFile('photos', new File('/path/to/photo'), 'public');\r\n\r\n<a name=\"file-uploads\"></a>\r\n### 文件上传\r\n\r\n在网络应用程序中，存储文件的最常见用例之一是存储用户上传的文件，如照片和文档。Laravel 使用上传文件实例上的 `store` 方法非常容易地存储上传的文件。使用你希望存储上传文件的路径调用 `store` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class UserAvatarController extends Controller\r\n    {\r\n        /**\r\n         * 更新用户的头像。\r\n         */\r\n        public function update(Request $request): string\r\n        {\r\n            $path = $request->file('avatar')->store('avatars');\r\n\r\n            return $path;\r\n        }\r\n    }\r\n\r\n\r\n关于这个例子有几点重要的注意事项。注意，我们只指定了目录名称而不是文件名。默认情况下，`store` 方法将生成一个唯一的 ID 作为文件名。文件的扩展名将通过检查文件的 MIME 类型来确定。文件的路径将由 `store` 方法返回，因此你可以将路径（包括生成的文件名）存储在数据库中。\r\n\r\n你也可以在 `Storage` Facade 上调用 `putFile` 方法来执行与上面示例相同的文件存储操作：\r\n\r\n    $path = Storage::putFile('avatars', $request->file('avatar'));\r\n\r\n<a name=\"specifying-a-file-name\"></a>\r\n#### 指定一个文件名\r\n\r\n如果你不希望文件名被自动分配给你存储的文件，你可以使用 `storeAs` 方法，该方法接收路径、文件名和（可选的）磁盘作为其参数：\r\n\r\n    $path = $request->file('avatar')->storeAs(\r\n        'avatars', $request->user()->id\r\n    );\r\n\r\n你也可以在 `Storage` Facade 使用 `putFileAs` 方法，它将执行与上面示例相同的文件存储操作：\r\n\r\n    $path = Storage::putFileAs(\r\n        'avatars', $request->file('avatar'), $request->user()->id\r\n    );\r\n\r\n> **警告**\r\n> 不可打印和无效的 Unicode 字符将自动从文件路径中删除。因此，你可能希望在将文件路径传递给 Laravel 的文件存储方法之前对其进行清理。文件路径使用 `League\\Flysystem\\WhitespacePathNormalizer::normalizePath` 方法进行规范化。\r\n\r\n<a name=\"specifying-a-disk\"></a>\r\n#### 指定一个磁盘\r\n\r\n默认情况下，此上传文件的 `store` 方法将使用你的默认磁盘。如果你想指定另一个磁盘，将磁盘名称作为第二个参数传递给 `store` 方法：\r\n\r\n    $path = $request->file('avatar')->store(\r\n        'avatars/'.$request->user()->id, 's3'\r\n    );\r\n\r\n\r\n如果你正在使用 `storeAs` 方法，你可以将磁盘名称作为第三个参数传递给该方法：\r\n\r\n    $path = $request->file('avatar')->storeAs(\r\n        'avatars',\r\n        $request->user()->id,\r\n        's3'\r\n    );\r\n\r\n<a name=\"other-uploaded-file-information\"></a>\r\n#### 其他上传文件的信息\r\n\r\n如果您想获取上传文件的原始名称和扩展名，可以使用 `getClientOriginalName` 和 `getClientOriginalExtension` 方法来实现：\r\n\r\n    $file = $request->file('avatar');\r\n\r\n    $name = $file->getClientOriginalName();\r\n    $extension = $file->getClientOriginalExtension();\r\n\r\n然而，请记住，`getClientOriginalName` 和 `getClientOriginalExtension` 方法被认为是不安全的，因为文件名和扩展名可能被恶意用户篡改。因此，你通常应该更喜欢使用 `hashName` 和 `extension` 方法来获取给定文件上传的名称和扩展名：\r\n\r\n    $file = $request->file('avatar');\r\n\r\n    $name = $file->hashName(); // 生成一个唯一的、随机的名字...\r\n    $extension = $file->extension(); // 根据文件的 MIME 类型来确定文件的扩展名...\r\n\r\n<a name=\"file-visibility\"></a>\r\n### 文件可见性\r\n\r\n在 Laravel 的 Flysystem 集成中，「visibility」 是跨多个平台的文件权限的抽象。文件可以被声明为 `public` 或 `private`。当一个文件被声明为 `public` 时，你表示该文件通常应该被其他人访问。例如，在使用 S3 驱动程序时，你可以检索 `public` 文件的 URL。\r\n\r\n你可以通过 `put` 方法在写入文件时设置可见性：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::put('file.jpg', $contents, 'public');\r\n\r\n如果文件已经被存储，可以通过 `getVisibility` 和 `setVisibility` 方法检索和设置其可见性：\r\n\r\n    $visibility = Storage::getVisibility('file.jpg');\r\n\r\n    Storage::setVisibility('file.jpg', 'public');\r\n\r\n\r\n在与上传文件交互时，你可以使用 `storePublicly` 和 `storePubliclyAs` 方法将上传文件存储为 `public` 可见性\r\n\r\n    $path = $request->file('avatar')->storePublicly('avatars', 's3');\r\n\r\n    $path = $request->file('avatar')->storePubliclyAs(\r\n        'avatars',\r\n        $request->user()->id,\r\n        's3'\r\n    );\r\n\r\n<a name=\"local-files-and-visibility\"></a>\r\n#### 本地文件和可见性\r\n\r\n当使用 `local` 驱动时，`public`[可见性](#file-visibility)转换为目录的 `0755` 权限和文件的 `0644` 权限。你可以在你的应用程序的 `filesystems` 配置文件中修改权限映射：\r\n\r\n    'local' => [\r\n        'driver' => 'local',\r\n        'root' => storage_path('app'),\r\n        'permissions' => [\r\n            'file' => [\r\n                'public' => 0644,\r\n                'private' => 0600,\r\n            ],\r\n            'dir' => [\r\n                'public' => 0755,\r\n                'private' => 0700,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n<a name=\"deleting-files\"></a>\r\n## 删除文件\r\n\r\n`delete` 方法接收一个文件名或一个文件名数组来将其从磁盘中删除：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::delete('file.jpg');\r\n\r\n    Storage::delete(['file.jpg', 'file2.jpg']);\r\n\r\n如果需要，你可以指定应从哪个磁盘删除文件。\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    Storage::disk('s3')->delete('path/file.jpg');\r\n\r\n<a name=\"directories\"></a>\r\n## 目录\r\n\r\n<a name=\"get-all-files-within-a-directory\"></a>\r\n#### 获取目录下所有的文件\r\n\r\n`files` 将以数组的形式返回给定目录下所有的文件。如果你想要检索给定目录的所有文件及其子目录的所有文件，你可以使用 `allFiles` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n\r\n    $files = Storage::files($directory);\r\n\r\n    $files = Storage::allFiles($directory);\r\n\r\n<a name=\"get-all-directories-within-a-directory\"></a>\r\n#### 获取特定目录下的子目录\r\n\r\n`directories` 方法以数组的形式返回给定目录中的所有目录。此外，你还可以使用 `allDirectories` 方法递归地获取给定目录中的所有目录及其子目录中的目录：\r\n\r\n    $directories = Storage::directories($directory);\r\n\r\n    $directories = Storage::allDirectories($directory);\r\n\r\n\r\n\r\n<a name=\"create-a-directory\"></a>\r\n#### 创建目录\r\n\r\n`makeDirectory` 方法可递归的创建指定的目录：\r\n\r\n    Storage::makeDirectory($directory);\r\n\r\n<a name=\"delete-a-directory\"></a>\r\n#### 删除一个目录\r\n\r\n最后，`deleteDirectory` 方法可用于删除一个目录及其下所有的文件：\r\n\r\n    Storage::deleteDirectory($directory);\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\nThe `Storage` facade's `fake` method allows you to easily generate a fake disk that, combined with the file generation utilities of the `Illuminate\\Http\\UploadedFile` class, greatly simplifies the testing of file uploads. For example:\r\n\r\n\r\n`Storage` 门面类的 `fake` 方法可以轻松创建一个虚拟磁盘，与`Illuminate\\Http\\UploadedFile` 类配合使用，大大简化了文件的上传测试。例如：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Http\\UploadedFile;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_albums_can_be_uploaded(): void\r\n        {\r\n            Storage::fake('photos');\r\n\r\n            $response = $this->json('POST', '/photos', [\r\n                UploadedFile::fake()->image('photo1.jpg'),\r\n                UploadedFile::fake()->image('photo2.jpg')\r\n            ]);\r\n\r\n            // 断言存储了一个或多个文件。\r\n            Storage::disk('photos')->assertExists('photo1.jpg');\r\n            Storage::disk('photos')->assertExists(['photo1.jpg', 'photo2.jpg']);\r\n\r\n            // 断言一个或多个文件未存储。\r\n            Storage::disk('photos')->assertMissing('missing.jpg');\r\n            Storage::disk('photos')->assertMissing(['missing.jpg', 'non-existing.jpg']);\r\n\r\n            // 断言给定目录为空。\r\n            Storage::disk('photos')->assertDirectoryEmpty('/wallpapers');\r\n        }\r\n    }\r\n\r\n\r\n默认情况下，`fake` 方法将删除临时目录中的所有文件。如果你想保留这些文件，你可以使用 \"persistentFake\" 方法代替。有关测试文件上传的更多信息，您可以查阅 [HTTP 测试文档的文件上传](/docs/laravel/10.x/http-tests#testing-file-uploads).\r\n\r\n> **警告**\r\n> `image` 方法需要 [GD 扩展](https://www.php.net/manual/en/book.image.php) .\r\n\r\n\r\n\r\n<a name=\"custom-filesystems\"></a>\r\n## 自定义文件系统\r\n\r\nLaravel 内置的文件系统提供了一些开箱即用的驱动；当然，它不仅仅是这些，它还提供了与其他存储系统的适配器。通过这些适配器，你可以在你的 Laravel 应用中创建自定义驱动。\r\n\r\n要安装自定义文件系统，你可能需要一个文件系统适配器。让我们将社区维护的 Dropbox 适配器添加到项目中：\r\n\r\n```shell\r\ncomposer require spatie/flysystem-dropbox\r\n```\r\n\r\n接下来，你可以在 [服务提供者](/docs/laravel/10.x/providers) 中注册一个带有 `boot` 方法的驱动。在提供者的 `boot` 方法中，你可以使用 `Storage` 门面的 `extend` 方法来定义一个自定义驱动：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n    use Illuminate\\Filesystem\\FilesystemAdapter;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use League\\Flysystem\\Filesystem;\r\n    use Spatie\\Dropbox\\Client as DropboxClient;\r\n    use Spatie\\FlysystemDropbox\\DropboxAdapter;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用程序服务。\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Storage::extend('dropbox', function (Application $app, array $config) {\r\n                $adapter = new DropboxAdapter(new DropboxClient(\r\n                    $config['authorization_token']\r\n                ));\r\n\r\n                return new FilesystemAdapter(\r\n                    new Filesystem($adapter, $config),\r\n                    $adapter,\r\n                    $config\r\n                );\r\n            });\r\n        }\r\n    }\r\n\r\n`extend` 方法的第一个参数是驱动程序的名称，第二个参数是接收 `$app` 和 `$config` 变量的闭包。闭包必须返回的实例 `League\\Flysystem\\Filesystem`。`$config` 变量包含 `config/filesystems.php` 为指定磁盘定义的值。\r\n\r\n一旦创建并注册了扩展的服务提供商，就可以 `dropbox` 在 `config/filesystems.php` 配置文件中使用该驱动程序。\r\n\r\n","p":"docs/filesystem.html"},{"t":"helpers (辅助函数)","d":"# 辅助函数\r\n\r\n- [简介](#introduction)\r\n- [可用方法](#available-methods)\r\n- [其他实用工具](#other-utilities)\r\n  - [Benchmarking](#benchmarking)\r\n  - [Pipeline](#pipeline)\r\n  - [Lottery](#lottery)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 包含各种各样的全局 PHP 「辅助」函数，框架本身也大量的使用了这些功能函数；如果你觉的方便，你可以在你的应用中任意使用这些函数。\r\n\r\n<a name=\"available-methods\"></a>\r\n## 可用方法\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        columns: 10.8em 3; -moz-columns: 10.8em 3; -webkit-columns: 10.8em 3;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n    }\r\n\r\n</style>\r\n\r\n<a name=\"arrays-and-objects-method-list\"></a>\r\n### 数组 & 对象\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[Arr::accessible](#method-array-accessible)\r\n[Arr::add](#method-array-add)\r\n[Arr::collapse](#method-array-collapse)\r\n[Arr::crossJoin](#method-array-crossjoin)\r\n[Arr::divide](#method-array-divide)\r\n[Arr::dot](#method-array-dot)\r\n[Arr::except](#method-array-except)\r\n[Arr::exists](#method-array-exists)\r\n[Arr::first](#method-array-first)\r\n[Arr::flatten](#method-array-flatten)\r\n[Arr::forget](#method-array-forget)\r\n[Arr::get](#method-array-get)\r\n[Arr::has](#method-array-has)\r\n[Arr::hasAny](#method-array-hasany)\r\n[Arr::isAssoc](#method-array-isassoc)\r\n[Arr::isList](#method-array-islist)\r\n[Arr::join](#method-array-join)\r\n[Arr::keyBy](#method-array-keyby)\r\n[Arr::last](#method-array-last)\r\n[Arr::map](#method-array-map)\r\n[Arr::only](#method-array-only)\r\n[Arr::pluck](#method-array-pluck)\r\n[Arr::prepend](#method-array-prepend)\r\n[Arr::prependKeysWith](#method-array-prependkeyswith)\r\n[Arr::pull](#method-array-pull)\r\n[Arr::query](#method-array-query)\r\n[Arr::random](#method-array-random)\r\n[Arr::set](#method-array-set)\r\n[Arr::shuffle](#method-array-shuffle)\r\n[Arr::sort](#method-array-sort)\r\n[Arr::sortDesc](#method-array-sort-desc)\r\n[Arr::sortRecursive](#method-array-sort-recursive)\r\n[Arr::toCssClasses](#method-array-to-css-classes)\r\n[Arr::undot](#method-array-undot)\r\n[Arr::where](#method-array-where)\r\n[Arr::whereNotNull](#method-array-where-not-null)\r\n[Arr::wrap](#method-array-wrap)\r\n[data_fill](#method-data-fill)\r\n[data_get](#method-data-get)\r\n[data_set](#method-data-set)\r\n[head](#method-head)\r\n[last](#method-last)\r\n\r\n</div>\r\n\r\n<a name=\"paths-method-list\"></a>\r\n### 路径\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[app_path](#method-app-path)\r\n[base_path](#method-base-path)\r\n[config_path](#method-config-path)\r\n[database_path](#method-database-path)\r\n[lang_path](#method-lang-path)\r\n[mix](#method-mix)\r\n[public_path](#method-public-path)\r\n[resource_path](#method-resource-path)\r\n[storage_path](#method-storage-path)\r\n\r\n</div>\r\n\r\n<a name=\"strings-method-list\"></a>\r\n### 字符串\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[\\__](#method-__)\r\n[class_basename](#method-class-basename)\r\n[e](#method-e)\r\n[preg_replace_array](#method-preg-replace-array)\r\n[Str::after](#method-str-after)\r\n[Str::afterLast](#method-str-after-last)\r\n[Str::ascii](#method-str-ascii)\r\n[Str::before](#method-str-before)\r\n[Str::beforeLast](#method-str-before-last)\r\n[Str::between](#method-str-between)\r\n[Str::betweenFirst](#method-str-between-first)\r\n[Str::camel](#method-camel-case)\r\n[Str::contains](#method-str-contains)\r\n[Str::containsAll](#method-str-contains-all)\r\n[Str::endsWith](#method-ends-with)\r\n[Str::excerpt](#method-excerpt)\r\n[Str::finish](#method-str-finish)\r\n[Str::headline](#method-str-headline)\r\n[Str::inlineMarkdown](#method-str-inline-markdown)\r\n[Str::is](#method-str-is)\r\n[Str::isAscii](#method-str-is-ascii)\r\n[Str::isJson](#method-str-is-json)\r\n[Str::isUlid](#method-str-is-ulid)\r\n[Str::isUuid](#method-str-is-uuid)\r\n[Str::kebab](#method-kebab-case)\r\n[Str::lcfirst](#method-str-lcfirst)\r\n[Str::length](#method-str-length)\r\n[Str::limit](#method-str-limit)\r\n[Str::lower](#method-str-lower)\r\n[Str::markdown](#method-str-markdown)\r\n[Str::mask](#method-str-mask)\r\n[Str::orderedUuid](#method-str-ordered-uuid)\r\n[Str::padBoth](#method-str-padboth)\r\n[Str::padLeft](#method-str-padleft)\r\n[Str::padRight](#method-str-padright)\r\n[Str::password](#method-str-password)\r\n[Str::plural](#method-str-plural)\r\n[Str::pluralStudly](#method-str-plural-studly)\r\n[Str::random](#method-str-random)\r\n[Str::remove](#method-str-remove)\r\n[Str::replace](#method-str-replace)\r\n[Str::replaceArray](#method-str-replace-array)\r\n[Str::replaceFirst](#method-str-replace-first)\r\n[Str::replaceLast](#method-str-replace-last)\r\n[Str::reverse](#method-str-reverse)\r\n[Str::singular](#method-str-singular)\r\n[Str::slug](#method-str-slug)\r\n[Str::snake](#method-snake-case)\r\n[Str::squish](#method-str-squish)\r\n[Str::start](#method-str-start)\r\n[Str::startsWith](#method-starts-with)\r\n[Str::studly](#method-studly-case)\r\n[Str::substr](#method-str-substr)\r\n[Str::substrCount](#method-str-substrcount)\r\n[Str::substrReplace](#method-str-substrreplace)\r\n[Str::swap](#method-str-swap)\r\n[Str::title](#method-title-case)\r\n[Str::toHtmlString](#method-str-to-html-string)\r\n[Str::ucfirst](#method-str-ucfirst)\r\n[Str::ucsplit](#method-str-ucsplit)\r\n[Str::upper](#method-str-upper)\r\n[Str::ulid](#method-str-ulid)\r\n[Str::uuid](#method-str-uuid)\r\n[Str::wordCount](#method-str-word-count)\r\n[Str::words](#method-str-words)\r\n[str](#method-str)\r\n[trans](#method-trans)\r\n[trans_choice](#method-trans-choice)\r\n\r\n</div>\r\n\r\n<a name=\"fluent-strings-method-list\"></a>\r\n### 字符流处理\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[after](#method-fluent-str-after)\r\n[afterLast](#method-fluent-str-after-last)\r\n[append](#method-fluent-str-append)\r\n[ascii](#method-fluent-str-ascii)\r\n[basename](#method-fluent-str-basename)\r\n[before](#method-fluent-str-before)\r\n[beforeLast](#method-fluent-str-before-last)\r\n[between](#method-fluent-str-between)\r\n[betweenFirst](#method-fluent-str-between-first)\r\n[camel](#method-fluent-str-camel)\r\n[classBasename](#method-fluent-str-class-basename)\r\n[contains](#method-fluent-str-contains)\r\n[containsAll](#method-fluent-str-contains-all)\r\n[dirname](#method-fluent-str-dirname)\r\n[endsWith](#method-fluent-str-ends-with)\r\n[excerpt](#method-fluent-str-excerpt)\r\n[exactly](#method-fluent-str-exactly)\r\n[explode](#method-fluent-str-explode)\r\n[finish](#method-fluent-str-finish)\r\n[headline](#method-fluent-str-headline)\r\n[inlineMarkdown](#method-fluent-str-inline-markdown)\r\n[is](#method-fluent-str-is)\r\n[isAscii](#method-fluent-str-is-ascii)\r\n[isEmpty](#method-fluent-str-is-empty)\r\n[isNotEmpty](#method-fluent-str-is-not-empty)\r\n[isJson](#method-fluent-str-is-json)\r\n[isUlid](#method-fluent-str-is-ulid)\r\n[isUuid](#method-fluent-str-is-uuid)\r\n[kebab](#method-fluent-str-kebab)\r\n[lcfirst](#method-fluent-str-lcfirst)\r\n[length](#method-fluent-str-length)\r\n[limit](#method-fluent-str-limit)\r\n[lower](#method-fluent-str-lower)\r\n[ltrim](#method-fluent-str-ltrim)\r\n[markdown](#method-fluent-str-markdown)\r\n[mask](#method-fluent-str-mask)\r\n[match](#method-fluent-str-match)\r\n[matchAll](#method-fluent-str-match-all)\r\n[isMatch](#method-fluent-str-is-match)\r\n[newLine](#method-fluent-str-new-line)\r\n[padBoth](#method-fluent-str-padboth)\r\n[padLeft](#method-fluent-str-padleft)\r\n[padRight](#method-fluent-str-padright)\r\n[pipe](#method-fluent-str-pipe)\r\n[plural](#method-fluent-str-plural)\r\n[prepend](#method-fluent-str-prepend)\r\n[remove](#method-fluent-str-remove)\r\n[replace](#method-fluent-str-replace)\r\n[replaceArray](#method-fluent-str-replace-array)\r\n[replaceFirst](#method-fluent-str-replace-first)\r\n[replaceLast](#method-fluent-str-replace-last)\r\n[replaceMatches](#method-fluent-str-replace-matches)\r\n[rtrim](#method-fluent-str-rtrim)\r\n[scan](#method-fluent-str-scan)\r\n[singular](#method-fluent-str-singular)\r\n[slug](#method-fluent-str-slug)\r\n[snake](#method-fluent-str-snake)\r\n[split](#method-fluent-str-split)\r\n[squish](#method-fluent-str-squish)\r\n[start](#method-fluent-str-start)\r\n[startsWith](#method-fluent-str-starts-with)\r\n[studly](#method-fluent-str-studly)\r\n[substr](#method-fluent-str-substr)\r\n[substrReplace](#method-fluent-str-substrreplace)\r\n[swap](#method-fluent-str-swap)\r\n[tap](#method-fluent-str-tap)\r\n[test](#method-fluent-str-test)\r\n[title](#method-fluent-str-title)\r\n[trim](#method-fluent-str-trim)\r\n[ucfirst](#method-fluent-str-ucfirst)\r\n[ucsplit](#method-fluent-str-ucsplit)\r\n[upper](#method-fluent-str-upper)\r\n[when](#method-fluent-str-when)\r\n[whenContains](#method-fluent-str-when-contains)\r\n[whenContainsAll](#method-fluent-str-when-contains-all)\r\n[whenEmpty](#method-fluent-str-when-empty)\r\n[whenNotEmpty](#method-fluent-str-when-not-empty)\r\n[whenStartsWith](#method-fluent-str-when-starts-with)\r\n[whenEndsWith](#method-fluent-str-when-ends-with)\r\n[whenExactly](#method-fluent-str-when-exactly)\r\n[whenNotExactly](#method-fluent-str-when-not-exactly)\r\n[whenIs](#method-fluent-str-when-is)\r\n[whenIsAscii](#method-fluent-str-when-is-ascii)\r\n[whenIsUlid](#method-fluent-str-when-is-ulid)\r\n[whenIsUuid](#method-fluent-str-when-is-uuid)\r\n[whenTest](#method-fluent-str-when-test)\r\n[wordCount](#method-fluent-str-word-count)\r\n[words](#method-fluent-str-words)\r\n\r\n</div>\r\n\r\n<a name=\"urls-method-list\"></a>\r\n### URLs\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[action](#method-action)\r\n[asset](#method-asset)\r\n[route](#method-route)\r\n[secure_asset](#method-secure-asset)\r\n[secure_url](#method-secure-url)\r\n[to_route](#method-to-route)\r\n[url](#method-url)\r\n\r\n</div>\r\n\r\n<a name=\"miscellaneous-method-list\"></a>\r\n### 杂项\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[abort](#method-abort)\r\n[abort_if](#method-abort-if)\r\n[abort_unless](#method-abort-unless)\r\n[app](#method-app)\r\n[auth](#method-auth)\r\n[back](#method-back)\r\n[bcrypt](#method-bcrypt)\r\n[blank](#method-blank)\r\n[broadcast](#method-broadcast)\r\n[cache](#method-cache)\r\n[class_uses_recursive](#method-class-uses-recursive)\r\n[collect](#method-collect)\r\n[config](#method-config)\r\n[cookie](#method-cookie)\r\n[csrf_field](#method-csrf-field)\r\n[csrf_token](#method-csrf-token)\r\n[decrypt](#method-decrypt)\r\n[dd](#method-dd)\r\n[dispatch](#method-dispatch)\r\n[dump](#method-dump)\r\n[encrypt](#method-encrypt)\r\n[env](#method-env)\r\n[event](#method-event)\r\n[fake](#method-fake)\r\n[filled](#method-filled)\r\n[info](#method-info)\r\n[logger](#method-logger)\r\n[method_field](#method-method-field)\r\n[now](#method-now)\r\n[old](#method-old)\r\n[optional](#method-optional)\r\n[policy](#method-policy)\r\n[redirect](#method-redirect)\r\n[report](#method-report)\r\n[report_if](#method-report-if)\r\n[report_unless](#method-report-unless)\r\n[request](#method-request)\r\n[rescue](#method-rescue)\r\n[resolve](#method-resolve)\r\n[response](#method-response)\r\n[retry](#method-retry)\r\n[session](#method-session)\r\n[tap](#method-tap)\r\n[throw_if](#method-throw-if)\r\n[throw_unless](#method-throw-unless)\r\n[today](#method-today)\r\n[trait_uses_recursive](#method-trait-uses-recursive)\r\n[transform](#method-transform)\r\n[validator](#method-validator)\r\n[value](#method-value)\r\n[view](#method-view)\r\n[with](#method-with)\r\n\r\n</div>\r\n\r\n<a name=\"method-listing\"></a>\r\n## 方法列表\r\n\r\n<style>\r\n    .collection-method code {\r\n        font-size: 14px;\r\n    }\r\n\r\n    .collection-method:not(.first-collection-method) {\r\n        margin-top: 50px;\r\n    }\r\n\r\n</style>\r\n\r\n<a name=\"arrays\"></a>\r\n## 数组 & 对象\r\n\r\n<a name=\"method-array-accessible\"></a>\r\n#### `Arr::accessible()` {.collection-method .first-collection-method}\r\n\r\n `Arr::accessible` 方法检查给定的值是否可被数组式访问：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    use Illuminate\\Support\\Collection;\r\n    \r\n    $isAccessible = Arr::accessible(['a' => 1, 'b' => 2]);\r\n    \r\n    // true\r\n    \r\n    $isAccessible = Arr::accessible(new Collection);\r\n    \r\n    // true\r\n    \r\n    $isAccessible = Arr::accessible('abc');\r\n    \r\n    // false\r\n    \r\n    $isAccessible = Arr::accessible(new stdClass);\r\n    \r\n    // false\r\n\r\n<a name=\"method-array-add\"></a>\r\n#### `Arr::add()` {.collection-method}\r\n\r\n如果给定的键名在数组中不存在键值或该键值设置为 `null` ，那么 `Arr::add` 方法将会把给定的键值对添加到数组中：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = Arr::add(['name' => 'Desk'], 'price', 100);\r\n    \r\n    // ['name' => 'Desk', 'price' => 100]\r\n    \r\n    $array = Arr::add(['name' => 'Desk', 'price' => null], 'price', 100);\r\n    \r\n    // ['name' => 'Desk', 'price' => 100]\r\n\r\n<a name=\"method-array-collapse\"></a>\r\n#### `Arr::collapse()` {.collection-method}\r\n\r\n`Arr::collapse` 方法将多个数组合并为一个数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\r\n    \r\n    // [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\r\n<a name=\"method-array-crossjoin\"></a>\r\n#### `Arr::crossJoin()` {.collection-method}\r\n\r\n`Arr::crossJoin` 方法交叉连接给定的数组，返回具有所有可能排列的笛卡尔乘积：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $matrix = Arr::crossJoin([1, 2], ['a', 'b']);\r\n    \r\n    /*\r\n        [\r\n            [1, 'a'],\r\n            [1, 'b'],\r\n            [2, 'a'],\r\n            [2, 'b'],\r\n        ]\r\n    */\r\n    \r\n    $matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);\r\n    \r\n    /*\r\n        [\r\n            [1, 'a', 'I'],\r\n            [1, 'a', 'II'],\r\n            [1, 'b', 'I'],\r\n            [1, 'b', 'II'],\r\n            [2, 'a', 'I'],\r\n            [2, 'a', 'II'],\r\n            [2, 'b', 'I'],\r\n            [2, 'b', 'II'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-array-divide\"></a>\r\n#### `Arr::divide()` {.collection-method}\r\n\r\n`Arr::divide` 方法返回一个二维数组，一个值包含原数组的键，另一个值包含原数组的值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    [$keys, $values] = Arr::divide(['name' => 'Desk']);\r\n    \r\n    // $keys: ['name']\r\n    \r\n    // $values: ['Desk']\r\n\r\n<a name=\"method-array-dot\"></a>\r\n#### `Arr::dot()` {.collection-method}\r\n\r\n`Arr::dot` 方法将多维数组中所有的键平铺到一维数组中，新数组使用「.」符号表示层级包含关系：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['products' => ['desk' => ['price' => 100]]];\r\n    \r\n    $flattened = Arr::dot($array);\r\n    \r\n    // ['products.desk.price' => 100]\r\n\r\n<a name=\"method-array-except\"></a>\r\n#### `Arr::except()` {.collection-method}\r\n\r\n`Arr::except` 方法从数组中删除指定的键值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['name' => 'Desk', 'price' => 100];\r\n    \r\n    $filtered = Arr::except($array, ['price']);\r\n    \r\n    // ['name' => 'Desk']\r\n\r\n<a name=\"method-array-exists\"></a>\r\n#### `Arr::exists()` {.collection-method}\r\n\r\n`Arr::exists` 方法检查给定的键是否存在提供的数组中：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['name' => 'John Doe', 'age' => 17];\r\n    \r\n    $exists = Arr::exists($array, 'name');\r\n    \r\n    // true\r\n    \r\n    $exists = Arr::exists($array, 'salary');\r\n    \r\n    // false\r\n\r\n<a name=\"method-array-first\"></a>\r\n#### `Arr::first()` {.collection-method}\r\n\r\n`Arr::first` 方法返回数组中满足指定条件的第一个元素：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [100, 200, 300];\r\n    \r\n    $first = Arr::first($array, function (int $value, int $key) {\r\n        return $value >= 150;\r\n    });\r\n    \r\n    // 200\r\n\r\n可将默认值作为第三个参数传递给该方法，如果数组中没有值满足指定条件，则返回该默认值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $first = Arr::first($array, $callback, $default);\r\n\r\n<a name=\"method-array-flatten\"></a>\r\n\r\n#### `Arr::flatten()` {.collection-method}\r\n\r\n `Arr::flatten` 方法将多维数组中数组的值取出平铺为一维数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['name' => 'Joe', 'languages' => ['PHP', 'Ruby']];\r\n    \r\n    $flattened = Arr::flatten($array);\r\n    \r\n    // ['Joe', 'PHP', 'Ruby']\r\n\r\n<a name=\"method-array-forget\"></a>\r\n#### `Arr::forget()` {.collection-method}\r\n\r\n`Arr::forget` 方法使用「.」符号从深度嵌套的数组中删除给定的键值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['products' => ['desk' => ['price' => 100]]];\r\n    \r\n    Arr::forget($array, 'products.desk');\r\n    \r\n    // ['products' => []]\r\n\r\n<a name=\"method-array-get\"></a>\r\n#### `Arr::get()` {.collection-method}\r\n\r\n`Arr::get` 方法使用「.」符号从深度嵌套的数组中根据指定键检索值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['products' => ['desk' => ['price' => 100]]];\r\n    \r\n    $price = Arr::get($array, 'products.desk.price');\r\n    \r\n    // 100\r\n\r\n `Arr::get` 方法也可以接受一个默认值，如果数组中不存在指定的键，则返回默认值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $discount = Arr::get($array, 'products.desk.discount', 0);\r\n    \r\n    // 0\r\n\r\n<a name=\"method-array-has\"></a>\r\n#### `Arr::has()` {.collection-method}\r\n\r\n`Arr::has` 方法使用「.」符号判断数组中是否存在指定的一个或多个键：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['product' => ['name' => 'Desk', 'price' => 100]];\r\n    \r\n    $contains = Arr::has($array, 'product.name');\r\n    \r\n    // true\r\n    \r\n    $contains = Arr::has($array, ['product.price', 'product.discount']);\r\n    \r\n    // false\r\n\r\n<a name=\"method-array-hasany\"></a>\r\n#### `Arr::hasAny()` {.collection-method}\r\n\r\n`Arr::hasAny` 方法使用「.」符号判断给定集合中的任一值是否存在于数组中：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['product' => ['name' => 'Desk', 'price' => 100]];\r\n    \r\n    $contains = Arr::hasAny($array, 'product.name');\r\n    \r\n    // true\r\n    \r\n    $contains = Arr::hasAny($array, ['product.name', 'product.discount']);\r\n    \r\n    // true\r\n    \r\n    $contains = Arr::hasAny($array, ['category', 'product.discount']);\r\n    \r\n    // false\r\n\r\n<a name=\"method-array-isassoc\"></a>\r\n#### `Arr::isAssoc()` {.collection-method}\r\n\r\n如果给定数组是关联数组，则 `Arr::isAssoc` 方法返回 `true`，如果该数组没有以零开头的顺序数字键，则将其视为「关联」数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $isAssoc = Arr::isAssoc(['product' => ['name' => 'Desk', 'price' => 100]]);\r\n    \r\n    // true\r\n    \r\n    $isAssoc = Arr::isAssoc([1, 2, 3]);\r\n    \r\n    // false\r\n\r\n<a name=\"method-array-islist\"></a>\r\n#### `Arr::isList()` {.collection-method}\r\n\r\n如果给定数组的键是从零开始的连续整数，则 `Arr::isList` 方法返回 `true`：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $isList = Arr::isList(['foo', 'bar', 'baz']);\r\n    \r\n    // true\r\n    \r\n    $isList = Arr::isList(['product' => ['name' => 'Desk', 'price' => 100]]);\r\n    \r\n    // false\r\n\r\n<a name=\"method-array-join\"></a>\r\n#### `Arr::join()` {.collection-method}\r\n\r\n`Arr::join()`方法将给定数组的所有值通过给定字符串连接起来。使用此方法的第二个参数，您还可以为数组中的最后一个元素指定连接的字符串：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['Tailwind', 'Alpine', 'Laravel', 'Livewire'];\r\n    \r\n    $joined = Arr::join($array, ', ');\r\n    \r\n    // Tailwind, Alpine, Laravel, Livewire\r\n    \r\n    $joined = Arr::join($array, ', ', ' and ');\r\n    \r\n    // Tailwind, Alpine, Laravel and Livewire\r\n\r\n<a name=\"method-array-keyby\"></a>\r\n#### `Arr::keyBy()` {.collection-method}\r\n\r\n`Arr::keyBy()`方法通过给定键名的值对该数组进行重组。如果数组中存在多个相同的值，则只有最后一个值会出现在新数组中：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n        ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n    ];\r\n    \r\n    $keyed = Arr::keyBy($array, 'product_id');\r\n    \r\n    /*\r\n        [\r\n            'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n            'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-array-last\"></a>\r\n#### `Arr::last()` {.collection-method}\r\n\r\n`Arr::last` 方法返回数组中满足指定条件的最后一个元素：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [100, 200, 300, 110];\r\n    \r\n    $last = Arr::last($array, function (int $value, int $key) {\r\n        return $value >= 150;\r\n    });\r\n    \r\n    // 300\r\n\r\n将默认值作为第三个参数传递给该方法，如果没有值满足条件，则返回该默认值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $last = Arr::last($array, $callback, $default);\r\n\r\n<a name=\"method-array-map\"></a>\r\n#### `Arr::map()` {.collection-method}\r\n\r\n`Arr::map` 方法用来遍历数组，并将每个值和键传递给给定的回调。数组值由回调返回的值替换：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['first' => 'james', 'last' => 'kirk'];\r\n    \r\n    $mapped = Arr::map($array, function (string $value, string $key) {\r\n        return ucfirst($value);\r\n    });\r\n    \r\n    // ['first' => 'James', 'last' => 'Kirk']\r\n\r\n<a name=\"method-array-only\"></a>\r\n#### `Arr::only()` {.collection-method}\r\n\r\n`Arr::only` 方法仅返回给定数组中的指定键/值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['name' => 'Desk', 'price' => 100, 'orders' => 10];\r\n    \r\n    $slice = Arr::only($array, ['name', 'price']);\r\n    \r\n    // ['name' => 'Desk', 'price' => 100]\r\n\r\n<a name=\"method-array-pluck\"></a>\r\n#### `Arr::pluck()` {.collection-method}\r\n\r\n`Arr::pluck` 方法从数组中检索给定键的所有值:\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        ['developer' => ['id' => 1, 'name' => 'Taylor']],\r\n        ['developer' => ['id' => 2, 'name' => 'Abigail']],\r\n    ];\r\n    \r\n    $names = Arr::pluck($array, 'developer.name');\r\n    \r\n    // ['Taylor', 'Abigail']\r\n\r\n你也可以指定结果的键:\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $names = Arr::pluck($array, 'developer.name', 'developer.id');\r\n    \r\n    // [1 => 'Taylor', 2 => 'Abigail']\r\n\r\n<a name=\"method-array-prepend\"></a>\r\n\r\n<a name=\"method-array-last\"></a>\r\n#### `Arr::last()` {.collection-method}\r\n\r\n`Arr::last`  方法返回数组中满足指定条件的最后一个元素：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [100, 200, 300, 110];\r\n    \r\n    $last = Arr::last($array, function (int $value, int $key) {\r\n        return $value >= 150;\r\n    });\r\n    \r\n    // 300\r\n\r\n将默认值作为第三个参数传递给该方法，如果没有值满足指定条件，则返回该默认值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $last = Arr::last($array, $callback, $default);\r\n\r\n<a name=\"method-array-map\"></a>\r\n#### `Arr::map()` {.collection-method}\r\n\r\n`Arr::map` 方法遍历数组并将每个键和值传递至给定的回调方法。数组的值将替换为该回调方法返回的值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['first' => 'james', 'last' => 'kirk'];\r\n    \r\n    $mapped = Arr::map($array, function (string $value, string $key) {\r\n        return ucfirst($value);\r\n    });\r\n    \r\n    // ['first' => 'James', 'last' => 'Kirk']\r\n\r\n<a name=\"method-array-only\"></a>\r\n#### `Arr::only()` {.collection-method}\r\n\r\n`Arr::only` 方法只返回给定数组中指定的键值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['name' => 'Desk', 'price' => 100, 'orders' => 10];\r\n    \r\n    $slice = Arr::only($array, ['name', 'price']);\r\n    \r\n    // ['name' => 'Desk', 'price' => 100]\r\n\r\n<a name=\"method-array-pluck\"></a>\r\n#### `Arr::pluck()` {.collection-method}\r\n\r\n`Arr::pluck` 方法从数组中检索给定键的所有值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        ['developer' => ['id' => 1, 'name' => 'Taylor']],\r\n        ['developer' => ['id' => 2, 'name' => 'Abigail']],\r\n    ];\r\n    \r\n    $names = Arr::pluck($array, 'developer.name');\r\n    \r\n    // ['Taylor', 'Abigail']\r\n\r\n你还可以指定结果的键：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $names = Arr::pluck($array, 'developer.name', 'developer.id');\r\n    \r\n    // [1 => 'Taylor', 2 => 'Abigail']\r\n\r\n<a name=\"method-array-prepend\"></a>\r\n#### `Arr::prepend()` {.collection-method}\r\n\r\n `Arr::prepend` 方法将一个值插入到数组的开始位置：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['one', 'two', 'three', 'four'];\r\n    \r\n    $array = Arr::prepend($array, 'zero');\r\n    \r\n    // ['zero', 'one', 'two', 'three', 'four']\r\n\r\n你也可以指定插入值的键：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['price' => 100];\r\n    \r\n    $array = Arr::prepend($array, 'Desk', 'name');\r\n    \r\n    // ['name' => 'Desk', 'price' => 100]\r\n\r\n<a name=\"method-array-prependkeyswith\"></a>\r\n#### `Arr::prependKeysWith()` {.collection-method}\r\n\r\n`Arr::prependKeysWith` 方法为关联数组中的所有键添加给定前缀：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        'name' => 'Desk',\r\n        'price' => 100,\r\n    ];\r\n    \r\n    $keyed = Arr::prependKeysWith($array, 'product.');\r\n    \r\n    /*\r\n        [\r\n            'product.name' => 'Desk',\r\n            'product.price' => 100,\r\n        ]\r\n    */\r\n\r\n<a name=\"method-array-pull\"></a>\r\n#### `Arr::pull()` {.collection-method}\r\n\r\n`Arr::pull` 方法从数组中返回指定键的值并删除此键值对：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['name' => 'Desk', 'price' => 100];\r\n    \r\n    $name = Arr::pull($array, 'name');\r\n    \r\n    // $name: Desk\r\n    \r\n    // $array: ['price' => 100]\r\n\r\n默认值可以作为第三个参数传递给该方法。如果指定键不存在，则返回该值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $value = Arr::pull($array, $key, $default);\r\n\r\n<a name=\"method-array-query\"></a>\r\n#### `Arr::query()` {.collection-method}\r\n\r\n`Arr::query` 方法将数组转换为查询字符串：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        'name' => 'Taylor',\r\n        'order' => [\r\n            'column' => 'created_at',\r\n            'direction' => 'desc'\r\n        ]\r\n    ];\r\n    \r\n    Arr::query($array);\r\n    \r\n    // name=Taylor&order[column]=created_at&order[direction]=desc\r\n\r\n<a name=\"method-array-random\"></a>\r\n#### `Arr::random()` {.collection-method}\r\n\r\n`Arr::random` 方法从数组中随机返回一个值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [1, 2, 3, 4, 5];\r\n    \r\n    $random = Arr::random($array);\r\n    \r\n    // 4 - (retrieved randomly)\r\n\r\n你还可以指定返回值的数量作为可选的第二个参数传递给该方法，请注意，提供这个参数会返回一个数组，即使是你只需要一项：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $items = Arr::random($array, 2);\r\n    \r\n    // [2, 5] - (retrieved randomly)\r\n\r\n<a name=\"method-array-set\"></a>\r\n#### `Arr::set()` {.collection-method}\r\n\r\n`Arr::set` 方法使用「.」符号在多维数组中设置指定键的值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['products' => ['desk' => ['price' => 100]]];\r\n    \r\n    Arr::set($array, 'products.desk.price', 200);\r\n    \r\n    // ['products' => ['desk' => ['price' => 200]]]\r\n\r\n<a name=\"method-array-shuffle\"></a>\r\n#### `Arr::shuffle()` {.collection-method}\r\n\r\n`Arr::shuffle` 方法将数组中值进行随机排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = Arr::shuffle([1, 2, 3, 4, 5]);\r\n    \r\n    // [3, 2, 5, 1, 4] - (generated randomly)\r\n\r\n<a name=\"method-array-sort\"></a>\r\n#### `Arr::sort()` {.collection-method}\r\n\r\n`Arr::sort` 方法根据给定数组的值进行升序排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['Desk', 'Table', 'Chair'];\r\n    \r\n    $sorted = Arr::sort($array);\r\n    \r\n    // ['Chair', 'Desk', 'Table']\r\n\r\n你还可以根据给定回调方法的返回结果对数组进行排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        ['name' => 'Desk'],\r\n        ['name' => 'Table'],\r\n        ['name' => 'Chair'],\r\n    ];\r\n    \r\n    $sorted = array_values(Arr::sort($array, function (array $value) {\r\n        return $value['name'];\r\n    }));\r\n    \r\n    /*\r\n        [\r\n            ['name' => 'Chair'],\r\n            ['name' => 'Desk'],\r\n            ['name' => 'Table'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-array-sort-desc\"></a>\r\n#### `Arr::sortDesc()` {.collection-method}\r\n\r\n`Arr::sortDesc`  方法根据给定数组的值进行降序排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = ['Desk', 'Table', 'Chair'];\r\n    \r\n    $sorted = Arr::sortDesc($array);\r\n    \r\n    // ['Table', 'Desk', 'Chair']\r\n\r\n你还可以根据给定回调方法的返回结果对数组进行排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        ['name' => 'Desk'],\r\n        ['name' => 'Table'],\r\n        ['name' => 'Chair'],\r\n    ];\r\n    \r\n    $sorted = array_values(Arr::sortDesc($array, function (array $value) {\r\n        return $value['name'];\r\n    }));\r\n    \r\n    /*\r\n        [\r\n            ['name' => 'Table'],\r\n            ['name' => 'Desk'],\r\n            ['name' => 'Chair'],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-array-sort-recursive\"></a>\r\n#### `Arr::sortRecursive()` {.collection-method}\r\n\r\n`Arr::sortRecursive` 方法对给定数组进行递归排序，使用 `sort` 方法对数字索引子数组进行按值升序排序，使用 `ksort` 方法对关联子数组进行按键升序排序：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        ['Roman', 'Taylor', 'Li'],\r\n        ['PHP', 'Ruby', 'JavaScript'],\r\n        ['one' => 1, 'two' => 2, 'three' => 3],\r\n    ];\r\n    \r\n    $sorted = Arr::sortRecursive($array);\r\n    \r\n    /*\r\n        [\r\n            ['JavaScript', 'PHP', 'Ruby'],\r\n            ['one' => 1, 'three' => 3, 'two' => 2],\r\n            ['Li', 'Roman', 'Taylor'],\r\n        ]\r\n    */\r\n\r\n\r\n\r\n<a name=\"method-array-to-css-classes\"></a>\r\n#### `Arr::toCssClasses()` {.collection-method}\r\n\r\n`Arr::toCssClasses` 方法根据给定的条件编译并返回 CSS 类字符串。该方法接受一个类数组，其中数组键包含你希望添加的一个或多个 CSS Class，而值是一个布尔表达式。如果数组元素有一个数字键，它将始终包含在呈现的类列表中：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $isActive = false;\r\n    $hasError = true;\r\n    \r\n    $array = ['p-4', 'font-bold' => $isActive, 'bg-red' => $hasError];\r\n    \r\n    $classes = Arr::toCssClasses($array);\r\n    \r\n    /*\r\n        'p-4 bg-red'\r\n    */\r\n\r\nLaravel 基于该方法实现 [Blade 组件里的条件合并类](/docs/laravel/10.x/blademd#conditionally-merge-classes) 以及 `@class` [Blade 指令](/docs/laravel/10.x/blademd#conditional-classes)：\r\n\r\n<a name=\"method-array-undot\"></a>\r\n#### `Arr::undot()` {.collection-method}\r\n\r\n`Arr::undot` 方法使用「.」符号将一维数组扩展为多维数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [\r\n        'user.name' => 'Kevin Malone',\r\n        'user.occupation' => 'Accountant',\r\n    ];\r\n    \r\n    $array = Arr::undot($array);\r\n    \r\n    // ['user' => ['name' => 'Kevin Malone', 'occupation' => 'Accountant']]\r\n\r\n<a name=\"method-array-where\"></a>\r\n\r\n#### `Arr::where()` {.collection-method}\r\n\r\n`Arr::where` 方法使用给定的回调函数返回的结果过滤数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [100, '200', 300, '400', 500];\r\n    \r\n    $filtered = Arr::where($array, function (string|int $value, int $key) {\r\n        return is_string($value);\r\n    });\r\n    \r\n    // [1 => '200', 3 => '400']\r\n\r\n<a name=\"method-array-where-not-null\"></a>\r\n#### `Arr::whereNotNull()` {.collection-method}\r\n\r\n`Arr::whereNotNull` 方法将从给定数组中删除所有 `null` 值：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = [0, null];\r\n    \r\n    $filtered = Arr::whereNotNull($array);\r\n    \r\n    // [0 => 0]\r\n\r\n<a name=\"method-array-wrap\"></a>\r\n#### `Arr::wrap()` {.collection-method}\r\n\r\n`Arr::wrap` 方法可以将给定值转换为一个数组，如果给定的值已经是一个数组，它将原样返回：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $string = 'Laravel';\r\n    \r\n    $array = Arr::wrap($string);\r\n    \r\n    // ['Laravel']\r\n\r\n如果给定值是 `null` ，将返回一个空数组：\r\n\r\n    use Illuminate\\Support\\Arr;\r\n    \r\n    $array = Arr::wrap(null);\r\n    \r\n    // []\r\n\r\n<a name=\"method-data-fill\"></a>\r\n#### `data_fill()` {#collection-method}\r\n\r\n`data_fill` 函数使用「.」符号给多维数组或对象设置缺少的值：\r\n\r\n    $data = ['products' => ['desk' => ['price' => 100]]];\r\n    \r\n    data_fill($data, 'products.desk.price', 200);\r\n    \r\n    // ['products' => ['desk' => ['price' => 100]]]\r\n    \r\n    data_fill($data, 'products.desk.discount', 10);\r\n    \r\n    // ['products' => ['desk' => ['price' => 100, 'discount' => 10]]]\r\n\r\n也可以接收 「\\*」 作为通配符，设置相应缺少的值：\r\n\r\n    $data = [\r\n        'products' => [\r\n            ['name' => 'Desk 1', 'price' => 100],\r\n            ['name' => 'Desk 2'],\r\n        ],\r\n    ];\r\n    \r\n    data_fill($data, 'products.*.price', 200);\r\n    \r\n    /*\r\n        [\r\n            'products' => [\r\n                ['name' => 'Desk 1', 'price' => 100],\r\n                ['name' => 'Desk 2', 'price' => 200],\r\n            ],\r\n        ]\r\n    */\r\n\r\n<a name=\"method-data-get\"></a>\r\n#### `data_get()` {#collection-method}\r\n\r\n`data_get` 函数使用 「.」 符号从多维数组或对象中根据指定键检索值\r\n\r\n    $data = ['products' => ['desk' => ['price' => 100]]];\r\n    \r\n    $price = data_get($data, 'products.desk.price');\r\n    \r\n    // 100\r\n\r\n`data_get` 函数也接受一个默认值，如果没有找到指定的键，将返回默认值：\r\n\r\n    $discount = data_get($data, 'products.desk.discount', 0);\r\n    \r\n    // 0\r\n\r\n该函数还接受「\\*」作为通配符，来指向数组或对象的任何键：\r\n\r\n    $data = [\r\n        'product-one' => ['name' => 'Desk 1', 'price' => 100],\r\n        'product-two' => ['name' => 'Desk 2', 'price' => 150],\r\n    ];\r\n    \r\n    data_get($data, '*.name');\r\n    \r\n    // ['Desk 1', 'Desk 2'];\r\n\r\n<a name=\"method-data-set\"></a>\r\n#### `data_set()` {#collection-method}\r\n\r\n`data_set` 函数使用「.」符号从多维数组或对象中根据指定键设置值：\r\n\r\n    $data = ['products' => ['desk' => ['price' => 100]]];\r\n    \r\n    data_set($data, 'products.desk.price', 200);\r\n    \r\n    // ['products' => ['desk' => ['price' => 200]]]\r\n\r\n同 `data_get` 一样，函数也支持使用「\\*」 作为通配符给相应键名赋值：\r\n\r\n    $data = [\r\n        'products' => [\r\n            ['name' => 'Desk 1', 'price' => 100],\r\n            ['name' => 'Desk 2', 'price' => 150],\r\n        ],\r\n    ];\r\n    \r\n    data_set($data, 'products.*.price', 200);\r\n    \r\n    /*\r\n        [\r\n            'products' => [\r\n                ['name' => 'Desk 1', 'price' => 200],\r\n                ['name' => 'Desk 2', 'price' => 200],\r\n            ],\r\n        ]\r\n    */\r\n\r\n通常情况下，已存在的值将会被覆盖。如果只是希望设置一个目前不存在的值，你可以增加一个 `false` 作为函数的第四个参数：\r\n\r\n    $data = ['products' => ['desk' => ['price' => 100]]];\r\n    \r\n    data_set($data, 'products.desk.price', 200, overwrite: false);\r\n    \r\n    // ['products' => ['desk' => ['price' => 100]]]\r\n\r\n<a name=\"method-head\"></a>\r\n#### `head()` {#collection-method}\r\n\r\n`head` 函数将返回数组中的第一个值：\r\n\r\n    $array = [100, 200, 300];\r\n    \r\n    $first = head($array);\r\n    \r\n    // 100\r\n\r\n<a name=\"method-last\"></a>\r\n\r\n#### `last()` {.collection-method}\r\n\r\n`last` 函数将返回数组中的最后一个值：\r\n\r\n    $array = [100, 200, 300];\r\n    \r\n    $last = last($array);\r\n    \r\n    // 300\r\n\r\n<a name=\"paths\"></a>\r\n## 路径\r\n\r\n<a name=\"method-app-path\"></a>\r\n#### `app_path()` {.collection-method}\r\n\r\n`app_path` 函数返回 `app` 目录的完整路径。你也可以使用 `app_path` 函数来生成应用目录下特定文件的完整路径：\r\n\r\n    $path = app_path();\r\n    \r\n    $path = app_path('Http/Controllers/Controller.php');\r\n\r\n<a name=\"method-base-path\"></a>\r\n#### `base_path()` {#collection-method}\r\n\r\n`base_path` 函数返回项目根目录的完整路径。你也可以使用 `base_path` 函数生成项目根目录下特定文件的完整路径：\r\n\r\n    $path = base_path();\r\n    \r\n    $path = base_path('vendor/bin');\r\n\r\n<a name=\"method-config-path\"></a>\r\n#### `config_path()` {#collection-method}\r\n\r\n`config_path` 函数返回项目配置目录 (config) 的完整路径。你也可以使用 `config_path` 函数来生成应用配置目录中的特定文件的完整路径：\r\n\r\n    $path = config_path();\r\n    \r\n    $path = config_path('app.php');\r\n\r\n<a name=\"method-database-path\"></a>\r\n#### `database_path()` {.collection-method}\r\n\r\n`database_path` 函数返回 `database` 目录的完整路径。你可以使用 `database_path` 函数来生成数据库目录下指定文件的完整路径：\r\n\r\n    $path = database_path();\r\n    \r\n    $path = database_path('factories/UserFactory.php');\r\n\r\n<a name=\"method-lang-path\"></a>\r\n#### `lang_path()` {.collection-method}\r\n\r\nThe `lang_path` 函数返回 `lang` 目录的完整路径。你可以使用 `lang_path`  函数来生成自定义语言目录下指定文件的完整路径：\r\n\r\n    $path = lang_path();\r\n    \r\n    $path = lang_path('en/messages.php');\r\n\r\n> **注意**\r\n> 默认情况下，Laravel 框架不包含 `lang` 目录。如果你想自定义 Laravel 的语言文件，可以通过 Artisan 命令 `lang:publish` 来发布它们。\r\n\r\n<a name=\"method-mix\"></a>\r\n#### `mix()` {.collection-method}\r\n\r\n`mix` 函数返回 [编译前端资源（Mix）的路径](/docs/laravel/10.x/mix)，便于加载 css，js 等静态文件：\r\n\r\n    $path = mix('css/app.css');\r\n\r\n<a name=\"method-public-path\"></a>\r\n#### `public_path()` {.collection-method}\r\n\r\n`public_path` 函数返回 `public` 目录的完整路径。你可以使用 `public_path` 函数来生成`public` 目录下指定文件的完整路径：\r\n\r\n    $path = public_path();\r\n    \r\n    $path = public_path('css/app.css');\r\n\r\n<a name=\"method-resource-path\"></a>\r\n#### `resource_path()` {.collection-method}\r\n\r\n`resource_path` 函数返回 `resource` 目录的完整路径。你可以使用 `resource_path` 函数来生成位于资源路径中指定文件的完整路径：\r\n\r\n    $path = resource_path();\r\n    \r\n    $path = resource_path('sass/app.scss');\r\n\r\n<a name=\"method-storage-path\"></a>\r\n#### `storage_path()`\r\n\r\n`storage_path` 函数返回 `storage` 目录的完整路径。 你也可以用 `storage_path` 函数来生成位于资源路径中的特定文件路径\r\n\r\n    $path = storage_path();\r\n    \r\n    $path = storage_path('app/file.txt');\r\n\r\n<a name=\"strings\"></a>\r\n\r\n## 字符串\r\n\r\n<a name=\"method-__\"></a>\r\n\r\n#### `__()`\r\n\r\n`__`函数可使用 [本地化文件](/docs/laravel/10.x/localization) 来翻译指定的字符串或特定的 key\r\n\r\n    echo __('Welcome to our application');\r\n    \r\n    echo __('messages.welcome');\r\n\r\n如果给定翻译的字符串或者 key 不存在， 则 `__` 会返回你指定的值。所以上述例子中， 如果给定翻译的字符串或者 key 不存在，则 `__` 函数会返回 `messages.welcome`。\r\n\r\n<a name=\"method-class-basename\"></a>\r\n\r\n#### `class_basename()`\r\n\r\n`class_basename` 函数返回不带命名空间的特定类的类名：\r\n\r\n    $class = class_basename('Foo\\Bar\\Baz');\r\n    \r\n    // Baz\r\n\r\n<a name=\"method-e\"></a>\r\n\r\n#### `e()`\r\n\r\n`e` 函数运行 PHP 的 `htmlspecialchars` 函数，且 `double_encode` 默认设定为 `true`：\r\n\r\n    echo e('<html>foo</html>');\r\n    \r\n    // &lt;html&gt;foo&lt;/html&gt;\r\n\r\n<a name=\"method-preg-replace-array\"></a>\r\n\r\n#### `preg_replace_array()` {.collection-method}\r\n\r\n`preg_replace_array` 函数按数组顺序替换字符串中符合给定模式的字符：\r\n\r\n    $string = 'The event will take place between :start and :end';\r\n    \r\n    $replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);\r\n    \r\n    // The event will take place between 8:30 and 9:00\r\n\r\n<a name=\"method-str-after\"></a>\r\n\r\n#### `Str::after()`\r\n\r\n`Str::after` 方法返回字符串中指定值之后的所有内容。如果字符串中不存在这个值，它将返回整个字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::after('This is my name', 'This is');\r\n    \r\n    // ' my name'\r\n\r\n\r\n\r\n<a name=\"method-str-after-last\"></a>\r\n\r\n#### `Str::afterLast()`\r\n\r\n`Str::afterLast` 方法返回字符串中指定值最后一次出现后的所有内容。如果字符串中不存在这个值，它将返回整个字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::afterLast('App\\Http\\Controllers\\Controller', '\\\\');\r\n    \r\n    // 'Controller'\r\n\r\n<a name=\"method-str-ascii\"></a>\r\n\r\n#### `Str::ascii()`\r\n\r\n`Str::ascii` 方法尝试将字符串转换为 ASCII 值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::ascii('û');\r\n    \r\n    // 'u'\r\n\r\n<a name=\"method-str-before\"></a>\r\n\r\n#### `Str::before()`\r\n\r\n`Str::before` 方法返回字符串中指定值之前的所有内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::before('This is my name', 'my name');\r\n    \r\n    // 'This is '\r\n\r\n<a name=\"method-str-before-last\"></a>\r\n\r\n#### `Str::beforeLast()`\r\n\r\n`Str::beforeLast` 方法返回字符串中指定值最后一次出现前的所有内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::beforeLast('This is my name', 'is');\r\n    \r\n    // 'This '\r\n\r\n<a name=\"method-str-between\"></a>\r\n\r\n#### `Str::between()`\r\n\r\n`Str::between` 方法返回字符串在指定两个值之间的内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::between('This is my name', 'This', 'name');\r\n    \r\n    // ' is my '\r\n\r\n<a name=\"method-str-between-first\"></a>\r\n\r\n#### `Str::betweenFirst()`\r\n\r\n `Str::betweenFirst` 方法返回字符串在指定两个值之间的最小可能的部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::betweenFirst('[a] bc [d]', '[', ']');\r\n    \r\n    // 'a'\r\n\r\n<a name=\"method-camel-case\"></a>\r\n\r\n#### `Str::camel()`\r\n\r\n`Str::camel` 方法将指定字符串转换为 `驼峰式` 表示方法：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::camel('foo_bar');\r\n    \r\n    // fooBar\r\n\r\n\r\n\r\n<a name=\"method-str-contains\"></a>\r\n\r\n#### `Str::contains()`\r\n\r\n`Str::contains` 方法判断指定字符串中是否包含另一指定字符串（区分大小写）：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $contains = Str::contains('This is my name', 'my');\r\n    \r\n    // true\r\n\r\n你也可以传递一个数组来判断指定字符串是否包含数组中的任一值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $contains = Str::contains('This is my name', ['my', 'foo']);\r\n    \r\n    // true\r\n\r\n<a name=\"method-str-contains-all\"></a>\r\n#### `Str::containsAll()`\r\n\r\n`Str::containsAll` 方法用于判断指定字符串是否包含指定数组中的所有值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $containsAll = Str::containsAll('This is my name', ['my', 'name']);\r\n    \r\n    // true\r\n\r\n<a name=\"method-ends-with\"></a>\r\n#### `Str::endsWith()`\r\n\r\n`Str::endsWith` 方法用于判断指定字符串是否以另一指定字符串结尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::endsWith('This is my name', 'name');\r\n    \r\n    // true\r\n\r\n你也可以传一个数组来判断指定字符串是否以指定数组中的任一值结尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::endsWith('This is my name', ['name', 'foo']);\r\n    \r\n    // true\r\n    \r\n    $result = Str::endsWith('This is my name', ['this', 'foo']);\r\n    \r\n    // false\r\n\r\n<a name=\"method-excerpt\"></a>\r\n#### `Str::excerpt()`\r\n\r\n`Str::excerpt` 方法提取字符串中给定短语匹配到的第一个片段：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $excerpt = Str::excerpt('This is my name', 'my', [\r\n        'radius' => 3\r\n    ]);\r\n    \r\n    // '...is my na...'\r\n\r\n`radius` 选项默认为 `100`，允许你定义应出现在截断字符串前后的字符数。\r\n\r\n此外，你可以使用`omission`选项来定义将附加到截断字符串的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $excerpt = Str::excerpt('This is my name', 'name', [\r\n        'radius' => 3,\r\n        'omission' => '(...) '\r\n    ]);\r\n    \r\n    // '(...) my name'\r\n\r\n<a name=\"method-str-finish\"></a>\r\n\r\n#### `Str::finish()` {.collection-method}\r\n\r\n`Str::finish`方法将指定的字符串修改为以指定的值结尾的形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $adjusted = Str::finish('this/string', '/');\r\n    \r\n    // this/string/\r\n    \r\n    $adjusted = Str::finish('this/string/', '/');\r\n    \r\n    // this/string/\r\n\r\n<a name=\"method-str-headline\"></a>\r\n#### `Str::headline()` {.collection-method}\r\n\r\n`Str::headline`方法会将由大小写、连字符或下划线分隔的字符串转换为空格分隔的字符串，同时保证每个单词的首字母大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $headline = Str::headline('steve_jobs');\r\n    \r\n    // Steve Jobs\r\n    \r\n    $headline = Str::headline('邮件通知发送');\r\n    \r\n    // 邮件通知发送\r\n\r\n<a name=\"method-str-inline-markdown\"></a>\r\n#### `Str::inlineMarkdown()` {.collection-method}\r\n\r\n`Str::inlineMarkdown`方法使用[通用标记](https://commonmark.thephpleague.com/)将 GitHub 风味 Markdown 转换为内联 HTML。然而，与`markdown`方法不同的是，它不会将所有生成的 HTML 都包装在块级元素中:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $html = Str::inlineMarkdown('**Laravel**');\r\n    \r\n    // <strong>Laravel</strong>\r\n\r\n<a name=\"method-str-is\"></a>\r\n#### `Str::is()` {.collection-method}\r\n\r\n`Str::is`方法用来判断字符串是否与指定模式匹配。星号`*`可用于表示通配符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $matches = Str::is('foo*', 'foobar');\r\n    \r\n    // true\r\n    \r\n    $matches = Str::is('baz*', 'foobar');\r\n    \r\n    // false\r\n\r\n<a name=\"method-str-is-ascii\"></a>\r\n#### `Str::isAscii()` {.collection-method}\r\n\r\n`Str::isAscii`方法用于判断字符串是否是 7 位 ASCII：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $isAscii = Str::isAscii('Taylor');\r\n    \r\n    // true\r\n    \r\n    $isAscii = Str::isAscii('ü');\r\n    \r\n    // false\r\n\r\n<a name=\"method-str-is-json\"></a>\r\n#### `Str::isJson()` {.collection-method}\r\n\r\n`Str::isJson`方法确定给定的字符串是否是有效的 JSON：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::isJson('[1,2,3]');\r\n    \r\n    // true\r\n    \r\n    $result = Str::isJson('{\"first\": \"John\", \"last\": \"Doe\"}');\r\n    \r\n    // true\r\n    \r\n    $result = Str::isJson('{first: \"John\", last: \"Doe\"}');\r\n    \r\n    // false\r\n\r\n<a name=\"method-str-is-ulid\"></a>\r\n#### `Str::isUlid()` {.collection-method}\r\n\r\n`Str::isUlid`方法用于判断指定字符串是否是有效的 ULID：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $isUlid = Str::isUlid('01gd6r360bp37zj17nxb55yv40');\r\n    \r\n    // true\r\n    \r\n    $isUlid = Str::isUlid('laravel');\r\n    \r\n    // false\r\n\r\n<a name=\"method-str-is-uuid\"></a>\r\n#### `Str::isUuid()` {.collection-method}\r\n\r\n`Str::isUuid`方法用于判断指定字符串是否是有效的 UUID：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');\r\n    \r\n    // true\r\n    \r\n    $isUuid = Str::isUuid('laravel');\r\n    \r\n    // false\r\n\r\n<a name=\"method-kebab-case\"></a>\r\n#### `Str::kebab()` {.collection-method}\r\n\r\n`Str::kebab`方法将字符串转换为`烤串式（ kebab-case ）`表示方法：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::kebab('fooBar');\r\n    \r\n    // foo-bar\r\n\r\n<a name=\"method-str-lcfirst\"></a>\r\n#### `Str::lcfirst()` {.collection-method}\r\n\r\n`Str::lcfirst`方法返回第一个小写字符的给定字符串:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::lcfirst('Foo Bar');\r\n    \r\n    // foo Bar\r\n\r\n<a name=\"method-str-length\"></a>\r\n#### `Str::length()` {.collection-method}\r\n\r\n`Str::length`方法返回指定字符串的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $length = Str::length('Laravel');\r\n    \r\n    // 7\r\n\r\n<a name=\"method-str-limit\"></a>\r\n#### `Str::limit()` {.collection-method}\r\n\r\n`Str::limit`方法将字符串以指定长度进行截断：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $truncated = Str::limit('敏捷的棕色狐狸跳过懒惰的狗', 20);\r\n    \r\n    // 敏捷的棕色狐狸...\r\n\r\n你也可通过第三个参数来改变追加到末尾的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $truncated = Str::limit('敏捷的棕色狐狸跳过懒惰的狗', 20, ' (...)');\r\n    \r\n    // 敏捷的棕色狐狸 (...)\r\n\r\n<a name=\"method-str-lower\"></a>\r\n#### `Str::lower()` {.collection-method}\r\n\r\n`Str::lower`方法用于将字符串转换为小写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::lower('LARAVEL');\r\n    \r\n    // laravel\r\n\r\n<a name=\"method-str-markdown\"></a>\r\n#### `Str::markdown()` {.collection-method}\r\n\r\n`Str::markdown`方法将 GitHub 风格的 Markdown 转换为 HTML 使用 [通用标记](https://commonmark.thephpleague.com/):\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $html = Str::markdown('# Laravel');\r\n    \r\n    // <h1>Laravel</h1>\r\n    \r\n    $html = Str::markdown('# Taylor <b>Otwell</b>', [\r\n        'html_input' => 'strip',\r\n    ]);\r\n    \r\n    // <h1>Taylor Otwell</h1>\r\n\r\n<a name=\"method-str-mask\"></a>\r\n#### `Str::mask()` {.collection-method}\r\n\r\n`Str::mask`方法会使用重复的字符掩盖字符串的一部分，并可用于混淆字符串段，例如电子邮件地址和电话号码：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::mask('taylor@example.com', '*', 3);\r\n    \r\n    // tay***************\r\n\r\n你可以提供一个负数作为`mask`方法的第三个参数，这将指示该方法在距字符串末尾的给定距离处开始屏蔽：\r\n\r\n    $string = Str::mask('taylor@example.com', '*', -15, 3);\r\n    \r\n    // tay***@example.com\r\n\r\n<a name=\"method-str-ordered-uuid\"></a>\r\n#### `Str::orderedUuid()` {.collection-method}\r\n\r\n`Str::orderedUuid`方法用于生成一个「时间戳优先」的 UUID ，它可作为数据库索引列的有效值。使用此方法生成的每个 UUID 将排在之前使用该方法生成的 UUID 后面：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    return (string) Str::orderedUuid();\r\n\r\n<a name=\"method-str-padboth\"></a>\r\n#### `Str::padBoth()` {.collection-method}\r\n\r\n`Str::padBoth`方法包装了 PHP 的`str_pad 方法`，在指定字符串的两侧填充上另一字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $padded = Str::padBoth('James', 10, '_');\r\n    \r\n    // '__James___'\r\n    \r\n    $padded = Str::padBoth('James', 10);\r\n    \r\n    // '  James   '\r\n\r\n<a name=\"method-str-padleft\"></a>\r\n#### `Str::padLeft()` {.collection-method}\r\n\r\n`Str::padLeft`方法包装了 PHP 的`str_pad`方法，在指定字符串的左侧填充上另一字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $padded = Str::padLeft('James', 10, '-=');\r\n    \r\n    // '-=-=-James'\r\n    \r\n    $padded = Str::padLeft('James', 10);\r\n    \r\n    // '     James'\r\n\r\n<a name=\"method-str-padright\"></a>\r\n#### `Str::padRight()` {.collection-method}\r\n\r\n`Str::padRight`方法包装了 PHP 的`str_pad`方法，在指定字符串的右侧填充上另一字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $padded = Str::padRight('James', 10, '-');\r\n    \r\n    // 'James-----'\r\n    \r\n    $padded = Str::padRight('James', 10);\r\n    \r\n    // 'James     '\r\n\r\n<a name=\"method-str-password\"></a>\r\n#### `Str::password()` {.collection-method}\r\n\r\n`Str::password`方法可用于生成给定长度的安全随机密码。密码由字母、数字、符号和空格组成。默认情况下，密码长度为32位:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $password = Str::password();\r\n    \r\n    // 'EbJo2vE-AS:U,$%_gkrV4n,q~1xy/-_4'\r\n    \r\n    $password = Str::password(12);\r\n    \r\n    // 'qwuar>#V|i]N'\r\n\r\n<a name=\"method-str-plural\"></a>\r\n#### `Str::plural()` {.collection-method}\r\n\r\n`Str::plural`方法将单数形式的字符串转换为复数形式。此方法支持 [Laravel 复数形式所支持的任何语言](/docs/laravel/10.x/localizationmd#pluralization-language)：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $plural = Str::plural('car');\r\n    \r\n    // cars\r\n    \r\n    $plural = Str::plural('child');\r\n    \r\n    // children\r\n\r\n你可以提供一个整数作为方法的第二个参数来检索字符串的单数或复数形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $plural = Str::plural('child', 2);\r\n    \r\n    // children\r\n    \r\n    $singular = Str::plural('child', 1);\r\n    \r\n    // child\r\n\r\n<a name=\"method-str-plural-studly\"></a>\r\n#### `Str::pluralStudly()` {.collection-method}\r\n\r\n`Str::pluralStudly`方法将以驼峰格式的单数字符串转化为其复数形式。此方法支持 [Laravel 复数形式所支持的任何语言](/docs/laravel/10.x/localization#pluralization-language)：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $plural = Str::pluralStudly('VerifiedHuman');\r\n    \r\n    // VerifiedHumans\r\n    \r\n    $plural = Str::pluralStudly('UserFeedback');\r\n    \r\n    // UserFeedback\r\n\r\n你可以提供一个整数作为方法的第二个参数来检索字符串的单数或复数形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $plural = Str::pluralStudly('VerifiedHuman', 2);\r\n    \r\n    // VerifiedHumans\r\n    \r\n    $singular = Str::pluralStudly('VerifiedHuman', 1);\r\n    \r\n    // VerifiedHuman\r\n\r\n<a name=\"method-str-random\"></a>\r\n#### `Str::random()` {.collection-method}\r\n\r\n`Str::random` 方法用于生成指定长度的随机字符串。这个方法使用了PHP的 `random_bytes` 函数：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $random = Str::random(40);\r\n\r\n<a name=\"method-str-remove\"></a>\r\n#### `Str::remove()` {.collection-method}\r\n\r\n`Str::remove` 方法从字符串中删除给定值或给定数组内的所有值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = 'Peter Piper picked a peck of pickled peppers.';\r\n    \r\n    $removed = Str::remove('e', $string);\r\n    \r\n    // Ptr Pipr pickd a pck of pickld ppprs.\r\n\r\n你还可以将`false`作为第三个参数传递给`remove`方法以在删除字符串时忽略大小写。\r\n\r\n<a name=\"method-str-replace\"></a>\r\n#### `Str::replace()` {.collection-method}\r\n\r\n`Str::replace` 方法用于替换字符串中的给定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = 'Laravel 10.x';\r\n    \r\n    $replaced = Str::replace('9.x', '10.x', $string);\r\n    \r\n    // Laravel 10.x\r\n\r\n<a name=\"method-str-replace-array\"></a>\r\n#### `Str::replaceArray()` {.collection-method}\r\n\r\n`Str::replaceArray` 方法使用数组有序的替换字符串中的特定字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = '该活动将在 ? 至 ? 举行';\r\n    \r\n    $replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);\r\n    \r\n    // 该活动将在 8:30 至 9:00 举行\r\n\r\n<a name=\"method-str-replace-first\"></a>\r\n#### `Str::replaceFirst()` {.collection-method}\r\n\r\n`Str::replaceFirst` 方法替换字符串中给定值的第一个匹配项：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');\r\n    \r\n    // a quick brown fox jumps over the lazy dog\r\n\r\n<a name=\"method-str-replace-last\"></a>\r\n#### `Str::replaceLast()` {.collection-method}\r\n\r\n`Str::replaceLast` 方法替换字符串中最后一次出现的给定值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');\r\n    \r\n    // the quick brown fox jumps over a lazy dog\r\n\r\n<a name=\"method-str-reverse\"></a>\r\n#### `Str::reverse()` {.collection-method}\r\n\r\n`Str::reverse` 方法用于反转给定的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $reversed = Str::reverse('Hello World');\r\n    \r\n    // dlroW olleH\r\n\r\n<a name=\"method-str-singular\"></a>\r\n#### `Str::singular()` {.collection-method}\r\n\r\n`Str::singular` 方法将字符串转换为单数形式。此方法支持 [Laravel 复数形式所支持的任何语言](/docs/laravel/10.x/localizationmd#pluralization-language)：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $singular = Str::singular('cars');\r\n    \r\n    // car\r\n    \r\n    $singular = Str::singular('children');\r\n    \r\n    // child\r\n\r\n<a name=\"method-str-slug\"></a>\r\n#### `Str::slug()` {.collection-method}\r\n\r\n`Str::slug` 方法将给定的字符串生成一个 URL 友好的「slug」：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slug = Str::slug('Laravel 10 Framework', '-');\r\n    \r\n    // laravel-10-framework\r\n\r\n<a name=\"method-snake-case\"></a>\r\n#### `Str::snake()` {.collection-method}\r\n\r\n`Str::snake` 方法是将驼峰的函数名或者字符串转换成 `_` 命名的函数或者字符串，例如 `snakeCase` 转换成 `snake_case`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::snake('fooBar');\r\n    \r\n    // foo_bar\r\n    \r\n    $converted = Str::snake('fooBar', '-');\r\n    \r\n    // foo-bar\r\n\r\n<a name=\"method-str-squish\"></a>\r\n#### `Str::squish()` {.collection-method}\r\n\r\n`Str::squish`方法删除字符串中所有多余的空白，包括单词之间多余的空白:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::squish('    laravel    framework    ');\r\n    \r\n    // laravel framework\r\n\r\n<a name=\"method-str-start\"></a>\r\n#### `Str::start()` {.collection-method}\r\n\r\n`Str::start`方法是将给定的值添加到字符串的开始位置，例如：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $adjusted = Str::start('this/string', '/');\r\n    \r\n    // /this/string\r\n    \r\n    $adjusted = Str::start('/this/string', '/');\r\n    \r\n    // /this/string\r\n\r\n<a name=\"method-starts-with\"></a>\r\n#### `Str::startsWith()` {.collection-method}\r\n\r\n`Str::startsWith`方法用来判断给定的字符串是否为给定值的开头：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::startsWith('This is my name', 'This');\r\n    \r\n    // true\r\n\r\n如果传递了一个可能值的数组且字符串以任何给定值开头，则`startsWith`方法将返回`true`：\r\n\r\n    $result = Str::startsWith('This is my name', ['This', 'That', 'There']);\r\n    \r\n    // true\r\n\r\n<a name=\"method-studly-case\"></a>\r\n#### `Str::studly()` {.collection-method}\r\n\r\n`Str::studly`方法将给定的字符串转换为`驼峰命名`的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::studly('foo_bar');\r\n    \r\n    // FooBar\r\n\r\n<a name=\"method-str-substr\"></a>\r\n#### `Str::substr()` {.collection-method}\r\n\r\n`Str::substr`方法返回由 start 和 length 参数指定的字符串部分:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::substr('The Laravel Framework', 4, 7);\r\n    \r\n    // Laravel\r\n\r\n<a name=\"method-str-substrcount\"></a>\r\n#### `Str::substrCount()` {.collection-method}\r\n\r\n`Str::substrCount` 方法返回给定字符串中给定值的出现次数：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $count = Str::substrCount('If you like ice cream, you will like snow cones.', 'like');\r\n    \r\n    // 2\r\n\r\n<a name=\"method-str-substrreplace\"></a>\r\n#### `Str::substrReplace()` {.collection-method}\r\n\r\n`Str::substrReplace` 方法替换字符串一部分中的文本，从第三个参数指定的位置开始，替换第四个参数指定的字符数。 当「0」传递给方法的第四个参数将在指定位置插入字符串，而不是替换字符串中的任何现有字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::substrReplace('1300', ':', 2);\r\n    // 13:\r\n    \r\n    $result = Str::substrReplace('1300', ':', 2, 0);\r\n    // 13:00\r\n\r\n<a name=\"method-str-swap\"></a>\r\n#### `Str::swap()` {.collection-method}\r\n\r\n`Str::swap` 方法使用 PHP 的 `strtr` 函数替换给定字符串中的多个值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::swap([\r\n        'Tacos' => 'Burritos',\r\n        'great' => 'fantastic',\r\n    ], 'Tacos are great!');\r\n    \r\n    // Burritos are fantastic！\r\n\r\n<a name=\"method-title-case\"></a>\r\n#### `Str::title()` {.collection-method}\r\n\r\n`Str::title` 方法将给定的字符串转换为 `Title Case`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::title('a nice title uses the correct case');\r\n    \r\n    // A Nice Title Uses The Correct Case\r\n\r\n<a name=\"method-str-to-html-string\"></a>\r\n#### `Str::toHtmlString()` {.collection-method}\r\n\r\n`Str::toHtmlString` 方法将字符串实例转换为 `Illuminate\\Support\\HtmlString` 的实例，它可以显示在 Blade 模板中：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $htmlString = Str::of('Nuno Maduro')->toHtmlString();\r\n\r\n<a name=\"method-str-ucfirst\"></a>\r\n#### `Str::ucfirst()` {.collection-method}\r\n\r\n`Str::ucfirst` 方法返回第一个字符大写的给定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::ucfirst('foo bar');\r\n    \r\n    // Foo bar\r\n\r\n<a name=\"method-str-ucsplit\"></a>\r\n#### `Str::ucsplit()` {.collection-method}\r\n\r\n`Str::ucsplit` 方法将给定的字符串按大写字符拆分为数组：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $segments = Str::ucsplit('FooBar');\r\n    \r\n    // [0 => 'Foo', 1 => 'Bar']\r\n\r\n<a name=\"method-str-upper\"></a>\r\n#### `Str::upper()` {.collection-method}\r\n\r\n`Str::upper` 方法将给定的字符串转换为大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::upper('laravel');\r\n    \r\n    // LARAVEL\r\n\r\n<a name=\"method-str-ulid\"></a>\r\n#### `Str::ulid()` {.collection-method}\r\n\r\n`Str::ulid` 方法生成一个 ULID：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    return (string) Str::ulid();\r\n    \r\n    // 01gd6r360bp37zj17nxb55yv40\r\n\r\n<a name=\"method-str-uuid\"></a>\r\n#### `Str::uuid()` {.collection-method}\r\n\r\n`Str::uuid` 方法生成一个 UUID（版本 4）：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    return (string) Str::uuid();\r\n\r\n<a name=\"method-str-word-count\"></a>\r\n#### `Str::wordCount()` {.collection-method}\r\n\r\n`Str::wordCount` 方法返回字符串包含的单词数\r\n\r\n```php\r\nuse Illuminate\\Support\\Str;\r\n\r\nStr::wordCount('Hello, world!'); // 2\r\n```\r\n\r\n<a name=\"method-str-words\"></a>\r\n#### `Str::words()` {.collection-method}\r\n\r\n`Str::words` 方法限制字符串中的单词数。 可以通过其第三个参数将附加字符串传递给此方法，以指定应将这个字符串附加到截断后的字符串末尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    return Str::words('Perfectly balanced, as all things should be.', 3, ' >>>');\r\n    \r\n    // Perfectly balanced, as >>>\r\n\r\n<a name=\"method-str\"></a>\r\n#### `str()` {.collection-method}\r\n\r\n`str` 函数返回给定字符串的新 `Illuminate\\Support\\Stringable` 实例。 此函数等效于 `Str::of` 方法：\r\n\r\n    $string = str('Taylor')->append(' Otwell');\r\n    \r\n    // 'Taylor Otwell'\r\n\r\n如果没有为 `str` 函数提供参数，该函数将返回 `Illuminate\\Support\\Str` 的实例：\r\n\r\n    $snake = str()->snake('FooBar');\r\n    \r\n    // 'foo_bar'\r\n\r\n<a name=\"method-trans\"></a>\r\n#### `trans()` {.collection-method}\r\n\r\n`trans` 函数使用你的 [语言文件](/docs/laravel/10.x/localization) 翻译给定的翻译键：\r\n\r\n```\r\n     echo trans('messages.welcome');\r\n```\r\n\r\n如果指定的翻译键不存在，`trans` 函数将返回给定的键。 因此，使用上面的示例，如果翻译键不存在，`trans` 函数将返回 `messages.welcome`。\r\n\r\n<a name=\"method-trans-choice\"></a>\r\n\r\n#### `trans_choice()` {.collection-method}\r\n\r\n`trans_choice` 函数用词形变化翻译给定的翻译键：\r\n\r\n```\r\n     echo trans_choice('messages.notifications', $unreadCount);\r\n```\r\n\r\n如果指定的翻译键不存在，`trans_choice` 函数将返回给定的键。 因此，使用上面的示例，如果翻译键不存在，`trans_choice` 函数将返回 `messages.notifications`。\r\n\r\n<a name=\"fluent-strings\"></a>\r\n## 字符流处理\r\n\r\nFluent strings 提供了一个更流畅的、面向对象的接口来处理字符串值，与传统的字符串操作相比，允许你使用更易读的语法将多个字符串操作链接在一起。\r\n\r\n<a name=\"method-fluent-str-after\"></a>\r\n#### `after` {.collection-method}\r\n\r\n`after` 方法返回字符串中给定值之后的所有内容。 如果字符串中不存在该值，则将返回整个字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::of('This is my name')->after('This is');\r\n    \r\n    // ' my name'\r\n\r\n<a name=\"method-fluent-str-after-last\"></a>\r\n#### `afterLast` {.collection-method}\r\n\r\n`afterLast` 方法返回字符串中最后一次出现给定值之后的所有内容。 如果字符串中不存在该值，则将返回整个字符串\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::of('App\\Http\\Controllers\\Controller')->afterLast('\\\\');\r\n    \r\n    // 'Controller'\r\n\r\n<a name=\"method-fluent-str-append\"></a>\r\n#### `append` {.collection-method}\r\n\r\n`append` 方法将给定的值附加到字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('Taylor')->append(' Otwell');\r\n    \r\n    // 'Taylor Otwell'\r\n\r\n<a name=\"method-fluent-str-ascii\"></a>\r\n#### `ascii` {.collection-method}\r\n\r\n`ascii` 方法将尝试将字符串音译为 ASCII 值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('ü')->ascii();\r\n    \r\n    // 'u'\r\n\r\n<a name=\"method-fluent-str-basename\"></a>\r\n#### `basename` {.collection-method}\r\n\r\n`basename` 方法将返回给定字符串的结尾名称部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('/foo/bar/baz')->basename();\r\n    \r\n    // 'baz'\r\n\r\n如果需要，你可以提供将从尾随组件中删除的「扩展名」：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('/foo/bar/baz.jpg')->basename('.jpg');\r\n    \r\n    // 'baz'\r\n\r\n<a name=\"method-fluent-str-before\"></a>\r\n#### `before` {.collection-method}\r\n\r\n`before` 方法返回字符串中给定值之前的所有内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::of('This is my name')->before('my name');\r\n    \r\n    // 'This is '\r\n\r\n<a name=\"method-fluent-str-before-last\"></a>\r\n#### `beforeLast` {.collection-method}\r\n\r\n`beforeLast` 方法返回字符串中最后一次出现给定值之前的所有内容：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slice = Str::of('This is my name')->beforeLast('is');\r\n    \r\n    // 'This '\r\n\r\n<a name=\"method-fluent-str-between\"></a>\r\n#### `between` {.collection-method}\r\n\r\n`between` 方法返回两个值之间的字符串部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::of('This is my name')->between('This', 'name');\r\n    \r\n    // ' is my '\r\n\r\n<a name=\"method-fluent-str-between-first\"></a>\r\n#### `betweenFirst` {.collection-method}\r\n\r\n`betweenFirst` 方法返回两个值之间字符串的最小可能部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::of('[a] bc [d]')->betweenFirst('[', ']');\r\n    \r\n    // 'a'\r\n\r\n<a name=\"method-fluent-str-camel\"></a>\r\n#### `camel` {.collection-method}\r\n\r\n`camel` 方法将给定的字符串转换为 `camelCase`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::of('foo_bar')->camel();\r\n    \r\n    // fooBar\r\n\r\n<a name=\"method-fluent-str-class-basename\"></a>\r\n#### `classBasename` {.collection-method}\r\n\r\n`classBasename` 方法返回给定类的类名，删除了类的命名空间：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $class = Str::of('Foo\\Bar\\Baz')->classBasename();\r\n    \r\n    // Baz\r\n\r\n<a name=\"method-fluent-str-contains\"></a>\r\n#### `contains` {.collection-method}\r\n\r\n`contains` 方法确定给定的字符串是否包含给定的值。 此方法区分大小写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $contains = Str::of('This is my name')->contains('my');\r\n    \r\n    // true\r\n\r\n你还可以传递一个值数组来确定给定字符串是否包含数组中的任意值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $contains = Str::of('This is my name')->contains(['my', 'foo']);\r\n    \r\n    // true\r\n\r\n<a name=\"method-fluent-str-contains-all\"></a>\r\n#### `containsAll` {.collection-method}\r\n\r\n`containsAll` 方法确定给定字符串是否包含给定数组中的所有值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $containsAll = Str::of('This is my name')->containsAll(['my', 'name']);\r\n    \r\n    // true\r\n\r\n<a name=\"method-fluent-str-dirname\"></a>\r\n#### `dirname` {.collection-method}\r\n\r\n`dirname` 方法返回给定字符串的父目录部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('/foo/bar/baz')->dirname();\r\n    \r\n    // '/foo/bar'\r\n\r\n如有必要，你还可以指定要从字符串中删除多少目录级别：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('/foo/bar/baz')->dirname(2);\r\n    \r\n    // '/foo'\r\n\r\n<a name=\"method-fluent-str-excerpt\"></a>\r\n#### `excerpt` {.collection-method}\r\n\r\n`excerpt` 方法从字符串中提取与该字符串中短语的第一个实例匹配的摘录：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $excerpt = Str::of('This is my name')->excerpt('my', [\r\n        'radius' => 3\r\n    ]);\r\n    \r\n    // '...is my na...'\r\n\r\n`radius` 选项默认为 `100`，允许你定义应出现在截断字符串每一侧的字符数。\r\n\r\n此外，还可以使用 `omission` 选项更改将添加到截断字符串之前和附加的字符串\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $excerpt = Str::of('This is my name')->excerpt('name', [\r\n        'radius' => 3,\r\n        'omission' => '(...) '\r\n    ]);\r\n    \r\n    // '(...) my name'\r\n\r\n<a name=\"method-fluent-str-ends-with\"></a>\r\n#### `endsWith` {.collection-method}\r\n\r\n`endsWith` 方法确定给定字符串是否以给定值结尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('This is my name')->endsWith('name');\r\n    \r\n    // true\r\n\r\n你还可以传递一个值数组来确定给定字符串是否以数组中的任何值结尾：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('This is my name')->endsWith(['name', 'foo']);\r\n    \r\n    // true\r\n    \r\n    $result = Str::of('This is my name')->endsWith(['this', 'foo']);\r\n    \r\n    // false\r\n\r\n<a name=\"method-fluent-str-exactly\"></a>\r\n#### `exactly` {.collection-method}\r\n\r\n`exactly` 方法确定给定的字符串是否与另一个字符串完全匹配：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('Laravel')->exactly('Laravel');\r\n    \r\n    // true\r\n\r\n<a name=\"method-fluent-str-explode\"></a>\r\n#### `explode` {.collection-method}\r\n\r\n`explode` 方法按给定的分隔符拆分字符串并返回包含拆分字符串的每个部分的集合：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $collection = Str::of('foo bar baz')->explode(' ');\r\n    \r\n    // collect(['foo', 'bar', 'baz'])\r\n\r\n<a name=\"method-fluent-str-finish\"></a>\r\n#### `finish` {.collection-method}\r\n\r\n`finish` 方法将给定值的单个实例添加到字符串中（如果它尚未以该值结尾）：\r\n    use Illuminate\\Support\\Str;\r\n\r\n    $adjusted = Str::of('this/string')->finish('/');\r\n    \r\n    // this/string/\r\n    \r\n    $adjusted = Str::of('this/string/')->finish('/');\r\n    \r\n    // this/string/\r\n\r\n<a name=\"method-fluent-str-headline\"></a>\r\n#### `headline` {.collection-method}\r\n\r\n`headline` 方法会将由大小写、连字符或下划线分隔的字符串转换为空格分隔的字符串，每个单词的首字母大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $headline = Str::of('taylor_otwell')->headline();\r\n    \r\n    // Taylor Otwell\r\n    \r\n    $headline = Str::of('EmailNotificationSent')->headline();\r\n    \r\n    // Email Notification Sent\r\n\r\n<a name=\"method-fluent-str-inline-markdown\"></a>\r\n#### `inlineMarkdown` {.collection-method}\r\n\r\n`inlineMarkdown` 方法使用 [CommonMark](https://commonmark.thephpleague.com/) 将 GitHub 风格的 Markdown 转换为内联 HTML。 但是，与 `markdown` 方法不同，它不会将所有生成的 HTML 包装在块级元素中：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $html = Str::of('**Laravel**')->inlineMarkdown();\r\n    \r\n    // <strong>Laravel</strong>\r\n\r\n<a name=\"method-fluent-str-is\"></a>\r\n#### `is` {.collection-method}\r\n\r\n`is` 方法确定给定字符串是否与给定模式匹配。 星号可用作通配符值\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $matches = Str::of('foobar')->is('foo*');\r\n    \r\n    // true\r\n    \r\n    $matches = Str::of('foobar')->is('baz*');\r\n    \r\n    // false\r\n\r\n<a name=\"method-fluent-str-is-ascii\"></a>\r\n#### `isAscii` {.collection-method}\r\n\r\n`isAscii` 方法确定给定字符串是否为 ASCII 字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('Taylor')->isAscii();\r\n    \r\n    // true\r\n    \r\n    $result = Str::of('ü')->isAscii();\r\n    \r\n    // false\r\n\r\n<a name=\"method-fluent-str-is-empty\"></a>\r\n#### `isEmpty` {.collection-method}\r\n\r\n`isEmpty` 方法确定给定的字符串是否为空：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('  ')->trim()->isEmpty();\r\n    \r\n    // true\r\n    \r\n    $result = Str::of('Laravel')->trim()->isEmpty();\r\n    \r\n    // false\r\n\r\n<a name=\"method-fluent-str-is-not-empty\"></a>\r\n#### `isNotEmpty` {.collection-method}\r\n\r\n`isNotEmpty` 方法确定给定的字符串是否不为空：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('  ')->trim()->isNotEmpty();\r\n    \r\n    // false\r\n    \r\n    $result = Str::of('Laravel')->trim()->isNotEmpty();\r\n    \r\n    // true\r\n\r\n<a name=\"method-fluent-str-is-json\"></a>\r\n#### `isJson` {.collection-method}\r\n\r\n`isJson` 方法确定给定的字符串是否是有效的 JSON:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('[1,2,3]')->isJson();\r\n    \r\n    // true\r\n    \r\n    $result = Str::of('{\"first\": \"John\", \"last\": \"Doe\"}')->isJson();\r\n    \r\n    // true\r\n    \r\n    $result = Str::of('{first: \"John\", last: \"Doe\"}')->isJson();\r\n    \r\n    // false\r\n\r\n<a name=\"method-fluent-str-is-ulid\"></a>\r\n#### `isUlid` {.collection-method}\r\n\r\n`isUlid` 方法确定给定的字符串是否一个 ULID:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('01gd6r360bp37zj17nxb55yv40')->isUlid();\r\n    \r\n    // true\r\n    \r\n    $result = Str::of('Taylor')->isUlid();\r\n    \r\n    // false\r\n\r\n<a name=\"method-fluent-str-is-uuid\"></a>\r\n#### `isUuid` {.collection-method}\r\n\r\n`isUuid` 方法确定给定的字符串是否是一个 UUID:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('5ace9ab9-e9cf-4ec6-a19d-5881212a452c')->isUuid();\r\n    \r\n    // true\r\n    \r\n    $result = Str::of('Taylor')->isUuid();\r\n    \r\n    // false\r\n\r\n<a name=\"method-fluent-str-kebab\"></a>\r\n#### `kebab` {.collection-method}\r\n\r\n`kebab` 方法转变给定的字符串为 `kebab-case`:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::of('fooBar')->kebab();\r\n    \r\n    // foo-bar\r\n\r\n<a name=\"method-fluent-str-lcfirst\"></a>\r\n\r\n#### `lcfirst` {.collection-method}\r\n\r\n`lcfirst` 方法返回给定的字符串的第一个字符为小写字母:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('Foo Bar')->lcfirst();\r\n    \r\n    // foo Bar\r\n\r\n<a name=\"method-fluent-str-length\"></a>\r\n\r\n#### `length` {.collection-method}\r\n\r\n`length` 方法返回给定字符串的长度:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $length = Str::of('Laravel')->length();\r\n    \r\n    // 7\r\n\r\n<a name=\"method-fluent-str-limit\"></a>\r\n#### `limit` {.collection-method}\r\n\r\n`limit` 方法将给定的字符串截断为指定的长度:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $truncated = Str::of('The quick brown fox jumps over the lazy dog')->limit(20);\r\n    \r\n    // The quick brown fox...\r\n\r\n你也可以通过第二个参数来改变追加到末尾的字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $truncated = Str::of('The quick brown fox jumps over the lazy dog')->limit(20, ' (...)');\r\n    \r\n    // The quick brown fox (...)\r\n\r\n<a name=\"method-fluent-str-lower\"></a>\r\n#### `lower`\r\n\r\n`lower` 方法将指定字符串转换为小写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('LARAVEL')->lower();\r\n    \r\n    // 'laravel'\r\n\r\n<a name=\"method-fluent-str-ltrim\"></a>\r\n#### `ltrim`\r\n\r\n`ltrim` 方法移除字符串左端指定的字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('  Laravel  ')->ltrim();\r\n    \r\n    // 'Laravel  '\r\n    \r\n    $string = Str::of('/Laravel/')->ltrim('/');\r\n    \r\n    // 'Laravel/'\r\n\r\n<a name=\"method-fluent-str-markdown\"></a>\r\n\r\n#### `markdown` {.collection-method}\r\n`markdown` 方法将 Github 风格的 Markdown 转换为 HTML：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $html = Str::of('# Laravel')->markdown();\r\n    \r\n    // <h1>Laravel</h1>\r\n    \r\n    $html = Str::of('# Taylor <b>Otwell</b>')->markdown([\r\n        'html_input' => 'strip',\r\n    ]);\r\n    \r\n    // <h1>Taylor Otwell</h1>\r\n\r\n<a name=\"method-fluent-str-mask\"></a>\r\n#### `mask`\r\n\r\n`mask` 方法用重复字符掩盖字符串的一部分，可用于模糊处理字符串的某些段，例如电子邮件地址和电话号码：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('taylor@example.com')->mask('*', 3);\r\n    \r\n    // tay***************\r\n\r\n需要的话，你可以提供一个负数作为 `mask` 方法的第三或第四个参数，这将指示该方法在距字符串末尾的给定距离处开始屏蔽：\r\n\r\n    $string = Str::of('taylor@example.com')->mask('*', -15, 3);\r\n    \r\n    // tay***@example.com\r\n    \r\n    $string = Str::of('taylor@example.com')->mask('*', 4, -4);\r\n    \r\n    // tayl**********.com\r\n\r\n<a name=\"method-fluent-str-match\"></a>\r\n#### `match`\r\n\r\n`match` 方法将会返回字符串中和指定正则表达式匹配的部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('foo bar')->match('/bar/');\r\n    \r\n    // 'bar'\r\n    \r\n    $result = Str::of('foo bar')->match('/foo (.*)/');\r\n    \r\n    // 'bar'\r\n\r\n<a name=\"method-fluent-str-match-all\"></a>\r\n#### `matchAll`\r\n\r\n`matchAll` 方法将会返回一个集合，该集合包含了字符串中与指定正则表达式匹配的部分\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('bar foo bar')->matchAll('/bar/');\r\n    \r\n    // collect(['bar', 'bar'])\r\n\r\n如果你在正则表达式中指定了一个匹配组， Laravel 将会返回与该组匹配的集合：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('bar fun bar fly')->matchAll('/f(\\w*)/');\r\n    \r\n    // collect(['un', 'ly']);\r\n\r\n如果没有找到任何匹配项，则返回空集合。\r\n\r\n<a name=\"method-fluent-str-is-match\"></a>\r\n#### `isMatch`\r\n\r\n`isMatch` 方法用于判断给定的字符串是否与正则表达式匹配：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('foo bar')->isMatch('/foo (.*)/');\r\n    \r\n    // true\r\n    \r\n    $result = Str::of('laravel')->match('/foo (.*)/');\r\n    \r\n    // false\r\n\r\n<a name=\"method-fluent-str-new-line\"></a>\r\n#### `newLine`\r\n\r\n`newLine` 方法将给字符串追加换行的字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $padded = Str::of('Laravel')->newLine()->append('Framework');\r\n    \r\n    // 'Laravel\r\n    //  Framework'\r\n\r\n<a name=\"method-fluent-str-padboth\"></a>\r\n#### `padBoth`\r\n\r\n`padBoth` 方法包装了 PHP 的 `str_pad` 函数，在指定字符串的两侧填充上另一字符串，直至该字符串到达指定的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $padded = Str::of('James')->padBoth(10, '_');\r\n    \r\n    // '__James___'\r\n    \r\n    $padded = Str::of('James')->padBoth(10);\r\n    \r\n    // '  James   '\r\n\r\n<a name=\"method-fluent-str-padleft\"></a>\r\n#### `padLeft`\r\n\r\nThe `padLeft` 方法包装了 PHP 的 `str_pad` 函数，在指定字符串的左侧填充上另一字符串，直至该字符串到达指定的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $padded = Str::of('James')->padLeft(10, '-=');\r\n    \r\n    // '-=-=-James'\r\n    \r\n    $padded = Str::of('James')->padLeft(10);\r\n    \r\n    // '     James'\r\n\r\n<a name=\"method-fluent-str-padright\"></a>\r\n#### `padRight`\r\n\r\n`padRight` 方法包装了 PHP 的 `str_pad` 函数，在指定字符串的右侧填充上另一字符串，直至该字符串到达指定的长度：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $padded = Str::of('James')->padRight(10, '-');\r\n    \r\n    // 'James-----'\r\n    \r\n    $padded = Str::of('James')->padRight(10);\r\n    \r\n    // 'James     '\r\n\r\n<a name=\"method-fluent-str-pipe\"></a>\r\n#### `pipe`\r\n\r\n`pipe` 方法将把字符串的当前值传递给指定的函数来转换字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $hash = Str::of('Laravel')->pipe('md5')->prepend('Checksum: ');\r\n    \r\n    // 'Checksum: a5c95b86291ea299fcbe64458ed12702'\r\n    \r\n    $closure = Str::of('foo')->pipe(function (Stringable $str) {\r\n        return 'bar';\r\n    });\r\n    \r\n    // 'bar'\r\n\r\n<a name=\"method-fluent-str-plural\"></a>\r\n#### `plural`\r\n\r\n`plural` 方法将单数形式的字符串转换为复数形式。该此函数支持 [Laravel的复数化器支持的任何语言](/docs/laravel/10.x/localizationmd#pluralization-language)\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $plural = Str::of('car')->plural();\r\n    \r\n    // cars\r\n    \r\n    $plural = Str::of('child')->plural();\r\n    \r\n    // children\r\n\r\n你也可以给该函数提供一个整数作为第二个参数，用于检索字符串的单数或复数形式：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $plural = Str::of('child')->plural(2);\r\n    \r\n    // children\r\n    \r\n    $plural = Str::of('child')->plural(1);\r\n    \r\n    // child\r\n\r\n<a name=\"method-fluent-str-prepend\"></a>\r\n#### `prepend`\r\n\r\n`prepend` 方法用于在指定字符串的开头插入另一指定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('Framework')->prepend('Laravel ');\r\n    \r\n    // Laravel Framework\r\n\r\n<a name=\"method-fluent-str-remove\"></a>\r\n#### `remove`\r\n\r\n`remove` 方法用于从字符串中删除给定的值或值数组：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('Arkansas is quite beautiful!')->remove('quite');\r\n    \r\n    // Arkansas is beautiful!\r\n\r\n你也可以传递 `false` 作为第二个参数以在删除字符串时忽略大小写。\r\n\r\n<a name=\"method-fluent-str-replace\"></a>\r\n#### `replace`\r\n\r\n`replace` 方法用于将字符串中的指定字符串替换为另一指定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $replaced = Str::of('Laravel 9.x')->replace('9.x', '10.x');\r\n    \r\n    // Laravel 10.x\r\n\r\n<a name=\"method-fluent-str-replace-array\"></a>\r\n#### `replaceArray`\r\n\r\n`replaceArray` 方法使用数组顺序替换字符串中的给定值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = 'The event will take place between ? and ?';\r\n    \r\n    $replaced = Str::of($string)->replaceArray('?', ['8:30', '9:00']);\r\n    \r\n    // The event will take place between 8:30 and 9:00\r\n\r\n<a name=\"method-fluent-str-replace-first\"></a>\r\n#### `replaceFirst`\r\n\r\n`replaceFirst` 方法替换字符串中给定值的第一个匹配项：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $replaced = Str::of('the quick brown fox jumps over the lazy dog')->replaceFirst('the', 'a');\r\n    \r\n    // a quick brown fox jumps over the lazy dog\r\n\r\n<a name=\"method-fluent-str-replace-last\"></a>\r\n#### `replaceLast`\r\n\r\n`replaceLast` 方法替换字符串中给定值的最后一个匹配项：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $replaced = Str::of('the quick brown fox jumps over the lazy dog')->replaceLast('the', 'a');\r\n    \r\n    // the quick brown fox jumps over a lazy dog\r\n\r\n<a name=\"method-fluent-str-replace-matches\"></a>\r\n#### `replaceMatches`\r\n\r\n`replaceMatches` 方法用给定的替换字符串替换与模式匹配的字符串的所有部分\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $replaced = Str::of('(+1) 501-555-1000')->replaceMatches('/[^A-Za-z0-9]++/', '')\r\n    \r\n    // '15015551000'\r\n\r\n`replaceMatches` 方法还接受一个闭包，该闭包将在字符串的每个部分与给定模式匹配时调用，从而允许你在闭包中执行替换逻辑并返回替换的值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $replaced = Str::of('123')->replaceMatches('/\\d/', function (Stringable $match) {\r\n        return '['.$match[0].']';\r\n    });\r\n    \r\n    // '[1][2][3]'\r\n\r\n<a name=\"method-fluent-str-rtrim\"></a>\r\n#### `rtrim`\r\n\r\n`rtrim` 方法修剪给定字符串的右侧：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('  Laravel  ')->rtrim();\r\n    \r\n    // '  Laravel'\r\n    \r\n    $string = Str::of('/Laravel/')->rtrim('/');\r\n    \r\n    // '/Laravel'\r\n\r\n<a name=\"method-fluent-str-scan\"></a>\r\n#### `scan`\r\n\r\n`scan` 方法根据 [PHP 函数 sscanf](https://www.php.net/manual/en/function.sscanf.php) 支持的格式把字符串中的输入解析为集合：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $collection = Str::of('filename.jpg')->scan('%[^.].%s');\r\n    \r\n    // collect(['filename', 'jpg'])\r\n\r\n<a name=\"method-fluent-str-singular\"></a>\r\n#### `singular`\r\n\r\n`singular` 方法将字符串转换为其单数形式。此函数支持 [Laravel的复数化器支持的任何语言](/docs/laravel/10.x/localizationmd#pluralization-language) ：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $singular = Str::of('cars')->singular();\r\n    \r\n    // car\r\n    \r\n    $singular = Str::of('children')->singular();\r\n    \r\n    // child\r\n\r\n<a name=\"method-fluent-str-slug\"></a>\r\n#### `slug` {.collection-method}\r\n\r\n`slug` 方法从给定字符串生成 URL 友好的 \"slug\"：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $slug = Str::of('Laravel Framework')->slug('-');\r\n    \r\n    // laravel-framework\r\n\r\n<a name=\"method-fluent-str-snake\"></a>\r\n#### `snake` {.collection-method}\r\n\r\n`snake` 方法将给定字符串转换为 `snake_case`\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::of('fooBar')->snake();\r\n    \r\n    // foo_bar\r\n\r\n<a name=\"method-fluent-str-split\"></a>\r\n#### `split` {.collection-method}\r\n\r\nsplit 方法使用正则表达式将字符串拆分为集合：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $segments = Str::of('one, two, three')->split('/[\\s,]+/');\r\n    \r\n    // collect([\"one\", \"two\", \"three\"])\r\n\r\n<a name=\"method-fluent-str-squish\"></a>\r\n#### `squish` {.collection-method}\r\n\r\n`squish` 方法删除字符串中所有无关紧要的空白,包括字符串之间的空白:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('    laravel    framework    ')->squish();\r\n    \r\n    // laravel framework\r\n\r\n<a name=\"method-fluent-str-start\"></a>\r\n#### `start` {.collection-method}\r\n\r\n`start` 方法将给定值的单个实例添加到字符串中，前提是该字符串尚未以该值开头：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $adjusted = Str::of('this/string')->start('/');\r\n    \r\n    // /this/string\r\n    \r\n    $adjusted = Str::of('/this/string')->start('/');\r\n    \r\n    // /this/string\r\n\r\n<a name=\"method-fluent-str-starts-with\"></a>\r\n#### `startsWith` {.collection-method}\r\n\r\n`startsWith` 方法确定给定字符串是否以给定值开头：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('This is my name')->startsWith('This');\r\n    \r\n    // true\r\n\r\n<a name=\"method-fluent-str-studly\"></a>\r\n#### `studly` {.collection-method}\r\n\r\n`studly` 方法将给定字符串转换为 `StudlyCase`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::of('foo_bar')->studly();\r\n    \r\n    // FooBar\r\n\r\n<a name=\"method-fluent-str-substr\"></a>\r\n#### `substr` {.collection-method}\r\n\r\n`substr` 方法返回由给定的起始参数和长度参数指定的字符串部分：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('Laravel Framework')->substr(8);\r\n    \r\n    // Framework\r\n    \r\n    $string = Str::of('Laravel Framework')->substr(8, 5);\r\n    \r\n    // Frame\r\n\r\n<a name=\"method-fluent-str-substrreplace\"></a>\r\n#### `substrReplace` {.collection-method}\r\n\r\n`substrReplace` 方法在字符串的一部分中替换文本，从第二个参数指定的位置开始替换第三个参数指定的字符数。将 `0` 传递给方法的第三个参数将在指定位置插入字符串，而不替换字符串中的任何现有字符：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('1300')->substrReplace(':', 2);\r\n    \r\n    // 13:\r\n    \r\n    $string = Str::of('The Framework')->substrReplace(' Laravel', 3, 0);\r\n    \r\n    // The Laravel Framework\r\n\r\n<a name=\"method-fluent-str-swap\"></a>\r\n#### `swap` {.collection-method}\r\n\r\n`swap` 方法使用 PHP 的 `strtr` 函数替换字符串中的多个值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('Tacos are great!')\r\n        ->swap([\r\n            'Tacos' => 'Burritos',\r\n            'great' => 'fantastic',\r\n        ]);\r\n    \r\n    // Burritos are fantastic!\r\n\r\n<a name=\"method-fluent-str-tap\"></a>\r\n\r\n#### `tap` {.collection-method}\r\n\r\n`tap` 方法将字符串传递给给定的闭包，允许你在不影响字符串本身的情况下检查字符串并与之交互。`tap` 方法返回原始字符串，而不管闭包返回什么：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('Laravel')\r\n        ->append(' Framework')\r\n        ->tap(function (Stringable $string) {\r\n            dump('String after append: '.$string);\r\n        })\r\n        ->upper();\r\n    \r\n    // LARAVEL FRAMEWORK\r\n\r\n<a name=\"method-fluent-str-test\"></a>\r\n#### `test` {.collection-method}\r\n\r\n`test` 方法确定字符串是否与给定的正则表达式模式匹配：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $result = Str::of('Laravel Framework')->test('/Laravel/');\r\n    \r\n    // true\r\n\r\n<a name=\"method-fluent-str-title\"></a>\r\n\r\n#### `title` {.collection-method}\r\n\r\n`title` 方法将给定字符串转换为 `title Case`：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $converted = Str::of('a nice title uses the correct case')->title();\r\n    \r\n    // A Nice Title Uses The Correct Case\r\n\r\n<a name=\"method-fluent-str-trim\"></a>\r\n#### `trim` {.collection-method}\r\n\r\n`trim` 方法修剪给定字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('  Laravel  ')->trim();\r\n    \r\n    // 'Laravel'\r\n    \r\n    $string = Str::of('/Laravel/')->trim('/');\r\n    \r\n    // 'Laravel'\r\n\r\n<a name=\"method-fluent-str-ucfirst\"></a>\r\n#### `ucfirst` {.collection-method}\r\n\r\n`ucfirst` 方法返回第一个字符大写的给定字符串\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('foo bar')->ucfirst();\r\n    \r\n    // Foo bar\r\n\r\n<a name=\"method-fluent-str-ucsplit\"></a>\r\n#### `ucsplit` {.collection-method}\r\n\r\n`ucsplit` 方法将给定的字符串按大写字符分割为一个集合:\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('Foo Bar')->ucsplit();\r\n    \r\n    // collect(['Foo', 'Bar'])\r\n\r\n<a name=\"method-fluent-str-upper\"></a>\r\n#### `upper` {.collection-method}\r\n\r\n`upper` 方法将给定字符串转换为大写：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $adjusted = Str::of('laravel')->upper();\r\n    \r\n    // LARAVEL\r\n\r\n<a name=\"method-fluent-str-when\"></a>\r\n#### `when` {.collection-method}\r\n\r\n如果给定的条件为 `true`，则 `when` 方法调用给定的闭包。闭包将接收一个流畅字符串实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('Taylor')\r\n                    ->when(true, function (Stringable $string) {\r\n                        return $string->append(' Otwell');\r\n                    });\r\n    \r\n    // 'Taylor Otwell'\r\n\r\n如果需要，可以将另一个闭包作为第三个参数传递给 `when` 方法。如果条件参数的计算结果为 `false`，则将执行此闭包。\r\n\r\n<a name=\"method-fluent-str-when-contains\"></a>\r\n#### `whenContains` {.collection-method}\r\n\r\n`whenContains` 方法会在字符串包含给定的值的前提下，调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('tony stark')\r\n                ->whenContains('tony', function (Stringable $string) {\r\n                    return $string->title();\r\n                });\r\n    \r\n    // 'Tony Stark'\r\n\r\n如有必要，你可以将另一个闭包作为第三个参数传递给 `whenContains` 方法。如果字符串不包含给定值，则此闭包将执行。\r\n\r\n你还可以传递一个值数组来确定给定的字符串是否包含数组中的任何值：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('tony stark')\r\n                ->whenContains(['tony', 'hulk'], function (Stringable $string) {\r\n                    return $string->title();\r\n                });\r\n    \r\n    // Tony Stark\r\n\r\n<a name=\"method-fluent-str-when-contains-all\"></a>\r\n#### `whenContainsAll` {.collection-method}\r\n\r\n`whenContainsAll` 方法会在字符串包含所有给定的子字符串时，调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('tony stark')\r\n                    ->whenContainsAll(['tony', 'stark'], function (Stringable $string) {\r\n                        return $string->title();\r\n                    });\r\n    \r\n    // 'Tony Stark'\r\n\r\n如有必要，你可以将另一个闭包作为第三个参数传递给 `whenContainsAll` 方法。如果条件参数评估为 `false`，则此闭包将执行。\r\n\r\n<a name=\"method-fluent-str-when-empty\"></a>\r\n#### `whenEmpty` {.collection-method}\r\n\r\n如果字符串为空，`whenEmpty` 方法将调用给定的闭包。如果闭包返回一个值，`whenEmpty` 方法也将返回该值。如果闭包不返回值，则将返回字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('  ')->whenEmpty(function (Stringable $string) {\r\n        return $string->trim()->prepend('Laravel');\r\n    });\r\n    \r\n    // 'Laravel'\r\n\r\n<a name=\"method-fluent-str-when-not-empty\"></a>\r\n#### `whenNotEmpty` {.collection-method}\r\n\r\n如果字符串不为空，`whenNotEmpty` 方法会调用给定的闭包。如果闭包返回一个值，那么 `whenNotEmpty` 方法也将返回该值。如果闭包没有返回值，则返回字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('Framework')->whenNotEmpty(function (Stringable $string) {\r\n        return $string->prepend('Laravel ');\r\n    });\r\n    \r\n    // 'Laravel Framework'\r\n\r\n<a name=\"method-fluent-str-when-starts-with\"></a>\r\n#### `whenStartsWith` {.collection-method}\r\n\r\n如果字符串以给定的子字符串开头，`whenStartsWith` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('disney world')->whenStartsWith('disney', function (Stringable $string) {\r\n        return $string->title();\r\n    });\r\n    \r\n    // 'Disney World'\r\n\r\n<a name=\"method-fluent-str-when-ends-with\"></a>\r\n#### `whenEndsWith` {.collection-method}\r\n\r\n如果字符串以给定的子字符串结尾，`whenEndsWith` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('disney world')->whenEndsWith('world', function (Stringable $string) {\r\n        return $string->title();\r\n    });\r\n    \r\n    // 'Disney World'\r\n\r\n<a name=\"method-fluent-str-when-exactly\"></a>\r\n#### `whenExactly` {.collection-method}\r\n\r\n如果字符串与给定字符串完全匹配，`whenExactly` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('laravel')->whenExactly('laravel', function (Stringable $string) {\r\n        return $string->title();\r\n    });\r\n    \r\n    // 'Laravel'\r\n\r\n<a name=\"method-fluent-str-when-not-exactly\"></a>\r\n#### `whenNotExactly` {.collection-method}\r\n\r\n如果字符串与给定字符串不完全匹配，`whenNotExactly`方法将调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('framework')->whenNotExactly('laravel', function (Stringable $string) {\r\n        return $string->title();\r\n    });\r\n    \r\n    // 'Framework'\r\n\r\n<a name=\"method-fluent-str-when-is\"></a>\r\n#### `whenIs` {.collection-method}\r\n\r\n如果字符串匹配给定的模式，`whenIs` 方法会调用给定的闭包。星号可用作通配符值。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('foo/bar')->whenIs('foo/*', function (Stringable $string) {\r\n        return $string->append('/baz');\r\n    });\r\n    \r\n    // 'foo/bar/baz'\r\n\r\n<a name=\"method-fluent-str-when-is-ascii\"></a>\r\n#### `whenIsAscii` {.collection-method}\r\n\r\n如果字符串是 7 位 ASCII，`whenIsAscii` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('laravel')->whenIsAscii(function (Stringable $string) {\r\n        return $string->title();\r\n    });\r\n    \r\n    // 'Laravel'\r\n\r\n<a name=\"method-fluent-str-when-is-ulid\"></a>\r\n#### `whenIsUlid` {.collection-method}\r\n\r\n如果字符串是有效的 ULID，`whenIsUlid` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('01gd6r360bp37zj17nxb55yv40')->whenIsUlid(function (Stringable $string) {\r\n        return $string->substr(0, 8);\r\n    });\r\n    \r\n    // '01gd6r36'\r\n\r\n<a name=\"method-fluent-str-when-is-uuid\"></a>\r\n#### `whenIsUuid` {.collection-method}\r\n\r\n如果字符串是有效的 UUID，`whenIsUuid` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('a0a2a2d2-0b87-4a18-83f2-2529882be2de')->whenIsUuid(function (Stringable $string) {\r\n        return $string->substr(0, 8);\r\n    });\r\n    \r\n    // 'a0a2a2d2'\r\n\r\n<a name=\"method-fluent-str-when-test\"></a>\r\n#### `whenTest` {.collection-method}\r\n\r\n如果字符串匹配给定的正则表达式，`whenTest` 方法会调用给定的闭包。闭包将接收字符流处理实例：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Support\\Stringable;\r\n    \r\n    $string = Str::of('laravel framework')->whenTest('/laravel/', function (Stringable $string) {\r\n        return $string->title();\r\n    });\r\n    \r\n    // 'Laravel Framework'\r\n\r\n<a name=\"method-fluent-str-word-count\"></a>\r\n#### `wordCount` {.collection-method}\r\n\r\n`wordCount` 方法返回字符串包含的单词数：\r\n\r\n```php\r\nuse Illuminate\\Support\\Str;\r\n\r\nStr::of('Hello, world!')->wordCount(); // 2\r\n```\r\n\r\n<a name=\"method-fluent-str-words\"></a>\r\n#### `words` {.collection-method}\r\n\r\n`words` 方法限制字符串中的字数。如有必要，可以指定附加到截断字符串的附加字符串：\r\n\r\n    use Illuminate\\Support\\Str;\r\n    \r\n    $string = Str::of('Perfectly balanced, as all things should be.')->words(3, ' >>>');\r\n    \r\n    // Perfectly balanced, as >>>\r\n\r\n<a name=\"urls\"></a>\r\n## URLs\r\n\r\n<a name=\"method-action\"></a>\r\n#### `action()` {.collection-method}\r\n\r\n`action` 函数为给定的控制器操作生成 URL：\r\n\r\n    use App\\Http\\Controllers\\HomeController;\r\n    \r\n    $url = action([HomeController::class, 'index']);\r\n\r\n如果该方法接受路由参数，则可以将它们作为第二个参数传递给该方法：\r\n\r\n    $url = action([UserController::class, 'profile'], ['id' => 1]);\r\n\r\n<a name=\"method-asset\"></a>\r\n#### `asset()` {.collection-method}\r\n\r\n`asset` 函数使用请求的当前方案（HTTP 或 HTTPS）生成 URL：\r\n\r\n    $url = asset('img/photo.jpg');\r\n\r\n你可以通过在`.env` 文件中设置 `ASSET_URL` 变量来配置资产 URL 主机。如果你将资产托管在外部服务（如 Amazon S3 或其他 CDN）上，这将非常有用：\r\n\r\n    // ASSET_URL=http://example.com/assets\r\n    \r\n    $url = asset('img/photo.jpg'); // http://example.com/assets/img/photo.jpg\r\n\r\n<a name=\"method-route\"></a>\r\n\r\n#### `route()` {.collection-method}\r\n\r\n`route` 函数为给定的 [命名路由](/docs/laravel/10.x/routingmd#named-routes)：\r\n\r\n    $url = route('route.name');\r\n\r\n如果路由接受参数，则可以将其作为第二个参数传递给函数：\r\n\r\n    $url = route('route.name', ['id' => 1]);\r\n\r\n默认情况下，`route` 函数会生成一个绝对路径的 URL。 如果想生成一个相对路径 URL，你可以传递 `false` 作为函数的第三个参数：\r\n\r\n    $url = route('route.name', ['id' => 1], false);\r\n\r\n<a name=\"method-secure-asset\"></a>\r\n#### `secure_asset()` {.collection-method}\r\n\r\n`secure_asset` 函数使用 HTTPS 为静态资源生成 URL：\r\n\r\n    $url = secure_asset('img/photo.jpg');\r\n\r\n<a name=\"method-secure-url\"></a>\r\n#### `secure_url()` {.collection-method}\r\n\r\n`secure_url` 函数生成给定路径的完全限定 HTTPS URL。 可以在函数的第二个参数中传递额外的 URL 段：\r\n\r\n    $url = secure_url('user/profile');\r\n    \r\n    $url = secure_url('user/profile', [1]);\r\n\r\n<a name=\"method-to-route\"></a>\r\n#### `to_route()` {.collection-method}\r\n\r\n`to_route` 函数为给定的 [命名路由](/docs/laravel/10.x/routingmd#named-routes) 生成一个 [重定向 HTTP 响应](/docs/laravel/10.x/responsesmd#redirects)：\r\n\r\n    return to_route('users.show', ['user' => 1]);\r\n\r\n如有必要，你可以将应分配给重定向的 HTTP 状态代码和任何其他响应标头作为第三个和第四个参数传递给 `to_route` 方法：\r\n\r\n    return to_route('users.show', ['user' => 1], 302, ['X-Framework' => 'Laravel']);\r\n\r\n<a name=\"method-url\"></a>\r\n#### `url()` {.collection-method}\r\n\r\n`url` 函数生成给定路径的完全限定 URL：\r\n\r\n    $url = url('user/profile');\r\n    \r\n    $url = url('user/profile', [1]);\r\n\r\n如果未提供路径，则返回一个 `Illuminate\\Routing\\UrlGenerator` 实例：\r\n\r\n    $current = url()->current();\r\n    \r\n    $full = url()->full();\r\n    \r\n    $previous = url()->previous();\r\n\r\n<a name=\"miscellaneous\"></a>\r\n## 杂项\r\n\r\n<a name=\"method-abort\"></a>\r\n#### `abort()` {.collection-method}\r\n\r\n使用`abort` 函数抛出一个 [HTTP 异常](/docs/laravel/10.x/errorsmd#http-exceptions) 交给 [异常处理](/docs/laravel/10.x/errorsmd#the-exception-handler \"异常处理程序\")\r\n\r\n    abort(403);\r\n\r\n你还可以提供应发送到浏览器的异常消息和自定义 HTTP 响应标头：\r\n\r\n    abort(403, 'Unauthorized.', $headers);\r\n\r\n<a name=\"method-abort-if\"></a>\r\n#### `abort_if()` {.collection-method}\r\n\r\n如果给定的布尔表达式的计算结果为 `true`，则 `abort_if` 函数会抛出 HTTP 异常：\r\n\r\n    abort_if(! Auth::user()->isAdmin(), 403);\r\n\r\n与 `abort` 方法一样，你还可以提供异常的响应文本作为函数的第三个参数，并提供自定义响应标头数组作为函数的第四个参数。\r\n\r\n<a name=\"method-abort-unless\"></a>\r\n#### `abort_unless()` {.collection-method}\r\n\r\n如果给定的布尔表达式的计算结果为 `false`，则 `abort_unless` 函数会抛出 HTTP 异常：\r\n\r\n    abort_unless(Auth::user()->isAdmin(), 403);\r\n\r\n与 `abort` 方法一样，你还可以提供异常的响应文本作为函数的第三个参数，并提供自定义响应标头数组作为函数的第四个参数。\r\n\r\n<a name=\"method-app\"></a>\r\n#### `app()` {.collection-method}\r\n\r\n`app` 函数返回 [服务容器](/docs/laravel/10.x/container) 实例：\r\n\r\n    $container = app();\r\n\r\n你可以传递一个类或接口名称以从容器中解析它：\r\n\r\n    $api = app('HelpSpot\\API');\r\n\r\n<a name=\"method-auth\"></a>\r\n#### `auth()` {.collection-method}\r\n\r\n`auth` 函数返回一个 [authenticator](/docs/laravel/10.x/authentication) 实例。 你可以将它用作 `Auth` 门面的替代品：\r\n\r\n    $user = auth()->user();\r\n\r\n如果需要，你可以指定要访问的守卫实例：\r\n\r\n    $user = auth('admin')->user();\r\n\r\n<a name=\"method-back\"></a>\r\n#### `back()` {.collection-method}\r\n\r\n`back` 函数生成一个 [重定向 HTTP 响应](/docs/laravel/10.x/responsesmd#redirects) 到用户之前的位置：\r\n\r\n    return back($status = 302, $headers = [], $fallback = '/');\r\n    \r\n    return back();\r\n\r\n<a name=\"method-bcrypt\"></a>\r\n#### `bcrypt()` {.collection-method}\r\n\r\n`bcrypt` 函数 [hashes](/docs/laravel/10.x/hashing) 使用 Bcrypt 的给定值。 您可以使用此函数作为 `Hash` 门面的替代方法：\r\n\r\n    $password = bcrypt('my-secret-password');\r\n\r\n<a name=\"method-blank\"></a>\r\n#### `blank()` {.collection-method}\r\n\r\n`blank` 函数确定给定值是否为「空白」：\r\n\r\n    blank('');\r\n    blank('   ');\r\n    blank(null);\r\n    blank(collect());\r\n    \r\n    // true\r\n    \r\n    blank(0);\r\n    blank(true);\r\n    blank(false);\r\n    \r\n    // false\r\n\r\n对于 `blank` 的反转，请参阅 [`filled`](#method-filled) 方法。\r\n\r\n<a name=\"method-broadcast\"></a>\r\n#### `broadcast()` {.collection-method}\r\n\r\n`broadcast` 函数 [broadcasts](/docs/laravel/10.x/broadcasting) 给定的 [event](/docs/laravel/10.x/events) 给它的听众：\r\n\r\n    broadcast(new UserRegistered($user));\r\n    \r\n    broadcast(new UserRegistered($user))->toOthers();\r\n\r\n<a name=\"method-cache\"></a>\r\n#### `cache()` {.collection-method}\r\n\r\n`cache` 函数可用于从 [cache](/docs/laravel/10.x/cache) 中获取值。 如果缓存中不存在给定的键，将返回一个可选的默认值：\r\n\r\n    $value = cache('key');\r\n    \r\n    $value = cache('key', 'default');\r\n\r\n你可以通过将键/值对数组传递给函数来将项目添加到缓存中。 你应该传递缓存值应被视为有效的秒数或持续时间：\r\n\r\n    cache(['key' => 'value'], 300);\r\n    \r\n    cache(['key' => 'value'], now()->addSeconds(10));\r\n\r\n<a name=\"method-class-uses-recursive\"></a>\r\n#### `class_uses_recursive()` {.collection-method}\r\n\r\n`class_uses_recursive` 函数返回一个类使用的所有特征，包括其所有父类使用的特征：\r\n\r\n    $traits = class_uses_recursive(App\\Models\\User::class);\r\n\r\n<a name=\"method-collect\"></a>\r\n#### `collect()` {.collection-method}\r\n\r\n`collect` 函数根据给定值创建一个 [collection](/docs/laravel/10.x/collections) 实例：\r\n\r\n    $collection = collect(['taylor', 'abigail']);\r\n\r\n<a name=\"method-config\"></a>\r\n#### `config()` {.collection-method}\r\n\r\n`config` 函数获取 [configuration](/docs/laravel/10.x/configuration) 变量的值。 可以使用「点」语法访问配置值，其中包括文件名和你希望访问的选项。 如果配置选项不存在，可以指定默认值并返回：\r\n\r\n    $value = config('app.timezone');\r\n    \r\n    $value = config('app.timezone', $default);\r\n\r\n你可以通过传递键/值对数组在运行时设置配置变量。 但是请注意，此函数只会影响当前请求的配置值，不会更新您的实际配置值：\r\n\r\n    config(['app.debug' => true]);\r\n\r\n<a name=\"method-cookie\"></a>\r\n#### `cookie()` {.collection-method}\r\n\r\n`cookie` 函数创建一个新的 [cookie](/docs/laravel/10.x/requestsmd#cookies) 实例：\r\n\r\n    $cookie = cookie('name', 'value', $minutes);\r\n\r\n<a name=\"method-csrf-field\"></a>\r\n#### `csrf_field()` {.collection-method}\r\n\r\n`csrf_field` 函数生成一个 HTML `hidden` 输入字段，其中包含 CSRF 令牌的值。 例如，使用 [Blade 语法](/docs/laravel/10.x/blade)：\r\n\r\n    {{ csrf_field() }}\r\n\r\n<a name=\"method-csrf-token\"></a>\r\n#### `csrf_token()` {.collection-method}\r\n\r\n`csrf_token` 函数检索当前 CSRF 令牌的值：\r\n\r\n    $token = csrf_token();\r\n\r\n<a name=\"method-decrypt\"></a>\r\n#### `decrypt()` {.collection-method}\r\n\r\n`decrypt` 函数 [解密](/docs/laravel/10.x/encryption) 给定的值。 你可以使用此函数作为 `Crypt` 门面的替代方法：\r\n\r\n    $password = decrypt($value);\r\n\r\n<a name=\"method-dd\"></a>\r\n#### `dd()` {.collection-method}\r\n\r\n`dd` 函数转储给定的变量并结束脚本的执行：\r\n\r\n    dd($value);\r\n    \r\n    dd($value1, $value2, $value3, ...);\r\n\r\n如果你不想停止脚本的执行，请改用 [`dump`](#method-dump) 函数。\r\n\r\n<a name=\"method-dispatch\"></a>\r\n#### `dispatch()` {.collection-method}\r\n\r\n`dispatch` 函数将给定的 [job](/docs/laravel/10.x/queuesmd#creating-jobs) 推送到 Laravel [job queue](/docs/laravel/10.x/queues)：\r\n\r\n    dispatch(new App\\Jobs\\SendEmails);\r\n\r\n<a name=\"method-dump\"></a>\r\n#### `dump()` {.collection-method}\r\n\r\n`dump` 函数转储给定的变量：\r\n\r\n    dump($value);\r\n    \r\n    dump($value1, $value2, $value3, ...);\r\n\r\n如果要在转储变量后停止执行脚本，请改用 [`dd`](#method-dd) 函数。\r\n\r\n<a name=\"method-encrypt\"></a>\r\n#### `encrypt()` {.collection-method}\r\n\r\n`encrypt` 函数 [encrypts](/docs/laravel/10.x/encryption) 给定值。 你可以使用此函数作为 `Crypt` 门面的替代方法：\r\n\r\n    $secret = encrypt('my-secret-value');\r\n\r\n<a name=\"method-env\"></a>\r\n#### `env()` {.collection-method}\r\n\r\n`env` 函数检索 [环境变量](/docs/laravel/10.x/configurationmd#environment-configuration) 的值或返回默认值：\r\n\r\n    $env = env('APP_ENV');\r\n    \r\n    $env = env('APP_ENV', 'production');\r\n\r\n> **警告**  \r\n> 如果你在部署过程中执行 `config:cache` 命令，你应该确保只从配置文件中调用 `env` 函数。 一旦配置被缓存，`.env` 文件将不会被加载，所有对 `env` 函数的调用都将返回 `null`。\r\n\r\n<a name=\"method-event\"></a>\r\n#### `event()` {.collection-method}\r\n\r\n`event` 函数将给定的 [event](/docs/laravel/10.x/events) 分派给它的监听器：\r\n\r\n    event(new UserRegistered($user));\r\n\r\n<a name=\"method-fake\"></a>\r\n#### `fake()` {.collection-method}\r\n\r\n`fake` 函数解析容器中的 [Faker](https://github.com/FakerPHP/Faker) 单例，这在模型工厂、数据库填充、测试和原型视图中创建假数据时非常有用：\r\n\r\n```blade\r\n@for($i = 0; $i < 10; $i++)\r\n    <dl>\r\n        <dt>Name</dt>\r\n        <dd>{{ fake()->name() }}</dd>\r\n\r\n        <dt>Email</dt>\r\n        <dd>{{ fake()->unique()->safeEmail() }}</dd>\r\n    </dl>\r\n@endfor\r\n```\r\n\r\n默认情况下，`fake` 函数将使用 `config/app.php` 配置文件中的 `app.faker_locale` 配置选项； 但是，你也可以通过将语言环境传递给 `fake` 函数来指定语言环境。 每个语言环境将解析一个单独的单例：\r\n\r\n    fake('nl_NL')->name()\r\n\r\n<a name=\"method-filled\"></a>\r\n#### `filled()` {.collection-method}\r\n\r\n`filled` 函数确定给定值是否不是「空白」：\r\n\r\n    filled(0);\r\n    filled(true);\r\n    filled(false);\r\n    \r\n    // true\r\n    \r\n    filled('');\r\n    filled('   ');\r\n    filled(null);\r\n    filled(collect());\r\n    \r\n    // false\r\n\r\n对于 `filled` 的反转，请参阅 [`blank`](#method-blank) 方法。\r\n\r\n<a name=\"method-info\"></a>\r\n#### `info()` {.collection-method}\r\n\r\n`info` 函数会将信息写入应用程序的 [log](/docs/laravel/10.x/logging)：\r\n\r\n    info('Some helpful information!');\r\n\r\n上下文数据数组也可以传递给函数：\r\n\r\n    info('User login attempt failed.', ['id' => $user->id]);\r\n\r\n<a name=\"method-logger\"></a>\r\n#### `logger()` {.collection-method}\r\n\r\n`logger` 函数可用于将 `debug` 级别的消息写入 [log](/docs/laravel/10.x/logging)：\r\n\r\n    logger('Debug message');\r\n\r\n上下文数据数组也可以传递给函数：\r\n\r\n    logger('User has logged in.', ['id' => $user->id]);\r\n\r\n如果没有值传递给函数，将返回一个 [logger](/docs/laravel/10.x/errorsmd#logging) 实例：\r\n\r\n    logger()->error('You are not allowed here.');\r\n\r\n<a name=\"method-method-field\"></a>\r\n#### `method_field()` {.collection-method}\r\n\r\n`method_field` 函数生成一个 HTML `hidden` 输入字段，其中包含表单 HTTP 谓词的欺骗值。 例如，使用 [Blade 语法](/docs/laravel/10.x/blade)：\r\n\r\n    <form method=\"POST\">\r\n        {{ method_field('DELETE') }}\r\n    </form>\r\n\r\n<a name=\"method-now\"></a>\r\n#### `now()` {.collection-method}\r\n\r\n`now` 函数为当前时间创建一个新的 `Illuminate\\Support\\Carbon` 实例：\r\n\r\n    $now = now();\r\n\r\n<a name=\"method-old\"></a>\r\n#### `old()` {.collection-method}\r\n\r\n`old` 函数 [retrieves](/docs/laravel/10.x/requestsmd#retrieving-input) 一个 [old input](/docs/laravel/10.x/requestsmd#old-input) 值闪入Session :\r\n\r\n    $value = old('value');\r\n    \r\n    $value = old('value', 'default');\r\n\r\n由于作为 `old` 函数的第二个参数提供的「默认值」通常是 Eloquent 模型的一个属性，Laravel 允许你简单地将整个 Eloquent 模型作为第二个参数传递给 `old` 函数。 这样做时，Laravel 将假定提供给 old 函数的第一个参数是 Eloquent 属性的名称，该属性应被视为「默认值」：\r\n\r\n    {{ old('name', $user->name) }}\r\n    \r\n    // 相当于...\r\n    \r\n    {{ old('name', $user) }}\r\n\r\n<a name=\"method-optional\"></a>\r\n#### `optional()` {.collection-method}\r\n\r\n`optional` 函数接受任何参数并允许您访问该对象的属性或调用方法。 如果给定对象为「null」，属性和方法将返回「null」而不是导致错误：\r\n\r\n    return optional($user->address)->street;\r\n    \r\n    {!! old('name', optional($user)->name) !!}\r\n\r\n`optional` 函数也接受一个闭包作为它的第二个参数。 如果作为第一个参数提供的值不为空，则将调用闭包：\r\n\r\n    return optional(User::find($id), function (User $user) {\r\n        return $user->name;\r\n    });\r\n\r\n<a name=\"method-policy\"></a>\r\n#### `policy()` {.collection-method}\r\n\r\n`policy` 方法检索给定类的 [policy](/docs/laravel/10.x/authorizationmd#creating-policies) 实例：\r\n\r\n    $policy = policy(App\\Models\\User::class);\r\n\r\n<a name=\"method-redirect\"></a>\r\n#### `redirect()` {.collection-method}\r\n\r\n`redirect` 函数返回一个[重定向 HTTP 响应](/docs/laravel/10.x/responsesmd#redirects)，或者如果不带参数调用则返回重定向器实例：\r\n\r\n    return redirect($to = null, $status = 302, $headers = [], $https = null);\r\n    \r\n    return redirect('/home');\r\n    \r\n    return redirect()->route('route.name');\r\n\r\n<a name=\"method-report\"></a>\r\n#### `report()` {.collection-method}\r\n\r\n`report` 函数将使用您的 [异常处理程序](/docs/laravel/10.x/errorsmd#the-exception-handler) 报告异常：\r\n\r\n    report($e);\r\n\r\n`report` 函数也接受一个字符串作为参数。 当给函数一个字符串时，该函数将创建一个异常，并将给定的字符串作为其消息：\r\n\r\n    report('Something went wrong.');\r\n\r\n<a name=\"method-report-if\"></a>\r\n#### `report_if()` {.collection-method}\r\n\r\n如果给定条件为「true」，「report_if」函数将使用您的 [异常处理程序](/docs/laravel/10.x/errorsmd#the-exception-handler) 报告异常：\r\n\r\n    report_if($shouldReport, $e);\r\n    \r\n    report_if($shouldReport, 'Something went wrong.');\r\n\r\n<a name=\"method-report-unless\"></a>\r\n#### `report_unless()` {.collection-method}\r\n\r\n如果给定条件为 `false`，`report_unless` 函数将使用你的 [异常处理程序](/docs/laravel/10.x/errorsmd#the-exception-handler) 报告异常：\r\n\r\n    report_unless($reportingDisabled, $e);\r\n    \r\n    report_unless($reportingDisabled, 'Something went wrong.');\r\n\r\n<a name=\"method-request\"></a>\r\n#### `request()` {.collection-method}\r\n\r\n`request` 函数返回当前的 [request](/docs/laravel/10.x/requests) 实例或从当前请求中获取输入字段的值：\r\n\r\n    $request = request();\r\n    \r\n    $value = request('key', $default);\r\n\r\n<a name=\"method-rescue\"></a>\r\n#### `rescue()` {.collection-method}\r\n\r\n`rescue` 函数执行给定的闭包并捕获其执行期间发生的任何异常。 捕获的所有异常都将发送到你的[异常处理程序](/docs/laravel/10.x/errorsmd#the-exception-handler)； 但是，请求将继续处理：\r\n\r\n    return rescue(function () {\r\n        return $this->method();\r\n    });\r\n\r\n你还可以将第二个参数传递给「rescue」函数。 如果在执行闭包时发生异常，这个参数将是应该返回的「默认」值：\r\n\r\n    return rescue(function () {\r\n        return $this->method();\r\n    }, false);\r\n    \r\n    return rescue(function () {\r\n        return $this->method();\r\n    }, function () {\r\n        return $this->failure();\r\n    });\r\n\r\n<a name=\"method-resolve\"></a>\r\n#### `resolve()` {.collection-method}\r\n\r\n`resolve` 函数使用 [服务容器](/docs/laravel/10.x/container) 将给定的类或接口名称解析为实例：\r\n\r\n    $api = resolve('HelpSpot\\API');\r\n\r\n<a name=\"method-response\"></a>\r\n#### `response()` {.collection-method}\r\n\r\n`response` 函数创建一个 [response](/docs/laravel/10.x/responses) 实例或获取响应工厂的实例：\r\n\r\n    return response('Hello World', 200, $headers);\r\n    \r\n    return response()->json(['foo' => 'bar'], 200, $headers);\r\n\r\n<a name=\"method-retry\"></a>\r\n#### `retry()` {.collection-method}\r\n\r\n`retry` 函数尝试执行给定的回调，直到达到给定的最大尝试阈值。 如果回调没有抛出异常，则返回它的返回值。 如果回调抛出异常，它会自动重试。 如果超过最大尝试次数，将抛出异常：\r\n\r\n    return retry(5, function () {\r\n        // 尝试 5 次，两次尝试之间休息 100 ms...\r\n    }, 100);\r\n\r\n如果想手动计算两次尝试之间休眠的毫秒数，你可以将闭包作为第三个参数传递给 `retry` 函数：\r\n\r\n    use Exception;\r\n    \r\n    return retry(5, function () {\r\n        // ...\r\n    }, function (int $attempt, Exception $exception) {\r\n        return $attempt * 100;\r\n    });\r\n\r\n为方便起见，你可以提供一个数组作为「retry」函数的第一个参数。 该数组将用于确定后续尝试之间要休眠多少毫秒：\r\n\r\n    return retry([100, 200], function () {\r\n        // 第一次重试时休眠 100 ms，第二次重试时休眠 200 ms...\r\n    });\r\n\r\n要仅在特定条件下重试，您可以将闭包作为第四个参数传递给 `retry` 函数：\r\n\r\n    use Exception;\r\n    \r\n    return retry(5, function () {\r\n        // ...\r\n    }, 100, function (Exception $exception) {\r\n        return $exception instanceof RetryException;\r\n    });\r\n\r\n<a name=\"method-session\"></a>\r\n#### `session()` {.collection-method}\r\n\r\n`session` 函数可用于获取或设置 [session](/docs/laravel/10.x/session) 值：\r\n\r\n    $value = session('key');\r\n\r\n你可以通过将键/值对数组传递给函数来设置值：\r\n\r\n    session(['chairs' => 7, 'instruments' => 3]);\r\n\r\n如果没有值传递给函数，会话存储将被返回：\r\n\r\n    $value = session()->get('key');\r\n    \r\n    session()->put('key', $value);\r\n\r\n<a name=\"method-tap\"></a>\r\n#### `tap()` {.collection-method}\r\n\r\n`tap` 函数接受两个参数：一个任意的 `$value` 和一个闭包。 `$value` 将传递给闭包，然后由 `tap` 函数返回。 闭包的返回值是无关紧要的：\r\n\r\n    $user = tap(User::first(), function (User $user) {\r\n        $user->name = 'taylor';\r\n    \r\n        $user->save();\r\n    });\r\n\r\n如果没有闭包传递给 `tap` 函数，你可以调用给定的 `$value` 上的任何方法。 你调用的方法的返回值将始终为「$value」，无论该方法在其定义中实际返回什么。 例如，Eloquent 的 update 方法通常返回一个整数。 但是，我们可以通过 tap 函数链接 update 方法调用来强制该方法返回模型本身：\r\n\r\n    $user = tap($user)->update([\r\n        'name' => $name,\r\n        'email' => $email,\r\n    ]);\r\n\r\n要向类添加 `tap` 方法，你可以向类添加 `Illuminate\\Support\\Traits\\Tappable` trait。 这个特征的 `tap` 方法接受一个闭包作为它唯一的参数。 对象实例本身将被传递给闭包，然后由 `tap` 方法返回：\r\n\r\n    return $user->tap(function (User $user) {\r\n        // ...\r\n    });\r\n\r\n<a name=\"method-throw-if\"></a>\r\n#### `throw_if()` {.collection-method}\r\n\r\n如果给定的布尔表达式的计算结果为「真」，则 `throw_if` 函数会抛出给定的异常：\r\n\r\n    throw_if(! Auth::user()->isAdmin(), AuthorizationException::class);\r\n    \r\n    throw_if(\r\n        ! Auth::user()->isAdmin(),\r\n        AuthorizationException::class,\r\n        '你不允许访问此页面。'\r\n    );\r\n\r\n<a name=\"method-throw-unless\"></a>\r\n#### `throw_unless()` {.collection-method}\r\n\r\n如果给定的布尔表达式的计算结果为 `false`，则 `throw_unless` 函数会抛出给定的异常：\r\n\r\n    throw_unless(Auth::user()->isAdmin(), AuthorizationException::class);\r\n    \r\n    throw_unless(\r\n        Auth::user()->isAdmin(),\r\n        AuthorizationException::class,\r\n        '你不允许访问此页面。'\r\n    );\r\n\r\n<a name=\"method-today\"></a>\r\n#### `today()` {.collection-method}\r\n\r\n`today` 函数根据当前日期创建新的 `Illuminate\\Support\\Carbon` 实例：\r\n\r\n    $today = today();\r\n\r\n<a name=\"method-trait-uses-recursive\"></a>\r\n#### `trait_uses_recursive()` {.collection-method}\r\n\r\n`trait_uses_recursive` 函数返回特征使用的所有 trait：\r\n\r\n    $traits = trait_uses_recursive(\\Illuminate\\Notifications\\Notifiable::class);\r\n\r\n<a name=\"method-transform\"></a>\r\n#### `transform()` {.collection-method}\r\n\r\n如果值不是 [blank](#method-blank)，则 transform 函数会对给定值执行闭包，然后返回闭包的返回值：\r\n\r\n    $callback = function (int $value) {\r\n        return $value * 2;\r\n    };\r\n    \r\n    $result = transform(5, $callback);\r\n    \r\n    // 10\r\n\r\n默认值或闭包可以作为函数的第三个参数传递。 如果给定值为空，将返回此值：\r\n\r\n    $result = transform(null, $callback, 'The value is blank');\r\n    \r\n    // The value is blank\r\n\r\n<a name=\"method-validator\"></a>\r\n#### `validator()` {.collection-method}\r\n\r\n`validator` 函数使用给定的参数创建一个新的 [validator](/docs/laravel/10.x/validation) 实例。 你可以将它用作 `Validator` 门面的替代品：\r\n\r\n    $validator = validator($data, $rules, $messages);\r\n\r\n<a name=\"method-value\"></a>\r\n\r\n#### `value()` {.collection-method}\r\n\r\n`value` 函数返回给定的值。 但是，如果将闭包传递给函数，则将执行闭包并返回其返回值：\r\n\r\n    $result = value(true);\r\n    \r\n    // true\r\n    \r\n    $result = value(function () {\r\n        return false;\r\n    });\r\n    \r\n    // false\r\n\r\n可以将其他参数传递给「value」函数。 如果第一个参数是一个闭包，那么附加参数将作为参数传递给闭包，否则它们将被忽略：\r\n\r\n    $result = value(function (string $name) {\r\n        return $name;\r\n    }, 'Taylor');\r\n    \r\n    // 'Taylor'\r\n\r\n<a name=\"method-view\"></a>\r\n#### `view()` {.collection-method}\r\n\r\n`view` 函数检索一个 [view](/docs/laravel/10.x/views) 实例：\r\n\r\n    return view('auth.login');\r\n\r\n<a name=\"method-with\"></a>\r\n#### `with()` {.collection-method}\r\n\r\n`with` 函数返回给定的值。 如果将闭包作为函数的第二个参数传递，则将执行闭包并返回其返回值：\r\n\r\n    $callback = function (mixed $value) {\r\n        return is_numeric($value) ? $value * 2 : 0;\r\n    };\r\n    \r\n    $result = with(5, $callback);\r\n    \r\n    // 10\r\n    \r\n    $result = with(null, $callback);\r\n    \r\n    // 0\r\n    \r\n    $result = with(5, null);\r\n    \r\n    // 5\r\n\r\n<a name=\"other-utilities\"></a>\r\n## 其他\r\n\r\n<a name=\"benchmarking\"></a>\r\n### 基准测试\r\n\r\n有时你可能希望快速测试应用程序某些部分的性能。 在这些情况下，您可以使用 Benchmark 支持类来测量给定回调完成所需的毫秒数：\r\n\r\n    <?php\r\n    \r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Benchmark;\r\n    \r\n    Benchmark::dd(fn () => User::find(1)); // 0.1 ms\r\n    \r\n    Benchmark::dd([\r\n        'Scenario 1' => fn () => User::count(), // 0.5 ms\r\n        'Scenario 2' => fn () => User::all()->count(), // 20.0 ms\r\n    ]);\r\n\r\n默认情况下，给定的回调将执行一次（一次迭代），并且它们的持续时间将显示在浏览器/控制台中。\r\n\r\n要多次调用回调，你可以将回调应调用的迭代次数指定为方法的第二个参数。 当多次执行回调时，「基准」类将返回在所有迭代中执行回调所花费的平均毫秒数：\r\n\r\n    Benchmark::dd(fn () => User::count(), iterations: 10); // 0.5 ms\r\n\r\n<a name=\"pipeline\"></a>\r\n### 管道\r\n\r\nLaravel 的 Pipeline 门面提供了一种便捷的方式来通过一系列可调用类、闭包或可调用对象「管道」给定输入，让每个类都有机会检查或修改输入并调用管道中的下一个可调用对象：\r\n\r\n    use Closure;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Pipeline;\r\n\r\n    $user = Pipeline::send($user)\r\n            ->through([\r\n                function (User $user, Closure $next) {\r\n                    // ...\r\n\r\n                    return $next($user);\r\n                },\r\n                function (User $user, Closure $next) {\r\n                    // ...\r\n\r\n                    return $next($user);\r\n                },\r\n            ])\r\n            ->then(fn (User $user) => $user);\r\n\r\n如你所见，管道中的每个可调用类或闭包都提供了输入和一个 `$next` 闭包。 调用 `$next` 闭包将调用管道中的下一个可调用对象。 你可能已经注意到，这与 [middleware](/docs/laravel/10.x/middleware) 非常相似。\r\n\r\n当管道中的最后一个可调用对象调用 `$next` 闭包时，提供给 `then` 方法的可调用对象将被调用。 通常，此可调用对象将简单地返回给定的输入。\r\n\r\n当然，如前所述，你不仅限于为管道提供闭包。 你还可以提供可调用的类。 如果提供了类名，该类将通过 Laravel 的 [服务容器](/docs/laravel/10.x/container) 实例化，允许将依赖项注入可调用类：\r\n\r\n    $user = Pipeline::send($user)\r\n            ->through([\r\n                GenerateProfilePhoto::class,\r\n                ActivateSubscription::class,\r\n                SendWelcomeEmail::class,\r\n            ])\r\n            ->then(fn (User $user) => $user);\r\n\r\n<a name=\"lottery\"></a>\r\n### 彩票\r\n\r\nLaravel 的 Lottery 类可用于根据一组给定的赔率执行回调。 当你只想为一定比例的传入请求执行代码时，这会特别有用：\r\n\r\n    use Illuminate\\Support\\Lottery;\r\n    \r\n    Lottery::odds(1, 20)\r\n        ->winner(fn () => $user->won())\r\n        ->loser(fn () => $user->lost())\r\n        ->choose();\r\n\r\n你可以将 Laravel 的彩票类与其他 Laravel 功能结合使用。 例如，你可能希望只向异常处理程序报告一小部分慢速查询。 而且，由于 Lottery 类是可调用的，我们可以将类的实例传递给任何接受可调用对象的方法：\r\n\r\n    use Carbon\\CarbonInterval;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\Support\\Lottery;\r\n    \r\n    DB::whenQueryingForLongerThan(\r\n        CarbonInterval::seconds(2),\r\n        Lottery::odds(1, 100)->winner(fn () => report('Querying > 2 seconds.')),\r\n    );\r\n\r\n<a name=\"testing-lotteries\"></a>\r\n#### 测试彩票\r\n\r\nLaravel 提供了一些简单的方法来让你轻松测试应用程序的 Lottery 调用：\r\n\r\n    // 彩票总是取胜...\r\n    Lottery::alwaysWin();\r\n    \r\n    // 彩票总是获败...\r\n    Lottery::alwaysLose();\r\n    \r\n    // 彩票会先赢后输，最后恢复到正常行为...\r\n    Lottery::fix([true, false]);\r\n    \r\n    // 彩票将恢复到正常行为...\r\n    Lottery::determineResultsNormally();","p":"docs/helpers.html"},{"t":"http-client (HTTP Client)","d":"# HTTP Client\r\n\r\n- [简介](#introduction)\r\n- [创建请求](#making-requests)\r\n    - [请求数据](#request-data)\r\n    - [请求头](#headers)\r\n    - [认证](#authentication)\r\n    - [超时](#timeout)\r\n    - [重试](#retries)\r\n    - [错误处理](#error-handling)\r\n    - [Guzzle 中间件](#guzzle-middleware)\r\n    - [Guzzle 选项](#guzzle-options)\r\n- [并发请求](#concurrent-requests)\r\n- [宏](#macros)\r\n- [测试](#testing)\r\n    - [模拟响应](#faking-responses)\r\n    - [注入请求](#inspecting-requests)\r\n    - [防止意外请求](#preventing-stray-requests)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 为 [Guzzle HTTP 客户端](http://docs.guzzlephp.org/en/stable/) 提供了一套语义化且轻量的 API，让你可用快速地使用 HTTP 请求与其他 Web 应用进行通信。该 API 专注于其在常见用例中的快速实现以及良好的开发者体验。\r\n\r\n在开始之前，你需要确保你的项目已经安装了 Guzzle 包作为依赖项。默认情况下，Laravel 已经包含了 Guzzle 包。但如果你此前手动移除了它，你也可以通过 Composer 重新安装它：\r\n\r\n```shell\r\ncomposer require guzzlehttp/guzzle\r\n```\r\n\r\n<a name=\"making-requests\"></a>\r\n## 创建请求\r\n\r\n你可以使用 `Http` Facade 提供的 `head`, `get`, `post`, `put`, `patch`，以及 `delete` 方法来创建请求。首先，让我们先看一下如何发出一个基础的 GET 请求：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::get('http://example.com');\r\n\r\n`get` 方法返回一个 `Illuminate\\Http\\Client\\Response` 的实例，该实例提供了大量的方法来检查请求的响应：\r\n\r\n    $response->body() : string;\r\n    $response->json($key = null, $default = null) : array|mixed;\r\n    $response->object() : object;\r\n    $response->collect($key = null) : Illuminate\\Support\\Collection;\r\n    $response->status() : int;\r\n    $response->successful() : bool;\r\n    $response->redirect(): bool;\r\n    $response->failed() : bool;\r\n    $response->clientError() : bool;\r\n    $response->header($header) : string;\r\n    $response->headers() : array;\r\n\r\n`Illuminate\\Http\\Client\\Response` 对象同样实现了 PHP 的 `ArrayAccess` 接口，这代表着你可以直接访问响应的 JSON 数据：\r\n\r\n    return Http::get('http://example.com/users/1')['name'];\r\n\r\n除了上面列出的响应方法之外，还可以使用以下方法来确定响应是否具有相映的状态码：\r\n\r\n    $response->ok() : bool;                  // 200 OK\r\n    $response->created() : bool;             // 201 Created\r\n    $response->accepted() : bool;            // 202 Accepted\r\n    $response->noContent() : bool;           // 204 No Content\r\n    $response->movedPermanently() : bool;    // 301 Moved Permanently\r\n    $response->found() : bool;               // 302 Found\r\n    $response->badRequest() : bool;          // 400 Bad Request\r\n    $response->unauthorized() : bool;        // 401 Unauthorized\r\n    $response->paymentRequired() : bool;     // 402 Payment Required\r\n    $response->forbidden() : bool;           // 403 Forbidden\r\n    $response->notFound() : bool;            // 404 Not Found\r\n    $response->requestTimeout() : bool;      // 408 Request Timeout\r\n    $response->conflict() : bool;            // 409 Conflict\r\n    $response->unprocessableEntity() : bool; // 422 Unprocessable Entity\r\n    $response->tooManyRequests() : bool;     // 429 Too Many Requests\r\n    $response->serverError() : bool;         // 500 Internal Server Error\r\n\r\n<a name=\"uri-templates\"></a>\r\n#### URI 模版\r\n\r\nHTTP客户端还允许你使用 [URI 模板规范](https://www.rfc-editor.org/rfc/rfc6570) 构造请求URL. 要定义URI查询参数，你可以使用 `withUrlParameters` 方法：\r\n\r\n    Http::withUrlParameters([\r\n        'endpoint' => 'https://laravel.com',\r\n        'page' => 'docs',\r\n        'version' => '9.x',\r\n        'topic' => 'validation',\r\n    ])->get('{+endpoint}/{page}/{version}/{topic}');\r\n\r\n<a name=\"dumping-requests\"></a>\r\n#### 打印请求信息\r\n\r\n如果要在发送请求之前打印输出请求信息并且结束脚本运行，你应该在创建请求前调用 `dd` 方法：\r\n\r\n    return Http::dd()->get('http://example.com');\r\n\r\n<a name=\"request-data\"></a>\r\n### 请求数据\r\n\r\n大多数情况下，`POST`、 `PUT` 和 `PATCH` 携带着额外的请求数据是相当常见的。所以，这些方法的第二个参数接受一个包含着请求数据的数组。默认情况下，这些数据会使用 `application/json` 类型随请求发送：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::post('http://example.com/users', [\r\n        'name' => 'Steve',\r\n        'role' => 'Network Administrator',\r\n    ]);\r\n\r\n<a name=\"get-request-query-parameters\"></a>\r\n#### GET 请求查询参数\r\n\r\n在创建 `GET` 请求时，你可以通过直接向 URL 添加查询字符串或是将键值对作为第二个参数传递给 `get` 方法：\r\n\r\n    $response = Http::get('http://example.com/users', [\r\n        'name' => 'Taylor',\r\n        'page' => 1,\r\n    ]);\r\n\r\n<a name=\"sending-form-url-encoded-requests\"></a>\r\n#### 发送 URL 编码请求\r\n\r\n如果你希望使用 `application/x-www-form-urlencoded` 作为请求的数据类型，你应该在创建请求前调用 `asForm` 方法：\r\n\r\n    $response = Http::asForm()->post('http://example.com/users', [\r\n        'name' => 'Sara',\r\n        'role' => 'Privacy Consultant',\r\n    ]);\r\n\r\n<a name=\"sending-a-raw-request-body\"></a>\r\n#### 发送原始数据（Raw）请求\r\n\r\n如果你想使用一个原始请求体发送请求，你可以在创建请求前调用 `withBody` 方法。你还可以将数据类型作为第二个参数传递给 `withBody` 方法：\r\n\r\n    $response = Http::withBody(\r\n        base64_encode($photo), 'image/jpeg'\r\n    )->post('http://example.com/photo');\r\n\r\n<a name=\"multi-part-requests\"></a>\r\n#### Multi-Part 请求\r\n\r\n如果你希望将文件作为 Multipart 请求发送，你应该在创建请求前调用 `attach` 方法。该方法接受文件的名字（相当于 HTML Input 的 name 属性）以及它对应的内容。你也可以在第三个参数传入自定义的文件名称，这不是必须的。如果有需要，你也可以通过第三个参数来指定文件的文件名：\r\n\r\n    $response = Http::attach(\r\n        'attachment', file_get_contents('photo.jpg'), 'photo.jpg'\r\n    )->post('http://example.com/attachments');\r\n\r\n除了传递文件的原始内容，你也可以传递 Stream 流数据：\r\n\r\n    $photo = fopen('photo.jpg', 'r');\r\n\r\n    $response = Http::attach(\r\n        'attachment', $photo, 'photo.jpg'\r\n    )->post('http://example.com/attachments');\r\n\r\n<a name=\"headers\"></a>\r\n### 请求头\r\n\r\n你可以通过 `withHeaders` 方法添加请求头。该 `withHeaders` 方法接受一个数组格式的键 / 值对：\r\n\r\n    $response = Http::withHeaders([\r\n        'X-First' => 'foo',\r\n        'X-Second' => 'bar'\r\n    ])->post('http://example.com/users', [\r\n        'name' => 'Taylor',\r\n    ]);\r\n\r\n你可以使用 `accept` 方法指定应用程序响应你的请求所需的内容类型：\r\n\r\n    $response = Http::accept('application/json')->get('http://example.com/users');\r\n\r\n为方便起见，你可以使用 `acceptJson` 方法快速指定应用程序需要 `application/json` 内容类型来响应你的请求：\r\n\r\n    $response = Http::acceptJson()->get('http://example.com/users');\r\n\r\n<a name=\"authentication\"></a>\r\n### 认证\r\n\r\n你可以使用 `withBasicAuth` 和 `withDigestAuth` 方法来分别指定使用 Basic 或是 Digest 认证方式：\r\n\r\n    // Basic 认证方式...\r\n    $response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(/* ... */);\r\n\r\n    // Digest 认证方式...\r\n    $response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(/* ... */);\r\n\r\n<a name=\"bearer-tokens\"></a>\r\n#### Bearer 令牌\r\n\r\n如果你想要为你的请求快速添加 `Authorization` Token 令牌请求头，你可以使用 `withToken` 方法：\r\n\r\n    $response = Http::withToken('token')->post(/* ... */);\r\n\r\n<a name=\"timeout\"></a>\r\n### 超时\r\n\r\n该 `timeout` 方法用于指定响应的最大等待秒数：\r\n\r\n    $response = Http::timeout(3)->get(/* ... */);\r\n\r\n如果响应时间超过了指定的超时时间，将会抛出 `Illuminate\\Http\\Client\\ConnectionException` 异常。\r\n\r\n你可以尝试使用 `connectTimeout` 方法指定连接到服务器时等待的最大秒数：\r\n\r\n    $response = Http::connectTimeout(3)->get(/* ... */);\r\n\r\n<a name=\"retries\"></a>\r\n### 重试\r\n\r\n如果你希望 HTTP 客户端在发生客户端或服务端错误时自动进行重试，你可以使用 retry 方法。该 retry 方法接受两个参数：重新尝试次数以及重试间隔（毫秒）：\r\n\r\n    $response = Http::retry(3, 100)->post(/* ... */);\r\n\r\n如果需要，你可以将第三个参数传递给该 `retry` 方法。第三个参数应该是一个可调用的，用于确定是否应该实际尝试重试。例如，你可能希望仅在初始请求遇到以下情况时重试请求 `ConnectionException`：\r\n\r\n    use Exception;\r\n    use Illuminate\\Http\\Client\\PendingRequest;\r\n\r\n    $response = Http::retry(3, 100, function (Exception $exception, PendingRequest $request) {\r\n        return $exception instanceof ConnectionException;\r\n    })->post(/* ... */);\r\n\r\n如果请求失败，你可以在新请求之前更改请求。你可以通过修改 `retry` 方法的第三个请求参数来实现这一点。例如，当请求返回身份验证错误，则可以使用新的授权令牌重试请求：\r\n\r\n    use Exception;\r\n    use Illuminate\\Http\\Client\\PendingRequest;\r\n\r\n    $response = Http::withToken($this->getToken())->retry(2, 0, function (Exception $exception, PendingRequest $request) {\r\n        if (! $exception instanceof RequestException || $exception->response->status() !== 401) {\r\n            return false;\r\n        }\r\n\r\n        $request->withToken($this->getNewToken());\r\n\r\n        return true;\r\n    })->post(/* ... */);\r\n\r\n所有请求都失败时，将会抛出一个`Illuminate\\Http\\Client\\RequestException`实例。如果不想抛出错误，你需要设置请求方法的`throw`参数为`false`。禁止后，当所有的请求都尝试完成后，最后一个响应将会return回来：\r\n\r\n    $response = Http::retry(3, 100, throw: false)->post(/* ... */);\r\n\r\n> **注意**   \r\n> 如果所有的请求都因为连接问题失败， 即使 `throw`属性设置为`false`，`Illuminate\\Http\\Client\\ConnectionException`错误依旧会被抛出。\r\n\r\n<a name=\"error-handling\"></a>\r\n### 错误处理\r\n\r\n与 Guzzle 的默认处理方式不同，Laravel 的 HTTP 客户端在客户端或者服务端出现4xx或者5xx错误时并不会抛出错误。你应该通过`successful`、 `clientError`或 `serverError`方法来校验返回的响应是否有错误信息:\r\n\r\n    // 判断状态码是否是 2xx\r\n    $response->successful();\r\n\r\n    // 判断错误码是否是 4xx或5xx\r\n    $response->failed();\r\n\r\n    // 判断错误码是4xx\r\n    $response->clientError();\r\n\r\n    // 判断错误码是5xx\r\n    $response->serverError();\r\n\r\n    // 如果出现客户端或服务器错误，则执行给定的回调\r\n    $response->onError(callable $callback);\r\n\r\n<a name=\"throwing-exceptions\"></a>\r\n#### 主动抛出错误\r\n\r\n如果你想在收到的响应是客户端或者服务端错误时抛出一个`Illuminate\\Http\\Client\\RequestException`实例，你可以使用`throw` 或 `throwIf` 方法：\r\n\r\n    use Illuminate\\Http\\Client\\Response;\r\n\r\n    $response = Http::post(/* ... */);\r\n\r\n    // 当收到服务端或客户端错误时抛出\r\n    $response->throw();\r\n\r\n    // 当满足condition条件是抛出错误\r\n    $response->throwIf($condition);\r\n\r\n    // 当给定的闭包执行结果是true时抛出错误\r\n    $response->throwIf(fn (Response $response) => true);\r\n\r\n    // 当给定条件是false是抛出错误\r\n    $response->throwUnless($condition);\r\n\r\n    // 当给定的闭包执行结果是false时抛出错误\r\n    $response->throwUnless(fn (Response $response) => false);\r\n\r\n    // 当收到的状态码是403时抛出错误\r\n    $response->throwIfStatus(403);\r\n\r\n    // 当收到的状态码不是200时抛出错误\r\n    $response->throwUnlessStatus(200);\r\n\r\n    return $response['user']['id'];\r\n\r\n`Illuminate\\Http\\Client\\RequestException` 实例拥有一个  `$response` 公共属性，该属性允许你检查返回的响应。\r\n\r\n如果没有发生错误，`throw` 方法返回响应实例，你可以将其他操作链接到 `throw` 方法：\r\n\r\n    return Http::post(/* ... */)->throw()->json();\r\n\r\n如果你希望在抛出异常前进行一些操作，你可以向 `throw` 方法传递一个闭包。异常将会在闭包执行完成后自动抛出，你不必在闭包内手动抛出异常：\r\n\r\n    use Illuminate\\Http\\Client\\Response;\r\n    use Illuminate\\Http\\Client\\RequestException;\r\n\r\n    return Http::post(/* ... */)->throw(function (Response $response, RequestException $e) {\r\n        // ...\r\n    })->json();\r\n\r\n<a name=\"guzzle-middleware\"></a>\r\n### Guzzle 中间件\r\n\r\n由于 Laravel 的 HTTP 客户端是由 Guzzle 提供支持的, 你可以利用 [Guzzle 中间件](https://docs.guzzlephp.org/en/stable/handlers-and-middleware.html) 来操作发出的请求或检查传入的响应。要操作发出的请求，需要通过 `withMiddleware` 方法和 Guzzle 的 `mapRequest` 中间件工厂注册一个 Guzzle 中间件：\r\n\r\n    use GuzzleHttp\\Middleware;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n    use Psr\\Http\\Message\\RequestInterface;\r\n\r\n    $response = Http::withMiddleware(\r\n        Middleware::mapRequest(function (RequestInterface $request) {\r\n            $request = $request->withHeader('X-Example', 'Value');\r\n            \r\n            return $request;\r\n        })\r\n    )->get('http://example.com');\r\n\r\n同样地，你可以通过 `withMiddleware` 方法结合 Guzzle 的 `mapResponse` 中间件工厂注册一个中间件来检查传入的 HTTP 响应：\r\n\r\n    use GuzzleHttp\\Middleware;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n    use Psr\\Http\\Message\\ResponseInterface;\r\n\r\n    $response = Http::withMiddleware(\r\n        Middleware::mapResponse(function (ResponseInterface $response) {\r\n            $header = $response->getHeader('X-Example');\r\n\r\n            // ...\r\n            \r\n            return $response;\r\n        })\r\n    )->get('http://example.com');\r\n\r\n<a name=\"guzzle-options\"></a>\r\n### Guzzle 选项\r\n\r\n你可以使用 `withOptions` 方法来指定额外的 [Guzzle 请求配置](http://docs.guzzlephp.org/en/stable/request-options.html)。`withOptions` 方法接受数组形式的键 / 值对：\r\n\r\n    $response = Http::withOptions([\r\n        'debug' => true,\r\n    ])->get('http://example.com/users');\r\n\r\n<a name=\"concurrent-requests\"></a>\r\n## 并发请求\r\n\r\n有时，你可能希望同时发出多个 HTTP 请求。换句话说，你希望同时分派多个请求，而不是按顺序发出请求。当与慢速 HTTP API 交互时，这可以显着提高性能。\r\n\r\n值得庆幸的是，你可以使用该 `pool` 方法完成此操作。`pool` 方法接受一个接收 `Illuminate\\Http\\Client\\Pool` 实例的闭包，能让你轻松地将请求添加到请求池以进行调度：\r\n\r\n    use Illuminate\\Http\\Client\\Pool;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $responses = Http::pool(fn (Pool $pool) => [\r\n        $pool->get('http://localhost/first'),\r\n        $pool->get('http://localhost/second'),\r\n        $pool->get('http://localhost/third'),\r\n    ]);\r\n\r\n    return $responses[0]->ok() &&\r\n           $responses[1]->ok() &&\r\n           $responses[2]->ok();\r\n\r\n如你所见，每个响应实例可以按照添加到池中的顺序来访问。你可以使用 `as` 方法命名请求，该方法能让你按名称访问相应的响应：\r\n\r\n    use Illuminate\\Http\\Client\\Pool;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $responses = Http::pool(fn (Pool $pool) => [\r\n        $pool->as('first')->get('http://localhost/first'),\r\n        $pool->as('second')->get('http://localhost/second'),\r\n        $pool->as('third')->get('http://localhost/third'),\r\n    ]);\r\n\r\n    return $responses['first']->ok();\r\n\r\n<a name=\"macros\"></a>\r\n## 宏\r\n\r\nLaravel HTTP客户端允许你定义「宏」（macros），这可以作为一种流畅、表达力强的机制，在与应用程序中的服务交互时配置常见的请求路径和标头。要开始使用，你可以在应用程序的 `App\\Providers\\AppServiceProvider` 类的 `boot` 方法中定义宏：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    /**\r\n     * 引导应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Http::macro('github', function () {\r\n            return Http::withHeaders([\r\n                'X-Example' => 'example',\r\n            ])->baseUrl('https://github.com');\r\n        });\r\n    }\r\n\r\n一旦你配置了宏，你可以在应用程序的任何地方调用它，以使用指定的配置创建一个挂起的请求：\r\n\r\n    $response = Http::github()->get('/');\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n许多 Laravel 服务提供功能来帮助你轻松、表达性地编写测试，而 Laravel 的 HTTP 客户端也不例外。`Http` 门面的 `fake` 方法允许你指示 HTTP 客户端在发出请求时返回存根/虚拟响应。\r\n\r\n<a name=\"faking-responses\"></a>\r\n### 伪造响应\r\n\r\n例如，要指示 HTTP 客户端在每个请求中返回空的 `200` 状态码响应，你可以调用 `fake` 方法而不传递参数：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Http::fake();\r\n\r\n    $response = Http::post(/* ... */);\r\n\r\n<a name=\"faking-specific-urls\"></a>\r\n#### 伪造特定的URL\r\n\r\n另外，你可以向 `fake` 方法传递一个数组。该数组的键应该代表你想要伪造的 URL 模式及其关联的响应。`*` 字符可以用作通配符。任何请求到未伪造的 URL 的请求将会被实际执行。你可以使用 `Http` 门面的 `response` 方法来构建这些端点的存根/虚拟响应：\r\n\r\n    Http::fake([\r\n        // 为 GitHub 端点存根一个 JSON 响应...\r\n        'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),\r\n\r\n        // 为 Google 端点存根一个字符串响应...\r\n        'google.com/*' => Http::response('Hello World', 200, $headers),\r\n    ]);\r\n\r\n如果你想指定一个后备 URL 模式来存根所有不匹配的 URL，你可以使用单个 `*` 字符：\r\n\r\n    Http::fake([\r\n        // 为 GitHub 端点存根 JSON 响应……\r\n        'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),\r\n\r\n        // 为其他所有端点存根字符串响应……\r\n        '*' => Http::response('Hello World', 200, ['Headers']),\r\n    ]);\r\n\r\n<a name=\"faking-response-sequences\"></a>\r\n#### 伪造响应序列\r\n\r\n有时候，你可能需要为单个 URL 指定其一系列的伪造响应的返回顺序。你可以使用 `Http::sequence` 方法来构建响应，以实现这个功能：\r\n\r\n    Http::fake([\r\n        // 存根 GitHub端点的一系列响应……\r\n        'github.com/*' => Http::sequence()\r\n                                ->push('Hello World', 200)\r\n                                ->push(['foo' => 'bar'], 200)\r\n                                ->pushStatus(404),\r\n    ]);\r\n\r\n当响应序列中的所有响应都被消费完后，后续的任何请求都将导致相应序列抛出一个异常。如果你想要在响应序列为空时指定一个默认的响应，则可以使用 `whenEmpty` 方法：\r\n\r\n    Http::fake([\r\n        // 为 GitHub 端点存根一系列响应\r\n        'github.com/*' => Http::sequence()\r\n                                ->push('Hello World', 200)\r\n                                ->push(['foo' => 'bar'], 200)\r\n                                ->whenEmpty(Http::response()),\r\n    ]);\r\n\r\n如果你想要伪造一个响应序列，但你又期望在伪造的时候无需指定一个特定的 URL 匹配模式，那么你可以使用 `Http::fakeSequence` 方法：\r\n\r\n    Http::fakeSequence()\r\n            ->push('Hello World', 200)\r\n            ->whenEmpty(Http::response());\r\n\r\n<a name=\"fake-callback\"></a>\r\n#### Fake 回调\r\n\r\n如果你需要更为复杂的逻辑来确定某些端点返回什么响应，你需要传递一个闭包给 `fake` 方法。这个闭包应该接受一个 `Illuminate\\Http\\Client\\Request` 实例且返回一个响应实例。在闭包中你可以执行任何必要的逻辑来确定要返回的响应类型：\r\n\r\n    use Illuminate\\Http\\Client\\Request;\r\n\r\n    Http::fake(function (Request $request) {\r\n        return Http::response('Hello World', 200);\r\n    });\r\n\r\n<a name=\"preventing-stray-requests\"></a>\r\n### 避免「流浪的」请求（确保请求总是伪造的）\r\n\r\n如果你想确保通过 HTTP 客户端发送的所有请求在整个单独的测试或完整的测试套件中都是伪造的，那么你可以调用 `preventStrayRequests` 方法。在调用该方法后，如果一个请求没有与之相匹配的伪造的响应，则将会抛出一个异常而不是发起一个真实的请求：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Http::preventStrayRequests();\r\n\r\n    Http::fake([\r\n        'github.com/*' => Http::response('ok'),\r\n    ]);\r\n\r\n    // 将会返回 OK 响应……\r\n    Http::get('https://github.com/laravel/framework');\r\n\r\n    // 抛出一个异常……\r\n    Http::get('https://laravel.com');\r\n\r\n<a name=\"inspecting-requests\"></a>\r\n### 检查请求\r\n\r\n在伪造响应时，你可能希望检查客户端收到的请求，以确保你的应用程序发出了正确的数据和标头。你可以在调用 `Http::fake` 方法后调用 `Http::assertSent` 方法来实现这个功能。\r\n\r\n`assertSent` 方法接受一个闭包，该闭包应当接收一个 `Illuminate\\Http\\Client\\Request` 实例且返回一个布尔值，该布尔值指示请求是否符合预期。为了使得测试通过，必须至少发出一个符合给定预期的请求：\r\n\r\n    use Illuminate\\Http\\Client\\Request;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Http::fake();\r\n\r\n    Http::withHeaders([\r\n        'X-First' => 'foo',\r\n    ])->post('http://example.com/users', [\r\n        'name' => 'Taylor',\r\n        'role' => 'Developer',\r\n    ]);\r\n\r\n    Http::assertSent(function (Request $request) {\r\n        return $request->hasHeader('X-First', 'foo') &&\r\n               $request->url() == 'http://example.com/users' &&\r\n               $request['name'] == 'Taylor' &&\r\n               $request['role'] == 'Developer';\r\n    });\r\n\r\n如果有需要，你可以使用 `assertNotSent` 方法来断言未发出指定的请求：\r\n\r\n    use Illuminate\\Http\\Client\\Request;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Http::fake();\r\n\r\n    Http::post('http://example.com/users', [\r\n        'name' => 'Taylor',\r\n        'role' => 'Developer',\r\n    ]);\r\n\r\n    Http::assertNotSent(function (Request $request) {\r\n        return $request->url() === 'http://example.com/posts';\r\n    });\r\n\r\n你可以使用 `assertSentCount` 方法来断言在测试过程中发出的请求数量：\r\n\r\n    Http::fake();\r\n\r\n    Http::assertSentCount(5);\r\n\r\n或者，你也可以使用 `assertNothingSent` 方法来断言在测试过程中没有发出任何请求：\r\n\r\n    Http::fake();\r\n\r\n    Http::assertNothingSent();\r\n\r\n<a name=\"recording-requests-and-responses\"></a>\r\n#### 记录请求和响应\r\n\r\n你可以使用 `recorded` 方法来收集所有的请求及其对应的响应。`recorded` 方法返回一个数组集合，其中包含了 `Illuminate\\Http\\Client\\Request` 实例和 `Illuminate\\Http\\Client\\Response` 实例：\r\n\r\n    Http::fake([\r\n        'https://laravel.com' => Http::response(status: 500),\r\n        'https://nova.laravel.com/' => Http::response(),\r\n    ]);\r\n\r\n    Http::get('https://laravel.com');\r\n    Http::get('https://nova.laravel.com/');\r\n\r\n    $recorded = Http::recorded();\r\n\r\n    [$request, $response] = $recorded[0];\r\n\r\n此外，`recorded` 函数也接受一个闭包，该闭包接受一个 `Illuminate\\Http\\Client\\Request` 和 `Illuminate\\Http\\Client\\Response` 实例，该闭包可以用来按照你的期望来过滤请求和响应：\r\n\r\n    use Illuminate\\Http\\Client\\Request;\r\n    use Illuminate\\Http\\Client\\Response;\r\n\r\n    Http::fake([\r\n        'https://laravel.com' => Http::response(status: 500),\r\n        'https://nova.laravel.com/' => Http::response(),\r\n    ]);\r\n\r\n    Http::get('https://laravel.com');\r\n    Http::get('https://nova.laravel.com/');\r\n\r\n    $recorded = Http::recorded(function (Request $request, Response $response) {\r\n        return $request->url() !== 'https://laravel.com' &&\r\n               $response->successful();\r\n    });\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\nLaravel 在发出 HTTP 请求的过程中将会触发三个事件。在发送请求前将会触发 `RequestSending` 事件，在接收到了指定请求对应的响应时将会触发 `ResponseReceived` 事件。如果没有收到指定请求对应的响应则会触发 `ConnectionFailed` 事件。\r\n\r\n`RequestSending` 和 `ConnectionFailed` 事件都包含一个公共的 `$request` 属性，你可以使用它来检查 `Illuminate\\Http\\Client\\Request` 实例。 同样，`ResponseReceived` 事件包含一个 `$request` 属性以及一个 `$response` 属性，可用于检查 `Illuminate\\Http\\Client\\Response` 实例。 你可以在你的 `App\\Providers\\EventServiceProvider` 服务提供者中为这个事件注册事件监听器：\r\n\r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Http\\Client\\Events\\RequestSending' => [\r\n            'App\\Listeners\\LogRequestSending',\r\n        ],\r\n        'Illuminate\\Http\\Client\\Events\\ResponseReceived' => [\r\n            'App\\Listeners\\LogResponseReceived',\r\n        ],\r\n        'Illuminate\\Http\\Client\\Events\\ConnectionFailed' => [\r\n            'App\\Listeners\\LogConnectionFailed',\r\n        ],\r\n    ];","p":"docs/http-client.html"},{"t":"localization (本地化)","d":"# 本地化\r\n\r\n- [简介](#introduction)\r\n    - [发布语言文件](#publishing-the-language-files)\r\n    - [配置语言环境](#configuring-the-locale)\r\n    - [多语种](#pluralization-language)\r\n- [定义翻译字符串](#defining-translation-strings)\r\n    - [使用短键](#using-short-keys)\r\n    - [使用翻译字符串作为键](#using-translation-strings-as-keys)\r\n- [检索翻译字符串](#retrieving-translation-strings)\r\n    - [替换翻译字符串中的参数](#replacing-parameters-in-translation-strings)\r\n    - [复数化](#pluralization)\r\n- [覆盖扩展包的语言文件](#overriding-package-language-files)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n> **技巧**\r\n> 默认情况下，Laravel 应用程序框架不包含 `lang` 目录。如果你想自定义 Laravel 的语言文件，可以通过 `lang:publish`  Artisan 命令发布它们。\r\n\r\nLaravel 的本地化功能提供了一种方便的方法来检索各种语言的字符串，从而使你可以轻松地在应用程序中支持多种语言。\r\n\r\nLaravel 提供了两种管理翻译字符串的方法。首先，语言字符串可以存储在 `lang` 目录里的文件中。在此目录中，可能存在应用程序支持的每种语言的子目录。这是 Laravel 用于管理内置 Laravel 功能（例如验证错误消息）的翻译字符串的方法：\r\n\r\n    /lang\r\n        /en\r\n            messages.php\r\n        /es\r\n            messages.php\r\n\r\n或者，可以在 `lang` 目录中放置的 JSON 文件中定义翻译字符串。采用这种方法时，应用程序支持的每种语言在此目录中都会有一个对应的 JSON 文件。对于具有大量可翻译字符串的应用，建议使用此方法：\r\n\r\n    /lang\r\n        en.json\r\n        es.json\r\n\r\n我们将在本文档中讨论每种管理翻译字符串的方法。\r\n\r\n<a name=\"publishing-the-language-files\"></a>\r\n### 发布语言文件\r\n\r\n默认情况下，Laravel 应用程序框架不包含 `lang` 目录。如果你想自定义 Laravel 的语言文件或创建自己的语言文件，则应通过 `lang:publish` Artisan 命令构建 `lang` 目录。 `lang:publish` 命令将在应用程序中创建 `lang` 目录，并发布 Laravel 使用的默认语言文件集：\r\n\r\n```shell\r\nphp artisan lang:publish\r\n```\r\n\r\n<a name=\"configuring-the-locale\"></a>\r\n### 配置语言环境\r\n\r\n应用程序的默认语言存储在 `config/app.php` 配置文件的 `locale` 配置选项中。你可以随意修改此值以适合你的应用程序的需求。\r\n\r\n你可以使用 `App` Facade 提供的 `setLocale` 方法，在运行时通过单个 HTTP 请求修改默认语言：\r\n\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    Route::get('/greeting/{locale}', function (string $locale) {\r\n        if (! in_array($locale, ['en', 'es', 'fr'])) {\r\n            abort(400);\r\n        }\r\n\r\n        App::setLocale($locale);\r\n\r\n        // ...\r\n    });\r\n\r\n你可以配置一个 「备用语言」，当当前语言不包含给定的翻译字符串时，将使用该语言。和默认语言一样，备用语言也是在 config/app.php 配置文件中配置的。\r\n\r\n    'fallback_locale' => 'en',\r\n\r\n<a name=\"determining-the-current-locale\"></a>\r\n#### 确定当前的语言环境\r\n\r\n你可以使用 `currentLocale` 和 `isLocale` 方法来确定当前的 `locale` 或检查 `locale` 是否是一个给定值。\r\n\r\n    use Illuminate\\Support\\Facades\\App;\r\n\r\n    $locale = App::currentLocale();\r\n\r\n    if (App::isLocale('en')) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"pluralization-language\"></a>\r\n### 多语种\r\n\r\n你可以使用 Laravel 的「pluralizer」来使用英语以外的语言，Eloquent 和框架的其他部分使用它来将单数字字符串转为复数字符串。这可以通过调用应用程序服务提供的 `boot` 方法中的 `useLanguage` 方法来实现。复数器目前支持的语言有 `法语`, `挪威语`, `葡萄牙语`, `西班牙语`, `土耳其语`:\r\n\r\n    use Illuminate\\Support\\Pluralizer;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Pluralizer::useLanguage('spanish');     \r\n\r\n        // ...     \r\n    }\r\n\r\n> **注意**\r\n> 如果你想自定义 pluralizer 的语言，则应该明确定义 Elquent 模型的 [表名](/docs/laravel/10.x/eloquentmd#table-names)。\r\n\r\n<a name=\"defining-translation-strings\"></a>\r\n## 定义翻译字符串\r\n\r\n<a name=\"using-short-keys\"></a>\r\n### 使用短键\r\n\r\n通常，翻译字符串存储在 `lang` 目录中的文件中。在这个目录中，应用程序支持的每种语言都应该有一个子目录。这是 Laravel 用于管理内置 Laravel 功能（如验证错误消息）的翻译字符串的方法：\r\n\r\n    /lang\r\n        /en\r\n            messages.php\r\n        /es\r\n            messages.php\r\n\r\n所有的语言文件都会返回一个键值对数组。比如下方这个例子：\r\n\r\n    <?php\r\n\r\n    // lang/en/messages.php\r\n\r\n    return [\r\n        'welcome' => 'Welcome to our application!',\r\n    ];\r\n\r\n> **技巧**\r\n> 对于不同地区的语言，应根据 ISO 15897 命名语言目录。例如，英式英语应使用「en_GB」而不是 「en_gb」。\r\n\r\n<a name=\"using-translation-strings-as-keys\"></a>\r\n### 使用翻译字符串作为键\r\n\r\n对于具有大量可翻译字符串的应用程序，在视图中引用键时，使用「短键」定义每个字符串可能会令人困惑，并且为应用程序支持的每个翻译字符串不断发明键会很麻烦。\r\n\r\n出于这个原因，Laravel 还支持使用字符串的「默认」翻译作为键来定义翻译字符串。使用翻译字符串作为键的翻译文件作为 JSON 文件存储在 `lang` 目录中。例如，如果你的应用程序有西班牙语翻译，你应该创建一个 `lang/es.json` 文件：\r\n\r\n```json\r\n{\r\n    \"I love programming.\": \"Me encanta programar.\"\r\n}\r\n```\r\n\r\n#### 键 / 文件冲突\r\n\r\n你不应该定义和其他翻译文件的文件名存在冲突的键。例如，在 `nl/action.php` 文件存在，但 `nl.json` 文件不存在时，对 `NL` 语言翻译 `__('Action')` 会导致翻译器返回 `nl/action.php` 文件的全部内容。\r\n\r\n<a name=\"retrieving-translation-strings\"></a>\r\n## 检索翻译字符串\r\n\r\n你可以使用 `__` 辅助函数从语言文件中检索翻译字符串。 如果你使用 「短键」 来定义翻译字符串，你应该使用 「.」 语法将包含键的文件和键本身传递给`__`函数。 例如，让我们从 `lang/en/messages.php` 语言文件中检索 `welcome` 翻译字符串：\r\n\r\n    echo __('messages.welcome');\r\n\r\n如果指定的翻译字符串不存在，`__` 函数将返回翻译字符串键。 因此，使用上面的示例，如果翻译字符串不存在，`__` 函数将返回 `messages.welcome`。\r\n\r\n如果是使用 [默认翻译字符串作为翻译键](#using-translation-strings-as-keys)，则应将字符串的默认翻译传递给 `__` 函数；\r\n\r\n    echo __('I love programming.');\r\n\r\n同理，如果翻译字符串不存在，`__` 函数将返回给定的翻译字符串键。\r\n\r\n如果是使用的是 [Blade 模板引擎](/docs/laravel/10.x/blade)，则可以使用 `{{ }}` 语法来显示翻译字符串：\r\n\r\n    {{ __('messages.welcome') }}\r\n\r\n<a name=\"replacing-parameters-in-translation-strings\"></a>\r\n### 替换翻译字符串中的参数\r\n\r\n如果愿意，可以在翻译字符串中定义占位符。所有占位符的前缀都是 `:`。例如，可以使用占位符名称定义欢迎消息：\r\n\r\n    'welcome' => 'Welcome, :name',\r\n\r\n在要检索翻译字符串时替换占位符，可以将替换数组作为第二个参数传递给 `__` 函数：\r\n\r\n    echo __('messages.welcome', ['name' => 'dayle']);\r\n\r\n如果占位符包含所有大写字母，或仅首字母大写，则转换后的值将相应地转换成大写：\r\n\r\n    'welcome' => 'Welcome, :NAME', // Welcome, DAYLE\r\n    'goodbye' => 'Goodbye, :Name', // Goodbye, Dayle\r\n\r\n<a name=\"object-replacement-formatting\"></a>\r\n#### 对象替换格式\r\n\r\n如果试图提供对象作为转换占位符，则将调用对象的 `__toString` 方法。[`__toString`](https://www.php.net/manual/en/language.oop5.magic.php#object.tostring)方法是PHP内置的「神奇方法」之一。然而，有时你可能无法控制给定类的 `__toString` 方法，例如当你正在交互的类属于第三方库时。\r\n\r\n在这些情况下，Laravel 允许你为特定类型的对象注册自定义格式处理程序。要实现这一点，你应该调用转换器的 `stringable` 方法。 `stringable` 方法接受闭包，闭包应类型提示其负责格式化的对象类型。通常，应在应用程序的 `AppServiceProvider` 类的 `boot` 方法中调用 `stringable` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Lang;\r\n    use Money\\Money;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Lang::stringable(function (Money $money) {\r\n            return $money->formatTo('en_GB');\r\n        });\r\n    }\r\n\r\n<a name=\"pluralization\"></a>\r\n### 复数化\r\n\r\n因为不同的语言有着各种复杂的复数化规则，所以复数化是个复杂的问题；不过 Laravel 可以根据你定义的复数化规则帮助你翻译字符串。使用 `|` 字符，可以区分字符串的单数形式和复数形式：\r\n\r\n    'apples' => 'There is one apple|There are many apples',\r\n\r\n当然，使用 [翻译字符串作为键](#using-translation-strings-as-keys) 时也支持复数化：\r\n\r\n```json\r\n{\r\n    \"There is one apple|There are many apples\": \"Hay una manzana|Hay muchas manzanas\"\r\n}\r\n```\r\n\r\n你甚至可以创建更复杂的复数化规则，为多个值范围指定转换字符串：\r\n\r\n    'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many',\r\n\r\n定义具有复数选项的翻译字符串后，可以使用 `trans_choice` 函数检索给定「count」的行。在本例中，由于计数大于 1 ，因此返回翻译字符串的复数形式：\r\n\r\n    echo trans_choice('messages.apples', 10);\r\n\r\n也可以在复数化字符串中定义占位符属性。通过将数组作为第三个参数传递给 `trans_choice` 函数，可以替换这些占位符：\r\n\r\n    'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago',\r\n\r\n    echo trans_choice('time.minutes_ago', 5, ['value' => 5]);\r\n\r\n如果要显示传递给 `trans_choice` 函数的整数值，可以使用内置的 `:count` 占位符：\r\n\r\n    'apples' => '{0} There are none|{1} There is one|[2,*] There are :count',\r\n\r\n<a name=\"overriding-package-language-files\"></a>\r\n## 覆盖扩展包的语言文件\r\n\r\n有些包可能随自己的语言文件一起封装。你可以将文件放置在 `lang/vendor/{package}/{locale}` 目录中，而不是更改扩展包的核心文件来调整这些行。\r\n\r\n例如，如果需要重写位于名为 `skyrim/hearthfire` 的包的 `messages.php` 文件内容，应将语言文件放在： `lang/vendor/hearthfire/en/messages.php` 在这个文件中，你应该只定义要覆盖的翻译字符串。任何未重写的翻译字符串仍将从包的原始语言文件中加载。","p":"docs/localization.html"},{"t":"mail (邮件)","d":"# 邮件\r\n\r\n- [介绍](#introduction)\r\n    - [配置](#configuration)\r\n    - [驱动前提](#driver-prerequisites)\r\n    - [故障转移配置](#failover-configuration)\r\n- [生成 Mailables](#generating-mailables)\r\n- [编写 Mailables](#writing-mailables)\r\n    - [配置发送者](#configuring-the-sender)\r\n    - [配置视图](#configuring-the-view)\r\n    - [视图数据](#view-data)\r\n    - [附件](#attachments)\r\n    - [内部附件](#inline-attachments)\r\n    - [可附着对象](#attachable-objects)\r\n    - [标头](#headers)\r\n    - [标记和元数据](#tags-and-metadata)\r\n    - [自定义 Symfony 消息](#customizing-the-symfony-message)\r\n- [Markdown 格式邮件](#markdown-mailables)\r\n    - [生成 Markdown 格式邮件](#generating-markdown-mailables)\r\n    - [生成 Markdown 格式邮件](#writing-markdown-messages)\r\n    - [自定义组件](#customizing-the-components)\r\n- [发送邮件](#sending-mail)\r\n    - [邮件队列](#queueing-mail)\r\n- [渲染邮件](#rendering-mailables)\r\n    - [浏览器中预览邮件](#previewing-mailables-in-the-browser)\r\n- [邮件本土化](#localizing-mailables)\r\n- [测试邮件](#testing-mailables)\r\n    - [测试邮件内容](#testing-mailable-content)\r\n    - [测试邮件发送](#testing-mailable-sending)\r\n- [邮件和本地开发](#mail-and-local-development)\r\n- [事件](#events)\r\n- [自定义传输方式](#custom-transports)\r\n    - [附 - Symfony 传输方式](#additional-symfony-transports)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n发送邮件并不复杂。Laravel 基于 [Symfony Mailer](https://symfony.com/doc/6.0/mailer.html) 组件提供了一个简洁、简单的邮件 API。Laravel 和 Symfony 为 Mailer SMTP 、Mailgun 、Postmark 、 Amazon SES 、 及 sendmail （发送邮件的方式）提供驱动，允许你通过本地或者云服务来快速发送邮件。\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\nLaravel 的邮件服务可以通过 `config/mail.php` 配置文件进行配置。邮件中的每一项都在配置文件中有单独的配置项，甚至是独有的「传输方式」，允许你的应用使用不同的邮件服务发送邮件。例如，你的应用程序在使用 Amazon SES 发送批量邮件时，也可以使用 Postmark 发送事务性邮件。\r\n\r\n在你的 `mail` 配置文件中，你将找到 `mailers` 配置数组。该数组包含 Laravel 支持的每个邮件 驱动程序 / 传输方式 配置，而 `default` 配置值确定当你的应用程序需要发送电子邮件时，默认情况下将使用哪个邮件驱动。\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动 / 传输的前提\r\n\r\n基于 API 的驱动，如 Mailgun 和 Postmark ，通常比 SMTP 服务器更简单快速。如果可以的话， 我们建议你使用下面这些驱动。\r\n\r\n<a name=\"mailgun-driver\"></a>\r\n#### Mailgun 驱动\r\n\r\n要使用 Mailgun 驱动，可以先通过 `composer` 来安装 `Mailgun` 函数库 ：\r\n\r\n```shell\r\ncomposer require symfony/mailgun-mailer symfony/http-client\r\n```\r\n\r\n接着，在应用的 `config/mail.php` 配置文件中，将默认项设置成 `mailgun`。配置好之后，确认 `config/services.php` 配置文件中包含以下选项：\r\n\r\n    'mailgun' => [\r\n        'domain' => env('MAILGUN_DOMAIN'),\r\n        'secret' => env('MAILGUN_SECRET'),\r\n    ],\r\n\r\n如果不使用 US [Mailgun region](https://documentation.mailgun.com/en/latest/api-intro.html#mailgun-regions) 区域终端 ，你需要在 `service` 文件中配置区域终端：\r\n\r\n    'mailgun' => [\r\n        'domain' => env('MAILGUN_DOMAIN'),\r\n        'secret' => env('MAILGUN_SECRET'),\r\n        'endpoint' => env('MAILGUN_ENDPOINT', 'api.eu.mailgun.net'),\r\n    ],\r\n\r\n<a name=\"postmark-driver\"></a>\r\n#### Postmark 驱动\r\n\r\n要使用 `Postmark` 驱动，先通过 `composer` 来安装 `Postmark` 函数库：\r\n\r\n```shell\r\ncomposer require symfony/postmark-mailer symfony/http-client\r\n```\r\n\r\n接着，在应用的 `config/mail.php` 配置文件中，将默认项设置成 `postmark`。配置好之后，确认 `config/services.php` 配置文件中包含如下选项：\r\n\r\n    'postmark' => [\r\n        'token' => env('POSTMARK_TOKEN'),\r\n    ],\r\n\r\n如果你要给指定邮件程序使用的 Postmark message stream，可以在配置数组中添加 `message_stream_id` 配置选项。这个配置数组在应用程序的 config/mail.php 配置文件中：\r\n\r\n    'postmark' => [\r\n        'transport' => 'postmark',\r\n        'message_stream_id' => env('POSTMARK_MESSAGE_STREAM_ID'),\r\n    ],\r\n\r\n这样，你还可以使用不同的 `message stream` 来设置多个 `Postmark 邮件驱动`。\r\n\r\n<a name=\"ses-driver\"></a>\r\n#### SES 驱动\r\n\r\n要使用 `Amazon SES` 驱动，你必须先安装 `PHP` 的 `Amazon AWS SDK` 。你可以可以通过 Composer 软件包管理器安装此库：\r\n\r\n```shell\r\ncomposer require aws/aws-sdk-php\r\n```\r\n\r\n然后，将 `config/mail.php` 配置文件的 `default` 选项设置成 `ses` 并确认你的 `config/services.php` 配置文件包含以下选项：\r\n\r\n    'ses' => [\r\n        'key' => env('AWS_ACCESS_KEY_ID'),\r\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n    ],\r\n\r\n为了通过 session token 来使用 AWS [temporary credentials](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html) ，你需要向应用的 SES 配置中添加一个 `token` 键：\r\n\r\n    'ses' => [\r\n        'key' => env('AWS_ACCESS_KEY_ID'),\r\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n        'token' => env('AWS_SESSION_TOKEN'),\r\n    ],\r\n\r\n发送邮件，如果你想传递一些 [额外的选项](https://docs.aws.amazon.com/aws-sdk-php/v3/api/api-sesv2-2019-09-27.html#sendemail) 给 AWS SDK 的 `SendEmail` 方法，你可以在 `ses` 配置中定义一个 `options` 数组：\r\n\r\n    'ses' => [\r\n        'key' => env('AWS_ACCESS_KEY_ID'),\r\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n        'options' => [\r\n            'ConfigurationSetName' => 'MyConfigurationSet',\r\n            'EmailTags' => [\r\n                ['Name' => 'foo', 'Value' => 'bar'],\r\n            ],\r\n        ],\r\n    ],\r\n\r\n<a name=\"failover-configuration\"></a>\r\n### 备用配置\r\n\r\n有时，已经配置好用于发送应用程序邮件的外部服务可能已关闭。在这种情况下，定义一个或多个备份邮件传递配置非常有用，这些配置将在主传递驱动程序关闭时使用。\r\n为此，应该在应用程序的 `mail` 配置文件中定义一个使用 `failover` 传输的邮件程序。应用程序的 `failover` 邮件程序的配置数组应包含一个 `mailers` 数组，该数组引用选择邮件驱动程序进行传递的顺序：\r\n\r\n    'mailers' => [\r\n        'failover' => [\r\n            'transport' => 'failover',\r\n            'mailers' => [\r\n                'postmark',\r\n                'mailgun',\r\n                'sendmail',\r\n            ],\r\n        ],\r\n\r\n        // ...\r\n    ],\r\n\r\n定义故障转移邮件程序后，应将此邮件程序设置为应用程序使用的`默认`邮件程序，方法是将其名称指定为应用程序 `mail` 配置文件中 `default` 配置密钥的值：\r\n\r\n    'default' => env('MAIL_MAILER', 'failover'),\r\n\r\n<a name=\"generating-mailables\"></a>\r\n## 生成 Mailables\r\n\r\n在构建 Laravel 应用程序时，应用程序发送的每种类型的电子邮件都表示为一个 `mailable` 类。这些类存储在 app/Mail 目录中。 如果你在应用程序中看不到此目录，请不要担心，因为它会在你使用 make:mail Artisan 命令创建第一个邮件类时自然生成：\r\n\r\n```shell\r\nphp artisan make:mail OrderShipped\r\n```\r\n\r\n<a name=\"writing-mailables\"></a>\r\n## 编写 Mailables\r\n\r\n一旦生成了一个邮件类，就打开它，这样我们就可以探索它的内容。邮件类的配置可以通过几种方法完成，包括 `envelope`、`content` 和 `attachments` 方法。\r\n\r\n `envelope` 方法返回 `Illuminate\\Mail\\Mailables\\Envelope` 对象，该对象定义邮件的主题，有时还定义邮件的收件人。`content` 方法返回 `Illuminate\\Mail\\Mailables\\Content` 对象，该对象定义将用于生成消息内容的[Blade模板](/docs/laravel/10.x/blade)。\r\n\r\n<a name=\"configuring-the-sender\"></a>\r\n### 配置发件人\r\n\r\n<a name=\"using-the-envelope\"></a>\r\n#### 使用 Envelope\r\n\r\n首先，让我们来看下如何配置电子邮件的发件人。电子邮件的「发件人」。有两种方法可以配置发送者。首先，你可以在邮件信封上指定「发件人」地址：\r\n\r\n    use Illuminate\\Mail\\Mailables\\Address;\r\n    use Illuminate\\Mail\\Mailables\\Envelope;\r\n\r\n    /**\r\n     * 获取邮件信封。\r\n     */\r\n    public function envelope(): Envelope\r\n    {\r\n        return new Envelope(\r\n            from: new Address('jeffrey@example.com', 'Jeffrey Way'),\r\n            subject: '订单发货',\r\n        );\r\n    }\r\n\r\n除此之外，还可以指定 `replyTo` 地址：\r\n\r\n    return new Envelope(\r\n        from: new Address('jeffrey@example.com', 'Jeffrey Way'),\r\n        replyTo: [\r\n            new Address('taylor@example.com', 'Taylor Otwell'),\r\n        ],\r\n        subject: '订单发货',\r\n    );\r\n\r\n<a name=\"using-a-global-from-address\"></a>\r\n#### 使用全局 `from` 地址\r\n\r\n当然，如果你的应用在任何邮件中使用的「发件人」地址都一致的话，在你生成的每一个 mailable 类中调用 `from` 方法可能会很麻烦。因此，你可以在 `config/mail.php` 文件中指定一个全局的「发件人」地址。当某个 mailable 类没有指定「发件人」时，它将使用该全局「发件人」：\r\n\r\n    'from' => ['address' => 'example@example.com', 'name' => 'App Name'],\r\n\r\n此外，你可以在 `config/mail.php` 配置文件中定义全局 「reply_to」 地址：\r\n\r\n    'reply_to' => ['address' => 'example@example.com', 'name' => 'App Name'],\r\n\r\n<a name=\"configuring-the-view\"></a>\r\n### 配置视图\r\n\r\n在邮件类下的 `content` 方法中使用 `view` 方法来指定在渲染邮件内容时要使用的模板。由于每封电子邮件通常使用一个 [Blade 模板](/docs/laravel/10.x/blade) 来渲染其内容。因此在构建电子邮件的 HTML 时，可以充分利用 Blade 模板引擎的功能和便利性：\r\n\r\n    /**\r\n     * 获取消息内容定义。\r\n     */\r\n    public function content(): Content\r\n    {\r\n        return new Content(\r\n            view: 'emails.orders.shipped',\r\n        );\r\n    }\r\n\r\n> **技巧**\r\n> 你可以创建一个 `resources/views/emails` 目录来存放所有的邮件模板；当然，也可以将其置于 `resources/views` 目录下的任何位置。\r\n\r\n<a name=\"plain-text-emails\"></a>\r\n#### 纯文本邮件\r\n\r\n如果要定义电子邮件的纯文本版本，可以在创建邮件的 `Content` 定义时指定纯文本模板。与 `view` 参数一样， `text` 参数是用于呈现电子邮件内容的模板名称。这样你就可以自由定义邮件的 Html 和纯文本版本：\r\n\r\n    /**\r\n     * 获取消息内容定义。\r\n     */\r\n    public function content(): Content\r\n    {\r\n        return new Content(\r\n            view: 'emails.orders.shipped',\r\n            text: 'emails.orders.shipped-text'\r\n        );\r\n    }\r\n\r\n为了清晰，`html` 参数可以用作 `view` 参数的别名：\r\n\r\n    return new Content(\r\n        html: 'emails.orders.shipped',\r\n        text: 'emails.orders.shipped-text'\r\n    );\r\n\r\n<a name=\"view-data\"></a>\r\n### 视图数\r\n\r\n<a name=\"via-public-properties\"></a>\r\n#### 通过 Public 属性\r\n\r\n通常，你需要将一些数据传递给视图，以便在呈现电子邮件的 HTML 时使用。有两种方法可以使数据对视图可用。首先，在 mailable 类上定义的任何公共属性都将自动对视图可用。例如，可以将数据传递到可邮寄类的构造函数中，并将该数据设置为类上定义的公共方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Mail;\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Mail\\Mailable;\r\n    use Illuminate\\Mail\\Mailables\\Content;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipped extends Mailable\r\n    {\r\n        use Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建新的消息实例。\r\n         */\r\n        public function __construct(\r\n            public Order $order,\r\n        ) {}\r\n\r\n        /**\r\n         * 获取消息内容定义。\r\n         */\r\n        public function content(): Content\r\n        {\r\n            return new Content(\r\n                view: 'emails.orders.shipped',\r\n            );\r\n        }\r\n    }\r\n\r\n一旦数据设置为公共属性，它将自动在视图中可用，因此可以像访问 Blade 模板中的任何其他数据一样访问它：\r\n\r\n    <div>\r\n        Price: {{ $order->price }}\r\n    </div>\r\n\r\n<a name=\"via-the-with-parameter\"></a>\r\n#### 通过 `with` 参数：\r\n\r\n如果你想要在邮件数据发送到模板前自定义它们的格式，你可以使用 `with` 方法来手动传递数据到视图中。一般情况下，你还是需要通过 mailable 类的构造函数来传递数据；不过，你应该将它们定义为 `protected` 或 `private` 以防止它们被自动传递到视图中。然后，在调用 `with` 方法的时候，可以以数组的形式传递你想要传递给模板的数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Mail;\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Mail\\Mailable;\r\n    use Illuminate\\Mail\\Mailables\\Content;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipped extends Mailable\r\n    {\r\n        use Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建新的消息实例。\r\n         */\r\n        public function __construct(\r\n            protected Order $order,\r\n        ) {}\r\n\r\n        /**\r\n         * 获取消息内容定义。\r\n         */\r\n        public function content(): Content\r\n        {\r\n            return new Content(\r\n                view: 'emails.orders.shipped',\r\n                with: [\r\n                    'orderName' => $this->order->name,\r\n                    'orderPrice' => $this->order->price,\r\n                ],\r\n            );\r\n        }\r\n    }\r\n\r\n一旦数据被传递到 `with` 方法，同样的它将自动在视图中可用，因此可以像访问 Blade 模板中的任何其他数据一样访问它：\r\n\r\n    <div>\r\n        Price: {{ $orderPrice }}\r\n    </div>\r\n\r\n<a name=\"attachments\"></a>\r\n### 附件\r\n\r\n要向电子邮件添加附件，你将向邮件的 `attachments` 方法返回的数组添加附件。首先，可以通过向 `Attachment` 类提供的 `fromPath` 方法提供文件路径来添加附件：\r\n\r\n    use Illuminate\\Mail\\Mailables\\Attachment;\r\n\r\n    /**\r\n     * 获取邮件的附件。\r\n     *\r\n     * @return array<int, \\Illuminate\\Mail\\Mailables\\Attachment>\r\n     */\r\n    public function attachments(): array\r\n    {\r\n        return [\r\n            Attachment::fromPath('/path/to/file'),\r\n        ];\r\n    }\r\n\r\n将文件附加到邮件时，还可以使用 `as` 和 `withMime` 方法来指定附件的显示名称 / 或 MIME 类型：\r\n\r\n    /**\r\n     * 获取邮件的附件。\r\n     *\r\n     * @return array<int, \\Illuminate\\Mail\\Mailables\\Attachment>\r\n     */\r\n    public function attachments(): array\r\n    {\r\n        return [\r\n            Attachment::fromPath('/path/to/file')\r\n                    ->as('name.pdf')\r\n                    ->withMime('application/pdf'),\r\n        ];\r\n    }\r\n\r\n<a name=\"attaching-files-from-disk\"></a>\r\n#### 从磁盘中添加附件\r\n\r\n如果你已经在 [文件存储](/docs/laravel/10.x/filesystem) 上存储了一个文件，则可以使用 `attachFromStorage` 方法将其附加到邮件中：\r\n\r\n    /**\r\n     * 获取邮件的附件。\r\n     *\r\n     * @return array<int, \\Illuminate\\Mail\\Mailables\\Attachment>\r\n     */\r\n    public function attachments(): array\r\n    {\r\n        return [\r\n            Attachment::fromStorage('/path/to/file'),\r\n        ];\r\n    }\r\n\r\n当然，也可以指定附件的名称和 MIME 类型：\r\n\r\n    /**\r\n     * 获取邮件的附件。\r\n     *\r\n     * @return array<int, \\Illuminate\\Mail\\Mailables\\Attachment>\r\n     */\r\n    public function attachments(): array\r\n    {\r\n        return [\r\n            Attachment::fromStorage('/path/to/file')\r\n                    ->as('name.pdf')\r\n                    ->withMime('application/pdf'),\r\n        ];\r\n    }\r\n\r\n如果需要指定默认磁盘以外的存储磁盘，可以使用 `attachFromStorageDisk` 方法：\r\n\r\n    /**\r\n     * 获取邮件的附件。\r\n     *\r\n     * @return array<int, \\Illuminate\\Mail\\Mailables\\Attachment>\r\n     */\r\n    public function attachments(): array\r\n    {\r\n        return [\r\n            Attachment::fromStorageDisk('s3', '/path/to/file')\r\n                    ->as('name.pdf')\r\n                    ->withMime('application/pdf'),\r\n        ];\r\n    }\r\n\r\n<a name=\"raw-data-attachments\"></a>\r\n#### 原始数据附件\r\n\r\n`fromData` 附件方法可用于附加原始字节字符串作为附件。例如，如果你在内存中生成了PDF，并且希望将其附加到电子邮件而不将其写入磁盘，可以使用到此方法。 `fromData` 方法接受一个闭包，该闭包解析原始数据字节以及应分配给附件的名称：\r\n\r\n    /**\r\n     * 获取邮件的附件。\r\n     *\r\n     * @return array<int, \\Illuminate\\Mail\\Mailables\\Attachment>\r\n     */\r\n    public function attachments(): array\r\n    {\r\n        return [\r\n            Attachment::fromData(fn () => $this->pdf, 'Report.pdf')\r\n                    ->withMime('application/pdf'),\r\n        ];\r\n    }\r\n\r\n<a name=\"inline-attachments\"></a>\r\n### 内联附件\r\n\r\n在邮件中嵌入内联图片通常很麻烦；不过，Laravel 提供了一种将图像附加到邮件的便捷方法。可以使用邮件模板中 $message 变量的 embed 方法来嵌入内联图片。Laravel 自动使 $message 变量在全部邮件模板中可用，不需要担心手动传递它：\r\n\r\n```blade\r\n<body>\r\n    这是一张图片：\r\n\r\n    <img src=\"{{ $message->embed($pathToImage) }}\">\r\n</body>\r\n```\r\n\r\n> **注意**\r\n> 该 `$message` 在文本消息中不可用，因为文本消息不能使用内联附件。\r\n\r\n<a name=\"embedding-raw-data-attachments\"></a>\r\n#### 嵌入原始数据附件\r\n\r\n如果你已经有了可以嵌入邮件模板的原始图像数据字符串，可以使用 `$message` 变量的 `embedData` 方法，当调用 `embedData` 方法时，需要传递一个文件名：\r\n\r\n```blade\r\n<body>\r\n    以下是原始数据的图像：\r\n\r\n    <img src=\"{{ $message->embedData($data, 'example-image.jpg') }}\">\r\n</body>\r\n```\r\n\r\n<a name=\"attachable-objects\"></a>\r\n### 可附着对象\r\n\r\n虽然通过简单的字符串路径将文件附加到消息通常就足够了，但在多数情况下，应用程序中的可附加实体由类表示。例如，如果你的应用程序正在将照片附加到消息中，那么在应用中可能还具有表示该照片的 `Photo` 模型。在这种情况下，简单地将 `Photo` 模型传递给 `attach` 方法会很方便。\r\n\r\n开始时，在可附加到邮件的对象上实现 `Illuminate\\Contracts\\Mail\\Attachable` 接口。此接口要求类定义一个 `toMailAttachment` 方法，该方法返回一个 `Illuminate\\Mail\\Attachment` 实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Contracts\\Mail\\Attachable;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Mail\\Attachment;\r\n\r\n    class Photo extends Model implements Attachable\r\n    {\r\n        /**\r\n         * 获取模型的可附加表示。\r\n         */\r\n        public function toMailAttachment(): Attachment\r\n        {\r\n            return Attachment::fromPath('/path/to/file');\r\n        }\r\n    }\r\n\r\n一旦定义了可附加对象，就可以在生成电子邮件时从 `attachments` 方法返回该对象的实例：\r\n\r\n    /**\r\n     * 获取邮件的附件。\r\n     *\r\n     * @return array<int, \\Illuminate\\Mail\\Mailables\\Attachment>\r\n     */\r\n    public function attachments(): array\r\n    {\r\n        return [$this->photo];\r\n    }\r\n\r\n当然，附件数据可以存储在远程文件存储服务（例如 Amazon S3）上。因此，Laravel 还允许你从存储在应用程序 [文件系统磁盘](/docs/laravel/10.x/filesystem) 上的数据生成附件实例：\r\n\r\n    // 从默认磁盘上的文件创建附件。。。\r\n    return Attachment::fromStorage($this->path);\r\n\r\n    // 从特定磁盘上的文件创建附件。。。\r\n    return Attachment::fromStorageDisk('backblaze', $this->path);\r\n\r\n此外，还可以通过内存中的数据创建附件实例。为此还提供了 `fromData` 方法的闭包。但闭包应返回表示附件的原始数据：\r\n\r\n    return Attachment::fromData(fn () => $this->content, 'Photo Name');\r\n\r\nLaravel 还提供了其他方法，你可以使用这些方法自定义附件。例如，可以使用 `as` 和 `withMime` 方法自定义文件名和 MIME 类型：\r\n\r\n    return Attachment::fromPath('/path/to/file')\r\n            ->as('Photo Name')\r\n            ->withMime('image/jpeg');\r\n\r\n<a name=\"headers\"></a>\r\n### 标头\r\n\r\n有时，你可能需要在传出消息中附加附加的标头。例如，你可能需要设置自定义 `Message-Id` 或其他任意文本标题。\r\n\r\n如果要实现这一点，请在邮件中定义 `headers` 方法。 `headers` 方法应返回 `Illuminate\\Mail\\Mailables\\Headers` 实例。此类接受 `messageId` 、 `references` 和 `text` 参数。当然，你可以只提供特定消息所需的参数：\r\n\r\n    use Illuminate\\Mail\\Mailables\\Headers;\r\n\r\n    /**\r\n     * 获取邮件标题。\r\n     */\r\n    public function headers(): Headers\r\n    {\r\n        return new Headers(\r\n            messageId: 'custom-message-id@example.com',\r\n            references: ['previous-message@example.com'],\r\n            text: [\r\n                'X-Custom-Header' => 'Custom Value',\r\n            ],\r\n        );\r\n    }\r\n\r\n<a name=\"tags-and-metadata\"></a>\r\n### 标记 和 元数据\r\n\r\n一些第三方电子邮件提供商（如 Mailgun 和 Postmark ）支持消息「标签」和 「元数据」，可用于对应用程序发送的电子邮件进行分组和跟踪。你可以通过 `Envelope` 来定义向电子邮件添加标签和元数据：\r\n\r\n    use Illuminate\\Mail\\Mailables\\Envelope;\r\n\r\n    /**\r\n     * 获取邮件信封。\r\n     *\r\n     * @return \\Illuminate\\Mail\\Mailables\\Envelope\r\n     */\r\n    public function envelope(): Envelope\r\n    {\r\n        return new Envelope(\r\n            subject: '订单发货',\r\n            tags: ['shipment'],\r\n            metadata: [\r\n                'order_id' => $this->order->id,\r\n            ],\r\n        );\r\n    }\r\n\r\n如果你的应用程序正在使用 Mailgun 驱动程序，你可以查阅 Mailgun 的文档以获取有关 [标签](https://documentation.mailgun.com/en/latest/user_manual.html#tagging-1) 和 [元数据](https://documentation.mailgun.com/en/latest/user_manual.html#attaching-data-to-messages) 的更多信息。同样，还可以查阅邮戳文档，了解其对 [标签](https://postmarkapp.com/blog/tags-support-for-smtp) 和 [元数据](https://postmarkapp.com/support/article/1125-custom-metadata-faq) 支持的更多信息\r\n\r\n如果你的应用程序使用 Amazon SES 发送电子邮件，则应使用 `metadata` 方法将 [SES 「标签」](https://docs.aws.amazon.com/ses/latest/APIReference/API_MessageTag.html)附加到邮件中。\r\n\r\n<a name=\"customizing-the-symfony-message\"></a>\r\n### 自定义 Symfony 消息\r\n\r\nLaravel 的邮件功能是由 Symfony Mailer 提供的。Laravel 在你发送消息之前是由 Symfony Message 注册然后再去调用自定义实例。这让你有机会在发送邮件之前对其进行深度定制。为此，请在 `Envelope` 定义上定义 `using` 参数：\r\n\r\n\r\n    use Illuminate\\Mail\\Mailables\\Envelope;\r\n    use Symfony\\Component\\Mime\\Email;\r\n    \r\n    /**\r\n     * 获取邮件信封。\r\n     */\r\n    public function envelope(): Envelope\r\n    {\r\n        return new Envelope(\r\n            subject: '订单发货',\r\n            using: [\r\n                function (Email $message) {\r\n                    // ...\r\n                },\r\n            ]\r\n        );\r\n    }\r\n\r\n<a name=\"markdown-mailables\"></a>\r\n## Markdown 格式邮件\r\n\r\nMarkdown 格式邮件允许你可以使用 mailable 中的预构建模板和 [邮件通知](/docs/laravel/10.x/notificationsmd#mail-notifications) 组件。由于消息是用 Markdown 编写，Laravel 能够渲染出美观的、响应式的 HTML 模板消息，同时还能自动生成纯文本副本。\r\n\r\n<a name=\"generating-markdown-mailables\"></a>\r\n### 生成 Markdown 邮件\r\n\r\n你可以在执行 `make:mail` 的 Artisan 命令时使用 `--markdown` 选项来生成一个 Markdown 格式模板的 mailable 类：\r\n\r\n```shell\r\nphp artisan make:mail OrderShipped --markdown=emails.orders.shipped\r\n```\r\n\r\n然后，在 `Content` 方法中配置邮寄的 `content` 定义时，使用 `markdown` 参数而不是 `view` 参数：\r\n\r\n    use Illuminate\\Mail\\Mailables\\Content;\r\n\r\n    /**\r\n     * 获取消息内容定义。\r\n     */\r\n    public function content(): Content\r\n    {\r\n        return new Content(\r\n            markdown: 'emails.orders.shipped',\r\n            with: [\r\n                'url' => $this->orderUrl,\r\n            ],\r\n        );\r\n    }\r\n\r\n<a name=\"writing-markdown-messages\"></a>\r\n### 编写 Markdown 邮件\r\n\r\nMarkdown mailable 类整合了 Markdown 语法和 Blade 组件，让你能够非常方便的使用 Laravel 预置的 UI 组件来构建邮件消息：\r\n\r\n```blade\r\n<x-mail::message>\r\n# 订单发货\r\n\r\n你的订单已发货！\r\n\r\n<x-mail::button :url=\"$url\">\r\n查看订单\r\n</x-mail::button>\r\n\r\n谢谢,<br>\r\n{{ config('app.name') }}\r\n</x-mail::message>\r\n```\r\n\r\n> **技巧**\r\n> 在编写 Markdown 邮件的时候，请勿使用额外的缩进。Markdown 解析器会把缩进渲染成代码块。\r\n\r\n<a name=\"button-component\"></a>\r\n#### 按钮组件\r\n\r\n按钮组件用于渲染居中的按钮链接。该组件接收两个参数，一个是 `url` 一个是可选的 `color`。 支持的颜色包括 `primary` ，`success` 和 `error`。你可以在邮件中添加任意数量的按钮组件：\r\n\r\n```blade\r\n<x-mail::button :url=\"$url\" color=\"success\">\r\n查看订单\r\n</x-mail::button>\r\n```\r\n\r\n<a name=\"panel-component\"></a>\r\n#### 面板组件\r\n\r\n面板组件在面板内渲染指定的文本块，面板与其他消息的背景色略有不同。它允许你绘制一个警示文本块：\r\n\r\n```blade\r\n<x-mail::panel>\r\n这是面板内容\r\n</x-mail::panel>\r\n```\r\n\r\n<a name=\"table-component\"></a>\r\n#### 表格组件\r\n\r\n表格组件允许你将 Markdown 表格转换成 HTML 表格。该组件接受 Markdown 表格作为其内容。列对齐支持默认的 Markdown 表格对齐语法：\r\n\r\n```blade\r\n<x-mail::table>\r\n| Laravel       | Table         | Example  |\r\n| ------------- |:-------------:| --------:|\r\n| Col 2 is      | Centered      | $10      |\r\n| Col 3 is      | Right-Aligned | $20      |\r\n</x-mail::table>\r\n```\r\n\r\n<a name=\"customizing-the-components\"></a>\r\n### 自定义组件\r\n\r\n你可以将所有 Markdown 邮件组件导出到自己的应用，用作自定义组件的模板。若要导出组件，使用 `laravel-mail` 资产标签的 `vendor:publish` Artisan 命令：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-mail\r\n```\r\n\r\n此命令会将 Markdown 邮件组件导出到 `resources/views/vendor/mail` 目录。 该 `mail` 目录包含 `html` 和 `text` 子目录，分别包含各自对应的可用组件描述。你可以按照自己的意愿自定义这些组件。\r\n\r\n<a name=\"customizing-the-css\"></a>\r\n#### 自定义 CSS\r\n\r\n组件导出后，`resources/views/vendor/mail/html/themes` 目录有一个 `default.css` 文件。可以在此文件中自定义 CSS，这些样式将自动内联到 Markdown 邮件消息的 HTML 表示中。\r\n\r\n如果想为 Laravel 的 Markdown 组件构建一个全新的主题，你可以在 `html/themes` 目录中新建一个 CSS 文件。命名并保存 CSS 文件后，并更新应用程序 `config/mail.php` 配置文件的 `theme` 选项以匹配新主题的名称。\r\n\r\n要想自定义单个邮件主题，可以将 mailable 类的 `$theme` 属性设置为发送 mailable 时应使用的主题名称。\r\n\r\n<a name=\"sending-mail\"></a>\r\n## 发送邮件\r\n\r\n若要发送邮件，使用 `Mail` [facade](/docs/laravel/10.x/facades) 的方法。该 `to` 方法接受 邮件地址、用户实例或用户集合。如果传递一个对象或者对象集合，mailer 在设置收件人时将自动使用它们的 `email` 和 `name` 属性，因此请确保对象的这些属性可用。一旦指定了收件人，就可以将 mailable 类实例传递给 `send` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Mail\\OrderShipped;\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n\r\n    class OrderShipmentController extends Controller\r\n    {\r\n        /**\r\n         * 发送给定的订单信息。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $order = Order::findOrFail($request->order_id);\r\n\r\n            // 发货订单。。。\r\n\r\n            Mail::to($request->user())->send(new OrderShipped($order));\r\n\r\n            return redirect('/orders');\r\n        }\r\n    }\r\n\r\n在发送消息时不止可以指定收件人。还可以通过链式调用「to」、「cc」、「bcc」一次性指定抄送和密送收件人：\r\n\r\n    Mail::to($request->user())\r\n        ->cc($moreUsers)\r\n        ->bcc($evenMoreUsers)\r\n        ->send(new OrderShipped($order));\r\n\r\n<a name=\"looping-over-recipients\"></a>\r\n#### 遍历收件人列表\r\n\r\n有时，你需要通过遍历一个收件人 / 邮件地址数组的方式，给一系列收件人发送邮件。但是，由于 `to` 方法会给 mailable 列表中的收件人追加邮件地址，因此，你应该为每个收件人重建 mailable 实例。\r\n\r\n    foreach (['taylor@example.com', 'dries@example.com'] as $recipient) {\r\n        Mail::to($recipient)->send(new OrderShipped($order));\r\n    }\r\n\r\n<a name=\"sending-mail-via-a-specific-mailer\"></a>\r\n#### 通过特定的 Mailer 发送邮件\r\n\r\n默认情况下，Laravel 将使用 `mail` 你的配置文件中配置为 `default` 邮件程序。 但是，你可以使用 `mailer` 方法通过特定的邮件程序配置发送：\r\n\r\n    Mail::mailer('postmark')\r\n            ->to($request->user())\r\n            ->send(new OrderShipped($order));\r\n\r\n<a name=\"queueing-mail\"></a>\r\n### 邮件队列\r\n\r\n<a name=\"queueing-a-mail-message\"></a>\r\n#### 将邮件消息加入队列\r\n\r\n由于发送邮件消息可能大幅度延长应用的响应时间，许多开发者选择将邮件消息加入队列放在后台发送。Laravel 使用内置的 [统一队列 API](/docs/laravel/10.x/queues) 简化了这一工作。若要将邮件消息加入队列，可以在指定消息的接收者后，使用 `Mail` 门面的 `queue` 方法：\r\n\r\n    Mail::to($request->user())\r\n        ->cc($moreUsers)\r\n        ->bcc($evenMoreUsers)\r\n        ->queue(new OrderShipped($order));\r\n\r\n此方法自动将作业推送到队列中以便消息在后台发送。使用此特性之前，需要 [配置队列](/docs/laravel/10.x/queues) 。\r\n\r\n<a name=\"delayed-message-queueing\"></a>\r\n#### 延迟消息队列\r\n\r\n想要延迟发送队列化的邮件消息，可以使用 `later` 方法。该 `later` 方法的第一个参数的第一个参数是标示消息何时发送的 `DateTime` 实例：\r\n\r\n    Mail::to($request->user())\r\n        ->cc($moreUsers)\r\n        ->bcc($evenMoreUsers)\r\n        ->later(now()->addMinutes(10), new OrderShipped($order));\r\n\r\n<a name=\"pushing-to-specific-queues\"></a>\r\n#### 推送到指定队列\r\n\r\n由于所有使用 `make:mail` 命令生成的 mailable 类都是用了 `Illuminate\\Bus\\Queueable` trait，因此你可以在任何 mailable 类实例上调用 `onQueue` 和 `onConnection` 方法来指定消息的连接和队列名：\r\n\r\n    $message = (new OrderShipped($order))\r\n                    ->onConnection('sqs')\r\n                    ->onQueue('emails');\r\n\r\n    Mail::to($request->user())\r\n        ->cc($moreUsers)\r\n        ->bcc($evenMoreUsers)\r\n        ->queue($message);\r\n\r\n<a name=\"queueing-by-default\"></a>\r\n#### 默认队列\r\n\r\n如果你希望你的邮件类始终使用队列，你可以给邮件类实现 `ShouldQueue` 契约，现在即使你调用了 `send` 方法，邮件依旧使用队列的方式发送\r\n\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\n    class OrderShipped extends Mailable implements ShouldQueue\r\n    {\r\n        // ...\r\n    }\r\n\r\n<a name=\"queued-mailables-and-database-transactions\"></a>\r\n#### 队列的邮件和数据库事务\r\n\r\n当在数据库事务中分发邮件队列时，队列可能在数据库事务提交之前处理邮件。 发生这种情况时，在数据库事务期间对模型或数据库记录所做的任何更新可能都不会反映在数据库中。另外，在事务中创建的任何模型或数据库记录都可能不存在于数据库中。如果你的邮件基于以上这些模型数据，则在处理邮件发送时，可能会发生意外错误。\r\n\r\n如果队列连接的 `after_commit` 配置选项设置为 `false`，那么仍然可以通过在 mailable 类上定义 `afterCommit` 属性来设置提交所有打开的数据库事务之后再调度特定的邮件队列：\r\n\r\n    Mail::to($request->user())->send(\r\n        (new OrderShipped($order))->afterCommit()\r\n    );\r\n\r\n或者，你可以 `afterCommit` 从 mailable 的构造函数中调用该方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Mail;\r\n\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Mail\\Mailable;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class OrderShipped extends Mailable implements ShouldQueue\r\n    {\r\n        use Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建新的消息实例。\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->afterCommit();\r\n        }\r\n    }\r\n\r\n> **技巧**\r\n> 要了解有关解决这些问题的更多信息，请查看 [队列和数据库事物](/docs/laravel/10.x/queuesmd#jobs-and-database-transactions)。\r\n\r\n<a name=\"rendering-mailables\"></a>\r\n## 渲染邮件\r\n\r\n有时你可能希望捕获邮件的 HTML 内容而不发送它。为此，可以调用邮件类的 `render` 方法。此方法将以字符串形式返回邮件类的渲染内容:\r\n\r\n    use App\\Mail\\InvoicePaid;\r\n    use App\\Models\\Invoice;\r\n\r\n    $invoice = Invoice::find(1);\r\n\r\n    return (new InvoicePaid($invoice))->render();\r\n\r\n<a name=\"previewing-mailables-in-the-browser\"></a>\r\n### 在浏览器中预览邮件\r\n\r\n设计邮件模板时，可以方便地在浏览器中预览邮件，就像典型的 Blade 模板一样。因此， Laravel 允许你直接从路由闭包或控制器返回任何邮件类。当邮件返回时，它将渲染并显示在浏览器中，允许你快速预览其设计，而无需将其发送到实际的电子邮件地址：\r\n\r\n    Route::get('/mailable', function () {\r\n        $invoice = App\\Models\\Invoice::find(1);\r\n\r\n        return new App\\Mail\\InvoicePaid($invoice);\r\n    });\r\n\r\n> **注意**\r\n> 在浏览器中预览邮件时，不会呈现 [内联附件](#inline-attachments) 要预览这些邮件，你应该将它们发送到电子邮件测试应用程序，例如 [Mailpit](https://github.com/axllent/mailpit) 或 [HELO](https://usehelo.com)。\r\n\r\n<a name=\"localizing-mailables\"></a>\r\n## 本地化邮件\r\n\r\nLaravel 允许你在请求的当前语言环境之外的语言环境中发送邮件，如果邮件在排队，它甚至会记住这个语言环境。\r\n\r\n为此， `Mail` 门面提供了一个 `locale` 方法来设置所需的语言。评估可邮寄的模板时，应用程序将更改为此语言环境，然后在评估完成后恢复为先前的语言环境：\r\n\r\n    Mail::to($request->user())->locale('es')->send(\r\n        new OrderShipped($order)\r\n    );\r\n\r\n<a name=\"user-preferred-locales\"></a>\r\n### 用户首选语言环境\r\n\r\n有时，应用程序存储每个用户的首选语言环境。 通过在一个或多个模型上实现 `HasLocalePreference` 契约，你可以指示 Laravel 在发送邮件时使用这个存储的语言环境：\r\n\r\n    use Illuminate\\Contracts\\Translation\\HasLocalePreference;\r\n\r\n    class User extends Model implements HasLocalePreference\r\n    {\r\n        /**\r\n         * 获取用户的区域设置。\r\n         */\r\n        public function preferredLocale(): string\r\n        {\r\n            return $this->locale;\r\n        }\r\n    }\r\n\r\n一旦你实现了接口，Laravel 将在向模型发送邮件和通知时自动使用首选语言环境。 因此，使用该接口时无需调用 `locale` 方法：\r\n\r\n    Mail::to($request->user())->send(new OrderShipped($order));\r\n\r\n<a name=\"testing-mailables\"></a>\r\n## 测试邮件\r\n\r\n<a name=\"testing-mailable-content\"></a>\r\n### 测试邮件内容\r\n\r\nLaravel 提供了几种方便的方法来测试你的邮件是否包含你期望的内容。 这些方法是：`assertSeeInHtml`、`assertDontSeeInHtml`、`assertSeeInOrderInHtml`、`assertSeeInText`、`assertDontSeeInText` 和 `assertSeeInOrderInText`。\r\n\r\n和你想的一样，「HTML」判断你的邮件的 HTML 版本中是否包含给定字符串，而「Text」是判断你的可邮寄邮件的纯文本版本是否包含给定字符串：\r\n\r\n    use App\\Mail\\InvoicePaid;\r\n    use App\\Models\\User;\r\n\r\n    public function test_mailable_content(): void\r\n    {\r\n        $user = User::factory()->create();\r\n\r\n        $mailable = new InvoicePaid($user);\r\n\r\n        $mailable->assertFrom('jeffrey@example.com');\r\n        $mailable->assertTo('taylor@example.com');\r\n        $mailable->assertHasCc('abigail@example.com');\r\n        $mailable->assertHasBcc('victoria@example.com');\r\n        $mailable->assertHasReplyTo('tyler@example.com');\r\n        $mailable->assertHasSubject('Invoice Paid');\r\n        $mailable->assertHasTag('example-tag');\r\n        $mailable->assertHasMetadata('key', 'value');\r\n\r\n        $mailable->assertSeeInHtml($user->email);\r\n        $mailable->assertSeeInHtml('Invoice Paid');\r\n        $mailable->assertSeeInOrderInHtml(['Invoice Paid', 'Thanks']);\r\n\r\n        $mailable->assertSeeInText($user->email);\r\n        $mailable->assertSeeInOrderInText(['Invoice Paid', 'Thanks']);\r\n\r\n        $mailable->assertHasAttachment('/path/to/file');\r\n        $mailable->assertHasAttachment(Attachment::fromPath('/path/to/file'));\r\n        $mailable->assertHasAttachedData($pdfData, 'name.pdf', ['mime' => 'application/pdf']);\r\n        $mailable->assertHasAttachmentFromStorage('/path/to/file', 'name.pdf', ['mime' => 'application/pdf']);\r\n        $mailable->assertHasAttachmentFromStorageDisk('s3', '/path/to/file', 'name.pdf', ['mime' => 'application/pdf']);\r\n    }\r\n\r\n<a name=\"testing-mailable-sending\"></a>\r\n### 测试邮件的发送\r\n\r\n我们建议将邮件内容和判断指定的邮件「发送」给特定用户的测试分开进行测试。通常来讲，邮件的内容与你正在测试的代码无关，只要能简单地判断 Laravel 能够发送指定的邮件就足够了。\r\n\r\n你可以使用 `Mail`方法的 `fake` 方法来阻止邮件的发送。调用了 `Mail` 方法的 `fake`方法后，你可以判断邮件是否已被发送给指定的用户，甚至可以检查邮件收到的数据：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Mail\\OrderShipped;\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_orders_can_be_shipped(): void\r\n        {\r\n            Mail::fake();\r\n\r\n            // 执行邮件发送。。。\r\n\r\n            // 判断没有发送的邮件。。。\r\n            Mail::assertNothingSent();\r\n\r\n            // 判断已发送邮件。。。\r\n            Mail::assertSent(OrderShipped::class);\r\n\r\n            // 判断已发送两次的邮件。。。\r\n            Mail::assertSent(OrderShipped::class, 2);\r\n\r\n            // 判断邮件是否未发送。。。\r\n            Mail::assertNotSent(AnotherMailable::class);\r\n        }\r\n    }\r\n\r\n如果你在后台排队等待邮件的传递，则应该使用 `assertQueued` 方法而不是 `assertSent` 方法。\r\n\r\n    Mail::assertQueued(OrderShipped::class);\r\n\r\n    Mail::assertNotQueued(OrderShipped::class);\r\n\r\n    Mail::assertNothingQueued();\r\n\r\n你可以向 `assertSent`、`assertNotSent`、 `assertQueued` 或者 `assertNotQueued` 方法来传递闭包，来判断发送的邮件是否通过给定的 「真值检验」。如果至少发送了一个可以通过的邮件，就可以判断为成功。\r\n\r\n    Mail::assertSent(function (OrderShipped $mail) use ($order) {\r\n        return $mail->order->id === $order->id;\r\n    });\r\n\r\n当调用 `Mail` 外观的判断方法时，提供的闭包所接受的邮件实例会公开检查邮件的可用方法：\r\n\r\n    Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) use ($user) {\r\n        return $mail->hasTo($user->email) &&\r\n               $mail->hasCc('...') &&\r\n               $mail->hasBcc('...') &&\r\n               $mail->hasReplyTo('...') &&\r\n               $mail->hasFrom('...') &&\r\n               $mail->hasSubject('...');\r\n    });\r\n\r\nmailable 实例还包括检查 mailable 上的附件的几种可用方法：\r\n\r\n    use Illuminate\\Mail\\Mailables\\Attachment;\r\n\r\n    Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) {\r\n        return $mail->hasAttachment(\r\n            Attachment::fromPath('/path/to/file')\r\n                    ->as('name.pdf')\r\n                    ->withMime('application/pdf')\r\n        );\r\n    });\r\n\r\n    Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) {\r\n        return $mail->hasAttachment(\r\n            Attachment::fromStorageDisk('s3', '/path/to/file')\r\n        );\r\n    });\r\n\r\n    Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) use ($pdfData) {\r\n        return $mail->hasAttachment(\r\n            Attachment::fromData(fn () => $pdfData, 'name.pdf')\r\n        );\r\n    });\r\n\r\n你可能已经注意到，有 2 种方法可以判断邮件是否发送, 即：`assertNotSent` 和 `assertNotQueued` 。有时你可能希望判断邮件没有被发送**或**排队。如果要实现这一点，你可以使用 `assertNothingOutgoing` 和 `assertNotOutgoing` 方法。\r\n\r\n    Mail::assertNothingOutgoing();\r\n\r\n    Mail::assertNotOutgoing(function (OrderShipped $mail) use ($order) {\r\n        return $mail->order->id === $order->id;\r\n    });\r\n\r\n<a name=\"mail-and-local-development\"></a>\r\n## 邮件和本地开发\r\n\r\n在开发发送电子邮件的应用程序时，你可能不希望实际将电子邮件发送到实际的电子邮件地址。 Laravel 提供了几种在本地开发期间「禁用」发送电子邮件的方法。\r\n\r\n<a name=\"log-driver\"></a>\r\n#### 日志驱动\r\n\r\n`log` 邮件驱动程序不会发送你的电子邮件，而是将所有电子邮件信息写入你的日志文件以供检查。 通常，此驱动程序仅在本地开发期间使用。有关按环境配置应用程序的更多信息，请查看 [配置文档](/docs/laravel/10.x/configurationmd#environment-configuration)。\r\n\r\n<a name=\"mailtrap\"></a>\r\n#### HELO / Mailtrap / Mailpit\r\n\r\n或者，你可以使用 [HELO](https://usehelo.com/) 或 [Mailtrap](https://mailtrap.io/) 之类的服务和 `smtp` 驱动程序将你的电子邮件信息发送到「虚拟」邮箱。你可以通过在真正的电子邮件客户端中查看它们。这种方法的好处是允许你在 Mailtrap 的消息查看实际并检查的最终电子邮件。\r\n\r\n如果你使用 [Laravel Sail](/docs/laravel/10.x/sail)，你可以使用 [Mailpit](https://github.com/axllent/mailpit) 预览你的消息。当 Sail 运行时，你可以访问 Mailpit 界面：`http://localhost:8025`。\r\n\r\n<a name=\"using-a-global-to-address\"></a>\r\n#### 使用全局 `to` 地址\r\n\r\n最后，你可以通过调用 `Mail` 门面提供的 `alwaysTo` 方法来指定一个全局的「收件人」地址。 通常，应该从应用程序的服务提供者之一的 `boot` 方法调用此方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n\r\n    /**\r\n     * 启动应用程序服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        if ($this->app->environment('local')) {\r\n            Mail::alwaysTo('taylor@example.com');\r\n        }\r\n    }\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\nLaravel 在发送邮件消息的过程中会触发 2 个事件。`MessageSending` 事件在消息发送之前触发，而 `MessageSent` 事件在消息发送后触发。请记住，这些事件是在邮件**发送**时触发的，而不是在排队时触发的。你可以在你的 `App\\Providers\\EventServiceProvider` 服务中为这个事件注册事件监听器：\r\n\r\n    use App\\Listeners\\LogSendingMessage;\r\n    use App\\Listeners\\LogSentMessage;\r\n    use Illuminate\\Mail\\Events\\MessageSending;\r\n    use Illuminate\\Mail\\Events\\MessageSent;\r\n\r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        MessageSending::class => [\r\n            LogSendingMessage::class,\r\n        ],\r\n\r\n        MessageSent::class => [\r\n            LogSentMessage::class,\r\n        ],\r\n    ];\r\n\r\n<a name=\"custom-transports\"></a>\r\n## 自定义传输\r\n\r\nLaravel 包含多种邮件传输；但是，你可能希望编写自己的传输程序，通过 Laravel 来发送电子邮件。首先，定义一个扩展 `Symfony\\Component\\Mailer\\Transport\\AbstractTransport` 类。然后，在传输上实现 `doSend` 和 `__toString()` 方法：\r\n\r\n    use MailchimpTransactional\\ApiClient;\r\n    use Symfony\\Component\\Mailer\\SentMessage;\r\n    use Symfony\\Component\\Mailer\\Transport\\AbstractTransport;\r\n    use Symfony\\Component\\Mime\\Address;\r\n    use Symfony\\Component\\Mime\\MessageConverter;\r\n\r\n    class MailchimpTransport extends AbstractTransport\r\n    {\r\n        /**\r\n         * 创建一个新的 Mailchimp 传输实例。\r\n         */\r\n        public function __construct(\r\n            protected ApiClient $client,\r\n        ) {\r\n            parent::__construct();\r\n        }\r\n\r\n        /**\r\n         * {@inheritDoc}\r\n         */\r\n        protected function doSend(SentMessage $message): void\r\n        {\r\n            $email = MessageConverter::toEmail($message->getOriginalMessage());\r\n\r\n            $this->client->messages->send(['message' => [\r\n                'from_email' => $email->getFrom(),\r\n                'to' => collect($email->getTo())->map(function (Address $email) {\r\n                    return ['email' => $email->getAddress(), 'type' => 'to'];\r\n                })->all(),\r\n                'subject' => $email->getSubject(),\r\n                'text' => $email->getTextBody(),\r\n            ]]);\r\n        }\r\n\r\n        /**\r\n         * 获取传输字符串的表示形式。\r\n         */\r\n        public function __toString(): string\r\n        {\r\n            return 'mailchimp';\r\n        }\r\n    }\r\n\r\n你一旦定义了自定义传输，就可以通过 `Mail` 外观提供的 `boot` 方法来注册它。通常情况下，这应该在应用程序的 `AppServiceProvider` 服务种提供的 `boot` 方法中完成。`$config` 参数将提供给 `extend` 方法的闭包。该参数将包含在应用程序中的 `config/mail.php` 来配置文件中为 mailer 定义的配置数组。\r\n\r\n    use App\\Mail\\MailchimpTransport;\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n\r\n    /**\r\n     * 启动应用程序服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Mail::extend('mailchimp', function (array $config = []) {\r\n            return new MailchimpTransport(/* ... */);\r\n        });\r\n    }\r\n\r\n定义并注册自定义传输后，你可以在应用程序中的 `config/mail.php` 配置文件中新建一个利用自定义传输的邮件定义：\r\n\r\n    'mailchimp' => [\r\n        'transport' => 'mailchimp',\r\n        // ...\r\n    ],\r\n\r\n<a name=\"additional-symfony-transports\"></a>\r\n### 额外的 Symfony 传输\r\n\r\nLaravel 同样支持一些现有的 Symfony 维护的邮件传输，如 Mailgun 和 Postmark 。但是，你可能希望通过扩展 Laravel，来支持 Symfony 维护的其他传输。你可以通过 Composer 请求必要的 Symfony 邮件并向 Laravel 注册运输。例如，你可以安装并注册 Symfony 的「Sendinblue」 邮件：\r\n\r\n```none\r\ncomposer require symfony/sendinblue-mailer symfony/http-client\r\n```\r\n\r\n安装 Sendinblue 邮件包后，你可以将 Sendinblue API 凭据的条目添加到应用程序的「服务」配置文件中：\r\n\r\n    'sendinblue' => [\r\n        'key' => 'your-api-key',\r\n    ],\r\n\r\n最后，你可以使用 `Mail` 门面的 `extend` 方法向 Laravel 注册传输。通常，这应该在服务提供者的 `boot` 方法中完成：\r\n\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n    use Symfony\\Component\\Mailer\\Bridge\\Sendinblue\\Transport\\SendinblueTransportFactory;\r\n    use Symfony\\Component\\Mailer\\Transport\\Dsn;\r\n\r\n    /**\r\n     * 启动应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Mail::extend('sendinblue', function () {\r\n            return (new SendinblueTransportFactory)->create(\r\n                new Dsn(\r\n                    'sendinblue+api',\r\n                    'default',\r\n                    config('services.sendinblue.key')\r\n                )\r\n            );\r\n        });\r\n    }\r\n\r\n你一旦注册了传输，就可以在应用程序的 `config/mail.php` 配置文件中创建一个用于新传输的 mailer 定义：\r\n\r\n    'sendinblue' => [\r\n        'transport' => 'sendinblue',\r\n        // ...\r\n    ],","p":"docs/mail.html"},{"t":"notifications (消息通知)","d":"# 消息通知\r\n-   [介绍](#introduction)\r\n-   [生成通知](#generating-notifications)\r\n-   [发送通知](#sending-notifications)\r\n    -   [使用可通知特征](#using-the-notifiable-trait)\r\n    -   [使用通知门面](#using-the-notification-facade)\r\n    -   [指定传送渠道](#specifying-delivery-channels)\r\n    -   [通知排队](#queueing-notifications)\r\n    -   [按需通知](#on-demand-notifications)\r\n-   [邮件通知](#mail-notifications)\r\n    -   [格式化邮件消息](#formatting-mail-messages)\r\n    -   [自定义发件人](#customizing-the-sender)\r\n    -   [自定义收件人](#customizing-the-recipient)\r\n    -   [自定义主题](#customizing-the-subject)\r\n    -   [自定义邮件程序](#customizing-the-mailer)\r\n    -   [自定义模板](#customizing-the-templates)\r\n    -   [附件](#mail-attachments)\r\n    -   [添加标签和元数据](#adding-tags-metadata)\r\n    -   [自定义 Symfony 消息](#customizing-the-symfony-message)\r\n    -   [使用 Mailables](#using-mailables)\r\n    -   [预览邮件通知](#previewing-mail-notifications)\r\n-   [Markdown 邮件通知](#markdown-mail-notifications)\r\n    -   [生成消息](#generating-the-message)\r\n    -   [撰写消息](#writing-the-message)\r\n    -   [自定义组件](#customizing-the-components)\r\n-   [数据库通知](#database-notifications)\r\n    -   [先决条件](#database-prerequisites)\r\n    -   [格式化数据库通知](#formatting-database-notifications)\r\n    -   [访问通知](#accessing-the-notifications)\r\n    -   [将通知标记为已读](#marking-notifications-as-read)\r\n-   [广播通知](#broadcast-notifications)\r\n    -   [先决条件](#broadcast-prerequisites)\r\n    -   [格式化广播通知](#formatting-broadcast-notifications)\r\n    -   [监听通知](#listening-for-notifications)\r\n-   [短信通知](#sms-notifications)\r\n    -   [先决条件](#sms-prerequisites)\r\n    -   [格式化短信通知](#formatting-sms-notifications)\r\n    -   [格式化短代码通知](#formatting-shortcode-notifications)\r\n    -   [自定义「来源」号码](#customizing-the-from-number)\r\n    -   [添加客户参考](#adding-a-client-reference)\r\n    -   [路由短信通知](#routing-sms-notifications)\r\n-   [Slack 通知](#slack-notifications)\r\n    -   [先决条件](#slack-prerequisites)\r\n    -   [格式化 Slack 通知](#formatting-slack-notifications)\r\n    -   [Slack 附件](#slack-attachments)\r\n    -   [路由 Slack 通知](#routing-slack-notifications)\r\n-   [本地化通知](#localizing-notifications)\r\n-   [测试](#testing)\r\n-   [通知事件](#notification-events)\r\n-   [自定义渠道](#custom-channels)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n除了支持 [发送电子邮件](/docs/laravel/10.x/mail) 之外，Laravel还提供了支持通过多种传递渠道发送通知的功能，包括电子邮件、短信（通过 [Vonage](https://www.vonage.com/communications-apis/)，前身为Nexmo）和 [Slack](https://slack.com/)。此外，已经创建了多种 [社区构建的通知渠道](https://laravel-notification-channels.com/about/#suggesting-a-new-channel)，用于通过数十个不同的渠道发送通知！通知也可以存储在数据库中，以便在你的Web界面中显示。\r\n\r\n通常，通知应该是简短的信息性消息，用于通知用户应用中发生的事情。例如，如果你正在编写一个账单应用，则可以通过邮件和短信频道向用户发送一个「支付凭证」通知。\r\n\r\n<a name=\"generating-notifications\"></a>\r\n## 创建通知\r\n\r\nLaravel 中，通常每个通知都由一个存储在 `app/Notifications` 目录下的一个类表示。如果在你的应用中没有看到这个目录，不要担心，当运行 `make:notification` 命令时它将为你创建：\r\n\r\n```shell\r\nphp artisan make:notification InvoicePaid\r\n```\r\n\r\n这个命令会在 `app/Notifications` 目录下生成一个新的通知类。每个通知类都包含一个 `via` 方法以及一个或多个消息构建的方法比如 `toMail` 或 `toDatabase`，它们会针对特定的渠道把通知转换为对应的消息。\r\n\r\n<a name=\"sending-notifications\"></a>\r\n## 发送通知\r\n\r\n<a name=\"using-the-notifiable-trait\"></a>\r\n### 使用 Notifiable Trait\r\n\r\n通知可以通过两种方式发送： 使用 `Notifiable` 特性的 `notify` 方法或使用 `Notification` [facade](/docs/laravel/10.x/facades)。 该 `Notifiable` 特性默认包含在应用程序的 `App\\Models\\User` 模型中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n    }\r\n\r\n此 `notify` 方法需要接收一个通知实例参数：\r\n\r\n    use App\\Notifications\\InvoicePaid;\r\n\r\n    $user->notify(new InvoicePaid($invoice));\r\n\r\n> **技巧**\r\n> 请记住，你可以在任何模型中使用 `Notifiable` trait。而不仅仅是在 `User` 模型中。\r\n\r\n<a name=\"using-the-notification-facade\"></a>\r\n### 使用 Notification Facade\r\n\r\n另外，你可以通过 `Notification` [facade](/docs/laravel/10.x/facades) 来发送通知。它主要用在当你需要给多个可接收通知的实体发送的时候，比如给用户集合发送通知。使用 Facade 发送通知的话，要把可接收通知实例和通知实例传递给 `send` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Notification;\r\n\r\n    Notification::send($users, new InvoicePaid($invoice));\r\n\r\n你也可以使用 `sendNow` 方法立即发送通知。即使通知实现了 `ShouldQueue` 接口，该方法也会立即发送通知：\r\n\r\n    Notification::sendNow($developers, new DeploymentCompleted($deployment));\r\n\r\n<a name=\"specifying-delivery-channels\"></a>\r\n### 发送指定频道\r\n\r\n每个通知类都有一个 `via` 方法，用于确定将在哪些通道上传递通知。通知可以在 `mail`、`database`、`broadcast`、`vonage` 和 `slack` 频道上发送。\r\n\r\n> **提示**\r\n> 如果你想使用其他的频道，比如 Telegram 或者 Pusher，你可以去看下社区驱动的 [Laravel 通知频道网站](http://laravel-notification-channels.com).\r\n\r\n`via` 方法接收一个 `$notifiable` 实例，这个实例将是通知实际发送到的类的实例。你可以用 `$notifiable` 来决定这个通知用哪些频道来发送：\r\n\r\n    /**\r\n     * 获取通知发送频道。\r\n     *\r\n     * @return array<int, string>\r\n     */\r\n    public function via(object $notifiable): array\r\n    {\r\n        return $notifiable->prefers_sms ? ['vonage'] : ['mail', 'database'];\r\n    }\r\n\r\n<a name=\"queueing-notifications\"></a>\r\n### 通知队列化\r\n\r\n> **注意**\r\n> 使用通知队列前需要配置队列并 [开启一个队列任务](/docs/laravel/10.x/queues)。\r\n\r\n发送通知可能是耗时的，尤其是通道需要调用额外的 API 来传输通知。为了加速应用的响应时间，可以将通知推送到队列中异步发送，而要实现推送通知到队列，可以让对应通知类实现 `ShouldQueue` 接口并使用 `Queueable` trait。如果通知类是通过 make:notification 命令生成的，那么该接口和 trait 已经默认导入，你可以快速将它们添加到通知类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Notifications;\r\n\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class InvoicePaid extends Notification implements ShouldQueue\r\n    {\r\n        use Queueable;\r\n\r\n        // ...\r\n    }\r\n\r\n一旦将 `ShouldQueue` 接口添加到你的通知中，你就可以发送通知。 Laravel 将检测类上的 `ShouldQueue` 接口并自动排队发送通知：\r\n\r\n    $user->notify(new InvoicePaid($invoice));\r\n\r\n排队通知时，将为每个收件人和频道组合创建一个排队的作业。比如，如果你的通知有三个收件人和两个频道，则六个作业将被分配到队列中。\r\n\r\n<a name=\"delaying-notifications\"></a>\r\n#### 延迟通知\r\n\r\n如果你需要延迟发送消息通知, 你可以在你的消息通知实例上添加 `delay` 方法:\r\n\r\n    $delay = now()->addMinutes(10);\r\n\r\n    $user->notify((new InvoicePaid($invoice))->delay($delay));\r\n\r\n<a name=\"delaying-notifications-per-channel\"></a>\r\n#### 多个通道的延迟通知\r\n\r\n将一个数组传递给 `delay` 方法来指定特定通道的延迟时间:\r\n\r\n    $user->notify((new InvoicePaid($invoice))->delay([\r\n        'mail' => now()->addMinutes(5),\r\n        'sms' => now()->addMinutes(10),\r\n    ]));\r\n\r\n或者，你可以在通知类本身上定义一个 `withDelay` 方法。 `withDelay` 方法会返回包含通道名称和延迟值的数组:\r\n\r\n    /**\r\n     * 确定通知的传递延迟.\r\n     *\r\n     * @return array<string, \\Illuminate\\Support\\Carbon>\r\n     */\r\n    public function withDelay(object $notifiable): array\r\n    {\r\n        return [\r\n            'mail' => now()->addMinutes(5),\r\n            'sms' => now()->addMinutes(10),\r\n        ];\r\n    }\r\n\r\n<a name=\"customizing-the-notification-queue-connection\"></a>\r\n#### 自定义消息通知队列连接\r\n\r\n默认情况下，排队的消息通知将使用应用程序的默认队列连接进行排队。如果你想指定一个不同的连接用于特定的通知，你可以在通知类上定义一个 `$connection` 属性:\r\n\r\n    /**\r\n     * 排队通知时要使用的队列连接的名称.\r\n     *\r\n     * @var string\r\n     */\r\n    public $connection = 'redis';\r\n\r\n或者，如果你想为每个通知通道都指定一个特定的队列连接，你可以在你的通知上定义一个 `viaConnections` 方法。这个方法应该返回一个通道名称 / 队列连接名称的数组。\r\n\r\n    /**\r\n     * 定义每个通知通道应该使用哪个连接。\r\n     *\r\n     * @return array<string, string>\r\n     */\r\n    public function viaConnections(): array\r\n    {\r\n        return [\r\n            'mail' => 'redis',\r\n            'database' => 'sync',\r\n        ];\r\n    }\r\n\r\n<a name=\"customizing-notification-channel-queues\"></a>\r\n#### 自定义通知通道队列\r\n\r\n如果你想为每个通知通道指定一个特定的队列，你可以在你的通知上定义一个 `viaQueues` 。 此方法应返回通道名称 / 队列名称对的数组：\r\n\r\n    /**\r\n     * 定义每个通知通道应使用哪条队列。\r\n     *\r\n     * @return array<string, string>\r\n     */\r\n    public function viaQueues(): array\r\n    {\r\n        return [\r\n            'mail' => 'mail-queue',\r\n            'slack' => 'slack-queue',\r\n        ];\r\n    }\r\n\r\n<a name=\"queued-notifications-and-database-transactions\"></a>\r\n#### 队列通知 & 数据库事务\r\n\r\n当队列通知在数据库事务中被分发时，它们可能在数据库事务提交之前被队列处理。发生这种情况时，你在数据库事务期间对模型或数据库记录所做的任何更新可能尚未反映在数据库中。甚至，在事务中创建的任何模型或数据库记录可能不存在于数据库中。如果你的通知依赖于这些模型，那么在处理发送队列通知时可能会发生意外错误。\r\n\r\n如果你的队列连接的 `after_commit` 配置选项设置为 `false`，你仍然可以通过在发送通知时调用 `afterCommit` 方法来指示应在提交所有打开的数据库事务后发送特定的排队通知：\r\n\r\n    use App\\Notifications\\InvoicePaid;\r\n\r\n    $user->notify((new InvoicePaid($invoice))->afterCommit());\r\n\r\n或者，你可以从通知的构造函数调用 `afterCommit` 方法：\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Notifications;\r\n\r\nuse Illuminate\\Bus\\Queueable;\r\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\r\nuse Illuminate\\Notifications\\Notification;\r\n\r\nclass InvoicePaid extends Notification implements ShouldQueue\r\n{\r\n    use Queueable;\r\n\r\n    /**\r\n     * 创建一个新的通知通知实例。\r\n     */\r\n    public function __construct()\r\n    {\r\n        $this->afterCommit();\r\n    }\r\n}\r\n```\r\n\r\n> **注意**  \r\n> 要了解更多解决这些问题的方法，请查阅有关队列作业和 [数据库事务](/docs/laravel/10.x/queuesmd#jobs-and-database-transactions) 的文档。\r\n\r\n<a name=\"determining-if-the-queued-notification-should-be-sent\"></a>\r\n#### 确定是否发送排队的通知\r\n\r\n在将排队的通知分派到后台处理的队列之后，它通常会被队列工作进程接受并发送给其目标收件人。\r\n\r\n然而，如果你想要在队列工作进程处理后最终确定是否发送排队的通知，你可以在通知类上定义一个 `shouldSend` 方法。如果此方法返回 `false`，则通知不会被发送：\r\n\r\n    /**\r\n     * 定义通知是否应该被发送。\r\n     */\r\n    public function shouldSend(object $notifiable, string $channel): bool\r\n    {\r\n        return $this->invoice->isPaid();\r\n    }\r\n\r\n<a name=\"on-demand-notifications\"></a>\r\n### 按需通知\r\n\r\n有时你需要向一些不属于你应用程序的「用户」发送通知。使用 `Notification` 门面的 `route` 方法，你可以在发送通知之前指定即时的通知路由信息：\r\n\r\n    use Illuminate\\Broadcasting\\Channel;\r\n    use Illuminate\\Support\\Facades\\Notification;\r\n\r\n    Notification::route('mail', 'taylor@example.com')\r\n                ->route('vonage', '5555555555')\r\n                ->route('slack', 'https://hooks.slack.com/services/...')\r\n                ->route('broadcast', [new Channel('channel-name')])\r\n                ->notify(new InvoicePaid($invoice));\r\n\r\n如果你想在向 `mail` 路由发送通知时指定收件人，你可以提供一个数组\r\n电子邮件地址作为键，名字作为值。\r\n\r\n    Notification::route('mail', [\r\n        'barrett@example.com' => 'Barrett Blair',\r\n    ])->notify(new InvoicePaid($invoice));\r\n\r\n<a name=\"mail-notifications\"></a>\r\n## 邮件通知\r\n\r\n<a name=\"formatting-mail-messages\"></a>\r\n### 格式化邮件\r\n\r\n如果一个通知支持以电子邮件的形式发送，你应该在通知类中定义一个 `toMail` 方法。这个方法将接收一个 `$notifiable` 实体，并应该返回一个`Illuminate\\Notifications\\Messages\\MailMessage` 实例。\r\n\r\n`MailMessage` 类包含一些简单的方法来帮助你建立事务性的电子邮件信息。邮件信息可能包含几行文字以及一个「操作」。让我们来看看一个 `toMail` 方法的例子。\r\n\r\n    /**\r\n     * 获取通知的邮件表示形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        $url = url('/invoice/'.$this->invoice->id);\r\n\r\n        return (new MailMessage)\r\n                    ->greeting('你好!')\r\n                    ->line('你的一张发票已经付款了！')\r\n                    ->lineIf($this->amount > 0, \"支出金额: {$this->amount}\")\r\n                    ->action('查看发票', $url)\r\n                    ->line('感谢你使用我们的应用程序！');\r\n    }\r\n\r\n> **注意**  \r\n> 注意我们在 `toMail` 方法中使用 `$this->invoice->id`。你可以在通知的构造函数中传递任何你的通知需要生成的信息数据。\r\n\r\n在这个例子中，我们注册了一个问候语、一行文字、一个操作，然后是另一行文字。`MailMessage` 对象所提供的这些方法使得邮件的格式化变得简单而快速。然后，邮件通道将把信息组件转换封装成一个漂亮的、响应式的HTML电子邮件模板，并有一个纯文本对应。\r\n下面是一个由 `mail` 通道生成的电子邮件的例子。\r\n\r\n<img src=\"https://laravel.com/img/docs/notification-example-2.png\">\r\n\r\n> **注意**  \r\n> 当发送邮件通知时，请确保在你的 `config/app.php` 配置文件中设置 `name` 配置选项。\r\n这个值将在你的邮件通知信息的标题和页脚中使用。\r\n\r\n<a name=\"error-messages\"></a>\r\n#### 错误消息\r\n\r\n一些通知会通知用户错误，比如支付失败的发票。你可以通过在构建消息时调用 `error` 方法来指示邮件消息是关于错误的。当在邮件消息上使用 `error` 方法时，操作按钮将会是红色而不是黑色：\r\n\r\n    /**\r\n     * 获取通知的邮件表示形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->error()\r\n                    ->subject('发票支付失败')\r\n                    ->line('...');\r\n    }\r\n\r\n<a name=\"other-mail-notification-formatting-options\"></a>\r\n#### 其他邮件通知格式选项\r\n你可以使用 `view` 方法来指定应用于呈现通知电子邮件的自定义模板，而不是在通知类中定义文本「行」：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)->view(\r\n            'emails.name', ['invoice' => $this->invoice]\r\n        );\r\n    }\r\n\r\n你可以通过将视图名称作为数组的第二个元素传递给 `view` 方法来指定邮件消息的纯文本视图：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)->view(\r\n            ['emails.name.html', 'emails.name.plain'],\r\n            ['invoice' => $this->invoice]\r\n        );\r\n    }\r\n\r\n<a name=\"customizing-the-sender\"></a>\r\n### 自定义发件人\r\n\r\n默认情况下，电子邮件的发件人/寄件人地址在 `config/mail.php` 配置文件中定义。但是，你可以使用 `from` 方法为特定的通知指定发件人地址：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->from('barrett@example.com', 'Barrett Blair')\r\n                    ->line('...');\r\n    }\r\n\r\n<a name=\"customizing-the-recipient\"></a>\r\n### 自定义收件人\r\n\r\n当通过 `mail` 通道发送通知时，通知系统将自动查找可通知实体的 `email` 属性。你可以通过在可通知实体上定义 `routeNotificationForMail` 方法来自定义用于传递通知的电子邮件地址：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * 路由邮件通道的通知。\r\n         *\r\n         * @return  array<string, string>|string\r\n         */\r\n        public function routeNotificationForMail(Notification $notification): array|string\r\n        {\r\n            // 只返回电子邮件地址...\r\n            return $this->email_address;\r\n\r\n            // 返回电子邮件地址和姓名...\r\n            return [$this->email_address => $this->name];\r\n        }\r\n    }\r\n\r\n<a name=\"customizing-the-subject\"></a>\r\n### 自定义主题\r\n\r\n默认情况下，邮件的主题是通知类的类名格式化为「标题案例」（Title Case）。因此，如果你的通知类命名为 `InvoicePaid`，则邮件的主题将是 `Invoice Paid`。如果你想为消息指定不同的主题，可以在构建消息时调用 `subject` 方法：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->subject('通知标题')\r\n                    ->line('...');\r\n    }\r\n\r\n<a name=\"customizing-the-mailer\"></a>\r\n### 自定义邮件程序\r\n\r\n默认情况下，邮件通知将使用 `config/mail.php` 配置文件中定义的默认邮件程序进行发送。但是，你可以在运行时通过在构建消息时调用 `mailer` 方法来指定不同的邮件程序：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->mailer('postmark')\r\n                    ->line('...');\r\n    }\r\n\r\n<a name=\"customizing-the-templates\"></a>\r\n### 自定义模板\r\n\r\n你可以通过发布通知包的资源来修改邮件通知使用的 HTML 和纯文本模板。运行此命令后，邮件通知模板将位于 `resources/views/vendor/notifications` 目录中：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-notifications\r\n```\r\n\r\n<a name=\"mail-attachments\"></a>\r\n### 附件\r\n\r\n要在电子邮件通知中添加附件，可以在构建消息时使用 `attach` 方法。`attach` 方法接受文件的绝对路径作为其第一个参数：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->greeting('你好!')\r\n                    ->attach('/path/to/file');\r\n    }\r\n\r\n> **注意**  \r\n> 通知邮件消息提供的 `attach` 方法还接受 [可附加对象](/docs/laravel/10.x/mailmd#attachable-objects)。请查阅全面的 [可附加对象](/docs/laravel/10.x/mailmd#attachable-objects) 文档以了解更多信息。\r\n\r\n当附加文件到消息时，你还可以通过将 `array` 作为 `attach` 方法的第二个参数来指定显示名称和/或 MIME 类型：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->greeting('你好!')\r\n                    ->attach('/path/to/file', [\r\n                        'as' => 'name.pdf',\r\n                        'mime' => 'application/pdf',\r\n                    ]);\r\n    }\r\n\r\n与在可邮寄对象中附加文件不同，你不能使用 `attachFromStorage` 直接从存储磁盘附加文件。相反，你应该使用 `attach` 方法，并提供存储磁盘上文件的绝对路径。或者，你可以从 `toMail` 方法中返回一个 [可邮寄对象](/docs/laravel/10.x/mailmd#generating-mailables)：\r\n\r\n    use App\\Mail\\InvoicePaid as InvoicePaidMailable;\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): Mailable\r\n    {\r\n        return (new InvoicePaidMailable($this->invoice))\r\n                    ->to($notifiable->email)\r\n                    ->attachFromStorage('/path/to/file');\r\n    }\r\n\r\n\r\n\r\n必要时，可以使用 `attachMany` 方法将多个文件附加到消息中：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->greeting('你好!')\r\n                    ->attachMany([\r\n                        '/path/to/forge.svg',\r\n                        '/path/to/vapor.svg' => [\r\n                            'as' => 'Logo.svg',\r\n                            'mime' => 'image/svg+xml',\r\n                        ],\r\n                    ]);\r\n    }\r\n\r\n<a name=\"raw-data-attachments\"></a>\r\n#### 原始数据附件\r\n\r\n`attachData` 方法可以用于将原始字节数组附加为附件。在调用 `attachData` 方法时，应提供应分配给附件的文件名：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->greeting('你好!')\r\n                    ->attachData($this->pdf, 'name.pdf', [\r\n                        'mime' => 'application/pdf',\r\n                    ]);\r\n    }\r\n\r\n<a name=\"adding-tags-metadata\"></a>\r\n### 添加标签和元数据\r\n\r\n一些第三方电子邮件提供商（如 Mailgun 和 Postmark）支持消息「标签」和「元数据」，可用于分组和跟踪应用程序发送的电子邮件。可以通过 `tag` 和 `metadata` 方法将标签和元数据添加到电子邮件消息中：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->greeting('评论点赞！')\r\n                    ->tag('点赞')\r\n                    ->metadata('comment_id', $this->comment->id);\r\n    }\r\n\r\n如果你的应用程序使用 Mailgun 驱动程序，则可以查阅 Mailgun 的文档以获取有关 [标签](https://documentation.mailgun.com/en/latest/user_manual.html#tagging-1) 和 [元数据](https://documentation.mailgun.com/en/latest/user_manual.html#attaching-data-to-messages) 的更多信息。同样，也可以参考 Postmark 文档了解他们对 [标签](https://postmarkapp.com/blog/tags-support-for-smtp) 和 [元数据](https://postmarkapp.com/support/article/1125-custom-metadata-faq) 的支持。\r\n\r\n\r\n如果你的应用程序使用 Amazon SES 发送电子邮件，则应使用 `metadata` 方法将 [SES 「标签」](https://docs.aws.amazon.com/ses/latest/APIReference/API_MessageTag.html)附加到消息。\r\n<a name=\"customizing-the-symfony-message\"></a>\r\n### 自定义 Symfony 消息\r\n\r\n`MailMessage`类的`withSymfonyMessage`方法允许你注册一个闭包，在发送消息之前将调用Symfony Message实例。这给你在传递消息之前有深度自定义消息的机会：\r\n\r\n    use Symfony\\Component\\Mime\\Email;\r\n\r\n    /**\r\n     * 获取通知的邮件表示形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->withSymfonyMessage(function (Email $message) {\r\n                        $message->getHeaders()->addTextHeader(\r\n                            'Custom-Header', 'Header Value'\r\n                        );\r\n                    });\r\n    }\r\n\r\n<a name=\"using-mailables\"></a>\r\n### 使用可邮寄对象\r\n\r\n如果需要，你可以从通知的 `toMail` 方法返回完整的 [mailable 对象](/docs/laravel/10.x/mail)。当返回 `Mailable` 而不是 `MailMessage` 时，你需要使用可邮寄对象的 `to` 方法指定消息接收者：\r\n\r\n    use App\\Mail\\InvoicePaid as InvoicePaidMailable;\r\n    use Illuminate\\Mail\\Mailable;\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): Mailable\r\n    {\r\n        return (new InvoicePaidMailable($this->invoice))\r\n                    ->to($notifiable->email);\r\n    }\r\n\r\n<a name=\"mailables-and-on-demand-notifications\"></a>\r\n#### 可邮寄对象和按需通知\r\n\r\n如果你正在发送[按需通知](#on-demand-notifications)，则提供给`toMail`方法的`$notifiable`实例将是`Illuminate\\Notifications\\AnonymousNotifiable`的一个实例，它提供了一个`routeNotificationFor`方法，该方法可用于检索应将按需通知发送到的电子邮件地址：\r\n\r\n    use App\\Mail\\InvoicePaid as InvoicePaidMailable;\r\n    use Illuminate\\Notifications\\AnonymousNotifiable;\r\n    use Illuminate\\Mail\\Mailable;\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): Mailable\r\n    {\r\n        $address = $notifiable instanceof AnonymousNotifiable\r\n                ? $notifiable->routeNotificationFor('mail')\r\n                : $notifiable->email;\r\n\r\n        return (new InvoicePaidMailable($this->invoice))\r\n                    ->to($address);\r\n    }\r\n\r\n<a name=\"previewing-mail-notifications\"></a>\r\n### 预览邮件通知\r\n\r\n设计邮件通知模板时，可以像典型的 Blade 模板一样在浏览器中快速预览呈现的邮件消息。出于这个原因，Laravel 允许你直接从路由闭包或控制器返回由邮件通知生成的任何邮件消息。当返回一个 `MailMessage` 时，它将在浏览器中呈现和显示，让你可以快速预览其设计，无需将其发送到实际的电子邮件地址：\r\n\r\n    use App\\Models\\Invoice;\r\n    use App\\Notifications\\InvoicePaid;\r\n\r\n    Route::get('/notification', function () {\r\n        $invoice = Invoice::find(1);\r\n\r\n        return (new InvoicePaid($invoice))\r\n                    ->toMail($invoice->user);\r\n    });\r\n\r\n<a name=\"markdown-mail-notifications\"></a>\r\n## Markdown 邮件通知\r\n\r\nMarkdown 邮件通知允许你利用邮件通知的预构建模板，同时为你提供编写更长、定制化消息的自由。由于这些消息是用 Markdown 写的，因此 Laravel 能够为消息呈现漂亮、响应式的 HTML 模板，同时还会自动生成一个纯文本的副本。\r\n\r\n<a name=\"generating-the-message\"></a>\r\n### 生成消息\r\n\r\n要生成具有相应 Markdown 模板的通知，可以使用 `make:notification` Artisan 命令的 `--markdown` 选项：\r\n\r\n```shell\r\nphp artisan make:notification InvoicePaid --markdown=mail.invoice.paid\r\n```\r\n\r\n与所有其他邮件通知一样，使用 Markdown 模板的通知应该在其通知类上定义一个 `toMail` 方法。但是，不要使用 `line` 和 `action` 方法构建通知，而是使用 `markdown` 方法指定应该使用的 Markdown 模板的名称。你希望提供给模板的数据数组可以作为该方法的第二个参数传递：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        $url = url('/invoice/'.$this->invoice->id);\r\n\r\n        return (new MailMessage)\r\n                    ->subject('发票支付')\r\n                    ->markdown('mail.invoice.paid', ['url' => $url]);\r\n    }\r\n\r\n<a name=\"writing-the-message\"></a>\r\n### 编写消息\r\n\r\nMarkdown 邮件通知使用 Blade 组件和 Markdown 语法的组合，可以让你在利用 Laravel 的预构建通知组件的同时，轻松构建通知：\r\n\r\n```blade\r\n<x-mail::message>\r\n# 发票支付\r\n\r\n你的发票已支付!\r\n\r\n<x-mail::button :url=\"$url\">\r\n查看发票\r\n</x-mail::button>\r\n\r\n谢谢，<br>\r\n{{ config('app.name') }}\r\n</x-mail::message>\r\n```\r\n\r\n<a name=\"button-component\"></a>\r\n#### Button 组件\r\n\r\nButton 组件会呈现一个居中的按钮链接。该组件接受两个参数，`url` 和一个可选的 `color`。支持的颜色有 `primary`、`green` 和 `red`。你可以在通知中添加任意数量的 Button 组件：\r\n\r\n```blade\r\n<x-mail::button :url=\"$url\" color=\"green\">\r\n查看发票\r\n</x-mail::button>\r\n```\r\n\r\n<a name=\"panel-component\"></a>\r\n#### Panel 组件\r\nPanel 组件会在通知中呈现给定的文本块，并在面板中以稍微不同的背景颜色呈现。这让你可以引起读者对特定文本块的注意：\r\n\r\n```blade\r\n<x-mail::panel>\r\n这是面板内容。\r\n</x-mail::panel>\r\n```\r\n\r\n<a name=\"table-component\"></a>\r\n#### Table 组件\r\nTable 组件允许你将 Markdown 表格转换为 HTML 表格。该组件接受 Markdown 表格作为其内容。可以使用默认的 Markdown 表格对齐语法来支持表格列对齐：\r\n\r\n```blade\r\n<x-mail::table>\r\n| Laravel       | Table         | Example  |\r\n| ------------- |:-------------:| --------:|\r\n| Col 2 is      | Centered      | $10      |\r\n| Col 3 is      | Right-Aligned | $20      |\r\n</x-mail::table>\r\n```\r\n\r\n<a name=\"customizing-the-components\"></a>\r\n### 定制组件\r\n你可以将所有的 Markdown 通知组件导出到自己的应用程序进行定制。要导出组件，请使用 `vendor:publish` Artisan 命令来发布 `laravel-mail` 资源标记：\r\n\r\n\r\n这个命令会将 Markdown 邮件组件发布到 `resources/views/vendor/mail` 目录下。`mail` 目录将包含一个 `html` 和一个 `text` 目录，每个目录都包含其可用组件的各自表示形式。你可以自由地按照自己的喜好定制这些组件。\r\n\r\n<a name=\"customizing-the-css\"></a>\r\n#### 定制 CSS 样式\r\n\r\n在导出组件之后，`resources/views/vendor/mail/html/themes` 目录将包含一个 `default.css` 文件。你可以在此文件中自定义 CSS 样式，你的样式将自动被内联到 Markdown 通知的 HTML 表示中。\r\n\r\n如果你想为 Laravel 的 Markdown 组件构建一个全新的主题，可以在 `html/themes` 目录中放置一个 CSS 文件。命名并保存 CSS 文件后，更新 `mail` 配置文件的 `theme` 选项以匹配你的新主题的名称。\r\n\r\n要为单个通知自定义主题，可以在构建通知的邮件消息时调用 `theme` 方法。`theme` 方法接受应该在发送通知时使用的主题名称：\r\n\r\n    /**\r\n     * 获取通知的邮件表现形式。\r\n     */\r\n    public function toMail(object $notifiable): MailMessage\r\n    {\r\n        return (new MailMessage)\r\n                    ->theme('发票')\r\n                    ->subject('发票支付')\r\n                    ->markdown('mail.invoice.paid', ['url' => $url]);\r\n    }\r\n\r\n<a name=\"database-notifications\"></a>\r\n## 数据库通知\r\n\r\n<a name=\"database-prerequisites\"></a>\r\n### 前提条件\r\n\r\n`database` 通知渠道将通知信息存储在一个数据库表中。该表将包含通知类型以及描述通知的 JSON 数据结构等信息。\r\n\r\n\r\n你可以查询该表，在你的应用程序用户界面中显示通知。但是，在此之前，你需要创建一个数据库表来保存你的通知。你可以使用 `notifications:table` 命令生成一个适当的表模式的 [迁移](/docs/laravel/10.x/migrations)：\r\n\r\n```shell\r\nphp artisan notifications:table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"formatting-database-notifications\"></a>\r\n### 格式化数据库通知\r\n\r\n如果一个通知支持被存储在一个数据库表中，你应该在通知类上定义一个 `toDatabase` 或 `toArray` 方法。这个方法将接收一个 `$notifiable` 实体，并应该返回一个普通的 PHP 数组。返回的数组将被编码为 JSON，并存储在你的 `notifications` 表的 `data` 列中。让我们看一个 `toArray` 方法的例子：\r\n\r\n    /**\r\n     * 获取通知的数组表示形式。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(object $notifiable): array\r\n    {\r\n        return [\r\n            'invoice_id' => $this->invoice->id,\r\n            'amount' => $this->invoice->amount,\r\n        ];\r\n    }\r\n\r\n<a name=\"todatabase-vs-toarray\"></a>\r\n#### `toDatabase` Vs. `toArray`\r\n\r\n`toArray` 方法也被 `broadcast` 频道用来确定要广播到你的 JavaScript 前端的数据。如果你想为 `database` 和 `broadcast` 频道定义两个不同的数组表示形式，你应该定义一个 `toDatabase` 方法，而不是一个 `toArray` 方法。\r\n\r\n<a name=\"accessing-the-notifications\"></a>\r\n### 访问通知\r\n\r\n一旦通知被存储在数据库中，你需要一个方便的方式从你的可通知实体中访问它们。`Illuminate\\Notifications\\Notifiable` trait 包含在 Laravel 的默认 `App\\Models\\User` 模型中，它包括一个 `notifications` [Eloquent 关联](/docs/laravel/10.x/eloquent-relationships)，返回实体的通知。要获取通知，你可以像访问任何其他 Eloquent 关系一样访问此方法。默认情况下，通知将按照 `created_at` 时间戳排序，最新的通知位于集合的开头：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    foreach ($user->notifications as $notification) {\r\n        echo $notification->type;\r\n    }\r\n\r\n如果你想要只检索「未读」的通知，你可以使用 `unreadNotifications` 关系。同样，这些通知将按照 `created_at` 时间戳排序，最新的通知位于集合的开头：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    foreach ($user->unreadNotifications as $notification) {\r\n        echo $notification->type;\r\n    }\r\n\r\n> **注意**  \r\n> 要从你的 JavaScript 客户端访问你的通知，你应该为你的应用程序定义一个通知控制器，该控制器返回一个可通知实体的通知，如当前用户。然后，你可以从你的 JavaScript 客户端向该控制器的 URL 发送 HTTP 请求。\r\n\r\n<a name=\"marking-notifications-as-read\"></a>\r\n### 将通知标记为已读\r\n\r\n通常，当用户查看通知时，你希望将通知标记为「已读」。`Illuminate\\Notifications\\Notifiable` trait 提供了一个 `markAsRead` 方法，该方法将更新通知的数据库记录上的 `read_at` 列：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    foreach ($user->unreadNotifications as $notification) {\r\n        $notification->markAsRead();\r\n    }\r\n\r\n然而，你可以直接在通知集合上使用 `markAsRead` 方法，而不是遍历每个通知：\r\n\r\n    $user->unreadNotifications->markAsRead();\r\n\r\n你也可以使用批量更新查询将所有通知标记为已读而不必从数据库中检索它们：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    $user->unreadNotifications()->update(['read_at' => now()]);\r\n\r\n你可以使用 `delete` 方法将通知删除并从表中完全移除：\r\n\r\n    $user->notifications()->delete();\r\n\r\n<a name=\"broadcast-notifications\"></a>\r\n## 广播通知\r\n\r\n<a name=\"broadcast-prerequisites\"></a>\r\n### 前提条件\r\n\r\n在广播通知之前，你应该配置并熟悉 Laravel 的 [事件广播](/docs/laravel/10.x/broadcasting) 服务。事件广播提供了一种从你的 JavaScript 前端响应服务器端 Laravel 事件的方法。\r\n\r\n<a name=\"formatting-broadcast-notifications\"></a>\r\n### 格式化广播通知\r\n\r\n`broadcast` 频道使用 Laravel 的 [事件广播](/docs/laravel/10.x/broadcasting) 服务来广播通知，允许你的 JavaScript 前端实时捕获通知。如果通知支持广播，你可以在通知类上定义一个 `toBroadcast` 方法。该方法将接收一个 `$notifiable` 实体，并应该返回一个 `BroadcastMessage` 实例。如果 `toBroadcast` 方法不存在，则将使用 `toArray` 方法来收集应该广播的数据。返回的数据将被编码为 JSON 并广播到你的 JavaScript 前端。让我们看一个 `toBroadcast` 方法的示例：\r\n\r\n    use Illuminate\\Notifications\\Messages\\BroadcastMessage;\r\n\r\n    /**\r\n     * 获取通知的可广播表示形式。\r\n     */\r\n    public function toBroadcast(object $notifiable): BroadcastMessage\r\n    {\r\n        return new BroadcastMessage([\r\n            'invoice_id' => $this->invoice->id,\r\n            'amount' => $this->invoice->amount,\r\n        ]);\r\n    }\r\n\r\n<a name=\"broadcast-queue-configuration\"></a>\r\n#### 广播队列配置\r\n\r\n所有广播通知都会被排队等待广播。如果你想配置用于排队广播操作的队列连接或队列名称，你可以使用 `BroadcastMessage` 的 `onConnection` 和 `onQueue` 方法：\r\n\r\n    return (new BroadcastMessage($data))\r\n                    ->onConnection('sqs')\r\n                    ->onQueue('broadcasts');\r\n\r\n<a name=\"customizing-the-notification-type\"></a>\r\n#### 自定义通知类型\r\n\r\n除了你指定的数据之外，所有广播通知还包含一个 `type` 字段，其中包含通知的完整类名。如果你想要自定义通知的 `type`，可以在通知类上定义一个 `broadcastType` 方法：\r\n\r\n    /**\r\n     * 获取正在广播的通知类型。\r\n     */\r\n    public function broadcastType(): string\r\n    {\r\n        return 'broadcast.message';\r\n    }\r\n\r\n<a name=\"listening-for-notifications\"></a>\r\n### 监听通知\r\n\r\n通知会以 `{notifiable}.{id}` 的格式在一个私有频道上广播。因此，如果你向一个 ID 为 `1` 的 `App\\Models\\User` 实例发送通知，通知将在 `App.Models.User.1` 私有频道上广播。当使用 [Laravel Echo](/docs/laravel/10.x/broadcastingmd#client-side-installation) 时，你可以使用 `notification` 方法轻松地在频道上监听通知：\r\n\r\n    Echo.private('App.Models.User.' + userId)\r\n        .notification((notification) => {\r\n            console.log(notification.type);\r\n        });\r\n\r\n<a name=\"customizing-the-notification-channel\"></a>\r\n#### 自定义通知频道\r\n\r\n如果你想自定义实体的广播通知在哪个频道上广播，可以在可通知实体上定义一个 `receivesBroadcastNotificationsOn` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Broadcasting\\PrivateChannel;\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * 用户接收通知广播的频道。\r\n         */\r\n        public function receivesBroadcastNotificationsOn(): string\r\n        {\r\n            return 'users.'.$this->id;\r\n        }\r\n    }\r\n\r\n<a name=\"sms-notifications\"></a>\r\n## 短信通知\r\n\r\n<a name=\"sms-prerequisites\"></a>\r\n### 先决条件\r\n\r\nLaravel 中发送短信通知是由 [Vonage](https://www.vonage.com/)（之前称为 Nexmo）驱动的。在通过 Vonage 发送通知之前，你需要安装 `laravel/vonage-notification-channel` 和 `guzzlehttp/guzzle` 包：\r\n\r\n    composer require laravel/vonage-notification-channel guzzlehttp/guzzle\r\n\r\n该包包括一个 [配置文件](https://github.com/laravel/vonage-notification-channel/blob/3.x/config/vonage.php)。但是，你不需要将此配置文件导出到自己的应用程序。你可以简单地使用 `VONAGE_KEY` 和 `VONAGE_SECRET` 环境变量来定义 Vonage 的公共和私有密钥。\r\n\r\n定义好密钥后，你可以设置一个 `VONAGE_SMS_FROM` 环境变量，该变量定义了你发送 SMS 消息的默认电话号码。你可以在 Vonage 控制面板中生成此电话号码：\r\n\r\n    VONAGE_SMS_FROM=15556666666\r\n\r\n<a name=\"formatting-sms-notifications\"></a>\r\n### 格式化短信通知\r\n\r\n如果通知支持作为 SMS 发送，你应该在通知类上定义一个 `toVonage` 方法。此方法将接收一个 `$notifiable` 实体并应返回一个 `Illuminate\\Notifications\\Messages\\VonageMessage` 实例：\r\n\r\n    use Illuminate\\Notifications\\Messages\\VonageMessage;\r\n\r\n    /**\r\n     * 获取通知的 Vonage / SMS 表达式。\r\n     */\r\n    public function toVonage(object $notifiable): VonageMessage\r\n    {\r\n        return (new VonageMessage)\r\n                    ->content('你的短信内容');\r\n    }\r\n\r\n<a name=\"unicode-content\"></a>\r\n#### Unicode 内容\r\n\r\n如果你的 SMS 消息将包含 unicode 字符，你应该在构造 `VonageMessage` 实例时调用 `unicode` 方法：\r\n\r\n    use Illuminate\\Notifications\\Messages\\VonageMessage;\r\n\r\n    /**\r\n     * 获取通知的 Vonage / SMS 表达式。\r\n     */\r\n    public function toVonage(object $notifiable): VonageMessage\r\n    {\r\n        return (new VonageMessage)\r\n                    ->content('你的统一码消息')\r\n                    ->unicode();\r\n    }\r\n\r\n<a name=\"customizing-the-from-number\"></a>\r\n### 自定义「来源」号码\r\n\r\n如果你想从一个不同于 `VONAGE_SMS_FROM` 环境变量所指定的电话号码发送通知，你可以在 `VonageMessage` 实例上调用 `from` 方法：\r\n\r\n    use Illuminate\\Notifications\\Messages\\VonageMessage;\r\n\r\n    /**\r\n     * 获取通知的 Vonage / SMS 表达式。\r\n     */\r\n    public function toVonage(object $notifiable): VonageMessage\r\n    {\r\n        return (new VonageMessage)\r\n                    ->content('您的短信内容')\r\n                    ->from('15554443333');\r\n    }\r\n\r\n<a name=\"adding-a-client-reference\"></a>\r\n### 添加客户关联\r\n\r\n如果你想跟踪每个用户、团队或客户的消费，你可以在通知中添加「客户关联」。Vonage 将允许你使用这个客户关联生成报告，以便你能更好地了解特定客户的短信使用情况。客户关联可以是任何字符串，最多 40 个字符。\r\n\r\n    use Illuminate\\Notifications\\Messages\\VonageMessage;\r\n\r\n    /**\r\n     * 获取通知的 Vonage / SMS 表达式。\r\n     */\r\n    public function toVonage(object $notifiable): VonageMessage\r\n    {\r\n        return (new VonageMessage)\r\n                    ->clientReference((string) $notifiable->id)\r\n                    ->content('你的短信内容');\r\n    }\r\n\r\n<a name=\"routing-sms-notifications\"></a>\r\n### 路由短信通知\r\n\r\n要将 Vonage 通知路由到正确的电话号码，请在你的通知实体上定义 `routeNotificationForVonage` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * Vonage 通道的路由通知。\r\n         */\r\n        public function routeNotificationForVonage(Notification $notification): string\r\n        {\r\n            return $this->phone_number;\r\n        }\r\n    }\r\n\r\n<a name=\"slack-notifications\"></a>\r\n## Slack 通知\r\n\r\n<a name=\"slack-prerequisites\"></a>\r\n### 先决条件\r\n\r\n在你可以通过 Slack 发送通知之前，你必须通过 Composer 安装 Slack 通知通道：\r\n\r\n```shell\r\ncomposer require laravel/slack-notification-channel\r\n```\r\n\r\n你还需要为你的团队创建一个 [Slack 应用](https://api.slack.com/apps?new_app=1)。创建应用后，你应该为工作区配置一个「传入 Webhook」。 然后，Slack 将为你提供一个 webhook URL，你可以在 [路由 Slack 通知](#routing-slack-notifications) 时使用该 URL。\r\n\r\n<a name=\"formatting-slack-notifications\"></a>\r\n### 格式化 Slack 通知\r\n\r\n如果通知支持作为 Slack 消息发送，你应在通知类上定义 `toSlack` 方法。此方法将接收一个 `$notifiable` 实体并应返回一个 `Illuminate\\Notifications\\Messages\\SlackMessage` 实例。Slack 消息可能包含文本内容以及格式化附加文本或字段数组的「附件」。  让我们看一个基本的 `toSlack` 示例：\r\n\r\n    use Illuminate\\Notifications\\Messages\\SlackMessage;\r\n\r\n    /**\r\n     * 获取通知的 Slack 表达式。\r\n     */\r\n    public function toSlack(object $notifiable): SlackMessage\r\n    {\r\n        return (new SlackMessage)\r\n                    ->content('你的一张发票已经付款了！');\r\n    }\r\n\r\n<a name=\"slack-attachments\"></a>\r\n### Slack 附件\r\n\r\n你还可以向 Slack 消息添加「附件」。附件提供比简单文本消息更丰富的格式选项。在这个例子中，我们将发送一个关于应用程序中发生的异常的错误通知，包括一个链接，以查看有关异常的更多详细信息：\r\n\r\n    use Illuminate\\Notifications\\Messages\\SlackAttachment;\r\n    use Illuminate\\Notifications\\Messages\\SlackMessage;\r\n\r\n    /**\r\n     * 获取通知的 Slack 表示形式。\r\n     */\r\n    public function toSlack(object $notifiable): SlackMessage\r\n    {\r\n        $url = url('/exceptions/'.$this->exception->id);\r\n\r\n        return (new SlackMessage)\r\n                    ->error()\r\n                    ->content('哎呀！出了问题。')\r\n                    ->attachment(function (SlackAttachment $attachment) use ($url) {\r\n                        $attachment->title('例外：文件未找到', $url)\r\n                                   ->content('文件 [background.jpg] 未找到。');\r\n                    });\r\n    }\r\n\r\n附件还允许你指定应呈现给用户的数据数组。 给定的数据将以表格形式呈现，以便于阅读：\r\n\r\n    use Illuminate\\Notifications\\Messages\\SlackAttachment;\r\n    use Illuminate\\Notifications\\Messages\\SlackMessage;\r\n\r\n    /**\r\n     * 获取通知的 Slack 表示形式。\r\n     */\r\n    public function toSlack(object $notifiable): SlackMessage\r\n    {\r\n        $url = url('/invoices/'.$this->invoice->id);\r\n\r\n        return (new SlackMessage)\r\n                    ->success()\r\n                    ->content('你的一张发票已经付款了！')\r\n                    ->attachment(function (SlackAttachment $attachment) use ($url) {\r\n                        $attachment->title('Invoice 1322', $url)\r\n                                   ->fields([\r\n                                        'Title' => 'Server Expenses',\r\n                                        'Amount' => '$1,234',\r\n                                        'Via' => 'American Express',\r\n                                        'Was Overdue' => ':-1:',\r\n                                    ]);\r\n                    });\r\n    }\r\n\r\n<a name=\"markdown-attachment-content\"></a>\r\n#### Markdown 附件内容\r\n\r\n如果你的附件字段中包含 Markdown，则可以使用 `markdown` 方法指示 Slack 解析和显示给定的附件字段为 Markdown 格式的文本。此方法接受的值是：`pretext`、`text`和/或`fields`。有关 Slack 附件格式的更多信息，请查看 [Slack API 文档](https://api.slack.com/docs/message-formatting#message_formatting)：\r\n\r\n    use Illuminate\\Notifications\\Messages\\SlackAttachment;\r\n    use Illuminate\\Notifications\\Messages\\SlackMessage;\r\n\r\n    /**\r\n     * 获取通知的 Slack 表示形式。\r\n     */\r\n    public function toSlack(object $notifiable): SlackMessage\r\n    {\r\n        $url = url('/exceptions/'.$this->exception->id);\r\n\r\n        return (new SlackMessage)\r\n                    ->error()\r\n                    ->content('Whoops! Something went wrong.')\r\n                    ->attachment(function (SlackAttachment $attachment) use ($url) {\r\n                        $attachment->title('Exception: File Not Found', $url)\r\n                                   ->content('File [background.jpg] was *not found*.')\r\n                                   ->markdown(['text']);\r\n                    });\r\n    }\r\n\r\n<a name=\"routing-slack-notifications\"></a>\r\n### 路由 Slack 通知\r\n\r\n为了将 Slack 通知路由到正确的 Slack 团队和频道，请在你的通知实体上定义一个 `routeNotificationForSlack` 方法。它应该返回要传送通知的 Webhook URL。Webhook URL 可以通过向你的 Slack 团队添加「传入 Webhook」服务来生成：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * 路由 Slack 频道的通知。\r\n         */\r\n        public function routeNotificationForSlack(Notification $notification): string\r\n        {\r\n            return 'https://hooks.slack.com/services/...';\r\n        }\r\n    }\r\n\r\n<a name=\"localizing-notifications\"></a>\r\n## 本地化通知\r\n\r\nLaravel 允许你在除了当前请求语言环境之外的其他语言环境中发送通知，甚至在通知被队列化的情况下也能记住此语言环境。\r\n\r\n为了实现这一功能，`Illuminate\\Notifications\\Notification` 类提供了 `locale` 方法来设置所需的语言环境。在通知被评估时，应用程序将切换到此语言环境，然后在评估完成后恢复到以前的语言环境：\r\n\r\n    $user->notify((new InvoicePaid($invoice))->locale('es'));\r\n\r\n通过 `Notification` 门面，也可以实现多个通知实体的本地化：\r\n\r\n    Notification::locale('es')->send(\r\n        $users, new InvoicePaid($invoice)\r\n    );\r\n\r\n<a name=\"user-preferred-locales\"></a>\r\n### 用户首选语言环境\r\n\r\n有时，应用程序会存储每个用户的首选区域设置。通过在你的可通知模型上实现 `HasLocalePreference` 合同，你可以指示 Laravel 在发送通知时使用此存储的区域设置：\r\n\r\n    use Illuminate\\Contracts\\Translation\\HasLocalePreference;\r\n\r\n    class User extends Model implements HasLocalePreference\r\n    {\r\n        /**\r\n         * 获取用户的首选语言环境。\r\n         */\r\n        public function preferredLocale(): string\r\n        {\r\n            return $this->locale;\r\n        }\r\n    }\r\n\r\n翻译：一旦你实现了这个接口，当发送通知和邮件到该模型时，Laravel 会自动使用首选语言环境。因此，在使用此接口时不需要调用`locale`方法：\r\n\r\n    $user->notify(new InvoicePaid($invoice));\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n你可以使用 `Notification` 门面的 `fake` 方法来阻止通知被发送。通常情况下，发送通知与你实际测试的代码无关。很可能，只需要断言 Laravel 被指示发送了给定的通知即可。\r\n\r\n在调用 `Notification` 门面的 `fake` 方法后，你可以断言已经被告知将通知发送给用户，甚至检查通知接收到的数据：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Notifications\\OrderShipped;\r\n    use Illuminate\\Support\\Facades\\Notification;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_orders_can_be_shipped(): void\r\n        {\r\n            Notification::fake();\r\n\r\n            // 执行订单发货...\r\n\r\n            // 断言没有发送通知...\r\n            Notification::assertNothingSent();\r\n\r\n            // 断言通知已发送给给定用户...\r\n            Notification::assertSentTo(\r\n                [$user], OrderShipped::class\r\n            );\r\n\r\n            // 断言未发送通知...\r\n            Notification::assertNotSentTo(\r\n                [$user], AnotherNotification::class\r\n            );\r\n\r\n            // 断言已发送给定数量的通知...\r\n            Notification::assertCount(3);\r\n        }\r\n    }\r\n\r\n你可以通过向 `assertSentTo` 或 `assertNotSentTo` 方法传递一个闭包来断言发送了符合给定「真实性测试」的通知。如果发送了至少一个符合给定真实性测试的通知，则断言将成功：\r\n\r\n    Notification::assertSentTo(\r\n        $user,\r\n        function (OrderShipped $notification, array $channels) use ($order) {\r\n            return $notification->order->id === $order->id;\r\n        }\r\n    );\r\n\r\n<a name=\"on-demand-notifications\"></a>\r\n#### 按需通知\r\n\r\n如果你正在测试的代码发送 [即时通知](https://chat.openai.com/chat#on-demand-notifications)，你可以使用 `assertSentOnDemand` 方法测试是否发送了即时通知：\r\n\r\n    Notification::assertSentOnDemand(OrderShipped::class);\r\n\r\n通过将闭包作为 `assertSentOnDemand` 方法的第二个参数传递，你可以确定是否将即时通知发送到了正确的 「route」 地址：\r\n\r\n    Notification::assertSentOnDemand(\r\n        OrderShipped::class,\r\n        function (OrderShipped $notification, array $channels, object $notifiable) use ($user) {\r\n            return $notifiable->routes['mail'] === $user->email;\r\n        }\r\n    );\r\n\r\n<a name=\"notification-events\"></a>\r\n## 通知事件\r\n\r\n<a name=\"notification-sending-event\"></a>\r\n#### 通知发送事件\r\n\r\n发送通知时，通知系统会调度 `Illuminate\\Notifications\\Events\\NotificationSending` [事件](/docs/laravel/10.x/events)。 这包含「可通知」实体和通知实例本身。 你可以在应用程序的 `EventServiceProvider` 中为该事件注册监听器：\r\n\r\n    use App\\Listeners\\CheckNotificationStatus;\r\n    use Illuminate\\Notifications\\Events\\NotificationSending;\r\n    \r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        NotificationSending::class => [\r\n            CheckNotificationStatus::class,\r\n        ],\r\n    ];\r\n\r\n如果 `NotificationSending` 事件的监听器从它的 `handle` 方法返回 `false`，通知将不会被发送：\r\n\r\n    use Illuminate\\Notifications\\Events\\NotificationSending;\r\n\r\n    /**\r\n     * 处理事件。\r\n     */\r\n    public function handle(NotificationSending $event): void\r\n    {\r\n        return false;\r\n    }\r\n\r\n在事件监听器中，你可以访问事件的 `notifiable`、`notification` 和 `channel` 属性，以了解有关通知接收者或通知本身的更多信息。\r\n\r\n    /**\r\n     * 处理事件。\r\n     */\r\n    public function handle(NotificationSending $event): void\r\n    {\r\n        // $event->channel\r\n        // $event->notifiable\r\n        // $event->notification\r\n    }\r\n\r\n<a name=\"notification-sent-event\"></a>\r\n#### 通知发送事件\r\n\r\n当通知被发送时，通知系统会触发 `Illuminate\\Notifications\\Events\\NotificationSent` [事件](/docs/laravel/10.x/events)，其中包含 「notifiable」 实体和通知实例本身。你可以在 `EventServiceProvider` 中注册此事件的监听器：\r\n\r\n    use App\\Listeners\\LogNotification;\r\n    use Illuminate\\Notifications\\Events\\NotificationSent;\r\n    \r\n    /**\r\n     * 应用程序的事件侦听器映射。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        NotificationSent::class => [\r\n            LogNotification::class,\r\n        ],\r\n    ];\r\n\r\n> **注意**  \r\n> 在 `EventServiceProvider` 中注册了监听器之后，可以使用 event:generate Artisan 命令快速生成监听器类。\r\n\r\n在事件监听器中，你可以访问事件上的 `notifiable`、`notification`、`channel` 和 `response` 属性，以了解更多有关通知收件人或通知本身的信息：\r\n\r\n    /**\r\n     * 处理事件。\r\n     */\r\n    public function handle(NotificationSent $event): void\r\n    {\r\n        // $event->channel\r\n        // $event->notifiable\r\n        // $event->notification\r\n        // $event->response\r\n    }\r\n\r\n<a name=\"custom-channels\"></a>\r\n## 自定义频道\r\nLaravel 提供了一些通知频道，但你可能想编写自己的驱动程序，以通过其他频道传递通知。Laravel 让这变得简单。要开始，定义一个包含 `send` 方法的类。该方法应接收两个参数：`$notifiable` 和 `$notification`。\r\n\r\n在 `send` 方法中，你可以调用通知上的方法来检索一个由你的频道理解的消息对象，然后按照你希望的方式将通知发送给 `$notifiable` 实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Notifications;\r\n\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class VoiceChannel\r\n    {\r\n        /**\r\n         * 发送给定的通知\r\n         */\r\n        public function send(object $notifiable, Notification $notification): void\r\n        {\r\n            $message = $notification->toVoice($notifiable);\r\n\r\n            // 将通知发送给 $notifiable 实例...\r\n        }\r\n    }\r\n\r\n一旦你定义了你的通知频道类，你可以从你的任何通知的 `via` 方法返回该类的名称。在这个例子中，你的通知的 `toVoice` 方法可以返回你选择来表示语音消息的任何对象。例如，你可以定义自己的 `VoiceMessage` 类来表示这些消息：\r\n\r\n    <?php\r\n\r\n    namespace App\\Notifications;\r\n\r\n    use App\\Notifications\\Messages\\VoiceMessage;\r\n    use App\\Notifications\\VoiceChannel;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Notifications\\Notification;\r\n\r\n    class InvoicePaid extends Notification\r\n    {\r\n        use Queueable;\r\n\r\n        /**\r\n         * 获取通知频道\r\n         */\r\n        public function via(object $notifiable): string\r\n        {\r\n            return VoiceChannel::class;\r\n        }\r\n\r\n        /**\r\n         * 获取通知的语音表示形式\r\n         */\r\n        public function toVoice(object $notifiable): VoiceMessage\r\n        {\r\n            // ...\r\n        }\r\n    }","p":"docs/notifications.html"},{"t":"packages (包开发)","d":"# 包开发\r\n\r\n- [介绍](#introduction)\r\n    - [关于 Facades](#a-note-on-facades)\r\n- [包发现](#package-discovery)\r\n- [服务提供者](#service-providers)\r\n- [资源](#resources)\r\n    - [配置](#configuration)\r\n    - [迁移](#migrations)\r\n    - [路由](#routes)\r\n    - [语言文件](#language-files)\r\n    - [视图](#views)\r\n    - [视图组件](#view-components)\r\n    - [\"About\" Artisan 命令](#about-artisan-command)\r\n- [命令](#commands)\r\n- [公共资源](#public-assets)\r\n- [发布文件组](#publishing-file-groups)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n包是向 Laravel 添加功能的主要方式。包可能是处理日期的好方法，例如 [Carbon](https://github.com/briannesbitt/Carbon)，也可能是允许您将文件与 Eloquent 模型相关联的包，例如 Spatie 的 [Laravel 媒体库](https://github.com/spatie/laravel-medialibrary)。\r\n\r\n包有不同类型。有些包是独立的，这意味着它们可以与任何 PHP 框架一起使用。 Carbon 和 PHPUnit 是独立包的示例。这种包可以通过 `composer.json` 文件引入，在 Laravel 中使用。\r\n\r\n此外，还有一些包是专门用在 Laravel 中。这些包可能包含路由、控制器、视图和配置，专门用于增强 Laravel 应用。本教程主要涵盖的就是这些专用于 Laravel 的包的开发。\r\n\r\n<a name=\"a-note-on-facades\"></a>\r\n### 关于 Facades\r\n\r\n编写 Laravel 应用时，通常使用契约（Contracts）还是门面（Facades）并不重要，因为两者都提供了基本相同的可测试性级别。但是，在编写包时，包通常是无法使用 Laravel 的所有测试辅助函数。如果您希望能够像将包安装在典型的 Laravel 应用程序中一样编写包测试，您可以使用 [Orchestral Testbench](https://github.com/orchestral/testbench) 包。\r\n\r\n\r\n<a name=\"package-discovery\"></a>\r\n## 包发现\r\n\r\n在 Laravel 应用程序的 `config/app.php` 配置文件中，providers 选项定义了 Laravel 应该加载的服务提供者列表。当有人安装您的软件包时，您通常希望您的服务提供者也包含在此列表中。 您可以在包的 `composer.json` 文件的 `extra` 部分中定义提供者，而不是要求用户手动将您的服务提供者添加到列表中。除了服务提供者外，您还可以列出您想注册的任何 [facades](/docs/laravel/10.x/facades)：\r\n\r\n```json\r\n\"extra\": {\r\n    \"laravel\": {\r\n        \"providers\": [\r\n            \"Barryvdh\\\\Debugbar\\\\ServiceProvider\"\r\n        ],\r\n        \"aliases\": {\r\n            \"Debugbar\": \"Barryvdh\\\\Debugbar\\\\Facade\"\r\n        }\r\n    }\r\n},\r\n```\r\n\r\n当你的包配置了包发现后，Laravel 会在安装该包时自动注册服务提供者及 Facades，这样就为你的包用户创造一个便利的安装体验。\r\n\r\n<a name=\"opting-out-of-package-discovery\"></a>\r\n### 退出包发现\r\n\r\n如果你是包消费者，要禁用包发现功能，你可以在应用的 `composer.json` 文件的 `extra` 区域列出包名：\r\n\r\n```json\r\n\"extra\": {\r\n    \"laravel\": {\r\n        \"dont-discover\": [\r\n            \"barryvdh/laravel-debugbar\"\r\n        ]\r\n    }\r\n},\r\n```\r\n\r\n你可以在应用的 `dont-discover` 指令中使用 `*` 字符，禁用所有包的包发现功能：\r\n\r\n```json\r\n\"extra\": {\r\n    \"laravel\": {\r\n        \"dont-discover\": [\r\n            \"*\"\r\n        ]\r\n    }\r\n},\r\n```\r\n\r\n<a name=\"service-providers\"></a>\r\n## 服务提供者\r\n\r\n[服务提供者](/docs/laravel/10.x/providers)是你的包和 Laravel 之间的连接点。服务提供者负责将事物绑定到 Laravel 的[服务容器](/docs/laravel/10.x/container)并告知 Laravel 到哪里去加载包资源，比如视图、配置及语言文件。\r\n\r\n\r\n\r\n服务提供者扩展了 `Illuminate/Support/ServiceProvider` 类，包含两个方法： `register` 和 `boot`。基本的 `ServiceProvider` 类位于 `illuminate/support` Composer 包中，你应该把它添加到你自己包的依赖项中。要了解更多关于服务提供者的结构和目的，请查看 [服务提供者](/docs/laravel/10.x/providers).\r\n\r\n<a name=\"resources\"></a>\r\n## 资源\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\n通常情况下，你需要将你的包的配置文件发布到应用程序的 `config` 目录下。这将允许在使用包时覆盖扩展包中的默认配置选项。发布配置文件，需要在服务提供者的 `boot` 方法中调用 `publishes` 方法:\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->publishes([\r\n            __DIR__.'/../config/courier.php' => config_path('courier.php'),\r\n        ]);\r\n    }\r\n\r\n使用扩展包的时候执行 Laravel 的 `vendor:publish` 命令, 你的文件将被复制到指定的发布位置。 一旦你的配置被发布, 它的值可以像其他的配置文件一样被访问:\r\n\r\n    $value = config('courier.option');\r\n\r\n> **Warning**  \r\n> 你不应该在你的配置文件中定义闭包。当用户执行 `config:cache` Artisan 命令时，它们不能被正确序列化。\r\n\r\n<a name=\"default-package-configuration\"></a>\r\n#### 默认的包配置\r\n\r\n你也可以将你自己的包的配置文件与应用程序的发布副本合并。这将允许你的用户在配置文件的发布副本中只定义他们真正想要覆盖的选项。要合并配置文件的值，请使用你的服务提供者的 `register` 方法中的 `mergeConfigFrom` 方法。\r\n\r\n\r\n\r\n`mergeConfigFrom` 方法的第一个参数为你的包的配置文件的路径，第二个参数为应用程序的配置文件副本的名称：\r\n\r\n    /**\r\n     * 注册应用程序服务\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->mergeConfigFrom(\r\n            __DIR__.'/../config/courier.php', 'courier'\r\n        );\r\n    }\r\n\r\n> **Warning**  \r\n> 这个方法只合并了配置数组的第一层。如果你的用户部分地定义了一个多维的配置阵列，缺少的选项将不会被合并。\r\n\r\n<a name=\"routes\"></a>\r\n### 路由\r\n\r\n如果你的软件包包含路由，你可以使用 `loadRoutesFrom` 方法加载它们。这个方法会自动判断应用程序的路由是否被缓存，如果路由已经被缓存，则不会加载你的路由文件：\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->loadRoutesFrom(__DIR__.'/../routes/web.php');\r\n    }\r\n\r\n<a name=\"migrations\"></a>\r\n### 迁移\r\n\r\n如果你的软件包包含了 [数据库迁移](/docs/laravel/10.x/migrations) , 你可以使用 `loadMigrationsFrom` 方法来加载它们。`loadMigrationsFrom` 方法的参数为软件包迁移文件的路径。\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->loadMigrationsFrom(__DIR__.'/../database/migrations');\r\n    }\r\n\r\n一旦你的软件包的迁移被注册，当 `php artisan migrate` 命令被执行时，它们将自动被运行。你不需要把它们导出到应用程序的 `database/migrations` 目录中。\r\n\r\n<a name=\"language-files\"></a>\r\n### 语言文件\r\n\r\n如果你的软件包包含 [语言文件](/docs/laravel/10.x/localization) , 你可以使用 `loadTranslationsFrom` 方法来加载它们。 例如, 如果你的包被命名为 `courier` , 你应该在你的服务提供者的 `boot` 方法中加入以下内容:\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');\r\n    }\r\n\r\n\r\n\r\n包的翻译行是使用 `package::file.line` 的语法惯例来引用的。因此，你可以这样从 `messages` 文件中加载 `courier` 包的 `welcome` 行：\r\n\r\n    echo trans('courier::messages.welcome');\r\n\r\n<a name=\"publishing-language-files\"></a>\r\n#### 发布语言文件\r\n\r\n如果你想把包的语言文件发布到应用程序的 `lang/vendor` 目录，可以使用服务提供者的 `publishes` 方法。`publishes` 方法接受一个软件包路径和它们所需的发布位置的数组。例如，要发布 `courier` 包的语言文件，你可以做以下工作：\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');\r\n\r\n        $this->publishes([\r\n            __DIR__.'/../lang' => $this->app->langPath('vendor/courier'),\r\n        ]);\r\n    }\r\n\r\n当你的软件包的用户执行Laravel的 `vendor:publish` Artisan 命令时, 你的软件包的语言文件会被发布到指定的发布位置。\r\n\r\n<a name=\"views\"></a>\r\n### 视图\r\n\r\n要在 Laravel 注册你的包的 [视图](/docs/laravel/10.x/views) , 你需要告诉 Laravel 这些视图的位置. 你可以使用服务提供者的 `loadViewsFrom` 方法来完成。`loadViewsFrom` 方法接受两个参数: 视图模板的路径和包的名称。 例如，如果你的包的名字是 `courier`，你可以在服务提供者的 `boot` 方法中加入以下内容：\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');\r\n    }\r\n\r\n包的视图是使用 `package::view` 的语法惯例来引用的。因此，一旦你的视图路径在服务提供者中注册，你可以像这样从 `courier` 包中加载 `dashboard` 视图。\r\n\r\n    Route::get('/dashboard', function () {\r\n        return view('courier::dashboard');\r\n    });\r\n\r\n\r\n\r\n<a name=\"overriding-package-views\"></a>\r\n#### 覆盖包的视图\r\n\r\n当你使用 `loadViewsFrom` 方法时, Laravel 实际上为你的视图注册了两个位置: 应用程序的 `resources/views/vendor` 目录和你指定的目录。 所以, 以 `courier` 包为例, Laravel 首先会检查视图的自定义版本是否已经被开发者放在 `resources/views/vendor/courier` 目录中。 然后, 如果视图没有被定制, Laravel 会搜索你在调用 `loadViewsFrom` 时指定的包的视图目录. 这使得包的用户可以很容易地定制/覆盖你的包的视图。\r\n\r\n<a name=\"publishing-views\"></a>\r\n#### 发布视图\r\n\r\n如果你想让你的视图可以发布到应用程序的 `resources/views/vendor` 目录下，你可以使用服务提供者的 `publishes` 方法。`publishes` 方法接受一个数组的包视图路径和它们所需的发布位置：\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');\r\n\r\n        $this->publishes([\r\n            __DIR__.'/../resources/views' => resource_path('views/vendor/courier'),\r\n        ]);\r\n    }\r\n\r\n当你的包的用户执行 Laravel 的 `vendor:publish` Artisan 命令时, 你的包的视图将被复制到指定的发布位置。\r\n\r\n<a name=\"view-components\"></a>\r\n### 视图组件\r\n\r\n如果你正在建立一个用 Blade 组件的包，或者将组件放在非传统的目录中，你将需要手动注册你的组件类和它的 HTML 标签别名，以便 Laravel 知道在哪里可以找到这个组件。你通常应该在你的包的服务提供者的 `boot` 方法中注册你的组件:\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n    use VendorPackage\\View\\Components\\AlertComponent;\r\n\r\n    /**\r\n     * 引导你的包的服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::component('package-alert', AlertComponent::class);\r\n    }\r\n\r\n\r\n\r\n当组件注册成功后，你就可以使用标签别名对其进行渲染：\r\n\r\n```blade\r\n<x-package-alert/>\r\n```\r\n\r\n<a name=\"autoloading-package-components\"></a>\r\n#### 自动加载包组件\r\n\r\n此外，你可以使用 `compoentNamespace` 方法依照规范自动加载组件类。比如，`Nightshade` 包中可能有 `Calendar` 和 `ColorPicker` 组件，存在于 `Nightshade\\Views\\Components` 命名空间中：\r\n\r\n    use Illuminate\\Support\\Facades\\Blade;\r\n\r\n    /**\r\n     * 启动包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Blade::componentNamespace('Nightshade\\\\Views\\\\Components', 'nightshade');\r\n    }\r\n\r\n我们可以使用 `package-name::` 语法，通过包提供商的命名空间调用包组件：\r\n\r\n```blade\r\n<x-nightshade::calendar />\r\n<x-nightshade::color-picker />\r\n```\r\n\r\nBlade 会通过组件名自动检测链接到该组件的类。子目录也支持使用'点'语法。\r\n\r\n<a name=\"anonymous-components\"></a>\r\n#### 匿名组件\r\n\r\n如果包中有匿名组件，则必须将它们放在包的视图目录(由[`loadViewsFrom` 方法](#views)指定)的 `components` 文件夹下。然后，你就可以通过在组件名的前面加上包视图的命名空间来对其进行渲染了：\r\n\r\n```blade\r\n<x-courier::alert />\r\n```\r\n\r\n<a name=\"about-artisan-command\"></a>\r\n### \"About\" Artisan 命令\r\n\r\nLaravel 内建的 `about` Artisan 命令提供了应用环境和配置的摘要信息。包可以通过 `AboutCommand` 类为该命令输出添加附加信息。一般而言，这些信息可以在包服务提供者的 `boot` 方法中添加：\r\n\r\n    use Illuminate\\Foundation\\Console\\AboutCommand;\r\n\r\n    /**\r\n     * Bootstrap any application services.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        AboutCommand::add('My Package', fn () => ['Version' => '1.0.0']);\r\n    }\r\n\r\n<a name=\"commands\"></a>\r\n## 命令\r\n\r\n要在 Laravel 中注册你的包的 Artisan 命令，你可以使用 `commands` 方法。 此方法需要一个命令类名称数组。 注册命令后，您可以使用 [Artisan CLI](https://learnku.com/docs/laravel/9.x/artisan) 执行它们：\r\n\r\n    use Courier\\Console\\Commands\\InstallCommand;\r\n    use Courier\\Console\\Commands\\NetworkCommand;\r\n\r\n    /**\r\n     * Bootstrap any package services.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        if ($this->app->runningInConsole()) {\r\n            $this->commands([\r\n                InstallCommand::class,\r\n                NetworkCommand::class,\r\n            ]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"public-assets\"></a>\r\n## 公共资源\r\n\r\n你的包可能有诸如 JavaScript 、CSS 和图片等资源。要发布这些资源到应用程序的 `public` 目录，请使用服务提供者的 `publishes` 方法。在下面例子中，我们还将添加一个 `public` 资源组标签，它可以用来轻松发布相关资源组：\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->publishes([\r\n            __DIR__.'/../public' => public_path('vendor/courier'),\r\n        ], 'public');\r\n    }\r\n\r\n当你的软件包的用户执行 `vendor:publish` 命令时，你的资源将被复制到指定的发布位置。通常用户需要在每次更新包的时候都要覆盖资源，你可以使用 `--force` 标志。\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=public --force\r\n```\r\n\r\n<a name=\"publishing-file-groups\"></a>\r\n## 发布文件组\r\n\r\n你可能想单独发布软件包的资源和资源组。例如，你可能想让你的用户发布你的包的配置文件，而不被强迫发布你的包的资源。你可以通过在调用包的服务提供者的 `publishes` 方法时对它们进行 `tagging` 来做到这一点。例如，让我们使用标签在软件包服务提供者的 `boot` 方法中为 `courier` 软件包定义两个发布组（ `courier-config` 和 `courier-migrations` ）。\r\n\r\n    /**\r\n     * 引导包服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        $this->publishes([\r\n            __DIR__.'/../config/package.php' => config_path('package.php')\r\n        ], 'courier-config');\r\n\r\n        $this->publishes([\r\n            __DIR__.'/../database/migrations/' => database_path('migrations')\r\n        ], 'courier-migrations');\r\n    }\r\n\r\n现在你的用户可以在执行 `vendor:publish` 命令时引用他们的标签来单独发布这些组。\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=courier-config\r\n```\r\n\r\n","p":"docs/packages.html"},{"t":"processes (进程管理)","d":"# 进程管理\r\n\r\n- [介绍](#introduction)\r\n- [调用过程](#invoking-processes)\r\n    - [进程选项](#process-options)\r\n    - [进程输出](#process-output)\r\n- [异步进程](#asynchronous-processes)\r\n    - [进程 ID 和信号](#process-ids-and-signals)\r\n    - [异步进程输出](#asynchronous-process-output)\r\n- [并行进程](#concurrent-processes)\r\n    - [命名进程池中的进程](#naming-pool-processes)\r\n    - [进程池进程 ID 和信号](#pool-process-ids-and-signals)\r\n- [测试](#testing)\r\n    - [伪造进程](#faking-processes)\r\n    - [伪造指定进程](#faking-specific-processes)\r\n    - [伪造进程序列](#faking-process-sequences)\r\n    - [伪造异步进程的生命周期](#faking-asynchronous-process-lifecycles)\r\n    - [可用的断言](#available-assertions)\r\n    - [防止运行未被伪造的进程](#preventing-stray-processes)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 通过 [Symfony Process 组件](https://symfony.com/doc/current/components/process.html) 提供了一个小而美的 API，让你可以方便地从 Laravel 应用程序中调用外部进程。 Laravel 的进程管理功能专注于提供最常见的用例和提升开发人员体验。\r\n\r\n<a name=\"invoking-processes\"></a>\r\n## 调用过程\r\n\r\n在调用过程中，你可以使用 `进程管理` facade 提供的 `run` 和 `start` 方法。 `run` 方法将调用一个进程并等待进程执行完毕，而 `start` 方法用于异步进程执行。我们将在本文档中探究这两种方法。首先，让我们了解一下如何调用基本的同步进程并检查其结果：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\n$result = Process::run('ls -la');\r\n\r\nreturn $result->output();\r\n```\r\n\r\n当然，由 `run` 方法返回的 `Illuminate\\Contracts\\Process\\ProcessResult` 实例提供了多种有用的方法，用于检查进程处理结果：\r\n\r\n```php\r\n$result = Process::run('ls -la');\r\n\r\n$result->successful();\r\n$result->failed();\r\n$result->exitCode();\r\n$result->output();\r\n$result->errorOutput();\r\n```\r\n\r\n<a name=\"throwing-exceptions\"></a>\r\n#### 抛出异常\r\n\r\n如果你有一个进程结果，并且希望在退出代码大于零（以此表明失败）的情况下抛出`Illuminate\\Process\\Exceptions\\ProcessFailedException`的一个实例，你可以使用`throw` 和 `throwIf` 方法。 如果进程没有失败，将返回进程结果实例：\r\n\r\n```php\r\n$result = Process::run('ls -la')->throw();\r\n\r\n$result = Process::run('ls -la')->throwIf($condition);\r\n```\r\n\r\n<a name=\"process-options\"></a>\r\n### 进程选项\r\n\r\n当然，你可能需要在调用进程之前自定义进程的行为。幸运的是，Laravel允许你调整各种进程特性，比如工作目录、超时和环境变量。\r\n\r\n<a name=\"working-directory-path\"></a>\r\n#### 工作目录路径\r\n\r\n你可以使用 `path` 方法指定进程的工作目录。如果不调用这个方法，进程将继承当前正在执行的PHP脚本的工作目录\r\n\r\n```php\r\n$result = Process::path(__DIR__)->run('ls -la');\r\n```\r\n\r\n<a name=\"input\"></a>\r\n#### 输入\r\n\r\n你可以使用 `input` 方法通过进程的“标准输入”提供输入：\r\n\r\n```php\r\n$result = Process::input('Hello World')->run('cat');\r\n```\r\n\r\n<a name=\"timeouts\"></a>\r\n#### 超时\r\n\r\n默认情况下，进程在执行超过60秒后将抛出`Illuminate\\Process\\Exceptions\\ProcessTimedOutException` 实例。但是，你可以通过 `timeout` 方法自定义此行为：\r\n\r\n```php\r\n$result = Process::timeout(120)->run('bash import.sh');\r\n```\r\n\r\n或者，如果要完全禁用进程超时，你可以调用 `forever` 方法：\r\n\r\n```php\r\n$result = Process::forever()->run('bash import.sh');\r\n```\r\n\r\n` idleTimeout`  方法可用于指定进程在不返回任何输出的情况下最多运行的秒数：\r\n\r\n```php\r\n$result = Process::timeout(60)->idleTimeout(30)->run('bash import.sh');\r\n```\r\n\r\n<a name=\"environment-variables\"></a>\r\n#### 环境变量\r\n\r\n可以通过 ` env ` 方法向进程提供环境变量。 调用的进程还将继承系统定义的所有环境变量：\r\n\r\n```php\r\n$result = Process::forever()\r\n            ->env(['IMPORT_PATH' => __DIR__])\r\n            ->run('bash import.sh');\r\n```\r\n\r\n如果你希望从调用的进程中删除继承的环境变量，则可以为该环境变量提供值为 false：\r\n\r\n```php\r\n$result = Process::forever()\r\n            ->env(['LOAD_PATH' => false])\r\n            ->run('bash import.sh');\r\n```\r\n\r\n<a name=\"tty-mode\"></a>\r\n#### TTY 模式\r\n\r\n`tty` 方法可以用于为你的进程启用 TTY 模式。 TTY 模式将进程的输入和输出连接到你的程序的输入和输出，允许你的进程作为一个进程打开编辑器（如 Vim 或 Nano）：\r\n\r\n```php\r\nProcess::forever()->tty()->run('vim');\r\n```\r\n\r\n<a name=\"process-output\"></a>\r\n### 进程输出\r\n\r\n如前所述，进程输出可以使用进程结果的 ` output` （标准输出）和 ` errorOutput` （标准错误输出）方法访问：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\n$result = Process::run('ls -la');\r\n\r\necho $result->output();\r\necho $result->errorOutput();\r\n```\r\n\r\n但是，通过将闭包作为 ` run`  方法的第二个参数，输出也可以实时收集。闭包将接收两个参数：输出的“类型”（stdout 或 stderr）和输出字符串本身：\r\n\r\n```php\r\n$result = Process::run('ls -la', function (string $type, string $output) {\r\n    echo $output;\r\n});\r\n```\r\n\r\nLaravel 还提供了 `seeInOutput` 和 `seeInErrorOutput`方法，这提供了一种方便的方式来确定进程输出中是否包含给定的字符串：\r\n\r\n```php\r\nif (Process::run('ls -la')->seeInOutput('laravel')) {\r\n    // ...\r\n}\r\n```\r\n\r\n<a name=\"disabling-process-output\"></a>\r\n#### 禁用进程输出\r\n\r\n如果你的进程写入了大量你不感兴趣的输出，则可以通过在构建进程时调用 `quietly` 方法来禁用输出检索。为此，请执行以下操作：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\n$result = Process::quietly()->run('bash import.sh');\r\n```\r\n\r\n<a name=\"asynchronous-processes\"></a>\r\n## 异步进程\r\n\r\n`start` 方法可以用来异步地调用进程，与之相对的是同步的 `run` 方法。使用 `start` 方法可以让进程在后台运行，而不会阻塞应用的其他任务。一旦进程被调用，你可以使用 `running` 方法来检查进程是否仍在运行：\r\n\r\n```php\r\n$process = Process::timeout(120)->start('bash import.sh');\r\n\r\nwhile ($process->running()) {\r\n    // ...\r\n}\r\n\r\n$result = $process->wait();\r\n```\r\n\r\n你可以使用 `wait`方法来等待进程执行完毕，并检索进程的执行结果实例：\r\n\r\n```php\r\n$process = Process::timeout(120)->start('bash import.sh');\r\n\r\n// ...\r\n\r\n$result = $process->wait();\r\n```\r\n\r\n<a name=\"process-ids-and-signals\"></a>\r\n### 进程 ID 和信号\r\n\r\n`id` 方法可以用来检索正在运行进程的操作系统分配的进程 ID：\r\n\r\n```php\r\n$process = Process::start('bash import.sh');\r\n\r\nreturn $process->id();\r\n```\r\n\r\n你可以使用 `signal` 方法向正在运行的进程发送“信号”。在 [PHP 文档中可以找到预定义的信号常量列表](https://www.php.net/manual/en/pcntl.constants.php):\r\n\r\n```php\r\n$process->signal(SIGUSR2);\r\n```\r\n\r\n<a name=\"asynchronous-process-output\"></a>\r\n### 异步进程输出\r\n\r\n当异步进程在运行时，你可以使用 `output` 和 `errorOutput` 方法访问其整个当前输出；但是，你可以使用`latestOutput` 和 `latestErrorOutput` 方法访问自上次检索输出以来的进程输出：\r\n\r\n```php\r\n$process = Process::timeout(120)->start('bash import.sh');\r\n\r\nwhile ($process->running()) {\r\n    echo $process->latestOutput();\r\n    echo $process->latestErrorOutput();\r\n\r\n    sleep(1);\r\n}\r\n```\r\n\r\n与 `run` 方法一样，也可以通过在 `start` 方法的第二个参数中传递一个闭包来从异步进程中实时收集输出。闭包将接收两个参数：输出类型（`stdout` 或 `stderr`）和输出字符串本身：\r\n\r\n```php\r\n$process = Process::start('bash import.sh', function (string $type, string $output) {\r\n    echo $output;\r\n});\r\n\r\n$result = $process->wait();\r\n```\r\n\r\n<a name=\"concurrent-processes\"></a>\r\n## 并行处理\r\n\r\nLaravel 还可以轻松地管理一组并发的异步进程，使你能够轻松地同时执行多个任务。要开始，请调用 pool 方法，该方法接受一个闭包，该闭包接收 Illuminate\\Process\\Pool 实例。\r\n\r\n在此闭包中，你可以定义属于该池的进程。一旦通过 `start` 方法启动了进程池，你可以通过 `running` 方法访问正在运行的进程 [集合](/docs/laravel/10.x/collections)：\r\n\r\n```php\r\nuse Illuminate\\Process\\Pool;\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\n$pool = Process::pool(function (Pool $pool) {\r\n    $pool->path(__DIR__)->command('bash import-1.sh');\r\n    $pool->path(__DIR__)->command('bash import-2.sh');\r\n    $pool->path(__DIR__)->command('bash import-3.sh');\r\n})->start(function (string $type, string $output, int $key) {\r\n    // ...\r\n});\r\n\r\nwhile ($pool->running()->isNotEmpty()) {\r\n    // ...\r\n}\r\n\r\n$results = $pool->wait();\r\n```\r\n\r\n可以看到，你可以通过 `wait` 方法等待所有池进程完成执行并解析它们的结果。`wait` 方法返回一个可访问进程结果实例的数组对象，通过其键可以访问池中每个进程的进程结果实例：\r\n\r\n```php\r\n$results = $pool->wait();\r\n\r\necho $results[0]->output();\r\n```\r\n\r\n或者，为方便起见，可以使用 `concurrently` 方法启动异步进程池并立即等待其结果。结合 PHP 的数组解构功能，这可以提供特别表达式的语法：\r\n\r\n```php\r\n[$first, $second, $third] = Process::concurrently(function (Pool $pool) {\r\n    $pool->path(__DIR__)->command('ls -la');\r\n    $pool->path(app_path())->command('ls -la');\r\n    $pool->path(storage_path())->command('ls -la');\r\n});\r\n\r\necho $first->output();\r\n```\r\n\r\n<a name=\"naming-pool-processes\"></a>\r\n### 命名进程池中的进程\r\n\r\n通过数字键访问进程池结果不太具有表达性，因此 Laravel 允许你通过 `as` 方法为进程池中的每个进程分配字符串键。该键也将传递给提供给 `start` 方法的闭包，使你能够确定输出属于哪个进程：\r\n\r\n```php\r\n$pool = Process::pool(function (Pool $pool) {\r\n    $pool->as('first')->command('bash import-1.sh');\r\n    $pool->as('second')->command('bash import-2.sh');\r\n    $pool->as('third')->command('bash import-3.sh');\r\n})->start(function (string $type, string $output, string $key) {\r\n    // ...\r\n});\r\n\r\n$results = $pool->wait();\r\n\r\nreturn $results['first']->output();\r\n```\r\n\r\n<a name=\"pool-process-ids-and-signals\"></a>\r\n### 进程池进程 ID 和信号\r\n\r\n由于进程池的 `running` 方法提供了一个包含池中所有已调用进程的集合，因此你可以轻松地访问基础池进程 ID：\r\n\r\n```php\r\n$processIds = $pool->running()->each->id();\r\n```\r\n\r\n为了方便起见，你可以在进程池上调用 `signal` 方法，向池中的每个进程发送信号：\r\n\r\n```php\r\n$pool->signal(SIGUSR2);\r\n```\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n许多 Laravel 服务都提供功能，以帮助你轻松、有表达力地编写测试，Laravel 的进程服务也不例外。`Process` 门面的 `fake` 方法允许你指示 Laravel 在调用进程时返回存根/伪造结果。\r\n\r\n<a name=\"faking-processes\"></a>\r\n### 伪造进程\r\n\r\n在探索 Laravel 的伪造进程能力时，让我们想象一下调用进程的路由：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Process;\r\nuse Illuminate\\Support\\Facades\\Route;\r\n\r\nRoute::get('/import', function () {\r\n    Process::run('bash import.sh');\r\n\r\n    return 'Import complete!';\r\n});\r\n```\r\n\r\n在测试这个路由时，我们可以通过在 `Process` 门面上调用无参数的 `fake` 方法，让 Laravel 返回一个伪造的成功进程结果。此外，我们甚至可以断言某个进程“已运行”：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace Tests\\Feature;\r\n\r\nuse Illuminate\\Process\\PendingProcess;\r\nuse Illuminate\\Contracts\\Process\\ProcessResult;\r\nuse Illuminate\\Support\\Facades\\Process;\r\nuse Tests\\TestCase;\r\n\r\nclass ExampleTest extends TestCase\r\n{\r\n    public function test_process_is_invoked(): void\r\n    {\r\n        Process::fake();\r\n\r\n        $response = $this->get('/');\r\n\r\n        // 简单的流程断言...\r\n        Process::assertRan('bash import.sh');\r\n\r\n        // 或者，检查流程配置...\r\n        Process::assertRan(function (PendingProcess $process, ProcessResult $result) {\r\n            return $process->command === 'bash import.sh' &&\r\n                   $process->timeout === 60;\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n如前所述，在 `Process` 门面上调用 `fake` 方法将指示 Laravel 始终返回一个没有输出的成功进程结果。但是，你可以使用 `Process` 门面的 `result` 方法轻松指定伪造进程的输出和退出码：\r\n\r\n```php\r\nProcess::fake([\r\n    '*' => Process::result(\r\n        output: 'Test output',\r\n        errorOutput: 'Test error output',\r\n        exitCode: 1,\r\n    ),\r\n]);\r\n```\r\n\r\n<a name=\"faking-specific-processes\"></a>\r\n### 伪造指定进程\r\n\r\n在你测试的过程中，如果要伪造不同的进程执行结果，你可以通过传递一个数组给 `fake` 方法来实现。\r\n\r\n数组的键应该表示你想伪造的命令模式及其相关结果。星号 `*` 字符可用作通配符，任何未被伪造的进程命令将会被实际执行。你可以使用 `Process` Facade的 `result` 方法为这些命令构建 stub/fake 结果：\r\n\r\n```php\r\nProcess::fake([\r\n    'cat *' => Process::result(\r\n        output: 'Test \"cat\" output',\r\n    ),\r\n    'ls *' => Process::result(\r\n        output: 'Test \"ls\" output',\r\n    ),\r\n]);\r\n```\r\n\r\n如果不需要自定义伪造进程的退出码或错误输出，你可以更方便地将伪造进程结果指定为简单字符串：\r\n\r\n```php\r\nProcess::fake([\r\n    'cat *' => 'Test \"cat\" output',\r\n    'ls *' => 'Test \"ls\" output',\r\n]);\r\n```\r\n\r\n<a name=\"faking-process-sequences\"></a>\r\n### 伪造进程序列\r\n\r\n如果你测试的代码调用了多个相同命令的进程，你可能希望为每个进程调用分配不同的伪造进程结果。你可以使用 `Process` Facade 的 `sequence`方法来实现这一点：\r\n\r\n```php\r\nProcess::fake([\r\n    'ls *' => Process::sequence()\r\n                ->push(Process::result('First invocation'))\r\n                ->push(Process::result('Second invocation')),\r\n]);\r\n```\r\n\r\n<a name=\"faking-asynchronous-process-lifecycles\"></a>\r\n### 伪造异步进程的生命周期\r\n\r\n到目前为止，我们主要讨论了伪造使用 `run` 方法同步调用的进程。但是，如果你正在尝试测试与通过 `start` 调用的异步进程交互的代码，则可能需要更复杂的方法来描述伪造进程。\r\n\r\n例如，让我们想象以下使用异步进程交互的路由：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Log;\r\nuse Illuminate\\Support\\Facades\\Route;\r\n\r\nRoute::get('/import', function () {\r\n    $process = Process::start('bash import.sh');\r\n\r\n    while ($process->running()) {\r\n        Log::info($process->latestOutput());\r\n        Log::info($process->latestErrorOutput());\r\n    }\r\n\r\n    return 'Done';\r\n});\r\n```\r\n\r\n为了正确地伪造这个进程，我们需要能够描述 `running` 方法应返回 `true` 的次数。此外，我们可能想要指定多行顺序返回的输出。为了实现这一点，我们可以使用 `Process` Facade 的 `describe` 方法：\r\n\r\n```php\r\nProcess::fake([\r\n    'bash import.sh' => Process::describe()\r\n            ->output('First line of standard output')\r\n            ->errorOutput('First line of error output')\r\n            ->output('Second line of standard output')\r\n            ->exitCode(0)\r\n            ->iterations(3),\r\n]);\r\n```\r\n\r\n让我们深入研究上面的例子。使用 `output` 和 `errorOutput` 方法，我们可以指定顺序返回的多行输出。`exitCode` 方法可用于指定伪造进程的最终退出码。最后，`iterations` 方法可用于指定 `running` 方法应返回 `true` 的次数。\r\n\r\n<a name=\"available-assertions\"></a>\r\n### 可用的断言\r\n\r\n [如前所述](#faking-processes)，Laravel 为你的功能测试提供了几个进程断言。我们将在下面讨论每个断言。\r\n\r\n<a name=\"assert-process-ran\"></a>\r\n#### assertRan\r\n\r\n断言已经执行了给定的进程：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\nProcess::assertRan('ls -la');\r\n```\r\n\r\n`assertRan` 方法还接受一个闭包，该闭包将接收一个进程实例和一个进程结果，使你可以检查进程的配置选项。如果此闭包返回 `true`，则断言将“通过”：\r\n\r\n```php\r\nProcess::assertRan(fn ($process, $result) =>\r\n    $process->command === 'ls -la' &&\r\n    $process->path === __DIR__ &&\r\n    $process->timeout === 60\r\n);\r\n```\r\n\r\n传递给 `assertRan` 闭包的 `$process` 是 `Illuminate\\Process\\PendingProcess` 的实例，而 $result 是 `Illuminate\\Contracts\\Process\\ProcessResult` 的实例。\r\n\r\n<a name=\"assert-process-didnt-run\"></a>\r\n#### assertDidntRun \r\n\r\n断言给定的进程没有被调用：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\nProcess::assertDidntRun('ls -la');\r\n```\r\n\r\n与 `assertRan` 方法类似，`assertDidntRun` 方法也接受一个闭包，该闭包将接收一个进程实例和一个进程结果，允许你检查进程的配置选项。如果此闭包返回 `true`，则断言将“失败”：\r\n\r\n```php\r\nProcess::assertDidntRun(fn (PendingProcess $process, ProcessResult $result) =>\r\n    $process->command === 'ls -la'\r\n);\r\n```\r\n\r\n<a name=\"assert-process-ran-times\"></a>\r\n#### assertRanTimes\r\n\r\n断言给定的进程被调用了指定的次数：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Process;\r\n\r\nProcess::assertRanTimes('ls -la', times: 3);\r\n```\r\n\r\n`assertRanTimes` 方法也接受一个闭包，该闭包将接收一个进程实例和一个进程结果，允许你检查进程的配置选项。如果此闭包返回 `true` 并且进程被调用了指定的次数，则断言将“通过”：\r\n\r\n```php\r\nProcess::assertRanTimes(function (PendingProcess $process, ProcessResult $result) {\r\n    return $process->command === 'ls -la';\r\n}, times: 3);\r\n```\r\n\r\n<a name=\"preventing-stray-processes\"></a>\r\n### 防止运行未被伪造的进程\r\n\r\n如果你想确保在单个测试或完整的测试套件中，所有被调用的进程都已经被伪造，你可以调用`preventStrayProcesses` 方法。调用此方法后，任何没有相应的伪造结果的进程都将引发异常，而不是启动实际进程：\r\n\r\n    use Illuminate\\Support\\Facades\\Process;\r\n\r\n    Process::preventStrayProcesses();\r\n\r\n    Process::fake([\r\n        'ls *' => 'Test output...',\r\n    ]);\r\n\r\n    // 返回假响应...\r\n    Process::run('ls -la');\r\n\r\n    // 抛出一个异常...\r\n    Process::run('bash import.sh');\r\n\r\n","p":"docs/processes.html"},{"t":"queues (队列)","d":"# 队列\r\n\r\n- [简介](#introduction)\r\n    - [连接 Vs. 驱动](#connections-vs-queues)\r\n    - [驱动程序说明 & 先决条件](#driver-prerequisites)\r\n- [创建任务](#creating-jobs)\r\n    - [生成任务类](#generating-job-classes)\r\n    - [任务类结构](#class-structure)\r\n    - [唯一任务](#unique-jobs)\r\n- [任务中间件](#job-middleware)\r\n    - [访问限制](#rate-limiting)\r\n    - [防止任务重复](#preventing-job-overlaps)\r\n    - [限制异常](#throttling-exceptions)\r\n- [任务调度](#dispatching-jobs)\r\n    - [延迟调度](#delayed-dispatching)\r\n    - [同步调度](#synchronous-dispatching)\r\n    - [任务 & 数据库事务](#jobs-and-database-transactions)\r\n    - [任务链](#job-chaining)\r\n    - [自定义队列 & 连接](#customizing-the-queue-and-connection)\r\n    - [指定任务最大尝试次数 / 超时值](#max-job-attempts-and-timeout)\r\n    - [错误处理](#error-handling)\r\n- [任务批处理](#job-batching)\r\n    - [定义可批处理任务](#defining-batchable-jobs)\r\n    - [分派批处理](#dispatching-batches)\r\n    - [将任务添加到批处理](#adding-jobs-to-batches)\r\n    - [校验批处理](#inspecting-batches)\r\n    - [取消批处理](#cancelling-batches)\r\n    - [批处理失败](#batch-failures)\r\n    - [批量清理](#pruning-batches)\r\n- [队列闭包](#queueing-closures)\r\n- [运行队列处理器](#running-the-queue-worker)\r\n    - [`queue:work` 命令](#the-queue-work-command)\r\n    - [队列优先级](#queue-priorities)\r\n    - [队列处理器 & 部署](#queue-workers-and-deployment)\r\n    - [任务过期 & 超时](#job-expirations-and-timeouts)\r\n- [Supervisor 配置](#supervisor-configuration)\r\n- [处理失败任务](#dealing-with-failed-jobs)\r\n    - [清理失败任务](#cleaning-up-after-failed-jobs)\r\n    - [重试失败任务](#retrying-failed-jobs)\r\n    - [忽略缺失的模型](#ignoring-missing-models)\r\n    - [清理失败的任务](#pruning-failed-jobs)\r\n    - [在 DynamoDB 中存储失败的任务](#storing-failed-jobs-in-dynamodb)\r\n    - [禁用失败的任务存储](#disabling-failed-job-storage)\r\n    - [任务失败事件](#failed-job-events)\r\n- [清理队列任务](#clearing-jobs-from-queues)\r\n- [监控你的队列](#monitoring-your-queues)\r\n- [测试](#testing)\r\n    - [伪造任务的一个子集](#faking-a-subset-of-jobs)\r\n    - [测试任务链](#testing-job-chains)\r\n    - [测试任务批处理](#testing-job-batches)\r\n- [任务事件](#job-events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在构建 Web 应用程序时，你可能需要执行一些任务，例如解析和存储上传的 CSV 文件，这些任务在典型的 Web 请求期间需要很长时间才能执行。 值得庆幸的是，Laravel 允许你轻松创建可以在后台处理的队列任务。 通过将时间密集型任务移至队列，你的应用程序可以以极快的速度响应 Web 请求，并为你的客户提供更好的用户体验。\r\n\r\nLaravel 队列为各种不同的队列驱动提供统一的队列 API，例如 [Amazon SQS](https://aws.amazon.com/sqs/)，[Redis](https://redis.io)，甚至关系数据库。\r\n\r\nLaravel 队列的配置选项存储在 `config/queue.php` 文件中。 在这个文件中，你可以找到框架中包含的每个队列驱动的连接配置，包括数据库， [Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io)， 和 [Beanstalkd](https://beanstalkd.github.io/) 驱动，以及一个会立即执行作业的同步驱动（用于本地开发）。还包括一个用于丢弃排队任务的 `null` 队列驱动。\r\n\r\n> **技巧**  \r\n> Laravel 提供了 Horizon ，适用于 Redis 驱动队列。 Horizon 是一个拥有漂亮仪表盘的配置系统。如需了解更多信息请查看完整的 [Horizon 文档](/docs/laravel/10.x/horizon)。\r\n\r\n<a name=\"connections-vs-queues\"></a>\r\n### 连接 Vs. 驱动\r\n\r\n在开始使用 Laravel 队列之前，理解「连接」和「队列」之间的区别非常重要。 在 `config/queue.php` 配置文件中，有一个 `connections` 连接选项。 此选项定义连接某个驱动（如 Amazon SQS、Beanstalk 或 Redis）。然而，任何给定的队列连接都可能有多个「队列」，这些「队列」可能被认为是不同的堆栈或成堆的排队任务。\r\n\r\n请注意， `queue` 配置文件中的每个连接配置示例都包含一个 `queue` 属性。\r\n\r\n这是将任务发送到给定连接时将被分配到的默认队列。换句话说，如果你没有显式地定义任务应该被发送到哪个队列，那么该任务将被放置在连接配置的 `queue` 属性中定义的队列上：\r\n\r\n    use App\\Jobs\\ProcessPodcast;\r\n\r\n    // 这个任务将被推送到默认队列...\r\n\r\n    ProcessPodcast::dispatch();\r\n\r\n\t// 这个任务将被推送到「emails」队列...\r\n\r\n    ProcessPodcast::dispatch()->onQueue('emails');\r\n\r\n有些应用程序可能不需要将任务推到多个队列中，而是倾向于使用一个简单的队列。然而，如果希望对任务的处理方式进行优先级排序或分段时，将任务推送到多个队列就显得特别有用，因为 Laravel 队列工作程序允许你指定哪些队列应该按优先级处理。例如，如果你将任务推送到一个 `high` 队列，你可能会运行一个赋予它们更高处理优先级的 worker：\r\n\r\n```shell\r\nphp artisan queue:work --queue=high,default\r\n```\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n\r\n### 驱动程序说明和先决条件\r\n\r\n<a name=\"database\"></a>\r\n\r\n#### 数据库\r\n\r\n要使用 `database` 队列驱动程序，你需要一个数据库表来保存任务。要生成创建此表的迁移，请运行 `queue:table` Artisan 命令。一旦迁移已经创建，你可以使用 `migrate` 命令迁移你的数据库：\r\n\r\n```shell\r\nphp artisan queue:table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n最后，请不要忘记通过修改`.env` 文件中的 `QUEUE_CONNECTION` 变量从而将 `database` 作为你的应用队列驱动程序:\r\n\r\n QUEUE_CONNECTION=database\r\n\r\n<a name=\"redis\"></a>\r\n\r\n#### Redis\r\n\r\n要使用 `redis` 队列驱动程序，需要在 `config/database.php` 配置文件中配置一个 redis 数据库连接。\r\n\r\n**Redis 集群**\r\n\r\n如果你的 Redis 队列当中使用了 Redis 集群，那么你的队列名称就必须包含一个 [key hash tag](https://redis.io/topics/cluster-spec#keys-hash-tags)。这是为了确保一个给定队列的所有 Redis 键都被放在同一个哈希插槽：\r\n\r\n    'redis' => [\r\n        'driver' => 'redis',\r\n        'connection' => 'default',\r\n        'queue' => '{default}',\r\n        'retry_after' => 90,\r\n    ],\r\n\r\n**阻塞**\r\n\r\n在使用 Redis 队列时，你可以使用 block_for 配置选项来指定在遍历 worker 循环和重新轮询 Redis 数据库之前，驱动程序需要等待多长时间才能使任务变得可用。\r\n\r\n根据你的队列负载调整此值要比连续轮询 Redis 数据库中的新任务更加有效。例如，你可以将值设置为 5 以指示驱动程序在等待任务变得可用时应该阻塞 5 秒：\r\n\r\n    'redis' => [\r\n        'driver' => 'redis',\r\n        'connection' => 'default',\r\n        'queue' => 'default',\r\n        'retry_after' => 90,\r\n        'block_for' => 5,\r\n    ],\r\n\r\n> **注意**\r\n> 将 block_for 设置为 0 将导致队列 workers 一直阻塞，直到某一个任务变得可用。这还能防止在下一个任务被处理之前处理诸如 SIGTERM 之类的信号。\r\n\r\n<a name=\"other-driver-prerequisites\"></a>\r\n\r\n#### 其他驱动的先决条件\r\n\r\n列出的队列驱动需要如下的依赖，这些依赖可通过 Composer 包管理器进行安装：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- Amazon SQS: `aws/aws-sdk-php ~3.0`\r\n- Beanstalkd: `pda/pheanstalk ~4.0`\r\n- Redis: `predis/predis ~1.0` or phpredis PHP extension\r\n\r\n</div>\r\n\r\n<a name=\"creating-jobs\"></a>\r\n## 创建任务\r\n\r\n<a name=\"generating-job-classes\"></a>\r\n### 生成任务类\r\n\r\n默认情况下，应用程序的所有的可排队任务都被存储在了 app/Jobs 目录中。如果 app/Jobs 目录不存在，当你运行 make:job Artisan 命令时，将会自动创建该目录：\r\n\r\n```shell\r\nphp artisan make:job ProcessPodcast\r\n```\r\n\r\n生成的类将会实现 Illuminate\\Contracts\\Queue\\ShouldQueue 接口， 告诉 Laravel ，该任务应该推入队列以异步的方式运行。\r\n\r\n> **技巧**\r\n> 你可以使用 [stub publishing](/docs/laravel/10.x/artisanmd#stub-customization) 来自定义任务 stub 。\r\n\r\n<a name=\"class-structure\"></a>\r\n### 任务类结构\r\n\r\n任务类非常简单，通常只包含一个 `handle` 方法，在队列处理任务时将会调用它。让我们看一个任务类的示例。在这个例子中，我们假设我们管理一个 podcast 服务，并且需要在上传的 podcast 文件发布之前对其进行处理：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use App\\Models\\Podcast;\r\n    use App\\Services\\AudioProcessor;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建一个新的任务实例\r\n         */\r\n        public function __construct(\r\n            public Podcast $podcast,\r\n        ) {}\r\n\r\n        /**\r\n         * 运行任务\r\n         */\r\n        public function handle(AudioProcessor $processor): void\r\n        {\r\n            // 处理上传的 podcast...\r\n        }\r\n    }\r\n\r\n在本示例中，请注意，我们能够将一个 [Eloquent model](/docs/laravel/10.x/eloquent)  直接传递到已排队任务的构造函数中。由于任务所使用的 `SerializesModels` ，在任务处理时，Eloquent 模型及其加载的关系将被优雅地序列化和反序列化。\r\n\r\n如果你的队列任务在其构造函数中接受一个 Eloquent 模型，那么只有模型的标识符才会被序列化到队列中。当实际处理任务时，队列系统将自动重新从数据库中获取完整的模型实例及其加载的关系。这种用于模型序列化的方式允许将更小的作业有效负载发送给你的队列驱动程序。\r\n\r\n<a name=\"handle-method-dependency-injection\"></a>\r\n#### `handle` 方法依赖注入\r\n\r\n当任务由队列处理时，将调用 `handle` 方法。注意，我们可以对任务的 `handle` 方法进行类型提示依赖。Laravel [服务容器](/docs/laravel/10.x/container) 会自动注入这些依赖项。\r\n\r\n如果你想完全控制容器如何将依赖注入  `handle` 方法，你可以使用容器的 `bindMethod`  方法。 `bindMethod` 方法接受一个可接收任务和容器的回调。在回调中，你可以在任何你想用的地方随意调用 `handle` 方法。 通常， 你应该从你的 `App\\Providers\\AppServiceProvider` [服务提供者](/docs/laravel/10.x/providers)  中来调用该方法:\r\n\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Services\\AudioProcessor;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n    $this->app->bindMethod([ProcessPodcast::class, 'handle'], function (ProcessPodcast $job, Application $app) {\r\n        return $job->handle($app->make(AudioProcessor::class));\r\n    });\r\n\r\n> **注意**\r\n> 二进制数据，例如原始图像内容，应该在传递到队列任务之前通过 `base64_encode` 函数传递。否则，在将任务放入队列时，可能无法正确地序列化为 JSON。\r\n\r\n<a name=\"handling-relationships\"></a>\r\n#### 队列关系\r\n\r\n因为加载的关系也会被序列化，所以处理序列化任务的字符串有时会变得相当大。为了防止该关系被序列化，可以在设置属性值时对模型调用 `withoutRelations` 方法。此方法将返回没有加载关系的模型实例：\r\n\r\n    /**\r\n     * 创建新的任务实例\r\n     */\r\n    public function __construct(Podcast $podcast)\r\n    {\r\n        $this->podcast = $podcast->withoutRelations();\r\n    }\r\n\r\n此外，当反序列化任务并从数据库中重新检索模型关系时，它们将被完整检索。反序列化任务时，将不会应用在任务排队过程中序列化模型之前应用的任何先前关系约束。因此，如果你希望使用给定关系的子集，则应在排队任务中重新限制该关系。\r\n\r\n<a name=\"unique-jobs\"></a>\r\n### 唯一任务\r\n\r\n> 注意：唯一任务需要支持 [locks](/docs/laravel/10.x/cachemd#atomic-locks) 的缓存驱动程序。 目前，`memcached`、`redis`、`dynamodb`、`database`、`file`和`array`缓存驱动支持原子锁。 此外，独特的任务约束不适用于批次内的任务。\r\n\r\n有时，你可能希望确保在任何时间点队列中只有一个特定任务的实例。你可以通过在你的工作类上实现 `ShouldBeUnique` 接口来做到这一点。这个接口不需要你在你的类上定义任何额外的方法：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\r\n\r\n    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\r\n    {\r\n        ...\r\n    }\r\n\r\n以上示例中，`UpdateSearchIndex` 任务是唯一的。因此，如果任务的另一个实例已经在队列中并且尚未完成处理，则不会分派该任务。\r\n\r\n在某些情况下，你可能想要定义一个使任务唯一的特定「键」，或者你可能想要指定一个超时时间，超过该时间任务不再保持唯一。为此，你可以在任务类上定义 `uniqueId` 和 `uniqueFor` 属性或方法：\r\n\r\n    <?php\r\n\r\n    use App\\Product;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\r\n\r\n    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\r\n    {\r\n        /**\r\n         * 产品实例\r\n         *\r\n         * @var \\App\\Product\r\n         */\r\n        public $product;\r\n\r\n        /**\r\n         * 任务的唯一锁将被释放的秒数\r\n         *\r\n         * @var int\r\n         */\r\n        public $uniqueFor = 3600;\r\n\r\n        /**\r\n         * 任务的唯一 ID\r\n         */\r\n        public function uniqueId(): string\r\n        {\r\n            return $this->product->id;\r\n        }\r\n    }\r\n\r\n以上示例中， `UpdateSearchIndex` 任务中的 product ID 是唯一的。因此，在现有任务完成处理之前，任何具有相同 product ID 的任务都将被忽略。此外，如果现有任务在一小时内没有得到处理，则释放唯一锁，并将具有相同唯一键的另一个任务分派到该队列。\r\n\r\n> **注意**\r\n> 如果你的应用程序从多个 web 服务器或容器分派任务，你应该确保你的所有服务器都与同一个中央缓存服务器通信，以便Laravel能够准确确定任务是否唯一。\r\n\r\n<a name=\"keeping-jobs-unique-until-processing-begins\"></a>\r\n#### 在任务处理开始前保证唯一\r\n\r\n默认情况下，在任务完成处理或所有重试尝试均失败后，唯一任务将被「解锁」。但是，在某些情况下，你可能希望任务在处理之前立即解锁。为此，你的任务类可以实现  `ShouldBeUniqueUntilProcessing`  接口，而不是实现 `ShouldBeUnique` 接口：\r\n\r\n    <?php\r\n\r\n    use App\\Product;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Contracts\\Queue\\ShouldBeUniqueUntilProcessing;\r\n\r\n    class UpdateSearchIndex implements ShouldQueue, ShouldBeUniqueUntilProcessing\r\n    {\r\n        // ...\r\n    }\r\n\r\n<a name=\"unique-job-locks\"></a>\r\n#### 唯一任务锁\r\n\r\n在底层实现中，当分发 `ShouldBeUnique` 任务时，Laravel 尝试使用`uniqueId` 键获取一个   [锁](/docs/laravel/10.x/cachemd#atomic-locks) 。如果未获取到锁，则不会分派任务。当任务完成处理或所有重试尝试失败时，将释放此锁。默认情况下，Laravel 将使用默认的缓存驱动程序来获取此锁。但是，如果你希望使用其他驱动程序来获取锁，则可以定义一个 `uniqueVia` 方法，该方法返回一个缓存驱动对象：\r\n\r\n    use Illuminate\\Contracts\\Cache\\Repository;\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\r\n    {\r\n        ...\r\n\r\n        /**\r\n         * 获取唯一任务锁的缓存驱动程序\r\n         */\r\n        public function uniqueVia(): Repository\r\n        {\r\n            return Cache::driver('redis');\r\n        }\r\n    }\r\n\r\n> 技巧：如果只需要限制任务的并发处理，请改用 [`WithoutOverlapping`](/docs/laravel/10.x/queuesmd#preventing-job-overlaps) 任务中间件。\r\n\r\n<a name=\"job-middleware\"></a>\r\n## 任务中间件\r\n\r\n任务中间件允许你围绕排队任务的执行封装自定义逻辑，从而减少了任务本身的样板代码。例如，看下面的  `handle` 方法，它利用了 Laravel 的 Redis 速率限制特性，允许每 5 秒只处理一个任务：\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    /**\r\n     * 执行任务\r\n     */\r\n    public function handle(): void\r\n    {\r\n        Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {\r\n            info('取得了锁...');\r\n\r\n            // 处理任务...\r\n        }, function () {\r\n            // 无法获取锁...\r\n\r\n            return $this->release(5);\r\n        });\r\n    }\r\n\r\n虽然这段代码是有效的， 但是 `handle` 方法的结构却变得杂乱，因为它掺杂了 Redis 速率限制逻辑。此外，其他任务需要使用速率限制的时候，只能将限制逻辑复制一次。\r\n\r\n我们可以定义一个处理速率限制的任务中间件，而不是在 handle 方法中定义速率限制。Laravel 没有任务中间件的默认位置，所以你可以将任务中间件放置在你喜欢的任何位置。在本例中，我们将把中间件放在  `app/Jobs/Middleware`  目录：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    class RateLimited\r\n    {\r\n        /**\r\n         * 处理队列任务\r\n         *\r\n         * @param  \\Closure(object): void  $next\r\n         */\r\n        public function handle(object $job, Closure $next): void\r\n        {\r\n            Redis::throttle('key')\r\n                    ->block(0)->allow(1)->every(5)\r\n                    ->then(function () use (object $job, Closure $next) {\r\n                        // 已获得锁...\r\n\r\n                        $next($job);\r\n                    }, function () use ($job) {\r\n                        // 没有获取到锁...\r\n\r\n                        $job->release(5);\r\n                    });\r\n        }\r\n    }\r\n\r\n正如你看到的，类似于 [路由中间件](/docs/laravel/10.x/middleware)，任务中间件接收正在处理队列任务以及一个回调来继续处理队列任务。\r\n\r\n在任务中间件被创建以后，他们可能被关联到通过从任务的 `middleware`方法返回的任务。这个方法并不存在于 `make:job`  Artisan 命令搭建的任务中，所以你需要将它添加到你自己的任务类的定义中：\r\n\r\n    use App\\Jobs\\Middleware\\RateLimited;\r\n\r\n    /**\r\n     * 获取一个可以被传递通过的中间件任务\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [new RateLimited];\r\n    }\r\n\r\n> **技巧**\r\n> 任务中间件也可以分配其他可队列处理的监听事件当中，比如邮件，通知等。\r\n\r\n<a name=\"rate-limiting\"></a>\r\n### 访问限制\r\n\r\n尽管我们刚刚演示了如何编写自己的访问限制的任务中间件，但 Laravel 实际上内置了一个访问限制中间件，你可以利用它来限制任务。与 [路由限流器](/docs/laravel/10.x/routingmd/14845#defining-rate-limiters) 一样，任务访问限制器是使用 `RateLimiter` facade 的 `for` 方法定义的。\r\n\r\n例如，你可能希望允许用户每小时备份一次数据，但不对高级客户施加此类限制。为此，可以在 `RateLimiter` 的 `boot` 方法中定义 `AppServiceProvider`：\r\n\r\n    use Illuminate\\Cache\\RateLimiting\\Limit;\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    /**\r\n     * 注册应用程序服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        RateLimiter::for('backups', function (object $job) {\r\n            return $job->user->vipCustomer()\r\n                        ? Limit::none()\r\n                        : Limit::perHour(1)->by($job->user->id);\r\n        });\r\n    }\r\n\r\n在上面的例子中，我们定义了一个小时访问限制；但是，你可以使用 `perMinute` 方法轻松定义基于分钟的访问限制。此外，你可以将任何值传递给访问限制的 `by` 方法，但是，这个值通常用于按客户来区分不同的访问限制：\r\n\r\n    return Limit::perMinute(50)->by($job->user->id);\r\n\r\n定义速率限制后，你可以使用 `Illuminate\\Queue\\Middleware\\RateLimited` 中间件将速率限制器附加到备份任务。 每次任务超过速率限制时，此中间件都会根据速率限制持续时间以适当的延迟将任务释放回队列。\r\n\r\n    use Illuminate\\Queue\\Middleware\\RateLimited;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [new RateLimited('backups')];\r\n    }\r\n\r\n将速率受限的任务释放回队列仍然会增加任务的 「尝试」总数。你可能希望相应地调整你的任务类上的 `tries` 和 `maxExceptions` 属性。或者，你可能希望使用 `retryUntil` [方法](#time-based-attempts) 来定义不再尝试任务之前的时间量。\r\n\r\n如果你不想在速率限制时重试任务，你可以使用 `dontRelease` 方法：\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [(new RateLimited('backups'))->dontRelease()];\r\n    }\r\n\r\n> **技巧**\r\n> 如果你使用 Redis，你可以使用 Illuminate\\Queue\\Middleware\\RateLimitedWithRedis 中间件，它针对 Redis 进行了微调，比基本的限速中间件更高效。\r\n\r\n<a name=\"preventing-job-overlaps\"></a>\r\n### 防止任务重叠\r\n\r\nLaravel 包含一个 `Illuminate\\Queue\\Middleware\\WithoutOverlapping` 中间件，允许你根据任意键防止任务重叠。当排队的任务正在修改一次只能由一个任务修改的资源时，这会很有帮助。\r\n\r\n例如，假设你有一个更新用户信用评分的排队任务，并且你希望防止同一用户 ID 的信用评分更新任务重叠。为此，你可以从任务的 `middleware` 方法返回 `WithoutOverlapping` 中间件：\r\n\r\n    use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [new WithoutOverlapping($this->user->id)];\r\n    }\r\n\r\n任何重叠的任务都将被释放回队列。你还可以指定再次尝试释放的任务之前必须经过的秒数：\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];\r\n    }\r\n\r\n如果你想立即删除任何重叠的任务，你可以使用 `dontRelease` 方法，这样它们就不会被重试：\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [(new WithoutOverlapping($this->order->id))->dontRelease()];\r\n    }\r\n\r\n`WithoutOverlapping` 中间件由 Laravel 的原子锁特性提供支持。有时，你的任务可能会以未释放锁的方式意外失败或超时。因此，你可以使用 expireAfter 方法显式定义锁定过期时间。例如，下面的示例将指示 Laravel 在任务开始处理三分钟后释放 WithoutOverlapping 锁：\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];\r\n    }\r\n\r\n> **注意**\r\n> `WithoutOverlapping` 中间件需要支持 [locks](/docs/laravel/10.x/cachemd#atomic-locks) 的缓存驱动程序。目前，`memcached`、`redis`、`dynamodb`、`database`、`file` 和 `array` 缓存驱动支持原子锁。\r\n\r\n<a name=\"sharing-lock-keys\"></a>\r\n#### 跨任务类别共享锁\r\n\r\n默认情况下，`WithoutOverlapping` 中间件只会阻止同一类的重叠任务。 因此，尽管两个不同的任务类可能使用相同的锁，但不会阻止它们重叠。 但是，你可以使用 `shared` 方法指示 Laravel 跨任务类应用锁：\r\n\r\n```php\r\nuse Illuminate\\Queue\\Middleware\\WithoutOverlapping;\r\n\r\nclass ProviderIsDown\r\n{\r\n    // ...\r\n\r\n\r\n    public function middleware(): array\r\n    {\r\n        return [\r\n            (new WithoutOverlapping(\"status:{$this->provider}\"))->shared(),\r\n        ];\r\n    }\r\n}\r\n\r\nclass ProviderIsUp\r\n{\r\n    // ...\r\n\r\n\r\n    public function middleware(): array\r\n    {\r\n        return [\r\n            (new WithoutOverlapping(\"status:{$this->provider}\"))->shared(),\r\n        ];\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"throttling-exceptions\"></a>\r\n### 节流限制异常\r\n\r\nLaravel 包含一个 `Illuminate\\Queue\\Middleware\\ThrottlesExceptions` 中间件，允许你限制异常。一旦任务抛出给定数量的异常，所有进一步执行该任务的尝试都会延迟，直到经过指定的时间间隔。该中间件对于与不稳定的第三方服务交互的任务特别有用。\r\n\r\n例如，让我们想象一个队列任务与开始抛出异常的第三方 API 交互。要限制异常，你可以从任务的 `middleware` 方法返回 `ThrottlesExceptions` 中间件。通常，此中间件应与实现 [基于时间的尝试](#time-based-attempts) 的任务配对：\r\n\r\n    use DateTime;\r\n    use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [new ThrottlesExceptions(10, 5)];\r\n    }\r\n\r\n    /**\r\n     * 确定任务应该超时的时间。\r\n     */\r\n    public function retryUntil(): DateTime\r\n    {\r\n        return now()->addMinutes(5);\r\n    }\r\n\r\n中间件接受的第一个构造函数参数是任务在被限制之前可以抛出的异常数，而第二个构造函数参数是在任务被限制后再次尝试之前应该经过的分钟数。在上面的代码示例中，如果任务在 5 分钟内抛出 10 个异常，我们将等待 5 分钟，然后再次尝试该任务。\r\n\r\n当任务抛出异常但尚未达到异常阈值时，通常会立即重试该任务。但是，你可以通过在将中间件附加到任务时调用 `backoff` 方法来指定此类任务应延迟的分钟数：\r\n\r\n    use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [(new ThrottlesExceptions(10, 5))->backoff(5)];\r\n    }\r\n\r\n在内部，这个中间件使用 Laravel 的缓存系统来实现速率限制，并利用任务的类名作为缓存 「键」。 在将中间件附加到任务时，你可以通过调用 `by` 方法来覆盖此键。 如果你有多个任务与同一个第三方服务交互并且你希望它们共享一个共同的节流 「桶」，这可能会很有用：\r\n\r\n    use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\r\n\r\n    /**\r\n     * 获取任务时，应该通过的中间件。\r\n     *\r\n     * @return array<int, object>\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [(new ThrottlesExceptions(10, 10))->by('key')];\r\n    }\r\n\r\n> **技巧**  \r\n> 如果你使用 Redis，你可以使用 `Illuminate\\Queue\\Middleware\\ThrottlesExceptionsWithRedis` 中间件，它针对 Redis 进行了微调，比基本的异常节流中间件更高效。\r\n\r\n<a name=\"dispatching-jobs\"></a>\r\n## 调度任务\r\n\r\n一旦你写好了你的任务类，你可以使用任务本身的 `dispatch` 方法来调度它。传递给 `dispatch` 方法的参数将被提供给任务的构造函数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个新的播客。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $podcast = Podcast::create(/* ... */);\r\n\r\n            // ...\r\n\r\n            ProcessPodcast::dispatch($podcast);\r\n\r\n            return redirect('/podcasts');\r\n        }\r\n    }\r\n\r\n如果你想有条件地分派任务，你可以使用 `dispatchIf` 和 `dispatchUnless` 方法：\r\n\r\n    ProcessPodcast::dispatchIf($accountActive, $podcast);\r\n\r\n    ProcessPodcast::dispatchUnless($accountSuspended, $podcast);\r\n\r\n在新的 Laravel 应用程序中，`sync` 是默认的队列驱动程序。 该驱动程序会在当前请求的前台同步执行任务，这在本地开发时通常会很方便。 如果你想在后台处理排队任务，你可以在应用程序的 `config/queue.php` 配置文件中指定一个不同的队列驱动程序。\r\n\r\n\r\n<a name=\"delayed-dispatching\"></a>\r\n### 延迟调度\r\n\r\n如果你想指定任务不应立即可供队列工作人员处理，你可以在调度任务时使用 `delay` 方法。例如，让我们指定一个任务在分派后 10 分钟内不能用于处理\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 储存一个新的播客\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $podcast = Podcast::create(/* ... */);\r\n\r\n            // ...\r\n\r\n            ProcessPodcast::dispatch($podcast)\r\n                        ->delay(now()->addMinutes(10));\r\n\r\n            return redirect('/podcasts');\r\n        }\r\n    }\r\n\r\n> **注意**  \r\n> Amazon SQS 队列服务的最大延迟时间为 15 分钟。\r\n\r\n<a name=\"dispatching-after-the-response-is-sent-to-browser\"></a>\r\n#### 响应发送到浏览器后调度\r\n\r\n或者，`dispatchAfterResponse` 方法延迟调度任务，直到 HTTP 响应发送到用户的浏览器之后。 即使排队的任务仍在执行，这仍将允许用户开始使用应用程序。这通常应该只用于需要大约一秒钟的工作，例如发送电子邮件。由于它们是在当前 HTTP 请求中处理的，因此以这种方式分派的任务不需要运行队列工作者来处理它们：\r\n\r\n    use App\\Jobs\\SendNotification;\r\n\r\n    SendNotification::dispatchAfterResponse();\r\n\r\n你也可以 `dispatch` 一个闭包并将 `afterResponse` 方法链接到 `dispatch` 帮助器以在 HTTP 响应发送到浏览器后执行一个闭包\r\n\r\n    use App\\Mail\\WelcomeMessage;\r\n    use Illuminate\\Support\\Facades\\Mail;\r\n\r\n    dispatch(function () {\r\n        Mail::to('taylor@example.com')->send(new WelcomeMessage);\r\n    })->afterResponse();\r\n\r\n<a name=\"synchronous-dispatching\"></a>\r\n### 同步调度\r\n\r\n如果你想立即（同步）调度任务，你可以使用 `dispatchSync` 方法。使用此方法时，任务不会排队，会在当前进程内立即执行：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 储存一个新的播客。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $podcast = Podcast::create(/* ... */);\r\n\r\n            // 创建播客\r\n\r\n            ProcessPodcast::dispatchSync($podcast);\r\n\r\n            return redirect('/podcasts');\r\n        }\r\n    }\r\n\r\n<a name=\"jobs-and-database-transactions\"></a>\r\n### 任务 & 数据库事务\r\n\r\n虽然在数据库事务中分派任务非常好，但你应该特别注意确保你的任务实际上能够成功执行。在事务中调度任务时，任务可能会在父事务提交之前由工作人员处理。发生这种情况时，你在数据库事务期间对模型或数据库记录所做的任何更新可能尚未反映在数据库中。此外，在事务中创建的任何模型或数据库记录可能不存在于数据库中。\r\n\r\n值得庆幸的是，Laravel 提供了几种解决这个问题的方法。首先，你可以在队列连接的配置数组中设置 `after_commit` 连接选项：\r\n\r\n    'redis' => [\r\n        'driver' => 'redis',\r\n        // ...\r\n        'after_commit' => true,\r\n    ],\r\n\r\n当 `after_commit` 选项为 true 时，你可以在数据库事务中分发任务；Laravel 会等到所有打开的数据库事务都已提交，然后才会开始分发任务。当然，如果当前没有打开的数据库事务，任务将被立即调度。\r\n\r\n如果事务因事务期间发生异常而回滚，则在该事务期间分发的已分发任务将被丢弃。\r\n\r\n> **技巧**  \r\n> 将 `after_commit` 配置选项设置为 `true` 还会导致所有排队的事件监听器、邮件、通知和广播事件在所有打开的数据库事务提交后才被调度。\r\n\r\n<a name=\"specifying-commit-dispatch-behavior-inline\"></a>\r\n#### 内联指定提交调度\r\n\r\n如果你没有将 `after_commit` 队列连接配置选项设置为 `true`，你可能需要在所有打开的数据库事务提交后才调度特定的任务。为此，你可以将 `afterCommit` 方法放到你的调度操作上：\r\n\r\n    use App\\Jobs\\ProcessPodcast;\r\n\r\n    ProcessPodcast::dispatch($podcast)->afterCommit();\r\n\r\n同样，如果 `after_commit` 配置选项设置为 `true`，则可以指示应立即调度特定作业，而无需等待任何打开的数据库事务提交：\r\n\r\n    ProcessPodcast::dispatch($podcast)->beforeCommit();\r\n\r\n<a name=\"job-chaining\"></a>\r\n### 任务链\r\n\r\n任务链允许你指定一组应在主任务成功执行后按顺序运行的排队任务。如果序列中的一个任务失败，其余的任务将不会运行。要执行一个排队的任务链，你可以使用 `Bus` facade 提供的 `chain` 方法：\r\n\r\n    use App\\Jobs\\OptimizePodcast;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Jobs\\ReleasePodcast;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n\r\n    Bus::chain([\r\n        new ProcessPodcast,\r\n        new OptimizePodcast,\r\n        new ReleasePodcast,\r\n    ])->dispatch();\r\n\r\n除了链接任务类实例之外，你还可以链接闭包：\r\n\r\n    Bus::chain([\r\n        new ProcessPodcast,\r\n        new OptimizePodcast,\r\n        function () {\r\n            Podcast::update(/* ... */);\r\n        },\r\n    ])->dispatch();\r\n\r\n> **注意**  \r\n> 在任务中使用 `$this->delete()` 方法删除任务不会阻止链式任务的处理。只有当链中的任务失败时，链才会停止执行。\r\n\r\n<a name=\"chain-connection-queue\"></a>\r\n#### 链式连接 & 队列\r\n\r\n如果要指定链接任务应使用的连接和队列，可以使用 `onConnection` 和 `onQueue` 方法。这些方法指定应使用的队列连接和队列名称，除非为排队任务显式分配了不同的连接 / 队列：\r\n\r\n    Bus::chain([\r\n        new ProcessPodcast,\r\n        new OptimizePodcast,\r\n        new ReleasePodcast,\r\n    ])->onConnection('redis')->onQueue('podcasts')->dispatch();\r\n\r\n<a name=\"chain-failures\"></a>\r\n#### 链故障\r\n\r\n链接任务时，你可以使用 `catch` 方法指定一个闭包，如果链中的任务失败，则应调用该闭包。给定的回调将接收导致任务失败的 `Throwable` 实例：\r\n\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n    use Throwable;\r\n\r\n    Bus::chain([\r\n        new ProcessPodcast,\r\n        new OptimizePodcast,\r\n        new ReleasePodcast,\r\n    ])->catch(function (Throwable $e) {\r\n        // 链中的任务失败了...\r\n    })->dispatch();\r\n\r\n> **注意**  \r\n> 由于链式回调由 Laravel 队列稍后序列化并执行，因此你不应在链式回调中使用 `$this` 变量。\r\n\r\n<a name=\"customizing-the-queue-and-connection\"></a>\r\n### 自定义队列 & 连接\r\n\r\n<a name=\"dispatching-to-a-particular-queue\"></a>\r\n#### 分派到特定队列\r\n\r\n通过将任务推送到不同的队列，你可以对排队的任务进行「分类」，甚至可以优先考虑分配给各个队列的工作人员数量。请记住，这不会将任务推送到队列配置文件定义的不同队列「连接」，而只会推送到单个连接中的特定队列。要指定队列，请在调度任务时使用 `onQueue` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 存储一个播客。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $podcast = Podcast::create(/* ... */);\r\n\r\n            // 创建播客...\r\n\r\n            ProcessPodcast::dispatch($podcast)->onQueue('processing');\r\n\r\n            return redirect('/podcasts');\r\n        }\r\n    }\r\n\r\n或者，你可以通过在任务的构造函数中调用 `onQueue` 方法来指定任务的队列：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n     use Illuminate\\Bus\\Queueable;\r\n     use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n     use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n     use Illuminate\\Queue\\InteractsWithQueue;\r\n     use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建一个新的任务实例\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->onQueue('processing');\r\n        }\r\n    }\r\n\r\n<a name=\"dispatching-to-a-particular-connection\"></a>\r\n#### 调度到特定连接\r\n\r\n如果你的应用程序与多个队列连接交互，你可以使用 `onConnection` 方法指定将任务推送到哪个连接：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Jobs\\ProcessPodcast;\r\n    use App\\Models\\Podcast;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PodcastController extends Controller\r\n    {\r\n        /**\r\n         * 储存新的播客\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $podcast = Podcast::create(/* ... */);\r\n\r\n            // 创建播客...\r\n\r\n            ProcessPodcast::dispatch($podcast)->onConnection('sqs');\r\n\r\n            return redirect('/podcasts');\r\n        }\r\n    }\r\n\r\n你可以将 `onConnection` 和 `onQueue` 方法链接在一起，以指定任务的连接和队列：\r\n\r\n    ProcessPodcast::dispatch($podcast)\r\n                  ->onConnection('sqs')\r\n                  ->onQueue('processing');\r\n\r\n或者，你可以通过在任务的构造函数中调用 `onConnection` 方法来指定任务的连接\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n     use Illuminate\\Bus\\Queueable;\r\n     use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n     use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n     use Illuminate\\Queue\\InteractsWithQueue;\r\n     use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建一个新的任务实例。\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->onConnection('sqs');\r\n        }\r\n    }\r\n\r\n<a name=\"max-job-attempts-and-timeout\"></a>\r\n### 指定最大任务尝试 / 超时值\r\n\r\n<a name=\"max-attempts\"></a>\r\n#### 最大尝试次数\r\n\r\n如果你的一个队列任务遇到了错误，你可能不希望无限制的重试。因此 Laravel 提供了各种方法来指定一个任务可以尝试多少次或多长时间。\r\n\r\n指定任务可尝试的最大次数的其中一个方法是，通过 Artisan 命令行上的 `--tries` 开关。这将适用于调度作业的所有任务，除非正在处理的任务指定了最大尝试次数。\r\n\r\n```shell\r\nphp artisan queue:work --tries=3\r\n```\r\n\r\n如果一个任务超过其最大尝试次数，将被视为「失败」的任务。有关处理失败任务的更多信息，可以参考 [处理失败队列](/docs/laravel/10.x/queuesmd/14873#dealing-with-failed-jobs)。如果将 `--tries=0` 提供给 `queue:work` 命令，任务将无限期地重试。\r\n\r\n你可以采取更细化的方法来定义任务类本身的最大尝试次数。如果在任务上指定了最大尝试次数，它将优先于命令行上提供的 `--tries` 开关设定的值：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        /**\r\n         * 任务可尝试的次数。\r\n         *\r\n         * @var int\r\n         */\r\n        public $tries = 5;\r\n    }\r\n\r\n<a name=\"time-based-attempts\"></a>\r\n#### 基于时间的尝试\r\n\r\n除了定义任务失败前尝试的次数之外，还可以定义任务应该超时的时间。这允许在给定的时间范围内尝试任意次数的任务。要定义任务超时的时间，请在任务类中添加 `retryUntil` 方法。这个方法应返回一个 `DateTime` 实例：\r\n\r\n    use DateTime;\r\n\r\n    /**\r\n     * 确定任务应该超时的时间。\r\n     */\r\n    public function retryUntil(): DateTime\r\n    {\r\n        return now()->addMinutes(10);\r\n    }\r\n\r\n> **技巧**  \r\n> 你也可以在 [队列事件监听器](/docs/laravel/10.x/eventsmd#queued-event-listeners) 上定义一个 `tries` 属性或 `retryUntil` 方法。\r\n\r\n<a name=\"max-exceptions\"></a>\r\n#### 最大尝试\r\n\r\n有时你可能希望指定一个任务可能会尝试多次，但如果重试由给定数量的未处理异常触发（而不是直接由 `release` 方法释放），则应该失败。为此，你可以在任务类上定义一个 `maxExceptions` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        /**\r\n         * 可以尝试任务的次数\r\n         *\r\n         * @var int\r\n         */\r\n        public $tries = 25;\r\n\r\n        /**\r\n         * 失败前允许的最大未处理异常数\r\n         *\r\n         * @var int\r\n         */\r\n        public $maxExceptions = 3;\r\n\r\n        /**\r\n         * 执行\r\n         */\r\n        public function handle(): void\r\n        {\r\n            Redis::throttle('key')->allow(10)->every(60)->then(function () {\r\n                // 获得锁，处理播客...\r\n            }, function () {\r\n                // 无法获取锁...\r\n                return $this->release(10);\r\n            });\r\n        }\r\n    }\r\n\r\n在此示例中，如果应用程序无法获得 Redis 锁，则该任务将在 10 秒后被释放，并将继续重试最多 25 次。但是，如果任务抛出三个未处理的异常，则任务将失败。\r\n\r\n<a name=\"timeout\"></a>\r\n#### 超时\r\n\r\n> **注意**  \r\n> 必须安装 `pcntl` PHP 扩展以指定任务超时。\r\n\r\n通常，你大致知道你预计排队的任务需要多长时间。出于这个原因，Laravel 允许你指定一个「超时」值。 如果任务的处理时间超过超时值指定的秒数，则处理该任务的任务进程将退出并出现错误。 通常，任务程序将由在你的[服务器上配置的进程管理器](#supervisor-configuration)自动重新启动。\r\n\r\n同样，任务可以运行的最大秒数可以使用 Artisan 命令行上的 `--timeout` 开关来指定：\r\n\r\n```shell\r\nphp artisan queue:work --timeout=30\r\n```\r\n\r\n如果任务因不断超时而超过其最大尝试次数，则它将被标记为失败。\r\n\r\n你也可以定义允许任务在任务类本身上运行的最大秒数。如果在任务上指定了超时，它将优先于在命令行上指定的任何超时:\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        /**\r\n         * 在超时之前任务可以运行的秒数.\r\n         *\r\n         * @var int\r\n         */\r\n        public $timeout = 120;\r\n    }\r\n\r\n有些时候，诸如 socket 或在 HTTP 连接之类的 IO 阻止进程可能不会遵守你指定的超时。因此，在使用这些功能时，也应始终尝试使用其 API 指定超时。例如，在使用 Guzzle 时，应始终指定连接并请求的超时时间。\r\n\r\n<a name=\"failing-on-timeout\"></a>\r\n#### 超时失败\r\n\r\n如果你希望在超时时将任务标记为 [failed](#dealing-with-failed-jobs)，可以在任务类上定义 `$failOnTimeout` 属性：\r\n\r\n```php\r\n/**\r\n * 标示是否应在超时时标记为失败.\r\n *\r\n * @var bool\r\n */\r\npublic $failOnTimeout = true;\r\n```\r\n\r\n<a name=\"error-handling\"></a>\r\n### 错误处理\r\n\r\n如果在处理任务时抛出异常，任务将自动释放回队列，以便再次尝试。 任务将继续发布，直到尝试达到你的应用程序允许的最大次数为止。最大尝试次数由 `queue:work` Artisan 命令中使用的 `--tries` 开关定义。或者，可以在任务类本身上定义最大尝试次数。有关运行队列处理器的更多信息 [可以在下面找到](#running-the-queue-worker)。\r\n\r\n<a name=\"manually-releasing-a-job\"></a>\r\n#### 手动发布\r\n\r\n有时你可能希望手动将任务发布回队列，以便稍后再次尝试。你可以通过调用 `release` 方法来完成此操作：\r\n\r\n    /**\r\n     * 执行任务。\r\n     */\r\n    public function handle(): void\r\n    {\r\n        // ...\r\n\r\n        $this->release();\r\n    }\r\n\r\n默认情况下，`release` 方法会将任务发布回队列以供立即处理。但是，通过向 `release` 方法传递一个整数，你可以指示队列在给定的秒数过去之前不使任务可用于处理：\r\n\r\n    $this->release(10);\r\n\r\n<a name=\"manually-failing-a-job\"></a>\r\n#### 手动使任务失败\r\n\r\n有时，你可能需要手动将任务标记为 「failed」。为此，你可以调用 `fail` 方法：\r\n\r\n    /**\r\n     * 执行任务。\r\n     */\r\n    public function handle(): void\r\n    {\r\n        // ...\r\n\r\n        $this->fail();\r\n    }\r\n\r\n如果你捕获了一个异常，你想直接将你的任务标记为失败，你可以将异常传递给 `fail` 方法。 或者，为方便起见，你可以传递一个字符串来表示错误异常信息：\r\n\r\n    $this->fail($exception);\r\n\r\n    $this->fail('Something went wrong.');\r\n\r\n> **技巧**  \r\n> 有关失败任务的更多信息，请查看 [处理任务失败的文档](#dealing-with-failed-jobs).\r\n\r\n<a name=\"job-batching\"></a>\r\n## 任务批处理\r\n\r\nLaravel 的任务批处理功能允许你轻松地执行一批任务，然后在这批任务执行完毕后执行一些操作。 在开始之前，你应该创建一个数据库迁移以构建一个表来包含有关你的任务批次的元信息，例如它们的完成百分比。 可以使用 `queue:batches-table` Artisan 命令来生成此迁移：\r\n\r\n```shell\r\nphp artisan queue:batches-table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"defining-batchable-jobs\"></a>\r\n### 定义可批处理任务\r\n\r\n要定义可批处理的任务，你应该像往常一样[创建可排队的任务](#creating-jobs)； 但是，你应该将 `Illuminate\\Bus\\Batchable` 特性添加到任务类中。 此 `trait` 提供对 `batch` 方法的访问，该方法可用于检索任务正在执行的当前批次：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use Illuminate\\Bus\\Batchable;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class ImportCsv implements ShouldQueue\r\n    {\r\n        use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 执行任务。\r\n         */\r\n        public function handle(): void\r\n        {\r\n            if ($this->batch()->cancelled()) {\r\n                // 确定批次是否已被取消...\r\n\r\n                return;\r\n            }\r\n\r\n            // 导入 CSV 文件的一部分...\r\n        }\r\n    }\r\n\r\n<a name=\"dispatching-batches\"></a>\r\n### 调度批次\r\n\r\n要调度一批任务，你应该使用 `Bus` 门面的 `batch` 方法。 当然，批处理主要在与完成回调结合使用时有用。 因此，你可以使用 `then`、`catch` 和 `finally` 方法来定义批处理的完成回调。 这些回调中的每一个在被调用时都会收到一个 `Illuminate\\Bus\\Batch` 实例。 在这个例子中，我们假设我们正在排队一批任务，每个任务处理 CSV 文件中给定数量的行：\r\n\r\n    use App\\Jobs\\ImportCsv;\r\n    use Illuminate\\Bus\\Batch;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n    use Throwable;\r\n\r\n    $batch = Bus::batch([\r\n        new ImportCsv(1, 100),\r\n        new ImportCsv(101, 200),\r\n        new ImportCsv(201, 300),\r\n        new ImportCsv(301, 400),\r\n        new ImportCsv(401, 500),\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务均已成功完成...\r\n    })->catch(function (Batch $batch, Throwable $e) {\r\n        // 检测到第一批任务失败...\r\n    })->finally(function (Batch $batch) {\r\n        // 批处理已完成执行...\r\n    })->dispatch();\r\n\r\n    return $batch->id;\r\n\r\n批次的 ID 可以通过 `$batch->id` 属性访问，可用于 [查询 Laravel 命令总线](#inspecting-batches) 以获取有关批次分派后的信息。\r\n\r\n> **注意**  \r\n> 由于批处理回调是由 Laravel 队列序列化并在稍后执行的，因此你不应在回调中使用 `$this` 变量。\r\n\r\n<a name=\"naming-batches\"></a>\r\n#### 命名批次\r\n\r\nLaravel Horizon 和 Laravel Telescope 等工具如果命名了批次，可能会为批次提供更用户友好的调试信息。要为批处理分配任意名称，你可以在定义批处理时调用 `name` 方法：\r\n\r\n    $batch = Bus::batch([\r\n        // ...\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务均已成功完成...\r\n    })->name('Import CSV')->dispatch();\r\n\r\n<a name=\"batch-connection-queue\"></a>\r\n#### 批处理连接 & 队列\r\n\r\n如果你想指定应用于批处理任务的连接和队列，你可以使用 `onConnection` 和 `onQueue` 方法。 所有批处理任务必须在相同的连接和队列中执行：\r\n\r\n    $batch = Bus::batch([\r\n        // ...\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务均已成功完成...\r\n    })->onConnection('redis')->onQueue('imports')->dispatch();\r\n\r\n<a name=\"chains-within-batches\"></a>\r\n#### 批量内链\r\n\r\n你可以通过将链接的任务放在数组中来在批处理中定义一组 [链接的任务](#job-chaining)。 例如，我们可以并行执行两个任务链，并在两个任务链都完成处理后执行回调：\r\n\r\n    use App\\Jobs\\ReleasePodcast;\r\n    use App\\Jobs\\SendPodcastReleaseNotification;\r\n    use Illuminate\\Bus\\Batch;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n\r\n    Bus::batch([\r\n        [\r\n            new ReleasePodcast(1),\r\n            new SendPodcastReleaseNotification(1),\r\n        ],\r\n        [\r\n            new ReleasePodcast(2),\r\n            new SendPodcastReleaseNotification(2),\r\n        ],\r\n    ])->then(function (Batch $batch) {\r\n        // ...\r\n    })->dispatch();\r\n\r\n<a name=\"adding-jobs-to-batches\"></a>\r\n### 批量添加任务\r\n\r\n有些时候，批量向批处理中添加任务可能很有用。当你需要批量处理数千个任务时，这种模式非常好用，而这些任务在 Web 请求期间可能需要很长时间才能调度。因此，你可能希望调度初始批次的「加载器」任务，这些任务与更多任务相结合：\r\n\r\n    $batch = Bus::batch([\r\n        new LoadImportBatch,\r\n        new LoadImportBatch,\r\n        new LoadImportBatch,\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务都成功完成... \r\n    })->name('Import Contacts')->dispatch();\r\n\r\n在这个例子中，我们将使用 `LoadImportBatch` 实例为批处理添加其他任务。为了实现这个功能，我们可以对批处理实例使用 `add` 方法，该方法可以通过 `batch` 实例访问：\r\n\r\n    use App\\Jobs\\ImportContacts;\r\n    use Illuminate\\Support\\Collection;\r\n\r\n    /**\r\n     * 执行任务。\r\n     */\r\n    public function handle(): void\r\n    {\r\n        if ($this->batch()->cancelled()) {\r\n            return;\r\n        }\r\n\r\n        $this->batch()->add(Collection::times(1000, function () {\r\n            return new ImportContacts;\r\n        }));\r\n    }\r\n\r\n> **注意**  \r\n> 你只能将任务添加到当前任务所属的批处理中。\r\n\r\n<a name=\"inspecting-batches\"></a>\r\n### 校验批处理\r\n\r\n为批处理完成后提供回调的 `Illuminate\\Bus\\Batch` 实例中具有多种属性和方法，可以帮助你与指定的批处理业务进行交互和检查：\r\n\r\n    // 批处理的UUID...\r\n    $batch->id;\r\n\r\n    // 批处理的名称（如果已经设置的话）...\r\n    $batch->name;\r\n\r\n    // 分配给批处理的任务数量...\r\n    $batch->totalJobs;\r\n\r\n    // 队列还没处理的任务数量...\r\n    $batch->pendingJobs;\r\n\r\n    // 失败的任务数量...\r\n    $batch->failedJobs;\r\n\r\n    // 到目前为止已经处理的任务数量...\r\n    $batch->processedJobs();\r\n\r\n    // 批处理已经完成的百分比（0-100）...\r\n    $batch->progress();\r\n\r\n    // 批处理是否已经完成执行...\r\n    $batch->finished();\r\n\r\n    // 取消批处理的运行...\r\n    $batch->cancel();\r\n\r\n    // 批处理是否已经取消...\r\n    $batch->cancelled();\r\n\r\n<a name=\"returning-batches-from-routes\"></a>\r\n#### 从路由返回批次\r\n\r\n所有 `Illuminate\\Bus\\Batch` 实例都是 JSON 可序列化的，这意味着你可以直接从应用程序的一个路由返回它们，以检索包含有关批处理的信息的 JSON 有效负载，包括其完成进度。这样可以方便地在应用程序的 UI 中显示有关批处理完成进度的信息。\r\n\r\n要通过 ID 检索批次，你可以使用 `Bus` 外观的 `findBatch` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n    use Illuminate\\Support\\Facades\\Route;\r\n\r\n    Route::get('/batch/{batchId}', function (string $batchId) {\r\n        return Bus::findBatch($batchId);\r\n    });\r\n\r\n<a name=\"cancelling-batches\"></a>\r\n### 取消批次\r\n\r\n有时你可能需要取消给定批处理的执行。这可以通过调用 `Illuminate\\Bus\\Batch` 实例的 `cancel` 方法来完成：\r\n\r\n    /**\r\n     * 执行任务。\r\n     */\r\n    public function handle(): void\r\n    {\r\n        if ($this->user->exceedsImportLimit()) {\r\n            return $this->batch()->cancel();\r\n        }\r\n\r\n        if ($this->batch()->cancelled()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n正如你在前面的示例中可能已经注意到的那样，批处理任务通常应在继续执行之前确定其相应的批处理是否已被取消。 但是，为了方便起见，你可以将 `SkipIfBatchCancelled` [中间件](#job-middleware) 分配给作业。 顾名思义，如果相应的批次已被取消，此中间件将指示 Laravel 不处理该作业：\r\n\r\n    use Illuminate\\Queue\\Middleware\\SkipIfBatchCancelled;\r\n\r\n    /**\r\n     * 获取任务应通过的中间件。\r\n     */\r\n    public function middleware(): array\r\n    {\r\n        return [new SkipIfBatchCancelled];\r\n    }\r\n\r\n<a name=\"batch-failures\"></a>\r\n### 批处理失败\r\n\r\n当批处理任务失败时，将调用 `catch` 回调（如果已分配）。此回调仅针对批处理中失败的第一个任务调用。\r\n\r\n<a name=\"allowing-failures\"></a>\r\n#### 允许失败\r\n\r\n当批处理中的某个任务失败时，Laravel 会自动将该批处理标记为「已取消」。如果你愿意，你可以禁用此行为，以便任务失败不会自动将批处理标记为已取消。这可以通过在调度批处理时调用 `allowFailures` 方法来完成：\r\n\r\n    $batch = Bus::batch([\r\n        // ...\r\n    ])->then(function (Batch $batch) {\r\n        // 所有任务均已成功完成...\r\n    })->allowFailures()->dispatch();\r\n\r\n<a name=\"retrying-failed-batch-jobs\"></a>\r\n#### 重试失败的批处理任务\r\n\r\n为方便起见，Laravel 提供了一个 `queue:retry-batch` Artisan 命令，允许你轻松重试给定批次的所有失败任务。 `queue:retry-batch` 命令接受应该重试失败任务的批处理的 UUID：\r\n\r\n```shell\r\nphp artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5\r\n```\r\n\r\n<a name=\"pruning-batches\"></a>\r\n### 修剪批次\r\n\r\n如果不进行修剪，`job_batches` 表可以非常快速地积累记录。为了缓解这种情况，你应该 [schedule](/docs/laravel/10.x/scheduling) `queue:prune-batches` Artisan 命令每天运行：\r\n\r\n    $schedule->command('queue:prune-batches')->daily();\r\n\r\n默认情况下，将修剪所有超过 24 小时的已完成批次。你可以在调用命令时使用 `hours` 选项来确定保留批处理数据的时间。例如，以下命令将删除 48 小时前完成的所有批次：\r\n\r\n    $schedule->command('queue:prune-batches --hours=48')->daily();\r\n\r\n有时，你的 `jobs_batches` 表可能会累积从未成功完成的批次的批次记录，例如任务失败且该任务从未成功重试的批次。 你可以使用 `unfinished` 选项指示 `queue:prune-batches` 命令修剪这些未完成的批处理记录：\r\n\r\n    $schedule->command('queue:prune-batches --hours=48 --unfinished=72')->daily();\r\n\r\n同样，你的 `jobs_batches` 表也可能会累积已取消批次的批次记录。 你可以使用 `cancelled` 选项指示 `queue:prune-batches` 命令修剪这些已取消的批记录：\r\n\r\n    $schedule->command('queue:prune-batches --hours=48 --cancelled=72')->daily();\r\n\r\n<a name=\"queueing-closures\"></a>\r\n## 队列闭包\r\n\r\n除了将任务类分派到队列之外，你还可以分派一个闭包。这对于需要在当前请求周期之外执行的快速、简单的任务非常有用。当向队列分派闭包时，闭包的代码内容是加密签名的，因此它不能在传输过程中被修改：\r\n\r\n    $podcast = App\\Podcast::find(1);\r\n\r\n    dispatch(function () use ($podcast) {\r\n        $podcast->publish();\r\n    });\r\n\r\n使用 `catch` 方法，你可以提供一个闭包，如果排队的闭包在耗尽所有队列的[配置的重试次数](#max-job-attempts-and-timeout) 后未能成功完成，则应执行该闭包：\r\n\r\n    use Throwable;\r\n\r\n    dispatch(function () use ($podcast) {\r\n        $podcast->publish();\r\n    })->catch(function (Throwable $e) {\r\n        // 这个任务失败了...\r\n    });\r\n\r\n> **注意**  \r\n> 由于 `catch` 回调由 Laravel 队列稍后序列化并执行，因此你不应在 `catch` 回调中使用 `$this` 变量。\r\n\r\n<a name=\"running-the-queue-worker\"></a>\r\n## 运行队列工作者\r\n\r\n<a name=\"the-queue-work-command\"></a>\r\n### `queue:work` 命令\r\n\r\nLaravel 包含一个 Artisan 命令，该命令将启动队列进程并在新任务被推送到队列时处理它们。 你可以使用 `queue:work` Artisan 命令运行任务进程。请注意，一旦 `queue:work` 命令启动，它将继续运行，直到手动停止或关闭终端：\r\n\r\n```shell\r\nphp artisan queue:work\r\n```\r\n\r\n> **技巧**  \r\n> 要保持 `queue:work` 进程在后台永久运行，你应该使用 [Supervisor](#supervisor-configuration) 等进程监视器来确保队列工作进程不会停止运行。\r\n\r\n\r\n\r\n如果你希望处理的任务 ID 包含在命令的输出中，则可以在调用 `queue:work` 命令时包含 -v 标志：\r\n\r\n```shell\r\nphp artisan queue:work -v\r\n```\r\n\r\n请记住，队列任务工作者是长期存在的进程，并将启动的应用程序状态存储在内存中。 因此，他们在启动后不会注意到你的代码库中的更改。 因此，在你的部署过程中，请务必[重新启动你的任务队列进程](#queue-workers-and-deployment)。 此外，请记住，你的应用程序创建或修改的任何静态状态都不会在任务启动之间自动重置。\r\n\r\n或者，你可以运行 `queue:listen` 命令。 使用 `queue:listen` 命令时，当你想要重新加载更新后的代码或重置应用程序状态时，无需手动重启 worker； 但是，此命令的效率明显低于 `queue:work` 命令：\r\n\r\n```shell\r\nphp artisan queue:listen\r\n```\r\n\r\n<a name=\"running-multiple-queue-workers\"></a>\r\n#### 运行多个队列进程\r\n\r\n要将多个 worker 分配到一个队列并同时处理任务，你应该简单地启动多个 `queue:work` 进程。 这可以通过终端中的多个选项卡在本地完成，也可以使用流程管理器的配置设置在生产环境中完成。 [使用 Supervisor 时](#supervisor-configuration)，你可以使用 `numprocs` 配置值。\r\n\r\n<a name=\"specifying-the-connection-queue\"></a>\r\n#### 指定连接 & 队列\r\n\r\n你还可以指定工作人员应使用哪个队列连接。 传递给 `work` 命令的连接名称应对应于 `config/queue.php` 配置文件中定义的连接之一：\r\n\r\n```shell\r\nphp artisan queue:work redis\r\n```\r\n\r\n默认情况下，`queue:work` 命令只处理给定连接上默认队列的任务。 但是，你可以通过仅处理给定连接的特定队列来进一步自定义你的队列工作者。 例如，如果你的所有电子邮件都在你的 `redis` 队列连接上的 `emails` 队列中处理，你可以发出以下命令来启动只处理该队列的工作程序：\r\n\r\n```shell\r\nphp artisan queue:work redis --queue=emails\r\n```\r\n\r\n<a name=\"processing-a-specified-number-of-jobs\"></a>\r\n#### Processing A Specified Number Of Jobs\r\n\r\n`--once` 选项可用于指定进程仅处理队列中的单个任务\r\n\r\n```shell\r\nphp artisan queue:work --once\r\n```\r\n\r\n`--max-jobs` 选项可用于指示 worker 处理给定数量的任务然后退出。 此选项在与 [Supervisor](#supervisor-configuration) 结合使用时可能很有用，这样你的工作人员在处理给定数量的任务后会自动重新启动，释放他们可能积累的任何内存：\r\n\r\n```shell\r\nphp artisan queue:work --max-jobs=1000\r\n```\r\n\r\n<a name=\"processing-all-queued-jobs-then-exiting\"></a>\r\n#### 处理所有排队的任务然后退出\r\n\r\n`--stop-when-empty` 选项可用于指定进程处理所有作业，然后正常退出。如果你希望在队列为空后关闭容器，则此选项在处理 Docker 容器中的 Laravel 队列时很有用\r\n\r\n```shell\r\nphp artisan queue:work --stop-when-empty\r\n```\r\n\r\n<a name=\"processing-jobs-for-a-given-number-of-seconds\"></a>\r\n#### 在给定的秒数内处理任务\r\n\r\n`--max-time` 选项可用于指示进程给定的秒数内处理作业，然后退出。 当与 [Supervisor](#supervisor-configuration) 结合使用时，此选项可能很有用，这样你的工作人员在处理作业给定时间后会自动重新启动，释放他们可能积累的任何内存：\r\n\r\n```shell\r\n# 处理进程一小时，然后退出...\r\nphp artisan queue:work --max-time=3600\r\n```\r\n\r\n<a name=\"worker-sleep-duration\"></a>\r\n#### 进程睡眠时间\r\n\r\n当队列中有任务可用时，进程将继续处理作业，而不会在它们之间产生延迟。但是，`sleep` 选项决定了如果没有可用的新任务，进程将 `sleep` 多少秒。 睡眠时，进程不会处理任何新的作业 - 任务将在进程再次唤醒后处理。\r\n\r\n```shell\r\nphp artisan queue:work --sleep=3\r\n```\r\n\r\n<a name=\"resource-considerations\"></a>\r\n#### 资源注意事项\r\n\r\n守护进程队列在处理每个任务之前不会 `reboot` 框架。因此，你应该在每个任务完成后释放所有繁重的资源。例如，如果你正在使用 GD 库进行图像处理，你应该在处理完图像后使用 `imagedestroy` 释放内存。\r\n\r\n<a name=\"queue-priorities\"></a>\r\n### 队列优先级\r\n\r\n有时你可能希望优先处理队列的处理方式。例如，在 `config/queue.php` 配置文件中，你可以将 `redis` 连接的默认 `queue` 设置为 `low`。 但是，有时你可能希望将作业推送到 `high` 优先级队列，如下所示：\r\n\r\n    dispatch((new Job)->onQueue('high'));\r\n\r\n要启动一个进程，在继续处理 `low` 队列上的任何任务之前验证所有 `high` 队列任务是否已处理，请将队列名称的逗号分隔列表传递给 `work` 命令：\r\n\r\n```shell\r\nphp artisan queue:work --queue=high,low\r\n```\r\n\r\n<a name=\"queue-workers-and-deployment\"></a>\r\n### 队列进程 & 部署\r\n\r\n由于队列任务是长期存在的进程，如果不重新启动，他们不会注意到代码的更改。因此，使用队列任务部署应用程序的最简单方法是在部署过程中重新启动任务。你可以通过发出 `queue:restart` 命令优雅地重新启动所有进程：\r\n\r\n```shell\r\nphp artisan queue:restart\r\n```\r\n\r\n此命令将指示所有队列进程在处理完当前任务后正常退出，以免丢失现有任务。由于队列任务将在执行 `queue:restart` 命令时退出，你应该运行诸如 [Supervisor](#supervisor-configuration) 之类的进程管理器来自动重新启动队列任务。\r\n\r\n>**注意**\r\n>队列使用 [cache](/docs/laravel/10.x/cache)  来存储重启信号，因此你应该在使用此功能之前验证是否为你的应用程序正确配置了缓存驱动程序。\r\n\r\n<a name=\"job-expirations-and-timeouts\"></a>\r\n### 任务到期 & 超时\r\n\r\n<a name=\"job-expiration\"></a>\r\n#### 任务到期\r\n\r\n在`config/queue.php`配置文件中，每个队列连接都定义了一个`retry_after`选项。该选项指定队列连接在重试正在处理的作业之前应该等待多少秒。例如，如果`retry_after`的值设置为`90`，如果作业已经处理了90秒而没有被释放或删除，则该作业将被释放回队列。通常，你应该将`retry_after`值设置为作业完成处理所需的最大秒数。\r\n\r\n>**警告**\r\n>唯一不包含 `retry_after` 值的队列连接是Amazon SQS。SQS将根据AWS控制台内管理的 [默认可见性超时](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html) 重试作业。\r\n\r\n<a name=\"worker-timeouts\"></a>\r\n#### 进程超时\r\n\r\n`queue:work` Artisan命令公开了一个`--timeout`选项。默认情况下，`--timeout`值为60秒。如果任务的处理时间超过超时值指定的秒数，则处理该任务的进程将退出并出现错误。通常，工作程序将由 [你的服务器上配置的进程管理器](#supervisor-configuration) 自动重新启动：\r\n\r\n```shell\r\nphp artisan queue:work --timeout=60\r\n```\r\n\r\n`retry_after` 配置选项和 `--timeout` CLI 选项是不同的，但它们协同工作以确保任务不会丢失并且任务仅成功处理一次。\r\n> **警告**\r\n> `--timeout` 值应始终比 `retry_after` 配置值至少短几秒钟。 这将确保处理冻结任务的进程始终在重试任务之前终止。 如果你的 `--timeout` 选项比你的 `retry_after` 配置值长，你的任务可能会被处理两次。\r\n\r\n<a name=\"supervisor-configuration\"></a>\r\n## Supervisor 配置\r\n\r\n在生产中，你需要一种方法来保持 `queue:work` 进程运行。 `queue:work` 进程可能会因多种原因停止运行，例如超过 worker 超时或执行 `queue:restart` 命令。\r\n出于这个原因，你需要配置一个进程监视器，它可以检测你的 `queue:work` 进程何时退出并自动重新启动它们。此外，进程监视器可以让你指定要同时运行多少个 `queue:work` 进程。Supervisor 是 Linux 环境中常用的进程监视器，我们将在下面的文档中讨论如何配置它。\r\n\r\n<a name=\"installing-supervisor\"></a>\r\n#### 安装 Supervisor\r\n\r\nSupervisor 是 Linux 操作系统的进程监视器，如果它们失败，它将自动重新启动你的 `queue:work` 进程。要在 Ubuntu 上安装 Supervisor，你可以使用以下命令：\r\n\r\n```shell\r\nsudo apt-get install supervisor\r\n```\r\n>**注意**\r\n>如果你自己配置和管理 Supervisor 听起来很费力，请考虑使用 [Laravel Forge](https://forge.laravel.com)，它会自动为你的生产 Laravel 项目安装和配置 Supervisor。\r\n\r\n<a name=\"configuring-supervisor\"></a>\r\n#### 配置 Supervisor\r\n\r\nSupervisor 配置文件通常存储在 `/etc/supervisor/conf.d` 目录中。在这个目录中，你可以创建任意数量的配置文件来指示 Supervisor 应该如何监控你的进程。例如，让我们创建一个启动和监控 `queue:work` 进程的 `laravel-worker.conf` 文件：\r\n\r\n```ini\r\n[program:laravel-worker]\r\nprocess_name=%(program_name)s_%(process_num)02d\r\ncommand=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600\r\nautostart=true\r\nautorestart=true\r\nstopasgroup=true\r\nkillasgroup=true\r\nuser=forge\r\nnumprocs=8\r\nredirect_stderr=true\r\nstdout_logfile=/home/forge/app.com/worker.log\r\nstopwaitsecs=3600\r\n```\r\n\r\n在这个例子中，`numprocs` 指令将指示 Supervisor 运行 8 个 `queue:work` 进程并监控所有进程，如果它们失败则自动重新启动它们。你应该更改配置的「命令」指令以反映你所需的队列连接和任务选项。\r\n\r\n> **警告**\r\n> 你应该确保 `stopwaitsecs` 的值大于运行时间最长的作业所消耗的秒数。否则，Supervisor 可能会在作业完成处理之前将其终止。\r\n\r\n<a name=\"starting-supervisor\"></a>\r\n#### 开始 Supervisor\r\n\r\n创建配置文件后，你可以使用以下命令更新 Supervisor 配置并启动进程：\r\n\r\n```shell\r\nsudo supervisorctl reread\r\n\r\nsudo supervisorctl update\r\n\r\nsudo supervisorctl start laravel-worker:*\r\n```\r\n\r\n有关 Supervisor 的更多信息，请参阅 [Supervisor 文档](http://supervisord.org/index.html)。\r\n\r\n<a name=\"dealing-with-failed-jobs\"></a>\r\n## 处理失败的任务\r\n\r\n有时，你队列的任务会失败。别担心，事情并不总是按计划进行！ Laravel 提供了一种方便的方法来 [指一个任务应该尝试的最大次数](#max-job-attempts-and-timeout)。在异步任务超过此尝试次数后，它将被插入到 `failed_jobs` 数据库表中。 失败的 [同步调度的任务](/docs/laravel/10.x/queuesmd#synchronous-dispatching) 不存储在此表中，它们的异常由应用程序立即处理。\r\n\r\n\r\n创建 `failed_jobs` 表的迁移通常已经存在于新的 Laravel 应用程序中。但是，如果你的应用程序不包含此表的迁移，你可以使用 `queue:failed-table` 命令来创建迁移：\r\n\r\n```shell\r\nphp artisan queue:failed-table\r\n\r\nphp artisan migrate\r\n```\r\n\r\n运行 [queue worker](#running-the-queue-worker) 进程时，你可以使用 `queue:work` 命令上的 `--tries` 开关指定任务应尝试的最大次数。如果你没有为 `--tries` 选项指定值，则作业将仅尝试一次或与任务类的 `$tries` 属性指定的次数相同：\r\n\r\n```shell\r\nphp artisan queue:work redis --tries=3\r\n```\r\n\r\n使用 `--backoff` 选项，你可以指定 Laravel 在重试遇到异常的任务之前应该等待多少秒。默认情况下，任务会立即释放回队列，以便可以再次尝试：\r\n\r\n```shell\r\nphp artisan queue:work redis --tries=3 --backoff=3\r\n```\r\n\r\n如果你想配置 Laravel 在重试每个任务遇到异常的任务之前应该等待多少秒，你可以通过在你的任务类上定义一个 `backoff` 属性来实现：\r\n\r\n    /**\r\n     * 重试任务前等待的秒数\r\n     *\r\n     * @var int\r\n     */\r\n    public $backoff = 3;\r\n\r\n如果你需要更复杂的逻辑来确定任务的退避时间，你可以在你的任务类上定义一个 `backoff` 方法：\r\n\r\n    /**\r\n    * 计算重试任务之前要等待的秒数\r\n    */\r\n    public function backoff(): int\r\n    {\r\n        return 3;\r\n    }\r\n\r\n你可以通过从 `backoff` 方法返回一组退避值来轻松配置 “exponential” 退避。在此示例中，第一次重试的重试延迟为 1 秒，第二次重试为 5 秒，第三次重试为 10 秒：\r\n\r\n    /**\r\n    * 计算重试任务之前要等待的秒数\r\n    *\r\n    * @return array<int, int>\r\n    */\r\n    public function backoff(): array\r\n    {\r\n        return [1, 5, 10];\r\n    }\r\n\r\n<a name=\"cleaning-up-after-failed-jobs\"></a>\r\n### 任务失败后清理\r\n\r\n当特定任务失败时，你可能希望向用户发送警报或恢复该任务部分完成的任何操作。为此，你可以在任务类上定义一个 `failed` 方法。导致作业失败的 `Throwable` 实例将被传递给 `failed` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use App\\Models\\Podcast;\r\n    use App\\Services\\AudioProcessor;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n    use Throwable;\r\n\r\n    class ProcessPodcast implements ShouldQueue\r\n    {\r\n        use InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建新任务实例\r\n         */\r\n        public function __construct(\r\n            public Podcast $podcast,\r\n        ) {}\r\n\r\n        /**\r\n         * 执行任务\r\n         */\r\n        public function handle(AudioProcessor $processor): void\r\n        {\r\n            // 处理上传的播客...\r\n        }\r\n\r\n        /**\r\n         * 处理失败作业\r\n         */\r\n        public function failed(Throwable $exception): void\r\n        {\r\n            // 向用户发送失败通知等...\r\n        }\r\n    }\r\n\r\n> **注意**  \r\n> 在调用 `failed` 方法之前实例化任务的新实例；因此，在 `handle` 方法中可能发生的任何类属性修改都将丢失。\r\n\r\n<a name=\"retrying-failed-jobs\"></a>\r\n### 重试失败的任务\r\n\r\n要查看已插入到你的 `failed_jobs` 数据库表中的所有失败任务，你可以使用 `queue:failed` Artisan 命令：\r\n\r\n```shell\r\nphp artisan queue:failed\r\n```\r\n\r\n`queue:failed` 命令将列出任务 ID、连接、队列、失败时间和有关任务的其他信息。任务 ID 可用于重试失败的任务。例如，要重试 ID 为 `ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece` 的失败任务，请发出以下命令：\r\n\r\n```shell\r\nphp artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece\r\n```\r\n\r\n如有必要，可以向命令传递多个 ID:\r\n\r\n```shell\r\nphp artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c-34f94a33c24d\r\n```\r\n\r\n还可以重试指定队列的所有失败任务：\r\n\r\n```shell\r\nphp artisan queue:retry --queue=name\r\n```\r\n\r\n重试所有失败任务，可以执行 `queue:retry` 命令，并将 `all` 作为 ID 传递：\r\n\r\n```shell\r\nphp artisan queue:retry all\r\n```\r\n\r\n如果要删除指定的失败任务，可以使用 `queue:forget` 命令：\r\n\r\n```shell\r\nphp artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d\r\n```\r\n\r\n> **技巧**  \r\n> 使用 [Horizon](/docs/laravel/10.x/horizon) 时，应该使用 `Horizon:forget` 命令来删除失败任务，而不是 `queue:forget` 命令。\r\n\r\n删除 `failed_jobs` 表中所有失败任务，可以使用 `queue:flush` 命令:\r\n\r\n```shell\r\nphp artisan queue:flush\r\n```\r\n\r\n<a name=\"ignoring-missing-models\"></a>\r\n### 忽略缺失的模型\r\n\r\n向任务中注入 `Eloquent` 模型时，模型会在注入队列之前自动序列化，并在处理任务时从数据库中重新检索。但是，如果在任务等待消费时删除了模型，则任务可能会失败，抛出 `ModelNotFoundException` 异常。\r\n\r\n为方便起见，可以把将任务的 `deleteWhenMissingModels` 属性设置为 `true`，这样会自动删除缺少模型的任务。当此属性设置为 `true` 时，Laravel 会放弃该任务，并且不会引发异常：\r\n\r\n    /**\r\n     * 如果任务的模型不存在，则删除该任务\r\n     *\r\n     * @var bool\r\n     */\r\n    public $deleteWhenMissingModels = true;\r\n\r\n<a name=\"pruning-failed-jobs\"></a>\r\n### 删除失败的任务\r\n\r\n你可以通过调用 `queue:prune-failed` Artisan 命令删除应用程序的 `failed_jobs` 表中的所有记录：\r\n\r\n```shell\r\nphp artisan queue:prune-failed\r\n```\r\n\r\n默认情况下，将删除所有超过 24 小时的失败任务记录，如果为命令提供 `--hours` 选项，则仅保留在过去 N 小时内插入的失败任务记录。例如，以下命令将删除超过 48 小时前插入的所有失败任务记录：\r\n\r\n```shell\r\nphp artisan queue:prune-failed --hours=48\r\n```\r\n\r\n<a name=\"storing-failed-jobs-in-dynamodb\"></a>\r\n### 在 DynamoDB 中存储失败的任务\r\n\r\nLaravel 还支持将失败的任务记录存储在 [DynamoDB](https://aws.amazon.com/dynamodb) 而不是关系数据库表中。但是，你必须创建一个 DynamoDB 表来存储所有失败的任务记录。通常，此表应命名为 `failed_jobs`，但你应根据应用程序的 `queue` 配置文件中的 `queue.failed.table` 配置值命名该表。\r\n\r\n`failed_jobs` 表应该有一个名为 `application` 的字符串主分区键和一个名为 uuid 的字符串主排序键。键的 `application` 部分将包含应用程序的名称，该名称由应用程序的 `app` 配置文件中的 `name` 配置值定义。由于应用程序名称是 DynamoDB 表键的一部分，因此你可以使用同一个表来存储多个 Laravel 应用程序的失败任务。\r\n\r\n此外，请确保你安装了 AWS 开发工具包，以便你的 Laravel 应用程序可以与 Amazon DynamoDB 通信：\r\n\r\n```shell\r\ncomposer require aws/aws-sdk-php\r\n```\r\n\r\n接下来，`queue.failed.driver` 配置选项的值设置为 `dynamodb`。此外，你应该在失败的作业配置数组中定义 `key`、`secret` 和 `region` 配置选项。 这些选项将用于向 AWS 进行身份验证。 当使用 `dynamodb` 驱动程序时，`queue.failed.database` 配置选项不是必须的：\r\n\r\n```php\r\n'failed' => [\r\n    'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),\r\n    'key' => env('AWS_ACCESS_KEY_ID'),\r\n    'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n    'table' => 'failed_jobs',\r\n],\r\n```\r\n\r\n<a name=\"disabling-failed-job-storage\"></a>\r\n### 禁用失败的任务存储\r\n\r\n你可以通过将 `queue.failed.driver` 配置选项的值设置为 `null` 来指示 Laravel 丢弃失败的任务而不存储它们。通过 `QUEUE_FAILED_DRIVER` 环境变量来完成：\r\n\r\n```ini\r\nQUEUE_FAILED_DRIVER=null\r\n```\r\n\r\n<a name=\"failed-job-events\"></a>\r\n### 失败的任务事件\r\n\r\n如果你想注册一个在作业失败时调用的事件监听器，你可以使用 `Queue` facade的 failing 方法。例如，我们可以从 Laravel 中包含的 `AppServiceProvider` 的 `boot` 方法为这个事件附加一个闭包：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Illuminate\\Queue\\Events\\JobFailed;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Queue::failing(function (JobFailed $event) {\r\n                // $event->connectionName\r\n                // $event->job\r\n                // $event->exception\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"clearing-jobs-from-queues\"></a>\r\n## 从队列中清除任务\r\n\r\n> **技巧**\r\n> 使用 [Horizon](/docs/laravel/10.x/horizon) 时，应使用 `horizon:clear` 命令从队列中清除作业，而不是使用 `queue:clear` 命令。\r\n\r\n如果你想从默认连接的默认队列中删除所有任务，你可以使用 `queue:clear` Artisan 命令来执行此操作：\r\n\r\n```shell\r\nphp artisan queue:clear\r\n```\r\n\r\n你还可以提供 `connection` 参数和 `queue` 选项以从特定连接和队列中删除任务：\r\n\r\n```shell\r\nphp artisan queue:clear redis --queue=emails\r\n```\r\n\r\n> **注意**\r\n> 从队列中清除任务仅适用于 SQS、Redis 和数据库队列驱动程序。 此外，SQS 消息删除过程最多需要 60 秒，因此在你清除队列后 60 秒内发送到 SQS 队列的任务也可能会被删除。\r\n\r\n<a name=\"monitoring-your-queues\"></a>\r\n## 监控你的队列\r\n\r\n如果你的队列突然涌入了大量的任务，它会导致队列任务繁重，从而增加了任务的完成时间，想你所想， Laravel 可以在队列执行超过设定的阈值时候提醒你。\r\n\r\n在开始之前， 你需要通过 `queue:monitor` 命令配置它 [每分钟执行一次](/docs/laravel/10.x/scheduling)。这个命令可以设定任务的名称，以及你想要设定的任务阈值：\r\n\r\n```shell\r\nphp artisan queue:monitor redis:default,redis:deployments --max=100\r\n```\r\n\r\n当你的任务超过设定阈值时候，仅通过这个方法还不足以触发通知，此时会触发一个 `Illuminate\\Queue\\Events\\QueueBusy` 事件。你可以在你的应用 `EventServiceProvider` 来监听这个事件，从而将监听结果通知给你的开发团队：\r\n\r\n```php\r\nuse App\\Notifications\\QueueHasLongWaitTime;\r\nuse Illuminate\\Queue\\Events\\QueueBusy;\r\nuse Illuminate\\Support\\Facades\\Event;\r\nuse Illuminate\\Support\\Facades\\Notification;\r\n\r\n/**\r\n * 为你的应用程序注册其他更多事件\r\n */\r\npublic function boot(): void\r\n{\r\n    Event::listen(function (QueueBusy $event) {\r\n        Notification::route('mail', 'dev@example.com')\r\n                ->notify(new QueueHasLongWaitTime(\r\n                    $event->connection,\r\n                    $event->queue,\r\n                    $event->size\r\n                ));\r\n    });\r\n}\r\n```\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n当测试调度任务的代码时，你可能希望指示 Laravel 不要实际执行任务本身，因为任务的代码可以直接和独立于调度它的代码进行测试。 当然，要测试任务本身，你可以实例化一个任务实例并在测试中直接调用 `handle` 方法。\r\n\r\n你可以使用 `Queue` facade 的 `fake` 方法来防止排队的任务实际被推送到队列中。 在调用 `Queue` facade 的 `fake` 方法后，你可以断言应用程序试图将任务推送到队列中：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Jobs\\AnotherJob;\r\n    use App\\Jobs\\FinalJob;\r\n    use App\\Jobs\\ShipOrder;\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_orders_can_be_shipped(): void\r\n        {\r\n            Queue::fake();\r\n\r\n            // 执行订单发货...\r\n\r\n            // 断言没有任务被推送......\r\n            Queue::assertNothingPushed();\r\n\r\n            // 断言一个任务被推送到一个给定的队列...\r\n            Queue::assertPushedOn('queue-name', ShipOrder::class);\r\n\r\n            // 断言任务被推了两次...\r\n            Queue::assertPushed(ShipOrder::class, 2);\r\n\r\n            // 断言任务没有被推送...\r\n            Queue::assertNotPushed(AnotherJob::class);\r\n\r\n            // 断言闭包被推送到队列中...\r\n            Queue::assertClosurePushed();\r\n        }\r\n    }\r\n\r\n你可以将闭包传递给 `assertPushed` 或 `assertNotPushed` 方法，以断言已推送通过给定「真实性测试」的任务。 如果至少有一项任务被推送并通过了给定的真值测试，则断言将成功：\r\n\r\n    Queue::assertPushed(function (ShipOrder $job) use ($order) {\r\n        return $job->order->id === $order->id;\r\n    });\r\n\r\n<a name=\"faking-a-subset-of-jobs\"></a>\r\n### 伪造任务的一个子集\r\n\r\n如果你只需要伪造特定的任务，同时允许你的其他任务正常执行，你可以将应该伪造的任务的类名传递给 fake 方法：\r\n\r\n    public function test_orders_can_be_shipped(): void\r\n    {\r\n        Queue::fake([\r\n            ShipOrder::class,\r\n        ]);\r\n\r\n        // 执行订单发货...\r\n\r\n        // 断言任务被推了两次......\r\n        Queue::assertPushed(ShipOrder::class, 2);\r\n    }\r\n\r\n你可以使用 `except` 方法伪造除一组指定任务之外的所有任务：\r\n\r\n    Queue::fake()->except([\r\n        ShipOrder::class,\r\n    ]);\r\n\r\n<a name=\"testing-job-chains\"></a>\r\n### 测试任务链\r\n\r\n要测试任务链，你需要利用 `Bus` 外观的伪造功能。 `Bus` 门面的 `assertChained` 方法可用于断言 [任务链](/docs/laravel/10.x/queues#job-chaining) 已被分派。 `assertChained` 方法接受一个链式任务数组作为它的第一个参数：\r\n\r\n    use App\\Jobs\\RecordShipment;\r\n    use App\\Jobs\\ShipOrder;\r\n    use App\\Jobs\\UpdateInventory;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n\r\n    Bus::fake();\r\n\r\n    // ...\r\n\r\n    Bus::assertChained([\r\n        ShipOrder::class,\r\n        RecordShipment::class,\r\n        UpdateInventory::class\r\n    ]);\r\n\r\n正如你在上面的示例中看到的，链式任务数组可能是任务类名称的数组。 但是，你也可以提供一组实际的任务实例。 这样做时，Laravel 将确保任务实例属于同一类，并且与你的应用程序调度的链式任务具有相同的属性值：\r\n\r\n    Bus::assertChained([\r\n        new ShipOrder,\r\n        new RecordShipment,\r\n        new UpdateInventory,\r\n    ]);\r\n\r\n你可以使用 `assertDispatchedWithoutChain` 方法来断言一个任务是在没有任务链的情况下被推送的：\r\n\r\n    Bus::assertDispatchedWithoutChain(ShipOrder::class);\r\n\r\n<a name=\"testing-job-batches\"></a>\r\n### 测试任务批处理\r\n\r\n`Bus` 门面的 `assertBatched` 方法可用于断言 [批处理任务](/docs/laravel/10.x/queuesmd#job-batching) 已分派。 给 `assertBatched` 方法的闭包接收一个 `Illuminate\\Bus\\PendingBatch` 的实例，它可用于检查批处理中的任务：\r\n\r\n    use Illuminate\\Bus\\PendingBatch;\r\n    use Illuminate\\Support\\Facades\\Bus;\r\n\r\n    Bus::fake();\r\n\r\n    // ...\r\n\r\n    Bus::assertBatched(function (PendingBatch $batch) {\r\n        return $batch->name == 'import-csv' &&\r\n               $batch->jobs->count() === 10;\r\n    });\r\n\r\n<a name=\"testing-job-batch-interaction\"></a>\r\n#### 测试任务 / 批处理交互\r\n\r\n此外，你可能偶尔需要测试单个任务与其基础批处理的交互。 例如，你可能需要测试任务是否取消了对其批次的进一步处理。 为此，你需要通过 `withFakeBatch` 方法为任务分配一个假批次。 `withFakeBatch` 方法返回一个包含任务实例和假批次的元组：\r\n\r\n    [$job, $batch] = (new ShipOrder)->withFakeBatch();\r\n\r\n    $job->handle();\r\n\r\n    $this->assertTrue($batch->cancelled());\r\n    $this->assertEmpty($batch->added);\r\n\r\n<a name=\"job-events\"></a>\r\n## 任务事件\r\n\r\n使用 `Queue` [facade](/docs/laravel/10.x/facades) 上的 `before` 和 `after` 方法，你可以指定要在处理排队任务之前或之后执行的回调。 这些回调是为仪表板执行额外日志记录或增量统计的绝佳机会。 通常，你应该从 [服务提供者](/docs/laravel/10.x/providers) 的 `boot` 方法中调用这些方法。 例如，我们可以使用 Laravel 自带的 `AppServiceProvider`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Illuminate\\Queue\\Events\\JobProcessed;\r\n    use Illuminate\\Queue\\Events\\JobProcessing;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务。\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Queue::before(function (JobProcessing $event) {\r\n                // $event->connectionName\r\n                // $event->job\r\n                // $event->job->payload()\r\n            });\r\n\r\n            Queue::after(function (JobProcessed $event) {\r\n                // $event->connectionName\r\n                // $event->job\r\n                // $event->job->payload()\r\n            });\r\n        }\r\n    }\r\n\r\n通过使用 `Queue` [facade](/docs/laravel/10.x/facades) 的 `looping` 方法 ，你可以在 worker 尝试从队列获取任务之前执行指定的回调。例如，你可以注册一个闭包，用以回滚之前失败任务打开的任何事务：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\Support\\Facades\\Queue;\r\n\r\n    Queue::looping(function () {\r\n        while (DB::transactionLevel() > 0) {\r\n            DB::rollBack();\r\n        }\r\n    });\r\n\r\n","p":"docs/queues.html"},{"t":"rate-limiting (限流)","d":"\n# 限流\r\n\r\n- [简介](#introduction)\r\n    - [缓存配置](#cache-configuration)\r\n- [基础用法](#basic-usage)\r\n    - [手动增加请求次数](#manually-incrementing-attempts)\r\n    - [清除请求](#clearing-attempts)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 包含了一个开箱即用的，基于 [缓存](cache) 实现的限流器，提供了一个简单的方法来限制指定时间内的任何操作。\r\n\r\n> **技巧**\r\n> 了解更多关于如何限制 HTTP 请求，请参考 [请求频率限制中间件](routing#rate-limiting)。\r\n\r\n<a name=\"cache-configuration\"></a>\r\n### 缓存配置\r\n\r\n通常情况下，限流器使用你默认的缓存驱动，由 `cache` 配置文件中的 `default` 键定义。你也可以通过在你的应用程序的 `cache` 配置文件中定义一个 `limiter` 来指定限流器应该使用哪一个缓存来驱动：\r\n\r\n    'default' => 'memcached',\r\n\r\n    'limiter' => 'redis',\r\n\r\n<a name=\"basic-usage\"></a>\r\n## 基本用法\r\n\r\n可以通过 `Illuminate\\Support\\Facades\\RateLimiter` 来操作限流器。限流器提供的最简单的方法是 `attempt` 方法，它将一个给定的回调函数执行次数限制在一个给定的秒数内。\r\n\r\n当回调函数执行次数超过限制时， `attempt` 方法返回 `false` ；否则， `attempt` 方法将返回回调的结果或 `true` 。 `attempt` 方法接受的第一个参数是一个速率限制器 「key」 ，它可以是你选择的任何字符串，代表被限制速率的动作：\r\n\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    $executed = RateLimiter::attempt(\r\n        'send-message:'.$user->id,\r\n        $perMinute = 5,\r\n        function() {\r\n            // 发送消息...\r\n        }\r\n    );\r\n\r\n    if (! $executed) {\r\n      return 'Too many messages sent!';\r\n    }\r\n\r\n\n\n<a name=\"manually-incrementing-attempts\"></a>\r\n### 手动配置尝试次数\r\n\r\n如果您想手动与限流器交互，可以使用多种方法。例如，您可以调用 `tooManyAttempts` 方法来确定给定的限流器是否超过了每分钟允许的最大尝试次数：\r\n\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {\r\n        return 'Too many attempts!';\r\n    }\r\n\r\n或者，您可以使用 `remaining` 方法检索给定密钥的剩余尝试次数。如果给定的密钥还有重试次数，您可以调用 `hit` 方法来增加总尝试次数：\r\n\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    if (RateLimiter::remaining('send-message:'.$user->id, $perMinute = 5)) {\r\n        RateLimiter::hit('send-message:'.$user->id);\r\n\r\n        // 发送消息...\r\n    }\r\n\r\n<a name=\"determining-limiter-availability\"></a>\r\n#### 确定限流器可用性\r\n\r\n当一个键没有更多的尝试次数时，`availableIn` 方法返回在尝试可用之前需等待的剩余秒数：\r\n\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {\r\n        $seconds = RateLimiter::availableIn('send-message:'.$user->id);\r\n\r\n        return 'You may try again in '.$seconds.' seconds.';\r\n    }\r\n\r\n<a name=\"clearing-attempts\"></a>\r\n### 清除尝试次数\r\n\r\n您可以使用 `clear` 方法重置给定速率限制键的尝试次数。例如，当接收者读取给定消息时，您可以重置尝试次数：\r\n\r\n    use App\\Models\\Message;\r\n    use Illuminate\\Support\\Facades\\RateLimiter;\r\n\r\n    /**\r\n     * 标记消息为已读。\r\n     */\r\n    public function read(Message $message): Message\r\n    {\r\n        $message->markAsRead();\r\n\r\n        RateLimiter::clear('send-message:'.$message->user_id);\r\n\r\n        return $message;\r\n    }\r\n\n","p":"docs/rate-limiting.html"},{"t":"scheduling (任务调度)","d":"# 任务调度\r\n\r\n- [简介](#introduction)\r\n- [定义调度](#defining-schedules)\r\n    - [Artisan 命令调度](#scheduling-artisan-commands)\r\n    - [队列任务调度](#scheduling-queued-jobs)\r\n    - [Shell 命令调度](#scheduling-shell-commands)\r\n    - [调度频率设置](#schedule-frequency-options)\r\n    - [时区](#timezones)\r\n    - [避免任务重复](#preventing-task-overlaps)\r\n    - [单机任务调度](#running-tasks-on-one-server)\r\n    - [后台任务](#background-tasks)\r\n    - [维护模式](#maintenance-mode)\r\n- [运行调度程序](#running-the-scheduler)\r\n    - [本地运行调度程序](#running-the-scheduler-locally)\r\n- [任务输出](#task-output)\r\n- [任务钩子](#task-hooks)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n过去，你可能需要在服务器上为每一个调度任务去创建 Cron 条目。因为这些任务的调度不是通过代码控制的，你要查看或新增任务调度都需要通过 SSH 远程登录到服务器上去操作，所以这种方式很快会让人变得痛苦不堪。\r\n\r\nLaravel 的命令行调度器允许你在 Laravel 中清晰明了地定义命令调度。在使用这个任务调度器时，你只需要在你的服务器上创建单个 Cron 入口。你的任务调度在 `app/Console/Kernel.php` 的 `schedule` 方法中进行定义。为了帮助你更好的入门，这个方法中有个简单的例子。\r\n\r\n<a name=\"defining-schedules\"></a>\r\n## 定义调度\r\n\r\n你可以在 `App\\Console\\Kernel` 类的 `schedule` 方法中定义所有的调度任务。在开始之前，我们来看一个例子：我们计划每天午夜执行一个闭包，这个闭包会执行一次数据库语句去清空一张表：\r\n\r\n    <?php\r\n\r\n    namespace App\\Console;\r\n\r\n    use Illuminate\\Console\\Scheduling\\Schedule;\r\n    use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    class Kernel extends ConsoleKernel\r\n    {\r\n        /**\r\n         * 定义应用中的命令调度\r\n         */\r\n        protected function schedule(Schedule $schedule): void\r\n        {\r\n            $schedule->call(function () {\r\n                DB::table('recent_users')->delete();\r\n            })->daily();\r\n        }\r\n    }\r\n\r\n除了调用闭包这种方式来调度外，你还可以调用 [可调用对象](https://secure.php.net/manual/en/language.oop5.magic.php#object.invoke)。 可调用对象是简单的 PHP 类，包含一个 `__invoke` 方法：\r\n\r\n    $schedule->call(new DeleteRecentUsers)->daily();\r\n\r\n如果你想查看任务计划的概述及其下次计划运行时间，你可以使用 `schedule:list` Artisan 命令：\r\n\r\n```bash\r\nphp artisan schedule:list\r\n```\r\n\r\n<a name=\"scheduling-artisan-commands\"></a>\r\n### Artisan 命令调度\r\n\r\n调度方式不仅有调用闭包，还有调用 [Artisan commands](/docs/laravel/10.x/artisan) 和操作系统命令。例如，你可以给 command 方法传递命令名称或类来调度一个 `Artisan` 命令：\r\n\r\n当使用命令类名调度 `Artisan` 命令时，你可以通过一个数组传递附加的命令行参数，且这些参数需要在命令触发时提供：\r\n\r\n    use App\\Console\\Commands\\SendEmailsCommand;\r\n\r\n    $schedule->command('emails:send Taylor --force')->daily();\r\n\r\n    $schedule->command(SendEmailsCommand::class, ['Taylor', '--force'])->daily();\r\n\r\n<a name=\"scheduling-queued-jobs\"></a>\r\n### 队列任务调度\r\n\r\n`job` 方法可以用来调度 [queued job](/docs/laravel/10.x/queues)。此方法提供了一种快捷方式来调度任务，而无需使用 `call` 方法创建闭包来调度任务：\r\n\r\n    use App\\Jobs\\Heartbeat;\r\n\r\n    $schedule->job(new Heartbeat)->everyFiveMinutes();\r\n\r\n`job` 方法提供了可选的第二，三参数，分别指定任务将被放置的队列名称及连接：\r\n\r\n    use App\\Jobs\\Heartbeat;\r\n\r\n    // 分发任务到「heartbeats」队列及「sqs」连接...\r\n    $schedule->job(new Heartbeat, 'heartbeats', 'sqs')->everyFiveMinutes();\r\n\r\n\r\n<a name=\"scheduling-shell-commands\"></a>\r\n### Shell 命令调度\r\n\r\n`exec` 方法可发送命令到操作系统：\r\n\r\n    $schedule->exec('node /home/forge/script.js')->daily();\r\n\r\n<a name=\"schedule-frequency-options\"></a>\r\n### 调度频率选项\r\n\r\n我们已经看到了几个如何设置任务在指定时间间隔运行的例子。不仅如此，你还有更多的任务调度频率可选：\r\n\r\n方法  | 描述\r\n------------- | -------------\r\n`->cron('* * * * *');`  |  按自定义 cron 计划运行任务\r\n`->everySecond();`  |  每秒运行一次任务\r\n`->everyTwoSeconds();`  |  每两秒运行一次任务\r\n`->everyFiveSeconds();`  |  每五秒运行一次任务\r\n`->everyTenSeconds();`  |  每十秒运行一次任务\r\n`->everyFifteenSeconds();`  |  每 15 秒运行一次任务\r\n`->everyTwentySeconds();`  |  每 20 秒运行一次任务\r\n`->everyThirtySeconds();`  |  每 30 秒运行一次任务\r\n`->everyMinute();`  |  每分钟运行一次任务\r\n`->everyTwoMinutes();`  |  每两分钟运行一次任务\r\n`->everyThreeMinutes();`  |  每三分钟运行一次任务\r\n`->everyFourMinutes();`  |  每四分钟运行一次任务\r\n`->everyFiveMinutes();`  |  每五分钟运行一次任务\r\n`->everyTenMinutes();`  |  每十分钟运行一次任务\r\n`->everyFifteenMinutes();`  |  每 15 分钟运行一次任务\r\n`->everyThirtyMinutes();`  |  每 30 分钟运行一次任务\r\n`->hourly();`  |  每小时运行一次任务\r\n`->hourlyAt(17);`  |  每小时第十七分钟时执行一次任务\r\n`->everyOddHour($minutes = 0);`  |  每奇数小时运行一次任务\r\n`->everyTwoHours($minutes = 0);`  |  每两小时运行一次任务\r\n`->everyThreeHours($minutes = 0);`  |  每三小时运行一次任务\r\n`->everyFourHours($minutes = 0);`  |  每四小时运行一次任务\r\n`->everySixHours($minutes = 0);`  |  每六小时运行一次任务\r\n`->daily();`  |  每天 00:00 执行一次任务\r\n`->dailyAt('13:00');`  |  每天 13：00 运行任务\r\n`->twiceDaily(1, 13);`  |  每天在 1：00 和 13：00 运行任务\r\n`->twiceDailyAt(1, 13, 15);`  |  每天在 1：15 和 13：15 运行任务\r\n`->weekly();`  |  每周日00：00运行任务\r\n`->weeklyOn(1, '8:00');`  |  每周一 8：00 运行任务\r\n`->monthly();`  |  每月第一天 00：00 运行任务\r\n`->monthlyOn(4, '15:00');`  |  每月第四天 15：00 运行任务\r\n`->twiceMonthly(1, 16, '13:00');`  |  每月第一天和第十六天的 13：00 运行任务\r\n`->lastDayOfMonth('15:00');`  |  每月的最后一天 15：00 运行任务\r\n`->quarterly();`  |  每个季度的第一天 00：00 运行任务\r\n`->quarterlyOn(4, '14:00');`  |  每季度 4 日 14：00 运行任务\r\n`->yearly();`  |  每年的第一天 00：00 运行任务\r\n`->yearlyOn(6, 1, '17:00');`  |  每年1月17日00：<>运行任务\r\n`->timezone('America/New_York');`  |  设置任务的时区\r\n\r\n这些方法与额外的约束条件相结合后，可用于创建在一周的特定时间运行甚至更精细的计划任务。例如，在每周一执行命令：\r\n\r\n    // 在每周一 13:00 执行...\r\n    $schedule->call(function () {\r\n        // ...\r\n    })->weekly()->mondays()->at('13:00');\r\n\r\n    // 在每个工作日 8:00 到 17:00 之间的每小时周期执行...\r\n    $schedule->command('foo')\r\n              ->weekdays()\r\n              ->hourly()\r\n              ->timezone('America/Chicago')\r\n              ->between('8:00', '17:00');\r\n\r\n下方列出了额外的约束条件：\r\n\r\n<div class=\"overflow-auto\">\r\n\r\n方法  | 描述\r\n:------------- | :-------------\r\n`->weekdays();`  |  限制任务在工作日执行\r\n`->weekends();`  |  限制任务在周末执行\r\n`->sundays();`  |  限制任务在周日执行\r\n`->mondays();`  |  限制任务在周一执行\r\n`->tuesdays();`  |  限制任务在周二执行\r\n`->wednesdays();`  |  限制任务在周三执行\r\n`->thursdays();`  |  限制任务在周四执行\r\n`->fridays();`  |  限制任务在周五执行\r\n`->saturdays();`  |  限制任务在周六执行\r\n`->days(array\\|mixed);`  |  限制任务在每周的指定日期执行\r\n`->between($startTime, $endTime);`  |  限制任务在 `$startTime` 和 `$endTime` 区间执行\r\n`->unlessBetween($startTime, $endTime);`  |  限制任务不在 `$startTime` 和 `$endTime` 区间执行\r\n`->when(Closure);`  |  限制任务在闭包返回为真时执行\r\n`->environments($env);`  |  限制任务在特定环境中执行\r\n\r\n</div>\r\n\r\n<a name=\"day-constraints\"></a>\r\n#### 周几（Day）限制\r\n\r\n`days` 方法可以用于限制任务在每周的指定日期执行。举个例子，你可以在让一个命令每周日和每周三每小时执行一次：\r\n\r\n    $schedule->command('emails:send')\r\n                    ->hourly()\r\n                    ->days([0, 3]);\r\n\r\n不仅如此，你还可以使用 `Illuminate\\Console\\Scheduling\\Schedule` 类中的常量来设置任务在指定日期运行：\r\n\r\n    use Illuminate\\Console\\Scheduling\\Schedule;\r\n\r\n    $schedule->command('emails:send')\r\n                    ->hourly()\r\n                    ->days([Schedule::SUNDAY, Schedule::WEDNESDAY]);\r\n\r\n<a name=\"between-time-constraints\"></a>\r\n#### 时间范围限制\r\n\r\n`between` 方法可用于限制任务在一天中的某个时间段执行：\r\n\r\n    $schedule->command('emails:send')\r\n                        ->hourly()\r\n                        ->between('7:00', '22:00');\r\n\r\n同样， `unlessBetween` 方法也可用于限制任务不在一天中的某个时间段执行：\r\n\r\n    $schedule->command('emails:send')\r\n                        ->hourly()\r\n                        ->unlessBetween('23:00', '4:00');\r\n\r\n<a name=\"truth-test-constraints\"></a>\r\n#### 真值检测限制\r\n\r\n`when` 方法可根据闭包返回结果来执行任务。换言之，若给定的闭包返回 `true`，若无其他限制条件阻止，任务就会一直执行：\r\n\r\n    $schedule->command('emails:send')->daily()->when(function () {\r\n        return true;\r\n    });\r\n\r\n`skip` 可看作是 `when` 的逆方法。若 `skip` 方法返回 `true`，任务将不会执行：\r\n\r\n    $schedule->command('emails:send')->daily()->skip(function () {\r\n        return true;\r\n    });\r\n\r\n当链式调用 `when` 方法时，仅当所有 `when` 都返回 `true` 时，任务才会执行。\r\n\r\n<a name=\"environment-constraints\"></a>\r\n#### 环境限制\r\n\r\n`environments` 方法可限制任务在指定环境中执行（由 `APP_ENV` [环境变量](/docs/laravel/10.x/configurationmd#environment-configuration) 定义）：\r\n\r\n    $schedule->command('emails:send')\r\n                ->daily()\r\n                ->environments(['staging', 'production']);\r\n\r\n<a name=\"timezones\"></a>\r\n### 时区\r\n\r\n`timezone` 方法可指定在某一时区的时间执行计划任务：\r\n\r\n    $schedule->command('report:generate')\r\n             ->timezone('America/New_York')\r\n             ->at('2:00')\r\n\r\n若想给所有计划任务分配相同的时区，那么需要在 `app/Console/Kernel.php` 类中定义 `scheduleTimezone` 方法。该方法会返回一个默认时区，最终分配给所有计划任务：\r\n\r\n    use DateTimeZone;\r\n\r\n    /**\r\n     * 获取计划事件默认使用的时区\r\n     */\r\n    protected function scheduleTimezone(): DateTimeZone|string|null\r\n    {\r\n        return 'America/Chicago';\r\n    }\r\n\r\n> **注意**\r\n> 请记住，有些时区会使用夏令时。当夏令时发生调整时，你的任务可能会执行两次，甚至根本不会执行。因此，我们建议尽可能避免使用时区来安排计划任务。\r\n\r\n<a name=\"preventing-task-overlaps\"></a>\r\n### 避免任务重复\r\n\r\n默认情况下，即使之前的任务实例还在执行，调度内的任务也会执行。为避免这种情况的发生，你可以使用 `withoutOverlapping` 方法：\r\n\r\n    $schedule->command('emails:send')->withoutOverlapping();\r\n\r\n在此例中，若 `emails:send` [Artisan 命令](/docs/laravel/10.x/artisan) 还未运行，那它将会每分钟执行一次。如果你的任务执行时间非常不确定，导致你无法准确预测任务的执行时间，那 `withoutOverlapping` 方法会特别有用。\r\n\r\n如有需要，你可以在 `withoutOverlapping` 锁过期之前，指定它的过期分钟数。默认情况下，这个锁会在 24 小时后过期：\r\n\r\n    $schedule->command('emails:send')->withoutOverlapping(10);\r\n\r\n上面这种场景中，`withoutOverlapping` 方法使用应用程序的 [缓存](/docs/laravel/10.x/cache) 获取锁。如有必要，可以使用`schedule:clear cache` Artisan命令清除这些缓存锁。这通常只有在任务由于意外的服务器问题而卡住时才需要。\r\n\r\n<a name=\"running-tasks-on-one-server\"></a>\r\n### 任务只运行在一台服务器上\r\n\r\n> **注意**\r\n> 要使用此功能，你的应用程序必须使用 `database`, `memcached`, `dynamodb`, 或 `redis` 缓存驱动程序作为应用程序的默认缓存驱动程序。此外，所有服务器必须和同一个中央缓存服务器通信。\r\n\r\n如果你的应用运行在多台服务器上，可能需要限制调度任务只在某台服务器上运行。 例如，假设你有一个每个星期五晚上生成新报告的调度任务，如果任务调度器运行在三台服务器上，调度任务会在三台服务器上运行并且生成三次报告，不够优雅！\r\n\r\n要指示任务应仅在一台服务器上运行，请在定义计划任务时使用 `onOneServer` 方法。第一台获取到该任务的服务器会给任务上一把原子锁以阻止其他服务器同时运行该任务:\r\n\r\n    $schedule->command('report:generate')\r\n                    ->fridays()\r\n                    ->at('17:00')\r\n                    ->onOneServer();\r\n\r\n<a name=\"naming-unique-jobs\"></a>\r\n#### 命名单服务器作业\r\n\r\n有时，你可能需要使用不同的参数调度相同的作业，同时使其仍然在单个服务器上运行作业。为此，你可以使用 `name` 方法为每个作业定义一个唯一的名字：\r\n\r\n```php\r\n$schedule->job(new CheckUptime('https://laravel.com'))\r\n            ->name('check_uptime:laravel.com')\r\n            ->everyFiveMinutes()\r\n            ->onOneServer();\r\n\r\n$schedule->job(new CheckUptime('https://vapor.laravel.com'))\r\n            ->name('check_uptime:vapor.laravel.com')\r\n            ->everyFiveMinutes()\r\n            ->onOneServer();\r\n```\r\n\r\n如果你使用闭包来定义单服务器作业，则必须为他们定义一个名字\r\n\r\n```php\r\n$schedule->call(fn () => User::resetApiRequestCount())\r\n    ->name('reset-api-request-count')\r\n    ->daily()\r\n    ->onOneServer();\r\n```\r\n\r\n<a name=\"background-tasks\"></a>\r\n### 后台任务\r\n\r\n默认情况下，同时运行多个任务将根据它们在 `schedule` 方法中定义的顺序执行。如果你有一些长时间运行的任务，将会导致后续任务比预期时间更晚启动。 如果你想在后台运行任务，以便它们可以同时运行，则可以使用 `runInBackground` 方法:\r\n\r\n    $schedule->command('analytics:report')\r\n             ->daily()\r\n             ->runInBackground();\r\n\r\n> **注意**\r\n> `runInBackground` 方法只有在通过 `command` 和 `exec` 方法调度任务时才可以使用\r\n\r\n<a name=\"maintenance-mode\"></a>\r\n### 维护模式\r\n\r\n当应用处于 [维护模式](/docs/laravel/10.x/configurationmd#maintenance-mode) 时，Laravel 的队列任务将不会运行。因为我们不想调度任务干扰到服务器上可能还未完成的维护项目。不过，如果你想强制任务在维护模式下运行，你可以使用 `evenInMaintenanceMode` 方法：\r\n\r\n    $schedule->command('emails:send')->evenInMaintenanceMode();\r\n\r\n<a name=\"running-the-scheduler\"></a>\r\n## 运行调度程序\r\n\r\n现在，我们已经学会了如何定义计划任务，接下来让我们讨论如何真正在服务器上运行它们。`schedule:run` Artisan 命令将评估你的所有计划任务，并根据服务器的当前时间决定它们是否运行。\r\n\r\n因此，当使用 Laravel 的调度程序时，我们只需要向服务器添加一个 cron 配置项，该项每分钟运行一次 `schedule:run` 命令。如果你不知道如何向服务器添加 cron 配置项，请考虑使用 [Laravel Forge](https://forge.laravel.com) 之类的服务来为你管理 cron 配置项：\r\n\r\n```shell\r\n* * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1\r\n```\r\n\r\n<a name=\"running-the-scheduler-locally\"></a>\r\n### 本地运行调度程序\r\n\r\n通常，你不会直接将 cron 配置项添加到本地开发计算机。你反而可以使用 `schedule:work` Artisan 命令。该命令将在前台运行，并每分钟调用一次调度程序，直到你终止该命令为止：\r\n\r\n```shell\r\nphp artisan schedule:work\r\n```\r\n\r\n<a name=\"task-output\"></a>\r\n## 任务输出\r\n\r\nLaravel 调度器提供了一些简便方法来处理调度任务生成的输出。首先，你可以使用 `sendOutputTo` 方法将输出发送到文件中以便后续检查：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->sendOutputTo($filePath);\r\n\r\n如果希望将输出追加到指定文件，可使用 `appendOutputTo` 方法：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->appendOutputTo($filePath);\r\n\r\n使用 `emailOutputTo` 方法，你可以将输出发送到指定邮箱。在发送邮件之前，你需要先配置 Laravel 的 [邮件服务](/docs/laravel/10.x/mail):\r\n\r\n    $schedule->command('report:generate')\r\n             ->daily()\r\n             ->sendOutputTo($filePath)\r\n             ->emailOutputTo('taylor@example.com');\r\n\r\n如果你只想在命令执行失败时将输出发送到邮箱，可使用 `emailOutputOnFailure` 方法：\r\n\r\n    $schedule->command('report:generate')\r\n             ->daily()\r\n             ->emailOutputOnFailure('taylor@example.com');\r\n\r\n> **注意**\r\n> `emailOutputTo`, `emailOutputOnFailure`, `sendOutputTo` 和 `appendOutputTo` 是 `command` 和 `exec` 独有的方法。\r\n\r\n<a name=\"task-hooks\"></a>\r\n## 任务钩子\r\n\r\n使用 `before` 和 `after` 方法，你可以决定在调度任务执行前或者执行后来运行代码：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->before(function () {\r\n                 // 任务即将执行。。。\r\n             })\r\n             ->after(function () {\r\n                 // 任务已经执行。。。\r\n             });\r\n\r\n\r\n\r\n使用 `onSuccess` 和 `onFailure` 方法，你可以决定在调度任务成功或者失败运行代码。失败表示 Artisan 或系统命令以非零退出码终止：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->onSuccess(function () {\r\n                 // 任务执行成功。。。\r\n             })\r\n             ->onFailure(function () {\r\n                 // 任务执行失败。。。\r\n             });\r\n\r\n如果你的命令有输出，你可以使用`after`, `onSuccess` 或 `onFailure`钩子并传入类型为`Illuminate\\Support\\Stringable`的`$output`参数的闭包来访问任务输出：\r\n\r\n    use Illuminate\\Support\\Stringable;\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->onSuccess(function (Stringable $output) {\r\n                 // The task succeeded...\r\n             })\r\n             ->onFailure(function (Stringable $output) {\r\n                 // The task failed...\r\n             });\r\n\r\n<a name=\"pinging-urls\"></a>\r\n#### Pinging 网址\r\n\r\n使用 `pingBefore` 和 `thenPing` 方法，你可以在任务完成之前或完成之后来 ping 指定的 URL。当前方法在通知外部服务，如 [Envoyer](https://envoyer.io)，计划任务在将要执行或已完成时会很有用：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->pingBefore($url)\r\n             ->thenPing($url);\r\n\r\n只有当条件为 `true` 时，才可以使用 `pingBeforeIf` 和 `thenPingIf` 方法来 ping 指定 URL ：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->pingBeforeIf($condition, $url)\r\n             ->thenPingIf($condition, $url);\r\n\r\n当任务成功或失败时，可使用 `pingOnSuccess` 和 `pingOnFailure` 方法来 ping 给定 URL。失败表示 Artisan 或系统命令以非零退出码终止：\r\n\r\n    $schedule->command('emails:send')\r\n             ->daily()\r\n             ->pingOnSuccess($successUrl)\r\n             ->pingOnFailure($failureUrl);\r\n\r\n\r\n\r\n所有 ping 方法都依赖 Guzzle HTTP 库。通常，Guzzle 已在所有新的 Laravel 项目中默认安装，不过，若意外将 Guzzle 删除，则可以使用 Composer 包管理器将 Guzzle 手动安装到项目中：\r\n\r\n```shell\r\ncomposer require guzzlehttp/guzzle\r\n```\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\n如果需要，你可以监听调度程序调度的 [事件](/docs/laravel/10.x/events)。通常，事件侦听器映射将在你的应用程序的 `App\\Providers\\EventServiceProvider` 类中定义：\r\n\r\n    /**\r\n     * 应用的事件监听器映射\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Console\\Events\\ScheduledTaskStarting' => [\r\n            'App\\Listeners\\LogScheduledTaskStarting',\r\n        ],\r\n\r\n        'Illuminate\\Console\\Events\\ScheduledTaskFinished' => [\r\n            'App\\Listeners\\LogScheduledTaskFinished',\r\n        ],\r\n\r\n        'Illuminate\\Console\\Events\\ScheduledBackgroundTaskFinished' => [\r\n            'App\\Listeners\\LogScheduledBackgroundTaskFinished',\r\n        ],\r\n\r\n        'Illuminate\\Console\\Events\\ScheduledTaskSkipped' => [\r\n            'App\\Listeners\\LogScheduledTaskSkipped',\r\n        ],\r\n\r\n        'Illuminate\\Console\\Events\\ScheduledTaskFailed' => [\r\n            'App\\Listeners\\LogScheduledTaskFailed',\r\n        ],\r\n    ];\r\n\r\n","p":"docs/scheduling.html"},{"t":"authentication (用户认证)","d":"\n# 用户认证\r\n\r\n- [介绍](#introduction)\r\n    - [入门套件](#starter-kits)\r\n    - [数据库注意事项](#introduction-database-considerations)\r\n    - [生态系统概述](#ecosystem-overview)\r\n- [快速开始用户认证](#authentication-quickstart)\r\n    - [安装入门套件](#install-a-starter-kit)\r\n    - [获取已认证的用户信息](#retrieving-the-authenticated-user)\r\n    - [路由保护](#protecting-routes)\r\n    - [登录限流](#login-throttling)\r\n- [手动认证用户](#authenticating-users)\r\n    - [记住密码](#remembering-users)\r\n    - [其他认证方法](#other-authentication-methods)\r\n- [HTTP Basic 认证](#http-basic-authentication)\r\n    - [无状态 HTTP Basic 认证](#stateless-http-basic-authentication)\r\n- [注销](#logging-out)\r\n    - [使其他设备上的会话无效](#invalidating-sessions-on-other-devices)\r\n- [密码确认](#password-confirmation)\r\n    - [配置](#password-confirmation-configuration)\r\n    - [路由](#password-confirmation-routing)\r\n    - [路由保护](#password-confirmation-protecting-routes)\r\n- [添加自定义看守器](#adding-custom-guards)\r\n    - [闭包请求看守器](#closure-request-guards)\r\n- [添加自定义用户提供器](#adding-custom-user-providers)\r\n    - [用户提供器契约](#the-user-provider-contract)\r\n    - [用户认证契约](#the-authenticatable-contract)\r\n- [社会化用户认证](/docs/laravel/10.x/socialite)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n许多 Web 应用程序为其用户提供了一种通过应用程序进行身份验证和「登录」的方法。在 Web 应用程序中实现此功能可能是一项复杂且具有潜在风险的工作。因此，Laravel 致力于为你提供所需的工具，以快速、安全、轻松地实现身份验证。\r\n\r\nLaravel 的身份验证工具的核心是由「看守器」和「提供器」组成的。 看守器定义如何对每个请求的用户进行身份验证。例如，Laravel 附带了一个 `session` 守卫，它使用 session 和 cookie 来维护状态。\r\n\r\n提供器定义如何从持久存储中检索用户。 Laravel 支持使用 [Eloquent](/docs/laravel/10.x/eloquent) 和数据库查询构建器检索用户。不仅如此，你甚至可以根据应用程序的需要自由定制其他提供程序。\r\n\r\n\n\n应用程序的身份验证配置文件位于 `config/auth.php`. 这个文件包含几个记载了的选项，用于调整 Laravel 身份验证服务的行为。\r\n\r\n> **注意**  \r\n> 看守器和提供器不应与「角色」和「权限」混淆。要了解有关通过权限授权用户操作的更多信息，请参阅 [用户授权](/docs/laravel/10.x/authorization) 文档。\r\n\r\n<a name=\"starter-kits\"></a>\r\n### 入门套件\r\n\r\n想要快速入门？在新的 Laravel 应用程序中安装 [Laravel 入门套件](/docs/laravel/10.x/starter-kits)。迁移数据库后，将浏览器导航到 `/register` 或分配给应用程序的任何其他 URL。这个入门套件将负责构建你的整个身份验证系统！\r\n\r\n**即使你在最终的 Laravel 应用程序中选择不使用入门套件，安装 [Laravel Breeze](/docs/laravel/10.x/starter-kits#laravel-breeze) 入门套件也是学习如何在实际的 Laravel 项目中实现所有 Laravel 身份验证功能的绝佳机会。** 由于 Laravel Breeze 为你创建身份验证控制器、路由和视图，因此你可以查看这些文件中的源码，进而了解如何实现 Laravel 的身份验证功能。\r\n\r\n<a name=\"introduction-database-considerations\"></a>\r\n### 数据库注意事项\r\n\r\n默认情况下，Laravel 在 `app/Models` 目录中包含一个 `App\\Models\\User` [Eloquent 模型](/docs/laravel/10.x/eloquent)。 此模型可与默认的 Eloquent 身份验证驱动程序一起使用。如果你的应用程序未使用 Eloquent，则可以使用 Laravel 查询构建器的 `database`  身份验证提供程序。\r\n\r\n为 `App\\Models\\User` 模型构建数据库架构时，请确保密码列的长度至少为 60 个字符。当然，新的 Laravel 应用程序中包含的 `users` 表迁移文件已经创建了一个超过此长度的列。\r\n\r\n\n\n此外，你应该验证你的 `users` (或等效) 表是否包含一个可为空的字符串 `remember_token` 列，该列包含 100 个字符。 此列将用于为在登录到应用程序时选择「记住我」选项的用户存储令牌。同样，新的 Laravel 应用程序中包含的默认 `users`  表迁移文件已经包含此列。\r\n\r\n<a name=\"ecosystem-overview\"></a>\r\n### 生态系统概述\r\n\r\nLaravel 提供了几个与身份验证相关的包。在继续之前，我们将回顾 Laravel 中的通用身份验证生态系统，并讨论每个包的预期用途。\r\n\r\n首先，考虑身份验证是如何工作的。使用 web 浏览器时，用户将通过登录表单提供他们的用户名和密码。如果这些凭据正确，应用程序将在用户的 [session](/docs/laravel/10.x/session)中存储有关已通过身份验证的用户的信息。发给浏览器的 cookie 包含 session ID，以便应用程序的后续请求可以将用户与正确的 session 相关联。在接收到 session 的 cookie 之后，应用程序将基于 session ID 检索 session 数据，注意认证信息已经存储在 session 中，并且将用户视为「已认证」。\r\n\r\n当远程服务需要通过身份验证才能访问 API 时，我们通常不用 cookie 进行身份验证，因为没有 web 浏览器。相反，远程服务会在每个请求时向 API 发送一个 token。应用程序可以对照有效 API 令牌表来验证传入 token ，并「验证」与该 API 令牌相关联的用户正在执行的请求。\r\n\r\n\n\n<a name=\"laravels-built-in-browser-authentication-services\"></a>\r\n#### Laravel 内置的浏览器认证服务\r\n\r\nLaravel 包括内置的身份验证和 session 服务，这些服务通常通过 `Auth` 和 `Session` facade 使用。 这些特性为从 web 浏览器发起的请求提供基于 cookie 的身份验证。它们提供的方法允许你验证用户的凭据并对用户进行身份验证。此外，这些服务会自动将正确的身份验证数据存储在用户的 session 中，并发布用户的会话 cookie 。本文档中包含对如何使用这些服务的讨论。\r\n\r\n**应用入门套件**\r\n\r\n如本文档中所述，你可以手动与这些身份验证服务进行交互，以构建应用程序自己的身份验证层。不过，为了帮助你更快地入门，我们发布了 [免费软件包](/docs/laravel/10.x/starter-kits)，为整个身份验证层提供强大的现代化脚手架。这些软件包分别是 [Laravel Breeze](/docs/laravel/10.x/starter-kits#laravel-breeze)，[Laravel Jetstream](/docs/laravel/10.x/starter-kits#laravel-jetstream)，和 [Laravel Fortify](/docs/laravel/10.x/fortify)。\r\n\r\n_Laravel Breeze_ 是 Laravel 所有身份验证功能的简单、最小实现，包括登录、注册、密码重置、电子邮件验证和密码确认。 Laravel Breeze 的视图层由简单的 [Blade 模板](/docs/laravel/10.x/blade) 组成，样式为 [Tailwind CSS](https://tailwindcss.com)。要开始使用，请查看 Laravel 的 [应用入门套件](/docs/laravel/10.x/starter-kits) 文档。\r\n\r\n_Laravel Fortify_ 是 Laravel 的无 header 身份验证后端，它实现了本文档中的许多功能，包括基于 cookie 的身份验证以及其他功能，如双因素身份验证和电子邮件验证。Fortify 为 Laravel Jetstream 提供身份验证后端，或者可以单独与 [Laravel Sanctum](/docs/laravel/10.x/sanctum) 结合使用，为需要使用 Laravel 进行身份验证的 SPA 提供身份验证。\r\n\r\n\n\n_[Laravel Jetstream](https://jetstream.laravel.com)_ 是一个强大的应用入门套件，它使用 [Tailwind CSS](https://tailwindcss.com)，[Livewire](https://laravel-livewire.com) 和 / 或 [Inertia](https://inertiajs.com) 提供美观的现代 UI，同时集成和扩展了 Laravel Fortify 的认证服务。Laravel Jetstream 提供了双因素身份验证、团队支持、浏览器 session 管理、个人资料管理等功能，并内置了 [Laravel Sanctum](/docs/laravel/10.x/sanctum) 的集成以支持 API 令牌身份验证。接下来我们将讨论 Laravel 的 API 身份验证产品。\r\n\r\n<a name=\"laravels-api-authentication-services\"></a>\r\n#### Laravel 的 API 认证服务\r\n\r\nLaravel 提供了两个可选的包来帮助你管理 API 令牌和验证使用 API 令牌发出的请求：[Passport](/docs/laravel/10.x/passport) 和 [Sanctum](/docs/laravel/10.x/sanctum)。请注意，这些库和 Laravel 内置的基于 Cookie 的身份验证库并不是互斥的。这些库主要关注 API 令牌身份验证，而内置的身份验证服务则关注基于 Cookie 的浏览器身份验证。许多应用程序将同时使用 Laravel 内置的基于 Cookie 的身份验证服务和一个 Laravel 的 API 身份验证包。\r\n\r\n**Passport**\r\n\r\nPassport 是一个 OAuth2 身份验证提供程序，提供各种 OAuth2 「授权类型」，允许你发布各种类型的令牌。总的来说，这是一个强大而复杂的 API 身份验证包。但是，大多数应用程序不需要 OAuth2 规范提供的复杂特性，这可能会让用户和开发人员感到困惑。此外，开发人员一直对如何使用 Passport 等 OAuth2 身份验证提供程序对 SPA 应用程序或移动应用程序进行身份验证感到困惑。\r\n\r\n**Sanctum**\r\n\r\n为了应对 OAuth2 的复杂性和开发人员的困惑，我们着手构建一个更简单、更精简的身份验证包，旨在处理通过令牌进行的第一方 Web 请求和 API 请求。 [Laravel Sanctum](/docs/laravel/10.x/sanctum) 发布后，这一目标就实现了。对于除 API 外还提供第一方 web UI 的应用程序，或由单页应用程序（SPA）提供支持的应用程序，或是提供移动客户端的应用程序，Sanctum 是首选推荐的身份验证包。\r\n\r\n\n\nLaravel Sanctum 是一个混合了 web 和 API 的身份验证包，它让我们管理应用程序的整个身份验证过程成为可能，因为当基于 Sanctum 的应用程序收到请求时，Sanctum 将首先确定请求是否包含引用已验证 session 的 session cookie。Sanctum 通过调用我们前面讨论过的 Laravel 的内置身份验证服务来实现这一点。如果请求没有通过 session cookie 进行身份验证，Sanctum 将检查请求中的 API 令牌。如果存在 API 令牌，则 Sanctum 将使用该令牌对请求进行身份验证。要了解有关此过程的更多信息，请参阅 Sanctum 的 [工作原理](/docs/laravel/10.x/sanctum#how-it-works) 文档。\r\n\r\nLaravel Sanctum 是我们选择与 [Laravel Jetstream](https://jetstream.laravel.com) 应用程序入门套件一起使用的 API 包，因为我们认为它最适合大多数 web 应用程序的身份验证需求。\r\n\r\n<a name=\"summary-choosing-your-stack\"></a>\r\n#### 汇总 & 选择你的解决方案\r\n\r\n总之，如果你的应用程序将使用浏览器访问，并且你正在构建一个单页面的 Laravel 应用程序，那么你的应用程序可以使用 Laravel 的内置身份验证服务。\r\n\r\n接下来，如果你的应用程序提供将由第三方使用的 API ，你可以在 [Passport](/docs/laravel/10.x/passport) 或 [Sanctum](/docs/laravel/10.x/sanctum) 之间进行选择，为你的应用程序提供 API 令牌身份验证。一般来说，尽可能选择 Sanctum，因为它是 API 认证、SPA 认证和移动认证的简单、完整的解决方案，包括对「scopes」或「abilities」的支持。\r\n\r\n如果你正在构建一个将由 Laravel 后端支持的单页面应用程序（SPA），那么应该使用 [Laravel Sanctum](/docs/laravel/10.x/sanctum)。在使用 Sanctum 时，你需要 [手动实现自己的后端验证路由](#authenticating-users) 或使用 [Laravel Fortify](/docs/laravel/10.x/fortify) 作为无 header 身份验证后端服务，为注册、密码重置、电子邮件验证等功能提供路由和控制器。\r\n\r\n\n\n当应用程序确定必须使用 OAuth2 规范提供的所有特性时，可以选择 Passport。\r\n\r\n而且，如果你想快速入门，我们很高兴推荐 [Laravel Breeze](/docs/laravel/10.x/starter-kits#laravel-breeze) 作为启动新 Laravel 应用程序的快速方法，该应用程序已经使用了我们首选的 Laravel 内置身份验证服务和 Laravel Sanctum 身份验证技术栈。\r\n\r\n<a name=\"authentication-quickstart\"></a>\r\n## 身份验证快速入门\r\n\r\n> **警告**  \r\n> 文档的这一部分讨论了通过 [Laravel 应用入门套件](/docs/laravel/10.x/starter-kits) 对用户进行身份验证，其中包括可帮助你快速入门的 UI 脚手架。如果你想直接与 Laravel 的身份验证系统集成，请查看 [手动验证用户](#authenticating-users) 上的文档。\r\n\r\n<a name=\"install-a-starter-kit\"></a>\r\n### 安装入门套件\r\n\r\n首先，你应该 [安装 Laravel 应用入门套件](/docs/laravel/10.x/starter-kits)。我们当前的入门套件 Laravel Breeze 和 Laravel Jetstream 提供了设计精美的起点，可将身份验证纳入你的全新 Laravel 应用程序。\r\n\r\nLaravel Breeze 是 Laravel 所有身份验证功能的最简单的实现，包括登录、注册、密码重置、电子邮件验证和密码确认。 Laravel Breeze 的视图层由简单的 [Blade templates](/docs/laravel/10.x/blade) 和 [Tailwind CSS](https://tailwindcss.com) 组成。Breeze 还使用 Vue 或 React 提供了基于 [Inertia](https://inertiajs.com) 的脚手架选项。\r\n\r\n[Laravel Jetstream](https://jetstream.laravel.com) 是一个更强大的应用入门套件，它支持使用 [Livewire](https://laravel-livewire.com) 或 [Inertia and Vue](https://inertiajs.com) 来构建你的应用程序。 此外，Jetstream 还提供可选的双因素身份验证支持、团队、配置文件管理、浏览器 session 管理、通过 [Laravel Sanctum](/docs/laravel/10.x/sanctum) 的 API 支持、帐户删除等。\r\n\r\n\n\n<a name=\"retrieving-the-authenticated-user\"></a>\r\n### 获取已认证的用户信息\r\n\r\n在安装身份验证入门套件并允许用户注册应用程序并对其进行身份验证之后，你通常需要与当前通过身份验证的用户进行交互。在处理传入请求时，你可以通过 `Auth` facade 的 `user` 方法访问通过身份验证的用户：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    // 获取当前的认证用户信息...\r\n    $user = Auth::user();\r\n\r\n    // 获取当前的认证用户ID...\r\n    $id = Auth::id();\r\n\r\n或者，一旦用户通过身份验证，你就可以通过 `Illuminate\\Http\\Request` 实例访问通过身份验证的用户。请记住，使用类型提示的类将自动注入到控制器方法中。通过对 `Illuminate\\Http\\Request` 对象进行类型提示，你可以通过 Request 的 `user` 方法从应用程序中的任何控制器方法方便地访问通过身份验证的用户：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class FlightController extends Controller\r\n    {\r\n        /**\r\n         * 更新现有航班的航班信息。\r\n         */\r\n        public function update(Request $request): RedirectResponse\r\n        {\r\n            $user = $request->user();\r\n\r\n            // ...\r\n\r\n            return redirect('/flights');\r\n        }\r\n    }\r\n\r\n<a name=\"determining-if-the-current-user-is-authenticated\"></a>\r\n#### 确定当前用户是否已通过身份验证\r\n\r\n要确定发出传入 HTTP 请求的用户是否通过身份验证，你可以在 `Auth` facade 上使用 `check` 方法。如果用户通过身份验证，此方法将返回 `true` ：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    if (Auth::check()) {\r\n        // 该用户已登录...\r\n    }\r\n\r\n> **注意**  \r\n> 尽管可以使用 `check` 方法确定用户是否已通过身份验证，但在允许用户访问某些路由 / 控制器之前，你通常会使用中间件验证用户是否已通过身份验证。要了解更多信息，请查看有关 [路由保护](/docs/laravel/10.x/authentication#protecting-routes) 的文档。\r\n\r\n\n\n<a name=\"protecting-routes\"></a>\r\n### 路由保护\r\n\r\n[路由中间件](/docs/laravel/10.x/middleware) 可用于仅允许通过身份验证的用户访问给定路由。Laravel 附带了一个 `auth` 中间件，它引用了 `Illuminate\\Auth\\Middleware\\Authenticate` 类。由于此中间件已在应用程序的 HTTP 内核中注册，因此你只需将中间件附加到路由定义即可：\r\n\r\n    Route::get('/flights', function () {\r\n        // 只有经过身份验证的用户才能访问此路由...\r\n    })->middleware('auth');\r\n\r\n<a name=\"redirecting-unauthenticated-users\"></a>\r\n#### 给未认证的用户设置重定向\r\n\r\n当 `auth` 中间件检测到未经身份验证的用户时，它将用户重定向到 `login` [命名路由](/docs/laravel/10.x/routing#named-routes)。你可以通过更新应用程序的 `app/Http/Middleware/Authenticate.php` 文件中的 `redirectTo` 方法来修改此行为：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    /**\r\n     * 获取用户应重定向到的路径。\r\n     */\r\n    protected function redirectTo(Request $request): string\r\n    {\r\n        return route('login');\r\n    }\r\n\r\n<a name=\"specifying-a-guard\"></a>\r\n#### 指定看守器\r\n\r\n将 `auth` 中间件附加到路由时，你还可以指定应该使用哪个「guard」来验证用户。指定的 guard 应与 `auth.php` 配置文件的 `guards` 数组中的一个键相对应：\r\n\r\n    Route::get('/flights', function () {\r\n        // 只有经过身份验证的用户才能访问此路由...\r\n    })->middleware('auth:admin');\r\n\r\n<a name=\"login-throttling\"></a>\r\n### 登录限流\r\n\r\n如果你使用的是 Laravel Breeze 或 Laravel Jetstream [入门套件](/docs/laravel/10.x/starter-kits)，那么在尝试登录的时候将自动应用速率限制。默认情况下，如果用户在多次尝试后未能提供正确的凭据，他们将在一分钟内无法登录。该限制对与用户的用户名 / 电子邮件地址及其 IP 地址是唯一的。\r\n\r\n> **注意**  \r\n> 如果你想对应用程序中的其他路由进行速率限制，请查看 [速率限制](/docs/laravel/10.x/routing#rate-limiting) 文档。\r\n\r\n\n\n<a name=\"authenticating-users\"></a>\r\n## 手动验证用户\r\n\r\n你并非一定要使用 Laravel 的 [应用入门套件](/docs/laravel/10.x/starter-kits) 附带的身份验证脚手架。如果你选择不使用这个脚手架，则需要直接使用 Laravel 身份验证类来管理用户身份验证。别担心，这也很容易！\r\n\r\n我们将通过 `Auth` [facade](/docs/laravel/10.x/facades) 访问 Laravel 的身份验证服务，因此我们需要确保在类的顶部导入 `Auth` facade 。接下来，让我们看看 `attempt` 方法。 `attempt` 方法通常用于处理来自应用程序「登录」表单的身份验证尝试。如果身份验证成功，你应该重新生成用户的 [session](/docs/laravel/10.x/session) 以防止 [session fixation](https://en.wikipedia.org/wiki/Session_fixation):\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    class LoginController extends Controller\r\n    {\r\n        /**\r\n         * 处理身份验证尝试。\r\n         */\r\n        public function authenticate(Request $request): RedirectResponse\r\n        {\r\n            $credentials = $request->validate([\r\n                'email' => ['required', 'email'],\r\n                'password' => ['required'],\r\n            ]);\r\n\r\n            if (Auth::attempt($credentials)) {\r\n                $request->session()->regenerate();\r\n\r\n                return redirect()->intended('dashboard');\r\n            }\r\n\r\n            return back()->withErrors([\r\n                'email' => 'The provided credentials do not match our records.',\r\n            ])->onlyInput('email');\r\n        }\r\n    }\r\n\r\n`attempt` 方法接受一个键 / 值对数组作为它的第一个参数。数组中的值将用于在数据库表中查找用户。因此，在上面的示例中，将通过 `email` 列的值检索用户。如果找到用户，则数据库中存储的 hash 密码将与通过数组传递给该方法的 `password` 值进行比较。你不应该对传入请求的 `password` 值进行 hash 处理，因为框架会在将该值与数据库中的 hash 密码进行比较之前自动对该值进行 hash 处理。如果两个 hash 密码匹配，将为用户启动一个通过身份验证的 session。\r\n\r\n\n\n请记住，Laravel 的身份验证服务将根据身份验证 guard 的「provider」配置，从数据库检索用户。在默认的 `config/auth.php`  配置文件中，指定了 Eloquent 为用户提供程序，并指示它在检索用户时使用 `App\\Models\\User` 模型。你可以根据应用程序的需要在配置文件中更改这些值。\r\n\r\n如果身份验证成功，`attempt` 方法将返回 `true` 。否则，将返回 `false`。\r\n\r\nLaravel 的重定向器提供的 `intended` 方法会将用户重定向到他们在被身份验证中间件拦截之前尝试访问的 URL。如果预期的目的地不可用，可以为该方法提供回退 URI。\r\n\r\n<a name=\"specifying-additional-conditions\"></a>\r\n#### 指定附加条件\r\n\r\n如果你愿意，除了用户的电子邮件和密码之外，你还可以向身份验证查询中添加额外的查询条件。为了实现这一点，我们可以简单地将查询条件添加到传递给 `attempt` 方法的数组中。例如，我们可以验证用户是否标记为「active」：\r\n\r\n    if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {\r\n        // 认证成功...\r\n    }\r\n\r\n对于复杂的查询条件，你可以在凭证数组中提供闭包。此闭包将与查询实例一起调用，允许你根据应用程序的需要自定义查询：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    if (Auth::attempt([\r\n        'email' => $email, \r\n        'password' => $password, \r\n        fn (Builder $query) => $query->has('activeSubscription'),\r\n    ])) {\r\n        // 认证成功...\r\n    }\r\n\r\n> **警告**  \r\n> 在这些例子中，`email` 不是必需的选项，它只是作为一个例子。你应该使用与数据库表中的「用户名」对应的任何列名。\r\n\r\n\n\n`attemptWhen` 方法接收一个闭包作为其第二个参数，可用于在实际验证用户之前对潜在用户执行更广泛的检查。闭包接收潜在用户并应返回 `true` 或 `false` 以指示用户是否可以通过身份验证：\r\n\r\n    if (Auth::attemptWhen([\r\n        'email' => $email,\r\n        'password' => $password,\r\n    ], function (User $user) {\r\n        return $user->isNotBanned();\r\n    })) {\r\n        // 认证成功...\r\n    }\r\n\r\n<a name=\"accessing-specific-guard-instances\"></a>\r\n#### 访问特定的看守器实例\r\n\r\n通过 `Auth` facade 的 `guard` 方法，你可以指定在对用户进行身份验证时要使用哪个 guard 实例。这允许你使用完全不同的可验证模型或用户表来管理应用程序的不同部分的验证。\r\n\r\n传递给 `guard` 方法的 guard 名称应该对应于 `auth.php` 配置文件中 guards 的其中一个：\r\n\r\n    if (Auth::guard('admin')->attempt($credentials)) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"remembering-users\"></a>\r\n### 记住用户\r\n\r\n许多 web 应用程序在其登录表单上提供了「记住我」复选框。如果你希望在应用程序中提供「记住我」功能，你可以将布尔值作为第二个参数传递给 `attempt` 方法。\r\n\r\n当此值为 `true` 时，Laravel 将无限期地保持用户身份验证，或者直到用户手动注销。 你的 `users` 表必须包含字符串 `remember_token` 列，该列将用于存储「记住我」标记。新的 Laravel 应用程序中包含的 `users` 表迁移文件已经包含此列：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {\r\n        // 正在为该用户执行记住我操作...\r\n    }\r\n\r\n\n\n如果你的应用程序提供「记住我」的功能，你可以使用 `viaRemember` 方法来确定当前通过身份验证的用户是否使用「记住我」cookie 进行了身份验证：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    if (Auth::viaRemember()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"other-authentication-methods\"></a>\r\n### 其他身份验证方法\r\n\r\n<a name=\"authenticate-a-user-instance\"></a>\r\n#### 验证用户实例\r\n\r\n如果你需要将现有用户实例设置为当前通过身份验证的用户，你可以将该用户实例传递给 `Auth` facade 的 `login` 方法。 给定的用户实例必须是 `Illuminate\\Contracts\\Auth\\Authenticatable` [契约](/docs/laravel/10.x/contracts) 的实现。 Laravel 中包含的 `App\\Models\\User` 模型已经实现了此接口。当你已经有一个有效的用户实例时（例如用户直接向你的应用程序注册之后），此身份验证方法非常有用：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    Auth::login($user);\r\n\r\n你可以将布尔值作为第二个参数传递给 `login` 方法。此值指示通过身份验证的 session 是否需要「记住我」功能。请记住，这意味着 session 将无限期地进行身份验证，或者直到用户手动注销应用程序为止：\r\n\r\n    Auth::login($user, $remember = true);\r\n\r\n如果需要，你可以在调用 `login` 方法之前指定身份验证看守器：\r\n\r\n    Auth::guard('admin')->login($user);\r\n\r\n<a name=\"authenticate-a-user-by-id\"></a>\r\n#### 通过 ID 对用户进行身份验证\r\n\r\n要使用数据库记录的主键对用户进行身份验证，你可以使用  `loginUsingId`  方法。此方法接受你要验证的用户的主键：\r\n\r\n    Auth::loginUsingId(1);\r\n\r\n你可以将布尔值作为第二个参数传递给 `loginUsingId` 方法。此值指示通过身份验证的 session 是否需要「记住我」功能。请记住，这意味着 session 将无限期地进行身份验证，或者直到用户手动注销应用程序为止：\r\n\r\n    Auth::loginUsingId(1, $remember = true);\r\n\r\n\n\n<a name=\"authenticate-a-user-once\"></a>\r\n#### 只验证一次\r\n\r\n你可以使用 `once` 方法通过应用程序对单个请求的用户进行身份验证。调用此方法时不会使用 session 或 cookie：\r\n\r\n    if (Auth::once($credentials)) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"http-basic-authentication\"></a>\r\n## HTTP Basic 用户认证\r\n\r\n[HTTP Basic 用户认证](https://en.wikipedia.org/wiki/Basic_access_authentication) 提供了一种无需设置专用「登录」页面即可对应用程序用户进行身份验证的快速方法。首先，将 `auth.basic` [中间件](/docs/laravel/10.x/middleware) 附加到路由。  `auth.basic` 中间件包含在 Laravel 框架中，因此你不需要定义它：\r\n\r\n    Route::get('/profile', function () {\r\n        // 只有经过身份验证的用户才能访问此路由...\r\n    })->middleware('auth.basic');\r\n\r\n将中间件附加到路由后，当你在浏览器中访问路由时，系统会自动提示你输入凭据。默认情况下 `auth.basic` 中间件将假定 `users` 数据库表中的 `email` 列是用户的「用户名」。\r\n\r\n<a name=\"a-note-on-fastcgi\"></a>\r\n#### 注意 FastCGI\r\n\r\n如果你使用的是 PHP FastCGI 和 Apache 来为 Laravel 应用程序提供服务，那么 HTTP Basic 身份验证可能无法正常工作。要纠正这些问题，可以将以下行添加到应用程序的 `.htaccess` 文件中：\r\n\r\n```apache\r\nRewriteCond %{HTTP:Authorization} ^(.+)$\r\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\r\n```\r\n\r\n<a name=\"stateless-http-basic-authentication\"></a>\r\n### 无状态 HTTP Basic 认证\r\n\r\n你也可以在 session 中不设置用户标识符 cookie 的情况下使用 HTTP Basic 身份验证。如果你选择使用 HTTP 身份验证来验证对应用程序 API 的请求，这将非常有用。为此，[定义一个中间件](/docs/laravel/10.x/middleware) 调用 `onceBasic` 方法。如果 `onceBasic` 方法没有返回响应，则请求可能会进一步传递到应用程序中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class AuthenticateOnceWithBasicAuth\r\n    {\r\n        /**\r\n         * 处理传入请求。\r\n         *\r\n         * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n         */\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            return Auth::onceBasic() ?: $next($request);\r\n        }\r\n\r\n    }\r\n\r\n\n\n然后，将中间件附加到路由中：\r\n\r\n    Route::get('/api/user', function () {\r\n        // 只有经过身份验证的用户才能访问此路由...\r\n    })->middleware(AuthenticateOnceWithBasicAuth::class);\r\n\r\n<a name=\"logging-out\"></a>\r\n## 退出登录\r\n\r\n要在应用程序中手动注销用户，可以使用 `Auth` facade 提供的 `logout` 方法。这将从用户的 session 中删除身份验证信息，以便后续请求不会得到身份验证。\r\n\r\n除了调用 `logout` 方法外，建议你将用户的 session 置为过期，并重新生成其 [CSRF token](/docs/laravel/10.x/csrf)。注销用户后，通常会将用户重定向到应用程序的根目录：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    /**\r\n     * 将用户退出应用程序。\r\n     */\r\n    public function logout(Request $request): RedirectResponse\r\n    {\r\n        Auth::logout();\r\n\r\n        $request->session()->invalidate();\r\n\r\n        $request->session()->regenerateToken();\r\n\r\n        return redirect('/');\r\n    }\r\n\r\n<a name=\"invalidating-sessions-on-other-devices\"></a>\r\n### 使其他设备上的 session 失效\r\n\r\nLaravel 还提供了这样一种机制，可以使在其他设备上处于活动状态的用户 session 无效和「注销」，而不会使其当前设备上的 session 失效。当用户正在更改或更新其密码，并且你希望在保持当前设备身份验证的同时使其他设备上的 session 无效时，通常会使用此功能。\r\n\r\n在开始之前，你应该确保 `Illuminate\\Session\\Middleware\\AuthenticateSession` 中间件已经包含在应该接收 session 身份验证的路由中。通常，你应该将此中间件放置在一个路由组定义中，以便它可以应用于大多数应用程序的路由。默认情况下， `AuthenticateSession` 中间件可以使用 `auth.session` 路由中间件别名，并附加到一个路由上，这个别名在你的应用程序的 HTTP 内核中定义：\r\n\r\n    Route::middleware(['auth', 'auth.session'])->group(function () {\r\n        Route::get('/', function () {\r\n            // ...\r\n        });\r\n    });\r\n\r\n\n\n然后，你可以使用 `Auth` facade 提供的 `logoutOtherDevices` 方法。此方法要求用户确认其当前密码，你的应用程序应通过输入表单接受该密码：\r\n\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    Auth::logoutOtherDevices($currentPassword);\r\n\r\n当调用 `logoutOtherDevices` 方法时，用户的其他 session 将完全失效，这意味着他们将从之前验证过的所有看守器中「注销」。\r\n\r\n<a name=\"password-confirmation\"></a>\r\n## 密码确认\r\n\r\n在构建应用程序时，你可能偶尔会要求用户在执行操作之前或在将用户重定向到应用程序的敏感区域之前确认其密码。Laravel 包含内置的中间件，使这个过程变得轻而易举。实现此功能你需要定义两个路由：一个路由显示请求用户确认其密码的视图，另一个路由确认密码有效并将用户重定向到其预期目的地。\r\n\r\n> **注意**  \r\n> 以下文档讨论了如何直接与 Laravel 的密码确认功能集成。然而，如果你想更快地开始使用，  [Laravel 应用入门套件](/docs/laravel/10.x/starter-kits) 包括对此功能的支持！\r\n\r\n<a name=\"password-confirmation-configuration\"></a>\r\n### 配置\r\n\r\n确认密码后，用户在三个小时内不会被要求再次确认密码。但是，你可以通过更改应用程序 `config/auth.php` 配置文件中的 `password_timeout` 配置值来配置重新提示用户输入密码之前的时长。\r\n\r\n\n\n<a name=\"password-confirmation-routing\"></a>\r\n### 路由\r\n\r\n<a name=\"the-password-confirmation-form\"></a>\r\n#### 密码确认表单\r\n\r\n首先，我们将定义一个路由以显示请求用户确认其密码的视图：\r\n\r\n    Route::get('/confirm-password', function () {\r\n        return view('auth.confirm-password');\r\n    })->middleware('auth')->name('password.confirm');\r\n\r\n如你所料，此路由返回的视图应该有一个包含 `password` 字段的表单。此外，可以随意在视图中包含说明用户正在进入应用程序的受保护区域并且必须确认其密码的文本。\r\n\r\n<a name=\"confirming-the-password\"></a>\r\n#### 确认密码\r\n\r\n接下来，我们将定义一个路由来处理来自「确认密码」视图的表单请求。此路由将负责验证密码并将用户重定向到其预期目的地：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Illuminate\\Support\\Facades\\Redirect;\r\n\r\n    Route::post('/confirm-password', function (Request $request) {\r\n        if (! Hash::check($request->password, $request->user()->password)) {\r\n            return back()->withErrors([\r\n                'password' => ['The provided password does not match our records.']\r\n            ]);\r\n        }\r\n\r\n        $request->session()->passwordConfirmed();\r\n\r\n        return redirect()->intended();\r\n    })->middleware(['auth', 'throttle:6,1']);\r\n\r\n在继续之前，让我们更详细地检查一下这条路由。首先，请求的 `password` 字段被确定为实际匹配经过身份验证的用户的密码。如果密码有效，我们需要通知 Laravel 的 session 用户已经确认了他们的密码。 `passwordConfirmed` 方法将在用户的 session 中设置一个时间戳，Laravel 可以使用它来确定用户上次确认密码的时间。最后，我们可以将用户重定向到他们想要的目的地。\r\n\r\n\n\n<a name=\"password-confirmation-protecting-routes\"></a>\r\n### 保护路由\r\n\r\n你应该确保为执行需要最近确认密码的操作的路由被分配到 `password.confirm` 中间件。此中间件包含在 Laravel 的默认安装中，并且会自动将用户的预期目的地存储在 session 中，以便用户在确认密码后可以重定向到该位置。在 session 中存储用户的预期目的地之后，中间件将用户重定向到 `password.confirm` 的 [命名路由](/docs/laravel/10.x/routing#named-routes)：\r\n\r\n    Route::get('/settings', function () {\r\n        // ...\r\n    })->middleware(['password.confirm']);\r\n\r\n    Route::post('/settings', function () {\r\n        // ...\r\n    })->middleware(['password.confirm']);\r\n\r\n<a name=\"adding-custom-guards\"></a>\r\n## 添加自定义的看守器\r\n\r\n你可以使用 `Auth` facade 上的 `extend` 方法定义你自己的身份验证看守器。你应该在 [服务提供者](/docs/laravel/10.x/providers) 中调用 `extend` 方法。 由于 Laravel 已经附带了 `AuthServiceProvider`，因此我们可以将代码放置在该提供者中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Services\\Auth\\JwtGuard;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n    use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    class AuthServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用程序验证 / 授权服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Auth::extend('jwt', function (Application $app, string $name, array $config) {\r\n                // 返回 Illuminate\\Contracts\\Auth\\Guard 的实例...\r\n\r\n                return new JwtGuard(Auth::createUserProvider($config['provider']));\r\n            });\r\n        }\r\n    }\r\n\r\n正如你在上面的示例中所看到的，传递给 `extend` 方法的回调应该返回 `Illuminate\\Contracts\\Auth\\Guard` 的实例。此接口包含一些方法，你需要实现这些方法来定义自定义看守器。定义自定义看守器后，你可以在 `auth.php` 配置文件的 `guards` 配置中引用该看守器：\r\n\r\n    'guards' => [\r\n        'api' => [\r\n            'driver' => 'jwt',\r\n            'provider' => 'users',\r\n        ],\r\n    ],\r\n\r\n\n\n<a name=\"closure-request-guards\"></a>\r\n### 闭包请求看守器\r\n\r\n实现基于 HTTP 请求的自定义身份验证系统的最简单方法是使用 `Auth::viaRequest` 方法。此方法允许你使用单个闭包快速定义身份验证过程。\r\n\r\n首先，请在 `AuthServiceProvider` 的 `boot` 方法中调用 `Auth::viaRequest` 方法。 `VIASRequest` 方法接受身份验证驱动程序名称作为其第一个参数。此名称可以是描述你的自定义看守器的任何字符串。传递给方法的第二个参数应该是一个闭包，该闭包接收传入的 HTTP 请求并返回用户实例，或者，如果身份验证失败返回 `null`:\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    /**\r\n     * 注册任意应用程序验证 / 授权服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Auth::viaRequest('custom-token', function (Request $request) {\r\n            return User::where('token', $request->token)->first();\r\n        });\r\n    }\r\n\r\n定义自定义身份验证驱动程序后，你可以将其配置为 `auth.php` 配置文件的 `guards` 配置中的驱动程序：\r\n\r\n    'guards' => [\r\n        'api' => [\r\n            'driver' => 'custom-token',\r\n        ],\r\n    ],\r\n\r\n最后，你可以在将身份验证中间件分配给路由时引用该看守器：\r\n\r\n    Route::middleware('auth:api')->group(function () {\r\n        // ...\r\n    }\r\n\r\n<a name=\"adding-custom-user-providers\"></a>\r\n## 添加自定义的用户提供器\r\n\r\n如果你不使用传统的关系型数据库来存储用户，你将需要使用你自己的身份验证用户提供器来扩展 Laravel。 我们将在 `Auth` facade 上的 `provider` 方法来定义自定义用户提供器。用户提供器解析器应返回 `Illuminate\\Contracts\\Auth\\UserProvider` 的实例：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Extensions\\MongoUserProvider;\r\n    use Illuminate\\Contracts\\Foundation\\Application;\r\n    use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n\r\n    class AuthServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用程序验证 / 授权服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Auth::provider('mongo', function (Application $app, array $config) {\r\n                // 返回 illighte\\Contracts\\Auth\\UserProvider 的实例...\r\n\r\n                return new MongoUserProvider($app->make('mongo.connection'));\r\n            });\r\n        }\r\n    }\r\n\r\n\n\n使用 `provider` 方法注册提供器后，你可以在 `auth.php` 配置文件中切换到新的用户提供器。 首先，定义一个使用新驱动程序的 `provider` :\r\n\r\n    'providers' => [\r\n        'users' => [\r\n            'driver' => 'mongo',\r\n        ],\r\n    ],\r\n\r\n最后，你可以在 `guards` 配置中引用此提供器：\r\n\r\n    'guards' => [\r\n        'web' => [\r\n            'driver' => 'session',\r\n            'provider' => 'users',\r\n        ],\r\n    ],\r\n\r\n<a name=\"the-user-provider-contract\"></a>\r\n### 用户提供器契约\r\n\r\n`Illuminate\\Contracts\\Auth\\UserProvider` 实现负责从持久性存储系统（如 MySQL、MongoDB 等）中获取 `Illuminate\\Contracts\\Auth\\Authenticatable` 实现。这两个接口可以保障 Laravel 身份验证机制持续工作，无论用户数据是如何存储的，或者可以使用任意类型的类来表示经过身份验证的用户：\r\n\r\n让我们看一下 `Illuminate\\Contracts\\Auth\\UserProvider` 契约：\r\n\r\n    <?php\r\n\r\n    namespace Illuminate\\Contracts\\Auth;\r\n\r\n    interface UserProvider\r\n    {\r\n        public function retrieveById($identifier);\r\n        public function retrieveByToken($identifier, $token);\r\n        public function updateRememberToken(Authenticatable $user, $token);\r\n        public function retrieveByCredentials(array $credentials);\r\n        public function validateCredentials(Authenticatable $user, array $credentials);\r\n    }\r\n\r\n`retrieveById` 函数通常接收表示用户的主键，例如 MySQL 数据库中的自动递增 ID。方法应检索并返回与 ID 匹配的 `Authenticatable` 实现。\r\n\r\n`retrieveByToken` 函数通过用户唯一的 `$identifier` 和 「记住我」的 `$token` 检索用户，通常存储在数据库列中，如 `remember_token` 。与前面的方法一样，此方法应返回具有匹配令牌值的  `Authenticatable` 实现。\r\n\r\n`updateMemberToken` 方法使用新的 `$token` 更新 `$user` 实例的 `remember_token`。在成功的「记住我」身份验证尝试或用户注销时，会将新令牌分配给用户。\r\n\r\n\n\n当尝试对应用程序进行身份验证时， `retrieveByCredentials` 方法接收传递给 `Auth::attempt` 方法的凭据数组。然后，该方法应该「查询」底层的持久性存储以查找与这些凭据匹配的用户。通常，此方法将运行带有「where」条件的查询，以搜索「username」与 `$credentials['username']` 的值匹配的用户记录。该方法应返回 `Authenticatable` 的实现。 **此方法不应尝试执行任何密码验证或身份验证。**\r\n\r\n`validateCredentials` 方法应将给定的 `$user` 与 `$credentials` 进行比较，以对用户进行身份验证。例如，此方法通常会使用 `Hash::check` 方法将 `$user->getAuthPassword()` 的值与 `$credentials['password']` 的值进行比较。此方法应返回 `true` 或 `false`，指示密码是否有效。\r\n\r\n<a name=\"the-authenticatable-contract\"></a>\r\n### 用户认证契约\r\n\r\n现在我们已经探索了 `UserProvider` 上的每个方法，现在让我们看看 `Authenticatable` 契约。请记住，`UserProvider` 应该从 `retrieveById`、`retrieveByToken` 和 `retrieveByCredentials` 方法返回此接口的实现：\r\n\r\n    <?php\r\n\r\n    namespace Illuminate\\Contracts\\Auth;\r\n\r\n    interface Authenticatable\r\n    {\r\n        public function getAuthIdentifierName();\r\n        public function getAuthIdentifier();\r\n        public function getAuthPassword();\r\n        public function getRememberToken();\r\n        public function setRememberToken($value);\r\n        public function getRememberTokenName();\r\n    }\r\n\r\n这个接口很简单。`getAuthIdentifierName` 方法应返回用户的「主键」字段的名称， `getAuthIdentifier` 方法应返回用户的「主键」。当使用 MySQL 后端时，这可能是分配给用户记录的自动递增主键。`getAuthPassword` 方法应返回用户的 hash 密码。\r\n\r\n\n\n此接口允许身份验证系统与任何「用户」类一起工作，而不管你使用的是哪个 ORM 或存储抽象层。默认情况下，Laravel 在实现此接口的 `app/Models` 目录中包含一个 `App\\Models\\User` 类。\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\n在身份验证过程中，Laravel 调度各种 [事件](/docs/laravel/10.x/events) 。你可以在 `EventServiceProvider` 中将监听器附加到这些事件上：\r\n\r\n    /**\r\n     * 应用事件监听映射\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Illuminate\\Auth\\Events\\Registered' => [\r\n            'App\\Listeners\\LogRegisteredUser',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Attempting' => [\r\n            'App\\Listeners\\LogAuthenticationAttempt',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Authenticated' => [\r\n            'App\\Listeners\\LogAuthenticated',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Login' => [\r\n            'App\\Listeners\\LogSuccessfulLogin',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Failed' => [\r\n            'App\\Listeners\\LogFailedLogin',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Validated' => [\r\n            'App\\Listeners\\LogValidated',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Verified' => [\r\n            'App\\Listeners\\LogVerified',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Logout' => [\r\n            'App\\Listeners\\LogSuccessfulLogout',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\CurrentDeviceLogout' => [\r\n            'App\\Listeners\\LogCurrentDeviceLogout',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\OtherDeviceLogout' => [\r\n            'App\\Listeners\\LogOtherDeviceLogout',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\Lockout' => [\r\n            'App\\Listeners\\LogLockout',\r\n        ],\r\n\r\n        'Illuminate\\Auth\\Events\\PasswordReset' => [\r\n            'App\\Listeners\\LogPasswordReset',\r\n        ],\r\n    ];\r\n\n","p":"docs/authentication.html"},{"t":"authorization (用户授权)","d":"# 用户授权\r\n\r\n- [简介](#introduction)\r\n- [拦截器](#gates)\r\n    - [编写拦截器](#writing-gates)\r\n    - [授权动作](#authorizing-actions-via-gates)\r\n    - [拦截器响应](#gate-responses)\r\n    - [拦截器拦截检查](#intercepting-gate-checks)\r\n    - [内联授权](#inline-authorization)\r\n- [创建策略](#creating-policies)\r\n    - [生成策略](#generating-policies)\r\n    - [注册策略](#registering-policies)\r\n- [编辑策略](#writing-policies)\r\n    - [策略模型](#policy-methods)\r\n    - [策略返回](#policy-responses)\r\n    - [不使用模型的方法](#methods-without-models)\r\n    - [访客和用户](#guest-users)\r\n    - [策略的过滤器](#policy-filters)\r\n- [使用策略进行授权操作](#authorizing-actions-using-policies)\r\n    - [通过用户模型](#via-the-user-model)\r\n    - [通过控制器辅助函数](#via-controller-helpers)\r\n    - [通过中间件](#via-middleware)\r\n    - [通过 Blade 模板](#via-blade-templates)\r\n    - [以附加形式提供给上下文调用](#supplying-additional-context)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n除了提供内置的 [authentication](/docs/laravel/10.x/authentication)（身份验证）服务外，Laravel 还提供了一种可以很简单就进行使用的方法，来对用户与资源的授权关系进行管理。 它很安全，即使用户已经通过了「身份验证（authentication)」, 用户也可能无权对应用程序中重要的模型或数据库记录进行删除或更改。简单、条理化的系统性，是 Laravel 对授权管理的特性。\r\n\r\nLaravel 主要提供了两种授权操作的方法: [拦截器](#gates)和[策略](#creating-policies)。 可以把拦截器（gates）和策略（policies）想象成路由和控制器。拦截器（Gates）提供了一种轻便的基于闭包函数的授权方法，像是路由。而策略（policies)，就像是一个控制器，对特定模型或资源，进行分组管理的逻辑规则。 在本文档中，我们将首先探讨拦截器（gates），然后研究策略（policies)。\r\n\r\n你在构建应用程序时，不用为是仅仅使用拦截器（gates）或是仅仅使用策略（policies）而担心，并不需要在两者中进行唯一选择。大多数的应用程序都同时包含两个方法，并且同时使用两者，能够更好的进行工作。拦截器（gates），更适用于没有与任何模型或资源有关的授权操作，例如查看管理员仪表盘。与之相反，当你希望为特定的模型或资源进行授权管理时，应该使用策略（policies) 方法。\r\n\r\n\r\n\r\n<a name=\"gates\"></a>\r\n## 拦截器 (Gates)\r\n\r\n<a name=\"writing-gates\"></a>\r\n### 编写拦截器（Gates）\r\n\r\n> **注意**  \r\n> 通过理解拦截器（Gates），是一个很好的学习 Laravel 授权特性的基础知识的方法。同时，考虑到 Laravel 应用程序的健壮性，应该结合使用策略 [policies](#creating-policies) 来组织授权规则。\r\n\r\n拦截器（Gates）是用来确定用户是否有权执行给定操作的闭包函数。默认条件下，拦截器（Gates）的使用，是在`App\\Providers\\AuthServiceProvider`类中的 `boot` 函数里来规定`Gate`规则。拦截器（Gates）始终接收用户实例为其第一个参数，并且可以选择性的接收其他参数，例如相关的 Eloquent 模型。\r\n\r\n在下面的例子中，我们将定义一个拦截器（Gates)，并通过调用`App\\Models\\Post`类，来实现结合用户的 POST 请求，命中给定的规则。拦截器（Gates）将通过比较用户的`id`，和 POST 请求中的`user_id`来实现这个目标：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    /**\r\n     * 注册任何需要身份验证、授权服务的行为\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Gate::define('update-post', function (User $user, Post $post)\r\n\t\t{\r\n            return $user->id === $post->user_id;\r\n        });\r\n    }\r\n\r\n像是在控制器中操作一样，也可以直接使用类，进行回调数组，完成拦截器（Gates）的定义：\r\n\r\n    use App\\Policies\\PostPolicy;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    /**\r\n     * 注册任何需要身份验证、授权服务的行为\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Gate::define('update-post', [PostPolicy::class, 'update']);\r\n    }\r\n\r\n<a name=\"authorizing-actions-via-gates\"></a>\r\n### 授权动作\r\n\r\n如果需要通过拦截器（Gates）来对行为进行授权控制，你可以通过调用`Gate`中的`allows`或`denies`方法。请注意，在使用过程中，你不需要将已经通过身份验证的用户信息传递给这些方法。 Laravel 将会自动把用户信息传递给拦截器（Gates）。以下是一个典型的，在控制器中使用拦截器（Gates）进行行为授权控制的例子：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 更新给定的帖子\r\n         */\r\n        public function update(Request $request, Post $post): RedirectResponse\r\n        {\r\n            if (! Gate::allows('update-post', $post)) {\r\n                abort(403);\r\n            }\r\n\r\n            // 更新帖子...\r\n\r\n            return redirect('/posts');\r\n        }\r\n    }\r\n\r\n\r\n\r\n如果你需要判断某个用户，是否有权执行某个行为，你可以在`Gate`门面中，使用`forUser`方法：\r\n\r\n    if (Gate::forUser($user)->allows('update-post', $post)) {\r\n        // 这个用户可以提交update...\r\n    }\r\n\r\n    if (Gate::forUser($user)->denies('update-post', $post)) {\r\n        // 这个用户不可以提交update...\r\n    }\r\n\r\n你还可以通过`any`或`none`方法来一次性授权多个行为:\r\n\r\n    if (Gate::any(['update-post', 'delete-post'], $post)) {\r\n        // 用户可以提交update或delete...\r\n    }\r\n\r\n    if (Gate::none(['update-post', 'delete-post'], $post)) {\r\n        // 用户不可以提交update和delete...\r\n    }\r\n\r\n<a name=\"authorizing-or-throwing-exceptions\"></a>\r\n#### 未通过授权时的抛出异常\r\n\r\n`Illuminate\\Auth\\Access\\AuthorizationException`中准备了 HTTP 的 403 响应。你可以使用`Gate`门面中的`authorize`方法，来规定如果用户进行了未授权的行为时，触发`AuthorizationException`实例 ，该实例会自动转换返回为 HTTP 的 403 响应:\r\n\r\n    Gate::authorize('update-post', $post);\r\n\r\n    // 行为已获授权...\r\n\r\n<a name=\"gates-supplying-additional-context\"></a>\r\n#### 上下文的值传递\r\n\r\n能够用于拦截器（Gates）的授权方法，(`allows`，`denies`，`check`，`any`，`none`， `authorize`，`can`，`cannot`) 和在前端进行的授权方法 [Blade 指令](#via-blade-templates) (`@can`，`@cannot`，`@canany`) 在第 2 个参数中，可以接收数组。这些数组元素作为参数传递给拦截器（Gates），在做出授权决策时可用于其他上下文:\r\n\r\n    use App\\Models\\Category;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::define('create-post', function (User $user, Category $category, bool $pinned) {\r\n        if (! $user->canPublishToGroup($category->group)) {\r\n            return false;\r\n        } elseif ($pinned && ! $user->canPinPosts()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    });\r\n\r\n    if (Gate::check('create-post', [$category, $pinned])) {\r\n        // 用户可以请求create...\r\n    }\r\n\r\n\r\n\r\n<a name=\"gate-responses\"></a>\r\n### 拦截器响应\r\n\r\n到目前为止，我们只学习了拦截器（Gates）中返回布尔值的简单操作。但是，有时你需要的返回可能更复杂，比如错误消息。所以，你可以尝试使用`Illuminate\\Auth\\Access\\Response`来构建你的拦截器（Gates）：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Access\\Response;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::define('edit-settings', function (User $user) {\r\n        return $user->isAdmin\r\n                    ? Response::allow()\r\n                    : Response::deny('You must be an administrator.');\r\n    });\r\n\r\n你希望从拦截器（Gates）中返回响应时，使用`Gate::allows`方法，将仅返回一个简单的布尔值；同时，你还可以使用`Gate::inspect`方法来返回拦截器（Gates）中的所有响应值：\r\n\r\n    $response = Gate::inspect('edit-settings');\r\n\r\n    if ($response->allowed()) {\r\n        // 行为进行授权...\r\n    } else {\r\n        echo $response->message();\r\n    }\r\n\r\n在使用`Gate::authorize`方法时，如果操作未被授权，仍然会触发`AuthorizationException`, 用户验证（authorization）响应提供的错误消息，将传递给 HTTP 响应：\r\n\r\n    Gate::authorize('edit-settings');\r\n\r\n    // 行为进行授权...\r\n\r\n<a name=\"customising-gate-response-status\"></a>\r\n#### 自定义HTTP响应状态\r\n\r\n当一个操作通过 Gate 被拒绝时，返回一个`403`HTTP 响应；然而，有时返回一个可选的HTTP状态代码是有用的。你可以使用`Illuminate\\Auth\\Access\\Response`类上的`denyWithStatus`静态构造函数自定义授权检查失败返回的HTTP状态代码：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Access\\Response;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::define('edit-settings', function (User $user) {\r\n        return $user->isAdmin\r\n                    ? Response::allow()\r\n                    : Response::denyWithStatus(404);\r\n    });\r\n\r\n\r\n\r\n由于通过`404`响应隐藏资源是 Web 应用程序的常见模式，为了方便起见，提供了`denyAsNotFound`方法:\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Access\\Response;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::define('edit-settings', function (User $user) {\r\n        return $user->isAdmin\r\n                    ? Response::allow()\r\n                    : Response::denyAsNotFound();\r\n    });\r\n\r\n<a name=\"intercepting-gate-checks\"></a>\r\n### 拦截 Gate 检查\r\n\r\n有时，你可能希望将所有能力授予特定用户。你可以使用`before`方法定义一个闭包，在所有其他授权检查之前运行:\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::before(function (User $user, string $ability) {\r\n        if ($user->isAdministrator()) {\r\n            return true;\r\n        }\r\n    });\r\n\r\n如果`before`返回的是非 null 结果，则该返回将会被视为最终的检查结果。\r\n\r\n你还可以使用`after`方法，来定义在所有授权拦截规则执行后，再次进行授权拦截规则判定：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Gate::after(function (User $user, string $ability, bool|null $result, mixed $arguments) {\r\n        if ($user->isAdministrator()) {\r\n            return true;\r\n        }\r\n    });\r\n\r\n类似于`before`方法，如果`after`闭包返回非空结果，则该结果将被视为授权检查的结果。\r\n\r\n<a name=\"inline-authorization\"></a>\r\n### 内联授权\r\n\r\n有时，你可能希望确定当前经过身份验证的用户是否有权执行给定操作，而无需编写与该操作对应的专用拦截器。Laravel 允许你通过`Gate::allowIf`和`Gate::denyIf`方法执行这些类型的「内联」授权检查：\r\n\r\n```php\r\nuse App\\Models\\User;\r\nuse Illuminate\\Support\\Facades\\Gate;\r\n\r\nGate::allowIf(fn (User $user) => $user->isAdministrator());\r\n\r\nGate::denyIf(fn (User $user) => $user->banned());\r\n```\r\n\r\n\r\n\r\n如果该操作未授权或当前没有用户经过身份验证，Laravel 将自动抛出`Illuminate\\Auth\\Access\\AuthorizationException`异常。`AuthorizationException`的实例会被 Laravel 的异常处理程序自动转换为 403 HTTP 响应：\r\n\r\n<a name=\"creating-policies\"></a>\r\n## 生成策略\r\n\r\n<a name=\"generating-policies\"></a>\r\n### 注册策略\r\n\r\n策略是围绕特定模型或资源组织授权逻辑的类。例如，如果你的应用程序是博客，可能有一个`App\\Models\\Post`模型和一个相应的`App\\Policies\\PostPolicy`来授权用户操作，例如创建或更新帖子。\r\n\r\n你可以使用`make:policy`Artisan 命令生成策略。生成的策略将放置在`app/Policies`目录中。如果应用程序中不存在此目录，Laravel 将自动创建：\r\n\r\n```shell\r\nphp artisan make:policy PostPolicy\r\n```\r\n\r\n`make:policy`命令将生成一个空的策略类。如果要生成一个包含与查看、创建、更新和删除资源相关的示例策略方法的类，可以在执行命令时提供一个`--model`选项：\r\n\r\n```shell\r\nphp artisan make:policy PostPolicy --model=Post\r\n```\r\n\r\n<a name=\"registering-policies\"></a>\r\n### 注册策略\r\n\r\n创建了策略类之后，还需要对其进行注册。注册策略是告知 Laravel 在授权针对给定模型类型的操作时使用哪个策略。\r\n\r\n新的 Laravel 应用程序中包含的`App\\Providers\\AuthServiceProvider`包含一个`policies`属性，它将 Eloquent 模型映射到其相应的策略。 注册策略将指示 Laravel 在授权针对给定 Eloquent 模型的操作时使用哪个策略：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Policies\\PostPolicy;\r\n    use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    class AuthServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 应用程序的策略映射。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $policies = [\r\n            Post::class => PostPolicy::class,\r\n        ];\r\n\r\n        /**\r\n         * 注册任何应用程序身份验证/授权服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"policy-auto-discovery\"></a>\r\n#### 策略自动发现\r\n\r\n只要模型和策略遵循标准的 Laravel 命名约定，Laravel 就可以自动发现策略，而不是手动注册模型策略。具体来说，策略必须位于包含模型的目录或其上方的「Policies」目录中。 因此，例如，模型可以放置在`app/Models`目录中，而策略可以放置在`app/Policies`目录中。在这种情况下，Laravel 将检查`app/Models/Policies`然后`app/Policies`中的策略。此外，策略名称必须与模型名称匹配并具有「策略」后缀。 因此，`User`模型将对应于`UserPolicy`策略类。\r\n\r\n如果要自定义策略的发现逻辑，可以使用`Gate::guessPolicyNamesUsing`方法注册自定义策略发现回调。通常，应该从应用程序的`AuthServiceProvider`的`boot`方法调用此方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    Gate::guessPolicyNamesUsing(function (string $modelClass) {\r\n        // 返回给定模型的策略类的名称…\r\n    });\r\n\r\n> **注意**  \r\n> 在`AuthServiceProvider`中显式映射的任何策略将优先于任何可能自动发现的策略。\r\n\r\n<a name=\"writing-policies\"></a>\r\n## 编写策略\r\n\r\n<a name=\"policy-methods\"></a>\r\n### 策略方法\r\n\r\n注册策略类后，可以为其授权的每个操作添加方法。例如，让我们在`PostPolicy`上定义一个 `update`方法，该方法确定给定的`App\\Models\\User`是否可以更新给定的`App\\Models\\Post`实例。\r\n\r\n该`update`方法将接收一个`User`和一个`Post`实例作为其参数，并应返回`true`或`false`，指示用户是否有权更新给定的`Post`。因此，在本例中，我们将验证用户的`id`是否与 Post 上的`user_id`匹配：\r\n\r\n    <?php\r\n\r\n    namespace App\\Policies;\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    class PostPolicy\r\n    {\r\n        /**\r\n         * 确定用户是否可以更新给定的帖子\r\n         */\r\n        public function update(User $user, Post $post): bool\r\n        {\r\n            return $user->id === $post->user_id;\r\n        }\r\n    }\r\n\r\n\r\n\r\n你可以继续根据需要为策略授权的各种操作定义其他方法。例如，你可以定义`view`或`delete`方法来授权各种与`Post`相关的操作，但请记住，你可以自由地为策略方法命名任何你喜欢的名称。\r\n\r\n如果你在 Artisan 控制台生成策略时使用了`--model`选项，它将包含用于`viewAny`、`view`、 `create`、`update`、`delete`、`restore`和`forceDelete`操作。\r\n\r\n> **技巧**  \r\n> 所有策略都通过 Laravel [服务容器](/docs/laravel/10.x/container)解析，允许你在策略的构造函数中键入任何需要的依赖项，以自动注入它们。\r\n\r\n<a name=\"policy-responses\"></a>\r\n### 策略响应\r\n\r\n到目前为止，我们只检查了返回简单布尔值的策略方法。但是，有时你可能希望返回更详细的响应，包括错误消息。为此，你可以从你的策略方法返回一个`Illuminate\\Auth\\Access\\Response`实例：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Access\\Response;\r\n\r\n    /**\r\n     * 确定用户是否可以更新给定的帖子。\r\n     */\r\n    public function update(User $user, Post $post): Response\r\n    {\r\n        return $user->id === $post->user_id\r\n                    ? Response::allow()\r\n                    : Response::deny('你不拥有这个帖子。');\r\n    }\r\n\r\n当从你的策略返回授权响应时，`Gate::allows`方法仍将返回一个简单的布尔值；但是，你可以使用`Gate::inspect`方法来获取返回的完整授权响应：\r\n\r\n    use Illuminate\\Support\\Facades\\Gate;\r\n\r\n    $response = Gate::inspect('update', $post);\r\n\r\n    if ($response->allowed()) {\r\n        // 操作已被授权…\r\n    } else {\r\n        echo $response->message();\r\n    }\r\n\r\n\r\n\r\n当使用`Gate::authorize`方法时，如果操作未被授权，该方法会抛出`AuthorizationException`  ，授权响应提供的错误消息将传播到 HTTP 响应：\r\n\r\n    Gate::authorize('update', $post);\r\n\r\n    // 该操作已授权通过...\r\n\r\n<a name=\"customising-policy-response-status\"></a>\r\n#### 自定义HTTP响应状态\r\n\r\n当一个操作通过策略方法被拒绝时，返回一个`403`HTTP 响应;然而，有时返回一个可选的 HTTP 状态代码是有用的。你可以使用`Illuminate\\Auth\\Access\\Response`类上的`denyWithStatus`静态构造函数自定义授权检查失败返回的 HTTP 状态代码:\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Access\\Response;\r\n\r\n    /**\r\n     * 确定用户是否可以更新给定的帖子。\r\n     */\r\n    public function update(User $user, Post $post): Response\r\n    {\r\n        return $user->id === $post->user_id\r\n                    ? Response::allow()\r\n                    : Response::denyWithStatus(404);\r\n    }\r\n\r\n由于通过`404`响应隐藏资源是 Web 应用程序的常见模式，为了方便起见，提供了`denyAsNotFound`方法:\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Access\\Response;\r\n\r\n    /**\r\n     * 确定用户是否可以更新给定的帖子。\r\n     */\r\n    public function update(User $user, Post $post): Response\r\n    {\r\n        return $user->id === $post->user_id\r\n                    ? Response::allow()\r\n                    : Response::denyAsNotFound();\r\n    }\r\n\r\n<a name=\"methods-without-models\"></a>\r\n### 无需传递模型的方法\r\n\r\n一些策略方法只接收当前经过身份验证的用户实例，最常见的情况是给 `create` 方法做授权。例如，如果你正在创建一个博客，你可能希望确定一个用户是否被授权创建任何文章，在这种情况下，你的策略方法应该只期望接收一个用户实例：\r\n\r\n    /**\r\n     * 确定给定用户是否可以创建文件\r\n     */\r\n    public function create(User $user): bool\r\n    {\r\n        return $user->role == 'writer';\r\n    }\r\n\r\n\r\n\r\n<a name=\"guest-users\"></a>\r\n### Guest 用户\r\n\r\n默认情况下，如果传入的 HTTP 请求不是经过身份验证的用户发起的，那么所有的拦截器（gates）和策略（policies）会自动返回`false`。但是，你可以通过声明一个「optional」类型提示或为用户参数定义提供一个`null`默认值，从而允许这些授权检查通过你的拦截器（gates）和策略（policies）：\r\n\r\n    <?php\r\n\r\n    namespace App\\Policies;\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    class PostPolicy\r\n    {\r\n        /**\r\n         * 确定用户是否可以更新给定的文章\r\n         */\r\n        public function update(?User $user, Post $post): bool\r\n        {\r\n            return $user?->id === $post->user_id;\r\n        }\r\n    }\r\n\r\n<a name=\"policy-filters\"></a>\r\n### 策略过滤器\r\n\r\n对于某些用户，你可能希望给他授权给定策略中的所有操作。为了实现这一点，你可以在策略上定义一个`before`方法。该`before`方法将在策略上的所有方法之前执行，这样就使你有机会在实际调用预期的策略方法之前就已经授权了操作。该功能常用于授权应用程序管理员来执行任何操作：\r\n\r\n    use App\\Models\\User;\r\n\r\n    /**\r\n     * 执行预先授权检查\r\n     */\r\n    public function before(User $user, string $ability): bool|null\r\n    {\r\n        if ($user->isAdministrator()) {\r\n            return true;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n如果你想拒绝特定类型用户的所有授权检查，那么你可以从`before`方法返回`false`。如果返回`null`，则授权检查将通过策略方法进行。\r\n\r\n> **注意**  \r\n> 如果策略类中不包含名称与被检查能力的名称相匹配的方法，则不会调用策略类的`before`方法。\r\n\r\n\r\n\r\n<a name=\"authorizing-actions-using-policies\"></a>\r\n## 使用策略进行授权操作\r\n\r\n<a name=\"via-the-user-model\"></a>\r\n### 通过用户模型\r\n\r\nLaravel 应用程序中的`App\\Models\\User`型提供了两个用于授权操作的方法：`can`和`cannot`。`can`和`cannot`方法接收你希望授权的操作名称和相关模型。例如，让我们确定一个用户是否被授权更新给定的`App\\Models\\Post`模型，这通常在控制器方法中实现：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 更新给定的帖子。\r\n         */\r\n        public function update(Request $request, Post $post): RedirectResponse\r\n        {\r\n            if ($request->user()->cannot('update', $post)) {\r\n                abort(403);\r\n            }\r\n\r\n            // 更新帖子...\r\n\r\n            return redirect('/posts');\r\n        }\r\n    }\r\n\r\n如果为给定模型[注册了策略](#registering-policies)，该`can`方法将自动调用适当的策略并返回布尔值；如果没有为模型注册策略，该`can`方法将尝试调用基于 Gate 的闭包，该闭包将匹配给定的操作名称。\r\n\r\n<a name=\"user-model-actions-that-dont-require-models\"></a>\r\n#### 不需要指定模型的操作\r\n\r\n请记住，某些操作可能对应着「不需要模型实例」的策略方法，比如`create`。在这些情况下，你可以将类名传递给`can`方法，类名将用于确定在授权操作时使用哪个策略：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 创建一个帖子。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            if ($request->user()->cannot('create', Post::class)) {\r\n                abort(403);\r\n            }\r\n\r\n            // 创建帖子…\r\n\r\n            return redirect('/posts');\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"via-controller-helpers\"></a>\r\n### 通过控制器辅助函数\r\n\r\n除了给`App\\Models\\User`模型提供了有用方法，Laravel 还给任何控制器提供了一个有用的  `authorize` 方法，这些控制器要继承（`extends`）`App\\Http\\Controllers\\Controller`基类。\r\n\r\n与`can`方法一样，`authorize`方法接收你希望授权的操作名称和相关模型，如果该操作未被授权，该方法将抛出`Illuminate\\Auth\\Access\\AuthorizationException`异常，Laravel 的异常处理程序将自动将该异常转换为一个带有 403 状态码的 HTTP 响应：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 更新指定的博客文章\r\n         *\r\n         * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\r\n         */\r\n        public function update(Request $request, Post $post): RedirectResponse\r\n        {\r\n            $this->authorize('update', $post);\r\n\r\n            // 当前用户可以更新博客文章…\r\n\r\n            return redirect('/posts');\r\n        }\r\n    }\r\n\r\n<a name=\"controller-actions-that-dont-require-models\"></a>\r\n#### 不需要指定模型的操作\r\n\r\n如前所述，一些策略方法 如`create`不需要模型实例，在这些情况下，你应该给`authorize`方法传递一个类名，该类名将用来确定在授权操作时使用哪个策略：\r\n\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    /**\r\n     * 创建一个新的博客文章。\r\n     *\r\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\r\n     */\r\n    public function create(Request $request): RedirectResponse\r\n    {\r\n        $this->authorize('create', Post::class);\r\n\r\n        // 当前用户可以创建博客帖子…\r\n\r\n        return redirect('/posts');\r\n    }\r\n\r\n<a name=\"authorizing-resource-controllers\"></a>\r\n\r\n\r\n#### 授权资源控制器\r\n\r\n如果你正在使用[资源控制器](/docs/laravel/10.x/controllers#resource-controllers)，你可以在控制器的构造方法中使用`authorizeResource`方法，该方法将把适当的`can`中间件定义附加到资源控制器的方法上。\r\n\r\n该`authorizeResource`方法的第一个参数是模型的类名，第二个参数是包含模型 ID 的 路由/请求参数的名称。你应该确保你的[资源控制器](/docs/laravel/10.x/controllers#resource-controllers)是使用 `--model` 标志创建的，这样它才具有所需的方法签名和类型提示。\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Post;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class PostController extends Controller\r\n    {\r\n        /**\r\n         * 创建控制器实例\r\n         */\r\n        public function __construct()\r\n        {\r\n            $this->authorizeResource(Post::class, 'post');\r\n        }\r\n    }\r\n\r\n以下控制器方法将映射到其相应的策略方法。当请求被路由到给定的控制器方法时，会在控制器方法执行之前自动调用相应的策略方法：\r\n\r\n\r\n| 控制器方法 | 策略方法 |\r\n| --- | --- |\r\n| index | viewAny |\r\n| show | view |\r\n| create | create |\r\n| store | create |\r\n| edit | update |\r\n| update | update |\r\n| destroy | delete |\r\n\r\n\r\n> **技巧**  \r\n> 你可以使用带有`make:policy`带有 `--model`选项的命令，快速的为给定模型生成一个策略类：`php artisan make:policy PostPolicy --model=Post`。\r\n\r\n<a name=\"via-middleware\"></a>\r\n### 通过中间件\r\n\r\nLaravel 包含一个中间件，可以在传入的请求到达路由或控制器之前对操作进行授权。默认情况下，`Illuminate\\Auth\\Middleware\\Authorize`中间件会在`App\\Http\\Kernel`中的`can`键中被指定。让我们来看一个使用`can`中间件授权用户更新博客文章的例子：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    Route::put('/post/{post}', function (Post $post) {\r\n        // 当前用户可以更新帖子…\r\n    })->middleware('can:update,post');\r\n\r\n\r\n\r\n在这个例子中，我们给`can`中间件传递了两个参数。第一个是我们希望授权操作的名称，第二个是我们希望传递给策略方法的路由参数。在这个例子中，当我们使用了[隐式模型绑定](/docs/laravel/10.x/routing#implicit-binding)后，一个`App\\Models\\Post`模型就将被传递给对应的策略方法。如果用户没有被授权执行给定操作的权限，那么中间件将会返回一个带有 403 状态码的 HTTP 响应。\r\n\r\n为了方便起见，你也可以使用`can`方法将`can`中间件绑定到你的路由上：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    Route::put('/post/{post}', function (Post $post) {\r\n        // 当前用户可以更新文章...\r\n    })->can('update', 'post');\r\n\r\n<a name=\"middleware-actions-that-dont-require-models\"></a>\r\n#### 不需要指定模型的操作\r\n\r\n同样的，一些策略方法不需要模型实例，比如`create`。在这些情况下，你可以给中间件传递一个类名。这个类名将用来确定在授权操作时使用哪个策略：\r\n\r\n    Route::post('/post', function () {\r\n        // 当前用户可以创建文章...\r\n    })->middleware('can:create,App\\Models\\Post');\r\n\r\n在一个中间件中定义整个类名会变得难以维护。因此，你也可以选择使用`can`方法将`can`中间件绑定到你的路由上：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    Route::post('/post', function () {\r\n        // 当前用户可以创建文章\r\n    })->can('create', Post::class);\r\n\r\n<a name=\"via-blade-templates\"></a>\r\n### 通过 Blade 模板\r\n\r\n\r\n\r\n当编写 Blade 模板时，你可能希望只展示给用户有权限操作的数据。例如，你可能希望当用户具有更新文章的权限时才展示更新博客文章的表单。在这种情况下，你可以使用`@can`和`@cannot`指令：\r\n\r\n```blade\r\n@can('update', $post)\r\n    <!-- 当前用户可更新的文章... -->\r\n@elsecan('create', App\\Models\\Post::class)\r\n    <!-- 当前用户可创建新文章... -->\r\n@else\r\n    <!-- ... -->\r\n@endcan\r\n\r\n@cannot('update', $post)\r\n    <!-- 当前用户不可更新的文章... -->\r\n@elsecannot('create', App\\Models\\Post::class)\r\n    <!-- 当前用户不可创建新文章... -->\r\n@endcannot\r\n```\r\n\r\n这些指令是编写`@if`和`@unless`语句的快捷方式。上面的`@can`和`@cannot`语句相当于下面的语句：\r\n\r\n```blade\r\n@if (Auth::user()->can('update', $post))\r\n    <!-- 当前用户可更新的文章... -->\r\n@endif\r\n\r\n@unless (Auth::user()->can('update', $post))\r\n    <!-- 当前用户不可更新的文章... -->\r\n@endunless\r\n```\r\n\r\n你还可以确定一个用户是否被授权从给定的操作数组中执行任何操作，要做到这一点，可以使用`@canany`指令：\r\n\r\n```blade\r\n@canany(['update', 'view', 'delete'], $post)\r\n    <!-- 当前用户可以更新、查看、删除文章... -->\r\n@elsecanany(['create'], \\App\\Models\\Post::class)\r\n    <!-- 当前用户可以创建新文章... -->\r\n@endcanany\r\n```\r\n\r\n<a name=\"blade-actions-that-dont-require-models\"></a>\r\n#### 不需要执行模型的操作\r\n\r\n像大多数其他授权方法一样，如果操作不需要模型实例，你可以给`@can`和`@cannot`指令传递一个类名：\r\n\r\n```blade\r\n@can('create', App\\Models\\Post::class)\r\n    <!-- 当前用户可以创建文章... -->\r\n@endcan\r\n\r\n@cannot('create', App\\Models\\Post::class)\r\n    <!-- 当前用户不能创建文章... -->\r\n@endcannot\r\n```\r\n\r\n\r\n\r\n<a name=\"supplying-additional-context\"></a>\r\n### 提供额外的上下文\r\n\r\n在使用策略授权操作时，可以将数组作为第二个参数传递给授权函数和辅助函数。数组中的第一个元素用于确定应该调用哪个策略，其余的数组元素作为参数传递给策略方法，并可在作出授权决策时用于额外的上下文中。例如，考虑下面的 `PostPolicy` 方法定义，它包含一个额外的 `$category` 参数：\r\n\r\n    /**\r\n     * 确认用户是否可以更新给定的文章。\r\n     */\r\n    public function update(User $user, Post $post, int $category): bool\r\n    {\r\n        return $user->id === $post->user_id &&\r\n               $user->canUpdateCategory($category);\r\n    }\r\n\r\n当尝试确认已验证过的用户是否可以更新给定的文章时，我们可以像这样调用此策略方法：\r\n\r\n    /**\r\n     * 更新给定的博客文章\r\n     *\r\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\r\n     */\r\n    public function update(Request $request, Post $post): RedirectResponse\r\n    {\r\n        $this->authorize('update', [$post, $request->category]);\r\n\r\n        // 当前用户可以更新博客文章...\r\n\r\n        return redirect('/posts');\r\n    }\r\n\r\n","p":"docs/authorization.html"},{"t":"verification (Email 认证)","d":"\n# Email 认证\r\n\r\n- [简介](#introduction)\r\n    - [准备模型](#model-preparation)\r\n    - [准备数据库](#database-preparation)\r\n- [路由](#verification-routing)\r\n    - [Email 认证通知](#the-email-verification-notice)\r\n    - [Email 认证处理](#the-email-verification-handler)\r\n    - [重新发送 Email 认证](#resending-the-verification-email)\r\n    - [保护路由](#protecting-routes)\r\n- [自定义](#customization)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n很多 Web 应用会要求用户在使用之前进行 Email 地址验证。Laravel 不会强迫你在每个应用中重复实现它，而是提供了便捷的方法来发送和校验电子邮件的验证请求。\r\n\r\n> **技巧**\r\n> 想快速上手吗？你可以在全新的应用中安装 [Laravel 应用入门套件](/docs/laravel/10.x/starter-kits) 。入门套件将帮助你搭建整个身份验证系统，包括电子邮件验证支持。\r\n\r\n<a name=\"model-preparation\"></a>\r\n### 准备模型\r\n\r\n在开始之前，需要检查你的 `App\\Models\\User` 模型是否实现了 `Illuminate\\Contracts\\Auth\\MustVerifyEmail` 契约：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Contracts\\Auth\\MustVerifyEmail;\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable implements MustVerifyEmail\r\n    {\r\n        use Notifiable;\r\n\r\n        // ...\r\n    }\r\n\r\n一旦这一接口被添加到模型中，新注册的用户将自动收到一封包含电子邮件验证链接的电子邮件。检查你的 `App\\Providers\\EventServiceProvider` 可以看到，Laravel 已经为 `Illuminate\\Auth\\Events\\Registered` 事件注册了一个 `SendEmailVerificationNotification` [监听器](/docs/laravel/10.x/events) 。这个事件监听器会通过邮件发送验证链接给用户。\r\n如果在应用中你没有使用 [入门套件](/docs/laravel/10.x/starter-kits) 而是手动实现的注册，你需要确保在用户注册成功后手动分发 `Illuminate\\Auth\\Events\\Registered` 事件：\r\n\r\n    use Illuminate\\Auth\\Events\\Registered;\r\n\r\n    event(new Registered($user));\r\n\r\n\n\n<a name=\"database-preparation\"></a>\r\n### 数据库准备\r\n\r\n接下来，你的 `users` 表必须有一个 `email_verified_at` 字段，用来存储用户邮箱验证的日期和时间。Laravel 框架自带的 `users` 表以及默认包含了该字段。因此，你只需运行数据库迁移即可：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"verification-routing\"></a>\r\n## 路由\r\n\r\n为了实现完整的电子邮件验证流程，你将需要定义三个路由。首先，需要定义一个路由向用户显示通知，告诉用户应该点击注册之后， Laravel 向他们发送的验证邮件中的链接。\r\n\r\n其次，需要一个路由来处理用户点击邮件中验证链接时发来的请求。\r\n\r\n第三，如果用户没有收到验证邮件，则需要一路由来重新发送验证邮件。\r\n\r\n<a name=\"the-email-verification-notice\"></a>\r\n### 邮箱验证通知\r\n\r\n如上所述，应该定义一条路由，该路由将返回一个视图，引导用户点击注册后 Laravel 发送给他们邮件中的验证链接。当用户尝试访问网站的其它页面而没有先完成邮箱验证时，将向用户显示此视图。请注意，只要您的 `App\\Models\\User` 模型实现了 `MustVerifyEmail` 接口，就会自动将该链接发邮件给用户：\r\n\r\n    Route::get('/email/verify', function () {\r\n        return view('auth.verify-email');\r\n    })->middleware('auth')->name('verification.notice');\r\n\r\n显示邮箱验证的路由，应该命名为 `verification.notice`。配置这个命名路由很重要，因为如果用户邮箱验证未通过，Laravel 自带的[`verified` 中间件](#protecting-routes) 将会自动重定向到该命名路由上。\r\n\r\n> **注意**  \r\n> 手动实现邮箱验证过程时，你需要自己定义验证通知视图。如果你希望包含所有必要的身份验证和验证视图，请查看 [Laravel 应用入门套件](/docs/laravel/10.x/starter-kits)\r\n\r\n\n\n<a name=\"the-email-verification-handler\"></a>\r\n### Email 认证处理\r\n\r\n接下来，我们需要定义一个路由，该路由将处理当用户点击验证链接时发送的请求。该路由应命名为 `verification.verify` ，并添加了 `auth` 和 `signed` 中间件\r\n\r\n    use Illuminate\\Foundation\\Auth\\EmailVerificationRequest;\r\n\r\n    Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {\r\n        $request->fulfill();\r\n\r\n        return redirect('/home');\r\n    })->middleware(['auth', 'signed'])->name('verification.verify');\r\n\r\n在继续之前，让我们仔细看一下这个路由。首先，您会注意到我们使用的是 `EmailVerificationRequest` 请求类型，而不是通常的 `Illuminate\\Http\\Request` 实例。 `EmailVerificationRequest` 是 Laravel 中包含的 [表单请求](/docs/laravel/10.x/validation#form-request-validation)。此请求将自动处理验证请求的 id 和 hash 参数。\r\n\r\n接下来，我们可以直接在请求上调用 `fulfill` 方法。该方法将在经过身份验证的用户上调用 `markEmailAsVerified` 方法，并会触发 `Illuminate\\Auth\\Events\\Verified` 事件。通过 `Illuminate\\Foundation\\Auth\\User` 基类，`markEmailAsVerified` 方法可用于默认的 `App\\Models\\User` 模型。验证用户的电子邮件地址后，您可以将其重定向到任意位置。\r\n\r\n<a name=\"resending-the-verification-email\"></a>\r\n### 重新发送 Email 认证邮件\r\n\r\n有时候，用户可能输错了电子邮件地址或者不小心删除了验证邮件。为了解决这种问题，您可能会想定义一个路由实现用户重新发送验证邮件。您可以通过在 [验证通知视图](#the-email-verification-notice) 中放置一个简单的表单来实现此功能。\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/email/verification-notification', function (Request $request) {\r\n        $request->user()->sendEmailVerificationNotification();\r\n\r\n        return back()->with('message', 'Verification link sent!');\r\n    })->middleware(['auth', 'throttle:6,1'])->name('verification.send');\r\n\r\n\n\n<a name=\"protecting-routes\"></a>\r\n### 保护路由\r\n\r\n[路由中间件](/docs/laravel/10.x/middleware)可用于仅允许经过验证的用户访问给定路由。Laravel 附带了一个 `verified` 中间件别名，它是 `Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified` 类的别名。由于该中间件已经在你的应用程序的 HTTP 内核中注册，所以你只需要将中间件附加到路由定义即可。通常，此中间件与 `auth` 中间件配对使用。\r\n\r\n    Route::get('/profile', function () {\r\n        // 仅经过验证的用户可以访问此路由。。。\r\n    })->middleware(['auth', 'verified']);\r\n\r\n如果未经验证的用户尝试访问已被分配了此中间件的路由，他们将自动重定向到`verification.notice` [命名路由](/docs/laravel/10.x/routing#named-routes)。\r\n\r\n<a name=\"customization\"></a>\r\n## 自定义\r\n\r\n<a name=\"verification-email-customization\"></a>\r\n#### 验证邮件自定义\r\n\r\n虽然默认的电子邮件验证通知应该能够满足大多数应用程序的要求，但 Laravel 允许你自定义如何构建电子邮件验证邮件消息。\r\n\r\n要开始自定义邮件验证消息，你需要将一个闭包传递给 `Illuminate\\Auth\\Notifications\\VerifyEmail` 通知提供的 `toMailUsing` 方法。该闭包将接收到通知的可通知模型实例以及用户必须访问以验证其电子邮件地址的已签名电子邮件验证 URL。该闭包应返回 `Illuminate\\Notifications\\Messages\\MailMessage` 的实例。通常，你应该从应用程序的 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中调用 `toMailUsing` 方法：\r\n\r\n    use Illuminate\\Auth\\Notifications\\VerifyEmail;\r\n    use Illuminate\\Notifications\\Messages\\MailMessage;\r\n\r\n    /**\r\n     * 注册任何身份验证/授权服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        // ...\r\n\r\n        VerifyEmail::toMailUsing(function (object $notifiable, string $url) {\r\n            return (new MailMessage)\r\n                ->subject('Verify Email Address')\r\n                ->line('Click the button below to verify your email address.')\r\n                ->action('Verify Email Address', $url);\r\n        });\r\n    }\r\n\r\n> 技巧：要了解更多有关邮件通知的信息，请参阅 [\r\n邮件通知文档](/docs/laravel/10.x/notifications#mail-notifications)。\r\n\r\n\n\n<a name=\"events\"></a>\r\n## 事件\r\n\r\n如果你是使用 [Laravel 应用入门套件](/docs/laravel/10.x/starter-kits) 的话，Laravel 在电子邮件验证通过后会派发 [事件](/docs/laravel/10.x/events) 。如果你想接收到这个事件并进行手动处理的话，你应该在 `EventServiceProvider` 中注册监听器：\r\n\r\n    use App\\Listeners\\LogVerifiedUser;\r\n    use Illuminate\\Auth\\Events\\Verified;\r\n    \r\n    /**\r\n     * 应用的事件监听器\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        Verified::class => [\r\n            LogVerifiedUser::class,\r\n        ],\r\n    ];\r\n\n","p":"docs/verification.html"},{"t":"encryption (加密解密)","d":"\n# 加密解密\r\n\r\n- [简介](#introduction)\r\n- [配置](#configuration)\r\n- [基本用法](#using-the-encrypter)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 的加密服务提供了一个简单、方便的接口，使用 OpenSSL 所提供的 AES-256 和 AES-128 加密和解密文本。所有 Laravel 加密的结果都会使用消息认证码 (MAC) 进行签名，因此一旦加密，其底层值就不能被修改或篡改。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n在使用 Laravel 的加密工具之前，你必须先设置 `config/app.php` 配置文件中的 `key` 配置项。该配置项由环境变量 `APP_KEY` 设定。你应当使用 `php artisan key:generate` 命令来生成该变量的值，`key:generate` 命令将使用 PHP 的安全随机字节生成器为你的应用程序构建加密安全密钥。通常情况下，在 [Laravel 安装](/docs/laravel/10.x/installation) 中会为你生成 APP_KEY 环境变量的值。\r\n\r\n<a name=\"using-the-encrypter\"></a>\r\n## 基本用法\r\n\r\n<a name=\"encrypting-a-value\"></a>\r\n#### 加密一个值\r\n\r\n你可以使用 `Crypt` 门面提供的 `encryptString` 方法来加密一个值。所有加密的值都使用 OpenSSL 的 AES-256-CBC 来进行加密。此外，所有加密过的值都会使用消息认证码 (MAC) 来签名，可以防止恶意用户对值进行篡改：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\User;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Crypt;\r\n\r\n    class DigitalOceanTokenController extends Controller\r\n    {\r\n        /**\r\n         *  为用户存储一个 DigitalOcean API 令牌。\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            $request->user()->fill([\r\n                'token' => Crypt::encryptString($request->token),\r\n            ])->save();\r\n\r\n            return redirect('/secrets');\r\n        }\r\n    }\r\n\r\n<a name=\"decrypting-a-value\"></a>\r\n#### 解密一个值\r\n\r\n你可以使用 `Crypt` 门面提供的 `decryptString` 来进行解密。如果该值不能被正确解密，例如消息认证码 (MAC) 无效，会抛出异常 `Illuminate\\Contracts\\Encryption\\DecryptException`：\r\n\r\n    use Illuminate\\Contracts\\Encryption\\DecryptException;\r\n    use Illuminate\\Support\\Facades\\Crypt;\r\n\r\n    try {\r\n        $decrypted = Crypt::decryptString($encryptedValue);\r\n    } catch (DecryptException $e) {\r\n        // ...\r\n    }\r\n\n","p":"docs/encryption.html"},{"t":"hashing (哈希)","d":"\n# 哈希\r\n\r\n- [介绍](#introduction)\r\n- [配置](#configuration)\r\n- [基本用法](#basic-usage)\r\n    - [哈希密码](#hashing-passwords)\r\n    - [验证密码是否与哈希值相匹配](#verifying-that-a-password-matches-a-hash)\r\n    - [确定密码是否需要重新哈希](#determining-if-a-password-needs-to-be-rehashed)\r\n\r\n<a name=\"introduction\"></a>\r\n\r\n## 介绍\r\n\r\nLaravel `Hash` [Facad](/docs/laravel/10.x/facades) 为存储用户密码提供了安全的 Bcrypt 和 Argon2 哈希。如果您使用的是一个[Laravel 应用程序启动套件](/docs/laravel/10.x/st arter-kits)，那么在默认情况下，Bcrypt 将用于注册和身份验证。\r\n\r\nBcrypt 是哈希密码的绝佳选择，因为它的「加密系数」是可调节的，这意味着随着硬件功率的增加，生成哈希的时间可以增加。当哈希密码时，越慢越好。算法花费的时间越长，恶意用户生成「彩虹表」的时间就越长，该表包含所有可能的字符串哈希值，这些哈希值可能会被用于针对应用程序的暴力攻击中。\r\n\r\n<a name=\"configuration\"></a>\r\n\r\n## 配置\r\n\r\n你可以在 `config/hashing.php` 配置文件中配置默认哈希驱动程序。目前有几个受支持的驱动程序：[Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) 和 [Argon2](https://en.wikipedia.org/wiki/Argon2)（Argon2i 和 Argon2id 变体）。\r\n\r\n<a name=\"basic-usage\"></a>\r\n\r\n## 基本用法\r\n\r\n<a name=\"hashing-passwords\"></a>\r\n\r\n### 哈希密码\r\n\r\n您可以通过在 `Hash` Facade 上调用 `make` 方法来哈希密码：\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Http\\Controllers\\Controller;\r\nuse Illuminate\\Http\\RedirectResponse;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Facades\\Hash;\r\n\r\nclass PasswordController extends Controller\r\n{\r\n    /**\r\n     * 更新用户的密码。\r\n     */\r\n    public function update(Request $request): RedirectResponse\r\n    {\r\n        // 验证新密码的长度...\r\n\r\n        $request->user()->fill([\r\n            'password' => Hash::make($request->newPassword)\r\n        ])->save();\r\n\r\n        return redirect('/profile');\r\n    }\r\n}\r\n```\n\n<a name=\"adjusting-the-bcrypt-work-factor\"></a>\r\n\r\n#### 调整 Bcrypt 加密系数\r\n\r\n如果您正在使用 Bcrypt 算法，则 `make` 方法允许您使用 `rounds` 选项来配置该算法的加密系数。然而，对大多数应用程序来说，默认值就足够了：\r\n\r\n```\r\n$hashed = Hash::make('password', [\r\n    'rounds' => 12,\r\n]);\r\n\r\n```\r\n\r\n<a name=\"adjusting-the-argon2-work-factor\"></a>\r\n\r\n#### 调整 Argon2 加密系数\r\n\r\n如果您正在使用 Argon2 算法，则 `make` 方法允许您使用 `memory`，`time` 和 `threads` 选项来配置该算法的加密系数。然后，对大多数应用程序来说，默认值就足够了：\r\n\r\n```\r\n$hashed = Hash::make('password', [\r\n    'memory' => 1024,\r\n    'time' => 2,\r\n    'threads' => 2,\r\n]);\r\n\r\n```\r\n\r\n> **注意**\r\n> 有关这些选项的更多信息，请参见 [关于 Argon 哈希的官方 PHP 文档](https://secure.php.net/manual/en/function.password-hash.php) 。\r\n\r\n<a name=\"verifying-that-a-password-matches-a-hash\"></a>\r\n\r\n### 验证密码是否与哈希值相匹配\r\n\r\n由 `Hash` Facade 提供的 `check` 方法允许您验证给定的明文字符串是否与给定的哈希值一致：\r\n\r\n```\r\nif (Hash::check('plain-text', $hashedPassword)) {\r\n    // The passwords match...\r\n}\r\n\r\n```\r\n\r\n<a name=\"determining-if-a-password-needs-to-be-rehashed\"></a>\r\n\r\n### 确定密码是否需要重新哈希\r\n\r\n由 `Hash` Facade 提供的 `needsRehash` 方法可以为你检查当散列 / 哈希的加密系数改变时，你的密码是否被新的加密系数重新加密过。某些应用程序选择在身份验证过程中执行此检查：\r\n\r\n```\r\nif (Hash::needsRehash($hashed)) {\r\n    $hashed = Hash::make('plain-text');\r\n}\r\n```\n","p":"docs/hashing.html"},{"t":"passwords (重置密码)","d":"\n# 重置密码\r\n\r\n-   [介绍](#introduction)\r\n    -   [模型准备](#model-preparation)\r\n    -   [数据库准备](#database-preparation)\r\n    -   [配置可信主机](#configuring-trusted-hosts)\r\n-   [路由](#routing)\r\n    -   [请求密码重置链接](#requesting-the-password-reset-link)\r\n    -   [重置密码](#resetting-the-password)\r\n-   [删除过期令牌](#deleting-expired-tokens)\r\n-   [自定义](#password-customization)\r\n\r\n<a name=\"introduction\"></a>\r\n\r\n## 介绍\r\n\r\n大多数 Web 应用程序都提供了一种让用户重置密码的方法。Laravel 已经提供了便捷的服务来发送密码重置链接和安全重置密码，而不需要您为每个应用程序重新实现此功能。\r\n\r\n> **注意**\r\n> 想要快速入门吗？在全新的 Laravel 应用程序中安装 Laravel [入门套件](/docs/laravel/10.x/starter-kits)。 Laravel 的起始包将为您的整个身份验证系统包括重置忘记的密码提供支持。\r\n\r\n<a name=\"model-preparation\"></a>\r\n\r\n### 模型准备\r\n\r\n在使用 Laravel 的密码重置功能之前，您的应用程序的 `App\\Models\\User` 模型必须使用 `Illuminate\\Notifications\\Notifiable` trait。通常，在新创建的 Laravel 应用程序的 `App\\Models\\User` 模型中默认引入了该 trait 。\r\n\r\n接下来，验证您的 `App\\Models\\User` 模型是否实现了 `Illuminate\\Contracts\\Auth\\CanResetPassword` 契约。框架中包含的 `App\\Models\\User` 模型已经实现了该接口，并使用 `Illuminate\\Auth\\Passwords\\CanResetPassword` 特性来包括实现该接口所需的方法。\r\n\r\n<a name=\"database-preparation\"></a>\r\n\r\n### 数据库准备\r\n\r\n必须创建一个表来存储您的应用程序的密码重置令牌。这个表的迁移被包含在默认的 Laravel 应用程序中，所以您只需要迁移您的数据库来创建这个表：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\n\n<a name=\"configuring-trusted-hosts\"></a>\r\n\r\n### 配置受信任的主机\r\n\r\n默认情况下，无论 HTTP 请求的 `Host` 头的内容是什么，Laravel 都会响应它收到的所有请求。此外，在 Web 请求期间生成应用程序的绝对 URL 时，将使用 `Host` 标头的值。\r\n\r\n通常，您应该将 Web 服务器（例如 Nginx 或 Apache）配置为仅向您的应用程序发送与给定主机名匹配的请求。然而，如果你没有能力直接自定义你的 web 服务器并且需要指示 Laravel 只响应某些主机名，你可以通过为你的应用程序启用 `App\\Http\\Middleware\\TrustHosts` 中间件来实现。当您的应用程序提供密码重置功能时，这一点尤其重要.\r\n\r\n要了解有关此中间件的更多信息，请参阅[`TrustHosts` 中间件文档](/docs/laravel/10.x/requests#configuring-trusted-hosts)。\r\n\r\n<a name=\"routing\"></a>\r\n\r\n## 路由\r\n\r\n要正确实现支持允许用户重置其密码的功能，我们需要定义多个路由。首先，我们需要一对路由来处理允许用户通过其电子邮件地址请求密码重置链接。其次，一旦用户访问通过电子邮件发送给他们的密码重置链接并完成密码重置表单，我们将需要一对路由来处理实际重置密码。\r\n\r\n<a name=\"requesting-the-password-reset-link\"></a>\r\n\r\n### 请求密码重置链接\r\n\r\n<a name=\"the-password-reset-link-request-form\"></a>\r\n\r\n#### 密码重置链接申请表\r\n\r\n首先，我们将定义请求密码重置链接所需的路由。首先，我们将定义一个路由，该路由返回一个带有密码重置链接请求表单的视图：\r\n\r\n```\r\nRoute::get('/forgot-password', function () {\r\n    return view('auth.forgot-password');\r\n})->middleware('guest')->name('password.request');\r\n\r\n```\n\n此路由返回的视图应该有一个包含 `email` 字段的表单，该字段允许用户请求给定电子邮件地址的密码重置链接。\r\n\r\n<a name=\"password-reset-link-handling-the-form-submission\"></a>\r\n#### 处理表单提交\r\n\r\n接下来，我们将定义一个路由，该路由将从「忘记密码」视图处理表单提交请求。此路由将负责验证电子邮件地址并将密码重置请求发送给相应用户：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Password;\r\n\r\n    Route::post('/forgot-password', function (Request $request) {\r\n        $request->validate(['email' => 'required|email']);\r\n\r\n        $status = Password::sendResetLink(\r\n            $request->only('email')\r\n        );\r\n\r\n        return $status === Password::RESET_LINK_SENT\r\n                    ? back()->with(['status' => __($status)])\r\n                    : back()->withErrors(['email' => __($status)]);\r\n    })->middleware('guest')->name('password.email');\r\n\r\n在继续之前，让我们更详细地检查一下这条路由。首先，验证请求的 `email` 属性。接下来，我们将使用 Laravel 内置的 `Password` 门面向用户发送一个密码重置链接。密码代理将负责按给定字段（在本例中是电子邮件地址）检索用户，并通过 Laravel 的内置 [消息通知系统](/docs/laravel/10.x/notifications) 向用户发送密码重置链接。\r\n\r\n该 `sendResetLink` 方法返回一个状态标识。可以使用 Laravel 的 [本地化](/docs/laravel/10.x/localization) 助手来转换此状态，以便向用户显示有关请求状态的用户友好提示。密码重置状态的转换由应用程序的 `lang/{lang}/passwords.php` 语言文件决定。状态 slug 的每个可能值的条目位于  `passwords` 语言文件中。\r\n\r\n> **注意**\r\n> 默认情况下, Laravel应用程序的框架不包括 `lang` 目录. 如果你想定制Laravel的语言文件, 你可以通过 `lang:publish` Artisan命令发布.\r\n\r\n\n\n你可能想知道，Laravel 在调用 Password 门面的 sendResetLink 方法时，Laravel 怎么知道如何从应用程序数据库中检索用户记录。Laravel 密码代理利用身份验证系统的「用户提供者」来检索数据库记录。密码代理使用的用户提供程序是在 passwords 配置文件的 config/auth.php 配置数组中配置的。要了解有关编写自定义用户提供程序的更多信息，请参阅 [身份验证文档](/docs/laravel/10.x/authenticationmd#adding-custom-user-providers)。\r\n\r\n> **Note**  \r\n> 技巧：当手动实现密码重置时，你需要自己定义视图和路由的内容。如果你想要包含所有必要的身份验证和验证逻辑的脚手架，请查看 [Laravel 应用程序入门工具包](/docs/laravel/10.x/starter-kits)。\r\n\r\n<a name=\"resetting-the-password\"></a>\r\n### 重置密码\r\n\r\n<a name=\"the-password-reset-form\"></a>\r\n#### 重置密码表单\r\n\r\n接下来，我们将定义用户点击重置密码邮件中的链接，进行重置密码所需要的一些路由。第一步，先定义一个获取重置密码表单的路由。这个路由需要一个 `token` 来验证请求：\r\n\r\n    Route::get('/reset-password/{token}', function (string $token) {\r\n        return view('auth.reset-password', ['token' => $token]);\r\n    })->middleware('guest')->name('password.reset');\r\n\r\n通过路由返回的视图应该显示一个含有 `email` 字段， `password` 字段，`password_confirmation` 字段和一个隐藏的值通过路由参数获取的 `token` 字段。\r\n\r\n\n\n<a name=\"password-reset-handling-the-form-submission\"></a>\r\n#### 处理表单提交的数据\r\n\r\n当然，我们需要定义一个路由来接受表单提交的数据。这个路由会检查传过来的参数并更新数据库中用户的密码：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Events\\PasswordReset;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Illuminate\\Support\\Facades\\Password;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    Route::post('/reset-password', function (Request $request) {\r\n        $request->validate([\r\n            'token' => 'required',\r\n            'email' => 'required|email',\r\n            'password' => 'required|min:8|confirmed',\r\n        ]);\r\n\r\n        $status = Password::reset(\r\n            $request->only('email', 'password', 'password_confirmation', 'token'),\r\n            function (User $user, string $password) {\r\n                $user->forceFill([\r\n                    'password' => Hash::make($password)\r\n                ])->setRememberToken(Str::random(60));\r\n\r\n                $user->save();\r\n\r\n                event(new PasswordReset($user));\r\n            }\r\n        );\r\n\r\n        return $status === Password::PASSWORD_RESET\r\n                    ? redirect()->route('login')->with('status', __($status))\r\n                    : back()->withErrors(['email' => [__($status)]]);\r\n    })->middleware('guest')->name('password.update');\r\n\r\n在继续之前，我们再详细地检查下这条路由。 首先，验证请求的 `token`，`email` 和 `password` 属性。 接下来，我们将使用 Laravel 的内置「密码代理」 (通过 `Password` facade) 来验证密码重置请求凭据。\r\n\r\n如果提供给密码代理的令牌、电子邮件地址和密码有效，则将调用传递给 `reset` 方法的闭包。 在这个接收用户实例和纯文本密码的闭包中，我们可以更新数据库中用户的密码。\r\n\r\n该 `reset` 方法返回一个「状态」标识。 此状态可以使用 Laravel 的 [本地化](/docs/laravel/10.x/localization) 助手来翻译此状态，以便向用户显示有关其请求状态的用户友好消息。密码重置状态的翻译由应用程序的 `lang/{lang}/passwords.php` 语言文件决定。状态段的每个可能值的条目位于 `passwords` 语言文件中。如果你的应用没有 `lang` 文件夹，你可以使用 `lang:publish` artisan命令来创建。\r\n\r\n\n\n在继续之前，你可能想知道 Laravel 如何在调用 `Password` facade的 `reset` 方法时如何知道如何从应用程序的数据库中检索用户记录。Laravel 密码代理利用你的身份验证系统的「用户提供者」来检索数据库记录。密码代理使用的用户提供程序在配置文件的 `config/auth.php` 配置文件的 `passwords` 配置数组中配置。 要了解有关编写自定义用户提供程序的更多信息，请参阅 [身份验证文档](/docs/laravel/10.x/authenticationmd#adding-custom-user-providers)。\r\n\r\n<a name=\"deleting-expired-tokens\"></a>\r\n## 删除过期令牌\r\n\r\n已过期的密码重置令牌仍将存在于你的数据库中。然而，你可以使用 `auth:clear-resets` Artisan 命令轻松删除这些记录：\r\n\r\n```shell\r\nphp artisan auth:clear-resets\r\n```\r\n\r\n如果你想使该过程自动化，请考虑将命令添加到应用程序的 [调度程序](/docs/laravel/10.x/scheduling)：\r\n\r\n    $schedule->command('auth:clear-resets')->everyFifteenMinutes();\r\n\r\n<a name=\"password-customization\"></a>\r\n## 自定义\r\n\r\n<a name=\"reset-link-customization\"></a>\r\n#### 重置链接自定义\r\n\r\n你可以使用 `ResetPassword` 通知类提供的 `createUrlUsing` 方法自定义密码重置链接 URL。 此方法接受一个闭包，该闭包接收正在接收通知的用户实例以及密码重置链接令牌。 通常，你应该从 `App\\Providers\\AuthServiceProvider` 服务提供者的 `boot` 方法中调用此方法：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Auth\\Notifications\\ResetPassword;\r\n\r\n    /**\r\n     * 注册任何身份验证/授权服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        ResetPassword::createUrlUsing(function (User $user, string $token) {\r\n            return 'https://example.com/reset-password?token='.$token;\r\n        });\r\n    }\r\n\r\n<a name=\"reset-email-customization\"></a>\r\n#### 重置邮件自定义\r\n\r\n你可以轻松修改用于向用户发送密码重置链接的通知类。 首先，覆盖你的 `App\\Models\\User` 模型上的 `sendPasswordResetNotification` 方法。 在此方法中，你可以使用你自己创建的任何 [通知类](/docs/laravel/10.x/notifications) 发送通知。 密码重置 `$token` 是该方法收到的第一个参数。 你可以使用这个 `$token` 来构建你选择的密码重置 URL 并将你的通知发送给用户：\r\n\r\n    use App\\Notifications\\ResetPasswordNotification;\r\n\r\n    /**\r\n     * 发送密码重置通知给用户\r\n     *\r\n     * @param string $token\r\n     */\r\n    public function sendPasswordResetNotification($token): void\r\n    {\r\n        $url = 'https://example.com/reset-password?token='.$token;\r\n\r\n        $this->notify(new ResetPasswordNotification($url));\r\n    }\r\n\n","p":"docs/passwords.html"},{"t":"database (数据库: 快速入门)","d":"\n# 数据库: 快速入门\r\n\r\n- [简介](#introduction)\r\n    - [配置](#configuration)\r\n    - [读写分离](#read-and-write-connections)\r\n- [运行原生 SQL 查询](#running-queries)\r\n    - [使用多个数据库连接](#using-multiple-database-connections)\r\n    - [监听查询事件](#listening-for-query-events)\r\n    - [监控累计查询时间](#monitoring-cumulative-query-time)\r\n- [数据库事务](#database-transactions)\r\n- [连接到数据库 CLI](#connecting-to-the-database-cli)\r\n- [检查数据库](#inspecting-your-databases)\r\n- [监控数据库](#monitoring-your-databases)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n几乎所有的应用程序都需要和数据库进行交互。Laravel 为此提供了一套非常简单易用的数据库交互方式。开发者可以使用原生 SQL，[查询构造器](/docs/laravel/10.x/queries)，以及 [Eloquent ORM](/docs/laravel/10.x/eloquent) 等方式与数据库交互。目前，Laravel 为以下五种数据库提供了官方支持：:\r\n\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- MariaDB 10.3+ ([版本策略](https://mariadb.org/about/#maintenance-policy))\r\n- MySQL 5.7+ ([版本策略](https://en.wikipedia.org/wiki/MySQL#Release_history))\r\n- PostgreSQL 10.0+ ([版本策略](https://www.postgresql.org/support/versioning/))\r\n- SQLite 3.8.8+\r\n- SQL Server 2017+ ([版本策略](https://docs.microsoft.com/en-us/lifecycle/products/?products=sql-server))\r\n\r\n</div>\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\nLaravel数据库服务的配置位于应用程序的`config/database.php`配置文件中。在此文件中，您可以定义所有数据库连接，并指定默认情况下应使用的连接。此文件中的大多数配置选项由应用程序环境变量的值驱动。本文件提供了Laravel支持的大多数数据库系统的示例。\r\n\r\n在默认情况下，Laravel 的示例 [环境配置](/docs/laravel/10.x/configuration#environment-configuration) 使用了 [Laravel Sail](/docs/laravel/10.x/sail)，Laravel Sail 是一种用于在本地开发 Laravel 应用的 Docker 配置。但你依然可以根据本地数据库的需要修改数据库配置。\r\n\r\n\n\n<a name=\"sqlite-configuration\"></a>\r\n#### SQLite 配置\r\n\r\nSQLite 数据库本质上只是一个存在你文件系统上的文件。你可以通过 <code>touch</code> 命令来建立一个新的 SQLite 数据库，如： <code>touch database/database.sqlite </code>. 建立数据库之后，你就可以很简单地使用数据库的绝对路径来配置 <code>DB_DATABASE</code> 环境变量，使其指向这个新创建的数据库：\r\n\r\n\r\n```ini\r\nDB_CONNECTION=sqlite\r\nDB_DATABASE=/absolute/path/to/database.sqlite\r\n```\r\n\r\n若要为 SQLite 连接启用外键约束，应将 <code>DB_FOREIGN_KEYS</code> 环境变量设置为 <code>true</code> ：\r\n\r\n```ini\r\nDB_FOREIGN_KEYS=true\r\n```\r\n\r\n<a name=\"mssql-configuration\"></a>\r\n#### Microsoft SQL Server 配置\r\n\r\n在使用 SQL Server 数据库前，你需要先确保你已安装并启用了 <code>sqlsrv</code> 和 <code>pdo_sqlsrv</code> PHP 扩展以及它们所需要的依赖项，例如 Microsoft SQL ODBC 驱动。\r\n\r\n<a name=\"configuration-using-urls\"></a>\r\n#### URL 形式配置\r\n\r\n通常，数据库连接使用多个配置项进行配置，例如 <code>host</code> 、<code>database</code> 、 <code>username</code> 、 <code>password</code> 等。这些配置项都拥有对应的环境变量。这意味着你需要在生产服务器上管理多个不同的环境变量。\r\n\r\n部分数据库托管平台（如 AWS 和 Heroku）会提供了包含所有连接信息的数据库「URL」。它们通常看起来像这样：\r\n\r\n\r\n```html\r\nmysql://root:password@127.0.0.1/forge?charset=UTF-8\r\n```\r\n\r\n这些 URL 通常遵循标准模式约定：\r\n\r\n```html\r\ndriver://username:password@host:port/database?options\r\n```\r\n\r\n\n\n为了方便起见，Laravel 支持使用这些 URL 替代传统的配置项来配置你的数据库。如果配置项 <code>url</code> （或其对应的环境变量 <code>DATABASE_URL</code> ）存在，那么 Laravel 将会尝试从 URL 中提取数据库连接以及凭证信息。\r\n\r\n<a name=\"read-and-write-connections\"></a>\r\n### 读写分离\r\n\r\n有时候你可能会希望使用一个数据库连接来执行 <code>SELECT</code> 语句，而 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句则由另一个数据库连接来执行。在 Laravel 中，无论你是使用原生 SQL 查询、查询构造器 或是 <code>Eloquent ORM</code>，都能轻松实现读写分离。\r\n\r\n为了弄明白如何配置读写分离，我们先来看个例子：\r\n\r\n    'mysql' => [\r\n        'read' => [\r\n            'host' => [\r\n                '192.168.1.1',\r\n                '196.168.1.2',\r\n            ],\r\n        ],\r\n        'write' => [\r\n            'host' => [\r\n                '196.168.1.3',\r\n            ],\r\n        ],\r\n        'sticky' => true,\r\n        'driver' => 'mysql',\r\n        'database' => 'database',\r\n        'username' => 'root',\r\n        'password' => '',\r\n        'charset' => 'utf8mb4',\r\n        'collation' => 'utf8mb4_unicode_ci',\r\n        'prefix' => '',\r\n    ],\r\n\r\n请注意，我们在数据库配置中加入了三个键，分别是： <code>read</code>, <code>write</code> 以及 <code>sticky</code> 。<code>read</code> 和 <code>write</code> 的值是一个只包含 <code>host</code> 键的数组。这代表其他的数据库选项将会从主 <code>mysql</code> 配置中获取。\r\n\r\n如果你想要覆写主 <code>mysql</code> 配置，只需要将需要覆写的值放到 <code>read</code> 和 <code>write</code> 数组里即可。所以，在这个例子中，<code>192.168.1.1</code> 将会被用作「读」连接主机，而 <code>192.168.1.3</code> 将作为「写」连接主机。这两个连接将共享 <code>mysql</code> 数组中的各项配置，如数据库凭证（用户名、密码）、前缀、字符编码等。如果 <code>host</code> 数组中存在多个值，<code>Laravel</code> 将会为每个连接随机选取所使用的数据库主机。\r\n\r\n\r\n\n\n<a name=\"the-sticky-option\"></a>\r\n#### <code>sticky</code> 选项\r\n\r\n<code>sticky</code> 是一个 可选 值，它用于允许 Laravel 立即读取在当前请求周期内写入到数据库的记录。若 <code>sticky</code> 选项被启用，且在当前请求周期中执行过「写」操作，那么在这之后的所有「读」操作都将使用「写」连接。这样可以确保同一个请求周期中写入的数据库可以被立即读取到，从而避免主从同步延迟导致的数据不一致。不过是否启用它取决于项目的实际需求。\r\n\r\n\r\n<a name=\"running-queries\"></a>\r\n## 执行原生SQL查询\r\n\r\n一旦配置好数据库连接，你就可以使用 <code>DB</code> Facade 来执行查询。<code>DB</code> Facade 为每种类型的查询都提供了相应的方法：<code>select</code>、<code>update</code>、<code>insert</code>、<code>delete</code> 以及 <code>statement</code>。\r\n\r\n\r\n<a name=\"running-a-select-query\"></a>\r\n#### 执行 SELECT 查询\r\n\r\n你可以使用 <code>DB</code> Facade 的 <code>select</code> 方法来执行一个基础的 SELECT 查询：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 展示应用程序所有的用户列表.\r\n         */\r\n        public function index(): View\r\n        {\r\n            $users = DB::select('select * from users where active = ?', [1]);\r\n\r\n            return view('user.index', ['users' => $users]);\r\n        }\r\n    }\r\n\r\n传递给 <code>select</code> 方法的第一个参数是一个原生 SQL 查询语句，而第二个参数则是需要绑定到查询中的参数值。通常，这些值用于约束 <code>where</code> 语句。使用参数绑定可以有效防止 SQL 注入。\r\n\r\n\n\n`select`方法将始终返回一个包含查询结果的数组。数组中的每个结果都对应一个数据库记录的`stdClass`对象：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::select('select * from users');\r\n\r\n    foreach ($users as $user) {\r\n        echo $user->name;\r\n    }\r\n\r\n<a name=\"selecting-scalar-values\"></a>\r\n#### 选择标量值\r\n\r\n有时你的数据库查询可能得到一个单一的标量值。而不是需要从记录对象中检索查询的标量结果，Laravel 允许你直接使用`scalar`方法检索此值:\r\n\r\n    $burgers = DB::scalar(\r\n        \"select count(case when food = 'burger' then 1 end) as burgers from menu\"\r\n    );\r\n\r\n<a name=\"using-named-bindings\"></a>\r\n#### 使用命名绑定\r\n\r\n除了使用`?`表示参数绑定外，你还可以使用命名绑定的形式来执行一个查询：\r\n\r\n    $results = DB::select('select * from users where id = :id', ['id' => 1]);\r\n\r\n<a name=\"running-an-insert-statement\"></a>\r\n#### 执行 Insert 语句\r\n\r\n你可以使用`DB` Facade 的`insert`方法来执行语句。跟`select`方法一样，该方法的第一个和第二个参数分别是原生 SQL 语句和绑定的数据：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);\r\n\r\n<a name=\"running-an-update-statement\"></a>\r\n#### 执行 Update 语句\r\n\r\n`update`方法用于更新数据库中现有的记录。该方法将会返回受到本次操作影响的记录行数：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $affected = DB::update(\r\n        'update users set votes = 100 where name = ?',\r\n        ['Anita']\r\n    );\r\n\r\n<a name=\"running-a-delete-statement\"></a>\r\n#### 执行 Delete 语句\r\n\r\n\n\n`delete` 函数被用于删除数据库中的记录。它的返回值与 `update` 函数相同，返回本次操作受影响的总行数。\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $deleted = DB::delete('delete from users');\r\n\r\n<a name=\"执行指定的 SQL\"></a>\r\n#### 执行指定的 SQL\r\n\r\n部分 SQL 语句不返回任何值。在这种情况下，你可能需要使用 `DB::statement($sql)` 来执行你的 SQL 语句。\r\n\r\n    DB::statement('drop table users');\r\n\r\n<a name=\"直接执行 SQL\"></a>\r\n#### 直接执行 SQL\r\n\r\n有时候你可能想执行一段 SQL 语句，但不需要进行 SQL 预处理绑定。这种情况下你可以使用 `DB::unprepared($sql)` 来执行你的 SQL 语句。\r\n\r\n    DB::unprepared('update users set votes = 100 where name = \"Dries\"');\r\n\r\n> **注意**  \r\n> 未经过预处理 SQL 的语句不绑定参数，它们可能容易受到 SQL 注入的攻击。在没有必要的理由的情况下，你不应直接在 SQL 中使用用户传入的数据。\r\n\r\n<a name=\"在事务中的隐式提交\"></a>\r\n#### 在事务中的隐式提交\r\n\r\n在事务中使用 `DB::statement($sql)` 与 `DB::unprepared($sql)` 时，你必须要谨慎处理，避免 SQL 语句产生[隐式提交](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html)。这些语句会导致数据库引擎间接地提交整个事务, 让 Laravel 丢失数据库当前的事务级别。下面是一个会产生隐式提交的示例 SQL：创建一个数据库表。\r\n\r\n    DB::unprepared('create table a (col varchar(1) null)');\r\n\r\n请参考[MySQL 官方手册](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html)以了解更多隐式提交的信息。\r\n\r\n<a name=\"使用多数据库连接\"></a>\r\n### 使用多数据库连接\r\n\r\n\n\n如果你在配置文件 `config/database.php` 中定义了多个数据库连接的话，你可以通过 DB Facade 的 `connection` 方法来使用它们。传递给 `connection` 方法的连接名称应该是你在 `config/database.php` 里或者通过 `config` 助手函数在运行时配置的连接之一：\r\n\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::connection('sqlite')->select(/* ... */);\r\n\r\n你也可以使用一个连接实例上的 `getPdo` 方法来获取底层的 PDO 实例：\r\n\r\n    $pdo = DB::connection()->getPdo();\r\n\r\n<a name=\"listening-for-query-events\"></a>\r\n### 监听查询事件\r\n\r\n如果你想要获取程序执行的每一条 SQL 语句，可以使用 `Db` facade 的 `listen` 方法。该方法对查询日志和调试非常有用，你可以在 [服务提供者](/docs/laravel/10.x/providers) 中使用 `boot` 方法注册查询监听器。\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Database\\Events\\QueryExecuted;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用服务\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任意应用服务\r\n         */\r\n        public function boot(): void\r\n        {\r\n            DB::listen(function (QueryExecuted $query) {\r\n                // $query->sql;\r\n                // $query->bindings;\r\n                // $query->time;\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"monitoring-cumulative-query-time\"></a>\r\n### 监控累积查询时间\r\n\r\n现代web应用程序的一个常见性能瓶颈是查询数据库所花费的时间。幸运的是，当Laravel在单个请求中花费了太多时间查询数据库时，它可以调用你定义的闭包或回调。要使用它，你可以调用 `whenQueryingForLongerThan` 方法并提供查询时间阀值(以毫秒为单位)和一个闭包作为参数。你可以在[服务提供者](/docs/laravel/10.x/providers) 的 `boot` 方法中调用此方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Database\\Connection;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Illuminate\\Database\\Events\\QueryExecuted;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任意应用服务\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任意应用服务\r\n         */\r\n        public function boot(): void\r\n        {\r\n            DB::whenQueryingForLongerThan(500, function (Connection $connection, QueryExecuted $event) {\r\n                // 通知开发团队...\r\n            });\r\n        }\r\n    }\r\n\r\n\n\n<a name=\"database-transactions\"></a>\r\n##  数据库事务\r\n\r\n想要在数据库事务中运行一系列操作，你可以使用 <code>DB</code> 门面的 <code>transaction</code> 方法。如果在事务的闭包中出现了异常，事务将会自动回滚。如果闭包执行成功，事务将会自动提交。在使用 <code>transaction</code> 方法时不需要手动回滚或提交：\r\n\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::transaction(function () {\r\n        DB::update('update users set votes = 1');\r\n\r\n        DB::delete('delete from posts');\r\n    });\r\n\r\n<a name=\"handling-deadlocks\"></a>\r\n#### 处理死锁\r\n\r\n<code>transaction</code> 方法接受一个可选的第二个参数，该参数定义发生死锁时事务应重试的次数。一旦这些尝试用尽，就会抛出一个异常：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::transaction(function () {\r\n        DB::update('update users set votes = 1');\r\n\r\n        DB::delete('delete from posts');\r\n    }, 5);\r\n\r\n<a name=\"manually-using-transactions\"></a>\r\n#### 手动执行事务\r\n\r\n如果你想要手动处理事务并完全控制回滚和提交，可以使用 <code>DB</code> 门面提供的 <code>beginTransaction</code> 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::beginTransaction();\r\n\r\n你可以通过 <code>rollBack</code> 方法回滚事务：\r\n\r\n    DB::rollBack();\r\n\r\n最后，你可以通过 <code>commit</code> 方法提交事务：\r\n\r\n    DB::commit();\r\n\r\n> **技巧**  \r\n> <code>DB</code> 门面的事务方法还可以用于控制 [查询构造器](/docs/laravel/10.x/queries) and [Eloquent ORM](/docs/laravel/10.x/eloquent).\r\n\r\n<a name=\"connecting-to-the-database-cli\"></a>\r\n## 连接到数据库 CLI\r\n\r\n\n\n如果你想连接到数据库的 CLI，则可以使用 <code>db</code> Artisan 命令：\r\n\r\n```shell\r\nphp artisan db\r\n```\r\n\r\n如果需要，你可以指定数据库连接名称以连接到不是默认连接的数据库连接：\r\n\r\n```shell\r\nphp artisan db mysql\r\n```\r\n\r\n<a name=\"inspecting-your-databases\"></a>\r\n## 检查你的数据库\r\n\r\n使用 <code>db:show</code> 和 <code>db:table</code> Artisan 命令，你可以深入了解数据库及其相关的表。要查看数据库的概述，包括它的大小、类型、打开的连接数以及表的摘要，你可以使用 <code>db:show</code> 命令：\r\n\r\n```shell\r\nphp artisan db:show\r\n```\r\n\r\n你可以通过 <code>--database</code> 选项向命令提供数据库连接名称来指定应该检查哪个数据库连接:\r\n\r\n\r\n```shell\r\nphp artisan db:show --database=pgsql\r\n```\r\n\r\n如果希望在命令的输出中包含表行计数和数据库视图详细信息，你可以分别提供 <code>--counts</code> 和 <code>--views</code> 选项。在大型数据库上，检索行数和视图详细信息可能很慢:\r\n\r\n```shell\r\nphp artisan db:show --counts --views\r\n```\r\n\r\n<a name=\"table-overview\"></a>\r\n#### 表的摘要信息\r\n\r\n如果你想获得数据库中单张表的概览，你可以执行 <code>db:table</code> Artisan命令。这个命令提供了一个数据库表的概览，包括它的列、类型、属性、键和索引:\r\n\r\n```shell\r\nphp artisan db:table users\r\n```\r\n\r\n<a name=\"monitoring-your-databases\"></a>\r\n## 监视数据库\r\n\r\n使用 <code>db:monitor</code> Artisan命令，如果你的数据库正在管理超过指定数量的打开连接，可以通过 Laravel 调度触发 <code>Illuminate\\Database\\Events\\DatabaseBusy</code> 事件。\r\n\r\n\n\n开始, 你应该将 `db:monitor` 命令安排为 [每分钟运行一次](/docs/laravel/10.x/scheduling)。 该命令接受要监视的数据库连接配置的名称，以及在分派事件之前应允许的最大打开连接数：\r\n\r\n```shell\r\nphp artisan db:monitor --databases=mysql,pgsql --max=100\r\n```\r\n\r\n仅调度此命令不足以触发通知，提醒你打开的连接数。当命令遇到打开连接计数超过阈值的数据库时，将调度 `DatabaseBusy` 事件。你应该在应用程序的 `EventServiceProvider` 中侦听此事件，以便向你或你的开发团队发送通知\r\n\r\n```php\r\nuse App\\Notifications\\DatabaseApproachingMaxConnections;\r\nuse Illuminate\\Database\\Events\\DatabaseBusy;\r\nuse Illuminate\\Support\\Facades\\Event;\r\nuse Illuminate\\Support\\Facades\\Notification;\r\n\r\n/**\r\n * 为应用程序注册任何其他事件。\r\n */\r\npublic function boot(): void\r\n{\r\n    Event::listen(function (DatabaseBusy $event) {\r\n        Notification::route('mail', 'dev@example.com')\r\n                ->notify(new DatabaseApproachingMaxConnections(\r\n                    $event->connectionName,\r\n                    $event->connections\r\n                ));\r\n    });\r\n}\r\n```\r\n\n","p":"docs/database.html"},{"t":"queries (数据库：查询生成器)","d":"# 数据库：查询生成器\r\n\r\n-   [介绍](#introduction)\r\n-   [运行数据库查询](#running-database-queries)\r\n    -   [分块结果](#chunking-results)\r\n    -   [延迟流式处理结果](#streaming-results-lazily)\r\n    -   [聚合](#aggregates)\r\n-   [Select 语句](#select-statements)\r\n-   [原始表达式](#raw-expressions)\r\n-   [Joins](#joins)\r\n-   [Unions](#unions)\r\n-   [基础 Where 语句](#basic-where-clauses)\r\n    -   [条件查询语句](#where-clauses)\r\n    -   [Or Where 语句](#or-where-clauses)\r\n    -   [Where Not 语句](#where-not-clauses)\r\n    -   [JSON Where 语句](#json-where-clauses)\r\n    -   [附加 Where 语句](#additional-where-clauses)\r\n    -   [逻辑分组](#logical-grouping)\r\n-   [高级 Where 语句](#advanced-where-clauses)\r\n    -   [Where Exists 语句](#where-exists-clauses)\r\n    -   [子查询 Where 语句](#subquery-where-clauses)\r\n    -   [全文 Where 子句](#full-text-where-clauses)\r\n-   [排序、分组、限制和偏移量](#ordering-grouping-limit-and-offset)\r\n    -   [排序](#ordering)\r\n    -   [分组](#grouping)\r\n    -   [Limit（限制） & Offset（偏移量）](#limit-and-offset)\r\n-   [条件语句](#conditional-clauses)\r\n-   [插入语句](#insert-statements)\r\n    -   [更新插入](#upserts)\r\n-   [更新语句](#update-statements)\r\n    -   [更新 JSON 列](#updating-json-columns)\r\n    -   [自增和自减](#increment-and-decrement)\r\n-   [删除语句](#delete-statements)\r\n-   [悲观锁](#pessimistic-locking)\r\n-   [调试](#debugging)\r\n\r\n<a name=\"introduction\"></a>\r\n\r\n## 介绍\r\n\r\nLaravel 的数据库查询生成器提供了一种便捷、流畅的接口来创建和运行数据库查询。它可用于执行应用程序中的大多数数据库操作，并与 Laravel 支持的所有数据库系统完美配合使用。\r\n\r\nLaravel 查询生成器使用 PDO 参数绑定来保护你的应用程序免受 SQL 注入攻击。无需清理或净化传递给查询生成器的字符串作为查询绑定。\r\n\r\n> **警告**\r\n> PDO 不支持绑定列名。因此，你不应该允许用户输入来决定查询引用的列名，包括 「order by」 列名。\r\n\r\n<a name=\"running-database-queries\"></a>\r\n\r\n## 运行数据库查询\r\n\r\n<a name=\"retrieving-all-rows-from-a-table\"></a>\r\n#### 从表中检索所有行\r\n\r\n你可以使用 <code>DB</code> facade 提供的 <code>table</code> 方法开始查询。table 方法为指定的表返回一个链式查询构造器实例，允许在查询上链接更多约束，最后使用 <code>get</code> 方法检索查询结果：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 展示应用程序所有用户的列表\r\n         */\r\n        public function index(): View\r\n        {\r\n            $users = DB::table('users')->get();\r\n\r\n            return view('user.index', ['users' => $users]);\r\n        }\r\n    }\r\n\r\n<code>get</code> 方法返回包含查询结果的 <code>Illuminate\\Support\\Collection</code> 实例，每个结果都是 PHP <code>stdClass</code> 实例。可以将列作为对象的属性来访问每列的值：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::table('users')->get();\r\n\r\n    foreach ($users as $user) {\r\n        echo $user->name;\r\n    }\r\n\r\n> **技巧:**  \r\n> Laravel 集合提供了各种及其强大的方法来映射和裁剪数据。有关 Laravel 集合的更多信息，请查看 [集合文档](/docs/laravel/10.x/collections).\r\n\r\n<a name=\"retrieving-a-single-row-column-from-a-table\"></a>\r\n#### 从表中检索单行或单列\r\n\r\n如果只需要从数据表中检索单行，可以使用 <code>DB</code> facade 中的 <code>first</code> 方法。 此方法将返回单个 <code>stdClass</code> 对象\r\n\r\n    $user = DB::table('users')->where('name', 'John')->first();\r\n\r\n    return $user->email;\r\n\r\n\r\n\r\n如果不想要整行，可以使用 `value` 方法从纪录中提取单个值。此方法将直接返回列的值：\r\n\r\n    $email = DB::table('users')->where('name', 'John')->value('email');\r\n\r\n如果要通过 `id` 字段值获取单行数据，可以使用 `find` 方法：\r\n\r\n    $user = DB::table('users')->find(3);\r\n\r\n<a name=\"retrieving-a-list-of-column-values\"></a>\r\n#### 获取某一列的值\r\n\r\n如果要获取包含单列值的 `Illuminate\\Support\\Collection` 实例，则可以使用 `pluck` 方法。在下面的例子中，我们将获取角色表中标题的集合：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $titles = DB::table('users')->pluck('title');\r\n\r\n    foreach ($titles as $title) {\r\n        echo $title;\r\n    }\r\n\r\n你可以通过向 `pluck` 方法提供第二个参数来指定结果集中要作为键的列：\r\n\r\n    $titles = DB::table('users')->pluck('title', 'name');\r\n\r\n    foreach ($titles as $name => $title) {\r\n        echo $title;\r\n    }\r\n\r\n<a name=\"chunking-results\"></a>\r\n### 分块结果\r\n\r\n如果需要处理成千上万的数据库记录，请考虑使用 `DB` 提供的 `chunk` 方法。这个方法一次检索一小块结果，并将每个块反馈到闭包函数中进行处理。例如，让我们以一次 100 条记录的块为单位检索整个 `users` 表：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {\r\n        foreach ($users as $user) {\r\n            // ...\r\n        }\r\n    });\r\n\r\n你可以通过从闭包中返回 `false` 来停止处理其余的块:\r\n\r\n    DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {\r\n        // 处理分块...\r\n\r\n        return false;\r\n    });\r\n\r\n\r\n\r\n如果在对结果进行分块时更新数据库记录，那分块结果可能会以意想不到的方式更改。如果你打算在分块时更新检索到的记录，最好使用 `chunkById` 方法。此方法将根据记录的主键自动对结果进行分页:\r\n\r\n    DB::table('users')->where('active', false)\r\n        ->chunkById(100, function (Collection $users) {\r\n            foreach ($users as $user) {\r\n                DB::table('users')\r\n                    ->where('id', $user->id)\r\n                    ->update(['active' => true]);\r\n            }\r\n        });\r\n\r\n> **注意**  \r\n> 当在更新或删除块回调中的记录时，对主键或外键的任何更改都可能影响块查询。这可能会导致记录未包含在分块结果中。\r\n\r\n<a name=\"streaming-results-lazily\"></a>\r\n### Lazily 流式传输结果\r\n\r\n`lazy` 方法的工作方式类似于 [`chunk` 方法](#chunking-results)，因为它以块的形式执行查询。但是，`lazy()` 方法不是将每个块传递给回调，而是返回一个 [`LazyCollection`](/docs/laravel/10.x/collections#lazy-collections)，它可以让你与结果进行交互单个流：\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\DB;\r\n\r\nDB::table('users')->orderBy('id')->lazy()->each(function (object $user) {\r\n    // ...\r\n});\r\n```\r\n再一次，如果你打算在迭代它们时更新检索到的记录，最好使用 `lazyById` 或 `lazyByIdDesc` 方法。 这些方法将根据记录的主键自动对结果进行分页：\r\n\r\n```php\r\nDB::table('users')->where('active', false)\r\n    ->lazyById()->each(function (object $user) {\r\n        DB::table('users')\r\n            ->where('id', $user->id)\r\n            ->update(['active' => true]);\r\n    });\r\n```\r\n\r\n> **注意**  \r\n>在迭代记录时更新或删除记录时，对主键或外键的任何更改都可能影响块查询。这可能会导致记录不包含在结果中。\r\n\r\n\r\n\r\n<a name=\"aggregates\"></a>\r\n### 聚合函数\r\n\r\n查询构建器还提供了多种检索聚合值的方法，例如 `count`， `max`， `min`，`avg`和 `sum`。你可以在构建查询后调用这些方法中的任何一个：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::table('users')->count();\r\n\r\n    $price = DB::table('orders')->max('price');\r\n\r\n当然，你可以将这些方法与其他子句结合起来，以优化计算聚合值的方式：\r\n\r\n    $price = DB::table('orders')\r\n                    ->where('finalized', 1)\r\n                    ->avg('price');\r\n\r\n<a name=\"determining-if-records-exist\"></a>\r\n#### 判断记录是否存在\r\n\r\n除了通过 `count` 方法可以确定查询条件的结果是否存在之外，还可以使用  `exists` 和 `doesntExist` 方法：\r\n\r\n    if (DB::table('orders')->where('finalized', 1)->exists()) {\r\n        // ...\r\n    }\r\n\r\n    if (DB::table('orders')->where('finalized', 1)->doesntExist()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"select-statements\"></a>\r\n## Select 语句\r\n\r\n<a name=\"specifying-a-select-clause\"></a>\r\n#### 指定一个 Select 语句\r\n\r\n可能你并不总是希望从数据库表中获取所有列。 使用 `select` 方法，可以自定义一个 「select」 查询语句来查询指定的字段：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::table('users')\r\n                ->select('name', 'email as user_email')\r\n                ->get();\r\n\r\n`distinct` 方法会强制让查询返回的结果不重复：\r\n\r\n    $users = DB::table('users')->distinct()->get();\r\n\r\n如果你已经有了一个查询构造器实例，并且希望在现有的查询语句中加入一个字段，那么你可以使用 `addSelect` 方法：\r\n\r\n    $query = DB::table('users')->select('name');\r\n\r\n    $users = $query->addSelect('age')->get();\r\n\r\n\r\n\r\n<a name=\"raw-expressions\"></a>\r\n## 原生表达式\r\n\r\n当你需要在查询中插入任意的字符串时，你可以使用 `DB` 门面提供的 `raw` 方法以创建原生表达式。\r\n\r\n    $users = DB::table('users')\r\n                 ->select(DB::raw('count(*) as user_count, status'))\r\n                 ->where('status', '<>', 1)\r\n                 ->groupBy('status')\r\n                 ->get();\r\n\r\n> **警告**  \r\n> 原生语句作为字符串注入到查询中，因此必须格外小心避免产生 SQL 注入漏洞。\r\n\r\n<a name=\"raw-methods\"></a>\r\n### 原生方法。\r\n\r\n可以使用以下方法代替 `DB::raw`，将原生表达式插入查询的各个部分。**请记住，Laravel 无法保证所有使用原生表达式的查询都不受到 SQL 注入漏洞的影响。**\r\n\r\n<a name=\"selectraw\"></a>\r\n#### `selectRaw`\r\n\r\n`selectRaw` 方法可以用来代替 `addSelect(DB::raw(/* ... */))`。此方法接受一个可选的绑定数组作为其第二个参数：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->selectRaw('price * ? as price_with_tax', [1.0825])\r\n                    ->get();\r\n\r\n<a name=\"whereraw-orwhereraw\"></a>\r\n#### `whereRaw / orWhereRaw`\r\n\r\n`whereRaw` 和 `orWhereRaw` 方法可用于将原始 「where」子句注入你的查询。这些方法接受一个可选的绑定数组作为它们的第二个参数：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->whereRaw('price > IF(state = \"TX\", ?, 100)', [200])\r\n                    ->get();\r\n\r\n<a name=\"havingraw-orhavingraw\"></a>\r\n#### `havingRaw / orHavingRaw`\r\n\r\n`havingRaw` 和 `orHavingRaw` 方法可用于提供原始字符串作为 「having」子句的值。这些方法接受一个可选的绑定数组作为它们的第二个参数：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->select('department', DB::raw('SUM(price) as total_sales'))\r\n                    ->groupBy('department')\r\n                    ->havingRaw('SUM(price) > ?', [2500])\r\n                    ->get();\r\n\r\n\r\n\r\n<a name=\"orderbyraw\"></a>\r\n#### `orderByRaw`\r\n\r\norderByRaw 方法可用于将原生字符串设置为「order by」子句的值：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->orderByRaw('updated_at - created_at DESC')\r\n                    ->get();\r\n\r\n<a name=\"groupbyraw\"></a>\r\n### `groupByRaw`\r\n\r\ngroupByRaw 方法可以用于将原生字符串设置为 `group by` 子句的值：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->select('city', 'state')\r\n                    ->groupByRaw('city, state')\r\n                    ->get();\r\n\r\n<a name=\"joins\"></a>\r\n## Joins\r\n\r\n<a name=\"inner-join-clause\"></a>\r\n#### Inner Join 语句\r\n\r\n查询构造器也还可用于向查询中添加连接子句。若要执行基本的「inner join」，你可以对查询构造器实例使用 `join` 方法。传递给 `join` 方法的第一个参数是需要你连接到的表的名称，而其余参数指定连接的列约束。你甚至还可以在一个查询中连接多个表：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $users = DB::table('users')\r\n                ->join('contacts', 'users.id', '=', 'contacts.user_id')\r\n                ->join('orders', 'users.id', '=', 'orders.user_id')\r\n                ->select('users.*', 'contacts.phone', 'orders.price')\r\n                ->get();\r\n\r\n<a name=\"left-join-right-join-clause\"></a>\r\n#### Left Join / Right Join 语句\r\n\r\n如果你想使用「left join」或者「right join」代替「inner join」，可以使用 `leftJoin` 或者 `rightJoin` 方法。这两个方法与 `join` 方法用法相同：\r\n\r\n    $users = DB::table('users')\r\n                ->leftJoin('posts', 'users.id', '=', 'posts.user_id')\r\n                ->get();\r\n\r\n    $users = DB::table('users')\r\n                ->rightJoin('posts', 'users.id', '=', 'posts.user_id')\r\n                ->get();\r\n\r\n\r\n\r\n<a name=\"cross-join-clause\"></a>\r\n#### Cross Join 语句\r\n\r\n你可以使用 `crossJoin` 方法执行「交叉连接」。交叉连接在第一个表和被连接的表之间会生成笛卡尔积：\r\n\r\n    $sizes = DB::table('sizes')\r\n                ->crossJoin('colors')\r\n                ->get();\r\n\r\n<a name=\"advanced-join-clauses\"></a>\r\n#### 高级 Join 语句\r\n\r\n你还可以指定更高级的联接子句。首先，将闭包作为第二个参数传递给 `join` 方法。闭包将收到一个 `Illuminate\\Database\\Query\\JoinClause` 实例，该实例允许你指定对 `join` 子句的约束：\r\n\r\n    DB::table('users')\r\n            ->join('contacts', function (JoinClause $join) {\r\n                $join->on('users.id', '=', 'contacts.user_id')->orOn(/* ... */);\r\n            })\r\n            ->get();\r\n\r\n如果你想要在连接上使用「where」风格的语句，你可以在连接上使用 `JoinClause` 实例中的 `where` 和 `orWhere` 方法。这些方法会将列和值进行比较，而不是列和列进行比较：\r\n\r\n    DB::table('users')\r\n            ->join('contacts', function (JoinClause $join) {\r\n                $join->on('users.id', '=', 'contacts.user_id')\r\n                     ->where('contacts.user_id', '>', 5);\r\n            })\r\n            ->get();\r\n\r\n<a name=\"subquery-joins\"></a>\r\n#### 子连接查询\r\n\r\n你可以使用 `joinSub`，`leftJoinSub` 和 `rightJoinSub` 方法关联一个查询作为子查询。他们每一种方法都会接收三个参数：子查询、表别名和定义关联字段的闭包。如下面这个例子，获取含有用户最近一次发布博客时的 `created_at` 时间戳的用户集合：\r\n\r\n    $latestPosts = DB::table('posts')\r\n                       ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))\r\n                       ->where('is_published', true)\r\n                       ->groupBy('user_id');\r\n\r\n    $users = DB::table('users')\r\n            ->joinSub($latestPosts, 'latest_posts', function (JoinClause $join) {\r\n                $join->on('users.id', '=', 'latest_posts.user_id');\r\n            })->get();\r\n\r\n\r\n\r\n<a name=\"unions\"></a>\r\n## 联合\r\n\r\n查询构造器还提供了一种简洁的方式将两个或者多个查询「联合」在一起。例如，你可以先创建一个查询，然后使用 `union` 方法来连接更多的查询：\r\n\r\n    use Illuminate\\Support\\Facades\\DB;\r\n\r\n    $first = DB::table('users')\r\n                ->whereNull('first_name');\r\n\r\n    $users = DB::table('users')\r\n                ->whereNull('last_name')\r\n                ->union($first)\r\n                ->get();\r\n\r\n查询构造器不仅提供了 `union` 方法，还提供了一个 `unionAll` 方法。当查询结合 `unionAll` 方法使用时，将不会删除重复的结果。`unionAll` 方法的用法和 `union` 方法一样。\r\n\r\n<a name=\"basic-where-clauses\"></a>\r\n## 基础的 Where 语句\r\n\r\n<a name=\"where-clauses\"></a>\r\n### Where 语句\r\n\r\n你可以在 `where` 语句中使用查询构造器的 `where` 方法。调用 `where` 方法需要三个基本参数。第一个参数是字段的名称。第二个参数是一个操作符，它可以是数据库中支持的任意操作符。第三个参数是与字段比较的值。\r\n\r\n例如。在 `users` 表中查询 `votes` 字段等于 `100` 并且 `age` 字段大于 `35` 的数据：\r\n\r\n    $users = DB::table('users')\r\n                    ->where('votes', '=', 100)\r\n                    ->where('age', '>', 35)\r\n                    ->get();\r\n\r\n为了方便起见。如果你想要比较一个字段的值是否 `等于` 给定的值。你可以将这个给定的值作为第二个参数传递给 `where` 方法。那么，Laravel 会默认使用 `=` 操作符：\r\n\r\n    $users = DB::table('users')->where('votes', 100)->get();\r\n\r\n\r\n\r\n如上所述，你可以使用数据库支持的任意操作符：\r\n\r\n    $users = DB::table('users')\r\n                    ->where('votes', '>=', 100)\r\n                    ->get();\r\n\r\n    $users = DB::table('users')\r\n                    ->where('votes', '<>', 100)\r\n                    ->get();\r\n\r\n    $users = DB::table('users')\r\n                    ->where('name', 'like', 'T%')\r\n                    ->get();\r\n\r\n你也可以将一个条件数组传递给 `where` 方法。数组的每个元素都应该是一个数组，其中包是传递给 `where` 方法的三个参数：\r\n\r\n    $users = DB::table('users')->where([\r\n        ['status', '=', '1'],\r\n        ['subscribed', '<>', '1'],\r\n    ])->get();\r\n\r\n> **注意**\r\n> PDO 不支持绑定字段名。因此，你不应该允许让用户输入字段名进行查询引用，包括结果集「order by」语句。\r\n\r\n<a name=\"or-where-clauses\"></a>\r\n### Or Where 语句\r\n\r\n当链式调用多个 `where` 方法的时候，这些「where」语句将会被看成是 `and` 关系。另外，你也可以在查询语句中使用 `orWhere` 方法来表示 `or` 关系。orWhere 方法接收的参数和 where 方法接收的参数一样：\r\n\r\n    $users = DB::table('users')\r\n                        ->where('votes', '>', 100)\r\n                        ->orWhere('name', 'John')\r\n                        ->get();\r\n\r\n如果你需要在括号内对 「or」 条件进行分组，那么可以传递一个闭包作为 `orWhere` 方法的第一个参数：\r\n\r\n    $users = DB::table('users')\r\n                ->where('votes', '>', 100)\r\n                ->orWhere(function(Builder $query) {\r\n                    $query->where('name', 'Abigail')\r\n                          ->where('votes', '>', 50);\r\n                })\r\n                ->get();\r\n\r\n上面的示例将生成以下 SQL：\r\n\r\n```sql\r\nselect * from users where votes > 100 or (name = 'Abigail' and votes > 50)\r\n```\r\n\r\n> **注意**\r\n> 为避免全局作用域应用时出现意外，你应始终对 `orWhere` 调用进行分组。\r\n\r\n\r\n<a name=\"where-not-clauses\"></a>\r\n### Where Not 语句\r\n\r\n`whereNot` 和 `orWhereNot` 方法可用于否定一组给定的查询条件。例如, 下面的查询排除了正在清仓甩卖或价格低于 10 的产品：\r\n\r\n    $products = DB::table('products')\r\n                    ->whereNot(function (Builder $query) {\r\n                        $query->where('clearance', true)\r\n                              ->orWhere('price', '<', 10);\r\n                    })\r\n                    ->get();\r\n\r\n<a name=\"json-where-clauses\"></a>\r\n### JSON Where 语句\r\n\r\nLaravel 也支持 JSON 类型的字段查询，前提是数据库也支持 JSON 类型。目前，有 MySQL 5.7+、PostgreSQL、SQL Server 2016 和 SQLite 3.39.0 支持 JSON 类型 (with the [JSON1 extension](https://www.sqlite.org/json1.html))。可以使用 `->` 操作符来查询 JSON 字段：\r\n\r\n    $users = DB::table('users')\r\n                    ->where('preferences->dining->meal', 'salad')\r\n                    ->get();\r\n\r\n你可以使用 `whereJsonContains` 方法来查询 JSON 数组。但是 SQLite 数据库版本低于3.38.0时不支持该功能：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereJsonContains('options->languages', 'en')\r\n                    ->get();\r\n\r\n如果你的应用使用的是 MySQL 或者 PostgreSQL 数据库，那么你可以向 `whereJsonContains` 方法中传递一个数组类型的值：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereJsonContains('options->languages', ['en', 'de'])\r\n                    ->get();\r\n\r\n你可以使用 `whereJsonLength` 方法来查询 JSON 数组的长度：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereJsonLength('options->languages', 0)\r\n                    ->get();\r\n\r\n    $users = DB::table('users')\r\n                    ->whereJsonLength('options->languages', '>', 1)\r\n                    ->get();\r\n\r\n<a name=\"additional-where-clauses\"></a>\r\n### 其他 Where 语句\r\n\r\n**whereBetween / orWhereBetween**\r\n\r\n`whereBetween` 方法是用来验证字段的值是否在给定的两个值之间：\r\n\r\n    $users = DB::table('users')\r\n               ->whereBetween('votes', [1, 100])\r\n               ->get();\r\n\r\n\r\n\r\n**whereNotBetween / orWhereNotBetween**\r\n\r\n`whereNotBetween`方法用于验证字段的值是否不在给定的两个值范围之中：\r\n\r\n    $users = DB::table('users')\r\n                        ->whereNotBetween('votes', [1, 100])\r\n                        ->get();\r\n\r\n**whereBetweenColumns / whereNotBetweenColumns / orWhereBetweenColumns / orWhereNotBetweenColumns**\r\n\r\n`whereBetweenColumns` 方法用于验证字段是否在给定的两个字段的值的范围中：\r\n\r\n\r\n    $patients = DB::table('patients')\r\n                           ->whereBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])\r\n                           ->get();\r\n\r\n`whereNotBetweenColumns` 方法用于验证字段是否不在给定的两个字段的值的范围中：\r\n\r\n    $patients = DB::table('patients')\r\n                           ->whereNotBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])\r\n                           ->get();\r\n\r\n**whereIn / whereNotIn / orWhereIn / orWhereNotIn**\r\n\r\n`whereIn` 方法用于验证字段是否在给定的值数组中：\r\n\r\n    $users = DB::table('users')\r\n                        ->whereIn('id', [1, 2, 3])\r\n                        ->get();\r\n\r\n`whereIn` 方法用于验证字段是否不在给定的值数组中：\r\n\r\n    $users = DB::table('users')\r\n                        ->whereNotIn('id', [1, 2, 3])\r\n                        ->get();\r\n\r\n你也可以为`whereIn` 方法的第二个参数提供一个子查询：\r\n\r\n    $activeUsers = DB::table('users')->select('id')->where('is_active', 1);\r\n\r\n    $users = DB::table('comments')\r\n                        ->whereIn('user_id', $activeUsers)\r\n                        ->get();\r\n\r\n上面的例子将会转换为下面的 SQL 查询语句：\r\n\r\n```sql\r\nselect * from comments where user_id in (\r\n    select id\r\n    from users\r\n    where is_active = 1\r\n)\r\n```\r\n\r\n> **注意**  \r\n> 如果你需要判断一个整数的大数组 `whereIntegerInRaw` 或 `whereIntegerNotInRaw`方法可能会更适合，这种用法的内存占用更小。\r\n\r\n**whereNull / whereNotNull / orWhereNull / orWhereNotNull**\r\n\r\n`whereNull` 方法用于判断指定的字段的值是否是`NULL`：\r\n\r\n    $users = DB::table('users')\r\n                    ->whereNull('updated_at')\r\n                    ->get();\r\n\r\n\r\n\r\n`whereNotNull` 方法是用来验证给定字段的值是否不为 `NULL`:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereNotNull('updated_at')\r\n                    ->get();\r\n\r\n**whereDate / whereMonth / whereDay / whereYear / whereTime**\r\n\r\n`whereDate`  方法是用来比较字段的值与给定的日期值是否相等:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereDate('created_at', '2016-12-31')\r\n                    ->get();\r\n\r\n`whereMonth` 方法是用来比较字段的值与给定的月是否相等:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereMonth('created_at', '12')\r\n                    ->get();\r\n\r\n`whereDay` 方法是用来比较字段的值与给定的日是否相等:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereDay('created_at', '31')\r\n                    ->get();\r\n\r\n`whereYear`  方法是用来比较字段的值与给定的年是否相等:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereYear('created_at', '2016')\r\n                    ->get();\r\n\r\n`whereTime` 方法是用来比较字段的值与给定的时间是否相等:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereTime('created_at', '=', '11:20:45')\r\n                    ->get();\r\n\r\n**whereColumn / orWhereColumn**\r\n\r\n`whereColumn` 方法是用来比较两个给定字段的值是否相等:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereColumn('first_name', 'last_name')\r\n                    ->get();\r\n\r\n你也可以将比较运算符传递给 `whereColumn` 方法:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereColumn('updated_at', '>', 'created_at')\r\n                    ->get();\r\n\r\n你还可以向 `whereColumn` 方法中传递一个数组。这些条件将使用 `and` 运算符联接:\r\n\r\n    $users = DB::table('users')\r\n                    ->whereColumn([\r\n                        ['first_name', '=', 'last_name'],\r\n                        ['updated_at', '>', 'created_at'],\r\n                    ])->get();\r\n\r\n\r\n\r\n<a name=\"logical-grouping\"></a>\r\n### 逻辑分组\r\n\r\n有时你可能需要将括号内的几个「where」子句分组，以实现查询所需的逻辑分组。实际上应该将 `orWhere` 方法的调用分组到括号中，以避免不可预料的查询逻辑误差。因此可以传递闭包给 `where` 方法：\r\n\r\n    $users = DB::table('users')\r\n               ->where('name', '=', 'John')\r\n               ->where(function (Builder $query) {\r\n                   $query->where('votes', '>', 100)\r\n                         ->orWhere('title', '=', 'Admin');\r\n               })\r\n               ->get();\r\n\r\n你可以看到， 通过一个闭包写入 `where` 方法 构建一个查询构造器来约束一个分组。这个闭包接收一个查询实例，你可以使用这个实例来设置应该包含的约束。上面的例子将生成以下 SQL：\r\n\r\n```sql\r\nselect * from users where name = 'John' and (votes > 100 or title = 'Admin')\r\n```\r\n\r\n> **注意**  \r\n> 你应该用 `orWhere` 调用这个分组，以避免应用全局作用时出现意外。\r\n\r\n<a name=\"advanced-where-clauses\"></a>\r\n### 高级 Where 语句\r\n\r\n<a name=\"where-exists-clauses\"></a>\r\n### Where Exists 语句\r\n\r\n`whereExists` 方法允许你使用 `where exists` SQL 语句。 `whereExists` 方法接收一个闭包参数，该闭包获取一个查询构建器实例，从而允许你定义放置在 `exists` 子句中查询:\r\n\r\n    $users = DB::table('users')\r\n               ->whereExists(function (Builder $query) {\r\n                   $query->select(DB::raw(1))\r\n                         ->from('orders')\r\n                         ->whereColumn('orders.user_id', 'users.id');\r\n               })\r\n               ->get();\r\n\r\n或者，可以向 `whereExists` 方法提供一个查询对象，替换上面的闭包：\r\n\r\n    $orders = DB::table('orders')\r\n                    ->select(DB::raw(1))\r\n                    ->whereColumn('orders.user_id', 'users.id');\r\n\r\n    $users = DB::table('users')\r\n                        ->whereExists($orders)\r\n                        ->get();\r\n\r\n\r\n\r\n上面的两个示例都会生成如下的 `SQL` 语句\r\n\r\n```sql\r\nselect * from users\r\nwhere exists (\r\n    select 1\r\n    from orders\r\n    where orders.user_id = users.id\r\n)\r\n```\r\n\r\n<a name=\"subquery-where-clauses\"></a>\r\n### 子查询 Where 语句\r\n\r\n有时候，你可能需要构造一个 `where` 子查询，将子查询的结果与给定的值进行比较。你可以通过向 `where` 方法传递闭包和值来实现此操作。例如，下面的查询将检索最后一次「会员」购买记录是「Pro」类型的所有用户；\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Database\\Query\\Builder;\r\n\r\n    $users = User::where(function (Builder $query) {\r\n        $query->select('type')\r\n            ->from('membership')\r\n            ->whereColumn('membership.user_id', 'users.id')\r\n            ->orderByDesc('membership.start_date')\r\n            ->limit(1);\r\n    }, 'Pro')->get();\r\n\r\n或者，你可能需要构建一个 `where` 子句，将列与子查询的结果进行比较。你可以通过将列、运算符和闭包传递给 `where` 方法来完成此操作。例如，以下查询将检索金额小于平均值的所有收入记录；\r\n\r\n    use App\\Models\\Income;\r\n    use Illuminate\\Database\\Query\\Builder;\r\n\r\n    $incomes = Income::where('amount', '<', function (Builder $query) {\r\n        $query->selectRaw('avg(i.amount)')->from('incomes as i');\r\n    })->get();\r\n\r\n<a name=\"full-text-where-clauses\"></a>\r\n### 全文 Where 子句\r\n\r\n> **注意**  \r\n> MySQL 和 PostgreSQL 目前支持全文 where 子句。\r\n\r\n可以使用 `where FullText` 和 `orWhere FullText` 方法将全文「where」 子句添加到具有 [full text indexes](/docs/laravel/10.x/migrations#available-index-types) 的列的查询中。这些方法将由Laravel转换为适用于底层数据库系统的SQL。例如，使用MySQL的应用会生成 `MATCH AGAINST` 子句\r\n\r\n    $users = DB::table('users')\r\n               ->whereFullText('bio', 'web developer')\r\n               ->get();\r\n\r\n\r\n\r\n<a name=\"ordering-grouping-limit-and-offset\"></a>\r\n## Ordering, Grouping, Limit & Offset\r\n\r\n<a name=\"ordering\"></a>\r\n### 排序\r\n\r\n<a name=\"orderby\"></a>\r\n#### `orderBy` 方法\r\n\r\n`orderBy` 方法允许你按给定列对查询结果进行排序。`orderBy` 方法接受的第一个参数应该是你希望排序的列，而第二个参数确定排序的方向，可以是 `asc` 或 `desc`：\r\n\r\n    $users = DB::table('users')\r\n                    ->orderBy('name', 'desc')\r\n                    ->get();\r\n\r\n要按多列排序，你以根据需要多次调用 `orderBy`：\r\n\r\n    $users = DB::table('users')\r\n                    ->orderBy('name', 'desc')\r\n                    ->orderBy('email', 'asc')\r\n                    ->get();\r\n\r\n<a name=\"latest-oldest\"></a>\r\n#### `latest` 和 `oldest` 方法\r\n\r\n`latest` 和 `oldest` 方法可以方便让你把结果根据日期排序。查询结果默认根据数据表的 `created_at` 字段进行排序 。或者，你可以传一个你想要排序的列名，通过:\r\n\r\n    $user = DB::table('users')\r\n                    ->latest()\r\n                    ->first();\r\n\r\n<a name=\"random-ordering\"></a>\r\n#### 随机排序\r\n\r\n`inRandomOrder` 方法被用来将查询结果随机排序。例如，你可以使用这个方法去获得一个随机用户:\r\n\r\n    $randomUser = DB::table('users')\r\n                    ->inRandomOrder()\r\n                    ->first();\r\n\r\n<a name=\"removing-existing-orderings\"></a>\r\n#### 移除已存在的排序\r\n\r\n`reorder` 方法会移除之前已经被应用到查询里的排序:\r\n\r\n    $query = DB::table('users')->orderBy('name');\r\n\r\n    $unorderedUsers = $query->reorder()->get();\r\n\r\n当你调用 `reorder` 方法去移除所有已经存在的排序的时候，你可以传递一个列名和排序方式去重新排序整个查询:\r\n\r\n    $query = DB::table('users')->orderBy('name');\r\n\r\n    $usersOrderedByEmail = $query->reorder('email', 'desc')->get();\r\n\r\n\r\n\r\n<a name=\"grouping\"></a>\r\n### 分组\r\n\r\n<a name=\"groupby-having\"></a>\r\n#### `groupBy` 和 `having` 方法\r\n\r\n如你所愿，`groupBy` 和 `having` 方法可以将查询结果分组。`having` 方法的使用方法类似于 `where` 方法:\r\n\r\n    $users = DB::table('users')\r\n                    ->groupBy('account_id')\r\n                    ->having('account_id', '>', 100)\r\n                    ->get();\r\n\r\n你可以使用 `havingBetween` 方法在一个给定的范围内去过滤结果:\r\n\r\n    $report = DB::table('orders')\r\n                    ->selectRaw('count(id) as number_of_orders, customer_id')\r\n                    ->groupBy('customer_id')\r\n                    ->havingBetween('number_of_orders', [5, 15])\r\n                    ->get();\r\n\r\n你可以传多个参数给 `groupBy` 方法将多列分组:\r\n\r\n    $users = DB::table('users')\r\n                    ->groupBy('first_name', 'status')\r\n                    ->having('account_id', '>', 100)\r\n                    ->get();\r\n\r\n想要构造更高级的 `having` 语句, 看 [`havingRaw`](#raw-methods) 方法。\r\n\r\n<a name=\"limit-and-offset\"></a>\r\n### 限制和偏移量\r\n\r\n<a name=\"skip-take\"></a>\r\n#### `skip` 和 `take` 方法\r\n\r\n你可以使用 `skip` 和 `take` 方法去限制查询结果的返回数量或者在查询结果中跳过给定数量:\r\n\r\n    $users = DB::table('users')->skip(10)->take(5)->get();\r\n\r\n或者，你可以使用 `limit` 和 `offset` 方法。这些方法在功能上等同于 `take` 和 `skip` 方法, 如下\r\n\r\n    $users = DB::table('users')\r\n                    ->offset(10)\r\n                    ->limit(5)\r\n                    ->get();\r\n\r\n<a name=\"conditional-clauses\"></a>\r\n## 条件语句\r\n\r\n有时，可能希望根据另一个条件将某些查询子句应用于查询。例如，当传入 HTTP 请求有一个给定的值的时候你才需要使用一个`where` 语句。你可以使用 `when` 方法去实现:\r\n\r\n    $role = $request->string('role');\r\n\r\n    $users = DB::table('users')\r\n                    ->when($role, function (Builder $query, string $role) {\r\n                        $query->where('role_id', $role);\r\n                    })\r\n                    ->get();\r\n\r\n\r\n\r\n`when` 方法只有当第一个参数为 `true` 时才执行给定的闭包。如果第一个参数是 `false` ，闭包将不会被执行。因此，在上面的例子中，只有在传入的请求包含 `role` 字段且结果为 `true` 时，`when` 方法里的闭包才会被调用。\r\n\r\n你可以将另一个闭包作为第三个参数传递给 `when` 方法。这个闭包则旨在第一个参数结果为 `false` 时才会执行。为了说明如何使用该功能，我们将使用它来配置查询的默认排序：\r\n\r\n    $sortByVotes = $request->boolean('sort_by_votes');\r\n\r\n    $users = DB::table('users')\r\n                    ->when($sortByVotes, function (Builder $query, bool $sortByVotes) {\r\n                        $query->orderBy('votes');\r\n                    }, function (Builder $query) {\r\n                        $query->orderBy('name');\r\n                    })\r\n                    ->get();\r\n\r\n<a name=\"insert-statements\"></a>\r\n## 插入语句\r\n\r\n查询构造器也提供了一个 `insert` 方法来用于插入记录到数据库表中。`insert` 方法接受一个列名和值的数组：\r\n\r\n    DB::table('users')->insert([\r\n        'email' => 'kayla@example.com',\r\n        'votes' => 0\r\n    ]);\r\n\r\n你可以通过传递一个二维数组来实现一次插入多条记录。每一个数组都代表了一个应当插入到数据表中的记录：\r\n\r\n    DB::table('users')->insert([\r\n        ['email' => 'picard@example.com', 'votes' => 0],\r\n        ['email' => 'janeway@example.com', 'votes' => 0],\r\n    ]);\r\n\r\n`insertOrIgnore` 方法将会在插入数据库的时候忽略发生的错误。当使用该方法时，你应当注意，重复记录插入的错误和其他类型的错误都将被忽略，这取决于数据库引擎。例如， `insertOrIgnore` 将会 [绕过 MySQL 的严格模式](https://dev.mysql.com/doc/refman/en/sql-mode.html#ignore-effect-on-execution) ：\r\n\r\n    DB::table('users')->insertOrIgnore([\r\n        ['id' => 1, 'email' => 'sisko@example.com'],\r\n        ['id' => 2, 'email' => 'archer@example.com'],\r\n    ]);\r\n\r\n\r\n\r\n`insertUsing` 方法将在表中插入新记录，同时用子查询来确定应插入的数据：\r\n\r\n    DB::table('pruned_users')->insertUsing([\r\n        'id', 'name', 'email', 'email_verified_at'\r\n    ], DB::table('users')->select(\r\n        'id', 'name', 'email', 'email_verified_at'\r\n    )->where('updated_at', '<=', now()->subMonth()));\r\n\r\n<a name=\"auto-incrementing-ids\"></a>\r\n#### 自增 IDs\r\n\r\n如果数据表有自增 ID ，使用 `insertGetId` 方法来插入记录可以返回 ID 值：\r\n\r\n    $id = DB::table('users')->insertGetId(\r\n        ['email' => 'john@example.com', 'votes' => 0]\r\n    );\r\n\r\n> **注意**  \r\n> 当使用 PostgreSQL 时，`insertGetId` 方法将默认把 `id` 作为自动递增字段的名称。如果你要从其他「字段」来获取 ID ，则需要将字段名称作为第二个参数传递给 `insertGetId` 方法。\r\n\r\n<a name=\"upserts\"></a>\r\n### 更新插入\r\n\r\n`upsert` 方法是是插入不存在的记录和为已经存在记录更新值。该方法的第一个参数包含要插入或更新的值，而第二个参数列出了在关联表中唯一标识记录的列。 该方法的第三个也是最后一个参数是一个列数组，如果数据库中已经存在匹配的记录，则应该更新这些列：\r\n\r\n    DB::table('flights')->upsert(\r\n        [\r\n            ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],\r\n            ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]\r\n        ],\r\n        ['departure', 'destination'],\r\n        ['price']\r\n    );\r\n\r\n在上面的例子中，Laravel 会尝试插入两条记录。如果已经存在具有相同 `departure` 和 `destination` 列值的记录，Laravel 将更新该记录的 `price` 列。\r\n\r\n> **注意**  \r\n> 除 SQL Server 之外的所有数据库都要求 `upsert` 方法的第二个参数中的列具有「主」或「唯一」索引。 此外，MySQL 数据库驱动程序忽略 `upsert` 方法的第二个参数，并始终使用表的「主」和「唯一」索引来检测现有记录。\r\n\r\n\r\n\r\n<a name=\"update-statements\"></a>\r\n## 更新语句\r\n\r\n除了插入记录到数据库之外，查询构造器也可以使用 `update` 方法来更新已经存在的记录。`update` 方法像 `insert` 方法一样，接受一个列名和值的数组作为参数，它表示要更新的列和数据。`update` 方法返回受影响的行数。你可以使用 `where` 子句来限制 `update` 查询：\r\n\r\n    $affected = DB::table('users')\r\n                  ->where('id', 1)\r\n                  ->update(['votes' => 1]);\r\n\r\n<a name=\"update-or-insert\"></a>\r\n#### 更新或插入\r\n\r\n有时你可能希望更新数据库中的记录，但如果指定记录不存在的时候则创建它。在这种情况下，可以使用 `updateOrInsert` 方法。`updateOrInsert` 方法接受两个参数：一个用于查找记录的条件数组，以及一个包含要更改记录的键值对数组。\r\n\r\n`updateOrInsert` 方法将尝试使用第一个参数的列名和值来定位匹配的数据库记录。如果记录存在，则使用第二个参数更新其值。如果找不到指定记录，则会合并两个参数的属性来创建一条记录并将其插入：\r\n\r\n    DB::table('users')\r\n        ->updateOrInsert(\r\n            ['email' => 'john@example.com', 'name' => 'John'],\r\n            ['votes' => '2']\r\n        );\r\n\r\n<a name=\"updating-json-columns\"></a>\r\n### 更新 JSON 字段\r\n\r\n当更新一个 JSON 列的收，你可以使用 `->` 语法来更新 JSON 对象中恰当的键。此操作需要 MySQL 5.7+ 和 PostgreSQL 9.5+ 的数据库：\r\n\r\n    $affected = DB::table('users')\r\n                  ->where('id', 1)\r\n                  ->update(['options->enabled' => true]);\r\n\r\n\r\n\r\n<a name=\"increment-and-decrement\"></a>\r\n### 自增与自减\r\n\r\n查询构造器还提供了方便的方法来增加或减少给定列的值。这两种方法都至少接受一个参数：要修改的列。可以提供第二个参数来指定列应该增加或减少的数量：\r\n\r\n    DB::table('users')->increment('votes');\r\n\r\n    DB::table('users')->increment('votes', 5);\r\n\r\n    DB::table('users')->decrement('votes');\r\n\r\n    DB::table('users')->decrement('votes', 5);\r\n\r\n你还可以在操作期间指定要更新的其他列：\r\n\r\n    DB::table('users')->increment('votes', 1, ['name' => 'John']);\r\n\r\n此外，你可以使用 <code>incrementEach</code> 和 <code>decrementEach</code> 方法同时增加或减少多个列:\r\n\r\n    DB::table('users')->incrementEach([\r\n        'votes' => 5,\r\n        'balance' => 100,\r\n    ]);\r\n\r\n<a name=\"delete-statements\"></a>\r\n## 删除语句\r\n\r\n查询构建器的 <code>delete</code> 方法可用于从表中删除记录。 <code>delete</code> 方法返回受影响的行数。你可以通过在调用 <code>delete</code> 方法之前添加 <code>where</code> 子句来限制 <code>delete</code> 语句：\r\n\r\n    $deleted = DB::table('users')->delete();\r\n\r\n    $deleted = DB::table('users')->where('votes', '>', 100)->delete();\r\n\r\n如果你希望截断整个表，这将从表中删除所有记录并将自动递增 ID 重置为零，你可以使用 <code>truncate</code> 方法：\r\n\r\n    DB::table('users')->truncate();\r\n\r\n<a name=\"table-truncation-and-postgresql\"></a>\r\n#### 截断表 & PostgreSQL\r\n\r\n截断 PostgreSQL 数据库时，将应用 <code>CASCADE</code> 行为。这意味着其他表中所有与外键相关的记录也将被删除。\r\n\r\n\r\n\r\n<a name=\"悲观锁\"></a>\r\n## 悲观锁\r\n\r\n查询构建器还包括一些函数，可帮助你在执行 `select` 语句时实现「悲观锁」。 要使用「共享锁」执行语句，你可以调用 `sharedLock` 方法。共享锁可防止选定的行被修改，直到你的事务被提交：\r\n\r\n    DB::table('users')\r\n            ->where('votes', '>', 100)\r\n            ->sharedLock()\r\n            ->get();\r\n\r\n或者，你可以使用 `lockForUpdate` 方法。「update」锁可防止所选记录被修改或被另一个共享锁选中：\r\n\r\n    DB::table('users')\r\n            ->where('votes', '>', 100)\r\n            ->lockForUpdate()\r\n            ->get();\r\n\r\n<a name=\"调试\"></a>\r\n## 调试\r\n\r\n你可以在构建查询时使用 `dd` 和 `dump` 方法来转储当前查询绑定和 SQL。 `dd` 方法将显示调试信息，然后停止执行请求。 `dump` 方法将显示调试信息，但允许请求继续执行：\r\n\r\n    DB::table('users')->where('votes', '>', 100)->dd();\r\n\r\n    DB::table('users')->where('votes', '>', 100)->dump();\r\n\r\n","p":"docs/queries.html"},{"t":"pagination (数据库：分页)","d":"# 数据库：分页\r\n\r\n- [介绍](#介绍)\r\n- [基本用法](#基本用法)\r\n    - [对查询构造器结果进行分页](#对查询构造器结果进行分页)\r\n    - [Eloquent ORM 分页](#EloquentORM分页)\r\n    - [游标分页](#游标分页)\r\n    - [手动创建分页](#手动创建分页)\r\n    - [自定义分页 URL](#自定义分页URL)\r\n- [显示分页结果](#显示分页结果)\r\n    - [调整分页链接窗口](#调整分页链接窗口)\r\n    - [将结果转换为 JSON](#将结果转换为JSON)\r\n- [自定义分页视图](#自定义分页视图)\r\n    - [使用 Bootstrap](#使用Bootstrap)\r\n- [分页器实例方法](#分页器实例方法)\r\n- [游标分页器实例方法](#游标分页器实例方法)\r\n\r\n<a name=\"介绍\"></a>\r\n## 介绍\r\n在其他框架中，分页可能非常痛苦，我们希望 Laravel 的分页方法像一股新鲜空气。 Laravel 的分页器集成了 [query builder](/docs/laravel/10.x/queries) 和 [Eloquent ORM](/docs/laravel/10.x/eloquent)，并提供了方便、易于使用的无需任何配置的数据库记录分页。\r\n\r\n默认情况下，由分页器生成的 HTML 与 [Tailwind CSS 框架](https://tailwindcss.com/) 兼容，然而，引导分页支持也是可用的。\r\n\r\n<a name=\"tailwind-jit\"></a>\r\n#### Tailwind JIT\r\n\r\n如果你使用 Laravel 的默认 Tailwind 视图和 Tailwind JIT 引擎，你应该确保你的应用程序的 `tailwind.config.js` 文件的 `content` 关键引用 Laravel 的分页视图，这样它们的 Tailwind 类就不会被清除：\r\n\r\n```js\r\ncontent: [\r\n    './resources/**/*.blade.php',\r\n    './resources/**/*.js',\r\n    './resources/**/*.vue',\r\n    './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php',\r\n],\r\n```\r\n\r\n<a name=\"基础用法\"></a>\r\n## 基础用法\r\n\r\n<a name=\"对查询构造器结果进行分页\"></a>\r\n### 对查询构造器结果进行分页\r\n有几种方法可以对结果进行分页，最简单的方法是在 [query builder](/docs/laravel/10.x/queries) 或 [Eloquent query](/docs/laravel/10.x/eloquent) 上使用 `paginate` 方法， `paginate` 方法根据用户查看的当前页面自动设置查询的「limit」和「offset」，默认情况下，通过 HTTP 请求中的 `page` 查询字符串参数的值检测当前页面，Laravel会自动检测这个值，它也会自动插入到分页器生成的链接中。\r\n\r\n\r\n在下面的例子中，传递给 <code>paginate</code> 方法的唯一参数是你想要在一页中显示的记录数。在此例中，我们希望「每页」显示 <code>15</code> 条数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示应用中所有用户列表\r\n         */\r\n        public function index(): View\r\n        {\r\n            return view('user.index', [\r\n                'users' => DB::table('users')->paginate(15)\r\n            ]);\r\n        }\r\n    }\r\n\r\n<a name=\"simple-pagination\"></a>\r\n#### 简单分页\r\n\r\n该 <code>paginate</code> 方法会在查询数据库之前先计算与查询匹配的记录总数，从而让分页器知道总共需要有多少个页面来显示所有的记录。不过，如果你不打算在界面上显示总页数的话，那么计算记录总数是没有意义的。\r\n\r\n因此，如果你只需要显示一个简单的「上一页」和「下一页」链接的话， <code>simplePaginate</code> 方法是一个更高效的选择：\r\n\r\n\r\n    $users = DB::table('users')->simplePaginate(15);\r\n\r\n<a name=\"paginating-eloquent-results\"></a>\r\n### Eloquent ORM 分页\r\n\r\n你也可以对 [Eloquent](/docs/laravel/10.x/eloquent) 查询结果进行分页. 在下面的例子中，我们将 <code>App\\Models\\User</code> 模型按每页 15 条记录进行分页。如你所见，其语法与查询构造器分页基本相同：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::paginate(15);\r\n\r\n当然，你也可以在调用 <code>paginate</code> 方法之前为查询添加其他约束，例如 <code>where</code> 子句：\r\n\r\n    $users = User::where('votes', '>', 100)->paginate(15);\r\n\r\n\r\n\r\n你也可以在 Eloquent ORM 分页中使用 `simplePaginate`：\r\n\r\n    $users = User::where('votes', '>', 100)->simplePaginate(15);\r\n\r\n同样，您可以使用 `cursorPaginate` 方法对 Eloquent 模型进行游标分页：\r\n\r\n    $users = User::where('votes', '>', 100)->cursorPaginate(15);\r\n\r\n<a name=\"multiple-paginator-instances-per-page\"></a>\r\n#### 每页有多个 Paginator 实例\r\n\r\n有时你可能需要在应用程序呈现的单个屏幕上呈现两个单独的分页器。 但是，如果两个分页器实例都使用 `page` 查询字符串参数来存储当前页面，则两个分页器会发生冲突。 要解决此冲突，您可以通过提供给 `paginate`、`simplePaginate` 和 `cursorPaginate` 方法的第三个参数传递你希望用于存储分页器当前页面的查询字符串参数的名称：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where('votes', '>', 100)->paginate(\r\n        $perPage = 15, $columns = ['*'], $pageName = 'users'\r\n    );\r\n\r\n<a name=\"cursor-pagination\"></a>\r\n### 游标分页\r\n\r\n虽然 <code>paginate</code> 和 <code>simplePaginate</code> 使用 SQL「offset」 子句创建查询，但游标分页通过构造「where」子句来工作，这些子句比较查询中包含的有序列的值，提供所有可用的最有效的数据库性能 Laravel 的分页方法。 这种分页方法特别适合大型数据集和「无限」滚动用户界面。\r\n\r\n与基于偏移量的分页在分页器生成的 URL 的查询字符串中包含页码不同，基于游标的分页在查询字符串中放置一个「游标」字符串。游标是一个编码字符串，包含下一个分页查询应该开始分页的位置和它应该分页的方向：\r\n\r\n```nothing\r\nhttp://localhost/users?cursor=eyJpZCI6MTUsIl9wb2ludHNUb05leHRJdGVtcyI6dHJ1ZX0\r\n```\r\n\r\n\r\n\r\n你可以通过查询生成器提供的 `cursorPaginate` 方法创建基于游标的分页器实例。这个方法返回一个 `Illuminate\\Pagination\\CursorPaginator` 的实例：\r\n\r\n    $users = DB::table('users')->orderBy('id')->cursorPaginate(15);\r\n\r\n检索到游标分页器实例后，你可以像使用 `paginate` 和 `simplePaginate` 方法时一样[显示分页结果](displaying-pagination-results)。更多游标分页器提供的实例方法请参考[游标分页器实例方法文档](#cursor-paginator-instance-methods).\r\n\r\n> **注意**\r\n> 你的查询必须包含「order by」子句才能使用游标分页。\r\n\r\n<a name=\"cursor-vs-offset-pagination\"></a>\r\n#### 游标与偏移分页\r\n\r\n为了说明偏移分页和游标分页之间的区别，让我们检查一些示例 SQL 查询。 以下两个查询都将显示按 `id` 排序的 `users` 表的「第二页」结果：\r\n\r\n```sql\r\n# 偏移分页...\r\nselect * from users order by id asc limit 15 offset 15;\r\n\r\n# 游标分页...\r\nselect * from users where id > 15 order by id asc limit 15;\r\n```\r\n\r\n与偏移分页相比，游标分页查询具有以下优势：\r\n\r\n- 对于大型数据集，如果「order by」列被索引，游标分页将提供更好的性能。 这是因为「offset」子句会扫描所有先前匹配的数据。\r\n\r\n- 对于频繁写入的数据集，如果最近在用户当前查看的页面中添加或删除了结果，偏移分页可能会跳过记录或显示重复。\r\n\r\n但是，游标分页有以下限制：\r\n\r\n- 与 `simplePaginate` 一样，游标分页只能用于显示「下一个」和「上一个」链接，不支持生成带页码的链接。\r\n\r\n- 它要求排序基于至少一个唯一列或唯一列的组合。 不支持具有 `null` 值的列。\r\n\r\n-「order by」子句中的查询表达式仅在它们被别名并添加到「select」子句时才受支持。\r\n\r\n\r\n\r\n\r\n<a name=\"manually-creating-a-paginator\"></a>\r\n### 手动创建分页\r\n\r\n有时你可能希望手动创建分页，并传递一个包含数据的数组给它。这可以通过手动创建 `Illuminate\\Pagination\\Paginator`, `Illuminate\\Pagination\\LengthAwarePaginator` 或者 `Illuminate\\Pagination\\CursorPaginator` 实例来实现，这取决于你的需要。\r\n\r\n`Paginator` 不需要知道数据的总数。然而，你也无法通过 `Paginator` 获取最后一页的索引。而 `LengthAwarePaginator` 接受和 `Paginator` 几乎相同的参数，不过，它会计算数据的总数。\r\n\r\n或者说，`Paginator` 相当于查询构造器或者 Eloquent ORM 分页的 `simplePaginate` 方法，而 `LengthAwarePaginator` 相当于 `paginate` 方法。\r\n\r\n> **注意**  \r\n> 手动创建分页器实例时，你应该手动「切片」传递给分页器的结果数组。如果你不确定如何执行此操作，请查看 [array_slice](https://secure.php.net/manual/en/function.array-slice.php) PHP 函数。\r\n\r\n<a name=\"customizing-pagination-urls\"></a>\r\n### 自定义分页的 URL\r\n\r\n默认情况下，分页器生成的链接会匹配当前的请求 URL。不过，分页器的 withPath 方法允许你自定义分页器生成链接时使用的 URL。比如说，你想要分页器生成类似 https://example.com/admin/users?page=N 的链接，你应该给 `withPath` 方法传递 `/admin/users` 参数：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        $users = User::paginate(15);\r\n\r\n        $users->withPath('/admin/users');\r\n\r\n        // ...\r\n    });\r\n\r\n\r\n\r\n<a name=\"appending-query-string-values\"></a>\r\n#### 附加参数到分页链接\r\n\r\n你可以使用 `appends` 方法向分页链接中添加查询参数。例如，要在每个分页链接中添加 `sort=votes` ，你应该这样调用 `appends`：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        $users = User::paginate(15);\r\n\r\n        $users->appends(['sort' => 'votes']);\r\n\r\n        // ...\r\n    });\r\n\r\n如果你想要把当前所有的请求查询参数添加到分页链接，你可以使用 `withQueryString` 方法：\r\n\r\n    $users = User::paginate(15)->withQueryString();\r\n\r\n<a name=\"appending-hash-fragments\"></a>\r\n#### 附加 hash 片段\r\n\r\n如果你希望向分页器的 URL 添加「哈希片段」，你可以使用 `fragment` 方法。例如，你可以使用 `fragment` 方法，为 `#user` 添加分页链接：\r\n\r\n    $users = User::paginate(15)->fragment('users');\r\n\r\n<a name=\"displaying-pagination-results\"></a>\r\n## 显示分页结果\r\n\r\n当调用 `paginate` 方法时， 你会得到一个 `Illuminate\\Pagination\\LengthAwarePaginator` 实例， 而调用 `simplePaginate` 方法时，会得到一个 `Illuminate\\Pagination\\Paginator` 实例。 最后，调用 `cursorPaginate` 方法，会得到 `Illuminate\\Pagination\\CursorPaginator` 实例。\r\n\r\n这些对象提供了数个方法来获取结果集的信息。除了这些辅助方法外，分页器的实例是迭代器，可以像数组一样遍历。所以，你可以使用 [Blade](/docs/laravel/10.x/blade) 模板来显示数据、渲染分页链接等：\r\n\r\n\r\n```blade\r\n<div class=\"container\">\r\n    @foreach ($users as $user)\r\n        {{ $user->name }}\r\n    @endforeach\r\n</div>\r\n\r\n{{ $users->links() }}\r\n```\r\n\r\nlinks 方法会渲染结果集中剩余页面的链接。每个链接都包含了 page 查询字符串变量。请记住，links 方法生成的 HTML 兼容 [Tailwind CSS 框架](https://tailwindcss.com) 。\r\n\r\n\r\n\r\n<a name=\"adjusting-the-pagination-link-window\"></a>\r\n### 调整分页链接窗口\r\n\r\n在使用分页器展示分页链接时，将展示当前页及当前页面前后各三页的链接。如果有需要，你可以通过 `onEachSide` 方法来控制每侧显示多少个链接：\r\n\r\n```blade\r\n{{ $users->onEachSide(5)->links() }}\r\n```\r\n\r\n<a name=\"converting-results-to-json\"></a>\r\n### 将结果转换为JSON\r\n\r\nLaravel 分页器类实现了 `Illuminate\\Contracts\\Support\\Jsonable` 接口契约，提供了 `toJson` 方法。这意味着你可以很方便地将分页结果转换为 JSON。你也可以通过直接在路由闭包或者控制器方法中返回分页实例来将其转换为 JSON：\r\n\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return User::paginate();\r\n    });\r\n\r\n分页器生成的 JSON 会包括诸如 `total`，`current_page`，`last_page`等元数据信息。实际结果对象将通过 JSON 数组的 `data` 键提供。以下是通过自路由中分页器实例的方式创建 JSON 的例子：\r\n\r\n    {\r\n       \"total\": 50,\r\n       \"per_page\": 15,\r\n       \"current_page\": 1,\r\n       \"last_page\": 4,\r\n       \"first_page_url\": \"http://laravel.app?page=1\",\r\n       \"last_page_url\": \"http://laravel.app?page=4\",\r\n       \"next_page_url\": \"http://laravel.app?page=2\",\r\n       \"prev_page_url\": null,\r\n       \"path\": \"http://laravel.app\",\r\n       \"from\": 1,\r\n       \"to\": 15,\r\n       \"data\":[\r\n            {\r\n                // 分页数据...\r\n            },\r\n            {\r\n                // 分页数据...\r\n            }\r\n       ]\r\n    }\r\n\r\n<a name=\"customizing-the-pagination-view\"></a>\r\n## 自定义分页视图\r\n\r\n默认情况下，分页器渲染的视图与 [Tailwind CSS](https://tailwindcss.com) 兼容。不过，如果你并非使用 Tailwind，你也可以自由地定义用于渲染这些链接的视图。在调用分页器实例的 `links` 方法时，将视图名称作为第一个参数传递给该方法：\r\n\r\n```blade\r\n{{ $paginator->links('view.name') }}\r\n\r\n<!-- 向视图传递参数... -->\r\n{{ $paginator->links('view.name', ['foo' => 'bar']) }}\r\n```\r\n\r\n\r\n\r\n不过，最简单的自定义分页视图的方法依然是使用 `vendor:publish` 命令将它们导出到 `resources/views/vendor` 目录：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=laravel-pagination\r\n```\r\n\r\n这个命令将会把分页视图导出到 `resources/views/vendor/pagination` 目录。该目录下的 `tailwind.blade.php` 文件就是默认的分页视图。你可以通过编辑这一文件来自定义分页视图。\r\n\r\n如果你想要定义不同的文件作为默认的分页视图，你可以在 `App\\Providers\\AppServiceProvider` 服务提供者中的 `boot` 方法内调用 `defaultView` 和 `defaultSimpleView` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Pagination\\Paginator;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 引导应用程序服务\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Paginator::defaultView('view-name');\r\n\r\n            Paginator::defaultSimpleView('view-name');\r\n        }\r\n    }\r\n\r\n<a name=\"using-bootstrap\"></a>\r\n### 使用 Bootstrap\r\n\r\nLaravel 同样包含使用 [Bootstrap CSS](https://getbootstrap.com/) 构建的分页视图。要使用这些视图来替代默认的 Tailwind 视图，你可以在 `App\\Providers\\AppServiceProvider` 服务提供者中的 `boot` 方法内调用分页器的 `useBootstrapFour` 或 `useBootstrapFive` 方法：\r\n\r\n    use Illuminate\\Pagination\\Paginator;\r\n\r\n    /**\r\n     * 引导应用程序服务\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Paginator::useBootstrapFive();\r\n        Paginator::useBootstrapFour();\r\n    }\r\n\r\n<a name=\"paginator-instance-methods\"></a>\r\n## 分页器实例方法\r\n\r\n每一个分页器实例都提供了下列方法来获取分页信息：\r\n\r\n方法  |  描述\r\n-------  |  -----------\r\n`$paginator->count()`  |  获取分页的总数据\r\n`$paginator->currentPage()`  |  获取当前页码\r\n`$paginator->firstItem()`  |  获取结果集中第一个数据的编号\r\n`$paginator->getOptions()`  |  获取分页器选项\r\n`$paginator->getUrlRange($start, $end)`  |  创建指定页数范围的 URL\r\n`$paginator->hasPages()`  |  是否有足够多的数据来创建多个页面\r\n`$paginator->hasMorePages()`  |  是否有更多的页面可供展示\r\n`$paginator->items()`  |  获取当前页的数据项\r\n`$paginator->lastItem()`  |  获取结果集中最后一个数据的编号\r\n`$paginator->lastPage()`  |  获取最后一页的页码（在`simplePaginate`中不可用）\r\n`$paginator->nextPageUrl()`  |  获取下一页的 URL\r\n`$paginator->onFirstPage()`  |  当前页是否为第一页\r\n`$paginator->perPage()`  |  获取每一页显示的数量总数\r\n`$paginator->previousPageUrl()`  |  获取上一页的 URL\r\n`$paginator->total()`  |  获取结果集中的数据总数（在 `simplePaginate`中不可用）\r\n`$paginator->url($page)`  |  获取指定页的 URL\r\n`$paginator->getPageName()`  |  获取用于储存页码的查询参数名\r\n`$paginator->setPageName($name)`  |  设置用于储存页码的查询参数名\r\n\r\n\r\n\r\n<a name=\"cursor-paginator-instance-methods\"></a>\r\n## 游标分页器实例方法\r\n\r\n每一个分页器实例都提供了下列额外方法来获取分页信息:\r\n\r\n方法  |  描述\r\n-------  |  -----------\r\n`$paginator->count()`  |  获取当前页的数据总数\r\n`$paginator->cursor()`  |  获取当前分页实例\r\n`$paginator->getOptions()`  |  获取分页参数选项\r\n`$paginator->hasPages()`  |  判断是否有足够数据用于分页\r\n`$paginator->hasMorePages()`  |  判断数据存储是否还有更多项目\r\n`$paginator->getCursorName()`  |  获取用于查询实例的变量名称\r\n`$paginator->items()`  | 获取当前页面的数据项目\r\n`$paginator->nextCursor()`  |  获取下一页数据实例\r\n`$paginator->nextPageUrl()`  | 获取下一页URL\r\n`$paginator->onFirstPage()`  |  判断页面是否属于第一页\r\n`$paginator->perPage()`  |  每页显示的数据数量\r\n`$paginator->previousCursor()`  |  获取上一页数据实例\r\n`$paginator->previousPageUrl()`  |  获取上一页URL\r\n`$paginator->setCursorName()`  |  设置用于查询实例的变量名称\r\n`$paginator->url($cursor)`  |  获取指定实例的 URL\r\n","p":"docs/pagination.html"},{"t":"migrations (数据库: 迁移)","d":"# 数据库: 迁移\r\n\r\n- [介绍](#introduction)\r\n- [生成迁移](#generating-migrations)\r\n    - [整合迁移](#squashing-migrations)\r\n- [迁移结构](#migration-structure)\r\n- [执行迁移](#running-migrations)\r\n    - [回滚迁移](#rolling-back-migrations)\r\n- [数据表](#tables)\r\n    - [创建数据表](#creating-tables)\r\n    - [更新数据表](#updating-tables)\r\n    - [重命名 / 删除表](#renaming-and-dropping-tables)\r\n- [字段](#columns)\r\n    - [创建字段](#creating-columns)\r\n    - [可用的字段类型](#available-column-types)\r\n    - [字段修饰符](#column-modifiers)\r\n    - [修改字段](#modifying-columns)\r\n    - [重命名字段](#renaming-columns)\r\n    - [删除字段](#dropping-columns)\r\n- [索引](#indexes)\r\n    - [创建索引](#creating-indexes)\r\n    - [重命名索引](#renaming-indexes)\r\n    - [删除索引](#dropping-indexes)\r\n    - [外键约束](#foreign-key-constraints)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n迁移就像数据库的版本控制，允许你的团队定义和共享应用程序的数据库架构定义。 如果你曾经不得不告诉团队成员在从代码控制中拉取更新后手动添加字段到他们的本地数据库，那么你就遇到了数据库迁移解决的问题。\r\n\r\nLaravel `Schema` [facade](/docs/laravel/10.x/facades) 为所有 Laravel 支持的数据库系统的创建和操作表提供了不依赖于数据库的支持。通常情况下，迁移会使用 facade 来创建和修改数据表和字段。\r\n\r\n<a name=\"generating-migrations\"></a>\r\n## 生成迁移\r\n\r\n你可以使用 `make:migration` [Artisan 命令](/docs/laravel/10.x/artisan) 来生成数据库迁移。新的迁移文件将放在你的 `database/migrations` 目录下。每个迁移文件名都包含一个时间戳来使 Laravel 确定迁移的顺序：\r\n\r\n```shell\r\nphp artisan make:migration create_flights_table\r\n```\r\n\r\nLaravel 将使用迁移文件的名称来猜测表名以及迁移是否会创建一个新表。如果 Laravel 能够从迁移文件的名称中确定表的名称，它将在生成的迁移文件中预填入指定的表，或者，你也可以直接在迁移文件中手动指定表名。\r\n\r\n\r\n如果要为生成的迁移指定自定义路径，你可以在执行 `make:migration` 命令时使用 `--path` 选项。给定的路径应该相对于应用程序的基本路径。\r\n\r\n> **技巧**  \r\n> 可以使用 [stub publishing](/docs/laravel/10.x/artisanmd#stub-customization) 自定义发布。\r\n\r\n<a name=\"squashing-migrations\"></a>\r\n### 整合迁移\r\n\r\n在构建应用程序时，可能会随着时间的推移积累越来越多的迁移。这可能会导致你的 `database/migrations` 目录因为数百次迁移而变得臃肿。你如果愿意的话，可以将迁移「压缩」到单个 SQL 文件中。如果你想这样做，请先执行`schema:dump` 命令：\r\n\r\n```shell\r\nphp artisan schema:dump\r\n\r\n# 转储当前数据库架构并删除所有现有迁移...\r\nphp artisan schema:dump --prune\r\n```\r\n\r\n执行此命令时，Laravel 将向应用程序的 `database/schema` 目录写入一个「schema」文件。现在，当你尝试迁移数据库而没有执行其他迁移时，Laravel 将首先执行模式文件的 SQL 语句。在执行数据库结构文件的语句之后，Laravel 将执行不属于数据库结构的剩余的所有迁移。\r\n\r\n如果你的应用程序的测试使用的数据库连接与你在本地开发过程中通常使用的不同，你应该确保你已经使用该数据库连接转储了一个 schema 文件，以便你的测试能够建立你的数据库。你可能希望在切换（dump）你在本地开发过程中通常使用的数据库连接之后再做这件事。\r\n\r\n```shell\r\nphp artisan schema:dump\r\nphp artisan schema:dump --database=testing --prune\r\n```\r\n\r\n\r\n\r\n你应该将数据库模式文件提交给源代码管理，以便团队中的其他新开发人员可以快速创建应用程序的初始数据库结构。\r\n\r\n> **注意**  \r\n> 整合迁移仅适用于 MySQL、PostgreSQL 和 SQLite 数据库，并使用数据库命令行的客户端。另外，数据库结构不能还原到内存中的 SQLite 数据库。\r\n\r\n<a name=\"migration-structure\"></a>\r\n## 迁移结构\r\n\r\n迁移类包含两个方法：`up` 和 `down` 。`up` 方法用于向数据库中添加新表、列或索引，而 down 方法用于撤销 `up` 方法执行的操作。.\r\n\r\n在这两种方法中，可以使用 Laravel 模式构建器来富有表现力地创建和修改表。要了解 `Schema` 构建器上可用的所有方法，[查看其文档](#creating-tables)。例如，以下迁移会创建一个 `flights` 表：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Database\\Migrations\\Migration;\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    return new class extends Migration\r\n    {\r\n        /**\r\n         * 执行迁移\r\n         */\r\n        public function up(): void\r\n        {\r\n            Schema::create('flights', function (Blueprint $table) {\r\n                $table->id();\r\n                $table->string('name');\r\n                $table->string('airline');\r\n                $table->timestamps();\r\n            });\r\n        }\r\n\r\n        /**\r\n         * 回滚迁移\r\n         */\r\n        public function down(): void\r\n        {\r\n            Schema::drop('flights');\r\n        }\r\n    };\r\n\r\n<a name=\"setting-the-migration-connection\"></a>\r\n#### 设置迁移连接\r\n\r\n如果你的迁移将与应用程序默认数据库连接以外的数据库连接进行交互，你应该设置迁移的 `$connection` 属性：\r\n\r\n    /**\r\n     * The database connection that should be used by the migration.\r\n     *\r\n     * @var string\r\n     */\r\n    protected $connection = 'pgsql';\r\n\r\n    /**\r\n     * 执行迁移\r\n     */\r\n    public function up(): void\r\n    {\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n<a name=\"running-migrations\"></a>\r\n## 执行迁移\r\n\r\n执行 Artisan 命令 `migrate`，来运行所有未执行过的迁移：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n如果你想查看目前已经执行了哪些迁移，可以使用 `migrate:status` Artisan 命令：\r\n\r\n```shell\r\nphp artisan migrate:status\r\n```\r\n\r\n如果你希望在不实际运行迁移的情况下看到将被执行的SQL语句，你可以在 `migrate` 命令中提供 `--pretend` 选项。\r\n\r\n```shell\r\nphp artisan migrate --pretend\r\n```\r\n\r\n#### 在隔离的环境中执行迁移\r\n\r\n如果你在多个服务器上部署你的应用程序，并在部署过程中运行迁移，你可能不希望两个服务器同时尝试迁移数据库。为了避免这种情况，你可以在调用 `migrate` 命令时使用 `isolated` 选项。\r\n\r\n当提供 `isolated` 选项时, Laravel 将使用你的应用程序缓存驱动获得一个原子锁，然后再尝试运行你的迁移。所有其他试图运行 `migrate` 命令的尝试在锁被持有时都不会执行; 然而, 命令仍然会以成功的退出状态码退出:\r\n\r\n```shell\r\nphp artisan migrate --isolated\r\n```\r\n\r\n> **注意**  \r\n> 要使用这个功能，你的应用程序必须使用 `memcached` / `redis` / `dynamodb` / `database` / `file`  或 `array` 缓存驱动作为你应用程序的默认缓存驱动。此外，所有的服务器必须与同一个中央缓存服务器进行通信。\r\n\r\n<a name=\"forcing-migrations-to-run-in-production\"></a>\r\n#### 在生产环境中执行强制迁移\r\n\r\n有些迁移操作是破坏性的，这意味着它们可能会导致数据丢失。为了防止你对生产数据库运行这些命令，在执行这些命令之前，系统将提示你进行确认。如果要在运行强制命令的时候去掉提示，需要加上 `--force` 标志：\r\n\r\n```shell\r\nphp artisan migrate --force\r\n```\r\n\r\n<a name=\"rolling-back-migrations\"></a>\r\n### 回滚迁移\r\n\r\n如果要回滚最后一次迁移操作，可以使用 Artisan 命令 `rollback`。该命令会回滚最后「一批」的迁移，这可能包含多个迁移文件：\r\n\r\n```shell\r\nphp artisan migrate:rollback\r\n```\r\n\r\n通过向 `rollback` 命令加上 `step` 参数，可以回滚指定数量的迁移。例如，以下命令将回滚最后五个迁移：\r\n\r\n```shell\r\nphp artisan migrate:rollback --step=5\r\n```\r\n\r\n你可以通过向 `rollback` 命令提供 `batch` 选项来回滚特定的批次迁移，其中 `batch` 选项对应于应用程序中 `migrations` 数据库表中的一个批次值。例如，下面的命令将回滚第三批中的所有迁移。\r\n\r\n```shell\r\nphp artisan migrate:rollback --batch=3\r\n```\r\n\r\n命令 `migrate:reset` 会回滚应用已运行过的所有迁移：\r\n\r\n```shell\r\nphp artisan migrate:reset\r\n```\r\n\r\n<a name=\"roll-back-migrate-using-a-single-command\"></a>\r\n#### 使用单个命令同时进行回滚和迁移操作\r\n\r\n命令 `migrate:refresh` 首先会回滚已运行过的所有迁移，随后会执行 `migrate`。这一命令可以高效地重建你的整个数据库：\r\n\r\n```shell\r\nphp artisan migrate:refresh\r\n\r\n# 重置数据库，并运行所有的 seeds...\r\nphp artisan migrate:refresh --seed\r\n```\r\n\r\n通过在命令 `refresh` 中使用 `step` 参数，你可以回滚并重新执行指定数量的迁移操作。例如，下列命令会回滚并重新执行最后五个迁移操作：\r\n\r\n```shell\r\nphp artisan migrate:refresh --step=5\r\n```\r\n\r\n<a name=\"drop-all-tables-migrate\"></a>\r\n#### 删除所有表然后执行迁移\r\n\r\n命令 `migrate:fresh` 会删去数据库中的所有表，随后执行命令 `migrate`：\r\n\r\n```shell\r\nphp artisan migrate:fresh\r\n\r\nphp artisan migrate:fresh --seed\r\n```\r\n\r\n> **注意**  \r\n> 该命令 `migrate:fresh` 在删去所有数据表的过程中，会无视它们的前缀。如果数据库涉及到其它应用，使用该命令须十分小心。\r\n\r\n<a name=\"tables\"></a>\r\n## 数据表\r\n\r\n<a name=\"creating-tables\"></a>\r\n### 创建数据表\r\n\r\n接下来我们将使用 Schema 的 `create` 方法创建一个新的数据表。`create` 接受两个参数：第一个参数是表名，而第二个参数是一个闭包，该闭包接受一个用来定义新数据表的 `Blueprint` 对象：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::create('users', function (Blueprint $table) {\r\n        $table->id();\r\n        $table->string('name');\r\n        $table->string('email');\r\n        $table->timestamps();\r\n    });\r\n\r\n创建表时，可以使用数据库结构构建器的 [列方法](#creating-columns) 来定义表的列。\r\n\r\n<a name=\"checking-for-table-column-existence\"></a>\r\n#### 检查表 / 列是否存在\r\n\r\n你可以使用 `hasTable` 和 `hasColumn` 方法检查表或列是否存在：\r\n\r\n    if (Schema::hasTable('users')) {\r\n        // 「users」表存在...\r\n    }\r\n\r\n    if (Schema::hasColumn('users', 'email')) {\r\n        // 「users」表存在，并且有「email」列...\r\n    }\r\n\r\n<a name=\"database-connection-table-options\"></a>\r\n#### 数据库连接和表选项\r\n\r\n如果要对不是应用程序默认的数据库连接执行数据库结构的操作，请使用 `connection` 方法：\r\n\r\n    Schema::connection('sqlite')->create('users', function (Blueprint $table) {\r\n        $table->id();\r\n    });\r\n\r\n此外，还可以使用其他一些属性和方法来定义表创建的其他地方。使用 MySQL 时，可以使用 `engine` 属性指定表的存储引擎：\r\n\r\n    Schema::create('users', function (Blueprint $table) {\r\n        $table->engine = 'InnoDB';\r\n\r\n        // ...\r\n    });\r\n\r\n`charset` 和 `collation` 属性可用于在使用 MySQL 时为创建的表指定字符集和排序规则：\r\n\r\n    Schema::create('users', function (Blueprint $table) {\r\n        $table->charset = 'utf8mb4';\r\n        $table->collation = 'utf8mb4_unicode_ci';\r\n\r\n        // ...\r\n    });\r\n\r\n`temporary` 方法可用于将表标识为「临时」状态。临时表仅对当前连接的数据库会话可见，当连接关闭时会自动删除：\r\n\r\n    Schema::create('calculations', function (Blueprint $table) {\r\n        $table->temporary();\r\n\r\n        // ...\r\n    });\r\n\r\n如果你想给数据库表添加「注释」，你可以在表实例上调用`comment`方法。目前只有 MySQL 和 Postgres 支持表注释：\r\n\r\n    Schema::create('calculations', function (Blueprint $table) {\r\n        $table->comment('Business calculations');\r\n\r\n        // ...\r\n    });\r\n\r\n<a name=\"更新数据表\"></a>\r\n### 更新数据表\r\n\r\n`Schema` 门面的 `table` 方法可用于更新现有表。与 `create` 方法一样，`table` 方法接受两个参数：表的名称和接收可用于向表添加列或索引的 `Blueprint` 实例的闭包：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->integer('votes');\r\n    });\r\n\r\n<a name=\"renaming-and-dropping-tables\"></a>\r\n### 重命名 / 删除表\r\n\r\n要重命名已存在的数据表，使用 `rename` 方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::rename($from, $to);\r\n\r\n要删除已存在的表，你可以使用 `drop` 或 `dropIfExists` 方法：\r\n\r\n    Schema::drop('users');\r\n\r\n    Schema::dropIfExists('users');\r\n\r\n<a name=\"renaming-tables-with-foreign-keys\"></a>\r\n#### 使用外键重命名表\r\n\r\n在重命名表之前，应该确认表的所有外键约束在迁移文件中有一个显式的名称，而不是让 Laravel 去指定。否则，外键约束名称将引用旧表名。\r\n\r\n<a name=\"columns\"></a>\r\n## 字段\r\n\r\n<a name=\"creating-columns\"></a>\r\n### 创建字段\r\n\r\n门面 `Schema` 的 `table` 方法可用于更新表。与 `create` 方法一样， `table` 方法接受两个参数：表名和一个闭包，该闭包接收一个 `illumb\\Database\\Schema\\Blueprint` 实例，可以使用该实例向表中添加列：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->integer('votes');\r\n    });\r\n\r\n<a name=\"可用的字段类型\"></a>\r\n### 可用的字段类型\r\n\r\nSchema 构建器 `Illuminate\\Database\\Schema\\Blueprint` 提供了多种方法，用来创建表中对应类型的列。下面列出了所有可用的方法：\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        columns: 10.8em 3; -moz-columns: 10.8em 3; -webkit-columns: 10.8em 3;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n    }\r\n\r\n    .collection-method code {\r\n        font-size: 14px;\r\n    }\r\n\r\n    .collection-method:not(.first-collection-method) {\r\n        margin-top: 50px;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[bigIncrements](#column-method-bigIncrements)\r\n[bigInteger](#column-method-bigInteger)\r\n[binary](#column-method-binary)\r\n[boolean](#column-method-boolean)\r\n[char](#column-method-char)\r\n[dateTimeTz](#column-method-dateTimeTz)\r\n[dateTime](#column-method-dateTime)\r\n[date](#column-method-date)\r\n[decimal](#column-method-decimal)\r\n[double](#column-method-double)\r\n[enum](#column-method-enum)\r\n[float](#column-method-float)\r\n[foreignId](#column-method-foreignId)\r\n[foreignIdFor](#column-method-foreignIdFor)\r\n[foreignUlid](#column-method-foreignUlid)\r\n[foreignUuid](#column-method-foreignUuid)\r\n[geometryCollection](#column-method-geometryCollection)\r\n[geometry](#column-method-geometry)\r\n[id](#column-method-id)\r\n[increments](#column-method-increments)\r\n[integer](#column-method-integer)\r\n[ipAddress](#column-method-ipAddress)\r\n[json](#column-method-json)\r\n[jsonb](#column-method-jsonb)\r\n[lineString](#column-method-lineString)\r\n[longText](#column-method-longText)\r\n[macAddress](#column-method-macAddress)\r\n[mediumIncrements](#column-method-mediumIncrements)\r\n[mediumInteger](#column-method-mediumInteger)\r\n[mediumText](#column-method-mediumText)\r\n[morphs](#column-method-morphs)\r\n[multiLineString](#column-method-multiLineString)\r\n[multiPoint](#column-method-multiPoint)\r\n[multiPolygon](#column-method-multiPolygon)\r\n[nullableMorphs](#column-method-nullableMorphs)\r\n[nullableTimestamps](#column-method-nullableTimestamps)\r\n[nullableUlidMorphs](#column-method-nullableUlidMorphs)\r\n[nullableUuidMorphs](#column-method-nullableUuidMorphs)\r\n[point](#column-method-point)\r\n[polygon](#column-method-polygon)\r\n[rememberToken](#column-method-rememberToken)\r\n[set](#column-method-set)\r\n[smallIncrements](#column-method-smallIncrements)\r\n[smallInteger](#column-method-smallInteger)\r\n[softDeletesTz](#column-method-softDeletesTz)\r\n[softDeletes](#column-method-softDeletes)\r\n[string](#column-method-string)\r\n[text](#column-method-text)\r\n[timeTz](#column-method-timeTz)\r\n[time](#column-method-time)\r\n[timestampTz](#column-method-timestampTz)\r\n[timestamp](#column-method-timestamp)\r\n[timestampsTz](#column-method-timestampsTz)\r\n[timestamps](#column-method-timestamps)\r\n[tinyIncrements](#column-method-tinyIncrements)\r\n[tinyInteger](#column-method-tinyInteger)\r\n[tinyText](#column-method-tinyText)\r\n[unsignedBigInteger](#column-method-unsignedBigInteger)\r\n[unsignedDecimal](#column-method-unsignedDecimal)\r\n[unsignedInteger](#column-method-unsignedInteger)\r\n[unsignedMediumInteger](#column-method-unsignedMediumInteger)\r\n[unsignedSmallInteger](#column-method-unsignedSmallInteger)\r\n[unsignedTinyInteger](#column-method-unsignedTinyInteger)\r\n[ulidMorphs](#column-method-ulidMorphs)\r\n[uuidMorphs](#column-method-uuidMorphs)\r\n[ulid](#column-method-ulid)\r\n[uuid](#column-method-uuid)\r\n[year](#column-method-year)\r\n\r\n</div>\r\n\r\n<a name=\"column-method-bigIncrements\"></a>\r\n#### `bigIncrements()` {.collection-method .first-collection-method}\r\n\r\n`bigIncrements` 方法用于在数据表中创建一个自增的 `UNSIGNED BIGINT` 类型（主键）的列：\r\n\r\n    $table->bigIncrements('id');\r\n\r\n<a name=\"column-method-bigInteger\"></a>\r\n#### `bigInteger()` {.collection-method}\r\n\r\n`bigInteger` 方法用于在数据表中创建一个 `BIGINT` 类型的列：\r\n\r\n    $table->bigInteger('votes');\r\n\r\n<a name=\"column-method-binary\"></a>\r\n#### `binary()` {.collection-method}\r\n\r\n`binary` 方法用于在数据表中创建一个 `BLOB` 类型的列：\r\n\r\n    $table->binary('photo');\r\n\r\n<a name=\"column-method-boolean\"></a>\r\n#### `boolean()` {.collection-method}\r\n\r\n`boolean` 方法用于在数据表中创建一个 `BOOLEAN` 类型的列：\r\n\r\n    $table->boolean('confirmed');\r\n\r\n<a name=\"column-method-char\"></a>\r\n#### `char()` {.collection-method}\r\n\r\n`char` 方法用于在数据表中创建一个 `CHAR` 类型的列，长度由参数指定：\r\n\r\n    $table->char('name', 100);\r\n\r\n<a name=\"column-method-dateTimeTz\"></a>\r\n#### `dateTimeTz()` {.collection-method}\r\n\r\n`dateTimeTz` 方法用于在数据表中创建一个 `DATETIME` 类型（附有 timezone）的列，可选参数为精度的总位数：\r\n\r\n    $table->dateTimeTz('created_at', $precision = 0);\r\n\r\n<a name=\"column-method-dateTime\"></a>\r\n#### `dateTime()` {.collection-method}\r\n\r\n`dateTime` 方法用于在数据表中创建一个 `DATETIME` 类型的列，可选参数为精度的总位数：\r\n\r\n    $table->dateTime('created_at', $precision = 0);\r\n\r\n<a name=\"column-method-date\"></a>\r\n#### `date()` {.collection-method}\r\n\r\n`date` 方法用于在数据表中创建一个 `DATE` 类型的列：\r\n\r\n    $table->date('created_at');\r\n\r\n<a name=\"column-method-decimal\"></a>\r\n#### `decimal()` {.collection-method}\r\n\r\n`decimal` 方法用于在数据表中创建一个 `DECIMAL` 类型的列，可选参数分别为有效字数总位数、小数部分总位数：\r\n\r\n    $table->decimal('amount', $precision = 8, $scale = 2);\r\n\r\n<a name=\"column-method-double\"></a>\r\n#### `double()` {.collection-method}\r\n\r\n`double` 方法用于在数据表中创建一个 `DOUBLE` 类型的列，可选参数分别为有效字数总位数、小数部分总位数：\r\n\r\n    $table->double('amount', 8, 2);\r\n\r\n<a name=\"column-method-enum\"></a>\r\n#### `enum()` {.collection-method}\r\n\r\n`enum` 方法用于在数据表中创建一个 `ENUM` 类型的列，合法的值列表由参数指定：\r\n\r\n    $table->enum('difficulty', ['easy', 'hard']);\r\n\r\n<a name=\"column-method-float\"></a>\r\n#### `float()` {.collection-method}\r\n\r\n `float` 方法用于在数据表中创建一个 `FLOAT` 类型的列，可选参数分别为有效字数总位数、小数部分总位数：\r\n\r\n    $table->float('amount', 8, 2);\r\n\r\n<a name=\"column-method-foreignId\"></a>\r\n#### `foreignId()` {.collection-method}\r\n\r\n`foreignId` 方法是 `unsignedBigInteger` 的别名：\r\n\r\n    $table->foreignId('user_id');\r\n\r\n<a name=\"column-method-foreignIdFor\"></a>\r\n#### `foreignIdFor()` {.collection-method}\r\n\r\n`foreignIdFor` 方法为给定模型类添加了 `{column}_id UNSIGNED BIGINT` 等效列：\r\n\r\n    $table->foreignIdFor(User::class);\r\n<a name=\"column-method-foreignUlid\"></a>\r\n#### `foreignUlid()` {.collection-method}\r\n\r\n`foreignUlid` 方法创建一个 `ULID` 等效列：\r\n\r\n    $table->foreignUlid('user_id');\r\n\r\n<a name=\"column-method-foreignUuid\"></a>\r\n#### `foreignUuid()` {.collection-method}\r\n`foreignUuid` 方法创建一个 `UUID` 等效列：\r\n```\r\n$table->foreignUuid('user_id');\r\n```\r\n\r\n<a name=\"column-method-geometryCollection\"></a>\r\n#### `geometryCollection()` {.collection-method}\r\n\r\n`geometryCollection` 方法相当于 `GEOMETRYCOLLECTION` :\r\n\r\n    $table->geometryCollection('positions');\r\n\r\n<a name=\"column-method-geometry\"></a>\r\n#### `geometry()` {.collection-method}\r\n\r\n`geometry` 方法相当于 `GEOMETRY` :\r\n\r\n    $table->geometry('positions');\r\n\r\n<a name=\"column-method-id\"></a>\r\n#### `id()` {.collection-method}\r\n\r\n `id` 方法是`bigIncrements` 的别名。默认情况下，该方法将创建一个 `id` 列; 但是，如果要为列指定不同的名称，则可以传递列名：\r\n\r\n    $table->id();\r\n\r\n<a name=\"column-method-increments\"></a>\r\n#### `increments()` {.collection-method}\r\n\r\n`increments` 方法创建一个自动递增相当于 `UNSIGNED INTEGER` 的列作为主键：\r\n\r\n    $table->increments('id');\r\n\r\n<a name=\"column-method-integer\"></a>\r\n#### `integer()` {.collection-method}\r\n\r\n`integer` 方法相当于 `INTEGER` ：\r\n\r\n    $table->integer('votes');\r\n\r\n<a name=\"column-method-ipAddress\"></a>\r\n#### `ipAddress()` {.collection-method}\r\n\r\n`ipAddress` 方法相当于 `VARCHAR` ：\r\n\r\n    $table->ipAddress('visitor');\r\n\r\n<a name=\"column-method-json\"></a>\r\n#### `json()` {.collection-method}\r\n\r\n`json` 方法相当于 `JSON`：\r\n\r\n    $table->json('options');\r\n\r\n<a name=\"column-method-jsonb\"></a>\r\n#### `jsonb()` {.collection-method}\r\n\r\n`jsonb` 方法相当于 `JSONB`：\r\n\r\n    $table->jsonb('options');\r\n\r\n<a name=\"column-method-lineString\"></a>\r\n#### `lineString()` {.collection-method}\r\n\r\n `lineString` 方法相当于 `LINESTRING`：\r\n\r\n    $table->lineString('positions');\r\n\r\n<a name=\"column-method-longText\"></a>\r\n#### `longText()` {.collection-method}\r\n\r\n `longText` 方法相当于 `LONGTEXT`：\r\n\r\n    $table->longText('description');\r\n\r\n<a name=\"column-method-macAddress\"></a>\r\n#### `macAddress()` {.collection-method}\r\n\r\n`macAddress` 方法创建一个用于保存 MAC 地址的列。一些数据库系统（如 PostgreSQL），为这种类型的数据提供了专用的类型。其他数据库系统相当于使用字符串类型：\r\n\r\n    $table->macAddress('device');\r\n\r\n<a name=\"column-method-mediumIncrements\"></a>\r\n#### `mediumIncrements()` {.collection-method}\r\n\r\n `mediumIncrements` 方法用于创建一个 `UNSIGNED MEDIUMINT` 类型的自动递增的列作为主键：\r\n\r\n    $table->mediumIncrements('id');\r\n\r\n<a name=\"column-method-mediumInteger\"></a>\r\n#### `mediumInteger()` {.collection-method}\r\n\r\n `mediumInteger` 方法用于创建一个 `MEDIUMINT` 类型的列：\r\n\r\n    $table->mediumInteger('votes');\r\n\r\n<a name=\"column-method-mediumText\"></a>\r\n#### `mediumText()` {.collection-method}\r\n\r\n`mediumText` 方法用于创建一个 `MEDIUMTEXT` 类型的列：\r\n\r\n    $table->mediumText('description');\r\n\r\n<a name=\"column-method-morphs\"></a>\r\n#### `morphs()` {.collection-method}\r\n\r\n `morphs` 方法用于快速创建一个名称为 `{column}_id` ，类型为 `UNSIGNED BIGINT` 的列和一个名称为 `{column}_type` ，类型为 `VARCHAR` 的列。\r\n\r\n这个方法在定义[多态关联](/docs/laravel/10.x/eloquent-relationships)所需的列时使用。在下面的例子中， `taggable_id` 和 `taggable_type` 这两个列会被创建：\r\n\r\n    $table->morphs('taggable');\r\n\r\n<a name=\"column-method-multiLineString\"></a>\r\n#### `multiLineString()` {.collection-method}\r\n\r\n `multiLineString` 方法用于创建一个 `MULTILINESTRING` 类型的列：\r\n\r\n    $table->multiLineString('positions');\r\n\r\n<a name=\"column-method-multiPoint\"></a>\r\n#### `multiPoint()` {.collection-method}\r\n\r\n `multiPoint` 方法用于创建一个 `MULTIPOINT` 类型的列：\r\n\r\n    $table->multiPoint('positions');\r\n\r\n<a name=\"column-method-multiPolygon\"></a>\r\n#### `multiPolygon()` {.collection-method}\r\n\r\n `multiPolygon` 方法用于创建一个 `MULTIPOLYGON` 类型的列：\r\n\r\n    $table->multiPolygon('positions');\r\n\r\n<a name=\"column-method-nullableTimestamps\"></a>\r\n#### `nullableTimestamps()` {.collection-method}\r\n\r\n这个方法和 [timestamps](#column-method-timestamps) 方法类似；需要注意的是此方法创建的列是 `nullable` 的：\r\n\r\n    $table->nullableTimestamps(0);\r\n\r\n<a name=\"column-method-nullableMorphs\"></a>\r\n#### `nullableMorphs()` {.collection-method}\r\n\r\n这个方法和 [morphs](#column-method-morphs) 方法类似；需要注意的是此方法创建的列是 `nullable` 的：\r\n\r\n    $table->nullableMorphs('taggable');\r\n\r\n<a name=\"column-method-nullableUlidMorphs\"></a>\r\n#### `nullableUlidMorphs()` {.collection-method}\r\n\r\n这个方法和 [ulidMorphs](#column-method-ulidMorphs) 方法类似；需要注意的是此方法创建的列是 `nullable`。\r\n\r\n    $table->nullableUlidMorphs('taggable');\r\n\r\n<a name=\"column-method-nullableUuidMorphs\"></a>\r\n#### `nullableUuidMorphs()` {.collection-method}\r\n\r\n这个方法和 [uuidMorphs](#column-method-uuidMorphs) 方法类似；需要注意的是此方法创建的列是 `nullable` 的：\r\n\r\n    $table->nullableUuidMorphs('taggable');\r\n\r\n<a name=\"column-method-point\"></a>\r\n#### `point()` {.collection-method}\r\n\r\n`point` 方法相当于 `POINT`：\r\n\r\n    $table->point('position');\r\n\r\n<a name=\"column-method-polygon\"></a>\r\n#### `polygon()` {.collection-method}\r\n\r\nThe `polygon` method creates a `POLYGON` equivalent column:\r\n\r\n    $table->polygon('position');\r\n\r\n<a name=\"column-method-rememberToken\"></a>\r\n#### `rememberToken()` {.collection-method}\r\n\r\n添加一个允许空值的 `VARCHAR (100)` 类型的 `remember_token` 字段，用于存储 [记住用户](/docs/laravel/10.x/authentication#remembering-users)：\r\n\r\n    $table->rememberToken();\r\n\r\n<a name=\"column-method-set\"></a>\r\n#### `set()` {.collection-method}\r\n\r\n`set` 方法使用给定的有效值列表创建一个 `SET` 等效列：\r\n\r\n    $table->set('flavors', ['strawberry', 'vanilla']);\r\n\r\n<a name=\"column-method-smallIncrements\"></a>\r\n#### `smallIncrements()` {.collection-method}\r\n\r\n`smallIncrements` 方法创建一个自动递增的 `UNSIGNED SMALLINT` 等效列作为主键：\r\n\r\n    $table->smallIncrements('id');\r\n\r\n<a name=\"column-method-smallInteger\"></a>\r\n#### `smallInteger()` {.collection-method}\r\n\r\n`smallInteger` 方法创建一个 `SMALLINT` 等效列：\r\n\r\n    $table->smallInteger('votes');\r\n\r\n<a name=\"column-method-softDeletesTz\"></a>\r\n\r\n\r\n#### `softDeletesTz()` {.collection-method}\r\n\r\n`softDeletesTz` 方法添加了一个可为空的 `deleted_at` `TIMESTAMP`（带时区）等效列，具有可选精度（总位数）。此列旨在存储 Eloquent 的“软删除”功能所需的 `deleted_at` 时间戳：\r\n\r\n    $table->softDeletesTz($column = 'deleted_at', $precision = 0);\r\n\r\n<a name=\"column-method-softDeletes\"></a>\r\n#### `softDeletes()` {.collection-method}\r\n\r\n`softDeletes` 方法添加了一个可为空的 `deleted_at` `TIMESTAMP` 等效列，具有可选精度（总位数）。此列旨在存储 Eloquent 的「软删除」功能所需的 `deleted_at` 时间戳，相当于为软删除添加一个可空的 `deleted_at` 字段：\r\n\r\n    $table->softDeletes($column = 'deleted_at', $precision = 0);\r\n\r\n<a name=\"column-method-string\"></a>\r\n#### `string()` {.collection-method}\r\n\r\n`string` 方法创建一个给定长度的 `VARCHAR` 等效列，相当于指定长度的 VARCHAR：\r\n\r\n    $table->string('name', 100);\r\n\r\n<a name=\"column-method-text\"></a>\r\n#### `text()` {.collection-method}\r\n\r\n`text` 方法创建一个 `TEXT` 等效列：\r\n\r\n    $table->text('description');\r\n\r\n<a name=\"column-method-timeTz\"></a>\r\n#### `timeTz()` {.collection-method}\r\n\r\n`timeTz` 方法创建一个具有可选精度（总位数）的 `TIME`（带时区）等效列：\r\n\r\n    $table->timeTz('sunrise', $precision = 0);\r\n\r\n<a name=\"column-method-time\"></a>\r\n#### `time()` {.collection-method}\r\n\r\n`time` 方法创建一个具有可选精度（总位数）的 `TIME` 等效列：\r\n\r\n    $table->time('sunrise', $precision = 0);\r\n\r\n<a name=\"column-method-timestampTz\"></a>\r\n#### `timestampTz()` {.collection-method}\r\n\r\n`timestampTz` 方法创建一个具有可选精度（总位数）的 `TIMESTAMP`（带时区）等效列：\r\n\r\n    $table->timestampTz('added_at', $precision = 0);\r\n\r\n<a name=\"column-method-timestamp\"></a>\r\n#### `timestamp()` {.collection-method}\r\n\r\n`timestamp` 方法创建一个具有可选精度（总位数）的 `TIMESTAMP` 等效列：\r\n\r\n    $table->timestamp('added_at', $precision = 0);\r\n\r\n<a name=\"column-method-timestampsTz\"></a>\r\n#### `timestampsTz()` {.collection-method}\r\n\r\n`timestampsTz` 方法创建 `created_at` 和 `updated_at` `TIMESTAMP`（带时区）等效列，具有可选精度（总位数）：\r\n\r\n    $table->timestampsTz($precision = 0);\r\n\r\n<a name=\"column-method-timestamps\"></a>\r\n#### `timestamps()` {.collection-method}\r\n\r\n`timestamps` 方法创建具有可选精度（总位数）的 `created_at` 和 `updated_at` `TIMESTAMP` 等效列：\r\n\r\n    $table->timestamps($precision = 0);\r\n\r\n<a name=\"column-method-tinyIncrements\"></a>\r\n#### `tinyIncrements()` {.collection-method}\r\n\r\n`tinyIncrements` 方法创建一个自动递增的 `UNSIGNED TINYINT` 等效列作为主键：\r\n\r\n    $table->tinyIncrements('id');\r\n\r\n<a name=\"column-method-tinyInteger\"></a>\r\n#### `tinyInteger()` {.collection-method}\r\n\r\n`tinyInteger` 方法用于创建一个 `TINYINT` 等效列：\r\n\r\n    $table->tinyInteger('votes');\r\n\r\n<a name=\"column-method-tinyText\"></a>\r\n#### `tinyText()` {.collection-method}\r\n\r\n`tinyText` 方法用于创建一个 `TINYTEXT` 等效列：\r\n\r\n    $table->tinyText('notes');\r\n\r\n<a name=\"column-method-unsignedBigInteger\"></a>\r\n#### `unsignedBigInteger()` {.collection-method}\r\n\r\n`unsignedBigInteger` 方法用于创建一个 `UNSIGNED BIGINT` 等效列：\r\n\r\n    $table->unsignedBigInteger('votes');\r\n\r\n<a name=\"column-method-unsignedDecimal\"></a>\r\n#### `unsignedDecimal()` {.collection-method}\r\n\r\n`unsignedDecimal` 方法用于创建一个 `UNSIGNED DECIMAL` 等效列，具有可选的精度（总位数）和小数位数（小数位数）：\r\n\r\n    $table->unsignedDecimal('amount', $precision = 8, $scale = 2);\r\n\r\n<a name=\"column-method-unsignedInteger\"></a>\r\n#### `unsignedInteger()` {.collection-method}\r\n\r\n`unsignedInteger` 方法用于创建一个 `UNSIGNED INTEGER` 等效列：\r\n\r\n    $table->unsignedInteger('votes');\r\n\r\n<a name=\"column-method-unsignedMediumInteger\"></a>\r\n#### `unsignedMediumInteger()` {.collection-method}\r\n\r\n`unsignedMediumInteger` 方法用于创建一个 `UNSIGNED MEDIUMINT` 等效列：\r\n\r\n    $table->unsignedMediumInteger('votes');\r\n\r\n<a name=\"column-method-unsignedSmallInteger\"></a>\r\n#### `unsignedSmallInteger()` {.collection-method}\r\n\r\n`unsignedSmallInteger` 方法用于创建一个 `UNSIGNED SMALLINT` 等效列：\r\n\r\n    $table->unsignedSmallInteger('votes');\r\n\r\n<a name=\"column-method-unsignedTinyInteger\"></a>\r\n#### `unsignedTinyInteger()` {.collection-method}\r\n\r\n`unsignedTinyInteger` 方法用于创建一个 `UNSIGNED TINYINT` 等效列：\r\n\r\n    $table->unsignedTinyInteger('votes');\r\n\r\n<a name=\"column-method-ulidMorphs\"></a>\r\n#### `ulidMorphs()` {.collection-method}\r\n\r\n`ulidMorphs` 方法用于快速创建一个名称为 `{column}_id` ，类型为 `CHAR(26)` 的列和一个名称为 `{column}_type` ，类型为  `VARCHAR` 的列。\r\n\r\n这个方法用于定义使用 UUID 标识符的[多态关联](/docs/laravel/10.x/eloquent-relationships)所需的列时使用。在下面的例子中，`taggable_id` 和 `taggable_type` 这两个列将会被创建：\r\n\r\n    $table->ulidMorphs('taggable');\r\n\r\n<a name=\"column-method-uuidMorphs\"></a>\r\n#### `uuidMorphs()` {.collection-method}\r\n\r\n`uuidMorphs` 方法用于快速创建一个名称为 `{column}_id` ，类型为 `CHAR(36)` 的列和一个名称为 `{column}_type` ，类型为  `VARCHAR` 的列。\r\n\r\n这个方法用于定义使用 UUID 标识符的[多态关联](/docs/laravel/10.x/eloquent-relationships)所需的列时使用。在下面的例子中，`taggable_id` 和 `taggable_type` 这两个列将会被创建：\r\n\r\n    $table->uuidMorphs('taggable');\r\n\r\n<a name=\"column-method-ulid\"></a>\r\n#### `ulid()` {.collection-method}\r\n\r\n`ulid` 方法用于创建一个 `ULID` 类型的列：\r\n\r\n    $table->ulid('id');\r\n\r\n<a name=\"column-method-uuid\"></a>\r\n#### `uuid()` {.collection-method}\r\n\r\n`uuid` 方法用于创建一个 `UUID` 类型的列：\r\n\r\n    $table->uuid('id');\r\n\r\n<a name=\"column-method-year\"></a>\r\n#### `year()` {.collection-method}\r\n\r\n`year` 方法用于创建一个 `YEAR` 类型的列：\r\n\r\n    $table->year('birth_year');\r\n\r\n<a name=\"column-modifiers\"></a>\r\n### 字段修饰符\r\n\r\n除了上面列出的列类型外，在向数据库表添加列时还有几个可以使用的「修饰符」。例如，如果要把列设置为要使列为「可空」，你可以使用 `nullable` 方法：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->string('email')->nullable();\r\n    });\r\n\r\n下表时所有可用的列修饰符。此列表不包括[索引修饰符](#creating-indexes):\r\n\r\n修饰符  |  说明\r\n--------  |  -----------\r\n`->after('column')`  |  将该列放在其它字段「之后」(MySQL)\r\n`->autoIncrement()`  |  设置 INTEGER 类型的列为自动递增 (主键)\r\n`->charset('utf8mb4')`  |  为该列指定字符集 (MySQL)\r\n`->collation('utf8mb4_unicode_ci')`  |  为该列指定排序规则 (MySQL/PostgreSQL/SQL Server)\r\n`->comment('my comment')`  |  为该列添加注释 (MySQL/PostgreSQL)\r\n`->default($value)`  |  为该列指定一个「默认值」\r\n`->first()`  |  将该列放在该表「首位」 (MySQL)\r\n`->from($integer)`  |  设置自动递增字段的起始值 (MySQL / PostgreSQL)\r\n`->invisible()`  |  使列对「SELECT \\*」查询不可见（MySQL）。\r\n`->nullable($value = true)`  |  允许 NULL 值插入到该列\r\n`->storedAs($expression)`  |  创建一个存储生成的列 (MySQL)\r\n`->unsigned()`  |  设置 INTEGER 类型的字段为 UNSIGNED (MySQL)\r\n`->useCurrent()`  |  设置 TIMESTAMP 类型的列使用 CURRENT_TIMESTAMP 作为默认值\r\n`->useCurrentOnUpdate()`  |  将 TIMESTAMP 类型的列设置为在更新时使用 CURRENT_TIMESTAMP 作为新值\r\n`->virtualAs($expression)`  |  创建一个虚拟生成的列 (MySQL)\r\n`->generatedAs($expression)`  |  使用指定的序列选项创建标识列 (PostgreSQL)\r\n`->always()`  |  定义序列值优先于标识列的输入 (PostgreSQL)\r\n`->isGeometry()`  |  将空间列类型设置为 `geometry` - 默认类型为 `geography` (PostgreSQL)。\r\n\r\n<a name=\"default-expressions\"></a>\r\n#### 默认值表达式\r\n\r\n`default` 修饰符接收一个变量或者一个 `\\Illuminate\\Database\\Query\\Expression` 实例。使用 `Expression` 实例可以避免使用包含在引号中的值，并且允许你使用特定数据库函数。这在当你需要给 `JSON` 字段指定默认值的时候特别有用：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Database\\Query\\Expression;\r\n    use Illuminate\\Database\\Migrations\\Migration;\r\n\r\n    return new class extends Migration\r\n    {\r\n        /**\r\n         * 运行迁移\r\n         */\r\n        public function up(): void\r\n        {\r\n            Schema::create('flights', function (Blueprint $table) {\r\n                $table->id();\r\n                $table->json('movies')->default(new Expression('(JSON_ARRAY())'));\r\n                $table->timestamps();\r\n            });\r\n        }\r\n    };\r\n\r\n> **注意**  \r\n> 支持哪些默认值的表示方式取决于你的数据库驱动、数据库版本、还有字段类型。请参考合适的文档使用。还有一点要注意的是，使用数据库特定函数，可能会将你绑牢到特定的数据库驱动上。\r\n\r\n<a name=\"column-order\"></a>\r\n#### 字段顺序\r\n\r\n使用 MySQL 数据库时，可以使用 `after` 方法在模式中的现有列后添加列：\r\n\r\n    $table->after('password', function (Blueprint $table) {\r\n        $table->string('address_line1');\r\n        $table->string('address_line2');\r\n        $table->string('city');\r\n    });\r\n\r\n<a name=\"modifying-columns\"></a>\r\n### 修改字段\r\n\r\n`change` 方法可以将现有的字段类型修改为新的类型或修改属性。比如，你可能想增加 `string` 字段的长度，可以使用 `change` 方法把 `name` 字段的长度从 25 增加到 50。所以，我们可以简单的更新字段属性然后调用  `change` 方法：\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->string('name', 50)->change();\r\n    });\r\n\r\n当修改一个列时，你必须明确包括所有你想在列定义上保留的修改器 —— 任何缺失的属性都将被丢弃。例如，为了保留 `unsigned`、`default` 和 `comment`  属性，你必须在修改列时明确每个属性的修改。\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->integer('votes')->unsigned()->default(1)->comment('my comment')->change();\r\n    });\r\n\r\n<a name=\"modifying-columns-on-sqlite\"></a>\r\n#### 在 SQLite 上修改列\r\n\r\n如果应用程序使用的是 SQLite 数据库，请确保你已经通过 Composer 包管理器安装了 `doctrine/dbal` 包。Doctrine DBAL 库用于确定字段的当前状态，并创建对该字段进行指定调整所需的 SQL 查询：\r\n\r\n    composer require doctrine/dbal\r\n\r\n如果你打算修改 `timestamp` 方法来创建列，你还需要将以下配置添加到应用程序的`config/database.php`配置文件中：\r\n\r\n```php\r\nuse Illuminate\\Database\\DBAL\\TimestampType;\r\n\r\n'dbal' => [\r\n    'types' => [\r\n        'timestamp' => TimestampType::class,\r\n    ],\r\n],\r\n```\r\n\r\n> **注意**  \r\n> 当使用 `doctrine/dbal` 包时，你可以修改以下列类型：`bigInteger`、`binary`、`boolean`、`char`、`date`、`dateTime`、`dateTimeTz`、`decimal`、`double`、`integer`、`json`、`longText`、`mediumText`、`smallInteger`、`string`、`text`、`time`、`tinyText`、`unsignedBigInteger`、`unsignedInteger`、`unsignedSmallInteger`、`ulid`、和 `uuid`。\r\n\r\n<a name=\"renaming-columns\"></a>\r\n#### 重命名字段\r\n\r\n要重命名一个列，你可以使用模式构建器提供的 `renameColumn` 方法：\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->renameColumn('from', 'to');\r\n    });\r\n\r\n<a name=\"renaming-columns-on-legacy-databases\"></a>\r\n#### 在较低版本数据库上重命名列\r\n\r\n如果你运行的数据库低于以下版本，你应该确保在重命名列之前通过 Composer 软件包管理器安装了 `doctrine/dbal` 库。\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- MySQL < `8.0.3`\r\n- MariaDB < `10.5.2`\r\n- SQLite < `3.25.0`\r\n\r\n</div>\r\n\r\n<a name=\"dropping-columns\"></a>\r\n### 删除字段\r\n\r\n要删除一个列，你可以使用 `dropColumn` 方法。\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->dropColumn('votes');\r\n    });\r\n\r\n你可以传递一个字段数组给 `dropColumn` 方法来删除多个字段：\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->dropColumn(['votes', 'avatar', 'location']);\r\n    });\r\n\r\n<a name=\"dropping-columns-on-legacy-databases\"></a>\r\n#### 在较低版本的数据库中删除列的内容\r\n\r\n如果你运行的 SQLite 版本在 `3.35.0` 之前，你必须通过 Composer  软件包管理器安装 `doctrine/dbal` 包，然后才能使用 `dropColumn` 方法。不支持在使用该包时在一次迁移中删除或修改多个列。\r\n\r\n<a name=\"available-command-aliases\"></a>\r\n#### 可用的命令别名\r\n\r\nLaravel 提供了几种常用的删除相关列的便捷方法。如下表所示：\r\n\r\n命令  |  说明\r\n-------  |  -----------\r\n`$table->dropMorphs('morphable');`  |  删除 `morphable_id` 和 `morphable_type` 字段\r\n`$table->dropRememberToken();`  |  删除 `remember_token` 字段\r\n`$table->dropSoftDeletes();`  |  删除 `deleted_at` 字段\r\n`$table->dropSoftDeletesTz();`  |  `dropSoftDeletes()` 方法的别名\r\n`$table->dropTimestamps();`  |  删除 `created_at` 和 `updated_at` 字段\r\n`$table->dropTimestampsTz();` |  `dropTimestamps()` 方法别名\r\n\r\n<a name=\"indexes\"></a>\r\n## 索引\r\n\r\n<a name=\"creating-indexes\"></a>\r\n### 创建索引\r\n\r\n结构生成器支持多种类型的索引。下面的例子中新建了一个值唯一的 `email` 字段。我们可以将 `unique` 方法链式地添加到字段定义上来创建索引：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('users', function (Blueprint $table) {\r\n        $table->string('email')->unique();\r\n    });\r\n\r\n或者，你也可以在定义完字段之后创建索引。为此，你应该调用结构生成器上的 `unique` 方法，此方法应该传入唯一索引的列名称：\r\n\r\n    $table->unique('email');\r\n\r\n你甚至可以将数组传递给索引方法来创建一个复合（或合成）索引：\r\n\r\n    $table->index(['account_id', 'created_at']);\r\n\r\n创建索引时，Laravel 会自动生成一个合理的索引名称，但你也可以传递第二个参数来自定义索引名称：\r\n\r\n    $table->unique('email', 'unique_email');\r\n\r\n<a name=\"available-index-types\"></a>\r\n#### 可用的索引类型\r\n\r\nLaravel 的结构生成器提供了 Laravel 支持的所有类型的索引方法。每个索引方法都接受一个可选的第二个参数来指定索引的名称。如果省略，名称将根据表和列的名称生成。下面是所有可用的索引方法：\r\n\r\n命令  |  说明\r\n-------  |  -----------\r\n`$table->primary('id');`  |  添加主键\r\n`$table->primary(['id', 'parent_id']);`  |   添加复合主键\r\n`$table->unique('email');`  |  添加唯一索引\r\n`$table->index('state');`  | 添加普通索引\r\n`$table->fullText('body');`  |  添加全文索引 (MySQL/PostgreSQL)\r\n`$table->fullText('body')->language('english');`  |  添加指定语言 (PostgreSQL) 的全文索引\r\n`$table->spatialIndex('location');`  |  添加空间索引（不支持 SQLite）\r\n\r\n<a name=\"index-lengths-mysql-mariadb\"></a>\r\n#### 索引长度 & MySQL / MariaDB\r\n\r\n默认情况下，Laravel 使用 `utf8mb4` 编码。如果你是在版本低于 5.7.7 的 MySQL 或者版本低于 10.2.2 的 MariaDB 上创建索引，那你就需要手动配置数据库迁移的默认字符串长度。也就是说，你可以通过在 `App\\Providers\\AppServiceProvider` 类的 `boot` 方法中调用 `Schema::defaultStringLength` 方法来配置默认字符串长度：\r\n\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    /**\r\n     * 引导任何应用程序「全局配置」\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Schema::defaultStringLength(191);\r\n    }\r\n\r\n当然，你也可以选择开启数据库的 `innodb_large_prefix` 选项。至于如何正确开启，请自行查阅数据库文档。\r\n\r\n<a name=\"renaming-indexes\"></a>\r\n### 重命名索引\r\n\r\n若要重命名索引，你需要调用 `renameIndex` 方法。此方法接受当前索引名称作为其第一个参数，并将所需名称作为其第二个参数：\r\n\r\n    $table->renameIndex('from', 'to')\r\n\r\n> **注意**  \r\n> 如果你的应用程序使用的是 SQLite 数据库，你必须通过 Composer 软件包管理器安装 `doctrine/dbal` 包，然后才能使用 `renameIndex` 方法。\r\n\r\n<a name=\"dropping-indexes\"></a>\r\n### 删除索引\r\n\r\n若要删除索引，则必须指定索引的名称。Laravel 默认会自动将数据表名称、索引的字段名及索引类型简单地连接在一起作为名称。举例如下：\r\n\r\n\r\n命令  |  说明\r\n-------  |  -----------\r\n`$table->dropPrimary('users_id_primary');`  |  从「users」表中删除主键\r\n`$table->dropUnique('users_email_unique');`  |  从「users」表中删除 unique 索引\r\n`$table->dropIndex('geo_state_index');`  |  从「geo」表中删除基本索引\r\n`$table->dropFullText('posts_body_fulltext');`  |  从「post」表中删除一个全文索引\r\n`$table->dropSpatialIndex('geo_location_spatialindex');`  | 从「geo」表中删除空间索引（不支持 SQLite）\r\n\r\n\r\n如果将字段数组传给 `dropIndex` 方法，会删除根据表名、字段和键类型生成的索引名称。\r\n\r\n    Schema::table('geo', function (Blueprint $table) {\r\n        $table->dropIndex(['state']); // 删除 'geo_state_index' 索引\r\n    });\r\n\r\n<a name=\"foreign-key-constraints\"></a>\r\n### 外键约束\r\n\r\nLaravel 还支持创建用于在数据库层中的强制引用完整性的外键约束。例如，让我们在 `posts` 表上定义一个引用 `users` 表的 `id` 字段的 `user_id` 字段：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('posts', function (Blueprint $table) {\r\n        $table->unsignedBigInteger('user_id');\r\n\r\n        $table->foreign('user_id')->references('id')->on('users');\r\n    });\r\n\r\n由于这种外键约束的定义方式过于繁复，Laravel 额外提供了更简洁的方法，基于约定来提供更好的开发人员体验。当使用 `foreignId` 方法来创建列时，上面的示例还可以这么写：\r\n\r\n    Schema::table('posts', function (Blueprint $table) {\r\n        $table->foreignId('user_id')->constrained();\r\n    });\r\n\r\n`foreignId` 方法是 `unsignedBigInteger` 的别名，而 `constrained` 方法将使用约定来确定所引用的表名和列名。如果表名与约定不匹配，可以通过将表名作为参数传递给 `constrained` 方法来指定表名：\r\n\r\n    Schema::table('posts', function (Blueprint $table) {\r\n        $table->foreignId('user_id')->constrained('users');\r\n    });\r\n\r\n你可以为约束的「on delete」和「on update」属性指定所需的操作：\r\n\r\n    $table->foreignId('user_id')\r\n          ->constrained()\r\n          ->onUpdate('cascade')\r\n          ->onDelete('cascade');\r\n\r\n还为这些操作提供了另一种表达性语法：\r\n\r\n方法  |  说明\r\n-------  |  -----------\r\n`$table->cascadeOnUpdate();` | 更新应该级联\r\n`$table->restrictOnUpdate();`| 应该限制更新\r\n`$table->cascadeOnDelete();` | 删除应该级联\r\n`$table->restrictOnDelete();`| 应该限制删除\r\n`$table->nullOnDelete();`    | 删除应将外键值设置为空\r\n\r\n当使用任意 [字段修饰符](#column-modifiers) 的时候，必须在调用 `constrained` 之前调用：\r\n\r\n    $table->foreignId('user_id')\r\n          ->nullable()\r\n          ->constrained();\r\n\r\n<a name=\"dropping-foreign-keys\"></a>\r\n#### 删除外键\r\n\r\n要删除一个外键，你需要使用 `dropForeign` 方法，将要删除的外键约束作为参数传递。外键约束采用的命名方式与索引相同。即，将数据表名称和约束的字段连接起来，再加上 `_foreign` 后缀：\r\n\r\n    $table->dropForeign('posts_user_id_foreign');\r\n\r\n或者，可以给 `dropForeign` 方法传递一个数组，该数组包含要删除的外键的列名。数组将根据  Laravel 的 结构生成器使用的约束名称约定自动转换：\r\n\r\n    $table->dropForeign(['user_id']);\r\n\r\n<a name=\"toggling-foreign-key-constraints\"></a>\r\n#### 更改外键约束\r\n\r\n你可以在迁移文件中使用以下方法来开启或关闭外键约束：\r\n\r\n    Schema::enableForeignKeyConstraints();\r\n\r\n    Schema::disableForeignKeyConstraints();\r\n\r\n    Schema::withoutForeignKeyConstraints(function () {\r\n        // 闭包中禁用的约束…\r\n    });\r\n\r\n> 注意：SQLite 默认禁用外键约束。使用 SQLite 时，请确保在数据库配置中[启用外键支持](/docs/laravel/10.x/databasemd#configuration) 然后再尝试在迁移中创建它们。另外，SQLite 只在创建表时支持外键，并且[将在修改表时不会支持](https://www.sqlite.org/omitted.html)。\r\n\r\n<a name=\"事件\"></a>\r\n## 事件\r\n\r\n为方便起见，每个迁移操作都会派发一个 [事件](/docs/laravel/10.x/events)。以下所有事件都扩展了基础 `Illuminate\\Database\\Events\\MigrationEvent` 类：\r\n\r\n类 | 描述\r\n-------|-------\r\n`Illuminate\\Database\\Events\\MigrationsStarted` | 即将执行一批迁移。 |\r\n`Illuminate\\Database\\Events\\MigrationsEnded` | 一批迁移已完成执行。 |\r\n`Illuminate\\Database\\Events\\MigrationStarted` | 即将执行单个迁移。 |\r\n`Illuminate\\Database\\Events\\MigrationEnded` | 单个迁移已完成执行。 |\r\n`Illuminate\\Database\\Events\\SchemaDumped` | 数据库结构转储已完成。 |\r\n`Illuminate\\Database\\Events\\SchemaLoaded` | 已加载现有数据库结构转储。 |\r\n","p":"docs/migrations.html"},{"t":"seeding (数据填充)","d":"# 数据填充\r\n\r\n- [简介](#introduction)\r\n- [编写 Seeders](#writing-seeders)\r\n    - [使用模型工厂](#using-model-factories)\r\n    - [调用其他 Seeders](#calling-additional-seeders)\r\n    - [禁用模型事件](#muting-model-events)\r\n- [运行 Seeders](#running-seeders)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 内置了一个可为你的数据库填充测试数据的数据填充类。所有的数据填充类都应该放在 `database/seeds` 目录下。Laravel 默认定义了一个 `DatabaseSeeder` 类。通过这个类，你可以用 `call` 方法来运行其他的 `seed` 类，从而控制数据填充的顺序。\r\n\r\n> **注意**  \r\n> 在数据库填充期间，[批量赋值保护](/docs/laravel/10.x/eloquentmd#mass-assignment)被自动禁用。\r\n\r\n<a name=\"writing-seeders\"></a>\r\n## 编写 Seeders\r\n\r\n运行 [Artisan 命令](/docs/laravel/10.x/artisan) `make:seeder` 可以生成 Seeder，生成的 seeders 都放在 `database/seeders` 目录下：\r\n\r\n```shell\r\nphp artisan make:seeder UserSeeder\r\n```\r\n\r\n一个数据填充类默认只包含一个方法：`run` ，当执行 `db:seed` [Artisan命令](/docs/laravel/10.x/artisan) 时，被调用。在 `run` 方法中, 可以按需将数据插入数据库中。 也可以使用[查询构造器](/docs/laravel/10.x/queries)来手动插入数据，或者可以使用 [Eloquent 数据工厂](/docs/laravel/10.x/eloquent-factories)。\r\n\r\n例如，在默认 `DatabaseSeeder` 类的 `run` 方法中添加一个数据库插入语句：\r\n\r\n    <?php\r\n\r\n    namespace Database\\Seeders;\r\n\r\n    use Illuminate\\Database\\Seeder;\r\n    use Illuminate\\Support\\Facades\\DB;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    class DatabaseSeeder extends Seeder\r\n    {\r\n        /**\r\n         * 运行数据填充\r\n         */\r\n        public function run(): void\r\n        {\r\n            DB::table('users')->insert([\r\n                'name' => Str::random(10),\r\n                'email' => Str::random(10).'@gmail.com',\r\n                'password' => Hash::make('password'),\r\n            ]);\r\n        }\r\n    }\r\n\r\n> **注意**  \r\n> 可以在 `run` 方法的参数中键入你需要的任何依赖性,它们将自动通过 Laravel [服务容器](/docs/laravel/10.x/container)注入。\r\n\r\n\r\n\r\n<a name=\"using-model-factories\"></a>\r\n### 使用模型工厂\r\n\r\n当然，手动指定每个模型填充的属性是很麻烦的。因此可以使用 [Eloquent 数据工厂](/docs/laravel/10.x/eloquent-factories)来更方便地生成大量的数据库记录。首先，查看 [Eloquent 数据工厂](/docs/laravel/10.x/eloquent-factories)，了解如何定义工厂。\r\n\r\n例如，创建50个用户，每个用户有一个相关的帖子：\r\n\r\n    use App\\Models\\User;\r\n\r\n    /**\r\n     * 运行数据库迁移\r\n     */\r\n    public function run(): void\r\n    {\r\n        User::factory()\r\n                ->count(50)\r\n                ->hasPosts(1)\r\n                ->create();\r\n    }\r\n\r\n<a name=\"calling-additional-seeders\"></a>\r\n### 调用其他 Seeders\r\n\r\n在 `DatabaseSeeder` 类中，可以使用 `call` 方法来执行其他的填充类。使用 `call` 方法可以将数据库迁移分成多个文件，这样就不会出现单个数据填充类过大。`call` 方法接受一个由数据填充类组成的数组：\r\n\r\n    /**\r\n     * 运行数据库迁移\r\n     */\r\n    public function run(): void\r\n    {\r\n        $this->call([\r\n            UserSeeder::class,\r\n            PostSeeder::class,\r\n            CommentSeeder::class,\r\n        ]);\r\n    }\r\n\r\n<a name=\"muting-model-events\"></a>\r\n### 禁用模型事件\r\n\r\n在运行时，你可能想阻止模型调用事件，可以使用 `WithoutModelEvents` 特性。使用 `WithoutModelEvents` trait 可确保不调用模型事件，即使通过 `call` 方法执行了额外的 seed 类：\r\n\r\n    <?php\r\n\r\n    namespace Database\\Seeders;\r\n\r\n    use Illuminate\\Database\\Seeder;\r\n    use Illuminate\\Database\\Console\\Seeds\\WithoutModelEvents;\r\n\r\n    class DatabaseSeeder extends Seeder\r\n    {\r\n        use WithoutModelEvents;\r\n\r\n        /**\r\n         * 运行数据库迁移\r\n         */\r\n        public function run(): void\r\n        {\r\n            $this->call([\r\n                UserSeeder::class,\r\n            ]);\r\n        }\r\n    }\r\n\r\n<a name=\"running-seeders\"></a>\r\n## 运行 Seeders\r\n\r\n执行 `db:seed` Artisan 命令来为数据库填充数据。默认情况下，`db:seed` 命令会运行 `Database\\Seeders\\DatabaseSeeder` 类来调用其他数据填充类。当然，也可以使用 `--class` 选项来指定一个特定的填充类：\r\n\r\n```shell\r\nphp artisan db:seed\r\n\r\nphp artisan db:seed --class=UserSeeder\r\n```\r\n\r\n\r\n\r\n你还可以使用 `migrate:fresh` 命令结合 `--seed` 选项，这将删除数据库中所有表并重新运行所有迁移。此命令对于完全重建数据库非常有用。 `--seeder` 选项可以用来指定要运行的填充文件：\r\n\r\n```shell\r\nphp artisan migrate:fresh --seed\r\n\r\nphp artisan migrate:fresh --seed --seeder=UserSeeder \r\n```\r\n\r\n<a name=\"forcing-seeding-production\"></a>\r\n#### 在生产环境中强制运行填充\r\n\r\n一些填充操作可能会导致原有数据的更新或丢失。为了保护生产环境数据库的数据，在 `生产环境` 中运行填充命令前会进行确认。可以添加 `--force` 选项来强制运行填充命令：\r\n\r\n```shell\r\nphp artisan db:seed --force\r\n```\r\n\r\n","p":"docs/seeding.html"},{"t":"redis (Redis)","d":"# Redis\r\n\r\n- [安装](#introduction)\r\n- [配置](#configuration)\r\n    - [集群](#clusters)\r\n    - [Predis](#predis)\r\n    - [phpredis](#phpredis)\r\n- [与Redis交互](#interacting-with-redis)\r\n    - [事务](#transactions)\r\n    - [管道命令](#pipelining-commands)\r\n- [发布与订阅](#pubsub)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Redis](https://redis.io) 是一个开源的, 高级键值对存储数据库。 保护的数据库类型有 [字符串](https://redis.io/topics/data-types#strings), [hash](https://redis.io/topics/data-types#hashes), [列表](https://redis.io/topics/data-types#lists), [集合](https://redis.io/topics/data-types#sets) 和 [有序集合](https://redis.io/topics/data-types#sorted-sets)。\r\n\r\n在将 Redis 与 Laravel 一起使用前，我们鼓励你通过 PECL 安装并使用 [PhpRedis](https://github.com/phpredis/phpredis) ，尽管扩展安装起来更复杂，但对于大量使用 Redis 的应用程序可能会带来更好的性能。如果你使用 [Laravel Sail](/docs/laravel/10.x/sail), 这个扩展已经事先在你的 Docker 容器中安装完成。\r\n\r\n如果你不能安装 PHPRedis 扩展，你或许可以使用 composer 安装 predis/predis 包。Predis 是一个完全用 PHP 编写的 Redis 客户端，不需要任何额外的扩展：\r\n\r\n```shell\r\ncomposer require predis/predis\r\n```\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n在你的应用中配置 Redis 信息，你要在 <code>config/database.php</code> 文件中进行配置。在该文件中，你将看到一个 <code>Redis</code> 数组包含了你的 Redis 配置信息。\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'default' => [\r\n            'host' => env('REDIS_HOST', '127.0.0.1'),\r\n            'password' => env('REDIS_PASSWORD'),\r\n            'port' => env('REDIS_PORT', 6379),\r\n            'database' => env('REDIS_DB', 0),\r\n        ],\r\n\r\n        'cache' => [\r\n            'host' => env('REDIS_HOST', '127.0.0.1'),\r\n            'password' => env('REDIS_PASSWORD'),\r\n            'port' => env('REDIS_PORT', 6379),\r\n            'database' => env('REDIS_CACHE_DB', 1),\r\n        ],\r\n\r\n    ],\r\n\r\n\r\n\r\n在你的配置文件里定义的每个 Redis 服务器，除了用 URL 来表示的 Redis 连接，都必需要指定名称 、 host （主机）和 port （端口）字段：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'default' => [\r\n            'url' => 'tcp://127.0.0.1:6379?database=0',\r\n        ],\r\n\r\n        'cache' => [\r\n            'url' => 'tls://user:password@127.0.0.1:6380?database=1',\r\n        ],\r\n\r\n    ],\r\n\r\n<a name=\"configuring-the-connection-scheme\"></a>\r\n#### 配置连接方案\r\n\r\n默认情况下，Redis 客户端使用 <code>tcp</code> 方案连接 Redis 服务器。另外，你也可以在你的 Redis 服务配置数组中指定一个 <code>scheme</code> 配置项，来使用 TLS/SSL 加密：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'default' => [\r\n            'scheme' => 'tls',\r\n            'host' => env('REDIS_HOST', '127.0.0.1'),\r\n            'password' => env('REDIS_PASSWORD'),\r\n            'port' => env('REDIS_PORT', 6379),\r\n            'database' => env('REDIS_DB', 0),\r\n        ],\r\n\r\n    ],\r\n\r\n<a name=\"clusters\"></a>\r\n### 集群\r\n\r\n如果你的应用使用 Redis 集群，你应该在 Redis 配置文件中用 <code>clusters</code> 键来定义集群。这个配置键默认没有，所以你需要在 <code>config/database.php</code> 配置文件中手动创建：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'clusters' => [\r\n            'default' => [\r\n                [\r\n                    'host' => env('REDIS_HOST', 'localhost'),\r\n                    'password' => env('REDIS_PASSWORD'),\r\n                    'port' => env('REDIS_PORT', 6379),\r\n                    'database' => 0,\r\n                ],\r\n            ],\r\n        ],\r\n\r\n    ],\r\n\r\n默认情况下，集群可以在节点上实现客户端分片，允许你实现节点池以及创建大量可用内存。这里要注意，客户端共享不会处理失败的情况；因此，这个功能主要适用于从另一个主数据库获取的缓存数据。\r\n如果要使用 Redis 原生集群，需要把 <code>config/database.php</code> 配置文件下的 <code>options.cluster</code> 配置项的值设置为 <code>redis</code> ：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'options' => [\r\n            'cluster' => env('REDIS_CLUSTER', 'redis'),\r\n        ],\r\n\r\n        'clusters' => [\r\n            // ...\r\n        ],\r\n\r\n    ],\r\n\r\n\r\n\r\n<a name=\"predis\"></a>\r\n### Predis\r\n\r\n要使用 Predis 扩展去连接 Redis， 请确保环境变量 <code>REDIS_CLIENT</code> 的值为 <code>predis</code> ：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'predis'),\r\n\r\n        // ...\r\n    ],\r\n\r\n除默认的 <code>host</code> ，<code>port</code> ，<code>database</code> 和 <code>password</code> 这些服务配置选项外， Predis 还支持为每个 Redis 服务器定义其它的 [连接参数](https://github.com/nrk/predis/wiki/Connection-Parameters)。如果要使用这些额外的配置项，可以在 config/database.php 配置文件中将任意选项添加到 Redis 服务器配置内：\r\n\r\n    'default' => [\r\n        'host' => env('REDIS_HOST', 'localhost'),\r\n        'password' => env('REDIS_PASSWORD'),\r\n        'port' => env('REDIS_PORT', 6379),\r\n        'database' => 0,\r\n        'read_write_timeout' => 60,\r\n    ],\r\n\r\n<a name=\"the-redis-facade-alias\"></a>\r\n#### Redis Facade 别名\r\n\r\nLaravel 的 <code>config/app.php</code> 配置文件包含了 <code>aliases</code> 数组，该数组可用于定义通过框架注册的所有类别名。方便起见，Laravel 提供了一份包含了所有 facade 的别名入口；不过，<code>Redis</code> 别名不能在这里使用，因为这与 phpredis 扩展提供的 <code>Redis</code> 类名冲突。如果正在使用 <code>Predis</code> 客户端并确实想要用这个别名，你可以在 <code>config/app.php</code> 配置文件中取消对此别名的注释。\r\n\r\n    'aliases' => Facade::defaultAliases()->merge([\r\n        'Redis' => Illuminate\\Support\\Facades\\Redis::class,\r\n    ])->toArray(),\r\n\r\n<a name=\"phpredis\"></a>\r\n### phpredis\r\n\r\nLaravel 默认使用 phpredis 扩展与 Redis 通信。Laravel 用于与 Redis 通信的客户端由 <code>redis.client</code> 配置项决定，这个配置通常为环境变量 <code>REDIS_CLIENT</code> 的值：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        // 重设 Redis 配置项...\r\n    ],\r\n\r\n\r\n\r\n除默认的 <code>scheme</code> , <code>host</code> , <code>port </code>, <code>database</code> 和 <code>password</code> 的服务器配置选项外，<code>phpredis</code> 还支持以下额外的连接参数：<code>name</code> , <code>persistent </code>, <code>persistent_id </code>, <code>prefix </code>, <code>read_timeout </code>, <code>retry_interval </code>, <code>timeout</code> 和 <code>context </code>。 你可以在 <code>config/database.php</code> 配置文件中将任意选项添加到 Redis 服务器配置内：\r\n\r\n    'default' => [\r\n        'host' => env('REDIS_HOST', 'localhost'),\r\n        'password' => env('REDIS_PASSWORD'),\r\n        'port' => env('REDIS_PORT', 6379),\r\n        'database' => 0,\r\n        'read_timeout' => 60,\r\n        'context' => [\r\n            // 'auth' => ['username', 'secret'],\r\n            // 'stream' => ['verify_peer' => false],\r\n        ],\r\n    ],\r\n\r\n<a name=\"phpredis-serialization\"></a>\r\n#### phpredis 序列化和压缩\r\n\r\nphpredis 扩展可以配置使用各种序列化和压缩算法。可以通过设置 Redis 配置中的 <code>options</code> 数组进行配置：\r\n\r\n    'redis' => [\r\n\r\n        'client' => env('REDIS_CLIENT', 'phpredis'),\r\n\r\n        'options' => [\r\n            'serializer' => Redis::SERIALIZER_MSGPACK,\r\n            'compression' => Redis::COMPRESSION_LZ4,\r\n        ],\r\n\r\n        // 重设 Redis 配置项...\r\n    ],\r\n\r\n当前支持的序列化算法包括： <code>Redis::SERIALIZER_NONE</code> （默认）, <code>Redis::SERIALIZER_PHP</code> , <code>Redis::SERIALIZER_JSON</code> , <code>Redis::SERIALIZER_IGBINARY</code> 和 <code>Redis::SERIALIZER_MSGPACK</code> 。\r\n\r\n支持的压缩算法包括： <code>Redis::COMPRESSION_NONE</code> （默认）, <code>Redis::COMPRESSION_LZF</code> , <code>Redis::COMPRESSION_ZSTD</code> 和 <code>Redis::COMPRESSION_LZ4</code> 。\r\n\r\n<a name=\"interacting-with-redis\"></a>\r\n## 与 Redis 交互\r\n\r\n你可以通过调用 <code>Redis</code> [facade](/docs/laravel/10.x/facades) 上的各种方法来与Redis进行交互。 <code>Redis</code> facade 支持动态方法，所以你可以在facade上调用各种 [Redis 命令](https://redis.io/commands) ,这些命令将直接传递给 Redis 。 在本例中，我们将调用 <code>Redis</code> facade 的 <code>get</code> 方法，来调用 Redis <code>GET</code> 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n    use Illuminate\\View\\View;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示给定用户的配置文件\r\n         */\r\n        public function show(string $id): View\r\n        {\r\n            return view('user.profile', [\r\n                'user' => Redis::get('user:profile:'.$id)\r\n            ]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n如上所述，你可以在 `Redis` facade 上调用任意 Redis 命令。 Laravel 使用魔术方法将命令传递给 Redis 服务器。如果一个 Redis 命令需要参数，则应将这些参数传递给 `Redis` facade 的相应方法：\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    Redis::set('name', 'Taylor');\r\n\r\n    $values = Redis::lrange('names', 5, 10);\r\n\r\n或者，你也可以使用 `Redis` facade 上的 `command` 方法将命令传递给服务器，它接受命令的名称作为其第一个参数，并将值的数组作为其第二个参数：\r\n\r\n    $values = Redis::command('lrange', ['name', 5, 10]);\r\n\r\n<a name=\"using-multiple-redis-connections\"></a>\r\n#### 使用多个 Redis 连接\r\n\r\n你应用里的 `config/database.php` 配置文件允许你去定义多个 Redis 连接或者服务器。你可以使用 `Redis` facade 上的 `connection` 方法获得指定的 Redis 连接：\r\n\r\n    $redis = Redis::connection('connection-name');\r\n\r\n要获取获取一个默认的 Redis 连接，你可以调用 `connection` 方法时，不带任何参数：\r\n\r\n    $redis = Redis::connection();\r\n\r\n<a name=\"transactions\"></a>\r\n### 事务\r\n\r\n`Redis` facade 上的 `transaction` 方法对 Redis 原生的 `MULTI` 和 `EXEC` 命令进行了封装。 `transaction` 方法接受一个闭包作为其唯一参数。这个闭包将接收一个 Redis 连接实例，并可能向这个实例发出想要的任何命令。闭包中发出的所有 Redis 命令都将在单个原子性事务中执行：\r\n\r\n    use Redis;\r\n    use Illuminate\\Support\\Facades;\r\n\r\n    Facades\\Redis::transaction(function (Redis $redis) {\r\n        $redis->incr('user_visits', 1);\r\n        $redis->incr('total_visits', 1);\r\n    });\r\n\r\n> **注意**  \r\n> 定义一个 Redis 事务时，你不能从 Redis 连接中获取任何值。请记住，事务是作为单个原子性操作执行的，在整个闭包执行完其命令之前，不会执行该操作。\r\n\r\n\r\n\r\n#### Lua 脚本\r\n\r\n`eval` 方法提供了另外一种原子性执行多条 Redis 命令的方式。但是，`eval` 方法的好处是能够在操作期间与 Redis 键值交互并检查它们。 Redis 脚本是用 [Lua 编程语言](https://www.lua.org/) 编写的。\r\n\r\n`eval` 方法一开始可能有点令人劝退，所以我们将用一个基本示例来明确它的使用方法。 `eval` 方法需要几个参数。第一，在方法中传递一个 Lua 脚本（作为一个字符串）。第二，在方法中传递脚本交互中用到的键的数量（作为一个整数）。第三，在方法中传递所有键名。最后，你可以传递一些脚本中用到的其他参数。\r\n\r\n在本例中，我们要对第一个计数器进行递增，检查它的新值，如果该计数器的值大于 5，那么递增第二个计数器。最终，我们将返回第一个计数器的值：\r\n\r\n    $value = Redis::eval(<<<'LUA'\r\n        local counter = redis.call(\"incr\", KEYS[1])\r\n\r\n        if counter > 5 then\r\n            redis.call(\"incr\", KEYS[2])\r\n        end\r\n\r\n        return counter\r\n    LUA, 2, 'first-counter', 'second-counter');\r\n\r\n> **注意**  \r\n> 请参考 [Redis 文档](https://redis.io/commands/eval) 更多关于 Redis 脚本的信息。\r\n\r\n<a name=\"pipelining-commands\"></a>\r\n### 管道命令\r\n\r\n当你需要执行很多个 Redis 命令时，你可以使用 `pipeline` 方法一次性提交所有命令，而不需要每条命令都与 Redis 服务器建立一次网络连接。 `pipeline` 方法只接受一个参数：接收一个 Redis 实例的闭包。你可以将所有命令发给这个 Redis 实例，它们将同时发送到 Redis 服务器，以减少到服务器的网络访问。这些命令仍然会按照发出的顺序执行：\r\n\r\n    use Redis;\r\n    use Illuminate\\Support\\Facades;\r\n\r\n    Facades\\Redis::pipeline(function (Redis $pipe) {\r\n        for ($i = 0; $i < 1000; $i++) {\r\n            $pipe->set(\"key:$i\", $i);\r\n        }\r\n    });\r\n\r\n\r\n\r\n<a name=\"pubsub\"></a>\r\n## 发布 / 订阅\r\n\r\nLaravel 为 Redis 的 `publish` 和 `subscribe` 命令提供了方便的接口。你可以用这些 Redis 命令监听指定「频道」上的消息。你也可以从一个应用程序发消息给另一个应用程序，哪怕它是用其它编程语言开发的，让应用程序和进程之间能够轻松进行通信。\r\n\r\n首先，用 `subscribe` 方法设置一个频道监听器。我们将这个方法调用放到一个 [Artisan 命令](/docs/laravel/10.x/artisan) 中，因为调用 `subscribe` 方法会启动一个常驻进程：\r\n\r\n    <?php\r\n\r\n    namespace App\\Console\\Commands;\r\n\r\n    use Illuminate\\Console\\Command;\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    class RedisSubscribe extends Command\r\n    {\r\n        /**\r\n         * 控制台命令的名称和签名\r\n         *\r\n         * @var string\r\n         */\r\n        protected $signature = 'redis:subscribe';\r\n\r\n        /**\r\n         * 控制台命令的描述\r\n         *\r\n         * @var string\r\n         */\r\n        protected $description = 'Subscribe to a Redis channel';\r\n\r\n        /**\r\n         * 执行控制台命令\r\n         */\r\n        public function handle(): void\r\n        {\r\n            Redis::subscribe(['test-channel'], function (string $message) {\r\n                echo $message;\r\n            });\r\n        }\r\n    }\r\n\r\n现在我们可以使用 `publish` 方法将消息发布到频道：\r\n\r\n    use Illuminate\\Support\\Facades\\Redis;\r\n\r\n    Route::get('/publish', function () {\r\n        // ...\r\n\r\n        Redis::publish('test-channel', json_encode([\r\n            'name' => 'Adam Wathan'\r\n        ]));\r\n    });\r\n\r\n<a name=\"wildcard-subscriptions\"></a>\r\n#### 通配符订阅\r\n\r\n使用 `psubscribe` 方法，你可以订阅一个通配符频道，用来获取所有频道中的所有消息，频道名称将作为第二个参数传递给提供的回调闭包：\r\n\r\n    Redis::psubscribe(['*'], function (string $message, string $channel) {\r\n        echo $message;\r\n    });\r\n\r\n    Redis::psubscribe(['users.*'], function (string $message, string $channel) {\r\n        echo $message;\r\n    });\r\n\r\n","p":"docs/redis.html"},{"t":"eloquent (Eloquent: 快速入门)","d":"# Eloquent: 快速入门\r\n\r\n- [简介](#introduction)\r\n- [生成模型类](#generating-model-classes)\r\n- [Eloquent模型约定](#eloquent-model-conventions)\r\n    - [表名](#table-names)\r\n    - [主键](#primary-keys)\r\n    - [UUID与ULID键](#uuid-and-ulid-keys)\r\n    - [时间戳](#timestamps)\r\n    - [数据库连接](#database-connections)\r\n    - [默认属性值](#default-attribute-values)\r\n    - [严格配置Eloquent](#configuring-eloquent-strictness)\r\n- [模型检索](#retrieving-models)\r\n    - [集合](#collections)\r\n    - [分块结果集](#chunking-results)\r\n    - [使用懒加载集合分块](#chunking-using-lazy-collections)\r\n    - [游标](#cursors)\r\n    - [高级子查询](#advanced-subqueries)\r\n- [检索单个模型/聚合](#retrieving-single-models)\r\n    - [检索或创建模型](#retrieving-or-creating-models)\r\n    - [检索聚合](#retrieving-aggregates)\r\n- [新增&更新模型](#inserting-and-updating-models)\r\n    - [新增](#inserts)\r\n    - [更新](#updates)\r\n    - [批量任务](#mass-assignment)\r\n    - [有则更新无则新增](#upserts)\r\n- [删除模型](#deleting-models)\r\n    - [软删除](#soft-deleting)\r\n    - [查询已被软删除模型](#querying-soft-deleted-models)\r\n- [修剪模型](#pruning-models)\r\n- [复制模型](#replicating-models)\r\n- [查询作用域](#query-scopes)\r\n    - [全局作用域](#global-scopes)\r\n    - [局部作用域](#local-scopes)\r\n- [模型对比](#comparing-models)\r\n- [事件](#events)\r\n    - [使用闭包方法](#events-using-closures)\r\n    - [观察者](#observers)\r\n    - [静默事件](#muting-events)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\nLaravel包含的Eloquent模块，是一个对象关系映射(ORM)，能使你更愉快地交互数据库。当你使用Eloquent时，数据库中每张表都有一个相对应的\"模型\"用于操作这张表。除了能从数据表中检索数据记录之外，Eloquent模型同时也允许你新增，更新和删除这对应表中的数据\r\n\r\n> **注意**  \r\n> 开始使用之前, 请确认在你的项目里的`config/database.php`配置文件中已经配置好一个可用的数据库连接. 关于配置数据库的更多信息, 请查阅[数据库配置文档](/docs/laravel/10.x/database#configuration).\r\n\r\n\r\n\r\n#### Laravel 训练营\r\n\r\n如果你是 Laravel 的新手，可以随时前往 [Laravel 训练营](https://bootcamp.laravel.com)。Laravel 训练营将指导你使用 Eloquent 建立你的第一个 Laravel 应用。这是一个很好的方式来了解 Laravel 和 Eloquent 所提供的一切。\r\n\r\n<a name=\"generating-model-classes\"></a>\r\n## 生成模型类\r\n\r\n首先，让我们创建一个 Eloquent 模型。模型通常位于 `app\\Models` 目录中，并继承 `Illuminate\\Database\\Eloquent\\Model` 类。 你可以使用 `make:model` [Artisan 命令](/docs/laravel/10.x/artisan) 来生成新模型类：\r\n\r\n```shell\r\nphp artisan make:model Flight\r\n```\r\n\r\n如果你想要在生成模型类的同时生成 [数据库迁移](/docs/laravel/10.x/migrations)， 可以使用 `--migration` 或 `-m` 选项：\r\n\r\n```shell\r\nphp artisan make:model Flight --migration\r\n```\r\n\r\n在生成模型的同时，你可能还想要各种其他类型的类，例如模型工厂、数据填充和控制器。这些选项可以组合在一起从而一次创建多个类：\r\n\r\n```shell\r\n# 生成模型和 Flight 工厂类...\r\nphp artisan make:model Flight --factory\r\nphp artisan make:model Flight -f\r\n\r\n# 生成模型和 Flight 数据填充类...\r\nphp artisan make:model Flight --seed\r\nphp artisan make:model Flight -s\r\n\r\n# 生成模型和 Flight 控制器类...\r\nphp artisan make:model Flight --controller\r\nphp artisan make:model Flight -c\r\n\r\n# 生成模型，Flight 控制器类，资源类和表单验证类...\r\nphp artisan make:model Flight --controller --resource --requests\r\nphp artisan make:model Flight -crR\r\n\r\n# 生成模型和 Flight 授权策略类...\r\nphp artisan make:model Flight --policy\r\n\r\n# 生成模型和数据库迁移，Filght 工厂类，数据库填充类和 Flight 控制器...\r\nphp artisan make:model Flight -mfsc\r\n\r\n# 快捷生成模型，数据库迁移，Flight 工厂类，数据库填充类，授权策略类，Flight 控制器和表单验证类...\r\nphp artisan make:model Flight --all\r\n\r\n# 生成中间表模型...\r\nphp artisan make:model Member --pivot\r\n```\r\n\r\n<a name=\"inspecting-models\"></a>\r\n#### 检查模型\r\n\r\n有时，仅仅通过略读代码来确定一个模型的所有可用属性和关系是很困难的。作为替代，试试 `model:show` Artisan 命令，它提供了一个对于模型的所有属性和关系的方便概述。\r\n\r\n```shell\r\nphp artisan model:show Flight\r\n```\r\n\r\n<a name=\"eloquent-model-conventions\"></a>\r\n## Eloquent 模型约定\r\n\r\n由 `make:model` 命令生成的模型会被放置在 `app/Models` 目录下。让我们检查一个基本的模型类并讨论 Eloquent 的一些关键约定：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        // ...\r\n    }\r\n\r\n<a name=\"table-names\"></a>\r\n### 数据表名称\r\n\r\n看了上面的例子，你可能已经注意到我们没有告诉 Eloquent 哪个数据库表对应我们的 `Flight` 模型。按照约定，除非明确指定另一个名称，类名称的下划线格式的复数形态将被用作表名。因此，在这个例子中，Eloquent 将假定 `Flight` 模型将记录存储在 `flights` 表中，而 `AirTrafficController`  模型将记录存储在 `air_traffic_controllers` 表中。\r\n\r\n如果你的模型对应的数据表不符合这个约定，你可以通过在模型上定义一个 `table` 属性来手动指定模型的表名：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 与模型关联的数据表。\r\n         *\r\n         * @var string\r\n         */\r\n        protected $table = 'my_flights';\r\n    }\r\n\r\n<a name=\"primary-keys\"></a>\r\n### 主键\r\n\r\nEloquent 还会假设每个模型对应的数据表都有一个名为 `id` 的列作为主键。如有必要，你可以在模型上定义一个受保护的 `$primaryKey` 属性，来指定一个不同的列名称用作模型的主键：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 与数据表关联的主键。\r\n         *\r\n         * @var string\r\n         */\r\n        protected $primaryKey = 'flight_id';\r\n    }\r\n\r\n此外，Eloquent 默认有一个 integer 值的主键，Eloquent 会自动转换这个主键为一个 integer 类型，如果你的主键不是自增或者不是数字类型，你可以在你的模型上定义一个 public 属性的 `$incrementing` ，并将其设置为 `false`：\r\n\r\n    <?php\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 指明模型的ID是否自动递增。\r\n         *\r\n         * @var bool\r\n         */\r\n        public $incrementing = false;\r\n    }\r\n\r\n如果你的模型主键不是 `integer`，应该定义一个 `protected $keyType` 属性在模型上，其值应为 `string`：\r\n\r\n    <?php\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 自动递增ID的数据类型。\r\n         *\r\n         * @var string\r\n         */\r\n        protected $keyType = 'string';\r\n    }\r\n\r\n<a name=\"composite-primary-keys\"></a>\r\n#### 复合主键\r\n\r\nEloquent 要求每个模型至少有一个可以作为其主键的唯一标识 ID。它不支持「复合」主键。但是，除了表的唯一标识主键之外，还可以向数据库表添加额外的多列唯一索引。\r\n\r\n<a name=\"uuid-and-ulid-keys\"></a>\r\n### UUID 与 ULID 键\r\n\r\n你可以选择使用UUID，而不是使用自动递增的整数作为Elquent模型的主键。UUID是36个字符长的通用唯一字母数字标识符。\r\n\r\n如果你希望模型使用UUID键而不是自动递增的整数键，可以在模型上使用 `Illuminate\\Database\\Eloquent\\Concerns\\HasUuids`  trait，在此情况下应该确保模型具有 [UUID相等的主键列](/docs/laravel/10.x/migrations#column-method-uuid):\r\n\r\n    use Illuminate\\Database\\Eloquent\\Concerns\\HasUuids;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Article extends Model\r\n    {\r\n        use HasUuids;\r\n\r\n        // ...\r\n    }\r\n\r\n    $article = Article::create(['title' => 'Traveling to Europe']);\r\n\r\n    $article->id; // \"8f8e8478-9035-4d23-b9a7-62f4d2612ce5\"\r\n\r\n\r\n默认情况下，`HasUuids` trait 将会为模型生成 [「ordered」 UUIDs](/docs/laravel/10.x/helpers#method-str-ordered-uuid) 。 这些 UUIDs 对于索引数据库存储更有效，因为它们可以按字典顺序进行排序。\r\n\r\n通过在模型中定义一个 `newUniqueId` 方法，你可以推翻给定模型的 UUID 生成方法。此外，你可以通过模型中的 `uniqueIds` 方法，来指定哪个字段是需要接收 UUIDs:\r\n\r\n    use Ramsey\\Uuid\\Uuid;\r\n\r\n    /**\r\n     * 为模型生成一个新的 UUID。\r\n     */\r\n    public function newUniqueId(): string\r\n    {\r\n        return (string) Uuid::uuid4();\r\n    }\r\n\r\n    /**\r\n     * 获取应该接收唯一标识符的列。\r\n     *\r\n     * @return array<int, string>\r\n     */\r\n    public function uniqueIds(): array\r\n    {\r\n        return ['id', 'discount_code'];\r\n    }\r\n\r\n如果你愿意，你可以选择利用 「ULIDs」 来替代 UUIDs。 ULIDs 类似于 UUIDs； 然而，它们的长度仅为 26 字符。类似于订单 UUIDs， ULIDs 是字典顺序排序，以实现高效的数据索引。为了利用 ULIDs， 你需要在你的模型中引用 `Illuminate\\Database\\Eloquent\\Concerns\\HasUlids` trait。 同样还需要确保模型中有一个 [ULID 匹配的主键字段](/docs/laravel/10.x/migrations#column-method-ulid):\r\n\r\n    use Illuminate\\Database\\Eloquent\\Concerns\\HasUlids;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Article extends Model\r\n    {\r\n        use HasUlids;\r\n\r\n        // ...\r\n    }\r\n\r\n    $article = Article::create(['title' => 'Traveling to Asia']);\r\n\r\n    $article->id; // \"01gd4d3tgrrfqeda94gdbtdk5c\"\r\n\r\n<a name=\"timestamps\"></a>\r\n### 时间戳\r\n\r\n默认情况下，Eloquent 需要 `created_at` 和 `updated_at` 字段存在你的模型数据表中。当模型被创建或更新时，Eloquent 将自动地设置这些字段的值。如果你不想让这些字段被 Eloquent 自动管理，你需要在你的模型中定义一个 `$timestamps` 属性并赋值为 `false`:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 指示模型是否主动维护时间戳。\r\n         *\r\n         * @var bool\r\n         */\r\n        public $timestamps = false;\r\n    }\r\n\r\n如果你需要自定义模型时间戳的格式，请在模型上设置 `$dateFormat` 属性。以此来定义时间戳在数据库中的存储方式以及模型序列化为数组或 JSON 时的格式：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 模型日期字段的存储格式。\r\n         *\r\n         * @var string\r\n         */\r\n        protected $dateFormat = 'U';\r\n    }\r\n\r\n如果需要自定义用于存储时间戳的字段的名称，可以在模型上定义 `CREATED_AT` 和 `UPDATED_AT` 常量：\r\n\r\n    <?php\r\n\r\n    class Flight extends Model\r\n    {\r\n        const CREATED_AT = 'creation_date';\r\n        const UPDATED_AT = 'updated_date';\r\n    }\r\n\r\n如果你想在不修改模型的 `updated_at` 时间戳的情况下执行模型操作，你可以在给 `withoutTimestamps` 方法的闭包中对模型进行操作：\r\n\r\n    Model::withoutTimestamps(fn () => $post->increment(['reads']));\r\n\r\n<a name=\"database-connections\"></a>\r\n### 数据库连接\r\n\r\n默认情况下，所有 Eloquent 模型使用的是应用程序配置的默认数据库连接。如果想指定在与特定模型交互时应该使用的不同连接，可以在模型上定义 `$connection` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 设置当前模型使用的数据库连接名。\r\n         *\r\n         * @var string\r\n         */\r\n        protected $connection = 'sqlite';\r\n    }\r\n\r\n<a name=\"default-attribute-values\"></a>\r\n### 默认属性值\r\n\r\n默认情况下，被实例化的模型不会包含任何属性值。如果你想为模型的某些属性定义默认值，可以在模型上定义一个 `$attributes` 属性。放在 `$attributes` 数组中的属性值应该是原始的，“可存储的”格式，就像它们刚刚从数据库中读取一样：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 模型的属性默认值。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $attributes = [\r\n            'options' => '[]',\r\n            'delayed' => false,\r\n        ];\r\n    }\r\n\r\n<a name=\"configuring-eloquent-strictness\"></a>\r\n### 配置严格 Eloquent\r\n\r\nLaravel 提供了几种方法允许你在各种情况下配置 Eloquent 的行为和其「严格性」。\r\n\r\n首先，`preventLazyLoading` 方法接受一个可选的布尔参数，它代表是否需要禁用延迟加载。例如，你可能希望仅在非生产环境下禁用延迟加载，以便即使在生产环境中的代码意外出现延迟加载关系，你的生产环境也可以继续正常运行。一般来说，该方法应该在应用程序的 `AppServiceProvider` 的 `boot` 方法中调用：\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\n/**\r\n * 启动任意应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Model::preventLazyLoading(! $this->app->isProduction());\r\n}\r\n```\r\n\r\n此外，你可以通过调用 `preventSilentlyDiscardingAttributes` 方法来让 Laravel 在使用尝试填充一个不能填充的属性的时候抛出一个异常。这有助于防止在本地开发过程中尝试设置尚未到模型的 `fillable` 数组中的属性时出现意外情况：\r\n\r\n```php\r\nModel::preventSilentlyDiscardingAttributes(! $this->app->isProduction());\r\n```\r\n\r\n最后，在你尝试访问模型上的一个无法从数据库中检索到或是该属性不存在的时候，你可能想要让 Eloquent 抛出一个异常。例如，当你忘记将属性添加到 Eloquent 查询的 `select` 子句时候，便可能发生这样的情况。\r\n\r\n```php\r\nModel::preventAccessingMissingAttributes(! $this->app->isProduction());\r\n```\r\n\r\n<a name=\"enabling-eloquent-strict-mode\"></a>\r\n#### 启用 Eloquent 的严格模式\r\n\r\n为了方便，你可以通过调用 `shouldBeStrict` 方法来启用上述的三种方法：\r\n\r\n```php\r\nModel::shouldBeStrict(! $this->app->isProduction());\r\n```\r\n\r\n<a name=\"retrieving-models\"></a>\r\n## 检索模型\r\n\r\n一旦你创建了一个模型和 [其关联的数据库表](/docs/laravel/10.x/migrations#writing-migrations)，就可以开始从数据库中检索数据了。可以将每个 Eloquent 模型视为一个强大的[查询构建器](/docs/laravel/10.x/queries) ，让你能流畅地查询与该模型关联的数据库表。模型中的 `all` 方法将从模型的关联数据库表中检索所有记录：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    foreach (Flight::all() as $flight) {\r\n        echo $flight->name;\r\n    }\r\n\r\n<a name=\"building-queries\"></a>\r\n#### 构建查询\r\n\r\nEloquent 的 `all` 方法会返回模型中所有的结果。由于每个 Eloquent 模型都可以被视为[查询构建器](/docs/laravel/10.x/queries)，可以添加额外的查询条件，然后使用 `get` 方法获取查询结果：\r\n\r\n    $flights = Flight::where('active', 1)\r\n                   ->orderBy('name')\r\n                   ->take(10)\r\n                   ->get();\r\n\r\n> **技巧**  \r\n> 由于 Eloquent 模型是查询构建器，因此你应该查看 Laravel 的[查询构建器](/docs/laravel/10.x/queries)提供的所有方法。在编写 Eloquent 查询时，这些是通用的。\r\n\r\n<a name=\"refreshing-models\"></a>\r\n#### 刷新模型\r\n\r\n如果已经有一个从数据库中检索到的 Eloquent 模型的实例，你可以使用  `fresh` 和 `refresh`方法「刷新」模型。 `fresh` 方法将从数据库中重新检索模型。现有模型实例不会受到影响：\r\n\r\n    $flight = Flight::where('number', 'FR 900')->first();\r\n\r\n    $freshFlight = $flight->fresh();\r\n\r\n `refresh` 方法会使用数据库中的新数据重新赋值现有的模型。此外，已经加载的关系也会被重新加载：\r\n\r\n    $flight = Flight::where('number', 'FR 900')->first();\r\n\r\n    $flight->number = 'FR 456';\r\n\r\n    $flight->refresh();\r\n\r\n    $flight->number; // \"FR 900\"\r\n\r\n\r\n\r\n<a name=\"collections\"></a>\r\n### 集合\r\n\r\n正如我们所见，像 `all` 和 `get` 这样的 Eloquent 方法从数据库中检索出多条记录。但是，这些方法不会返回一个普通的 PHP 数组。相反，会返回一个 `Illuminate\\Database\\Eloquent\\Collection` 的实例。\r\n\r\nEloquent `Collection` 类扩展了 Laravel 的 `Illuminate\\Support\\Collection` 基类，它提供了[大量的辅助方法](/docs/laravel/10.x/collections#available-methods)来与数据集合交互。例如，`reject` 方法可用于根据调用闭包的结果从集合中删除模型：\r\n\r\n```php\r\n$flights = Flight::where('destination', 'Paris')->get();\r\n\r\n$flights = $flights->reject(function (Flight $flight) {\r\n    return $flight->cancelled;\r\n});\r\n```\r\n\r\n除了 Laravel 的基础集合类提供的方法之外，Eloquent 集合类还提供了[一些额外的方法](/docs/laravel/10.x/eloquent-collections#available-methods)，专门用于与 Eloquent 的模型。\r\n\r\n由于 Laravel 的所有集合都实现了 PHP 的可迭代接口，因此你可以像数组一样循环遍历集合：\r\n\r\n```php\r\nforeach ($flights as $flight) {\r\n    echo $flight->name;\r\n}\r\n```\r\n\r\n<a name=\"chunking-results\"></a>\r\n### 结果分块\r\n\r\n如果你尝试通过`all` 或 `get` 方法加载数万条 Eloquent 记录，你的应用程序可能会耗尽内存。为了避免出现这种情况， `chunk` 方法可以用来更有效地处理这些大量数据。\r\n\r\n`chunk` 方法将传递 Eloquent 模型的子集，将它们交给闭包进行处理。由于一次只检索当前的 Eloquent 模型块的数据，所以当处理大量模型数据时， `chunk` 方法将显着减少内存使用：\r\n\r\n```php\r\nuse App\\Models\\Flight;\r\nuse Illuminate\\Database\\Eloquent\\Collection;\r\n\r\nFlight::chunk(200, function (Collection $flights) {\r\n    foreach ($flights as $flight) {\r\n        // ...\r\n    }\r\n});\r\n```\r\n\r\n传递给`chunk`方法的第一个参数是每个分块检索的数据数量。第二个参数传递的闭包将方法将应用到每个分块，以数据库中查询到的分块结果来作为参数。\r\n\r\n如果要根据一个字段来过滤`chunk`方法拿到的数据，同时，这个字段的数据在遍历的时候还需要更新的话，那么可以使用「chunkById」方法。在这种场景下如果使用`chunk`方法的话，得到的结果可能和预想中的不一样。在`chunkById` 方法的内部，默认会查询 id 字段大于前一个分块中最后一个模型的 id。\r\n\r\n```php\r\nFlight::where('departed', true)\r\n    ->chunkById(200, function (Collection $flights) {\r\n        $flights->each->update(['departed' => false]);\r\n    }, $column = 'id');\r\n```\r\n\r\n<a name=\"chunking-using-lazy-collections\"></a>\r\n### 使用惰性集合进行分块\r\n\r\n`lazy` 方法的工作方式类似于 [`chunk` 方法](#chunking-results)，因为它在后台以块的形式执行查询。 然而，`lazy` 方法不是将每个块直接传递到回调中，而是返回 Eloquent 模型的扁平化 [`LazyCollection`](/docs/laravel/10.x/collections#lazy-collections)，它可以让你将结果作为单个流进行交互：\r\n\r\n```php\r\nuse App\\Models\\Flight;\r\n\r\nforeach (Flight::lazy() as $flight) {\r\n    // ...\r\n}\r\n```\r\n\r\n如果要根据一个字段来过滤`lazy`方法拿到的数据，同时，这个字段的数据在遍历的时候还需要更新的话，那么可以使用`lazyById`方法。在`lazyById` 方法的内部，默认会查询 id 字段大于前一个`chunk`中最后一个模型的 id 。\r\n\r\n```php\r\nFlight::where('departed', true)\r\n    ->lazyById(200, $column = 'id')\r\n    ->each->update(['departed' => false]);\r\n```\r\n\r\n\r\n\r\n你可以使用 `lazyByIdDesc` 方法根据 `id` 的降序过滤结果。\r\n\r\n<a name=\"cursors\"></a>\r\n### 游标\r\n\r\n与 `lazy` 方法类似，`cursor` 方法可用于在查询数万条 Eloquent 模型记录时减少内存的使用。\r\n\r\n`cursor` 方法只会执行一次数据库查询；但是，各个 Eloquent 模型在实际迭代之前不会被数据填充。因此，在遍历游标时，在任何给定时间，只有一个 Eloquent 模型保留在内存中。\r\n\r\n> **注意**  \r\n> 由于 `cursor` 方法一次只能在内存中保存一个 Eloquent 模型，因此它不能预加载关系。如果需要预加载关系，请考虑使用[`lazy` 方法](#chunking-using-lazy-collections)。\r\n\r\n在内部，`cursor` 方法使用 PHP [generators](https://www.php.net/manual/en/language.generators.overview.php) 来实现此功能：\r\n\r\n```php\r\nuse App\\Models\\Flight;\r\n\r\nforeach (Flight::where('destination', 'Zurich')->cursor() as $flight) {\r\n    // ...\r\n}\r\n```\r\n\r\n`cursor` 返回一个 `Illuminate\\Support\\LazyCollection` 实例。[惰性集合](/docs/laravel/10.x/collections#lazy-collections) 可以使用 Laravel 集合中的可用方法，同时一次仅将单个模型加载到内存中：\r\n\r\n```php\r\nuse App\\Models\\User;\r\n\r\n$users = User::cursor()->filter(function (User $user) {\r\n    return $user->id > 500;\r\n});\r\n\r\nforeach ($users as $user) {\r\n    echo $user->id;\r\n}\r\n```\r\n\r\n尽管 `cursor` 方法使用的内存比常规查询要少得多（一次只在内存中保存一个 Eloquent 模型），但它最终仍会耗尽内存。这是[由于 PHP 的 PDO 驱动程序内部将所有原始查询结果缓存在其缓冲区中](https://www.php.net/manual/en/mysqlinfo.concepts.buffering.php)。 如果要处理大量 Eloquent 记录，请考虑使用 [`lazy` 方法](#chunking-using-lazy-collections)。\r\n\r\n<a name=\"advanced-subqueries\"></a>\r\n### 高级子查询\r\n\r\n<a name=\"subquery-selects\"></a>\r\n#### selects 子查询\r\n\r\nEloquent 还提供高级子查询支持，你可以在单条语句中从相关表中提取信息。 例如，假设我们有一个航班目的地表`destinations`和一个到达这些目的地的航班表`flights`。 `flights` 表包含一个 `arrived_at` 字段，指示航班何时到达目的地。\r\n\r\n使用查询生成器可用的子查询功能 `select` 和 `addSelect` 方法，我们可以用单条语句查询全部目的地 `destinations` 和 抵达各目的地最后一班航班的名称：\r\n\r\n    use App\\Models\\Destination;\r\n    use App\\Models\\Flight;\r\n\r\n    return Destination::addSelect(['last_flight' => Flight::select('name')\r\n        ->whereColumn('destination_id', 'destinations.id')\r\n        ->orderByDesc('arrived_at')\r\n        ->limit(1)\r\n    ])->get();\r\n\r\n<a name=\"subquery-ordering\"></a>\r\n#### 子查询排序\r\n\r\n此外，查询构建器的 `orderBy` 也同样支持子查询。继续使用我们的航班为例，根据最后一次航班到达该目的地的时间对所有目的地进行排序。这同样可以在执行单个数据库查询时完成：\r\n\r\n    return Destination::orderByDesc(\r\n        Flight::select('arrived_at')\r\n            ->whereColumn('destination_id', 'destinations.id')\r\n            ->orderByDesc('arrived_at')\r\n            ->limit(1)\r\n    )->get();\r\n\r\n<a name=\"retrieving-single-models\"></a>\r\n## 检索单个模型 / 聚合\r\n\r\n除了检索与给定查询匹配的所有记录之外，还可以使用 `find`、`first` 或 `firstWhere` 方法检索单个记录。 这些方法不是返回模型集合，而是返回单个模型实例：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    // 通过主键检索模型...\r\n    $flight = Flight::find(1);\r\n\r\n    // 检索与查询约束匹配的第一个模型...\r\n    $flight = Flight::where('active', 1)->first();\r\n\r\n    // 替代检索与查询约束匹配的第一个模型...\r\n    $flight = Flight::firstWhere('active', 1);\r\n\r\n有时你可能希望检索查询的第一个结果或在未找到结果时执行一些其他操作。`firstOr` 方法将返回匹配查询的第一个结果，或者，如果没有找到结果，则执行给定的闭包。闭包返回的值将被视为 `firstOr` 方法的结果：\r\n\r\n    $flight = Flight::findOr(1, function () {\r\n        // ...\r\n    });\r\n\r\n    $flight = Flight::where('legs', '>', 3)->firstOr(function () {\r\n        // ...\r\n    });\r\n\r\n<a name=\"not-found-exceptions\"></a>\r\n#### 未找到时抛出异常\r\n\r\n如果找不到模型，你可能希望抛出异常。这在路由或控制器中特别有用。 `findOrFail` 和 `firstOrFail` 方法将检索查询的第一个结果；但是，如果没有找到结果，则会抛出 `Illuminate\\Database\\Eloquent\\ModelNotFoundException`：\r\n\r\n    $flight = Flight::findOrFail(1);\r\n\r\n    $flight = Flight::where('legs', '>', 3)->firstOrFail();\r\n\r\n如果没有捕获到 `ModelNotFoundException`，则会自动将 404 HTTP 响应发送回客户端：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    Route::get('/api/flights/{id}', function (string $id) {\r\n        return Flight::findOrFail($id);\r\n    });\r\n\r\n<a name=\"retrieving-or-creating-models\"></a>\r\n### 检索或创建模型\r\n\r\n`firstOrCreate` 方法将尝试使用给定的列 / 值对来查找数据库记录。如果在数据库中找不到该模型，则将插入一条记录，其中包含将第一个数组参数与可选的第二个数组参数合并后产生的属性：\r\n\r\n`firstOrNew` 方法，类似 `firstOrCreate`，会尝试在数据库中找到与给定属性匹配的记录。如果没有找到，则会返回一个新的模型实例。请注意，由 `firstOrNew` 返回的模型尚未持久化到数据库中。需要手动调用 `save` 方法来保存它：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    // 按名称检索航班，如果不存在则创建它...\r\n    $flight = Flight::firstOrCreate([\r\n        'name' => 'London to Paris'\r\n    ]);\r\n\r\n    // 按名称检索航班或使用名称、延迟和到达时间属性创建它...\r\n    $flight = Flight::firstOrCreate(\r\n        ['name' => 'London to Paris'],\r\n        ['delayed' => 1, 'arrival_time' => '11:30']\r\n    );\r\n\r\n    // 按名称检索航班或实例化一个新的航班实例...\r\n    $flight = Flight::firstOrNew([\r\n        'name' => 'London to Paris'\r\n    ]);\r\n\r\n    // 按名称检索航班或使用名称、延迟和到达时间属性实例化...\r\n    $flight = Flight::firstOrNew(\r\n        ['name' => 'Tokyo to Sydney'],\r\n        ['delayed' => 1, 'arrival_time' => '11:30']\r\n    );\r\n\r\n\r\n\r\n<a name=\"retrieving-aggregates\"></a>\r\n### 检索聚合\r\n\r\n当使用 Eloquent 模型交互的时候，你可以使用 `count`、`sum`、`max`，以及一些 laravel [查询生成器](/docs/laravel/10.x/queries)提供的其他[聚合方法](/docs/laravel/10.x/queries#aggregates)。如你所需要的，这些方法会返回一个数字值而不是 Eloquent 模型实例：\r\n\r\n    $count = Flight::where('active', 1)->count();\r\n\r\n    $max = Flight::where('active', 1)->max('price');\r\n\r\n<a name=\"inserting-and-updating-models\"></a>\r\n## 新增 & 更新模型\r\n\r\n<a name=\"inserts\"></a>\r\n### 新增\r\n\r\n显然，使用 Eloquent 的时候，我们不仅需要从数据库中检索模型，同时也需要新增新的数据记录。值得高兴的是，对于这种需求 Eloquent 可以从容应对。为了向数据库新增新的数据记录，你需要实例化一个新的模型实例并且为它的属性赋值，然后调用这个实例的 `save` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use App\\Http\\Controllers\\Controller;\r\n    use App\\Models\\Flight;\r\n    use Illuminate\\Http\\RedirectResponse;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    class FlightController extends Controller\r\n    {\r\n        /**\r\n         * 向数据库中存储条新的航班信息.\r\n         */\r\n        public function store(Request $request): RedirectResponse\r\n        {\r\n            // 验证request...\r\n\r\n            $flight = new Flight;\r\n\r\n            $flight->name = $request->name;\r\n\r\n            $flight->save();\r\n\r\n            return redirect('/flights');\r\n        }\r\n    }\r\n\r\n在这个例子中，我们使用来自 HTTP request 请求中的 `name` 参数值来对 `App\\Models\\Flight` 模型实例的`name`属性赋值，当我们调用 `save` 方法时，数据库便会增加一条数据记录，模型的 `created_at` 和 `updated_at` 字段将会在调用 `save` 方法时自动设置为相应的时间, 所以不需要手动去设置这两个属性。\r\n\r\n\r\n\r\n或者，可以使用 `create` 方法使用单个 PHP 语句「保存」一个新模型。插入的模型实例将通过 `create` 方法返回：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flight = Flight::create([\r\n        'name' => 'London to Paris',\r\n    ]);\r\n\r\n但是，在使用 `create` 方法之前，你需要在模型类上指定 `fillable` 或 `guarded` 属性。这些属性是必需的，因为默认情况下，所有 Eloquent 模型都受到保护，免受批量赋值漏洞的影响。 要了解有关批量赋值的更多信息，请参阅[批量赋值文档](#mass-assignment)。\r\n\r\n<a name=\"updates\"></a>\r\n### 更新\r\n\r\n`save` 方法也可以用来更新数据库中已经存在的模型。要更新模型，应该检索它并设置你想更新的任何属性。然后调用模型的 `save` 方法。 同样，`updated_at` 时间戳将自动更新，因此无需手动设置其值：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flight = Flight::find(1);\r\n\r\n    $flight->name = 'Paris to London';\r\n\r\n    $flight->save();\r\n\r\n<a name=\"mass-updates\"></a>\r\n#### 批量更新\r\n\r\n还可以批量更新与给定条件匹配的所有模型。在此示例中，所有 `active` 且 `destination` 为 `San Diego` 的航班都将被标记为延迟：\r\n\r\n    Flight::where('active', 1)\r\n          ->where('destination', 'San Diego')\r\n          ->update(['delayed' => 1]);\r\n\r\n`update` 方法需要一个表示应该更新的列的列和值对数组。`update` 方法返回受影响的行数。\r\n\r\n> **注意**  \r\n> 通过 Eloquent 批量更新时，不会触发模型的 `saving`、`saved`、`updating` 和 `updated` 模型事件。 这是因为在批量更新时从未真正检索到模型。\r\n\r\n<a name=\"examining-attribute-changes\"></a>\r\n#### 检查属性变更\r\n\r\nEloquent 提供了 `isDirty`、`isClean` 和 `wasChanged` 方法来检查模型的内部状态，并确定它的属性与最初检索模型时的变化情况。\r\n\r\n`isDirty` 方法确定模型的任何属性在检索模型后是否已更改。你可以传递特定的属性名称来确定它是否「变脏」。`isClean` 方法将确定自检索模型以来属性是否保持不变。 它也接受可选的属性参数：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::create([\r\n        'first_name' => 'Taylor',\r\n        'last_name' => 'Otwell',\r\n        'title' => 'Developer',\r\n    ]);\r\n\r\n    $user->title = 'Painter';\r\n\r\n    $user->isDirty(); // true\r\n    $user->isDirty('title'); // true\r\n    $user->isDirty('first_name'); // false\r\n    $user->isDirty(['first_name', 'title']); // true\r\n\r\n    $user->isClean(); // false\r\n    $user->isClean('title'); // false\r\n    $user->isClean('first_name'); // true\r\n    $user->isClean(['first_name', 'title']); // false\r\n\r\n    $user->save();\r\n\r\n    $user->isDirty(); // false\r\n    $user->isClean(); // true\r\n\r\n\r\n`wasChanged` 方法确定在当前请求周期内最后一次保存模型时是否更改了任何属性。你还可以传递属性名称以查看特定属性是否已更改：\r\n\r\n    $user = User::create([\r\n        'first_name' => 'Taylor',\r\n        'last_name' => 'Otwell',\r\n        'title' => 'Developer',\r\n    ]);\r\n\r\n    $user->title = 'Painter';\r\n\r\n    $user->save();\r\n\r\n    $user->wasChanged(); // true\r\n    $user->wasChanged('title'); // true\r\n    $user->wasChanged(['title', 'slug']); // true\r\n    $user->wasChanged('first_name'); // false\r\n    $user->wasChanged(['first_name', 'title']); // true\r\n\r\n`getOriginal` 方法返回一个包含模型原始属性的数组，忽略加载模型之后进行的任何更改。你也可以传递特定的属性名称来获取特定属性的原始值：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->name; // John\r\n    $user->email; // john@example.com\r\n\r\n    $user->name = \"Jack\";\r\n    $user->name; // Jack\r\n\r\n    $user->getOriginal('name'); // John\r\n    $user->getOriginal(); // 原始属性数组\r\n\r\n\r\n\r\n<a name=\"mass-assignment\"></a>\r\n### 批量赋值\r\n\r\n你可以使用`create`方法使用单个 PHP 语句「保存」一个新模型。插入的模型实例将通过该方法返回：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flight = Flight::create([\r\n        'name' => 'London to Paris',\r\n    ]);\r\n\r\n但是，在使用 `create` 方法之前，需要在模型类上指定 `fillable` 或 `guarded` 属性。 这些属性是必需的，因为默认情况下，所有 Eloquent 模型都受到保护，免受批量分配漏洞的影响。\r\n\r\n当用户传递一个意外的 HTTP 请求字段并且该字段更改了你的数据库中的一个字段，而你没有预料到时，就会出现批量分配漏洞。 例如，恶意用户可能通过 HTTP 请求发送 `is_admin` 参数，然后将其传递给模型的 `create` 方法，从而允许用户将自己升级为管理员。\r\n\r\n因此，你应该定义要使哪些模型属性可批量分配。可以使用模型上的 `$fillable` 属性来执行此操作。 例如，让 `Flight` 模型的 `name` 属性可以批量赋值：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Flight extends Model\r\n    {\r\n        /**\r\n         * 可批量赋值的属性。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $fillable = ['name'];\r\n    }\r\n\r\n一旦你指定了哪些属性是可批量分配的，可以使用 `create` 方法在数据库中插入一条新记录。`create` 方法返回新创建的模型实例\r\n\r\n    $flight = Flight::create(['name' => 'London to Paris']);\r\n\r\n如果你已经有一个模型实例，你可以使用 `fill` 方法来填充它的属性数组：\r\n\r\n    $flight->fill(['name' => 'Amsterdam to Frankfurt']);\r\n\r\n\r\n<a name=\"mass-assignment-json-columns\"></a>\r\n#### 批量赋值 & JSON 列\r\n\r\n分配 JSON 列时，必须在模型的 `$fillable` 数组中指定每个列的批量分配键。为了安全起见，Laravel 不支持在使用 `guarded` 属性时更新嵌套的 JSON 属性：\r\n\r\n    /**\r\n     * 可以批量赋值的属性。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $fillable = [\r\n        'options->enabled',\r\n    ];\r\n\r\n<a name=\"allowing-mass-assignment\"></a>\r\n#### 允许批量分配\r\n\r\n如果你想让所有属性都可以批量赋值，你可以将 `$guarded` 定义成一个空数组。如果你选择解除你的模型的保护，你应该时刻特别注意传递给 Eloquent 的 `fill`、`create` 和 `update` 方法的数组：\r\n\r\n    /**\r\n     * 不可以批量赋值的属性。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $guarded = [];\r\n\r\n<a name=\"mass-assignment-exceptions\"></a>\r\n#### 批量作业异常抛出\r\n\r\n默认情况下，在执行批量分配操作时，未包含在`$fillable`数组中的属性将被静默丢弃。 在生产环境中，这是预期行为; 然而，在局部开发过程中，它可能导致为什么模型更改没有生效的困惑。\r\n\r\n如果你愿意，你可以指示Laravel在试图通过调用` preventSilentlyDiscardingAttributes`方法填充一个不可填充的属性时抛出一个异常。 通常，这个方法在应用程序服务提供者的`boot `方法中调用:\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    /**\r\n     * 加载任意应用服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Model::preventSilentlyDiscardingAttributes($this->app->isLocal());\r\n    }\r\n\r\n<a name=\"upserts\"></a>\r\n### 新增或更新\r\n\r\n有时，如果不存在匹配的模型，你可能需要更新现有模型或创建新模型。与 `firstOrCreate` 方法一样，`updateOrCreate` 方法会持久化模型，因此无需手动调用 `save` 方法。\r\n\r\n\r\n在下面的示例中，如果存在`departure`位置为`Oakland`且`destination`位置为`San Diego`的航班，则其`price`和`discounted`列将被更新。 如果不存在这样的航班，将创建一个新航班，该航班具有将第一个参数数组与第二个参数数组合并后的属性：\r\n\r\n    $flight = Flight::updateOrCreate(\r\n        ['departure' => 'Oakland', 'destination' => 'San Diego'],\r\n        ['price' => 99, 'discounted' => 1]\r\n    );\r\n\r\n如果你想在单个查询中执行多个「新增或更新」，那么应该使用 `upsert` 方法。该方法的第一个参数包含要插入或更新的值，而第二个参数列出了在关联表中唯一标识记录的列。该方法的第三个也是最后一个参数是一个列数组，如果数据库中已经存在匹配的记录，则应该更新这些列。如果在模型上启用了时间戳，`upsert` 方法将自动设置 `created_at` 和 `updated_at` 时间戳：\r\n\r\n    Flight::upsert([\r\n        ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],\r\n        ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]\r\n    ], ['departure', 'destination'], ['price']);\r\n\r\n> **注意**  \r\n> 除SQL Server外，其他所有数据库都要求`upsert`方法的第二个参数中的列具有主键索引或唯一索引。 此外，MySQL数据库驱动程序忽略了`upsert` 方法的第二个参数，总是使用表的主键索引和唯一索引来检测现有的记录\r\n\r\n<a name=\"deleting-models\"></a>\r\n## 删除模型\r\n\r\n想删除模型，你可以调用模型实例的 `delete` 方法:\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flight = Flight::find(1);\r\n\r\n    $flight->delete();\r\n\r\n\r\n\r\n你可以调用 `truncate` 方法来删除所有模型关联的数据库记录。 `truncate` 操作还将重置模型关联表上的所有自动递增 ID：\r\n\r\n    Flight::truncate();\r\n\r\n<a name=\"deleting-an-existing-model-by-its-primary-key\"></a>\r\n#### 通过其主键删除现有模型\r\n\r\n在上面的示例中，我们在调用`delete`方法之前从数据库中检索模型。但是，如果你知道模型的主键，则可以通过调用 `destroy` 方法删除模型而无需显式检索它。除了接受单个主键之外，`destroy` 方法还将接受多个主键、主键数组或主键 [集合](/docs/laravel/10.x/collections)：\r\n\r\n    Flight::destroy(1);\r\n\r\n    Flight::destroy(1, 2, 3);\r\n\r\n    Flight::destroy([1, 2, 3]);\r\n\r\n    Flight::destroy(collect([1, 2, 3]));\r\n\r\n> **注意**  \r\n> `destroy` 方法单独加载每个模型并调用 `delete` 方法，以便为每个模型正确调度 `deleting` 和 `deleted` 事件。\r\n\r\n<a name=\"deleting-models-using-queries\"></a>\r\n#### 使用查询删除模型\r\n\r\n当然，你可以构建一个 Eloquent 查询来删除所有符合你查询条件的模型。在此示例中，我们将删除所有标记为非活动的航班。与批量更新一样，批量删除不会为已删除的模型调度模型事件：\r\n\r\n    $deleted = Flight::where('active', 0)->delete();\r\n\r\n> **注意**  \r\n> 通过 Eloquent 执行批量删除语句时，不会为已删除的模型调度 `deleting` 和 `deleted` 模型事件。这是因为在执行 delete 语句时从未真正检索到模型。\r\n\r\n<a name=\"soft-deleting\"></a>\r\n### 软删除\r\n\r\n\r\n\r\n除了实际从数据库中删除记录之外，Eloquent 还可以「软删除」。软删除不会真的从数据库中删除记录。相反，它在模型上设置了一个 `deleted_at` 属性，记录模型被「删除」的日期和时间。要为模型启用软删除，请将 `Illuminate\\Database\\Eloquent\\SoftDeletes` trait 添加到模型中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\SoftDeletes;\r\n\r\n    class Flight extends Model\r\n    {\r\n        use SoftDeletes;\r\n    }\r\n\r\n> **注意**  \r\n> `SoftDeletes` trait 会自动将 `deleted_at` 属性转换为 `DateTime` / `Carbon` 实例\r\n\r\n当然，你需要把 `deleted_at` 字段添加到数据表中。`Laravel` 的[数据迁移](/docs/laravel/10.x/migrations)有创建这个字段的方法：\r\n\r\n    use Illuminate\\Database\\Schema\\Blueprint;\r\n    use Illuminate\\Support\\Facades\\Schema;\r\n\r\n    Schema::table('flights', function (Blueprint $table) {\r\n        $table->softDeletes();\r\n    });\r\n\r\n    Schema::table('flights', function (Blueprint $table) {\r\n        $table->dropSoftDeletes();\r\n    });\r\n\r\n那现在，当你在模型实例上使用 `delete` 方法，当前日期时间会写入 `deleted_at` 字段。同时，查询出来的结果也会自动排除已被软删除的记录。\r\n\r\n判断模型实例是否已被软删除，可以使用 `trashed` 方法：\r\n\r\n    if ($flight->trashed()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"restoring-soft-deleted-models\"></a>\r\n#### 恢复软删除的模型\r\n\r\n有时你可能希望「撤销」软删除的模型。要恢复软删除的模型，可以在模型实例上调用`restore`方法。 `restore` 方法会将模型的 `deleted_at` 列设置为 `null`：\r\n\r\n    $flight->restore();\r\n\r\n\r\n你也可以在查询中使用 `restore` 方法，从而快速恢复多个模型。和其他「批量」操作一样，这个操作不会触发模型的任何事件：\r\n\r\n    Flight::withTrashed()\r\n            ->where('airline_id', 1)\r\n            ->restore();\r\n\r\n`restore` 方法可以在[关联查询](/docs/laravel/10.x/eloquent-relationships)中使用：\r\n\r\n    $flight->history()->restore();\r\n\r\n<a name=\"permanently-deleting-models\"></a>\r\n#### 永久删除模型\r\n\r\n有时你可能需要从数据库中真正删除模型。要从数据库中永久删除软删除的模型，请使用 `forceDelete` 方法：\r\n\r\n    $flight->forceDelete();\r\n\r\n`forceDelete` 同样可以用在关联查询上:\r\n\r\n    $flight->history()->forceDelete();\r\n\r\n<a name=\"querying-soft-deleted-models\"></a>\r\n### 查询软删除模型\r\n\r\n<a name=\"including-soft-deleted-models\"></a>\r\n#### 包括已软删除的模型\r\n\r\n如上所述，软删除模型将自动从查询结果中排除。但是，你也可以通过在查询上调用 `withTrashed` 方法来强制将软删除模型包含在查询结果中：\r\n\r\n    use App\\Models\\Flight;\r\n\r\n    $flights = Flight::withTrashed()\r\n                    ->where('account_id', 1)\r\n                    ->get();\r\n\r\n`withTrashed` 方法可以在 [关联查询](/docs/laravel/10.x/eloquent-relationships) 中使用\r\n\r\n    $flight->history()->withTrashed()->get();\r\n\r\n<a name=\"retrieving-only-soft-deleted-models\"></a>\r\n#### 仅检索软删除的模型\r\n\r\n`onlyTrashed` 方法将检索 **只被** 软删除模型：\r\n\r\n    $flights = Flight::onlyTrashed()\r\n                    ->where('airline_id', 1)\r\n                    ->get();\r\n\r\n<a name=\"pruning-models\"></a>\r\n## 修剪模型\r\n\r\n有时你可能希望定期删除不再需要的模型。为此，你可以将 `Illuminate\\Database\\Eloquent\\Prunable` 或 `Illuminate\\Database\\Eloquent\\MassPrunable` trait 添加到要定期修剪的模型中。将其中一个 trait 添加到模型后，实现 `prunable` 方法，该方法返回一个 Eloquent 查询构建器，用于检索不再需要的模型数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Prunable;\r\n\r\n    class Flight extends Model\r\n    {\r\n        use Prunable;\r\n\r\n        /**\r\n         * 获取可修剪模型查询构造器。\r\n         */\r\n        public function prunable(): Builder\r\n        {\r\n            return static::where('created_at', '<=', now()->subMonth());\r\n        }\r\n    }\r\n\r\n\r\n\r\n当将模型标记为 `Prunable` 时，你还可以在模型上定义 `pruning` 方法。该方法将在模型被删除之前被调用。在从数据库中永久删除模型之前，此方法可用于删除与模型关联的任何其他资源，例如存储的文件：\r\n\r\n    /**\r\n     * 准备模型进行修剪。\r\n     */\r\n    protected function pruning(): void\r\n    {\r\n        // ...\r\n    }\r\n\r\n配置可修剪模型后，你还应该在应用程序的 `App\\Console\\Kernel` 类中调度 `model:prune` Artisan 命令。你可以自由选择运行此命令的时间间隔：\r\n\r\n    /**\r\n     * 定义应用程序的命令计划。\r\n     */\r\n    protected function schedule(Schedule $schedule): void\r\n    {\r\n        $schedule->command('model:prune')->daily();\r\n    }\r\n\r\n在后台，`model:prune` 命令会自动检测应用程序的 `app/Models` 目录中的「Prunable」模型。 如果模型位于不同的位置，可以使用 `--model` 选项来指定模型类名称：\r\n\r\n    $schedule->command('model:prune', [\r\n        '--model' => [Address::class, Flight::class],\r\n    ])->daily();\r\n\r\n如果你想在修剪所有其他检测到的模型时排除某些模型被修剪，你可以使用 `--except` 选项：\r\n\r\n    $schedule->command('model:prune', [\r\n        '--except' => [Address::class, Flight::class],\r\n    ])->daily();\r\n\r\n你可以通过执行带有 `--pretend` 选项的 `model:prune` 命令来预测你的 `prunable` 查询。预测时，`model:prune` 命令将报告该命令实际运行将修剪多少记录：\r\n\r\n```shell\r\nphp artisan model:prune --pretend\r\n```\r\n\r\n> **注意**  \r\n> 如果软删除模型与可修剪查询匹配，则它们将被永久删除（`forceDelete`）。\r\n\r\n<a name=\"mass-pruning\"></a>\r\n#### 批量修剪模型\r\n\r\n当模型被标记为 `Illuminate\\Database\\Eloquent\\MassPrunable` 特征时，模型会使用批量删除查询从数据库中删除。因此，不会调用 `pruning` 方法，也不会触发 `deleting` 和 `deleted` 模型事件。这是因为模型在删除之前从未真正检索过，因此更高效：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\MassPrunable;\r\n\r\n    class Flight extends Model\r\n    {\r\n        use MassPrunable;\r\n\r\n        /**\r\n         * 获取可修剪模型查询。\r\n         */\r\n        public function prunable(): Builder\r\n        {\r\n            return static::where('created_at', '<=', now()->subMonth());\r\n        }\r\n    }\r\n\r\n<a name=\"replicating-models\"></a>\r\n## 复制模型\r\n\r\n可以使用 `replicate` 方法创建现有模型实例的未保存副本。在拥有共享许多相同属性的模型实例时，此方法特别有用：\r\n\r\n    use App\\Models\\Address;\r\n\r\n    $shipping = Address::create([\r\n        'type' => 'shipping',\r\n        'line_1' => '123 Example Street',\r\n        'city' => 'Victorville',\r\n        'state' => 'CA',\r\n        'postcode' => '90001',\r\n    ]);\r\n\r\n    $billing = $shipping->replicate()->fill([\r\n        'type' => 'billing'\r\n    ]);\r\n\r\n    $billing->save();\r\n\r\n要排除一个或多个属性被复制到新模型，可以将数组传递给 `replicate` 方法：\r\n\r\n    $flight = Flight::create([\r\n        'destination' => 'LAX',\r\n        'origin' => 'LHR',\r\n        'last_flown' => '2020-03-04 11:00:00',\r\n        'last_pilot_id' => 747,\r\n    ]);\r\n\r\n    $flight = $flight->replicate([\r\n        'last_flown',\r\n        'last_pilot_id'\r\n    ]);\r\n\r\n<a name=\"query-scopes\"></a>\r\n## 查询作用域\r\n\r\n<a name=\"global-scopes\"></a>\r\n### 全局作用域\r\n\r\n全局作用域可以为模型的所有查询添加约束。 Laravel 的[软删除](#soft-deleting) 功能就是利用全局范围仅从数据库中检索「未删除」模型。编写全局范围查询可以为模型的每个查询都添加约束条件。\r\n\r\n<a name=\"writing-global-scopes\"></a>\r\n#### 编写全局作用域\r\n\r\n编写全局范围很简单。首先，定义一个实现 `Illuminate\\Database\\Eloquent\\Scope` 接口的类。 Laravel 没有放置作用域类的常规位置，因此你可以自由地将此类放置在你希望的任何目录中。\r\n\r\n`Scope` 接口要求实现 `apply` 方法。 `apply` 方法可以根据需要向查询中添加 `where` 约束或其他类型的子句：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models\\Scopes;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Scope;\r\n\r\n    class AncientScope implements Scope\r\n    {\r\n        /**\r\n         * 将作用域应用于给定的 Eloquent 查询构建器\r\n         */\r\n        public function apply(Builder $builder, Model $model): void\r\n        {\r\n            $builder->where('created_at', '<', now()->subYears(2000));\r\n        }\r\n    }\r\n\r\n> **注意**  \r\n> 如果需要在 `select` 语句里添加字段，应使用 `addSelect` 方法，而不是 `select` 方法。这将有效防止无意中替换现有 `select` 语句的情况。\r\n\r\n<a name=\"applying-global-scopes\"></a>\r\n#### 应用全局作用域\r\n\r\n要将全局作用域分配给模型，需要重写模型的 `booted` 方法并使用 `addGlobalScope` 方法，`addGlobalScope` 方法接受作用域的一个实例作为它的唯一参数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Models\\Scopes\\AncientScope;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 模型的「引导」方法。\r\n         */\r\n        protected static function booted(): void\r\n        {\r\n            static::addGlobalScope(new AncientScope);\r\n        }\r\n    }\r\n\r\n将上例中的作用域添加到 `App\\Models\\User` 模型后，用 `User::all()` 方法将执行以下 SQL 查询：\r\n\r\n```sql\r\nselect * from `users` where `created_at` < 0021-02-18 00:00:00\r\n```\r\n\r\n<a name=\"anonymous-global-scopes\"></a>\r\n#### 匿名全局作用域\r\n\r\nEloquent 同样允许使用闭包定义全局作用域，这样就不需要为一个简单的作用域而编写一个单独的类。使用闭包定义全局作用域时，你应该指定一个作用域名称作为 `addGlobalScope` 方法的第一个参数：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 模型的「引导」方法。\r\n         */\r\n        protected static function booted(): void\r\n        {\r\n            static::addGlobalScope('ancient', function (Builder $builder) {\r\n                $builder->where('created_at', '<', now()->subYears(2000));\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"removing-global-scopes\"></a>\r\n#### 取消全局作用域\r\n\r\n如果需要对当前查询取消全局作用域，需要使用 `withoutGlobalScope` 方法。该方法仅接受全局作用域类名作为它唯一的参数：\r\n\r\n    User::withoutGlobalScope(AncientScope::class)->get();\r\n\r\n或者，如果你使用闭包定义了全局作用域，则应传递分配给全局作用域的字符串名称：\r\n\r\n    User::withoutGlobalScope('ancient')->get();\r\n\r\n如果需要取消部分或者全部的全局作用域的话，需要使用 `withoutGlobalScopes` 方法：\r\n\r\n    // 取消全部全局作用域...\r\n    User::withoutGlobalScopes()->get();\r\n\r\n    // 取消部分作用域...\r\n    User::withoutGlobalScopes([\r\n        FirstScope::class, SecondScope::class\r\n    ])->get();\r\n\r\n<a name=\"local-scopes\"></a>\r\n### 局部作用域\r\n\r\n局部作用域允许定义通用的约束集合以便在应用程序中重复使用。例如，你可能经常需要获取所有「流行」的用户。要定义这样一个范围，只需要在对应的 Eloquent 模型方法前添加 `scope` 前缀。\r\n\r\n作用域总是返回一个查询构造器实例或者`void`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 只查询受欢迎的用户的作用域。\r\n         */\r\n        public function scopePopular(Builder $query): void\r\n        {\r\n            $query->where('votes', '>', 100);\r\n        }\r\n\r\n        /**\r\n         * 只查询 active 用户的作用域。\r\n         */\r\n        public function scopeActive(Builder $query): void\r\n        {\r\n            $query->where('active', 1);\r\n        }\r\n    }\r\n\r\n<a name=\"utilizing-a-local-scope\"></a>\r\n#### 使用局部作用域\r\n\r\n一旦定义了作用域，就可以在查询该模型时调用作用域方法。不过，在调用这些方法时不必包含 `scope` 前缀。甚至可以链式调用多个作用域，例如：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::popular()->active()->orderBy('created_at')->get();\r\n\r\n通过 `or` 查询运算符组合多个 Eloquent 模型作用域可能需要使用闭包来实现正确的[逻辑分组](/docs/laravel/10.x/queries#logical-grouping)：\r\n\r\n    $users = User::popular()->orWhere(function (Builder $query) {\r\n        $query->active();\r\n    })->get();\r\n\r\n然而这可能有点麻烦，所以 Laravel 提供了一个更高阶的 `orWhere` 方法，允许你流畅地将作用域链接在一起，而无需使用闭包：\r\n\r\n    $users = App\\Models\\User::popular()->orWhere->active()->get();\r\n\r\n<a name=\"dynamic-scopes\"></a>\r\n#### 动态作用域\r\n\r\n有时可能地希望定义一个可以接受参数的作用域。把额外参数传递给作用域就可以达到此目的。作用域参数要放在 `$query` 参数之后：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 将查询作用域限制为仅包含给定类型的用户。\r\n         */\r\n        public function scopeOfType(Builder $query, string $type): void\r\n        {\r\n            $query->where('type', $type);\r\n        }\r\n    }\r\n\r\n\r\n一旦将预期的参数添加到作用域方法的签名中，你就可以在调用作用域时传递参数：\r\n\r\n    $users = User::ofType('admin')->get();\r\n\r\n<a name=\"comparing-models\"></a>\r\n## 模型比较\r\n\r\n有时可能需要判断两个模型是否「相同」。`is` 和 `isNot` 方法可以用来快速校验两个模型是否拥有相同的主键、表和数据库连接：\r\n\r\n    if ($post->is($anotherPost)) {\r\n        // ...\r\n    }\r\n\r\n    if ($post->isNot($anotherPost)) {\r\n        // ...\r\n    }\r\n\r\n当使用 `belongsTo`、`hasOne`、`morphTo` 和 `morphOne` [relationships](/docs/laravel/10.x/eloquent-relationships) 时，`is` 和 `isNot` 方法也可用。当你想比较相关模型而不发出查询来检索该模型时，此方法特别有用：\r\n\r\n    if ($post->author()->is($user)) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"events\"></a>\r\n## Events\r\n\r\n> **注意**  \r\n> 想要将 Eloquent 事件直接广播到客户端应用程序？查看 Laravel 的[模型事件广播](/docs/laravel/10.x/broadcasting#model-broadcasting)。\r\n\r\nEloquent 模型触发几个事件，允许你挂接到模型生命周期的如下节点： `retrieved`、`creating`、`created`、`updating`、`updated`、`saving`、`saved`、`deleting`、`deleted`、`restoring`、`restored`、`replicating`。事件允许你每当特定模型保存或更新数据库时执行代码。每个事件通过其构造器接受模型实例。\r\n\r\n当从数据库中检索到现有模型时，将调度 `retrieved` 事件。 当一个新模型第一次被保存时，`creating` 和 `created` 事件将被触发。 `updating` / `updated` 事件将在修改现有模型并调用 `save` 方法时触发。`saving` / `saved` 事件将在创建或更新模型时触发 - 即使模型的属性没有更改。以`-ing`结尾的事件名称在模型的任何更改被持久化之前被调度，而以`-ed`结尾的事件在对模型的更改被持久化之后被调度。\r\n\r\n\r\n要开始监听模型事件，请在 Eloquent 模型上定义一个 $dispatchesEvents 属性。此属性将 Eloquent 模型生命周期的各个点映射到你定义的[事件类](/docs/laravel/10.x/events)。每个模型事件类都应该通过其构造函数接收受影响的模型的实例：\r\n\r\n\t<?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Events\\UserDeleted;\r\n    use App\\Events\\UserSaved;\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Notifiable;\r\n\r\n        /**\r\n         * 模型的事件映射。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $dispatchesEvents = [\r\n            'saved' => UserSaved::class,\r\n            'deleted' => UserDeleted::class,\r\n        ];\r\n    }\r\n\r\n在定义和映射了 Eloquent 事件之后，可以使用 [event listeners](/docs/laravel/10.x/events#defining-listeners) 来处理事件。\r\n\r\n> **注意**  \r\n> 在使用 Eloquent 进行批量更新或删除查询时，受影响的模型不会触发`saved`、`updated`、`deleting`和`deleted`等事件。这是因为在执行批量更新或删除操作时，实际上没有检索到这些模型，所以也就不会触发这些事件。\r\n\r\n<a name=\"events-using-closures\"></a>\r\n### 使用闭包\r\n\r\n你可以注册一些闭包函数来处理模型事件，而不使用自定义事件类。通常，你应该在模型的 `booted` 方法中注册这些闭包\r\n\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 模型的「booted」方法。\r\n         */\r\n        protected static function booted(): void\r\n        {\r\n            static::created(function (User $user) {\r\n                // ...\r\n            });\r\n        }\r\n    }\r\n\r\n如果需要，你可以在注册模型事件时使用[队列匿名事件侦听器](/docs/laravel/10.x/events#queuable-anonymous-event-listeners) 。这将指示 Laravel 使用应用程序的 [queue](/docs/laravel/10.x/queues) 在后台执行模型事件监听器：\r\n\r\n    use function Illuminate\\Events\\queueable;\r\n\r\n    static::created(queueable(function (User $user) {\r\n        // ...\r\n    }));\r\n\r\n<a name=\"observers\"></a>\r\n### 观察者\r\n\r\n<a name=\"defining-observers\"></a>\r\n#### 定义观察者\r\n\r\n如果在一个模型上监听了多个事件，可以使用观察者来将这些监听器组织到一个单独的类中。观察者类的方法名映射到你希望监听的 Eloquent 事件。这些方法都以模型作为其唯一参数。`make:observer` Artisan 命令可以快速建立新的观察者类：\r\n\r\n```shell\r\nphp artisan make:observer UserObserver --model=User\r\n```\r\n\r\n此命令将在 `App/Observers` 文件夹放置新的观察者类。如果这个目录不存在，Artisan 将替你创建。使用如下方式开启观察者：\r\n\r\n    <?php\r\n\r\n    namespace App\\Observers;\r\n\r\n    use App\\Models\\User;\r\n\r\n    class UserObserver\r\n    {\r\n        /**\r\n         * 处理用户「创建」事件。\r\n         */\r\n        public function created(User $user): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 处理用户「更新」事件。\r\n         */\r\n        public function updated(User $user): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 处理用户「删除」事件。\r\n         */\r\n        public function deleted(User $user): void\r\n        {\r\n            // ...\r\n        }\r\n        \r\n        /**\r\n         * 处理用户「还原」事件。\r\n         */\r\n        public function restored(User $user): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 处理用户「强制删除」事件。\r\n         */\r\n        public function forceDeleted(User $user): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n要注册观察者，需要在要观察的模型上调用`Observer` 方法。你可以在应用程序的 `boot` 方法中注册观察者\r\n\r\n`App\\Providers\\EventServiceProvider` 服务提供者:\r\n\r\n    use App\\Models\\User;\r\n    use App\\Observers\\UserObserver;\r\n\r\n    /**\r\n     * 为你的应用程序注册任何事件。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        User::observe(UserObserver::class);\r\n    }\r\n\r\n或者，可以在应用程序的 `$observers` 属性中列出你的观察者\r\n\r\n`App\\Providers\\EventServiceProvider` class:\r\n\r\n    use App\\Models\\User;\r\n    use App\\Observers\\UserObserver;\r\n\r\n    /**\r\n     * 应用程序的模型观察者。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $observers = [\r\n        User::class => [UserObserver::class],\r\n    ];\r\n\r\n> **技巧**  \r\n> 观察者可以监听其他事件，例如「saving」和「retrieved」。这些事件在 [events](#events) 文档中进行了描述。\r\n\r\n\r\n\r\n<a name=\"observers-and-database-transactions\"></a>\r\n#### 观察者与数据库事务\r\n\r\n在数据库事务中创建模型时，你可能希望指示观察者仅在提交数据库事务后执行其事件处理程序。可以通过在观察者上定义一个 `$afterCommit` 属性来完成此操作。如果数据库事务不在进行中，事件处理程序将立即执行：\r\n\r\n    <?php\r\n\r\n    namespace App\\Observers;\r\n\r\n    use App\\Models\\User;\r\n\r\n    class UserObserver\r\n    {\r\n        /**\r\n         * 在提交所有事务后处理事件\r\n         *\r\n         * @var bool\r\n         */\r\n        public $afterCommit = true;\r\n\r\n        /**\r\n         *  处理用户「创建」事件。\r\n         */\r\n        public function created(User $user): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n<a name=\"muting-events\"></a>\r\n### 静默事件\r\n\r\n也许有时候你会需要暂时将所有由模型触发的事件「静默」处理。使用 `withoutEvents` 达到目的。`withoutEvents` 方法接受一个闭包作为唯一参数。任何在闭包中执行的代码都不会被分配模型事件，并且闭包函数返回的任何值都将被 `withoutEvents` 方法所返回：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::withoutEvents(function () {\r\n        User::findOrFail(1)->delete();\r\n\r\n        return User::find(2);\r\n    });\r\n\r\n<a name=\"saving-a-single-model-without-events\"></a>\r\n#### 静默的保存单个模型\r\n\r\n有时候，你也许会想要「保存」一个已有的模型，且不触发任何事件。那么你可用 `saveQuietly` 方法达到目的：\r\n\r\n    $user = User::findOrFail(1);\r\n\r\n    $user->name = 'Victoria Faith';\r\n\r\n    $user->saveQuietly();\r\n\r\n你也可以「更新」「删除」「软删除」「还原」「复制」给定模型且不触发任何事件：\r\n\r\n    $user->deleteQuietly();\r\n    $user->forceDeleteQuietly();\r\n    $user->restoreQuietly();\r\n\r\n","p":"docs/eloquent.html"},{"t":"eloquent-relationships (Eloquent: 关联)","d":"# Eloquent: 关联\r\n\r\n- [简介](#introduction)\r\n- [定义关联](#defining-relationships)\r\n    - [一对一](#one-to-one)\r\n    - [一对多](#one-to-many)\r\n    - [一对多(反向)/属于](#one-to-many-inverse)\r\n    - [一对多检索](#has-one-of-many)\r\n    - [远程一对一](#has-one-through)\r\n    - [远程一对多](#has-many-through)\r\n- [多对多关联](#many-to-many)\r\n    - [获取中间表字段](#retrieving-intermediate-table-columns)\r\n    - [通过中间表字段过滤查询](#filtering-queries-via-intermediate-table-columns)\r\n    - [通过中间表字段排序查询](#ordering-queries-via-intermediate-table-columns)\r\n    - [自定义中间表模型](#defining-custom-intermediate-table-models)\r\n- [多态关联](#polymorphic-relationships)\r\n    - [一对一](#one-to-one-polymorphic-relations)\r\n    - [一对多](#one-to-many-polymorphic-relations)\r\n    - [一对多检索](#one-of-many-polymorphic-relations)\r\n    - [多对多](#many-to-many-polymorphic-relations)\r\n    - [自定义多态模型](#custom-polymorphic-types)\r\n- [动态关联](#dynamic-relationships)\r\n- [查询关联](#querying-relations)\r\n    - [关联方法与动态属性](#relationship-methods-vs-dynamic-properties)\r\n    - [基于存在的关联查询](#querying-relationship-existence)\r\n    - [基于不存在的关联查询](#querying-relationship-absence)\r\n    - [基于多态的关联查询](#querying-morph-to-relationships)\r\n- [统计关联模型](#aggregating-related-models)\r\n    - [关联模型计数](#counting-related-models)\r\n    - [其他统计函数](#other-aggregate-functions)\r\n    - [多态关联数据计数](#counting-related-models-on-morph-to-relationships)\r\n- [预加载](#eager-loading)\r\n    - [约束预加载](#constraining-eager-loads)\r\n    - [延迟预加载](#lazy-eager-loading)\r\n    - [阻止延迟加载](#preventing-lazy-loading)\r\n- [插入及更新关联模型](#inserting-and-updating-related-models)\r\n    - [ save 方法](#the-save-method)\r\n    - [ create 方法](#the-create-method)\r\n    - [属于关联](#updating-belongs-to-relationships)\r\n    - [多对多关联](#updating-many-to-many-relationships)\r\n- [更新父级时间戳](#touching-parent-timestamps)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n数据库表通常相互关联。例如，一篇博客文章可能有许多评论，或者一个订单对应一个下单用户。`Eloquent` 让这些关联的管理和使用变得简单，并支持多种常用的关联类型：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- [一对一](#one-to-one)\r\n- [一对多](#one-to-many)\r\n- [多对多](#many-to-many)\r\n- [远程一对一](#has-one-through)\r\n- [远程一对多](#has-many-through)\r\n- [多态一对一](#one-to-one-polymorphic-relations)\r\n- [多态一对多](#one-to-many-polymorphic-relations)\r\n- [多态多对多](#many-to-many-polymorphic-relations)\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"defining-relationships\"></a>\r\n## 定义关联\r\n\r\nEloquent 关联在 Eloquent 模型类中以方法的形式呈现。如同 Eloquent 模型本身，关联也可以作为强大的[查询语句构造器](/docs/laravel/10.x/queries)，使用，提供了强大的链式调用和查询功能。例如，我们可以在 `posts` 关联的链式调用中附加一个约束条件：\r\n\r\n    $user->posts()->where('active', 1)->get();\r\n\r\n不过在深入使用关联之前，让我们先学习如何定义每种关联类型。\r\n\r\n<a name=\"one-to-one\"></a>\r\n### 一对一\r\n\r\n一对一是最基本的数据库关系。 例如，一个 `User` 模型可能与一个 `Phone` 模型相关联。为了定义这个关联关系，我们要在 `User` 模型中写一个 `phone` 方法。 在 `phone` 方法中调用 `hasOne` 方法并返回其结果。  `hasOne` 方法被定义在 `Illuminate\\Database\\Eloquent\\Model` 这个模型基类中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\HasOne;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 获取与用户相关的电话记录\r\n         */\r\n        public function phone(): HasOne\r\n        {\r\n            return $this->hasOne(Phone::class);\r\n        }\r\n    }\r\n\r\n`hasOne` 方法的第一个参数是关联模型的类名。一旦定义了模型关联，我们就可以使用 Eloquent 的动态属性获得相关的记录。动态属性允许你访问该关联方法，就像访问模型中定义的属性一样：\r\n\r\n    $phone = User::find(1)->phone;\r\n\r\nEloquent 基于父模型 `User` 的名称来确定关联模型 `Phone` 的外键名称。在本例中，会自动假定 `Phone` 模型有一个 `user_id` 的外键。如果你想重写这个约定，可以传递第二个参数给 `hasOne` 方法：\r\n\r\n    return $this->hasOne(Phone::class, 'foreign_key');\r\n\r\n\r\n\r\n另外，Eloquent 假设外键的值是与父模型的主键（Primary Key）相同的。换句话说，Eloquent 将会通过 `Phone` 记录的 `user_id` 列中查找与用户表的 `id` 列相匹配的值。如果你希望使用自定义的主键值，而不是使用 `id` 或者模型中的 `$primaryKey` 属性，你可以给 `hasOne` 方法传递第三个参数：\r\n\r\n    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');\r\n\r\n<a name=\"定义反向关联\"></a>\r\n#### 定义反向关联\r\n\r\n我们已经能从 `User` 模型访问到 `Phone` 模型了。接下来，让我们再在 `Phone` 模型上定义一个关联，它能让我们访问到拥有该电话的用户。我们可以使用 `belongsTo` 方法来定义反向关联， `belongsTo` 方法与 `hasOne` 方法相对应：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\r\n\r\n    class Phone extends Model\r\n    {\r\n        /**\r\n         * 获取拥有此电话的用户\r\n         */\r\n        public function user(): BelongsTo\r\n        {\r\n            return $this->belongsTo(User::class);\r\n        }\r\n    }\r\n\r\n在调用 `user` 方法时，Eloquent 会尝试查找一个 `User` 模型，该 `User` 模型上的 `id` 字段会与 `Phone` 模型上的 `user_id` 字段相匹配。\r\n\r\nEloquent 通过关联方法（`user`）的名称并使用 `_id` 作为后缀名来确定外键名称。因此，在本例中，Eloquent 会假设 `Phone` 模型有一个 `user_id` 字段。但是，如果 `Phone` 模型的外键不是 `user_id`，这时你可以给 `belongsTo` 方法的第二个参数传递一个自定义键名：\r\n\r\n    /**\r\n     * 获取拥有此电话的用户\r\n     */\r\n    public function user(): BelongsTo\r\n    {\r\n        return $this->belongsTo(User::class, 'foreign_key');\r\n    }\r\n\r\n\r\n\r\n如果父模型的主键未使用 `id` 作为字段名，或者你想要使用其他的字段来匹配相关联的模型，那么你可以向 `belongsTo` 方法传递第三个参数，这个参数是在父模型中自己定义的字段名称：\r\n\r\n    /**\r\n     * 获取当前手机号的用户\r\n     */\r\n    public function user(): BelongsTo\r\n    {\r\n        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');\r\n    }\r\n\r\n<a name=\"one-to-many\"></a>\r\n### 一对多\r\n\r\n当要定义一个模型是其他 （一个或者多个）模型的父模型这种关系时，可以使用一对多关联。例如，一篇博客可以有很多条评论。和其他模型关联一样，一对多关联也是在 Eloquent 模型文件中用一个方法来定义的：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\HasMany;\r\n\r\n    class Post extends Model\r\n    {\r\n        /**\r\n         * 获取这篇博客的所有评论\r\n         */\r\n        public function comments(): HasMany\r\n        {\r\n            return $this->hasMany(Comment::class);\r\n        }\r\n    }\r\n\r\n注意，Eloquent 将会自动为 `Comment` 模型选择一个合适的外键。通常，这个外键是通过使用父模型的「蛇形命名」方式，然后再加上 `_id`. 的方式来命名的。因此，在上面这个例子中，Eloquent 将会默认 `Comment` 模型的外键是 `post_id` 字段。\r\n\r\n如果关联方法被定义，那么我们就可以通过 `comments` 属性来访问相关的评论 [集合](/docs/laravel/10.x/eloquent-collections)。注意，由于 Eloquent 提供了「动态属性」，所以我们就可以像访问模型属性一样来访问关联方法：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $comments = Post::find(1)->comments;\r\n\r\n    foreach ($comments as $comment) {\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n由于所有的关系都可以看成是查询构造器，所以你也可以通过链式调用的方式，在 `comments` 方法中继续添加条件约束：\r\n\r\n    $comment = Post::find(1)->comments()\r\n                        ->where('title', 'foo')\r\n                        ->first();\r\n\r\n像 `hasOne` 方法一样，你也可以通过将附加参数传递给 `hasMany` 方法来覆盖外键和本地键：\r\n\r\n    return $this->hasMany(Comment::class, 'foreign_key');\r\n\r\n    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');\r\n\r\n<a name=\"one-to-many-inverse\"></a>\r\n### 一对多 (反向) / 属于\r\n\r\n目前我们可以访问一篇文章的所有评论，下面我们可以定义一个关联关系，从而让我们可以通过一条评论来获取到它所属的文章。这个关联关系是 `hasMany` 的反向，可以在子模型中通过 `belongsTo` 方法来定义这种关联关系：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\r\n\r\n    class Comment extends Model\r\n    {\r\n        /**\r\n         * 获取这条评论所属的文章。\r\n         */\r\n        public function post(): BelongsTo\r\n        {\r\n            return $this->belongsTo(Post::class);\r\n        }\r\n    }\r\n\r\n如果定义了这种关联关系，那么我们就可以通过 `Comment` 模型中的 `post` 「动态属性」来获取到这条评论所属的文章：\r\n\r\n    use App\\Models\\Comment;\r\n\r\n    $comment = Comment::find(1);\r\n\r\n    return $comment->post->title;\r\n\r\n在上面这个例子中，Eloquent 将会尝试寻找 `Post` 模型中的 `id` 字段与 `Comment` 模型中的 `post_id` 字段相匹配。\r\n\r\nEloquent 通过检查关联方法的名称，从而在关联方法名称后面加上 `_` ，然后再加上父模型 （Post）的主键名称，以此来作为默认的外键名。因此，在上面这个例子中，Eloquent 将会默认 `Post` 模型在 `comments` 表中的外键是 `post_id`。\r\n\r\n\r\n但是，如果你的外键不遵循这种约定的话，那么你可以传递一个自定义的外键名来作为 `belongsTo` 方法的第二个参数：\r\n\r\n    /**\r\n     * 获取这条评论所属的文章。\r\n     */\r\n    public function post(): BelongsTo\r\n    {\r\n        return $this->belongsTo(Post::class, 'foreign_key');\r\n    }\r\n\r\n如果你的父表不使用 `id` 作为主键，或者你希望使用不同的列来关联模型，你可以将第三个参数传递给 `belongsTo` 方法，指定父表的自定义键：\r\n\r\n    /**\r\n     * 获取这条评论所属的文章。\r\n     */\r\n    public function post(): BelongsTo\r\n    {\r\n        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');\r\n    }\r\n\r\n<a name=\"default-models\"></a>\r\n#### 默认模型\r\n\r\n当 `belongsTo`，`hasOne`，`hasOneThrough` 和 `morphOne` 这些关联方法返回 `null` 的时候，你可以定义一个默认的模型返回。该模式通常被称为 [空对象模式](https://en.wikipedia.org/wiki/Null_Object_pattern)，它可以帮你省略代码中的一些条件判断。在下面这个例子中，如果 `Post` 模型中没有用户，那么 `user` 关联关系将会返回一个空的 `App\\Models\\User` 模型：\r\n\r\n    /**\r\n     * 获取文章的作者。\r\n     */\r\n    public function user(): BelongsTo\r\n    {\r\n        return $this->belongsTo(User::class)->withDefault();\r\n    }\r\n\r\n可以向 `withDefault` 方法传递数组或者闭包来填充默认模型的属性。\r\n\r\n    /**\r\n     * 获取文章的作者。\r\n     */\r\n    public function user(): BelongsTo\r\n    {\r\n        return $this->belongsTo(User::class)->withDefault([\r\n            'name' => 'Guest Author',\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * 获取文章的作者。\r\n     */\r\n    public function user(): BelongsTo\r\n    {\r\n        return $this->belongsTo(User::class)->withDefault(function (User $user, Post $post) {\r\n            $user->name = 'Guest Author';\r\n        });\r\n    }\r\n\r\n\r\n\r\n<a name=\"querying-belongs-to-relationships\"></a>\r\n#### 查询所属关系\r\n\r\n在查询「所属」的子模型时，可以构建 `where` 语句来检索相应的 Eloquent 模型：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::where('user_id', $user->id)->get();\r\n\r\n但是，你会发现使用 `whereBelongsTo` 方法更方便，它会自动确定给定模型的正确关系和外键：\r\n\r\n    $posts = Post::whereBelongsTo($user)->get();\r\n\r\n你还可以向 `whereBelongsTo` 方法提供一个 [集合](/docs/laravel/10.x/eloquent-collections) 实例。 这样 Laravel 将检索属于集合中任何父模型的子模型：\r\n\r\n    $users = User::where('vip', true)->get();\r\n\r\n    $posts = Post::whereBelongsTo($users)->get();\r\n\r\n默认情况下，Laravel 将根据模型的类名来确定给定模型的关联关系； 你也可以通过将关系名称作为 `whereBelongsTo` 方法的第二个参数来手动指定关系名称：\r\n\r\n    $posts = Post::whereBelongsTo($user, 'author')->get();\r\n\r\n<a name=\"has-one-of-many\"></a>\r\n### 一对多检索\r\n\r\n有时一个模型可能有许多相关模型，如果你想很轻松的检索「最新」或「最旧」的相关模型。例如，一个 `User` 模型可能与许多 `Order` 模型相关，但你想定义一种方便的方式来与用户最近下的订单进行交互。 可以使用 `hasOne` 关系类型结合 `ofMany` 方法来完成此操作：\r\n\r\n```php\r\n/**\r\n * 获取用户最新的订单。\r\n */\r\npublic function latestOrder(): HasOne\r\n{\r\n    return $this->hasOne(Order::class)->latestOfMany();\r\n}\r\n```\r\n\r\n\r\n\r\n同样，你可以定义一个方法来检索 「oldest」或第一个相关模型：\r\n\r\n```php\r\n/**\r\n * 获取用户最早的订单。\r\n */\r\npublic function oldestOrder(): HasOne\r\n{\r\n    return $this->hasOne(Order::class)->oldestOfMany();\r\n}\r\n```\r\n\r\n默认情况下，`latestOfMany` 和 `oldestOfMany` 方法将根据模型的主键检索最新或最旧的相关模型，该主键必须是可排序的。 但是，有时你可能希望使用不同的排序条件从更大的关系中检索单个模型。\r\n\r\n例如，使用 `ofMany` 方法，可以检索用户最昂贵的订单。 `ofMany` 方法接受可排序列作为其第一个参数，以及在查询相关模型时应用哪个聚合函数（`min` 或 `max`）：\r\n\r\n```php\r\n/**\r\n * 获取用户最昂贵的订单。\r\n */\r\npublic function largestOrder(): HasOne\r\n{\r\n    return $this->hasOne(Order::class)->ofMany('price', 'max');\r\n}\r\n```\r\n\r\n> **注意**\r\n> 因为 PostgreSQL 不支持对 UUID 列执行 `MAX` 函数，所以目前无法将一对多关系与 PostgreSQL UUID 列结合使用。\r\n\r\n<a name=\"advanced-has-one-of-many-relationships\"></a>\r\n#### 进阶一对多检索\r\n\r\n可以构建更高级的「一对多检索」关系。例如，一个 `Product` 模型可能有许多关联的 `Price` 模型，即使在新定价发布后，这些模型也会保留在系统中。此外，产品的新定价数据能够通过 `published_at` 列提前发布，以便在未来某日生效。\r\n\r\n因此，我们需要检索最新的发布定价。 此外，如果两个价格的发布日期相同，我们优先选择 ID 更大的价格。 为此，我们必须将一个数组传递给 `ofMany` 方法，其中包含确定最新价格的可排序列。此外，将提供一个闭包作为 `ofMany` 方法的第二个参数。此闭包将负责向关系查询添加额外的发布日期约束：\r\n\r\n```php\r\n/**\r\n * 获取产品的当前定价。\r\n */\r\npublic function currentPricing(): HasOne\r\n{\r\n    return $this->hasOne(Price::class)->ofMany([\r\n        'published_at' => 'max',\r\n        'id' => 'max',\r\n    ], function (Builder $query) {\r\n        $query->where('published_at', '<', now());\r\n    });\r\n}\r\n```\r\n\r\n\r\n\r\n<a name=\"has-one-through\"></a>\r\n### 远程一对一\r\n\r\n「远程一对一」关联定义了与另一个模型的一对一的关联。然而，这种关联是声明的模型通过第三个模型来与另一个模型的一个实例相匹配。\r\n\r\n例如，在一个汽车维修的应用程序中，每一个 `Mechanic` 模型都与一个 `Car` 模型相关联，同时每一个 `Car` 模型也和一个 `Owner` 模型相关联。虽然维修师（mechanic）和车主（owner）在数据库中并没有直接的关联，但是维修师可以通过 `Car` 模型来找到车主。让我们来看看定义这种关联所需要的数据表：\r\n\r\n    mechanics\r\n        id - integer\r\n        name - string\r\n\r\n    cars\r\n        id - integer\r\n        model - string\r\n        mechanic_id - integer\r\n\r\n    owners\r\n        id - integer\r\n        name - string\r\n        car_id - integer\r\n\r\n既然我们已经了解了远程一对一的表结构，那么我们就可以在 `Mechanic` 模型中定义这种关联：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\HasOneThrough;\r\n\r\n    class Mechanic extends Model\r\n    {\r\n        /**\r\n         * 获取汽车的主人。\r\n         */\r\n        public function carOwner(): HasOneThrough\r\n        {\r\n            return $this->hasOneThrough(Owner::class, Car::class);\r\n        }\r\n    }\r\n\r\n传递给 `hasOneThrough` 方法的第一个参数是我们希望访问的最终模型的名称，而第二个参数是中间模型的名称。\r\n\r\n或者，如果相关的关联已经在关联中涉及的所有模型上被定义，你可以通过调用 `through` 方法和提供这些关联的名称来流式定义一个「远程一对一」关联。例如，`Mechanic` 模型有一个 `cars` 关联，`Car` 模型有一个 `owner` 关联，你可以这样定义一个连接维修师和车主的「远程一对一」关联：\r\n\r\n```php\r\n// 基于字符串的语法...\r\nreturn $this->through('cars')->has('owner');\r\n\r\n// 动态语法...\r\nreturn $this->throughCars()->hasOwner();\r\n```\r\n\r\n\r\n\r\n<a name=\"has-one-through-key-conventions\"></a>\r\n#### 键名约定\r\n\r\n当使用远程一对一进行关联查询时，Eloquent 将会使用约定的外键名。如果你想要自定义相关联的键名的话，可以传递两个参数来作为「hasOneThrough」 方法的第三个和第四个参数。第三个参数是中间表的外键名。第四个参数是最终想要访问的模型的外键名。第五个参数是当前模型的本地键名，第六个参数是中间模型的本地键名：\r\n\r\n    class Mechanic extends Model\r\n    {\r\n        /**\r\n         * Get the car's owner.\r\n         */\r\n        public function carOwner(): HasOneThrough\r\n        {\r\n            return $this->hasOneThrough(\r\n                Owner::class,\r\n                Car::class,\r\n                'mechanic_id', // 机械师表的外键...\r\n                'car_id', // 车主表的外键...\r\n                'id', // 机械师表的本地键...\r\n                'id' // 汽车表的本地键...\r\n            );\r\n        }\r\n    }\r\n\r\n如果所涉及的模型已经定义了相关关系，可以调用 `through` 方法并提供关系名来定义「远程一对一」关联。该方法的优点是重复使用已有关系上定义的主键约定：\r\n```php\r\n// 基本语法...\r\nreturn $this->through('cars')->has('owner');\r\n\r\n// 动态语法...\r\nreturn $this->throughCars()->hasOwner();\r\n```\r\n\r\n<a name=\"has-many-through\"></a>\r\n### 远程一对多\r\n\r\n「远程一对多」关联是可以通过中间关系来实现远程一对多的。例如，我们正在构建一个像 [Laravel Vapor](https://vapor.laravel.com)这样的部署平台。一个 `Project` 模型可以通过一个中间的 `Environment` 模型来访问许多个 `Deployment` 模型。就像上面的这个例子，可以在给定的 environment 中很方便的获取所有的 deployments。下面是定义这种关联关系所需要的数据表：\r\n\r\n    projects\r\n        id - integer\r\n        name - string\r\n\r\n    environments\r\n        id - integer\r\n        project_id - integer\r\n        name - string\r\n\r\n    deployments\r\n        id - integer\r\n        environment_id - integer\r\n        commit_hash - string\r\n\r\n\r\n\r\n既然我们已经检查了关系的表结构，现在让我们在 `Project` 模型上定义该关系：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\HasManyThrough;\r\n\r\n    class Project extends Model\r\n    {\r\n        /**\r\n         * 获取该项目的所有部署。\r\n         */\r\n        public function deployments(): HasManyThrough\r\n        {\r\n            return $this->hasManyThrough(Deployment::class, Environment::class);\r\n        }\r\n    }\r\n\r\n`hasManyThrough` 方法中传递的第一个参数是我们希望访问的最终模型名称，而第二个参数是中间模型的名称。\r\n\r\n或者，所有模型上都定义好了关系，你可以通过调用 `through` 方法并提供这些关系的名称来定义「has-many-through」关系。例如，如果  `Project` 模型具有 `environments` 关系，而 `Environment` 模型具有 `deployments` 关系，则可以定义连接 project 和 deployments 的「has-many-through」关系，如下所示：\r\n\r\n```php\r\n// 基于字符串的语法。。。\r\nreturn $this->through('environments')->has('deployments');\r\n\r\n// 动态语法。。。\r\nreturn $this->throughEnvironments()->hasDeployments();\r\n```\r\n虽然 `Deployment` 模型的表格不包含 `project_id` 列，但 `hasManyThrough` 关系通过 `$project->deployments` 提供了访问项目的部署方式。为了检索这些模型，Eloquent 在中间的 `Environment` 模型表中检查 `project_id` 列。在找到相关的 environment ID 后，它们被用来查询 `Deployment` 模型。\r\n\r\n<a name=\"has-many-through-key-conventions\"></a>\r\n#### 键名约定\r\n\r\n在执行关系查询时，通常会使用典型的 Eloquent 外键约定。如果你想要自定义关系键名，可以将它们作为 `hasManyThrough` 方法的第三个和第四个参数传递。第三个参数是中间模型上的外键名称。第四个参数是最终模型上的外键名称。第五个参数是本地键，而第六个参数是中间模型的本地键：\r\n\r\n    class Project extends Model\r\n    {\r\n        public function deployments(): HasManyThrough\r\n        {\r\n            return $this->hasManyThrough(\r\n                Deployment::class,\r\n                Environment::class,\r\n                'project_id', // 在 environments 表上的外键...\r\n                'environment_id', // 在 deployments 表上的外键...\r\n                'id', // 在 projects 表上的本地键...\r\n                'id' // 在 environments 表格上的本地键...\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n\r\n或者，如前所述，如果涉及关系的相关关系已经在所有模型上定义，你可以通过调用 `through` 方法并提供这些关系的名称来定义「has-many-through」关系。这种方法的优点是可以重复使用已经定义在现有关系上的键约定：\r\n\r\n```php\r\n// 基于字符串的语法。。。\r\nreturn $this->through('environments')->has('deployments');\r\n\r\n// 动态语法。。。\r\nreturn $this->throughEnvironments()->hasDeployments();\r\n```\r\n\r\n<a name=\"many-to-many\"></a>\r\n## 多对多关联\r\n\r\n多对多关联比 `hasOne` 和 `hasMany` 关联略微复杂。举个例子，一个用户可以拥有多个角色，同时这些角色也可以分配给其他用户。例如，一个用户可是「作者」和「编辑」；当然，这些角色也可以分配给其他用户。所以，一个用户可以拥有多个角色，一个角色可以分配给多个用户。\r\n\r\n<a name=\"many-to-many-table-structure\"></a>\r\n#### 表结构\r\n\r\n要定义这种关联，需要三个数据库表: `users`, `roles` 和 `role_user`。`role_user` 表的命名是由关联的两个模型按照字母顺序来的，并且包含了 `user_id` 和 `role_id` 字段。该表用作链接 `users` 和 `roles` 的中间表\r\n\r\n特别提醒，由于角色可以属于多个用户，因此我们不能简单地在 `roles` 表上放置 `user_id` 列。如果这样，这意味着角色只能属于一个用户。为了支持将角色分配给多个用户，需要使用 `role_user` 表。我们可以这样定义表结构：\r\n\r\n    users\r\n        id - integer\r\n        name - string\r\n\r\n    roles\r\n        id - integer\r\n        name - string\r\n\r\n    role_user\r\n        user_id - integer\r\n        role_id - integer\r\n\r\n\r\n\r\n<a name=\"many-to-many-model-structure\"></a>\r\n#### 模型结构\r\n\r\n多对多关联是通过调用 `belongsToMany` 方法结果的方法来定义的。 `belongsToMany` 方法由 `Illuminate\\Database\\Eloquent\\Model` 基类提供，所有应用程序的 Eloquent 模型都使用该基类。 例如，让我们在 `User` 模型上定义一个 `roles` 方法。 传递给此方法的第一个参数是相关模型类的名称：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 用户所拥有的角色\r\n         */\r\n        public function roles(): BelongsToMany\r\n        {\r\n            return $this->belongsToMany(Role::class);\r\n        }\r\n    }\r\n\r\n定义关系后，可以使用 `roles` 动态关系属性访问用户的角色：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    foreach ($user->roles as $role) {\r\n        // ...\r\n    }\r\n\r\n由于所有的关系也可以作为查询构建器，你可以通过调用 `roles()` 方法查询来为关系添加约束：\r\n\r\n    $roles = User::find(1)->roles()->orderBy('name')->get();\r\n\r\n为了确定关系的中间表的表名，Eloquent 会按字母顺序连接两个相关的模型名。 你也可以随意覆盖此约定。 通过将第二个参数传递给 `belongsToMany` 方法来做到这一点：\r\n\r\n    return $this->belongsToMany(Role::class, 'role_user');\r\n\r\n除了自定义连接表的表名，你还可以通过传递额外的参数到 `belongsToMany` 方法来定义该表中字段的键名。第三个参数是定义此关联的模型在连接表里的外键名，第四个参数是另一个模型在连接表里的外键名:\r\n\r\n    return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');\r\n\r\n\r\n\r\n<a name=\"many-to-many-defining-the-inverse-of-the-relationship\"></a>\r\n#### 定义反向关联\r\n\r\n要定义多对多的反向关联，只需要在关联模型中调用 `belongsToMany` 方法。我们在 `Role` 模型中定义 `users` 方法:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany;\r\n\r\n    class Role extends Model\r\n    {\r\n        /**\r\n         * 拥有此角色的用户\r\n         */\r\n        public function users(): BelongsToMany\r\n        {\r\n            return $this->belongsToMany(User::class);\r\n        }\r\n    }\r\n\r\n如你所见，除了引用 `App\\Models\\User` 模型之外，该关系的定义与其对应的 `User` 模型完全相同。 由于我们复用了 `belongsToMany` 方法，所以在定义多对多关系的「反向」关系时，所有常用的表和键自定义选项都可用。\r\n\r\n<a name=\"retrieving-intermediate-table-columns\"></a>\r\n### 获取中间表字段\r\n\r\n如上所述，处理多对多关系需要一个中间表。 Eloquent 提供了一些非常有用的方式来与它进行交互。 假设我们的 `User` 对象关联了多个 `Role` 对象。在获得这些关联对象后，可以使用模型的 `pivot` 属性访问中间表的属性：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    foreach ($user->roles as $role) {\r\n        echo $role->pivot->created_at;\r\n    }\r\n\r\n需要注意的是，我们获取的每个 `Role` 模型对象，都会被自动赋予 `pivot` 属性，它代表中间表的一个模型对象，并且可以像其他的 Eloquent 模型一样使用。\r\n\r\n默认情况下，`pivot` 对象只包含两个关联模型的主键，如果你的中间表里还有其他额外字段，你必须在定义关联时明确指出：\r\n\r\n    return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');\r\n\r\n\r\n\r\n如果你想让中间表自动维护 `created_at` 和 `updated_at` 时间戳，那么在定义关联时附加上 `withTimestamps` 方法即可：\r\n\r\n    return $this->belongsToMany(Role::class)->withTimestamps();\r\n\r\n> **注意**\r\n> 使用 Eloquent 自动维护时间戳的中间表需要同时具有 `created_at` 和 `updated_at`时间戳字段。\r\n\r\n<a name=\"customizing-the-pivot-attribute-name\"></a>\r\n#### 自定义 pivot 属性名称\r\n\r\n如前所述，可以通过 `pivot` 属性在模型上访问中间表中的属性。 但是，你可以随意自定义此属性的名称，以更好地反映其在应用程序中的用途。\r\n\r\n例如，如果你的应用程序包含可能订阅播客的用户，则用户和播客之间可能存在多对多关系。 如果是这种情况，你可能希望将中间表属性重命名为 `subscription` 而不是 `pivot`。 这可以在定义关系时使用 `as` 方法来完成：\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscription')\r\n                    ->withTimestamps();\r\n\r\n一旦定义完成，你可以使用自定义名称访问中间表数据：\r\n\r\n    $users = User::with('podcasts')->get();\r\n\r\n    foreach ($users->flatMap->podcasts as $podcast) {\r\n        echo $podcast->subscription->created_at;\r\n    }\r\n\r\n<a name=\"filtering-queries-via-intermediate-table-columns\"></a>\r\n### 通过中间表过滤查询\r\n\r\n你还可以在定义关系时使用 `wherePivot`、`wherePivotIn`、`wherePivotNotIn`、`wherePivotBetween`、`wherePivotNotBetween`、`wherePivotNull` 和 `wherePivotNotNull` 方法过滤 `belongsToMany` 关系查询返回的结果：\r\n\r\n    return $this->belongsToMany(Role::class)\r\n                    ->wherePivot('approved', 1);\r\n\r\n    return $this->belongsToMany(Role::class)\r\n                    ->wherePivotIn('priority', [1, 2]);\r\n\r\n    return $this->belongsToMany(Role::class)\r\n                    ->wherePivotNotIn('priority', [1, 2]);\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscriptions')\r\n                    ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscriptions')\r\n                    ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscriptions')\r\n                    ->wherePivotNull('expired_at');\r\n\r\n    return $this->belongsToMany(Podcast::class)\r\n                    ->as('subscriptions')\r\n                    ->wherePivotNotNull('expired_at');\r\n\r\n\r\n\r\n<a name=\"ordering-queries-via-intermediate-table-columns\"></a>\r\n### 通过中间表字段排序\r\n\r\n你可以使用 `orderByPivot` 方法对 `belongsToMany` 关系查询返回的结果进行排序。在下面的例子中，我们将检索用户的最新徽章：\r\n\r\n    return $this->belongsToMany(Badge::class)\r\n                    ->where('rank', 'gold')\r\n                    ->orderByPivot('created_at', 'desc');\r\n\r\n<a name=\"defining-custom-intermediate-table-models\"></a>\r\n### 自定义中间表模型\r\n\r\n如果你想定义一个自定义模型来表示多对多关系的中间表，你可以在定义关系时调用 `using` 方法。\r\n\r\n自定义多对多中间表模型都必须继承 `Illuminate\\Database\\Eloquent\\Relations\\Pivot` 类，自定义多对多（多态）中间表模型必须继承 `Illuminate\\Database\\Eloquent\\Relations\\MorphPivot` 类。例如，我们在写 `Role` 模型的关联时，使用自定义中间表模型 `RoleUser`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany;\r\n\r\n    class Role extends Model\r\n    {\r\n        /**\r\n         * 属于该角色的用户。\r\n         */\r\n        public function users(): BelongsToMany\r\n        {\r\n            return $this->belongsToMany(User::class)->using(RoleUser::class);\r\n        }\r\n    }\r\n\r\n当定义 `RoleUser` 模型时，我们要继承 `Illuminate\\Database\\Eloquent\\Relations\\Pivot` 类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\Pivot;\r\n\r\n    class RoleUser extends Pivot\r\n    {\r\n        // ...\r\n    }\r\n\r\n> **注意**\r\n> Pivot 模型不可以使用 `SoftDeletes` trait。 如果需要软删除数据关联记录，请考虑将数据关联模型转换为实际的 Eloquent 模型。\r\n\r\n\r\n<a name=\"custom-pivot-models-and-incrementing-ids\"></a>\r\n\r\n\r\n#### 自定义中间模型和自增 ID\r\n\r\n如果你用一个自定义的中继模型定义了多对多的关系，而且这个中继模型拥有一个自增的主键，你应当确保这个自定义中继模型类中定义了一个 `incrementing` 属性且其值为 `true`。\r\n\r\n    /**\r\n     * 标识 ID 是否自增\r\n     *\r\n     * @var bool\r\n     */\r\n    public $incrementing = true;\r\n\r\n<a name=\"polymorphic-relationships\"></a>\r\n## 多态关系\r\n\r\n多态关联允许子模型使用单个关联属于多种类型的模型。例如，假设你正在构建一个应用程序，允许用户共享博客文章和视频。在这样的应用程序中，`Comment` 模型可能同时属于 `Post` 和 `Video` 模型。\r\n\r\n<a name=\"one-to-one-polymorphic-relations\"></a>\r\n### 一对一 (多态)\r\n\r\n<a name=\"one-to-one-polymorphic-table-structure\"></a>\r\n#### 表结构\r\n\r\n一对一多态关联类似于典型的一对一关系，但是子模型可以使用单个关联属于多个类型的模型。例如，一个博客 `Post` 和一个 `User` 可以共享到一个 `Image` 模型的多态关联。使用一对一多态关联允许你拥有一个唯一图像的单个表，这些图像可以与帖子和用户关联。首先，让我们查看表结构：\r\n\r\n    posts\r\n        id - integer\r\n        name - string\r\n\r\n    users\r\n        id - integer\r\n        name - string\r\n\r\n    images\r\n        id - integer\r\n        url - string\r\n        imageable_id - integer\r\n        imageable_type - string\r\n\r\n请注意 `images` 表上的 `imageable_id` 和 `imageable_type` 两列。`imageable_id` 列将包含帖子或用户的ID值，而 `imageable_type` 列将包含父模型的类名。`imageable_type` 列用于 Eloquent 在访问 `imageable` 关联时确定要返回哪种类型的父模型。在本例中，该列将包含 `App\\Models\\Post` 或 `App\\Models\\User`。\r\n\r\n\r\n\r\n<a name=\"one-to-one-polymorphic-model-structure\"></a>\r\n#### 模型结构\r\n\r\n接下来，让我们来看一下构建这个关系所需的模型定义：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    class Image extends Model\r\n    {\r\n        /**\r\n         * 获取父级 imageable 模型（用户或帖子）。\r\n         */\r\n        public function imageable(): MorphTo\r\n        {\r\n            return $this->morphTo();\r\n        }\r\n    }\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphOne;\r\n\r\n    class Post extends Model\r\n    {\r\n        /**\r\n         * 获取文章图片\r\n         */\r\n        public function image(): MorphOne\r\n        {\r\n            return $this->morphOne(Image::class, 'imageable');\r\n        }\r\n    }\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphOne;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 获取用户的图片。\r\n         */\r\n        public function image(): MorphOne\r\n        {\r\n            return $this->morphOne(Image::class, 'imageable');\r\n        }\r\n    }\r\n\r\n<a name=\"one-to-one-polymorphic-retrieving-the-relationship\"></a>\r\n#### 检索关联关系\r\n\r\n一旦定义了表和模型，就可以通过模型访问此关联。比如，要获取文章图片，可以使用 `image` 动态属性：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::find(1);\r\n\r\n    $image = $post->image;\r\n\r\n还可以通过访问执行 `morphTo` 调用的方法名来从多态模型中获知父模型。在这个例子中，就是 `Image` 模型的 `imageable` 方法。所以，我们可以像动态属性那样访问这个方法：\r\n\r\n    use App\\Models\\Image;\r\n\r\n    $image = Image::find(1);\r\n\r\n    $imageable = $image->imageable;\r\n\r\n`Image` 模型上的 `imageable` 关系将返回 `Post` 实例或 `User` 实例，具体取决于模型拥有图像的类型。\r\n\r\n<a name=\"morph-one-to-one-key-conventions\"></a>\r\n#### 键名约定\r\n\r\n如有需要，你可以指定多态子模型中使用的 `id` 和 `type` 列的名称。 如果这样做，请确保始终将关联名称作为第一个参数传递给 `morphTo` 方法。 通常，此值应与方法名称匹配，因此你可以使用 PHP 的 `__FUNCTION__` 常量：\r\n\r\n    /**\r\n     * 获取 image 实例所属的模型\r\n     */\r\n    public function imageable(): MorphTo\r\n    {\r\n        return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');\r\n    }\r\n\r\n\r\n\r\n<a name=\"one-to-many-polymorphic-relations\"></a>\r\n### 一对多（多态）\r\n\r\n<a name=\"one-to-many-polymorphic-table-structure\"></a>\r\n#### 表结构\r\n\r\n一对多多态关联与简单的一对多关联类似，不过，目标模型可以在一个关联中从属于多个模型。假设应用中的用户可以同时「评论」文章和视频。使用多态关联，可以用单个 `comments` 表同时满足这些情况。我们还是先来看看用来构建这种关联的表结构：\r\n\r\n    posts\r\n        id - integer\r\n        title - string\r\n        body - text\r\n\r\n    videos\r\n        id - integer\r\n        title - string\r\n        url - string\r\n\r\n    comments\r\n        id - integer\r\n        body - text\r\n        commentable_id - integer\r\n        commentable_type - string\r\n\r\n<a name=\"one-to-many-polymorphic-model-structure\"></a>\r\n#### 模型结构\r\n\r\n接下来，看看构建这种关联的模型定义：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    class Comment extends Model\r\n    {\r\n        /**\r\n         * 获取拥有此评论的模型（Post 或 Video）。\r\n         */\r\n        public function commentable(): MorphTo\r\n        {\r\n            return $this->morphTo();\r\n        }\r\n    }\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphMany;\r\n\r\n    class Post extends Model\r\n    {\r\n        /**\r\n         * 获取此文章的所有评论\r\n         */\r\n        public function comments(): MorphMany\r\n        {\r\n            return $this->morphMany(Comment::class, 'commentable');\r\n        }\r\n    }\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphMany;\r\n\r\n    class Video extends Model\r\n    {\r\n        /**\r\n         * 获取此视频的所有评论\r\n         */\r\n        public function comments(): MorphMany\r\n        {\r\n            return $this->morphMany(Comment::class, 'commentable');\r\n        }\r\n    }\r\n\r\n<a name=\"one-to-many-polymorphic-retrieving-the-relationship\"></a>\r\n#### 获取关联\r\n\r\n一旦定义了数据库表和模型，就可以通过模型访问关联。例如，可以使用 `comments` 动态属性访问文章的全部评论：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::find(1);\r\n\r\n    foreach ($post->comments as $comment) {\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n你还可以通过访问执行对 `morphTo` 的调用的方法名来从多态模型获取其所属模型。在我们的例子中，这就是 `Comment` 模型上的 `commentable` 方法。因此，我们将以动态属性的形式访问该方法：\r\n\r\n    use App\\Models\\Comment;\r\n\r\n    $comment = Comment::find(1);\r\n\r\n    $commentable = $comment->commentable;\r\n\r\n`Comment` 模型的 `commentable` 关联将返回 `Post` 或 `Video` 实例，其结果取决于评论所属的模型。\r\n\r\n<a name=\"one-of-many-polymorphic-relations\"></a>\r\n### 一对多检索（多态）\r\n\r\n有时一个模型可能有许多相关模型，要检索关系的「最新」或「最旧」相关模型。 例如，一个 `User` 模型可能与许多 `Image` 模型相关，如果你想自定义一种方便的方式来与用户上传的最新图像进行交互。 可以使用 `morphOne` 关系类型结合 `ofMany` 方法来完成此操作：\r\n\r\n```php\r\n/**\r\n * 获取用户最近上传的图像。\r\n */\r\npublic function latestImage(): MorphOne\r\n{\r\n    return $this->morphOne(Image::class, 'imageable')->latestOfMany();\r\n}\r\n```\r\n\r\n同样，你也可以定义一个方法来检索关系的「最早」或第一个相关模型：\r\n\r\n```php\r\n/**\r\n * 获取用户最早上传的图像。\r\n */\r\npublic function oldestImage(): MorphOne\r\n{\r\n    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();\r\n}\r\n```\r\n\r\n默认情况下，`latestOfMany` 和 `oldestOfMany` 方法将基于模型的主键（必须可排序）检索最新或最旧的相关模型。但是，有时你可能希望使用不同的排序条件从较大的关系中检索单个模型。\r\n\r\n\r\n例如，使用 `ofMany` 方法，可以检索用户点赞最高的图像。`ofMany` 方法接受可排序列作为其第一个参数，以及在查询相关模型时应用哪个聚合函数（`min` 或 `max`）：\r\n\r\n```php\r\n/**\r\n * 获取用户最受欢迎的图像。\r\n */\r\npublic function bestImage(): MorphOne\r\n{\r\n    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');\r\n}\r\n```\r\n\r\n> **提示**\r\n> 要构建更高级的「一对多」关系。 请查看 [进阶一对多检索](#advanced-has-one-of-many-relationships).\r\n\r\n<a name=\"many-to-many-polymorphic-relations\"></a>\r\n### 多对多（多态）\r\n\r\n<a name=\"many-to-many-polymorphic-table-structure\"></a>\r\n#### 表结构\r\n\r\n多对多多态关联比 `morphOne` 和 `morphMany` 关联略微复杂一些。例如，`Post` 和 `Video` 模型能够共享关联到 `Tag` 模型的多态关系。在这种情况下使用多对多多态关联允许使用一个唯一标签在博客文章和视频间共享。以下是多对多多态关联的表结构：\r\n\r\n    posts\r\n        id - integer\r\n        name - string\r\n\r\n    videos\r\n        id - integer\r\n        name - string\r\n\r\n    tags\r\n        id - integer\r\n        name - string\r\n\r\n    taggables\r\n        tag_id - integer\r\n        taggable_id - integer\r\n        taggable_type - string\r\n\r\n> **提示**\r\n> 在深入研究多态多对多关系之前，阅读 [多对多关系](#many-to-many) 的文档会对你有帮助。\r\n\r\n\r\n<a name=\"many-to-many-polymorphic-model-structure\"></a>\r\n#### 模型结构\r\n\r\n接下来，我们可以定义模型之间的关联。`Post` 和 `Video` 模型都将包含一个 `tags` 方法，该方法调用了基础 Eloquent 模型类提供的 `morphToMany` 方法。\r\n\r\n\r\n\r\n`morphToMany` 方法接受相关模型的名称以及“关系名称”。根据我们分配给中间表的名称及其包含的键，我们将将关系称为 「taggable」：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphToMany;\r\n\r\n    class Post extends Model\r\n    {\r\n        /**\r\n         * 获取帖子的所有标签。\r\n         */\r\n        public function tags(): MorphToMany\r\n        {\r\n            return $this->morphToMany(Tag::class, 'taggable');\r\n        }\r\n    }\r\n\r\n<a name=\"many-to-many-polymorphic-defining-the-inverse-of-the-relationship\"></a>\r\n#### 定义多对多（多态）反向关系\r\n\r\n接下来, 在这个 `Tag` 模型中, 你应该为每个可能的父模型定义一个方法. 所以, 在这个例子中, 我们将会定义一个  `posts` 方法 和 一个 `videos` 方法. 这两个方法都应该返回 `morphedByMany`  结果。\r\n\r\n`morphedByMany` 方法接受相关模型的名称以及「关系名称」。根据我们分配给中间表名的名称及其包含的键，我们将该关系称为「taggable」：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphToMany;\r\n\r\n    class Tag extends Model\r\n    {\r\n        /**\r\n         * 获取分配给此标签的所有帖子。\r\n         */\r\n        public function posts(): MorphToMany\r\n        {\r\n            return $this->morphedByMany(Post::class, 'taggable');\r\n        }\r\n\r\n        /**\r\n         * 获取分配给此视频的所有帖子.\r\n         */\r\n        public function videos(): MorphToMany\r\n        {\r\n            return $this->morphedByMany(Video::class, 'taggable');\r\n        }\r\n    }\r\n\r\n<a name=\"many-to-many-polymorphic-retrieving-the-relationship\"></a>\r\n#### 获取关联\r\n\r\n一旦定义了数据库表和模型，你就可以通过模型访问关系。 例如，要访问帖子的所有标签，你可以使用 `tags` 动态关系属性：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::find(1);\r\n\r\n    foreach ($post->tags as $tag) {\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n还可以访问执行 `morphedByMany` 方法调用的方法名来从多态模型获取其所属模型。在这个示例中，就是 `Tag` 模型的 `posts` 或 `videos` 方法。可以像动态属性一样访问这些方法：\r\n\r\n    use App\\Models\\Tag;\r\n\r\n    $tag = Tag::find(1);\r\n\r\n    foreach ($tag->posts as $post) {\r\n        // ...\r\n    }\r\n\r\n    foreach ($tag->videos as $video) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"custom-polymorphic-types\"></a>\r\n### 自定义多态类型\r\n\r\n默认情况下，Laravel 将使用完全限定的类名来存储相关模型的「类型」。 例如，给定上面的一对多关系示例，其中 `Comment` 模型可能属于 `Post` 或 `Video`模型，默认的 `commentable_type` 将分别是 `App\\Models\\Post` 或 `App\\Models\\Video`。 但是，你可能希望将这些值与应用程序的内部结构解耦。\r\n\r\n例如，我们可以使用简单的字符串，例如 `post` 和 `video`，而不是使用模型名称作为「类型」。 通过这样做，即使模型被重命名，我们数据库中的多态「类型」列值也将保持有效：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\Relation;\r\n\r\n    Relation::enforceMorphMap([\r\n        'post' => 'App\\Models\\Post',\r\n        'video' => 'App\\Models\\Video',\r\n    ]);\r\n\r\n你可以在 `App\\Providers\\AppServiceProvider` 类的 `boot` 方法中调用 `enforceMorphMap` 方法，或者你也可以创建一个单独的服务提供者。\r\n\r\n你可以在运行时使用 `getMorphClass` 方法确定给定模型的别名。相反，可以使用 `Relation::getMorphedModel` 方法来确定与别名相关联的类名：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\Relation;\r\n\r\n    $alias = $post->getMorphClass();\r\n\r\n    $class = Relation::getMorphedModel($alias);\r\n\r\n> **注意**\r\n> 向现有应用程序添加「变形映射」时，数据库中仍包含完全限定类的每个可变形 `*_type` 列值都需要转换为其「映射」名称。\r\n\r\n\r\n\r\n<a name=\"dynamic-relationships\"></a>\r\n### 动态关联\r\n\r\n你可以使用 `resolveRelationUsing` 方法在运行时定义 Eloquent 模型之间的关系。虽然通常不建议在常规应用程序开发中使用它，但是在开发 Laravel 软件包时，这有时可能会很有用。\r\n\r\n`resolveRelationUsing` 方法的第一个参数是关联名称。传递给该方法的第二个参数应该是一个闭包，闭包接受模型实例并返回一个有效的 Eloquent 关联定义。通常情况下，你应该在[服务提供器](https://learnku.com/docs/laravel/10.x/providersmd/14843)的启动方法中配置动态关联:\r\n\r\n    use App\\Models\\Order;\r\n    use App\\Models\\Customer;\r\n\r\n    Order::resolveRelationUsing('customer', function (Order $orderModel) {\r\n        return $orderModel->belongsTo(Customer::class, 'customer_id');\r\n    });\r\n\r\n> **注意**  \r\n> 定义动态关系时，始终为 Eloquent 关系方法提供显式的键名参数。\r\n\r\n<a name=\"querying-relations\"></a>\r\n## 查询关联\r\n\r\n因为所有的 Eloquent 关联都是通过方法定义的，你可以调用这些方法来获取关联的实例，而无需真实执行查询来获取相关的模型。此外，所有的 Eloquent 关联也可以用作[查询构造器](https://learnku.com/docs/laravel/10.x/queriesmd/14883)，允许你在最终对数据库执行 SQL 查询之前，继续通过链式调用添加约束条件。\r\n\r\n例如，假设有一个博客系统，它的 `User` 模型有许多关联的 `Post` 模型:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\HasMany;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 获取该用户的所有文章.\r\n         */\r\n        public function posts(): HasMany\r\n        {\r\n            return $this->hasMany(Post::class);\r\n        }\r\n    }\r\n\r\n你可以查询 `posts` 关联，并给它添加额外的约束条件，如下例所示:\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->posts()->where('active', 1)->get();\r\n\r\n\r\n\r\n你可以在关联上使用任意的 [查询构造器]([查询构造器 | 《Laravel 10 中文文档》 (learnku.com)](https://learnku.com/docs/laravel/10.x/queriesmd/14883)) 方法，所以一定要阅读查询构造器的文档，了解它的所有方法，这会对你非常有用。\r\n\r\n<a name=\"chaining-orwhere-clauses-after-relationships\"></a>\r\n#### 在关联之后链式添加 `orWhere` 子句\r\n\r\n如上例所示，你可以在查询关联时，自由的给关联添加额外的约束条件。但是，在将 `orWhere` 子句链接到关联上时，一定要小心，因为 `orWhere` 子句将在逻辑上与关联约束处于同一级别：\r\n\r\n    $user->posts()\r\n            ->where('active', 1)\r\n            ->orWhere('votes', '>=', 100)\r\n            ->get();\r\n\r\n上面的例子将生成以下 SQL。像你看到的那样， 这个 `or` 子句的查询指令，将返回大于 100 票的任一用户，查询不再限于特定的用户：\r\n\r\n```sql\r\nselect *\r\nfrom posts\r\nwhere user_id = ? and active = 1 or votes >= 100\r\n```\r\n\r\n在大多数情况下，你应该使用 [逻辑分组]([查询构造器 | 《Laravel 10 中文文档》 (learnku.com)](https://learnku.com/docs/laravel/10.x/queriesmd/14883#logical-grouping)) 在括号中对条件检查进行分组：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $user->posts()\r\n            ->where(function (Builder $query) {\r\n                return $query->where('active', 1)\r\n                             ->orWhere('votes', '>=', 100);\r\n            })\r\n            ->get();\r\n\r\n上面的示例将生成以下 SQL。 请注意，逻辑分组已正确分组约束，并且查询仍然受限于特定用户：\r\n\r\n```sql\r\nselect *\r\nfrom posts\r\nwhere user_id = ? and (active = 1 or votes >= 100)\r\n```\r\n\r\n<a name=\"relationship-methods-vs-dynamic-properties\"></a>\r\n### 关联方法 VS 动态属性\r\n\r\n如果你不需要向 Eloquent 关联查询添加额外的约束，你可以像访问属性一样访问关联。 例如，继续使用我们的 `User` 和 `Post` 示例模型，我们可以像这样访问用户的所有帖子：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    foreach ($user->posts as $post) {\r\n        // ...\r\n    }\r\n\r\n\r\n\r\n动态属性是 「懒加载」 的，只有实际访问到才会加载关联数据。因此，通常用 [预加载](#eager-loading) 来准备模型需要用到的关联数据。预加载能大量减少因加载模型关联执行的 SQL 语句。 \r\n\r\n<a name=\"querying-relationship-existence\"></a>\r\n### 基于存在的关联查询\r\n\r\n在检索模型记录时，你可能希望基于关系的存在限制结果。例如，假设你想检索至少有一条评论的所有博客文章。为了实现这一点，你可以将关系名称传递给 `has` 和 `orHas` 方法：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    // 检索所有至少有一条评论的文章...\r\n    $posts = Post::has('comments')->get();\r\n\r\n也可以指定运算符和数量来进一步自定义查询：\r\n\r\n    // 检索所有有三条或更多评论的文章...\r\n    $posts = Post::has('comments', '>=', 3)->get();\r\n\r\n可以使用用「.」语法构造嵌套的 `has` 语句。例如，你可以检索包含至少一张图片的评论的所有文章：\r\n\r\n    // 查出至少有一条带图片的评论的文章...\r\n    $posts = Post::has('comments.images')->get();\r\n\r\n如果你需要更多的功能，你可以使用 `whereHas` 和 `orWhereHas` 方法在 `has` 查询中定义额外的查询约束，例如检查评论的内容：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    // 检索至少有一条评论包含类似于 code% 单词的文章...\r\n    $posts = Post::whereHas('comments', function (Builder $query) {\r\n        $query->where('content', 'like', 'code%');\r\n    })->get();\r\n\r\n    // 检索至少有十条评论包含类似于 code% 单词的文章...\r\n    $posts = Post::whereHas('comments', function (Builder $query) {\r\n        $query->where('content', 'like', 'code%');\r\n    }, '>=', 10)->get();\r\n\r\n> **注意**\r\n> Eloquent 目前不支持跨数据库查询关系是否存在。 这些关系必须存在于同一数据库中。\r\n\r\n\r\n\r\n<a name=\"inline-relationship-existence-queries\"></a>\r\n#### 内联关系存在查询\r\n\r\n如果你想使用附加到关系查询简单的 where 条件来确认关系是否存在，使用 `whereRelation`, `orWhereRelation`, `whereMorphRelation`和 `orWhereMorphRelation` 方法更方便. 例如，查询所有评论未获批准的帖子:\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::whereRelation('comments', 'is_approved', false)->get();\r\n\r\n当然，就像调用查询构建器的 `where` 方法一样，你也可以指定一个运算符：\r\n\r\n    $posts = Post::whereRelation(\r\n        'comments', 'created_at', '>=', now()->subHour()\r\n    )->get();\r\n\r\n<a name=\"querying-relationship-absence\"></a>\r\n### 查询不存在的关联\r\n\r\n检索模型记录时，你可能会根据不存在关系来限制结果。例如，要检索所有**没有**任何评论的所有博客文章。 可以将关系的名称传递给 `doesntHave` 和 `orDoesntHave` 方法：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::doesntHave('comments')->get();\r\n\r\n如果需要更多功能，可以使用 `whereDoesntHave` 和 `orWhereDoesntHave` 方法将「where」 条件加到 `doesntHave` 查询上。这些方法允许你向关联加入自定义限制，比如检测评论内容：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $posts = Post::whereDoesntHave('comments', function (Builder $query) {\r\n        $query->where('content', 'like', 'code%');\r\n    })->get();\r\n\r\n你可以使用「点」符号对嵌套关系执行查询。例如，以下查询将检索所有没有评论的帖子；但是，有未被禁止的作者评论的帖子将包含在结果中:\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $posts = Post::whereDoesntHave('comments.author', function (Builder $query) {\r\n        $query->where('banned', 0);\r\n    })->get();\r\n\r\n\r\n\r\n<a name=\"querying-morph-to-relationships\"></a>\r\n### 查询多态关联\r\n\r\n要查询「多态关联」的存在，可以使用 `whereHasMorph` 和 `whereDoesntHaveMorph` 方法。这些方法接受关联名称作为它们的第一个参数。接下来，这些方法接受你希望在查询中包含的相关模型的名称。最后，你可以提供一个闭包来自定义关联查询。\r\n\r\n    use App\\Models\\Comment;\r\n    use App\\Models\\Post;\r\n    use App\\Models\\Video;\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    // 检索与标题类似于 code% 的帖子或视频相关的评论。\r\n    $comments = Comment::whereHasMorph(\r\n        'commentable',\r\n        [Post::class, Video::class],\r\n        function (Builder $query) {\r\n            $query->where('title', 'like', 'code%');\r\n        }\r\n    )->get();\r\n\r\n    // 检索与标题不类似于 code% 的帖子相关的评论。\r\n    $comments = Comment::whereDoesntHaveMorph(\r\n        'commentable',\r\n        Post::class,\r\n        function (Builder $query) {\r\n            $query->where('title', 'like', 'code%');\r\n        }\r\n    )->get();\r\n\r\n你可能需要根据相关多态模型的「类型」添加查询约束。传递给 `whereHasMorph` 方法的闭包可以接收 `$type` 值作为其第二个参数。此参数允许你检查正在构建的查询的「类型」：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $comments = Comment::whereHasMorph(\r\n        'commentable',\r\n        [Post::class, Video::class],\r\n        function (Builder $query, string $type) {\r\n            $column = $type === Post::class ? 'content' : 'title';\r\n\r\n            $query->where($column, 'like', 'code%');\r\n        }\r\n    )->get();\r\n\r\n<a name=\"querying-all-morph-to-related-models\"></a>\r\n#### 查询所有相关模型\r\n\r\n你可以使用通配符 `*` 代替多态模型的数组，这将告诉 Laravel 从数据库中检索所有可能的多态类型。为了执行此操作，Laravel 将执行额外的查询：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {\r\n        $query->where('title', 'like', 'foo%');\r\n    })->get();\r\n\r\n\r\n\r\n<a name=\"aggregating-related-models\"></a>\r\n## 聚合相关模型\r\n\r\n<a name=\"counting-related-models\"></a>\r\n### 计算相关模型的数量\r\n\r\n有时候你可能想要计算给定关系的相关模型的数量，而不实际加载模型。为了实现这一点，你可以使用 `withCount` 方法。`withCount` 方法将在生成的模型中放置一个 `{relation}_count` 属性：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::withCount('comments')->get();\r\n\r\n    foreach ($posts as $post) {\r\n        echo $post->comments_count;\r\n    }\r\n\r\n通过将数组传递给 withCount 方法，你可以同时添加多个关系的 \"计数\"，并向查询添加其他约束：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $posts = Post::withCount(['votes', 'comments' => function (Builder $query) {\r\n        $query->where('content', 'like', 'code%');\r\n    }])->get();\r\n\r\n    echo $posts[0]->votes_count;\r\n    echo $posts[0]->comments_count;\r\n\r\n你还可以给关系计数结果起别名，从而在同一关系上进行多个计数：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $posts = Post::withCount([\r\n        'comments',\r\n        'comments as pending_comments_count' => function (Builder $query) {\r\n            $query->where('approved', false);\r\n        },\r\n    ])->get();\r\n\r\n    echo $posts[0]->comments_count;\r\n    echo $posts[0]->pending_comments_count;\r\n\r\n<a name=\"deferred-count-loading\"></a>\r\n#### 延迟计数加载\r\n\r\n使用 `loadCount` 方法，你可以在获取父模型后加载关系计数：\r\n\r\n    $book = Book::first();\r\n\r\n    $book->loadCount('genres');\r\n\r\n如果你需要在计数查询上设置其他查询约束，你可以传递一个以你想要计数的关系为键的数组。数组的值应该是接收查询构建器实例的闭包：\r\n\r\n    $book->loadCount(['reviews' => function (Builder $query) {\r\n        $query->where('rating', 5);\r\n    }])\r\n\r\n\r\n\r\n<a name=\"relationship-counting-and-custom-select-statements\"></a>\r\n#### 关联计数和自定义查询字段\r\n\r\n如果你的查询同时包含 `withCount` 和 `select`，请确保 `withCount` 一定在 `select` 之后调用：\r\n\r\n    $posts = Post::select(['title', 'body'])\r\n                    ->withCount('comments')\r\n                    ->get();\r\n\r\n<a name=\"other-aggregate-functions\"></a>\r\n### 其他聚合函数\r\n\r\n除了 `withCount` 方法外，Eloquent 还提供了 `withMin`, `withMax`, `withAvg` 和 `withSum` 等聚合方法。\r\n这些方法会通过 `{relation}_{function}_{column}` 的命名方式将聚合结果添加到获取到的模型属性中：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $posts = Post::withSum('comments', 'votes')->get();\r\n\r\n    foreach ($posts as $post) {\r\n        echo $post->comments_sum_votes;\r\n    }\r\n\r\n如果你想使用其他名称访问聚合函数的结果，可以自定义的别名：\r\n\r\n    $posts = Post::withSum('comments as total_comments', 'votes')->get();\r\n\r\n    foreach ($posts as $post) {\r\n        echo $post->total_comments;\r\n    }\r\n\r\n与 `loadCount` 方法类似，这些方法也有延迟调用的方法。这些延迟方法可在已获取到的 Eloquent 模型上调用：\r\n\r\n\r\n    $post = Post::first();\r\n\r\n    $post->loadSum('comments', 'votes');\r\n\r\n如果你将这些聚合方法和一个 `select` 语句组合在一起，确保你在 `select` 方法之后调用聚合方法:\r\n\r\n    $posts = Post::select(['title', 'body'])\r\n                    ->withExists('comments')\r\n                    ->get();\r\n\r\n<a name=\"counting-related-models-on-morph-to-relationships\"></a>\r\n### 多态关联计数\r\n\r\n如果你想预加载多态关联关系以及这个关联关系关联的其他关联关系的计数统计，可以通过将 `with` 方法与 `morphTo` 关系和 `morphWithCount` 方法结合来实现。\r\n\r\n在这个例子中，我们假设 `Photo` 和 `Post` 模型可以创建 `ActivityFeed` 模型。 我们将假设 `ActivityFeed`模型定义了一个名为`parentable`的多态关联关系，它允许我们为给定的 `ActivityFeed` 实例检索父级 `Photo` 或 `Post` 模型。 此外，让我们假设 `Photo` 模型有很多 `Tag` 模型、`Post` 模型有很多 `Comment` 模型。\r\n\r\n\r\n\r\n假如我们想要检索 `ActivityFeed` 实例并为每个 `ActivityFeed` 实例预先加载 `parentable` 父模型。 此外，我们想要检索与每张父照片关联的标签数量以及与每个父帖子关联的评论数量：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    $activities = ActivityFeed::with([\r\n        'parentable' => function (MorphTo $morphTo) {\r\n            $morphTo->morphWithCount([\r\n                Photo::class => ['tags'],\r\n                Post::class => ['comments'],\r\n            ]);\r\n        }])->get();\r\n\r\n<a name=\"morph-to-deferred-count-loading\"></a>\r\n#### 延迟计数加载\r\n\r\n假设我们已经检索了一组 `ActivityFeed` 模型，现在我们想要加载与活动提要关联的各种 `parentable` 模型的嵌套关系计数。 可以使用 `loadMorphCount` 方法来完成此操作：\r\n\r\n    $activities = ActivityFeed::with('parentable')->get();\r\n\r\n    $activities->loadMorphCount('parentable', [\r\n        Photo::class => ['tags'],\r\n        Post::class => ['comments'],\r\n    ]);\r\n\r\n<a name=\"eager-loading\"></a>\r\n## 预加载\r\n\r\n当将 Eloquent 关系作为属性访问时，相关模型是延迟加载的。 这意味着在你第一次访问该属性之前不会实际加载关联数据。 但是，Eloquent 可以在查询父模型时主动加载关联关系。 预加载减轻了 `N + 1` 查询问题。 为了说明 `N + 1` 查询问题，请参考属于 `Author` 模型的 `Book` 模型：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\r\n\r\n    class Book extends Model\r\n    {\r\n        /**\r\n         * 获取写了这本书的作者。\r\n         */\r\n        public function author(): BelongsTo\r\n        {\r\n            return $this->belongsTo(Author::class);\r\n        }\r\n    }\r\n\r\n现在，让我们检索所有书籍及其作者：\r\n\r\n    use App\\Models\\Book;\r\n\r\n    $books = Book::all();\r\n\r\n    foreach ($books as $book) {\r\n        echo $book->author->name;\r\n    }\r\n\r\n\r\n\r\n该循环将执行一个查询以检索数据库表中的所有书籍，然后对每本书执行另一个查询以检索该书的作者。 因此，如果我们有 25 本书，上面的代码将运行 26 个查询：一个查询原本的书籍信息，另外 25 个查询来检索每本书的作者。\r\n\r\n值得庆幸的是，我们可以使用预加载将这个操作减少到两个查询。 在构建查询时，可以使用 `with` 方法指定应该预加载哪些关系： \r\n\r\n    $books = Book::with('author')->get();\r\n\r\n    foreach ($books as $book) {\r\n        echo $book->author->name;\r\n    }\r\n\r\n对于此操作，将只执行两个查询 - 一个查询检索书籍，一个查询检索所有书籍的作者：\r\n\r\n```sql\r\nselect * from books\r\n\r\nselect * from authors where id in (1, 2, 3, 4, 5, ...)\r\n```\r\n\r\n<a name=\"eager-loading-multiple-relationships\"></a>\r\n#### 预加载多个关联\r\n\r\n有时，你可能需要在单一操作中预加载几个不同的关联。要达成此目的，只要向 `with` 方法传递多个关联名称构成的数组参数：\r\n\r\n    $books = Book::with(['author', 'publisher'])->get();\r\n\r\n<a name=\"nested-eager-loading\"></a>\r\n#### 嵌套预加载\r\n\r\n可以使用 「.」 语法预加载嵌套关联。比如在一个 Eloquent 语句中预加载所有书籍作者及其联系方式：\r\n\r\n    $books = Book::with('author.contacts')->get();\r\n\r\n另外，你可以通过向 `with` 方法提供嵌套数组来指定嵌套的预加载关系，这在预加载多个嵌套关系时非常方便。\r\n\r\n    $books = Book::with([\r\n        'author' => [\r\n            'contacts',\r\n            'publisher',\r\n        ],\r\n    ])->get();\r\n\r\n\r\n\r\n<a name=\"nested-eager-loading-morphto-relationships\"></a>\r\n#### 嵌套预加载 `morphTo` 关联\r\n\r\n如果你希望加载一个 `morphTo` 关系，以及该关系可能返回的各种实体的嵌套关系，可以将 `with` 方法与 `morphTo` 关系的 `morphWith` 方法结合使用。为了说明这种方法，让我们参考以下模型：\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    class ActivityFeed extends Model\r\n    {\r\n        /**\r\n         * 获取活动记录的父记录。\r\n         */\r\n        public function parentable(): MorphTo\r\n        {\r\n            return $this->morphTo();\r\n        }\r\n    }\r\n\r\n在这个例子中，我们假设 `Event`，`Photo` 和 `Post` 模型可以创建 `ActivityFeed` 模型。 另外，我们假设 `Event` 模型属于 `Calendar` 模型，`Photo` 模型与 `Tag` 模型相关联，`Post` 模型属于 `Author` 模型。\r\n\r\n使用这些模型定义和关联，我们可以查询 `ActivityFeed` 模型实例并预加载所有 `parentable` 模型及其各自的嵌套关系：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    $activities = ActivityFeed::query()\r\n        ->with(['parentable' => function (MorphTo $morphTo) {\r\n            $morphTo->morphWith([\r\n                Event::class => ['calendar'],\r\n                Photo::class => ['tags'],\r\n                Post::class => ['author'],\r\n            ]);\r\n        }])->get();\r\n\r\n<a name=\"eager-loading-specific-columns\"></a>\r\n#### 预加载指定列\r\n\r\n并不是总需要获取关系的每一列。在这种情况下，Eloquent 允许你为关联指定想要获取的列:\r\n\r\n    $books = Book::with('author:id,name,book_id')->get();\r\n\r\n> **注意**\r\n> 使用此功能时，应始终在要检索的列列表中包括 `id` 列和任何相关的外键列。\r\n\r\n\r\n\r\n<a name=\"eager-loading-by-default\"></a>\r\n#### 默认预加载\r\n\r\n有时可能希望在查询模型时始终加载某些关联。 为此，你可以在模型上定义 `$with` 属性\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\r\n\r\n    class Book extends Model\r\n    {\r\n        /**\r\n         * 默认预加载的关联。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $with = ['author'];\r\n\r\n        /**\r\n         * 获取书籍作者。\r\n         */\r\n        public function author(): BelongsTo\r\n        {\r\n            return $this->belongsTo(Author::class);\r\n        }\r\n\r\n        /**\r\n         * 获取书籍类型。\r\n         */\r\n        public function genre(): BelongsTo\r\n        {\r\n            return $this->belongsTo(Genre::class);\r\n        }\r\n    }\r\n\r\n如果你想从单个查询的 `$with` 属性中删除一个预加载，你可以使用 `without` 方法：\r\n\r\n    $books = Book::without('author')->get();\r\n\r\n如果你想要覆盖 `$with` 属性中所有项，仅针对单个查询，你可以使用 `withOnly` 方法：\r\n\r\n    $books = Book::withOnly('genre')->get();\r\n\r\n<a name=\"constraining-eager-loads\"></a>\r\n### 约束预加载\r\n\r\n有时，你可能希望预加载一个关联，同时为预加载查询添加额外查询条件。你可以通过将一个关联数组传递给 `with` 方法来实现这一点，其中数组键是关联名称，数组值是一个闭包，它为预先加载查询添加了额外的约束：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::with(['posts' => function (Builder $query) {\r\n        $query->where('title', 'like', '%code%');\r\n    }])->get();\r\n\r\n在这个例子中，Eloquent 只会预加载帖子的 `title` 列包含单词 `code` 的帖子。 你可以调用其他 [查询构造器](/docs/laravel/10.x/queries) 方法来自定义预加载操作：\r\n\r\n    $users = User::with(['posts' => function (Builder $query) {\r\n        $query->orderBy('created_at', 'desc');\r\n    }])->get();\r\n\r\n> **注意**\r\n> 在约束预加载时，不能使用 limit 和 take 查询构造器方法。\r\n\r\n\r\n\r\n<a name=\"constraining-eager-loading-of-morph-to-relationships\"></a>\r\n#### `morphTo` 关联预加载添加约束\r\n\r\n如果你在使用 Eloquent 进行 `morphTo` 关联的预加载时，Eloquent 将运行多个查询以获取每种类型的相关模型。你可以使用 `MorphTo` 关联的 `constrain` 方法向每个查询添加附加约束条件：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    $comments = Comment::with(['commentable' => function (MorphTo $morphTo) {\r\n        $morphTo->constrain([\r\n            Post::class => function (Builder $query) {\r\n                $query->whereNull('hidden_at');\r\n            },\r\n            Video::class => function (Builder $query) {\r\n                $query->where('type', 'educational');\r\n            },\r\n        ]);\r\n    }])->get();\r\n\r\n在这个例子中，Eloquent 只会预先加载未被隐藏的帖子，并且视频的 `type` 值为 `educational`。\r\n\r\n<a name=\"constraining-eager-loads-with-relationship-existence\"></a>\r\n#### 基于存在限制预加载\r\n\r\n有时候，你可能需要同时检查关系的存在性并根据相同条件加载关系。例如，你可能希望仅查询具有符合给定条件的子模型 `Post` 的 `User` 模型，同时也预加载匹配的文章。你可以使用 Laravel 中的 `withWhereHas` 方法来实现这一点。\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    $users = User::withWhereHas('posts', function (Builder $query) {\r\n        $query->where('featured', true);\r\n    })->get();\r\n\r\n<a name=\"lazy-eager-loading\"></a>\r\n### 延迟预加载\r\n\r\n有时你可能需要在查询父模型之后预加载关联。例如，如果你需要动态地决定是否加载相关模型，则这可能非常有用：\r\n\r\n    use App\\Models\\Book;\r\n\r\n    $books = Book::all();\r\n\r\n    if ($someCondition) {\r\n        $books->load('author', 'publisher');\r\n    }\r\n\r\n\r\n\r\n如果要在渴求式加载的查询语句中进行条件约束，可以通过数组的形式去加载，键为对应的关联关系，值为 `Closure` 闭包函数，该闭包的参数为一个查询实例：\r\n\r\n    $author->load(['books' => function (Builder $query) {\r\n        $query->orderBy('published_date', 'asc');\r\n    }]);\r\n\r\n如果希望仅加载未被加载的关联关系时，你可以使用 `loadMissing` 方法：\r\n\r\n    $book->loadMissing('author');\r\n\r\n<a name=\"nested-lazy-eager-loading-morphto\"></a>\r\n#### 嵌套延迟预加载 & `morphTo`\r\n\r\n如果要预加载 `morphTo` 关系，以及该关系可能返回的各种实体上的嵌套关系，你可以使用 `loadMorph` 方法。\r\n\r\n这个方法接受 `morphTo` 关系的名称作为它的第一个参数，第二个参数接收模型数组、关系数组。例如:\r\n\r\n    <?php\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\r\n\r\n    class ActivityFeed extends Model\r\n    {\r\n        /**\r\n         * 获取活动提要记录的父项。\r\n         */\r\n        public function parentable(): MorphTo\r\n        {\r\n            return $this->morphTo();\r\n        }\r\n    }\r\n\r\n在这个例子中，让我们假设 `Event` 、`Photo` 和 `Post` 模型可以创建 `ActivityFeed` 模型。此外，让我们假设 `Event` 模型属于 `Calendar` 模型，`Photo` 模型与 `Tag` 模型相关联，`Post` 模型属于 `Author` 模型。\r\n\r\n使用这些模型定义和关联关系，我们方可以检索 `ActivityFeed` 模型实例，并立即加载所有 `parentable` 模型及其各自的嵌套关系：\r\n\r\n    $activities = ActivityFeed::with('parentable')\r\n        ->get()\r\n        ->loadMorph('parentable', [\r\n            Event::class => ['calendar'],\r\n            Photo::class => ['tags'],\r\n            Post::class => ['author'],\r\n        ]);\r\n\r\n\r\n\r\n<a name=\"preventing-lazy-loading\"></a>\r\n### 防止延迟加载\r\n\r\n如前所述，预加载关系可以为应用程序提供显著的性能优势。 但你也可以指示 Laravel 始终防止延迟加载关系。 你可以调用基本 Eloquent 模型类提供的 `preventLazyLoading` 方法。 通常，你应该在应用程序的 `AppServiceProvider` 类的 `boot` 方法中调用此方法。\r\n\r\n`preventLazyLoading` 方法接受一个可选的布尔类型的参数，表示是否阻止延迟加载。例如，你可能希望只在非生产环境中禁用延迟加载，这样即使在生产环境代码中意外出现了延迟加载关系，你的生产环境也能继续正常运行。\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\n/**\r\n * 引导应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Model::preventLazyLoading(! $this->app->isProduction());\r\n}\r\n```\r\n\r\n在阻止延迟加载之后，当你的应用程序尝试延迟加载任何 Eloquent 关系时，Eloquent 将抛出 `Illuminate\\Database\\LazyLoadingViolationException` 异常。\r\n\r\n你可以使用 `handleLazyLoadingViolationsUsing` 方法自定义延迟加载的违规行为。例如，使用此方法，你可以指示违规行为只被记录，而不是使用异常中断应用程序的执行：\r\n\r\n```php\r\nModel::handleLazyLoadingViolationUsing(function (Model $model, string $relation) {\r\n    $class = get_class($model);\r\n\r\n    info(\"Attempted to lazy load [{$relation}] on model [{$class}].\");\r\n});\r\n```\r\n\r\n<a name=\"inserting-and-updating-related-models\"></a>\r\n## 插入 & 更新关联模型\r\n\r\n<a name=\"the-save-method\"></a>\r\n### `save` 方法\r\n\r\nEloquent 提供了向关系中添加新模型的便捷方法。例如，你可能需要向一篇文章（`Post` 模型）添加一条新的评论（`Comment` 模型），你不用手动设置 `Comment` 模型上的 `post_id` 属性，你可以直接使用关联模型中的 `save` 方法：\r\n\r\n    use App\\Models\\Comment;\r\n    use App\\Models\\Post;\r\n\r\n    $comment = new Comment(['message' => 'A new comment.']);\r\n\r\n    $post = Post::find(1);\r\n\r\n    $post->comments()->save($comment);\r\n\r\n\r\n\r\n注意，我们没有将 `comments` 关联作为动态属性访问，相反，我们调用了 `comments` 方法来来获得关联实例， `save` 方法会自动添加适当的 `post_id` 值到新的 `Comment` 模型中。\r\n\r\n如果需要保存多个关联模型，你可以使用 `saveMany` 方法：\r\n\r\n    $post = Post::find(1);\r\n\r\n    $post->comments()->saveMany([\r\n        new Comment(['message' => 'A new comment.']),\r\n        new Comment(['message' => 'Another new comment.']),\r\n    ]);\r\n\r\n`save` 和 `saveMany` 方法不会将新模型（`Comment`）加载到父模型（`Post`) 上， 如果你计划在使用 `save` 或 `saveMany` 方法后访问该关联模型（`Comment`），你需要使用 `refresh` 方法重新加载模型及其关联，这样你就可以访问到所有评论，包括新保存的评论了：\r\n\r\n    $post->comments()->save($comment);\r\n\r\n    $post->refresh();\r\n\r\n    // 所有评论，包括新保存的评论...\r\n    $post->comments;\r\n\r\n<a name=\"the-push-method\"></a>\r\n#### 递归保存模型和关联数据\r\n\r\n如果你想 `save` 模型及其所有关联数据，你可以使用 `push` 方法，在此示例中，将保存 `Post` 模型及其评论和评论作者：\r\n\r\n    $post = Post::find(1);\r\n\r\n    $post->comments[0]->message = 'Message';\r\n    $post->comments[0]->author->name = 'Author Name';\r\n\r\n    $post->push();\r\n\r\n`pushQuietly` 方法可用于保存模型及其关联关系，而不触发任何事件：\r\n\r\n    $post->pushQuietly();\r\n\r\n<a name=\"the-create-method\"></a>\r\n###  `create` 方法\r\n\r\n除了 `save` 和 `saveMany` 方法外，你还可以使用 `create` 方法。它接受一个属性数组，同时会创建模型并插入到数据库中。 还有， `save` 和 `create` 方法的不同之处在于， `save` 方法接受一个完整的 Eloquent 模型实例，而 `create` 则接受普通的 PHP 数组：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::find(1);\r\n\r\n    $comment = $post->comments()->create([\r\n        'message' => 'A new comment.',\r\n    ]);\r\n\r\n\r\n\r\n你还可以使用 `createMany` 方法去创建多个关联模型：\r\n\r\n    $post = Post::find(1);\r\n\r\n    $post->comments()->createMany([\r\n        ['message' => 'A new comment.'],\r\n        ['message' => 'Another new comment.'],\r\n    ]);\r\n\r\n还可以使用 `createQuietly` 和 `createManyQuietly`方法创建模型，而无需调度任何事件：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->posts()->createQuietly([\r\n        'title' => 'Post title.',\r\n    ]);\r\n\t\r\n    $user->posts()->createManyQuietly([\r\n        ['title' => 'First post.'],\r\n        ['title' => 'Second post.'],\r\n    ]);\r\n\r\n你还可以使用 `findOrNew`, `firstOrNew`, `firstOrCreate` 和 `updateOrCreate` 方法来 [创建和更新关系模型](/docs/laravel/10.x/eloquent#upserts)。\r\n\r\n> **注意**：在使用 `create` 方法前，请务必确保查看过本文档的 [批量赋值](/docs/laravel/10.x/eloquent#mass-assignment) 章节。\r\n\r\n<a name=\"updating-belongs-to-relationships\"></a>\r\n### Belongs To 关联\r\n\r\n如果你想将子模型分配给新的父模型，你可以使用 `associate` 方法。在这个例子中，`User` 模型定义了一个与 `Account` 模型的 `belongsTo` 关系。 这个 `associate` 方法将在子模型上设置外键：\r\n\r\n    use App\\Models\\Account;\r\n\r\n    $account = Account::find(10);\r\n\r\n    $user->account()->associate($account);\r\n\r\n    $user->save();\r\n\r\n要从子模型中删除父模型，你可以使用 `dissociate` 方法。此方法会将关联外键设置为 `null`：\r\n\r\n    $user->account()->dissociate();\r\n\r\n    $user->save();\r\n\r\n<a name=\"updating-many-to-many-relationships\"></a>\r\n### 多对多关联\r\n\r\n<a name=\"attaching-detaching\"></a>\r\n#### 附加 / 分离\r\n\r\nEloquent 也提供了一些额外的辅助方法，使相关模型的使用更加方便。例如，我们假设一个用户可以拥有多个角色，并且每个角色都可以被多个用户共享。给某个用户附加一个角色是通过向中间表插入一条记录实现的，可以使用 `attach` 方法完成该操作：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->roles()->attach($roleId);\r\n\r\n\r\n\r\n在将关系附加到模型时，还可以传递一组要插入到中间表中的附加数据：\r\n\r\n    $user->roles()->attach($roleId, ['expires' => $expires]);\r\n\r\n当然，有时也需要移除用户的角色。可以使用 `detach` 移除多对多关联记录。`detach` 方法将会移除中间表对应的记录。但是这两个模型都将会保留在数据库中:\r\n\r\n    // 移除用户的一个角色...\r\n    $user->roles()->detach($roleId);\r\n\r\n    // 移除用户的所有角色...\r\n    $user->roles()->detach();\r\n\r\n为了方便起见，`attach` 和 `detach` 也允许传递一个 IDs 数组：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->roles()->detach([1, 2, 3]);\r\n\r\n    $user->roles()->attach([\r\n        1 => ['expires' => $expires],\r\n        2 => ['expires' => $expires],\r\n    ]);\r\n\r\n<a name=\"syncing-associations\"></a>\r\n#### 同步关联\r\n\r\n你也可以使用 `sync` 方法构建多对多关联。`sync` 方法接收一个 IDs 数组以替换中间表的记录。中间表记录中，所有未在 IDs 数组中的记录都将会被移除。所以该操作结束后，只有给出数组的 IDs 会被保留在中间表中：\r\n\r\n    $user->roles()->sync([1, 2, 3]);\r\n\r\n你也可以通过 IDs 传递额外的附加数据到中间表：\r\n\r\n    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\r\n\r\n如果你想为每个同步的模型 IDs 插入相同的中间表，你可以使用 `syncWithPivotValues` 方法：\r\n\r\n    $user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);\r\n\r\n如果你不想移除现有的 IDs，可以使用 `syncWithoutDetaching` 方法：\r\n\r\n    $user->roles()->syncWithoutDetaching([1, 2, 3]);\r\n\r\n\r\n\r\n<a name=\"toggling-associations\"></a>\r\n#### 切换关联\r\n\r\n多对多关联也提供了 `toggle` 方法用于「切换」给定 ID 数组的附加状态。 如果给定的 ID 已被附加在中间表中，那么它将会被移除，同样，如果给定的 ID 已被移除，它将会被附加：\r\n\r\n    $user->roles()->toggle([1, 2, 3]);\r\n\r\n你还可以将附加的中间表值与ID 一起传递：\r\n\r\n    $user->roles()->toggle([\r\n        1 => ['expires' => true],\r\n        2 => ['expires' => true],\r\n    ]);\r\n\r\n<a name=\"updating-a-record-on-the-intermediate-table\"></a>\r\n#### 更新中间表上的记录\r\n\r\n如果你需要在中间表中更新一条已存在的记录，可以使用 `updateExistingPivot` 方法。 此方法接收中间表的外键与要更新的数据数组进行更新：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->roles()->updateExistingPivot($roleId, [\r\n        'active' => false,\r\n    ]);\r\n\r\n<a name=\"touching-parent-timestamps\"></a>\r\n## 更新父级时间戳\r\n\r\n当一个模型属 `belongsTo` 或者 `belongsToMany` 另一个模型时， 例如 `Comment` 属于 `Post` ，有时更新子模型导致更新父模型时间戳非常有用。\r\n\r\n例如，当 `Comment` 模型被更新时，你需要自动「触发」父级 `Post` 模型的 `updated_at` 时间戳的更新。`Eloquent` 让它变得简单。只要在子模型加一个包含关联名称的 `touches` 属性即可：:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\r\n\r\n    class Comment extends Model\r\n    {\r\n        /**\r\n         * 需要触发的所有关联关系。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $touches = ['post'];\r\n\r\n        /**\r\n         * 获取评论所属文章。\r\n         */\r\n        public function post(): BelongsTo\r\n        {\r\n            return $this->belongsTo(Post::class);\r\n        }\r\n    }\r\n\r\n> **注意**：只有使用 `Eloquent` 的 `save` 方法更新子模型时，才会触发更新父模型时间戳。\r\n\r\n","p":"docs/eloquent-relationships.html"},{"t":"eloquent-collections (Eloquent：集合)","d":"# Eloquent：集合\r\n\r\n- [介绍](#introduction)\r\n- [可用的方法](#available-methods)\r\n- [自定义集合](#custom-collections)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n所有以多个模型为查询结果的 Eloquent 方法的返回值都是 `Illuminate\\Database\\Eloquent\\Collection` 类的实例, 其中包括了通过 `get` 方法和关联关系获取的结果。Eloquent 集合对象扩展了 Laravel 的[基础集合类](/docs/laravel/10.x/collections)，因此它自然地继承了许多用于流畅地处理 Eloquent 模型的底层数组的方法。请务必查看 Laravel 集合文档以了解所有这些有用的方法！\r\n\r\n所有的集合都可作为迭代器，你可以像遍历普通的 PHP 数组一样来遍历它们:\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where('active', 1)->get();\r\n\r\n    foreach ($users as $user) {\r\n        echo $user->name;\r\n    }\r\n\r\n然而，正如前面所提到的，集合远比数组要强大，而且暴露了一系列直观的、可用于链式调用的 map/reduce 方法。打个比方，我们可以删除所有不活跃的模型，然后收集余下的所有用户的名字。\r\n\r\n    $names = User::all()->reject(function (User $user) {\r\n        return $user->active === false;\r\n    })->map(function (User $user) {\r\n        return $user->name;\r\n    });\r\n\r\n<a name=\"eloquent-collection-conversion\"></a>\r\n#### Eloquent 集合转换\r\n\r\n在大多数 Eloquent 集合方法返回一个新的 Eloquent 集合实例的前提下，`collapse`，`flatten`，`flip`， `keys`，`pluck`，以及 `zip` 方法返回一个[基础集合类](/docs/laravel/10.x/collections)的实例。 如果一个 `map` 方法返回了一个不包含任何模型的 Eloquent 集合，它也会被转换成一个基础集合实例。\r\n\r\n<a name=\"available-methods\"></a>\r\n## 可用的方法\r\n\r\n所有 Eloquent 的集合都继承了 [Laravel collection](/docs/laravel/10.x/collectionsmd#available-methods) 对象；因此， 他们也继承了所有集合基类提供的强大的方法。\r\n\r\n另外， `Illuminate\\Database\\Eloquent\\Collection` 类提供了一套上层的方法来帮你管理你的模型集合。大多数方法返回 `Illuminate\\Database\\Eloquent\\Collection` 实例；然而，也会有一些方法， 例如 `modelKeys`， 它们会返回基于 `Illuminate\\Support\\Collection` 类的实例。\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        columns: 14.4em 1; -moz-columns: 14.4em 1; -webkit-columns: 14.4em 1;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n    }\r\n\r\n    .collection-method code {\r\n        font-size: 14px;\r\n    }\r\n\r\n    .collection-method:not(.first-collection-method) {\r\n        margin-top: 50px;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[append](#method-append)\r\n[contains](#method-contains)\r\n[diff](#method-diff)\r\n[except](#method-except)\r\n[find](#method-find)\r\n[fresh](#method-fresh)\r\n[intersect](#method-intersect)\r\n[load](#method-load)\r\n[loadMissing](#method-loadMissing)\r\n[modelKeys](#method-modelKeys)\r\n[makeVisible](#method-makeVisible)\r\n[makeHidden](#method-makeHidden)\r\n[only](#method-only)\r\n[setVisible](#method-setVisible)\r\n[setHidden](#method-setHidden)\r\n[toQuery](#method-toquery)\r\n[unique](#method-unique)\r\n\r\n</div>\r\n\r\n<a name=\"method-append\"></a>\r\n#### `append($attributes)` {.collection-method .first-collection-method}\r\n\r\n可以使用`append`方法来为集合中的模型[追加属性](/docs/laravel/10.x/eloquent-serializationmd#appending-values-to-json)。 可以是数组或单个属性追加:\r\n\r\n    $users->append('team');\r\n\r\n    $users->append(['team', 'is_admin']);\r\n\r\n<a name=\"method-contains\"></a>\r\n#### `contains($key, $operator = null, $value = null)` {.collection-method}\r\n\r\n`contains` 方法可用于判断集合中是否包含指定的模型实例。这个方法接收一个主键或者模型实例：\r\n\r\n    $users->contains(1);\r\n\r\n    $users->contains(User::find(1));\r\n\r\n<a name=\"method-diff\"></a>\r\n#### `diff($items)` {.collection-method}\r\n\r\n`diff` 方法返回不在给定集合中的所有模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = $users->diff(User::whereIn('id', [1, 2, 3])->get());\r\n\r\n\r\n\r\n<a name=\"method-except\"></a>\r\n#### `except($keys)` {.collection-method}\r\n\r\n`except` 方法返回给定主键外的所有模型：\r\n\r\n    $users = $users->except([1, 2, 3]);\r\n\r\n<a name=\"method-find\"></a>\r\n#### `find($key)` {.collection-method}\r\n\r\n`find` 方法查找给定主键的模型。如果 `$key` 是一个模型实例， `find` 将会尝试返回与主键匹配的模型。 如果 `$key` 是一个关联数组， `find` 将返回所有数组主键匹配的模型：\r\n\r\n    $users = User::all();\r\n\r\n    $user = $users->find(1);\r\n\r\n<a name=\"method-fresh\"></a>\r\n#### `fresh($with = [])` {.collection-method}\r\n\r\n`fresh` 方法用于从数据库中检索集合中每个模型的新实例。此外，还将加载任何指定的关联关系：\r\n\r\n    $users = $users->fresh();\r\n\r\n    $users = $users->fresh('comments');\r\n\r\n<a name=\"method-intersect\"></a>\r\n#### `intersect($items)` {.collection-method}\r\n\r\n`intersect` 方法返回给定集合与当前模型的交集：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());\r\n\r\n<a name=\"method-load\"></a>\r\n#### `load($relations)` {.collection-method}\r\n\r\n`load` 方法为集合中的所有模型加载给定关联关系：\r\n\r\n    $users->load(['comments', 'posts']);\r\n\r\n    $users->load('comments.author');\r\n\r\n    $users->load(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);\r\n\r\n<a name=\"method-loadMissing\"></a>\r\n#### `loadMissing($relations)` {.collection-method}\r\n\r\n如果尚未加载关联关系，则 `loadMissing` 方法将加载集合中所有模型的给定关联关系：\r\n\r\n    $users->loadMissing(['comments', 'posts']);\r\n\r\n    $users->loadMissing('comments.author');\r\n\r\n    $users->loadMissing(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);\r\n\r\n<a name=\"method-modelKeys\"></a>\r\n\r\n\r\n#### `modelKeys()` {.collection-method}\r\n\r\n`modelKeys` 方法返回集合中所有模型的主键：\r\n\r\n    $users->modelKeys();\r\n\r\n    // [1, 2, 3, 4, 5]\r\n\r\n<a name=\"method-makeVisible\"></a>\r\n#### `makeVisible($attributes)` {.collection-method}\r\n\r\n`makeVisible` 方法[使模型上的隐藏属性可见](/docs/laravel/10.x/eloquent-serializationmd#hiding-attributes-from-json) ：\r\n\r\n    $users = $users->makeVisible(['address', 'phone_number']);\r\n\r\n<a name=\"method-makeHidden\"></a>\r\n#### `makeHidden($attributes)` {.collection-method}\r\n\r\n`makeHidden` 方法[隐藏模型属性](/docs/laravel/10.x/eloquent-serializationmd#hiding-attributes-from-json) ：\r\n\r\n    $users = $users->makeHidden(['address', 'phone_number']);\r\n\r\n<a name=\"method-only\"></a>\r\n#### `only($keys)` {.collection-method}\r\n\r\n`only` 方法返回具有给定主键的所有模型：\r\n\r\n    $users = $users->only([1, 2, 3]);\r\n\r\n<a name=\"method-setVisible\"></a>\r\n#### `setVisible($attributes)` {.collection-method}\r\n\r\n`setVisible`方法[临时覆盖](/docs/laravel/10.x/eloquent-serializationmd#temporarily-modifying-attribute-visibility)集合中每个模型的所有可见属性:\r\n\r\n    $users = $users->setVisible(['id', 'name']);\r\n\r\n<a name=\"method-setHidden\"></a>\r\n#### `setHidden($attributes)` {.collection-method}\r\n\r\n`setHidden`方法[临时覆盖](/docs/laravel/10.x/eloquent-serializationmd#temporarily-modifying-attribute-visibility)集合中每个模型的所有隐藏属性:\r\n\r\n    $users = $users->setHidden(['email', 'password', 'remember_token']);\r\n\r\n<a name=\"method-toquery\"></a>\r\n#### `toQuery()` {.collection-method}\r\n\r\n`toQuery` 方法返回一个 Eloquent 查询生成器实例，该实例包含集合模型主键上的 `whereIn` 约束：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $users = User::where('status', 'VIP')->get();\r\n\r\n    $users->toQuery()->update([\r\n        'status' => 'Administrator',\r\n    ]);\r\n\r\n<a name=\"method-unique\"></a>\r\n#### `unique($key = null, $strict = false)` {.collection-method}\r\n\r\n`unique` 方法返回集合中所有不重复的模型，若模型在集合中存在相同类型且相同主键的另一模型，该模型将被删除：\r\n\r\n    $users = $users->unique();\r\n\r\n<a name=\"custom-collections\"></a>\r\n## 自定义集合\r\n\r\n如果你想在与模型交互时使用一个自定义的 `Collection` 对象，你可以通过在模型中定义 `newCollection` 方法来实现：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Support\\UserCollection;\r\n    use Illuminate\\Database\\Eloquent\\Collection;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 创建新的Elquent Collection实例。\r\n         *\r\n         * @param  array<int, \\Illuminate\\Database\\Eloquent\\Model>  $models\r\n         * @return \\Illuminate\\Database\\Eloquent\\Collection<int, \\Illuminate\\Database\\Eloquent\\Model>\r\n         */\r\n        public function newCollection(array $models = []): Collection\r\n        {\r\n            return new UserCollection($models);\r\n        }\r\n    }\r\n\r\n一旦在模型中定义了一个 `newCollection` 方法，每当 Eloquent 需要返回一个 `Illuminate\\Database\\Eloquent\\Collection` 实例的时候，将会返回自定义集合的实例取代之。如果你想使每一个模型都使用自定义的集合，可以在一个模型基类中定义一个 `newCollection` 方法，然后让其它模型派生于此基类。\r\n\r\n","p":"docs/eloquent-collections.html"},{"t":"eloquent-mutators (Eloquent: 修改器 & 类型转换)","d":"# Eloquent: 修改器 & 类型转换\r\n\r\n- [简介](#introduction)\r\n- [访问器 & 修改器](#accessors-and-mutators)\r\n    - [定义一个访问器](#defining-an-accessor)\r\n    - [定义一个修改器](#defining-a-mutator)\r\n- [属性转换](#attribute-casting)\r\n    - [数组 & JSON 转换](#array-and-json-casting)\r\n    - [日期转换](#date-casting)\r\n    - [枚举转换](#enum-casting)\r\n    - [加密转换](#encrypted-casting)\r\n    - [查询时转换](#query-time-casting)\r\n- [自定义类型转换](#custom-casts)\r\n    - [值对象转换](#value-object-casting)\r\n    - [数组 / JSON 序列化](#array-json-serialization)\r\n    - [入站转换](#inbound-casting)\r\n    - [类型转换参数](#cast-parameters)\r\n    - [可转换](#castables)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n当你在 Eloquent 模型实例中获取或设置某些属性值时，访问器和修改器允许你对 Eloquent 属性值进行格式化。例如，你可能需要使用[ Laravel 加密器](/docs/laravel/10.x/encryption) 来加密保存在数据库中的值，而在使用 Eloquent 模型访问该属性的时候自动进行解密其值。\r\n\r\n或者，当通过 Eloquent 模型访问存储在数据库的 JSON 字符串时，你可能希望将其转换为数组。\r\n\r\n<a name=\"accessors-and-mutators\"></a>\r\n## 访问器 & 修改器\r\n\r\n<a name=\"defining-an-accessor\"></a>\r\n### 定义一个访问器\r\n\r\n访问器会在访问一个模型的属性时转换 Eloquent 值。要定义访问器，请在模型中创建一个受保护的「驼峰式」方法来表示可访问属性。此方法名称对应到真正的底层模型 `属性/数据库字段` 的表示。\r\n\r\n在本例中，我们将为 `first_name` 属性定义一个访问器。在尝试检索 `first_name` 属性的值时，Eloquent 会自动调用访问器。所有属性访问器 / 修改器方法必须声明 `Illuminate\\Database\\Eloquent\\Casts\\Attribute`的返回类型提示：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 获取用户的名字。\r\n         */\r\n        protected function firstName(): Attribute\r\n        {\r\n            return Attribute::make(\r\n                get: fn (string $value) => ucfirst($value),\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n\r\n所有访问器方法都返回一个 `Attribute` 实例，该实例定义了如何访问该属性以及如何改变该属性。 在此示例中，我们仅定义如何访问该属性。 为此，我们将 `get` 参数提供给 `Attribute` 类构造函数。\r\n\r\n如你所见，字段的原始值被传递到访问器中，允许你对它进行处理并返回结果。如果想获取被修改后的值，你可以在模型实例上访问 `first_name` 属性：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $firstName = $user->first_name;\r\n\r\n> **注意**： 如果要将这些计算值添加到模型的 array / JSON 中表示，[你需要追加它们](/docs/laravel/10.x/eloquent-serializationmd#appending-values-to-json).\r\n\r\n<a name=\"building-value-objects-from-multiple-attributes\"></a>\r\n#### 从多个属性构建值对象\r\n\r\n有时你的访问器可能需要将多个模型属性转换为单个「值对象」。 为此，你的 `get` 闭包可以接受 `$attributes` 的第二个参数，该参数将自动提供给闭包，并将包含模型所有当前属性的数组：\r\n\r\n```php\r\nuse App\\Support\\Address;\r\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n\r\n/**\r\n * 与用户地址交互。\r\n */\r\nprotected function address(): Attribute\r\n{\r\n    return Attribute::make(\r\n        get: fn (mixed $value, array $attributes) => new Address(\r\n            $attributes['address_line_one'],\r\n            $attributes['address_line_two'],\r\n        ),\r\n    );\r\n}\r\n```\r\n\r\n<a name=\"accessor-caching\"></a>\r\n#### 访问器缓存\r\n\r\n从访问器返回值对象时，对值对象所做的任何更改都将在模型保存之前自动同步回模型。 这是可能的，因为 Eloquent 保留了访问器返回的实例，因此每次调用访问器时都可以返回相同的实例：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->address->lineOne = 'Updated Address Line 1 Value';\r\n    $user->address->lineTwo = 'Updated Address Line 2 Value';\r\n\r\n    $user->save();\r\n\r\n\r\n\r\n有时你可能希望为字符串和布尔值等原始值启用缓存，特别是当它们是计算密集型时。要实现这一点，你可以在定义访问器时调用 `shouldCache` 方法：\r\n\r\n```php\r\nprotected function hash(): Attribute\r\n{\r\n    return Attribute::make(\r\n        get: fn (string $value) => bcrypt(gzuncompress($value)),\r\n    )->shouldCache();\r\n}\r\n```\r\n\r\n如果要禁用属性的缓存，可以在定义属性时调用 `withoutObjectCaching` 方法：\r\n\r\n```php\r\n/**\r\n * 与 user 的 address 交互。\r\n */\r\nprotected function address(): Attribute\r\n{\r\n    return Attribute::make(\r\n        get: fn (mixed $value, array $attributes) => new Address(\r\n            $attributes['address_line_one'],\r\n            $attributes['address_line_two'],\r\n        ),\r\n    )->withoutObjectCaching();\r\n}\r\n```\r\n\r\n<a name=\"defining-a-mutator\"></a>\r\n### 定义修改器\r\n\r\n修改器会在设置属性时生效。要定义修改器，可以在定义属性时提供 `set` 参数。让我们为 `first_name` 属性定义一个修改器。这个修改器将会在我们修改 `first_name` 属性的值时自动调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 与 user 的 first name 交互。\r\n         */\r\n        protected function firstName(): Attribute\r\n        {\r\n            return Attribute::make(\r\n                get: fn (string $value) => ucfirst($value),\r\n                set: fn (string $value) => strtolower($value),\r\n            );\r\n        }\r\n    }\r\n\r\n修改器的闭包会接收将要设置的值，并允许我们使用和返回该值。要使该修改器生效，只需在模型上设置 `first_name` 即可：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->first_name = 'Sally';\r\n\r\n\r\n\r\n在本例中，值 `Sally` 将会触发 `set` 回调。然后，修改器会使用 `strtolower` 函数处理姓名，并将结果值设置在模型的 `$attributes` 数组中。\r\n\r\n<a name=\"mutating-multiple-attributes\"></a>\r\n#### 修改多个属性\r\n\r\n有时你的修改器可能需要修改底层模型的多个属性。 为此，你的 `set` 闭包可以返回一个数组，数组中的每个键都应该与模型的属性 / 数据库列相对应：\r\n\r\n```php\r\nuse App\\Support\\Address;\r\nuse Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n\r\n/**\r\n * 与user模型的address交互。\r\n */\r\nprotected function address(): Attribute\r\n{\r\n    return Attribute::make(\r\n        get: fn (mixed $value, array $attributes) => new Address(\r\n            $attributes['address_line_one'],\r\n            $attributes['address_line_two'],\r\n        ),\r\n        set: fn (Address $value) => [\r\n            'address_line_one' => $value->lineOne,\r\n            'address_line_two' => $value->lineTwo,\r\n        ],\r\n    );\r\n}\r\n```\r\n\r\n<a name=\"attribute-casting\"></a>\r\n## 属性转换\r\n\r\n属性转换提供了类似于访问器和修改器的功能，且无需在模型上定义任何其他方法。模型中的 `$casts` 属性提供了一个便利的方法来将属性转换为常见的数据类型。\r\n\r\n`$casts` 属性应是一个数组，且数组的键是那些需要被转换的属性名称，值则是你希望转换的数据类型。支持转换的数据类型有：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `array`\r\n- `AsStringable::class`\r\n- `boolean`\r\n- `collection`\r\n- `date`\r\n- `datetime`\r\n- `immutable_date`\r\n- `immutable_datetime`\r\n- <code>decimal:&lt;precision&gt;</code>\r\n- `double`\r\n- `encrypted`\r\n- `encrypted:array`\r\n- `encrypted:collection`\r\n- `encrypted:object`\r\n- `float`\r\n- `integer`\r\n- `object`\r\n- `real`\r\n- `string`\r\n- `timestamp`\r\n\r\n</div>\r\n\r\n\r\n\r\n示例， 让我们把以整数（`0` 或 `1`）形式存储在数据库中的 `is_admin`  属性转成布尔值：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 类型转换。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $casts = [\r\n            'is_admin' => 'boolean',\r\n        ];\r\n    }\r\n\r\n现在当你访问 `is_admin` 属性时，虽然保存在数据库里的值是一个整数类型，但是返回值总是会被转换成布尔值类型：\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    if ($user->is_admin) {\r\n        // ...\r\n    }\r\n\r\n如果需要在运行时添加新的临时强制转换，可以使用 `mergeCasts` 这些强制转换定义将添加到模型上已定义的任何强制转换中：\r\n\r\n    $user->mergeCasts([\r\n        'is_admin' => 'integer',\r\n        'options' => 'object',\r\n    ]);\r\n\r\n> **注意**： 值属性将不会被转换。此外，禁止定义与关联同名的类型转换（或属性）。\r\n\r\n<a name=\"stringable-casting\"></a>\r\n#### 强制转换\r\n\r\n你可以用 `Illuminate\\Database\\Eloquent\\Casts\\AsStringable` 类将模型属性强制转换为 [ `Illuminate\\Support\\Stringable` 对象](/docs/laravel/10.x/helpersmd#fluent-strings-method-list):\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\AsStringable;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 类型转换。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $casts = [\r\n            'directory' => AsStringable::class,\r\n        ];\r\n    }\r\n\r\n<a name=\"array-and-json-casting\"></a>\r\n### 数组 & JSON 转换\r\n\r\n当你在数据库存储序列化的 `JSON` 的数据时， `array` 类型的转换非常有用。比如：如果你的数据库具有被序列化为 JSON 的 `JSON` 或 `TEXT` 字段类型，并且在 Eloquent 模型中加入了 `array` 类型转换，那么当你访问的时候就会自动被转换为 PHP 数组：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 类型转换。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $casts = [\r\n            'options' => 'array',\r\n        ];\r\n    }\r\n\r\n\r\n\r\n一旦定义了转换，你访问 `options` 属性时他会自动从 JSON 类型反序列化为 PHP 数组。当你设置了 `options` 属性的值时，给定的数组也会自动序列化为 JSON 类型存储：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $options = $user->options;\r\n\r\n    $options['key'] = 'value';\r\n\r\n    $user->options = $options;\r\n\r\n    $user->save();\r\n\r\n当使用 `update` 方法更新 JSON 属性的单个字段时，可以使用 `->` 操作符让语法更加简洁：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->update(['options->key' => 'value']);\r\n\r\n<a name=\"array-object-and-collection-casting\"></a>\r\n#### 数组对象 & 集合类型转换\r\n\r\n虽然标准的 `array` 类型转换对于许多应用程序来说已经足够了，但它确实有一些缺点。由于 `array` 类型转换返回一个基础类型，因此不可能直接改变数组键的值。例如，以下代码将触发一个 PHP 错误：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->options['key'] = $value;\r\n\r\n为了解决这个问题，Laravel 提供了一个 `AsArrayObject` 类型转换，它将 JSON 属性转换为一个 [数组对象](https://www.php.net/manual/en/class.arrayobject.php) 类。这个特性是使用 Laravel 的 [自定义类型转换](#custom-casts) 实现的，它允许 Laravel 智能地缓存和转换修改的对象，这样可以在不触发 PHP 错误的情况下修改各个键的值。要使用 `AsArrayObject` 类型转换，只需将其指定给一个属性即可：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\AsArrayObject;\r\n\r\n    /**\r\n     * 类型转换。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'options' => AsArrayObject::class,\r\n    ];\r\n\r\n类似的，Laravel 提供了一个 `AsCollection` 类型转换，它将 JSON 属性转换为 Laravel [集合](/docs/laravel/10.x/collections) 实例：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\AsCollection;\r\n\r\n    /**\r\n     * 类型转换。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'options' => AsCollection::class,\r\n    ];\r\n\r\n\r\n\r\n<a name=\"date-casting\"></a>\r\n### Date 转换\r\n\r\n默认情况下，Eloquent 会将 `created_at` 和 `updated_at` 字段转换为 [Carbon](https://github.com/briannesbitt/Carbon) 实例，它继承了 PHP 原生的 `DateTime` 类并提供了各种有用的方法。你可以通过在模型的 `$casts` 属性数组中定义额外的日期类型转换，用来转换其他的日期属性。通常来说，日期应该使用 `datetime` 或 `immutable_datetime` 类型转换来转换。\r\n\r\n当使用 `date` 或 `datetime` 类型转换时，你也可以指定日期的格式。这种格式会被用在 [模型序列化为数组或者 JSON](/docs/laravel/10.x/eloquent-serialization)：\r\n\r\n    /**\r\n     * 类型转换。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'created_at' => 'datetime:Y-m-d',\r\n    ];\r\n\r\n将列类型转换为日期时，可以将其值设置为 UNIX 时间戳、日期字符串（`Y-m-d`）、日期时间字符串或 `DateTime` / `Carbon` 实例。日期值将会被准确的转换并存储在数据库中。\r\n\r\n通过在模型中定义 `serializeDate` 方法，你可以自定义所有模型日期的默认序列化格式。此方法不会影响日期在数据库中存储的格式：\r\n\r\n    /**\r\n     * 为 array / JSON 序列化准备日期格式。\r\n     */\r\n    protected function serializeDate(DateTimeInterface $date): string\r\n    {\r\n        return $date->format('Y-m-d');\r\n    }\r\n\r\n在模型上定义 `$dateFormat` 属性后，模型的日期将会以你指定的格式实际存储于数据库中：\r\n\r\n    /**\r\n     * 模型日期列的存储格式。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $dateFormat = 'U';\r\n\r\n<a name=\"date-casting-and-timezones\"></a>\r\n\r\n\r\n#### 日期转换，序列化，& 时区\r\n\r\n默认情况下，`date` 和 `datetime` 会序列化为 UTC ISO-8601 格式的（ `1986-05-28T21:05:54.000000Z` ）字符串，并不会受到应用的 `timezone` 配置影响。强烈建议您始终使用此序列化格式，并不更改应用程序的 `timezone` 配置（默认 `UTC` ）以将应用程序的日期存储在 UTC 时区中。在整个应用程序中始终使用 UTC 时区，会使与其他 PHP 和 JavaScript 类库的互操作性更高。\r\n\r\n如果对 `date` 或 `datetime` 属性自定义了格式，例如 `datetime:Y-m-d H:i​:s`，那么在日期序列化期间将使用 Carbon 实例的内部时区。通常，这是应用程序的 `timezone` 配置选项中指定的时区。\r\n\r\n<a name=\"enum-casting\"></a>\r\n### 枚举转换\r\n\r\nEloquent 还允许您将属性值强制转换为 PHP 的 [枚举](https://www.php.net/manual/en/language.enumerations.backed.php)。 为此，可以在模型的 `$casts` 数组属性中指定要转换的属性和枚举：\r\n\r\n    use App\\Enums\\ServerStatus;\r\n\r\n    /**\r\n     * 类型转换。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'status' => ServerStatus::class,\r\n    ];\r\n\r\n在模型上定义了转换后，与属性交互时，指定的属性都将在枚举中强制转换：\r\n\r\n    if ($server->status == ServerStatus::Provisioned) {\r\n        $server->status = ServerStatus::Ready;\r\n\r\n        $server->save();\r\n    }\r\n\r\n<a name=\"casting-arrays-of-enums\"></a>\r\n#### 转换枚举数组\r\n\r\n\r\n\r\n有时，你可能需要模型在单个列中存储枚举值的数组。为此，你可以使用 Laravel 提供的`AsEnumArrayObject`或`AsEnumCollection`强制转换：\r\n\r\n    use App\\Enums\\ServerStatus;\r\n    use Illuminate\\Database\\Eloquent\\Casts\\AsEnumCollection;\r\n\r\n    /**\r\n     * 类型转换。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'statuses' => AsEnumCollection::class.':'.ServerStatus::class,\r\n    ];\r\n\r\n<a name=\"encrypted-casting\"></a>\r\n### 加密转换\r\n\r\n`encrypted` 转换使用了 Laravel 的内置 [encryption](/docs/laravel/10.x/encryption) 功能加密模型的属性值。 此外，`encrypted:array`、`encrypted:collection`、`encrypted:object`、`AsEncryptedArrayObject` 和 `AsEncryptedCollection` 类型转换的工作方式与未加密的类型相同； 但是，正如您所料，底层值在存储在数据库中时是加密的。\r\n\r\n由于加密文本的最终长度不可预测并且比其纯文本长度要长，因此请确保关联的数据库列属性是 `TEXT` 类型或更大。此外，由于数据库中的值是加密的，您将无法查询或搜索加密的属性值。\r\n\r\n<a name=\"key-rotation\"></a>\r\n#### 密钥轮换\r\n\r\n如你所知，Laravel使用应用程序的 `app` 配置文件中指定的 `key` 配置值对字符串进行加密。通常，该值对应于 `APP_KEY` 环境变量的值。如果需要轮换应用程序的加密密钥，则需要使用新密钥手动重新加密加密属性。\r\n\r\n<a name=\"query-time-casting\"></a>\r\n### 查询时转换\r\n\r\n有时你可能需要在执行查询时应用强制转换，例如从表中选择原始值时。 例如，考虑以下查询：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    $users = User::select([\r\n        'users.*',\r\n        'last_posted_at' => Post::selectRaw('MAX(created_at)')\r\n                ->whereColumn('user_id', 'users.id')\r\n    ])->get();\r\n\r\n\r\n\r\n在该查询获取到的结果集中，`last_posted_at` 属性将会是一个字符串。假如我们在执行查询时进行 `datetime` 类型转换将更方便。你可以通过使用 `withCasts` 方法来完成上述操作：\r\n\r\n    $users = User::select([\r\n        'users.*',\r\n        'last_posted_at' => Post::selectRaw('MAX(created_at)')\r\n                ->whereColumn('user_id', 'users.id')\r\n    ])->withCasts([\r\n        'last_posted_at' => 'datetime'\r\n    ])->get();\r\n\r\n<a name=\"custom-casts\"></a>\r\n## 自定义类型转换\r\n\r\nLaravel 有多种内置的、有用的类型转换； 如果需要自定义强制转换类型。要创建一个类型转换，执行`make:cast`命令。 新的强制转换类将被放置在你的`app/Casts`目录中:\r\n\r\n```shell\r\nphp artisan make:cast Json\r\n```\r\n\r\n所有自定义强制转换类都实现了`CastsAttributes`接口。 实现这个接口的类必须定义一个 `get` 和 `set` 方法。`get`方法负责将数据库中的原始值转换为转换值，而 `set` 方法应将转换值转换为可以存储在数据库中的原始值。 作为示例，我们将内置的 `json` 类型转换重新实现为自定义类型：\r\n\r\n    <?php\r\n\r\n    namespace App\\Casts;\r\n\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Json implements CastsAttributes\r\n    {\r\n        /**\r\n         * 将取出的数据进行转换。\r\n         *\r\n         * @param  array<string, mixed>  $attributes\r\n         * @return array<string, mixed>\r\n         */\r\n        public function get(Model $model, string $key, mixed $value, array $attributes): array\r\n        {\r\n            return json_decode($value, true);\r\n        }\r\n\r\n        /**\r\n         * 转换成将要进行存储的值。\r\n         *\r\n         * @param  array<string, mixed>  $attributes\r\n         */\r\n        public function set(Model $model, string $key, mixed $value, array $attributes): string\r\n        {\r\n            return json_encode($value);\r\n        }\r\n    }\r\n\r\n\r\n\r\n定义好自定义类型转换后，可以使用其类名称将其附加到模型属性里：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use App\\Casts\\Json;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 应被强制转换的属性。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $casts = [\r\n            'options' => Json::class,\r\n        ];\r\n    }\r\n\r\n<a name=\"value-object-casting\"></a>\r\n### 值对象转换\r\n\r\n你不仅可以将数据转换成原生的数据类型，还可以将数据转换成对象。两种自定义类型转换的定义方式非常类似。但是将数据转换成对象的自定义转换类中的 `set` 方法需要返回键值对数组，用于设置原始、可存储的值到对应的模型中。\r\n\r\n例如，我们将定义一个自定义转换类，将多个模型值转换为单个`Address`值对象。 我们将假设 `Address` 值有两个公共属性：`lineOne` 和 `lineTwo`：\r\n\r\n    <?php\r\n\r\n    namespace App\\Casts;\r\n\r\n    use App\\ValueObjects\\Address as AddressValueObject;\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use InvalidArgumentException;\r\n\r\n    class Address implements CastsAttributes\r\n    {\r\n        /**\r\n         * 转换给定的值。\r\n         *\r\n         * @param  array<string, mixed>  $attributes\r\n         */\r\n        public function get(Model $model, string $key, mixed $value, array $attributes): AddressValueObject\r\n        {\r\n            return new AddressValueObject(\r\n                $attributes['address_line_one'],\r\n                $attributes['address_line_two']\r\n            );\r\n        }\r\n\r\n        /**\r\n         * 准备给定值以进行存储。\r\n         *\r\n         * @param  array<string, mixed>  $attributes\r\n         * @return array<string, string>\r\n         */\r\n        public function set(Model $model, string $key, mixed $value, array $attributes): array\r\n        {\r\n            if (! $value instanceof AddressValueObject) {\r\n                throw new InvalidArgumentException('The given value is not an Address instance.');\r\n            }\r\n\r\n            return [\r\n                'address_line_one' => $value->lineOne,\r\n                'address_line_two' => $value->lineTwo,\r\n            ];\r\n        }\r\n    }\r\n\r\n\r\n\r\n转换为值对象时，对值对象所做的任何更改都将在模型保存之前自动同步回模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->address->lineOne = 'Updated Address Value';\r\n\r\n    $user->save();\r\n\r\n> 注意：如果你计划将包含值对象的 Eloquent 模型序列化为 JSON 或数组，那么应该在值对象上实现 `Illuminate\\Contracts\\Support\\Arrayable` 和 `JsonSerializable` 接口。\r\n\r\n<a name=\"array-json-serialization\"></a>\r\n### 数组 / JSON 序列化\r\n\r\n当使用 `toArray` 和 `toJson` 方法将 Eloquent 模型转换为数组或 JSON 时，自定义转换值对象通常会被序列化，只要它们实现 `Illuminate\\Contracts\\Support\\Arrayable` 和 `JsonSerializable` 接口。 但是，在使用第三方库提供的值对象时，你可能无法将这些接口添加到对象中。\r\n\r\n因此，你可以指定你自定义的类型转换类，它将负责序列化成值对象。为此，你自定义的类型转换类需要实现 `Illuminate\\Contracts\\Database\\Eloquent\\SerializesCastableAttributes` 接口。此接口声明类应包含 `serialize` 方法，该方法应返回值对象的序列化形式：\r\n\r\n    /**\r\n     * 获取值的序列化表示形式。\r\n     *\r\n     * @param  array<string, mixed>  $attributes\r\n     */\r\n    public function serialize(Model $model, string $key, mixed $value, array $attributes): string\r\n    {\r\n        return (string) $value;\r\n    }\r\n\r\n<a name=\"inbound-casting\"></a>\r\n### 入站转换\r\n\r\n有时候，你可能只需要对写入模型的属性值进行类型转换而不需要对从模型中获取的属性值进行任何处理。\r\n\r\n\r\n入站自定义强制转换应该实现`CastsInboundAttributes`接口，该接口只需要定义一个`set`方法。`make:cast`Artisan 命令可以通过`——inbound`选项调用来生成一个入站强制转换类:\r\n\r\n```shell\r\nphp artisan make:cast Hash --inbound\r\n```\r\n\r\n仅入站强制转换的一个经典示例是「hashing」强制转换。例如，我们可以定义一个类型转换，通过给定的算法散列入站值:\r\n\r\n    <?php\r\n\r\n    namespace App\\Casts;\r\n\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\CastsInboundAttributes;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Hash implements CastsInboundAttributes\r\n    {\r\n        /**\r\n         * 创建一个新的强制转换类实例。\r\n         */\r\n        public function __construct(\r\n            protected string $algorithm = null,\r\n        ) {}\r\n\r\n        /**\r\n         * 转换成将要进行存储的值\r\n         *\r\n         * @param  array<string, mixed>  $attributes\r\n         */\r\n        public function set(Model $model, string $key, mixed $value, array $attributes): string\r\n        {\r\n            return is_null($this->algorithm)\r\n                        ? bcrypt($value)\r\n                        : hash($this->algorithm, $value);\r\n        }\r\n    }\r\n\r\n<a name=\"cast-parameters\"></a>\r\n### 转换参数\r\n\r\n当将自定义类型转换附加到模型时，可以指定传入的类型转换参数。传入类型转换参数需使用 `:` 将参数与类名分隔，多个参数之间使用逗号分隔。这些参数将会传递到类型转换类的构造函数中：\r\n\r\n    /**\r\n     * 应该强制转换的属性。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $casts = [\r\n        'secret' => Hash::class.':sha256',\r\n    ];\r\n\r\n<a name=\"castables\"></a>\r\n### 可转换\r\n\r\n如果要允许应用程序对象的值定义它们自定义转换类。除了将自定义转换类附加到你的模型之外，还可以附加一个实现 `Illuminate\\Contracts\\Database\\Eloquent\\Castable` 接口的值对象类：\r\n\r\n    use App\\Models\\Address;\r\n\r\n    protected $casts = [\r\n        'address' => Address::class,\r\n    ];\r\n\r\n\r\n\r\n实现 `Castable` 接口的对象必须定义一个 `castUsing` 方法，此方法返回的是负责将 `Castable` 类进行自定义转换的转换器类名：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\Castable;\r\n    use App\\Casts\\Address as AddressCast;\r\n\r\n    class Address implements Castable\r\n    {\r\n        /**\r\n         * 获取转换器的类名用以转换当前类型转换对象。\r\n         *\r\n         * @param  array<string, mixed>  $arguments\r\n         */\r\n        public static function castUsing(array $arguments): string\r\n        {\r\n            return AddressCast::class;\r\n        }\r\n    }\r\n\r\n使用 `Castable` 类时，仍然可以在 `$casts` 定义中提供参数。参数将传递给 `castUsing` 方法：\r\n\r\n    use App\\Models\\Address;\r\n\r\n    protected $casts = [\r\n        'address' => Address::class.':argument',\r\n    ];\r\n\r\n<a name=\"anonymous-cast-classes\"></a>\r\n#### 可转换 & 匿名类型转换类\r\n\r\n通过将 `castables` 与 PHP 的 [匿名类](https://www.php.net/manual/en/language.oop5.anonymous.php) 相结合，可以将值对象及其转换逻辑定义为单个可转换对象。为此，请从值对象的 `castUsing` 方法返回一个匿名类。匿名类应该实现 `CastsAttributes` 接口：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\Castable;\r\n    use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class Address implements Castable\r\n    {\r\n        // ...\r\n\r\n        /**\r\n         * 获取转换器类用以转换当前类型转换对象。\r\n         *\r\n         * @param  array<string, mixed>  $arguments\r\n         */\r\n        public static function castUsing(array $arguments): CastsAttributes\r\n        {\r\n            return new class implements CastsAttributes\r\n            {\r\n                public function get(Model $model, string $key, mixed $value, array $attributes): Address\r\n                {\r\n                    return new Address(\r\n                        $attributes['address_line_one'],\r\n                        $attributes['address_line_two']\r\n                    );\r\n                }\r\n\r\n                public function set(Model $model, string $key, mixed $value, array $attributes): array\r\n                {\r\n                    return [\r\n                        'address_line_one' => $value->lineOne,\r\n                        'address_line_two' => $value->lineTwo,\r\n                    ];\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n","p":"docs/eloquent-mutators.html"},{"t":"eloquent-resources (Eloquent: API Resources)","d":"# Eloquent: API Resources\r\n\r\n- [简介](#introduction)\r\n- [生成资源](#generating-resources)\r\n- [生成资源](#concept-overview)\r\n    - [资源集合](#resource-collections)\r\n- [编写资源](#writing-resources)\r\n    - [数据包裹](#data-wrapping)\r\n    - [分页](#pagination)\r\n    - [条件属性](#conditional-attributes)\r\n    - [条件关系](#conditional-relationships)\r\n    - [添加元数据](#adding-meta-data)\r\n- [资源响应](#resource-responses)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在构建 API 时，你往往需要一个转换层来联结你的 Eloquent 模型和实际返回给用户的 JSON 响应。比如，你可能希望显示部分用户属性而不是全部，或者你可能希望在模型的 JSON 中包括某些关系。Eloquent 的资源类能够让你以更直观简便的方式将模型和模型集合转化成 JSON。\r\n\r\n当然，你可以始终使用 Eloquent 模型或集合的 `toJson` 方法将其转换为 JSON ；但是，Eloquent 的资源提供了对模型及其关系的 JSON 序列化更加精细和更加健壮的控制。\r\n\r\n<a name=\"generating-resources\"></a>\r\n## 生成资源\r\n\r\n你可以使用 `make:resource` artisan 命令来生成一个资源类。默认情况下，资源将放在应用程序的 `app/Http/Resources` 目录下。资源继承自 `Illuminate\\Http\\Resources\\Json\\JsonResource` 类：\r\n\r\n```shell\r\nphp artisan make:resource UserResource\r\n```\r\n\r\n<a name=\"generating-resource-collections\"></a>\r\n#### 资源集合\r\n\r\n除了生成转换单个模型的资源之外，还可以生成负责转换模型集合的资源。这允许你的 JSON 包含与给定资源的整个集合相关的其他信息。\r\n\r\n\r\n\r\n你应该在创建资源集合时使用 `--collection` 标志来表明你要生成一个资源集合。或者，在资源名称中包含 Collection 一词将向 Laravel 表明它应该生成一个资源集合。资源集合继承自 `Illuminate\\Http\\Resources\\Json\\ResourceCollection` 类：\r\n\r\n```shell\r\nphp artisan make:resource User --collection\r\n\r\nphp artisan make:resource UserCollection\r\n```\r\n\r\n<a name=\"concept-overview\"></a>\r\n## 概念综述\r\n\r\n> **提示**  \r\n> 提示：这是对资源和资源集合的高度概述。强烈建议您阅读本文档的其他部分，以深入了解如何更好地自定义和使用资源。\r\n\r\n在深入了解如何定制化编写你的资源之前，让我们首先从高层次上了解 Laravel 中如何使用资源。一个资源类表示一个单一模型需要被转换成 JSON 格式。例如，下面是一个简单的 `UserResource` 资源类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 将资源转换为数组。\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function toArray(Request $request): array\r\n        {\r\n            return [\r\n                'id' => $this->id,\r\n                'name' => $this->name,\r\n                'email' => $this->email,\r\n                'created_at' => $this->created_at,\r\n                'updated_at' => $this->updated_at,\r\n            ];\r\n        }\r\n    }\r\n\r\n每个资源类都定义了一个 `toArray` 方法，当资源从路由或控制器方法作为响应被调用返回时，该方法返回应该转换为 JSON 的属性数组。\r\n\r\n注意，我们可以直接使用 `$this` 变量访问模型属性。这是因为资源类将自动代理属性和方法访问到底层模型以方便访问。一旦定义了资源，你可以从路由或控制器中调用并返回它。资源通过其构造函数接受底层模型实例：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{id}', function (string $id) {\r\n        return new UserResource(User::findOrFail($id));\r\n    });\r\n\r\n\r\n\r\n<a name=\"resource-collections\"></a>\r\n### 资源集合\r\n\r\n如果你要返回一个资源集合或一个分页响应，你应该在路由或控制器中创建资源实例时使用你的资源类提供的 `collection` 方法：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return UserResource::collection(User::all());\r\n    });\r\n\r\n当然了，使用如上方法你将不能添加任何附加的元数据和集合一起返回。如果你需要自定义资源集合响应，你需要创建一个专用的资源来表示集合：\r\n\r\n```shell\r\nphp artisan make:resource UserCollection\r\n```\r\n\r\n此时，你就可以轻松地自定义响应中应该包含的任何元数据：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * 将资源集合转换为数组。\r\n         *\r\n         * @return array<int|string, mixed>\r\n         */\r\n        public function toArray(Request $request): array\r\n        {\r\n            return [\r\n                'data' => $this->collection,\r\n                'links' => [\r\n                    'self' => 'link-value',\r\n                ],\r\n            ];\r\n        }\r\n    }\r\n\r\n你可以在路由或者控制器中返回已定义的资源集合：\r\n\r\n    use App\\Http\\Resources\\UserCollection;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return new UserCollection(User::all());\r\n    });\r\n\r\n<a name=\"preserving-collection-keys\"></a>\r\n#### 保护集合的键\r\n\r\n当从路由返回一个资源集合时，Laravel 会重置集合的键，使它们按数字顺序排列。但是，你可以在资源类中添加 `preserveKeys` 属性，以指示是否应该保留集合的原始键：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 指示是否应保留资源的集合原始键。\r\n         *\r\n         * @var bool\r\n         */\r\n        public $preserveKeys = true;\r\n    }\r\n\r\n\r\n\r\n如果 `preserveKeys` 属性设置为 `true` ，那么从路由或控制器返回集合时，集合的键将会被保留：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return UserResource::collection(User::all()->keyBy->id);\r\n    });\r\n\r\n<a name=\"customizing-the-underlying-resource-class\"></a>\r\n#### 自定义基础资源类\r\n\r\n通常，资源集合的 `$this->collection` 属性会被自动填充，结果是将集合的每个项映射到其单个资源类。单个资源类被假定为资源的类名，但没有类名末尾的 `Collection` 部分。 此外，根据您的个人偏好，单个资源类可以带着后缀 `Resource` ，也可以不带。\r\n\r\n例如，`UserCollection` 会尝试将给定的用户实例映射到 `User` 或 `UserResource` 资源。想要自定义该行为，你可以重写资源集合中的 `$collects` 属性指定自定义的资源：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * 自定义资源类名。\r\n         *\r\n         * @var string\r\n         */\r\n        public $collects = Member::class;\r\n    }\r\n\r\n<a name=\"writing-resources\"></a>\r\n## 编写资源\r\n\r\n> **Note**  \r\n> 技巧：如果您还没有阅读 [概念综述](#concept-overview)，那么在继续阅读本文档前，强烈建议您去阅读一下，会更容易理解本节的内容。\r\n\r\n从本质上说，资源的作用很简单，它只需将一个给定的模型转换为一个数组。因此，每个资源都包含一个 `toArray` 方法，这个方法会将模型的属性转换为一个 API 友好的数组，然后将该数组通过路由或控制器返回给用户：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 将资源转换为数组。\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function toArray(Request $request): array\r\n        {\r\n            return [\r\n                'id' => $this->id,\r\n                'name' => $this->name,\r\n                'email' => $this->email,\r\n                'created_at' => $this->created_at,\r\n                'updated_at' => $this->updated_at,\r\n            ];\r\n        }\r\n    }\r\n\r\n\r\n\r\n一旦资源被定义，它可以直接从路由或控制器返回：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{id}', function (string $id) {\r\n        return new UserResource(User::findOrFail($id));\r\n    });\r\n\r\n<a name=\"relationships\"></a>\r\n#### 关联关系\r\n\r\n如果你想在你的响应中包含关联的资源，你可以将它们添加到你的资源的 `toArray` 方法返回的数组中。在下面的例子中，我们将使用 `PostResource` 资源的 `collection` 方法来将用户的博客文章添加到资源响应中：\r\n\r\n    use App\\Http\\Resources\\PostResource;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    /**\r\n     * 将资源转换为数组。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            'posts' => PostResource::collection($this->posts),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n> 注意：如果你只希望在已经加载的关联关系中包含它们，点这里查看 [条件关联](#conditional-relationships)。\r\n\r\n<a name=\"writing-resource-collections\"></a>\r\n#### 资源集合\r\n\r\n当资源将单个模型转换为数组时，资源集合将模型集合转换为数组。当然，你并不是必须要为每个类都定义一个资源集合类，因为所有的资源都提供了一个 `collection` 方法来动态地生成一个「临时」资源集合：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return UserResource::collection(User::all());\r\n    });\r\n\r\n当然，如果你需要自定义资源集合返回的元数据，那就需要自己创建资源集合类：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * 将资源集合转换为数组。\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function toArray(Request $request): array\r\n        {\r\n            return [\r\n                'data' => $this->collection,\r\n                'links' => [\r\n                    'self' => 'link-value',\r\n                ],\r\n            ];\r\n        }\r\n    }\r\n\r\n\r\n与单一资源一样，资源集合可以直接从路由或控制器返回:\r\n\r\n    use App\\Http\\Resources\\UserCollection;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return new UserCollection(User::all());\r\n    });\r\n\r\n<a name=\"data-wrapping\"></a>\r\n### 数据包裹\r\n\r\n默认情况下，当资源响应被转换为 JSON 时，最外层的资源被包裹在 `data` 键中。因此一个典型的资源收集响应如下所示:\r\n\r\n```json\r\n{\r\n    \"data\": [\r\n        {\r\n            \"id\": 1,\r\n            \"name\": \"Eladio Schroeder Sr.\",\r\n            \"email\": \"therese28@example.com\"\r\n        },\r\n        {\r\n            \"id\": 2,\r\n            \"name\": \"Liliana Mayert\",\r\n            \"email\": \"evandervort@example.com\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n如果你想使用自定义键而不是 `data`，你可以在资源类上定义一个 `$wrap` 属性:\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 应该应用的「数据」包装器。\r\n         *\r\n         * @var string|null\r\n         */\r\n        public static $wrap = 'user';\r\n    }\r\n\r\n如果你想禁用最外层资源的包裹，你应该调用基类 `Illuminate\\Http\\Resources\\Json\\JsonResource` 的 `withoutWrapping` 方法。通常，你应该从你的 `AppServiceProvider` 或其他在程序每一个请求中都会被加载的 [服务提供者](/docs/laravel/10.x/providers) 中调用这个方法:\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务。\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            JsonResource::withoutWrapping();\r\n        }\r\n    }\r\n\r\n> **注意**  \r\n> `withoutWrapping` 方法只会禁用最外层资源的包裹，不会删除你手动添加到资源集合中的 `data` 键。\r\n\r\n\r\n\r\n和单个资源一样，你可以在路由或控制器中直接返回资源集合：\r\n\r\n    use App\\Http\\Resources\\UserCollection;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return new UserCollection(User::all());\r\n    });\r\n\r\n<a name=\"data-wrapping\"></a>\r\n### 数据包裹\r\n\r\n默认情况下，当资源响应被转换为 JSON 时，最外层的资源被包裹在 `data` 键中。因此一个典型的资源收集响应如下所示：\r\n\r\n```json\r\n{\r\n    \"data\": [\r\n        {\r\n            \"id\": 1,\r\n            \"name\": \"Eladio Schroeder Sr.\",\r\n            \"email\": \"therese28@example.com\"\r\n        },\r\n        {\r\n            \"id\": 2,\r\n            \"name\": \"Liliana Mayert\",\r\n            \"email\": \"evandervort@example.com\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n如果你想使用自定义键而不是 `data`，你可以在资源类上定义一个 `$wrap` 属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 应该应用的「数据」包装器。\r\n         *\r\n         * @var string|null\r\n         */\r\n        public static $wrap = 'user';\r\n    }\r\n\r\n如果你想禁用最外层资源的包裹，你应该调用基类 `Illuminate\\Http\\Resources\\Json\\JsonResource` 的 `withoutWrapping` 方法。通常，你应该从你的 `AppServiceProvider` 或其他在程序每一个请求中都会被加载的 [服务提供者](/docs/laravel/10.x/providers) 中调用这个方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册任何应用程序服务。\r\n         */\r\n        public function register(): void\r\n        {\r\n            // ...\r\n        }\r\n\r\n        /**\r\n         * 引导任何应用程序服务。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            JsonResource::withoutWrapping();\r\n        }\r\n    }\r\n> **注意**\r\n>`withoutWrapping` 方法只会禁用最外层资源的包裹，不会删除你手动添加到资源集合中的 `data` 键。\r\n\r\n\r\n<a name=\"wrapping-nested-resources\"></a>\r\n#### 包裹嵌套资源\r\n\r\n你可以完全自由地决定资源关联如何被包裹。如果你希望无论怎样嵌套，所有的资源集合都包裹在一个 `data` 键中，你应该为每个资源定义一个资源集合类，并将返回的集合包裹在 `data` 键中。\r\n\r\n你可能会担心这是否会导致最外层的资源包裹在两层 `data` 键中。别担心， Laravel 永远不会让你的资源被双层包裹，所以你不必担心资源集合被多重嵌套的问题：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class CommentsCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * 将资源集合转换成数组。\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function toArray(Request $request): array\r\n        {\r\n            return ['data' => $this->collection];\r\n        }\r\n    }\r\n\r\n<a name=\"data-wrapping-and-pagination\"></a>\r\n#### 数据包裹和分页\r\n\r\n当通过资源响应返回分页集合时，即使你调用了 `withoutWrapping` 方法，Laravel 也会将你的资源数据包裹在 `data` 键中。这是因为分页响应总会有 `meta` 和 `links` 键包含关于分页状态的信息：\r\n\r\n```json\r\n{\r\n    \"data\": [\r\n        {\r\n            \"id\": 1,\r\n            \"name\": \"Eladio Schroeder Sr.\",\r\n            \"email\": \"therese28@example.com\"\r\n        },\r\n        {\r\n            \"id\": 2,\r\n            \"name\": \"Liliana Mayert\",\r\n            \"email\": \"evandervort@example.com\"\r\n        }\r\n    ],\r\n    \"links\":{\r\n        \"first\": \"http://example.com/pagination?page=1\",\r\n        \"last\": \"http://example.com/pagination?page=1\",\r\n        \"prev\": null,\r\n        \"next\": null\r\n    },\r\n    \"meta\":{\r\n        \"current_page\": 1,\r\n        \"from\": 1,\r\n        \"last_page\": 1,\r\n        \"path\": \"http://example.com/pagination\",\r\n        \"per_page\": 15,\r\n        \"to\": 10,\r\n        \"total\": 10\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"pagination\"></a>\r\n### 分页\r\n\r\n你可以将 Laravel 分页实例传递给资源的 `collection` 方法或自定义资源集合：\r\n\r\n    use App\\Http\\Resources\\UserCollection;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/users', function () {\r\n        return new UserCollection(User::paginate());\r\n    });\r\n\r\n\r\n分页响应中总有 `meta` 和 `links` 键包含着分页状态信息：\r\n\r\n```json\r\n{\r\n    \"data\": [\r\n        {\r\n            \"id\": 1,\r\n            \"name\": \"Eladio Schroeder Sr.\",\r\n            \"email\": \"therese28@example.com\"\r\n        },\r\n        {\r\n            \"id\": 2,\r\n            \"name\": \"Liliana Mayert\",\r\n            \"email\": \"evandervort@example.com\"\r\n        }\r\n    ],\r\n    \"links\":{\r\n        \"first\": \"http://example.com/pagination?page=1\",\r\n        \"last\": \"http://example.com/pagination?page=1\",\r\n        \"prev\": null,\r\n        \"next\": null\r\n    },\r\n    \"meta\":{\r\n        \"current_page\": 1,\r\n        \"from\": 1,\r\n        \"last_page\": 1,\r\n        \"path\": \"http://example.com/pagination\",\r\n        \"per_page\": 15,\r\n        \"to\": 10,\r\n        \"total\": 10\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"conditional-attributes\"></a>\r\n### 条件属性\r\n\r\n有些时候，你可能希望在给定条件满足时添加属性到资源响应里。例如，你可能希望如果当前用户是「管理员」时添加某个值到资源响应中。在这种情况下 Laravel 提供了一些辅助方法来帮助你解决问题。`when` 方法可以被用来有条件地向资源响应添加属性：\r\n\r\n    /**\r\n     * 将资源转换成数组。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            'secret' => $this->when($request->user()->isAdmin(), 'secret-value'),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n在上面这个例子中，只有当 `isAdmin` 方法返回 `true` 时，`secret` 键才会最终在资源响应中被返回。如果该方法返回 `false` 键将会在资源响应被发送给客户端之前被删除。 `when` 方法可以使你避免使用条件语句拼接数组，转而用更优雅的方式来编写你的资源。\r\n\r\n`when` 方法也接受闭包作为其第二个参数，只有在给定条件为 `true` 时，才从闭包中计算返回的值：\r\n\r\n    'secret' => $this->when($request->user()->isAdmin(), function () {\r\n        return 'secret-value';\r\n    }),\r\n\r\n\r\n `whenHas` 方法可以用来包含一个属性，如果它确实存在于底层模型中：\r\n\r\n    'name' => $this->whenHas('name'),\r\n\r\n此外， `whenNotNull` 方法可用于在资源响应中包含一个属性，如果该属性不为空：\r\n\r\n    'name' => $this->whenNotNull($this->name),\r\n\r\n<a name=\"merging-conditional-attributes\"></a>\r\n#### 有条件地合并数据\r\n\r\n有些时候，你可能希望在给定条件满足时添加多个属性到资源响应里。在这种情况下，你可以使用 `mergeWhen` 方法在给定的条件为 `true` 时将多个属性添加到响应中：\r\n\r\n    /**\r\n     * 将资源转换成数组\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            $this->mergeWhen($request->user()->isAdmin(), [\r\n                'first-secret' => 'value',\r\n                'second-secret' => 'value',\r\n            ]),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n同理，如果给定的条件为 `false` 时，则这些属性将会在资源响应被发送给客户端之前被移除。\r\n\r\n> **注意**  \r\n>  `mergeWhen` 方法不应该被使用在混合字符串和数字键的数组中。此外，它也不应该被使用在不按顺序排列的数字键的数组中。\r\n\r\n<a name=\"conditional-relationships\"></a>\r\n### 条件关联\r\n\r\n除了有条件地加载属性之外，你还可以根据模型关联是否已加载来有条件地在你的资源响应中包含关联。这允许你在控制器中决定加载哪些模型关联，这样你的资源可以在模型关联被加载后才添加它们。最终，这样做可以使你的资源轻松避免「N+1」查询问题。\r\n\r\n\r\n\r\n如果属性确实存在于模型中，可以用`whenHas`来获取：\r\n\r\n    'name' => $this->whenHas('name'),\r\n\r\n此外，`whenNotNull`可用于在资源响应中获取一个不为空的属性：\r\n\r\n    'name' => $this->whenNotNull($this->name),\r\n\r\n<a name=\"merging-conditional-attributes\"></a>\r\n#### 有条件地合并数据\r\n\r\n有些时候，你可能希望在给定条件满足时添加多个属性到资源响应里。在这种情况下，你可以使用 `mergeWhen` 方法在给定的条件为 `true` 时将多个属性添加到响应中：\r\n\r\n    /**\r\n     * 将资源转换成数组。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            $this->mergeWhen($request->user()->isAdmin(), [\r\n                'first-secret' => 'value',\r\n                'second-secret' => 'value',\r\n            ]),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n同理，如果给定的条件为 `false` 时，则这些属性将会在资源响应被发送给客户端之前被移除。\r\n\r\n> **注意**\r\n>`mergeWhen` 方法不应该被使用在混合字符串和数字键的数组中。此外，它也不应该被使用在不按顺序排列的数字键的数组中。\r\n\r\n<a name=\"conditional-relationships\"></a>\r\n### 条件关联\r\n\r\n除了有条件地加载属性之外，你还可以根据模型关联是否已加载来有条件地在你的资源响应中包含关联。这允许你在控制器中决定加载哪些模型关联，这样你的资源可以在模型关联被加载后才添加它们。最终，这样做可以使你的资源轻松避免「N+1」查询问题。\r\n\r\n\r\n可以使用`whenLoaded`方法来有条件的加载关联。为了避免加载不必要的关联，此方法接受关联的名称而不是关联本身作为其参数：\r\n\r\n    use App\\Http\\Resources\\PostResource;\r\n\r\n    /**\r\n     * 将资源转换成数组。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            'posts' => PostResource::collection($this->whenLoaded('posts')),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n在上面这个例子中，如果关联没有被加载，则`posts`键将会在资源响应被发送给客户端之前被删除。\r\n\r\n<a name=\"conditional-relationship-counts\"></a>\r\n#### 条件关系计数\r\n\r\n除了有条件地包含关系之外，你还可以根据关系的计数是否已加载到模型上，有条件地包含资源响应中的关系「计数」:\r\n\r\n    new UserResource($user->loadCount('posts'));\r\n\r\n`whenCounted`方法可用于在资源响应中有条件地包含关系的计数。该方法避免在关系计数不存在时不必要地包含属性:\r\n\r\n    /**\r\n     * 将资源转换为一个数组。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'email' => $this->email,\r\n            'posts_count' => $this->whenCounted('posts'),\r\n            'created_at' => $this->created_at,\r\n            'updated_at' => $this->updated_at,\r\n        ];\r\n    }\r\n\r\n在这个例子中，如果`posts`关系的计数还没有加载，`posts_count`键将在资源响应发送到客户端之前从资源响应中删除。\r\n\r\n<a name=\"conditional-pivot-information\"></a>\r\n#### 条件中间表信息\r\n\r\n\r\n\r\n除了在你的资源响应中有条件地包含关联外，你还可以使用 `whenPivotLoaded` 方法有条件地从多对多关联的中间表中添加数据。`whenPivotLoaded` 方法接受的第一个参数为中间表的名称。第二个参数是一个闭包，它定义了在模型上如果中间表信息可用时要返回的值：\r\n\r\n    /**\r\n     * 将资源转换成数组。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'expires_at' => $this->whenPivotLoaded('role_user', function () {\r\n                return $this->pivot->expires_at;\r\n            }),\r\n        ];\r\n    }\r\n\r\n如果你的关联使用的是 [自定义中间表](/docs/laravel/10.x/eloquent-relationships#defining-custom-intermediate-table-models)，你可以将中间表模型的实例作为 `whenPivotLoaded` 方法的第一个参数:\r\n\r\n    'expires_at' => $this->whenPivotLoaded(new Membership, function () {\r\n        return $this->pivot->expires_at;\r\n    }),\r\n\r\n如果你的中间表使用的是 `pivot` 以外的访问器，你可以使用 `whenPivotLoadedAs` 方法：\r\n\r\n    /**\r\n     * 将资源转换成数组。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'id' => $this->id,\r\n            'name' => $this->name,\r\n            'expires_at' => $this->whenPivotLoadedAs('subscription', 'role_user', function () {\r\n                return $this->subscription->expires_at;\r\n            }),\r\n        ];\r\n    }\r\n\r\n<a name=\"adding-meta-data\"></a>\r\n### 添加元数据\r\n\r\n一些 JSON API 标准需要你在资源和资源集合响应中添加元数据。这通常包括资源或相关资源的 `links` ，或一些关于资源本身的元数据。如果你需要返回有关资源的其他元数据，只需要将它们包含在 `toArray` 方法中即可。例如在转换资源集合时你可能需要添加 `link` 信息：\r\n\r\n    /**\r\n     * 将资源转换成数组。\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function toArray(Request $request): array\r\n    {\r\n        return [\r\n            'data' => $this->collection,\r\n            'links' => [\r\n                'self' => 'link-value',\r\n            ],\r\n        ];\r\n    }\r\n\r\n\r\n当添加额外的元数据到你的资源中时，你不必担心会覆盖 Laravel 在返回分页响应时自动添加的 `links` 或 `meta` 键。你添加的任何其他 `links` 会与分页响应添加的 `links` 相合并。\r\n\r\n<a name=\"top-level-meta-data\"></a>\r\n#### 顶层元数据\r\n\r\n有时候，你可能希望当资源被作为顶层资源返回时添加某些元数据到资源响应中。这通常包括整个响应的元信息。你可以在资源类中添加 `with` 方法来定义元数据。此方法应返回一个元数据数组，当资源被作为顶层资源渲染时，这个数组将会被包含在资源响应中：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\Resources\\Json\\ResourceCollection;\r\n\r\n    class UserCollection extends ResourceCollection\r\n    {\r\n        /**\r\n         * 将资源集合转换成数组。\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function toArray(Request $request): array\r\n        {\r\n            return parent::toArray($request);\r\n        }\r\n\r\n        /**\r\n         * 返回应该和资源一起返回的其他数据数组。\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function with(Request $request): array\r\n        {\r\n            return [\r\n                'meta' => [\r\n                    'key' => 'value',\r\n                ],\r\n            ];\r\n        }\r\n    }\r\n\r\n<a name=\"adding-meta-data-when-constructing-resources\"></a>\r\n#### 构造资源时添加元数据\r\n\r\n你还可以在路由或者控制器中构造资源实例时添加顶层数据。所有资源都可以使用 `additional` 方法来接受应该被添加到资源响应中的数据数组：\r\n\r\n    return (new UserCollection(User::all()->load('roles')))\r\n                    ->additional(['meta' => [\r\n                        'key' => 'value',\r\n                    ]]);\r\n\r\n<a name=\"resource-responses\"></a>\r\n\r\n\r\n## 响应资源\r\n\r\n就像你知道的那样，资源可以直接在路由和控制器中被返回：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user/{id}', function (string $id) {\r\n        return new UserResource(User::findOrFail($id));\r\n    });\r\n\r\n但有些时候，在发送给客户端前你可能需要自定义 HTTP 响应。你有两种办法。第一，你可以链式调用 `response` 方法。此方法将会返回 `Illuminate\\Http\\JsonResponse` 实例，允许你自定义响应头信息：\r\n\r\n    use App\\Http\\Resources\\UserResource;\r\n    use App\\Models\\User;\r\n\r\n    Route::get('/user', function () {\r\n        return (new UserResource(User::find(1)))\r\n                    ->response()\r\n                    ->header('X-Value', 'True');\r\n    });\r\n\r\n另外，你还可以在资源中定义一个 `withResponse` 方法。此方法将会在资源被作为顶层资源在响应时被调用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Resources;\r\n\r\n    use Illuminate\\Http\\JsonResponse;\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Http\\Resources\\Json\\JsonResource;\r\n\r\n    class UserResource extends JsonResource\r\n    {\r\n        /**\r\n         * 将资源转换为数组。\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function toArray(Request $request): array\r\n        {\r\n            return [\r\n                'id' => $this->id,\r\n            ];\r\n        }\r\n\r\n        /**\r\n         * 自定义响应信息。\r\n         */\r\n        public function withResponse(Request $request, JsonResponse $response): void\r\n        {\r\n            $response->header('X-Value', 'True');\r\n        }\r\n    }\r\n\r\n","p":"docs/eloquent-resources.html"},{"t":"eloquent-serialization (Eloquent: 序列化)","d":"# Eloquent: 序列化\r\n\r\n- [简介](#introduction)\r\n- [序列化模型 & 集合](#serializing-models-and-collections)\r\n    - [序列化为数组](#serializing-to-arrays)\r\n    - [序列化为 JSON](#serializing-to-json)\r\n- [隐藏 JSON 属性](#hiding-attributes-from-json)\r\n- [追加 JSON 值](#appending-values-to-json)\r\n- [序列化日期](#date-serialization)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n在使用 Laravel 构建 API 时，经常需要把模型和关联转化为数组或 JSON。针对这些操作，Eloquent 提供了一些便捷方法，以及对序列化中的属性控制。\r\n\r\n> 技巧：想获得更全面处理 Eloquent 的模型和集合 JSON 序列化的方法，请查看 [Eloquent API 资源](/docs/laravel/10.x/eloquent-resources) 文档。\r\n\r\n<a name=\"serializing-models-and-collections\"></a>\r\n## 序列化模型 & 集合\r\n\r\n<a name=\"serializing-to-arrays\"></a>\r\n### 序列化为数组\r\n\r\n要转化模型及其加载的 [关联](/docs/laravel/10.x/eloquent-relationships) 为数组，可以使用 `toArray` 方法。这是一个递归的方法，因此所有的属性和关联（包括关联的关联）都将转化成数组：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::with('roles')->first();\r\n\r\n    return $user->toArray();\r\n\r\n`attributesToArray` 方法可用于将模型的属性转换为数组，但不会转换其关联：\r\n\r\n    $user = User::first();\r\n\r\n    return $user->attributesToArray();\r\n\r\n您还可以通过调用集合实例上的 `toArray` 方法，将模型的全部 [集合](/docs/laravel/10.x/eloquent-collections) 转换为数组：\r\n\r\n    $users = User::all();\r\n\r\n    return $users->toArray();\r\n\r\n<a name=\"serializing-to-json\"></a>\r\n### 序列化为 JSON\r\n\r\n您可以使用 `toJson` 方法将模型转化成 JSON。和 `toArray` 一样，`toJson` 方法也是递归的，因此所有属性和关联都会转化成 JSON, 您还可以指定由 [PHP 支持](https://secure.php.net/manual/en/function.json-encode.php)的任何  JSON 编码选项：\r\n\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    return $user->toJson();\r\n\r\n    return $user->toJson(JSON_PRETTY_PRINT);\r\n\r\n\r\n\r\n或者，你也可以将模型或集合转换为字符串，模型或集合上的 `toJson` 方法会自动调用：\r\n\r\n    return (string) User::find(1);\r\n\r\n由于模型和集合在转化为字符串的时候会转成 JSON， 因此可以在应用的路由或控制器中直接返回 Eloquent 对象。Laravel 会自动将 Eloquent 模型和集合序列化为 JSON：\r\n\r\n    Route::get('users', function () {\r\n        return User::all();\r\n    });\r\n\r\n<a name=\"relationships\"></a>\r\n#### 关联关系\r\n\r\n当一个模型被转化为 JSON 的时候，它加载的关联关系也将自动转化为 JSON 对象被包含进来。同时，通过「小驼峰」定义的关联方法，关联的 JSON 属性将会是「蛇形」命名。\r\n\r\n<a name=\"hiding-attributes-from-json\"></a>\r\n## 隐藏 JSON 属性\r\n\r\n有时要将模型数组或 JSON 中的某些属性进行隐藏，比如密码。则可以在模型中添加 `$hidden` 属性。模型序列化后， `$hidden` 数组中列出的属性将不会被显示：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 数组中的属性会被隐藏。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $hidden = ['password'];\r\n    }\r\n\r\n> **注意**\r\n> 隐藏关联时，需添加关联的方法名到 `$hidden` 属性中。\r\n\r\n此外，也可以使用属性 `visible` 定义一个模型数组和 JSON 可见的「白名单」。转化后的数组或 JSON 不会出现其他的属性：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 数组中的属性会被展示。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $visible = ['first_name', 'last_name'];\r\n    }\r\n\r\n\r\n<a name=\"temporarily-modifying-attribute-visibility\"></a>\r\n#### 临时修改可见属性\r\n\r\n如果你想要在一个模型实例中显示隐藏的属性，可以使用 `makeVisible` 方法。`makeVisible` 方法返回模型实例：\r\n\r\n    return $user->makeVisible('attribute')->toArray();\r\n\r\n相应地，如果你想要在一个模型实例中隐藏可见的属性，可以使用 `makeHidden` 方法。\r\n\r\n    return $user->makeHidden('attribute')->toArray();\r\n\r\n如果你想临时覆盖所有可见或隐藏的属性，你可以分别使用`setVisible`和`setHidden`方法:\r\n\r\n    return $user->setVisible(['id', 'name'])->toArray();\r\n\r\n    return $user->setHidden(['email', 'password', 'remember_token'])->toArray();\r\n\r\n<a name=\"appending-values-to-json\"></a>\r\n## 追加 JSON 值\r\n\r\n有时，需要在模型转换为数组或 JSON 时添加一些数据库中不存在字段的对应属性。要实现这个功能，首先要定义一个 [访问器](/docs/laravel/10.x/eloquent-mutators)：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Casts\\Attribute;\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 判断用户是否是管理员。\r\n         */\r\n        protected function isAdmin(): Attribute\r\n        {\r\n            return new Attribute(\r\n                get: fn () => 'yes',\r\n            );\r\n        }\r\n    }\r\n\r\n如果你想附加属性到模型中，可以使用模型属性 `appends` 中添加该属性名。注意，尽管访问器使用「驼峰命名法」方式定义，但是属性名通常以「蛇形命名法」的方式来引用：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n    class User extends Model\r\n    {\r\n        /**\r\n         * 要附加到模型数组表单的访问器。\r\n         *\r\n         * @var array\r\n         */\r\n        protected $appends = ['is_admin'];\r\n    }\r\n\r\n\r\n使用 `appends` 方法追加属性后，它将包含在模型的数组和 JSON 中。`appends` 数组中的属性也将遵循模型上配置的 `visible` 和 `hidden` 设置。\r\n\r\n<a name=\"appending-at-run-time\"></a>\r\n#### 运行时追加\r\n\r\n在运行时，你可以在单个模型实例上使用 `append` 方法来追加属性。或者，使用 `setAppends` 方法来重写整个追加属性的数组：\r\n\r\n    return $user->append('is_admin')->toArray();\r\n\r\n    return $user->setAppends(['is_admin'])->toArray();\r\n\r\n<a name=\"date-serialization\"></a>\r\n## 日期序列化\r\n\r\n<a name=\"customizing-the-default-date-format\"></a>\r\n#### 自定义默认日期格式\r\n\r\n你可以通过重写 `serializeDate` 方法来自定义默认序列化格式。此方法不会影响日期在数据库中存储的格式：\r\n\r\n    /**\r\n     * 为 array / JSON 序列化准备日期格式\r\n     */\r\n    protected function serializeDate(DateTimeInterface $date): string\r\n    {\r\n        return $date->format('Y-m-d');\r\n    }\r\n\r\n<a name=\"customizing-the-default-date-format\"></a>\r\n#### 自定义默认日期格式\r\n\r\n你可以在 Eloquent 的 [属性转换](/docs/laravel/10.x/eloquent-mutators#attribute-casting) 中单独为日期属性自定义日期格式：\r\n\r\n    protected $casts = [\r\n        'birthday' => 'date:Y-m-d',\r\n        'joined_at' => 'datetime:Y-m-d H:00',\r\n    ];\r\n\r\n","p":"docs/eloquent-serialization.html"},{"t":"eloquent-factories (Eloquent：数据工厂)","d":"# Eloquent：数据工厂\r\n\r\n- [介绍](#introduction)\r\n- [定义模型工厂](#defining-model-factories)\r\n    - [生成工厂](#generating-factories)\r\n    - [工厂状态](#factory-states)\r\n    - [工厂回调](#factory-callbacks)\r\n- [使用工厂创建模型](#creating-models-using-factories)\r\n    - [实例化模型](#instantiating-models)\r\n    - [持久化模型](#persisting-models)\r\n    - [序列](#sequences)\r\n- [工厂关联](#factory-relationships)\r\n    - [一对多关系](#has-many-relationships)\r\n    - [属于关系](#belongs-to-relationships)\r\n    - [多对多关系](#many-to-many-relationships)\r\n    - [多态关系](#polymorphic-relationships)\r\n    - [在工厂中定义关系](#defining-relationships-within-factories)\r\n    - [重复利用现有的模型建立关系](#recycling-an-existing-model-for-relationships)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n当测试你的应用程序或向数据库填充数据时，你可能需要插入一些记录到数据库中。Laravel 允许你使用模型工厂为每个 [Eloquent 模型](/docs/laravel/10.x/eloquent)定义一组默认属性，而不是手动指定每个列的值。\r\n\r\n要查看如何编写工厂的示例，请查看你的应用程序中的 `database/factories/UserFactory.php` 文件。这个工厂已经包含在所有新的 Laravel 应用程序中，并包含以下工厂定义：\r\n\r\n    namespace Database\\Factories;\r\n\r\n    use Illuminate\\Support\\Str;\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\n\r\n    class UserFactory extends Factory\r\n    {\r\n        /**\r\n         * 定义模型的默认状态\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function definition(): array\r\n        {\r\n            return [\r\n                'name' => fake()->name(),\r\n                'email' => fake()->unique()->safeEmail(),\r\n                'email_verified_at' => now(),\r\n                'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password\r\n                'remember_token' => Str::random(10),\r\n            ];\r\n        }\r\n    }\r\n\r\n正如你所见，在其最基本的形式下，数据工厂是扩展 Laravel 基础工厂类并定义一个 `definition` 方法的类。`definition` 方法返回在使用工厂创建模型时应用的默认属性值集合。\r\n\r\n通过 `fake` 辅助器，工厂可以访问 [Faker](https://github.com/FakerPHP/Faker) PHP 库，它允许你方便地生成各种用于测试和填充的随机数据。\r\n\r\n> **注意**\r\n> 你可以通过在 `config/app.php` 配置文件中添加 `faker_locale` 选项来设置你应用程序的 Faker 区域设置。\r\n\r\n<a name=\"defining-model-factories\"></a>\r\n## 定义模型工厂\r\n\r\n<a name=\"generating-factories\"></a>\r\n### 创建工厂\r\n\r\n要创建工厂，请执行 `make:factory` [Artisan 命令](https://chat.openai.com/docs/laravel/10.x/artisan):\r\n\r\n```shell\r\nphp artisan make:factory PostFactory\r\n```\r\n\r\n新工厂类将被放置在你的 `database/factories` 目录中。\r\n\r\n<a name=\"factory-and-model-discovery-conventions\"></a>\r\n#### 模型和工厂的自动发现机制\r\n\r\n一旦你定义了工厂，你可以使用 `Illuminate\\Database\\Eloquent\\Factories\\HasFactory` 特征提供给模型的静态 `factory` 方法来为该模型实例化工厂。\r\n\r\n`HasFactory` 特征的 `factory` 方法将使用约定来确定适用于特定模型的工厂。具体而言，该方法将在 `Database\\Factories` 命名空间中查找一个工厂，该工厂的类名与模型名称匹配，并以 `Factory` 为后缀。如果这些约定不适用于你的特定应用程序或工厂，则可以在模型上覆盖 `newFactory` 方法，以直接返回模型对应的工厂的实例：\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\nuse Database\\Factories\\Administration\\FlightFactory;\r\n\r\n/**\r\n * 为模型创建一个新的工厂实例。\r\n */\r\nprotected static function newFactory(): Factory\r\n{\r\n    return FlightFactory::new();\r\n}\r\n\r\n```\r\n\r\n接下来，定义相应工厂的 `model` 属性：\r\n\r\n```php\r\nuse App\\Administration\\Flight;\r\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\n\r\nclass FlightFactory extends Factory\r\n{\r\n    /**\r\n     * 工厂对应的模型名称。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $model = Flight::class;\r\n}\r\n\r\n```\r\n\r\n<a name=\"factory-states\"></a>\r\n### 工厂状态\r\n\r\n状态操作方法可以让你定义离散的修改，这些修改可以在任意组合中应用于你的模型工厂。例如，你的 `Database\\Factories\\UserFactory` 工厂可能包含一个 `suspended` 状态方法，该方法可以修改其默认属性值之一。\r\n\r\n状态转换方法通常会调用 Laravel 基础工厂类提供的 `state` 方法。`state` 方法接受一个闭包函数，该函数将接收为工厂定义的原始属性数组，并应返回一个要修改的属性数组：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\n\r\n    /**\r\n     * 表示用户已被暂停。\r\n     */\r\n    public function suspended(): Factory\r\n    {\r\n        return $this->state(function (array $attributes) {\r\n            return [\r\n                'account_status' => 'suspended',\r\n            ];\r\n        });\r\n    }\r\n\r\n#### 「Trashed」状态\r\n如果你的 Eloquent 模型可以进行[软删除](/docs/laravel/10.x/eloquentmd#soft-deleting)，你可以调用内置的 `trashed` 状态方法来表示创建的模型应该已经被「软删除」。你不需要手动定义 `trashed` 状态，因为它对所有工厂都是自动可用的：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()->trashed()->create();\r\n\r\n<a name=\"factory-callbacks\"></a>\r\n### 工厂回调函数\r\n\r\n工厂回调函数是使用 `afterMaking` 和 `afterCreating` 方法注册的，它们允许你在创建或制造模型后执行其他任务。你应该通过在工厂类中定义一个 `configure` 方法来注册这些回调函数。当工厂被实例化时，Laravel 将自动调用这个方法：\r\n\r\n    namespace Database\\Factories;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    class UserFactory extends Factory\r\n    {\r\n        /**\r\n         * 配置模型工厂。\r\n         */\r\n        public function configure(): static\r\n        {\r\n            return $this->afterMaking(function (User $user) {\r\n                // ...\r\n            })->afterCreating(function (User $user) {\r\n                // ...\r\n            });\r\n        }\r\n\r\n        // ...\r\n    }\r\n\r\n<a name=\"creating-models-using-factories\"></a>\r\n## 使用工厂创建模型\r\n\r\n<a name=\"instantiating-models\"></a>\r\n### 实例化模型\r\n\r\n一旦你定义了工厂，你可以使用由 `Illuminate\\Database\\Eloquent\\Factories\\HasFactory` 特征为你的模型提供的静态 `factory` 方法来实例化该模型的工厂对象。让我们看一些创建模型的示例。首先，我们将使用 `make` 方法创建模型，而不将其持久化到数据库中：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()->make();\r\n\r\n你可以使用 count 方法创建多个模型的集合：\r\n\r\n    $users = User::factory()->count(3)->make();\r\n\r\n<a name=\"applying-states\"></a>\r\n#### 应用状态\r\n\r\n你也可以将任何[状态](#factory-states)应用于这些模型。如果你想要对这些模型应用多个状态转换，只需直接调用状态转换方法即可：\r\n\r\n    $users = User::factory()->count(5)->suspended()->make();\r\n\r\n<a name=\"overriding-attributes\"></a>\r\n#### 覆盖属性\r\n\r\n如果你想要覆盖模型的一些默认值，可以将一个值数组传递给 `make` 方法。只有指定的属性将被替换，而其余的属性将保持设置为工厂指定的默认值：\r\n\r\n    $user = User::factory()->make([\r\n        'name' => 'Abigail Otwell',\r\n    ]);\r\n\r\n或者，可以直接在工厂实例上调用 state 方法进行内联状态转换：\r\n\r\n    $user = User::factory()->state([\r\n        'name' => 'Abigail Otwell',\r\n    ])->make();\r\n\r\n> 注意：使用工厂创建模型时，[批量赋值保护](/docs/laravel/10.x/eloquent#mass-assignment)会自动被禁用。\r\n\r\n<a name=\"persisting-models\"></a>\r\n### 持久化模型\r\n\r\n`create` 方法会实例化模型并使用 Eloquent 的 `save` 方法将它们持久化到数据库中：\r\n\r\n    use App\\Models\\User;\r\n\r\n    // 创建单个 App\\Models\\User 实例。。。\r\n    $user = User::factory()->create();\r\n\r\n    // 创建三个 App\\Models\\User 实例。。。\r\n    $users = User::factory()->count(3)->create();\r\n\r\n你可以通过将属性数组传递给 `create` 方法来覆盖工厂的默认模型属性：\r\n\r\n    $user = User::factory()->create([\r\n        'name' => 'Abigail',\r\n    ]);\r\n\r\n<a name=\"sequences\"></a>\r\n### 序列\r\n\r\n有时，你可能希望为每个创建的模型交替更改给定模型属性的值。你可以通过将状态转换定义为序列来实现此目的。例如，你可能希望为每个创建的用户在 `admin` 列中在 `Y` 和 `N` 之间交替更改：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Sequence;\r\n\r\n    $users = User::factory()\r\n                    ->count(10)\r\n                    ->state(new Sequence(\r\n                        ['admin' => 'Y'],\r\n                        ['admin' => 'N'],\r\n                    ))\r\n                    ->create();\r\n\r\n在这个例子中，将创建五个 `admin` 值为 `Y` 的用户和五个 `admin` 值为 `N` 的用户。\r\n\r\n如果需要，你可以将闭包作为序列值包含在内。每次序列需要一个新值时，都会调用闭包：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Factories\\Sequence;\r\n\r\n    $users = User::factory()\r\n                    ->count(10)\r\n                    ->state(new Sequence(\r\n                        fn (Sequence $sequence) => ['role' => UserRoles::all()->random()],\r\n                    ))\r\n                    ->create();\r\n\r\n在序列闭包内，你可以访问注入到闭包中的序列实例上的 `$index` 或 `$count` 属性。 `$index` 属性包含到目前为止已经进行的序列迭代次数，而 `$count` 属性包含序列将被调用的总次数：\r\n\r\n    $users = User::factory()\r\n                    ->count(10)\r\n                    ->sequence(fn (Sequence $sequence) => ['name' => 'Name '.$sequence->index])\r\n                    ->create();\r\n\r\n为了方便，序列也可以使用 `sequence` 方法应用，该方法只是在内部调用了 `state` 方法。 `sequence` 方法接受一个闭包或序列化属性的数组：\r\n\r\n    $users = User::factory()\r\n                    ->count(2)\r\n                    ->sequence(\r\n                        ['name' => 'First User'],\r\n                        ['name' => 'Second User'],\r\n                    )\r\n                    ->create();\r\n\r\n<a name=\"factory-relationships\"></a>\r\n## 工厂关联\r\n\r\n<a name=\"has-many-relationships\"></a>\r\n### 一对多关系\r\n\r\n接下来，让我们探讨如何使用 Laravel 流畅的工厂方法构建 Eloquent 模型关系。首先，假设我们的应用程序有一个 `App\\Models\\User` 模型和一个 `App\\Models\\Post` 模型。同时，假设 `User` 模型定义了与 `Post` 的一对多关系。我们可以使用 Laravel 工厂提供的 `has` 方法创建一个有三篇文章的用户。`has` 方法接受一个工厂实例：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()\r\n                ->has(Post::factory()->count(3))\r\n                ->create();\r\n\r\n按照约定，当将 `Post` 模型传递给 `has` 方法时，Laravel 将假定 `User` 模型必须有一个 `posts` 方法来定义关系。如果需要，你可以显式指定你想要操作的关系名称：\r\n\r\n    $user = User::factory()\r\n                ->has(Post::factory()->count(3), 'posts')\r\n                ->create();\r\n\r\n当然，你可以对相关模型执行状态操作。此外，如果你的状态更改需要访问父模型，你可以传递一个基于闭包的状态转换：\r\n\r\n    $user = User::factory()\r\n                ->has(\r\n                    Post::factory()\r\n                            ->count(3)\r\n                            ->state(function (array $attributes, User $user) {\r\n                                return ['user_type' => $user->type];\r\n                            })\r\n                )\r\n                ->create();\r\n\r\n<a name=\"has-many-relationships-using-magic-methods\"></a>\r\n#### 使用魔术方法\r\n\r\n为了方便起见，你可以使用 Laravel 的魔术工厂关系方法来构建关系。例如，以下示例将使用约定来确定应该通过 `User` 模型上的 `posts` 关系方法创建相关模型：\r\n\r\n    $user = User::factory()\r\n                ->hasPosts(3)\r\n                ->create();\r\n\r\n当使用魔术方法创建工厂关系时，你可以传递一个属性数组来覆盖相关模型的属性：\r\n\r\n    $user = User::factory()\r\n                ->hasPosts(3, [\r\n                    'published' => false,\r\n                ])\r\n                ->create();\r\n\r\n如果你的状态更改需要访问父模型，你可以提供一个基于闭包的状态转换：\r\n\r\n    $user = User::factory()\r\n                ->hasPosts(3, function (array $attributes, User $user) {\r\n                    return ['user_type' => $user->type];\r\n                })\r\n                ->create();\r\n\r\n<a name=\"belongs-to-relationships\"></a>\r\n### 反向关系\r\n\r\n现在我们已经探讨了如何使用工厂构建「一对多」关系，让我们来探讨关系的反向操作。`for` 方法可用于定义工厂创建的模型所属的父模型。例如，我们可以创建三个 `App\\Models\\Post` 模型实例，这些实例属于同一个用户：\r\n\r\n    use App\\Models\\Post;\r\n    use App\\Models\\User;\r\n\r\n    $posts = Post::factory()\r\n                ->count(3)\r\n                ->for(User::factory()->state([\r\n                    'name' => 'Jessica Archer',\r\n                ]))\r\n                ->create();\r\n\r\n如果你已经有一个应该与正在创建的模型关联的父模型实例，则可以将该模型实例传递给 `for` 方法：\r\n\r\n    $user = User::factory()->create();\r\n\r\n    $posts = Post::factory()\r\n                ->count(3)\r\n                ->for($user)\r\n                ->create();\r\n\r\n<a name=\"belongs-to-relationships-using-magic-methods\"></a>\r\n#### 使用魔术方法\r\n\r\n为了方便起见，你可以使用 Laravel 的魔术工厂关系方法来定义「属于」关系。例如，以下示例将使用惯例来确定这三篇文章应该属于 `Post` 模型上的 `user` 关系：\r\n\r\n    $posts = Post::factory()\r\n                ->count(3)\r\n                ->forUser([\r\n                    'name' => 'Jessica Archer',\r\n                ])\r\n                ->create();\r\n\r\n<a name=\"many-to-many-relationships\"></a>\r\n### 多对多关系\r\n\r\n与[一对多](#has-many-relationships)关系一样，可以使用 `has` 方法创建「多对多」关系：\r\n\r\n    use App\\Models\\Role;\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()\r\n                ->has(Role::factory()->count(3))\r\n                ->create();\r\n\r\n<a name=\"pivot-table-attributes\"></a>\r\n#### 中间表属性\r\n\r\n如果需要定义应该在链接模型的透视表/中间表上设置的属性，可以使用 `hasAttached` 方法。此方法接受透视表属性名称和值的数组作为其第二个参数：\r\n\r\n    use App\\Models\\Role;\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()\r\n                ->hasAttached(\r\n                    Role::factory()->count(3),\r\n                    ['active' => true]\r\n                )\r\n                ->create();\r\n\r\n如果你的状态更改需要访问相关模型，则可以提供基于闭包的状态转换：\r\n\r\n    $user = User::factory()\r\n                ->hasAttached(\r\n                    Role::factory()\r\n                        ->count(3)\r\n                        ->state(function (array $attributes, User $user) {\r\n                            return ['name' => $user->name.' Role'];\r\n                        }),\r\n                    ['active' => true]\r\n                )\r\n                ->create();\r\n\r\n如果你已经有要附加到正在创建的模型的模型实例，则可以将这些模型实例传递给 `hasAttached` 方法。在此示例中，相同的三个角色将附加到所有三个用户：\r\n\r\n    $roles = Role::factory()->count(3)->create();\r\n\r\n    $user = User::factory()\r\n                ->count(3)\r\n                ->hasAttached($roles, ['active' => true])\r\n                ->create();\r\n\r\n<a name=\"many-to-many-relationships-using-magic-methods\"></a>\r\n#### 使用魔术方法\r\n\r\n为了方便，你可以使用 Laravel 的魔术工厂关系方法来定义多对多关系。例如，以下示例将使用约定确定应通过 `User` 模型上的 `roles` 关系方法创建相关模型：\r\n\r\n    $user = User::factory()\r\n                ->hasRoles(1, [\r\n                    'name' => 'Editor'\r\n                ])\r\n                ->create();\r\n\r\n<a name=\"polymorphic-relationships\"></a>\r\n### 多态关联\r\n\r\n[多态关联](/docs/laravel/10.x/eloquent-relationships#polymorphic-relationships)也可以使用工厂函数创建。多态「morph many」关联的创建方式与典型的「has many」关联相同。例如，如果 `App\\Models\\Post` 模型与 `App\\Models\\Comment` 模型具有多态的`morphMany`关系：\r\n\r\n    use App\\Models\\Post;\r\n\r\n    $post = Post::factory()->hasComments(3)->create();\r\n\r\n<a name=\"morph-to-relationships\"></a>\r\n#### Morph To 关联\r\n\r\n不能使用魔术方法创建 `morphTo` 关联。必须直接使用 `for` 方法，并明确提供关联名称。例如，假设 `Comment` 模型有一个 `commentable` 方法，该方法定义了一个 `morphTo` 关联。在这种情况下，我们可以使用 `for` 方法直接创建属于单个帖子的三个评论：\r\n\r\n    $comments = Comment::factory()->count(3)->for(\r\n        Post::factory(), 'commentable'\r\n    )->create();\r\n\r\n<a name=\"polymorphic-many-to-many-relationships\"></a>\r\n#### 多态多对多关联\r\n\r\n多态「many to many」( `morphToMany` / `morphedByMany` ) 关联的创建方式与非多态 「many to many」 关联相同：\r\n\r\n    use App\\Models\\Tag;\r\n    use App\\Models\\Video;\r\n\r\n    $videos = Video::factory()\r\n                ->hasAttached(\r\n                    Tag::factory()->count(3),\r\n                    ['public' => true]\r\n                )\r\n                ->create();\r\n\r\n当然，魔术方法 `has` 也可以用于创建多态「many to many」关系：\r\n\r\n    $videos = Video::factory()\r\n                ->hasTags(3, ['public' => true])\r\n                ->create();\r\n\r\n<a name=\"defining-relationships-within-factories\"></a>\r\n### 在工厂中定义关系\r\n\r\n在模型工厂中定义关系时，通常会将一个新的工厂实例分配给关系的外键。这通常是针对「反向」关系，例如 `belongsTo` 和 `morphTo` 关系。例如，如果你想在创建帖子时创建一个新用户，则可以执行以下操作：\r\n\r\n    use App\\Models\\User;\r\n\r\n    /**\r\n     * 定义模型的默认状态.\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function definition(): array\r\n    {\r\n        return [\r\n            'user_id' => User::factory(),\r\n            'title' => fake()->title(),\r\n            'content' => fake()->paragraph(),\r\n        ];\r\n    }\r\n\r\n如果关系的列依赖于定义它的工厂，你可以将闭包分配给属性。该闭包将接收工厂计算出的属性数组\r\n\r\n    /**\r\n     * 定义模型的默认状态.\r\n     *\r\n     * @return array<string, mixed>\r\n     */\r\n    public function definition(): array\r\n    {\r\n        return [\r\n            'user_id' => User::factory(),\r\n            'user_type' => function (array $attributes) {\r\n                return User::find($attributes['user_id'])->type;\r\n            },\r\n            'title' => fake()->title(),\r\n            'content' => fake()->paragraph(),\r\n        ];\r\n    }\r\n\r\n<a name=\"recycling-an-existing-model-for-relationships\"></a>\r\n### 在关系中重复使用现有模型\r\n\r\n如果你有多个模型与另一个模型共享一个公共关系，则可以使用 `recycle` 方法来确保相关模型的单个实例在工厂创建的所有关系中被重复使用。\r\n\r\n例如，假设你有 `Airline`、`Flight` 和 `Ticket` 模型，其中机票属于一个航空公司和一个航班，而航班也属于一个航空公司。在创建机票时，你可能希望将同一航空公司用于机票和航班，因此可以将一个航空公司实例传递给 `recycle` 方法：\r\n\r\n    Ticket::factory()\r\n        ->recycle(Airline::factory()->create())\r\n        ->create();\r\n\r\n如果你的模型属于一个公共用户或团队，则可以发现 `recycle` 方法特别有用。\r\n\r\n`recycle` 方法还接受一组现有模型。当一组集合提供给 `recycle` 方法时，当工厂需要该类型的模型时，将从集合中选择一个随机模型：\r\n\r\n    Ticket::factory()\r\n        ->recycle($airlines)\r\n        ->create();","p":"docs/eloquent-factories.html"},{"t":"testing (测试：入门)","d":"\n# 测试：入门\r\n\r\n- [介绍](#introduction)\r\n- [环境](#environment)\r\n- [创建测试](#creating-tests)\r\n- [运行测试](#running-tests)\r\n    - [并行运行测试](#running-tests-in-parallel)\r\n    - [测试覆盖率报告](#reporting-test-coverage)\r\n    - [性能分析测试](#profiling-tests)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n`Laravel` 在构建时考虑到了测试。实际上，对 `PHPUnit` 测试的支持是开箱即用的，并且已经为你的应用程序设置了一个 `phpunit.xml` 文件。 `Laravel`还附带了方便的帮助方法，允许你对应用程序进行富有表现力的测试。\r\n\r\n默认情况下，你应用程序的`tests`目录下包含两个子目录：`Feature` 和 `Unit`。**单元测试**（`Unit`）是针对你的代码中非常少，而且相对独立的一部分代码来进行的测试。实际上，大部分单元测试都是针对单个方法进行的。在你的 `Unit` 测试目录中进行测试，不会启动你的 `Laravel` 应用程序，因此无法访问你的应用程序的数据库或其他框架服务。\r\n\r\n**功能测试**（`Feature`）能测试你的大部分代码，包括多个对象如何相互交互，甚至是对 `JSON` 端点的完整 `HTTP` 请求。 **通常，你的大多数测试应该是功能测试。这些类型的测试可以最大程度地确保你的系统作为一个整体按预期运行。**\r\n\r\n`Feature` 和 `Unit` 测试目录中都提供了一个 `ExampleTest.php` 文件。 安装新的 Laravel 应用程序后，执行 `vendor/bin/phpunit` 或 `php artisan test` 命令来运行你的测试。\r\n\r\n<a name=\"environment\"></a>\r\n## 环境\r\n\r\n运行测试时，由于 `phpunit.xml` 文件中定义了 [环境变量](/docs/laravel/10.x/configuration#environment-configuration) ，`Laravel` 会自动配置环境变量为 `testing`。`Laravel` 还会在测试时自动将会话和缓存配置到 `array` 驱动程序，这意味着在测试时不会持久化会话或缓存数据。\r\n\r\n\n\n你可以根据需要自由定义其他测试环境配置值。 `testing` 环境变量可以在应用程序的 `phpunit.xml` 文件中配置，但请确保在运行测试之前使用 `config:clear` Artisan 命令清除配置缓存！\r\n\r\n<a name=\"the-env-testing-environment-file\"></a>\r\n#### `.env.testing` 环境配置文件\r\n\r\n此外，你可以在项目的根目录中创建一个 `.env.testing` 文件。 当运行 `PHPUnit` 测试或使用 `--env=testing` 选项执行 Artisan 命令时，将不会使用 `.env` 文件，而是使用此文件。\r\n\r\n<a name=\"the-creates-application-trait\"></a>\r\n#### `CreatesApplication` Trait\r\n\r\nLaravel 包含一个 `CreatesApplication` Trait，该`Trait`应用于应用程序的基类 `TestCase` 。 这个 `trait` 包含一个 `createApplication` 方法，它在运行测试之前引导 Laravel 应用程序。 重要的是，应将此 `trait` 保留在其原始位置，因为某些功能（例如 `Laravel` 的并行测试功能）依赖于它。\r\n\r\n<a name=\"creating-tests\"></a>\r\n## 创建测试\r\n\r\n要创建新的测试用例，请使用Artisan 命令： `make:test` 。 默认情况下，测试将放置在 `tests/Feature` 目录中：\r\n\r\n```shell\r\nphp artisan make:test UserTest\r\n```\r\n\r\n如果想在 `tests/Unit` 目录中创建一个测试，你可以在执行 `make:test` 命令时使用 `--unit` 选项：\r\n\r\n```shell\r\nphp artisan make:test UserTest --unit\r\n```\r\n\r\n如果想创建一个 [Pest PHP](https://pestphp.com) 测试, 你可以为 `make:test` 命令提供 `--pest` 选项：\r\n\r\n```shell\r\nphp artisan make:test UserTest --pest\r\nphp artisan make:test UserTest --unit --pest\r\n```\r\n\r\n> **技巧**  \r\n> 可以使用 [Stub 定制](/docs/laravel/10.x/artisan#stub-customization)来自定义测试。\r\n\r\n\n\n生成测试后，你可以像通常使用 [PHPUnit](https://phpunit.de/) 那样定义测试方法。要运行测试，请从终端执行 `vendor/bin/phpunit`或 `php artisan test` 命令：\r\n\r\n```\r\n<?php\r\n\r\nnamespace Tests\\\\Unit;\r\n\r\nuse PHPUnit\\\\Framework\\\\TestCase;\r\n\r\nclass ExampleTest extends TestCase\r\n{\r\n    /**\r\n     * 基础测试样例\r\n     *\r\n     * @return void\r\n     */\r\n    public function test_basic_test()\r\n    {\r\n        $this->assertTrue(true);\r\n    }\r\n}\r\n\r\n```\r\n\r\n>注意：如果你在测试类中定义自己的 `setUp`  或 `tearDown`  方法，请务必在父类上调用各自的 `parent::setUp()`  或 `parent::tearDown()`  方法。\r\n\r\n****运行测试****\r\n\r\n正如前面提到的，编写测试后，可以使用 `phpunit`  命令来执行测试：\r\n```shell\r\n./vendor/bin/phpunit\r\n```\r\n\r\n除了 `phpunit`  命令，你还可以使用 `test`  Artisan 命令来运行你的测试。 Artisan 测试运行器提供了详细的测试报告，以简化开发和调试：\r\n```shell\r\nphp artisan test\r\n```\r\n任何可以传递给 `phpunit`  命令的参数也可以传递给 Artisan `test`  命令：\r\n\r\n```shell\r\nphp artisan test --testsuite=Feature --stop-on-failure\r\n```\r\n\r\n****并行运行测试****\r\n\r\n默认情况下，`Laravel`  和 `PHPUnit`  在执行测试时，是在单进程中按照先后顺序执行的。除此之外，通过多个进程同时运行测试，则可以大大减少运行测试所需的时间。首先，请确保你的应用程序已依赖于 `^5.3`  或更高版本的 `nunomaduro/collision`  依赖包。然后，在执行 `test`  Artisan 命令时，请加入 `--parallel`  选项：\r\n```shell\r\nphp artisan test --parallel\r\n```\r\n默认情况下，`Laravel`  将创建与计算机上可用 CPU 内核数量一样多的进程。但是，你可以使用 `--processes`  选项来调整进程数：\r\n```shell\r\nphp artisan test --parallel --processes=4\r\n```\r\n\r\n>注意：在并行测试时，某些 PHPUnit 选项（例如 `--do-not-cache-result` ）可能不可用。\r\n\r\n\n\n### **并行测试和数据库**\r\n\r\n`Laravel` 在执行并行测试时，自动为每个进程创建并迁移生成一个测试数据库。这些测试数据库将以每个进程唯一的进程令牌作为后缀。例如，如果你有两个并行的测试进程，`Laravel` 将创建并使用 `your_db_test_1` 和 `your_db_test_2` 测试数据库。\r\n\r\n默认情况下，在多次调用 `test` Artisan 命令时，上一次的测试数据库依然存在，以便下一次的 `test` 命令可以再次使用它们。但是，你可以使用 `--recreate-databases` 选项重新创建它们：\r\n\r\n```\r\nphp artisan test --parallel --recreate-databases\r\n\r\n```\r\n\r\n### **并行测试钩子**\r\n\r\n有时，你可能需要为应用程序测试准备某些资源，以便可以将它们安全地用于多个测试进程。\r\n\r\n使用 `ParallelTesting` 门面，你就可以在进程或测试用例的 `setUp` 和 `tearDown` 上指定要执行的代码。给定的闭包将分别接收包含进程令牌和当前测试用例的 `$token` 和 `$testCase` 变量：\r\n```\r\n<?php\r\n\r\nnamespace App\\Providers;\r\n\r\nuse Illuminate\\Support\\Facades\\Artisan;\r\nuse Illuminate\\Support\\Facades\\ParallelTesting;\r\nuse Illuminate\\Support\\ServiceProvider;\r\n\r\nclass AppServiceProvider extends ServiceProvider\r\n{\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        ParallelTesting::setUpProcess(function ($token) {\r\n            // ...\r\n        });\r\n\r\n        ParallelTesting::setUpTestCase(function ($token, $testCase) {\r\n            // ...\r\n        });\r\n\r\n        // 在创建测试数据库时执行……\r\n        ParallelTesting::setUpTestDatabase(function ($database, $token) {\r\n            Artisan::call('db:seed');\r\n        });\r\n\r\n        ParallelTesting::tearDownTestCase(function ($token, $testCase) {\r\n            // ...\r\n        });\r\n\r\n        ParallelTesting::tearDownProcess(function ($token) {\r\n            // ...\r\n        });\r\n    }\r\n}\r\n```\n\n### **访问并行测试令牌**\r\n\r\n如果你想从应用程序的测试代码中的任何其他位置访问当前的并行进程的 `token`，则可以使用 `token` 方法。该令牌（`token`）是单个测试进程的唯一字符串标识符，可用于在并行测试过程中划分资源。例如，`Laravel` 自动用此令牌值作为每个并行测试进程创建的测试数据库名的后缀：\r\n\r\n```\r\n$token = ParallelTesting::token();\r\n\r\n```\r\n\r\n### **报告测试覆盖率**\r\n\r\n> 注意：这个功能需要 Xdebug 或 PCOV。\r\n\r\n在运行测试时，你可能需要确定测试用例是否真的测到了某些程序代码，以及在运行测试时究竟使用了多少应用程序代码。要实现这一点，你可以在调用 `test` 命令时，增加一个 `--coverage` 选项：\r\n```\r\nphp artisan test --coverage\r\n```\r\n\r\n### **最小覆盖率阈值限制**\r\n\r\n你可以使用 `--min` 选项来为你的应用程序定义一个最小测试覆盖率阈值。如果不满足此阈值，测试套件将失败：\r\n\r\n```\r\nphp artisan test --coverage --min=80.3\r\n\r\n```\r\n\r\n### 测试性能分析\r\n\r\nArtisan 测试运行器还提供了一个方便的机制用于列出你的应用程序中最慢的测试。使用`--profile`选项调用测试命令，可以看到10个最慢的测试列表，这可以让你很容易地识别哪些测试可以被改进，以加快你的测试套件。\r\n\r\n```\r\nphp artisan test --profile\r\n```\n","p":"docs/testing.html"},{"t":"http-tests (HTTP 测试)","d":"# HTTP 测试\r\n\r\n- [简介](#introduction)\r\n- [创建请求](#making-requests)\r\n    - [自定义请求头](#customizing-request-headers)\r\n    - [Cookies](#cookies)\r\n    - [会话 / 认证](#session-and-authentication)\r\n    - [调试响应](#debugging-responses)\r\n    - [异常处理](#exception-handling)\r\n- [测试 JSON APIs](#testing-json-apis)\r\n    - [流畅 JSON 测试](#fluent-json-testing)\r\n- [测试文件上传](#testing-file-uploads)\r\n- [测试视图](#testing-views)\r\n    - [渲染切面 & 组件](#rendering-blade-and-components)\r\n- [可用断言](#available-assertions)\r\n    - [响应断言](#response-assertions)\r\n    - [身份验证断言](#authentication-assertions)\r\n    - [验证断言](#validation-assertions)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 提供了一个非常流畅的 API，用于向应用程序发出 HTTP 请求并检查响应。例如，看看下面定义的特性测试：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例。\r\n         */\r\n        public function test_a_basic_request(): void\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            $response->assertStatus(200);\r\n        }\r\n    }\r\n\r\n`get` 方法向应用程序发出 `Get` 请求，而 `assertStatus` 方法则断言返回的响应应该具有给定的 HTTP 状态代码。除了这个简单的断言之外，Laravel 还包含各种用于检查响应头、内容、JSON 结构等的断言。\r\n\r\n<a name=\"making-requests\"></a>\r\n## 创建请求\r\n\r\n要向应用程序发出请求，可以在测试中调用`get`、`post`、`put`、`patch`或`delete`方法。这些方法实际上不会向应用程序发出「真正的」HTTP 请求。相反，整个网络请求是在内部模拟的。\r\n\r\n测试请求方法不返回`Illuminate\\Http\\Response`实例，而是返回`Illuminate\\Testing\\TestResponse`实例，该实例提供[各种有用的断言](##available-assertions),允许你检查应用程序的响应：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例。\r\n         */\r\n        public function test_a_basic_request(): void\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            $response->assertStatus(200);\r\n        }\r\n    }\r\n\r\n通常，你的每个测试应该只向你的应用发出一个请求。如果在单个测试方法中执行多个请求，则可能会出现意外行为。\r\n\r\n> **技巧**\r\n> 为了方便起见，运行测试时会自动禁用 CSRF 中间件。\r\n\r\n<a name=\"customizing-request-headers\"></a>\r\n### 自定义请求头\r\n\r\n你可以使用此 `withHeaders` 方法自定义请求的标头，然后再将其发送到应用程序。这使你可以将任何想要的自定义标头添加到请求中：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例。\r\n         */\r\n        public function test_interacting_with_headers(): void\r\n        {\r\n            $response = $this->withHeaders([\r\n                'X-Header' => 'Value',\r\n            ])->post('/user', ['name' => 'Sally']);\r\n\r\n            $response->assertStatus(201);\r\n        }\r\n    }\r\n\r\n<a name=\"cookies\"></a>\r\n### Cookies\r\n\r\n在发送请求前你可以使用 `withCookie` 或 `withCookies` 方法设置 cookie。`withCookie` 接受 cookie 的名称和值这两个参数，而 `withCookies` 方法接受一个名称 / 值对数组：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_interacting_with_cookies(): void\r\n        {\r\n            $response = $this->withCookie('color', 'blue')->get('/');\r\n\r\n            $response = $this->withCookies([\r\n                'color' => 'blue',\r\n                'name' => 'Taylor',\r\n            ])->get('/');\r\n        }\r\n    }\r\n\r\n<a name=\"session-and-authentication\"></a>\r\n### 会话 (Session) / 认证 (Authentication)\r\n\r\nLaravel 提供了几个可在 HTTP 测试时使用 Session 的辅助函数。首先，你需要传递一个数组给 `withSession` 方法来设置 session 数据。这样在应用程序的测试请求发送之前，就会先去给数据加载 session：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_interacting_with_the_session(): void\r\n        {\r\n            $response = $this->withSession(['banned' => false])->get('/');\r\n        }\r\n    }\r\n\r\nLaravel 的 session 通常用于维护当前已验证用户的状态。因此，`actingAs` 方法提供了一种将给定用户作为当前用户进行身份验证的便捷方法。例如，我们可以使用一个[工厂模式](/docs/laravel/10.x/eloquent-factories)来生成和认证一个用户：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use App\\Models\\User;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_an_action_that_requires_authentication(): void\r\n        {\r\n            $user = User::factory()->create();\r\n\r\n            $response = $this->actingAs($user)\r\n                             ->withSession(['banned' => false])\r\n                             ->get('/');\r\n        }\r\n    }\r\n\r\n你也可以通过传递看守器名称作为 `actingAs` 方法的第二参数以指定用户通过哪种看守器来认证。提供给 `actingAs` 方法的防护也将成为测试期间的默认防护。\r\n\r\n    $this->actingAs($user, 'web')\r\n\r\n<a name=\"debugging-responses\"></a>\r\n### 调试响应\r\n\r\n在向你的应用程序发出测试请求之后，可以使用 `dump`、`dumpHeaders` 和 `dumpSession` 方法来检查和调试响应内容：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例。\r\n         */\r\n        public function test_basic_test(): void\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            $response->dumpHeaders();\r\n\r\n            $response->dumpSession();\r\n\r\n            $response->dump();\r\n        }\r\n    }\r\n\r\n或者，你可以使用 `dd`、`ddHeaders` 和 `ddSession` 方法转储有关响应的信息，然后停止执行：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例。\r\n         */\r\n        public function test_basic_test(): void\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            $response->ddHeaders();\r\n\r\n            $response->ddSession();\r\n\r\n            $response->dd();\r\n        }\r\n    }\r\n\r\n<a name=\"exception-handling\"></a>\r\n### 异常处理\r\n\r\n有时你可能想要测试你的应用程序是否引发了特定异常。为了确保异常不会被 Laravel 的异常处理程序捕获并作为 HTTP 响应返回，可以在发出请求之前调用 `withoutExceptionHandling` 方法：\r\n\r\n    $response = $this->withoutExceptionHandling()->get('/');\r\n\r\n此外，如果想确保你的应用程序没有使用 PHP 语言或你的应用程序正在使用的库已弃用的功能，你可以在发出请求之前调用 `withoutDeprecationHandling` 方法。禁用弃用处理时，弃用警告将转换为异常，从而导致你的测试失败：\r\n\r\n    $response = $this->withoutDeprecationHandling()->get('/');\r\n\r\n<a name=\"testing-json-apis\"></a>\r\n## 测试 JSON APIs\r\n\r\nLaravel 也提供了几个辅助函数来测试 JSON APIs 和其响应。例如，`json`、`getJson`、`postJson`、`putJson`、`patchJson`、`deleteJson` 以及 `optionsJson` 可以被用于发送各种 HTTP 动作。你也可以轻松地将数据和请求头传递到这些方法中。首先，让我们实现一个测试示例，发送 `POST` 请求到 `/api/user`，并断言返回的期望数据：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例。\r\n         */\r\n        public function test_making_an_api_request(): void\r\n        {\r\n            $response = $this->postJson('/api/user', ['name' => 'Sally']);\r\n\r\n            $response\r\n                ->assertStatus(201)\r\n                ->assertJson([\r\n                    'created' => true,\r\n                ]);\r\n        }\r\n    }\r\n\r\n此外，JSON 响应数据可以作为响应上的数组变量进行访问，从而使你可以方便地检查 JSON 响应中返回的各个值：\r\n\r\n    $this->assertTrue($response['created']);\r\n\r\n> **技巧**\r\n> `assertJson` 方法将响应转换为数组，并利用 `PHPUnit::assertArraySubset` 验证给定数组是否存在于应用程序返回的 JSON 响应中。因此，如果 JSON 响应中还有其他属性，则只要存在给定的片段，此测试仍将通过。\r\n\r\n<a name=\"verifying-exact-match\"></a>\r\n#### 验证 JSON 完全匹配\r\n\r\n如前所述，`assertJson` 方法可用于断言 JSON 响应中存在 JSON 片段。如果你想验证给定数组是否与应用程序返回的 JSON **完全匹配**，则应使用 `assertExactJson` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例。\r\n         */\r\n        public function test_asserting_an_exact_json_match(): void\r\n        {\r\n            $response = $this->postJson('/user', ['name' => 'Sally']);\r\n\r\n            $response\r\n                ->assertStatus(201)\r\n                ->assertExactJson([\r\n                    'created' => true,\r\n                ]);\r\n        }\r\n    }\r\n\r\n<a name=\"verifying-json-paths\"></a>\r\n#### 验证 JSON 路径\r\n\r\n如果你想验证 JSON 响应是否包含指定路径上的某些给定数据，可以使用 `assertJsonPath` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        /**\r\n         * 基本功能测试示例。\r\n         */\r\n        public function test_asserting_a_json_paths_value(): void\r\n        {\r\n            $response = $this->postJson('/user', ['name' => 'Sally']);\r\n\r\n            $response\r\n                ->assertStatus(201)\r\n                ->assertJsonPath('team.owner.name', 'Darian');\r\n        }\r\n    }\r\n\r\n`assertJsonPath` 方法也接受一个闭包，可以用来动态地确定断言是否应该通过。\r\n\r\n    $response->assertJsonPath('team.owner.name', fn (string $name) => strlen($name) >= 3);\r\n\r\n<a name=\"fluent-json-testing\"></a>\r\n### JSON 流式测试\r\n\r\nLaravel 还提供了一种漂亮的方式来流畅地测试应用程序的 JSON 响应。首先，将闭包传递给 `assertJson` 方法。这个闭包将使用 `Illuminate\\Testing\\Fluent\\AssertableJson` 的实例调用，该实例可用于对应用程序返回的 JSON 进行断言。 `where` 方法可用于对 JSON 的特定属性进行断言，而 `missing` 方法可用于断言 JSON 中缺少特定属性：\r\n\r\n    use Illuminate\\Testing\\Fluent\\AssertableJson;\r\n\r\n    /**\r\n     * 基本功能测试示例。\r\n     */\r\n    public function test_fluent_json(): void\r\n    {\r\n        $response = $this->getJson('/users/1');\r\n\r\n        $response\r\n            ->assertJson(fn (AssertableJson $json) =>\r\n                $json->where('id', 1)\r\n                     ->where('name', 'Victoria Faith')\r\n                     ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))\r\n                     ->whereNot('status', 'pending')\r\n                     ->missing('password')\r\n                     ->etc()\r\n            );\r\n    }\r\n\r\n#### 了解 `etc` 方法\r\n\r\n在上面的例子中, 你可能已经注意到我们在断言链的末端调用了 `etc` 方法. 这个方法通知Laravel，在JSON对象上可能还有其他的属性存在。如果没有使用 `etc` 方法, 如果你没有对JSON对象的其他属性进行断言, 测试将失败.\r\n\r\n这种行为背后的意图是保护你不会在你的 JSON 响应中无意地暴露敏感信息，因为它迫使你明确地对该属性进行断言或通过 `etc` 方法明确地允许额外的属性。\r\n\r\n然而，你应该知道，在你的断言链中不包括 `etc` 方法并不能确保额外的属性不会被添加到嵌套在 JSON 对象中的数组。`etc` 方法只能确保在调用 `etc` 方法的嵌套层中不存在额外的属性。\r\n\r\n<a name=\"asserting-json-attribute-presence-and-absence\"></a>\r\n#### 断言属性存在/不存在\r\n\r\n要断言属性存在或不存在，可以使用 `has` 和 `missing` 方法：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->has('data')\r\n             ->missing('message')\r\n    );\r\n\r\n此外，`hasAll` 和 `missingAll` 方法允许同时断言多个属性的存在或不存在：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->hasAll(['status', 'data'])\r\n             ->missingAll(['message', 'code'])\r\n    );\r\n\r\n你可以使用 `hasAny` 方法来确定是否存在给定属性列表中的至少一个：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->has('status')\r\n             ->hasAny('data', 'message', 'code')\r\n    );\r\n\r\n<a name=\"asserting-against-json-collections\"></a>\r\n#### 断言反对 JSON 集合\r\n\r\n通常，你的路由将返回一个 JSON 响应，其中包含多个项目，例如多个用户：\r\n\r\n    Route::get('/users', function () {\r\n        return User::all();\r\n    });\r\n\r\n在这些情况下，我们可以使用 fluent JSON 对象的 `has` 方法对响应中包含的用户进行断言。例如，让我们断言 JSON 响应包含三个用户。接下来，我们将使用 `first` 方法对集合中的第一个用户进行一些断言。 `first` 方法接受一个闭包，该闭包接收另一个可断言的 JSON 字符串，我们可以使用它来对 JSON 集合中的第一个对象进行断言：\r\n\r\n    $response\r\n        ->assertJson(fn (AssertableJson $json) =>\r\n            $json->has(3)\r\n                 ->first(fn (AssertableJson $json) =>\r\n                    $json->where('id', 1)\r\n                         ->where('name', 'Victoria Faith')\r\n                         ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))\r\n                         ->missing('password')\r\n                         ->etc()\r\n                 )\r\n        );\r\n\r\n<a name=\"scoping-json-collection-assertions\"></a>\r\n#### JSON 集合范围断言\r\n\r\n有时，你的应用程序的路由将返回分配有命名键的 JSON 集合：\r\n\r\n    Route::get('/users', function () {\r\n        return [\r\n            'meta' => [...],\r\n            'users' => User::all(),\r\n        ];\r\n    })\r\n\r\n在测试这些路由时，你可以使用 `has` 方法来断言集合中的项目数。此外，你可以使用 `has` 方法来确定断言链的范围：\r\n\r\n    $response\r\n        ->assertJson(fn (AssertableJson $json) =>\r\n            $json->has('meta')\r\n                 ->has('users', 3)\r\n                 ->has('users.0', fn (AssertableJson $json) =>\r\n                    $json->where('id', 1)\r\n                         ->where('name', 'Victoria Faith')\r\n                         ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))\r\n                         ->missing('password')\r\n                         ->etc()\r\n                 )\r\n        );\r\n\r\n但是，你可以进行一次调用，提供一个闭包作为其第三个参数，而不是对 `has` 方法进行两次单独调用来断言 `users` 集合。这样做时，将自动调用闭包并将其范围限定为集合中的第一项：\r\n\r\n    $response\r\n        ->assertJson(fn (AssertableJson $json) =>\r\n            $json->has('meta')\r\n                 ->has('users', 3, fn (AssertableJson $json) =>\r\n                    $json->where('id', 1)\r\n                         ->where('name', 'Victoria Faith')\r\n                         ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))\r\n                         ->missing('password')\r\n                         ->etc()\r\n                 )\r\n        );\r\n\r\n<a name=\"asserting-json-types\"></a>\r\n#### 断言 JSON 类型\r\n\r\n你可能只想断言 JSON 响应中的属性属于某种类型。 `Illuminate\\Testing\\Fluent\\AssertableJson` 类提供了 `whereType` 和 `whereAllType` 方法来做到这一点：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->whereType('id', 'integer')\r\n             ->whereAllType([\r\n                'users.0.name' => 'string',\r\n                'meta' => 'array'\r\n            ])\r\n    );\r\n\r\n你可以使用 `|` 字符指定多种类型，或者将类型数组作为第二个参数传递给 `whereType` 方法。如果响应值为任何列出的类型，则断言将成功：\r\n\r\n    $response->assertJson(fn (AssertableJson $json) =>\r\n        $json->whereType('name', 'string|null')\r\n             ->whereType('id', ['string', 'integer'])\r\n    );\r\n\r\n`whereType` 和 `whereAllType` 方法识别以下类型：`string`、`integer`、`double`、`boolean`、`array` 和 `null`。\r\n\r\n<a name=\"testing-file-uploads\"></a>\r\n## 测试文件上传\r\n\r\n`Illuminate\\Http\\UploadedFile` 提供了一个 `fake` 方法用于生成虚拟的文件或者图像以供测试之用。它可以和 `Storage` facade 的 `fake` 方法相结合，大幅度简化了文件上传测试。举个例子，你可以结合这两者的功能非常方便地进行头像上传表单测试：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Illuminate\\Http\\UploadedFile;\r\n    use Illuminate\\Support\\Facades\\Storage;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_avatars_can_be_uploaded(): void\r\n        {\r\n            Storage::fake('avatars');\r\n\r\n            $file = UploadedFile::fake()->image('avatar.jpg');\r\n\r\n            $response = $this->post('/avatar', [\r\n                'avatar' => $file,\r\n            ]);\r\n\r\n            Storage::disk('avatars')->assertExists($file->hashName());\r\n        }\r\n    }\r\n\r\n如果你想断言一个给定的文件不存在，则可以使用由 `Storage` facade 提供的 `AssertMissing` 方法：\r\n\r\n    Storage::fake('avatars');\r\n\r\n    // ...\r\n\r\n    Storage::disk('avatars')->assertMissing('missing.jpg');\r\n\r\n<a name=\"fake-file-customization\"></a>\r\n#### 虚拟文件定制\r\n\r\n当使用 `UploadedFile` 类提供的 `fake` 方法创建文件时，你可以指定图片的宽度、高度和大小（以千字节为单位），以便更好地测试你的应用程序的验证规则。\r\n\r\n    UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);\r\n\r\n除创建图像外，你也可以用 `create` 方法创建其他类型的文件：\r\n\r\n    UploadedFile::fake()->create('document.pdf', $sizeInKilobytes);\r\n\r\n如果需要，可以向该方法传递一个 `$mimeType` 参数，以显式定义文件应返回的 MIME 类型：\r\n\r\n    UploadedFile::fake()->create(\r\n        'document.pdf', $sizeInKilobytes, 'application/pdf'\r\n    );\r\n\r\n<a name=\"testing-views\"></a>\r\n## 测试视图\r\n\r\nLaravel 允许在不向应用程序发出模拟 HTTP 请求的情况下独立呈现视图。为此，可以在测试中使用 `view` 方法。`view` 方法接受视图名称和一个可选的数据数组。这个方法返回一个 `Illuminate\\Testing\\TestView` 的实例，它提供了几个方法来方便地断言视图的内容：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        public function test_a_welcome_view_can_be_rendered(): void\r\n        {\r\n            $view = $this->view('welcome', ['name' => 'Taylor']);\r\n\r\n            $view->assertSee('Taylor');\r\n        }\r\n    }\r\n\r\n`TestView` 对象提供了以下断言方法：`assertSee`、`assertSeeInOrder`、`assertSeeText`、`assertSeeTextInOrder`、`assertDontSee` 和 `assertDontSeeText`。\r\n\r\n如果需要，你可以通过将 `TestView` 实例转换为一个字符串获得原始的视图内容：\r\n\r\n    $contents = (string) $this->view('welcome');\r\n\r\n<a name=\"sharing-errors\"></a>\r\n#### 共享错误\r\n\r\n一些视图可能依赖于 Laravel 提供的 [全局错误包](/docs/laravel/10.x/validation#quick-displaying-the-validation-errors) 中共享的错误。要在错误包中生成错误消息，可以使用 `withViewErrors` 方法：\r\n\r\n    $view = $this->withViewErrors([\r\n        'name' => ['Please provide a valid name.']\r\n    ])->view('form');\r\n\r\n    $view->assertSee('Please provide a valid name.');\r\n\r\n<a name=\"rendering-blade-and-components\"></a>\r\n### 渲染模板 & 组件\r\n\r\n必要的话，你可以使用 `blade` 方法来计算和呈现原始的 [Blade](/docs/laravel/10.x/blade) 字符串。与 `view` 方法一样，`blade` 方法返回的是 `Illuminate\\Testing\\TestView` 的实例：\r\n\r\n    $view = $this->blade(\r\n        '<x-component :name=\"$name\" />',\r\n        ['name' => 'Taylor']\r\n    );\r\n\r\n    $view->assertSee('Taylor');\r\n\r\n你可以使用 `component` 方法来评估和渲染 [Blade 组件](/docs/laravel/10.x/blade#components)。类似于 `view` 方法，`component` 方法返回一个 `Illuminate\\Testing\\TestView` 的实例：\r\n\r\n    $view = $this->component(Profile::class, ['name' => 'Taylor']);\r\n\r\n    $view->assertSee('Taylor');\r\n\r\n<a name=\"available-assertions\"></a>\r\n## 可用断言\r\n\r\n<a name=\"response-assertions\"></a>\r\n### 响应断言\r\n\r\nLaravel 的 `Illuminate\\Testing\\TestResponse` 类提供了各种自定义断言方法，你可以在测试应用程序时使用它们。可以在由 `json`、`get`、`post`、`put` 和 `delete` 方法返回的响应上访问这些断言：\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        columns: 14.4em 2; -moz-columns: 14.4em 2; -webkit-columns: 14.4em 2;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[assertCookie](#assert-cookie)\r\n[assertCookieExpired](#assert-cookie-expired)\r\n[assertCookieNotExpired](#assert-cookie-not-expired)\r\n[assertCookieMissing](#assert-cookie-missing)\r\n[assertCreated](#assert-created)\r\n[assertDontSee](#assert-dont-see)\r\n[assertDontSeeText](#assert-dont-see-text)\r\n[assertDownload](#assert-download)\r\n[assertExactJson](#assert-exact-json)\r\n[assertForbidden](#assert-forbidden)\r\n[assertHeader](#assert-header)\r\n[assertHeaderMissing](#assert-header-missing)\r\n[assertJson](#assert-json)\r\n[assertJsonCount](#assert-json-count)\r\n[assertJsonFragment](#assert-json-fragment)\r\n[assertJsonIsArray](#assert-json-is-array)\r\n[assertJsonIsObject](#assert-json-is-object)\r\n[assertJsonMissing](#assert-json-missing)\r\n[assertJsonMissingExact](#assert-json-missing-exact)\r\n[assertJsonMissingValidationErrors](#assert-json-missing-validation-errors)\r\n[assertJsonPath](#assert-json-path)\r\n[assertJsonMissingPath](#assert-json-missing-path)\r\n[assertJsonStructure](#assert-json-structure)\r\n[assertJsonValidationErrors](#assert-json-validation-errors)\r\n[assertJsonValidationErrorFor](#assert-json-validation-error-for)\r\n[assertLocation](#assert-location)\r\n[assertContent](#assert-content)\r\n[assertNoContent](#assert-no-content)\r\n[assertStreamedContent](#assert-streamed-content)\r\n[assertNotFound](#assert-not-found)\r\n[assertOk](#assert-ok)\r\n[assertPlainCookie](#assert-plain-cookie)\r\n[assertRedirect](#assert-redirect)\r\n[assertRedirectContains](#assert-redirect-contains)\r\n[assertRedirectToRoute](#assert-redirect-to-route)\r\n[assertRedirectToSignedRoute](#assert-redirect-to-signed-route)\r\n[assertSee](#assert-see)\r\n[assertSeeInOrder](#assert-see-in-order)\r\n[assertSeeText](#assert-see-text)\r\n[assertSeeTextInOrder](#assert-see-text-in-order)\r\n[assertSessionHas](#assert-session-has)\r\n[assertSessionHasInput](#assert-session-has-input)\r\n[assertSessionHasAll](#assert-session-has-all)\r\n[assertSessionHasErrors](#assert-session-has-errors)\r\n[assertSessionHasErrorsIn](#assert-session-has-errors-in)\r\n[assertSessionHasNoErrors](#assert-session-has-no-errors)\r\n[assertSessionDoesntHaveErrors](#assert-session-doesnt-have-errors)\r\n[assertSessionMissing](#assert-session-missing)\r\n[assertStatus](#assert-status)\r\n[assertSuccessful](#assert-successful)\r\n[assertUnauthorized](#assert-unauthorized)\r\n[assertUnprocessable](#assert-unprocessable)\r\n[assertValid](#assert-valid)\r\n[assertInvalid](#assert-invalid)\r\n[assertViewHas](#assert-view-has)\r\n[assertViewHasAll](#assert-view-has-all)\r\n[assertViewIs](#assert-view-is)\r\n[assertViewMissing](#assert-view-missing)\r\n\r\n</div>\r\n\r\n<a name=\"assert-cookie\"></a>\r\n#### assertCookie\r\n\r\n断言响应中包含给定的 cookie：\r\n\r\n    $response->assertCookie($cookieName, $value = null);\r\n\r\n<a name=\"assert-cookie-expired\"></a>\r\n#### assertCookieExpired\r\n\r\n断言响应包含给定的过期的 cookie：\r\n\r\n    $response->assertCookieExpired($cookieName);\r\n\r\n<a name=\"assert-cookie-not-expired\"></a>\r\n#### assertCookieNotExpired\r\n\r\n断言响应包含给定的未过期的 cookie：\r\n\r\n    $response->assertCookieNotExpired($cookieName);\r\n\r\n<a name=\"assert-cookie-missing\"></a>\r\n#### assertCookieMissing\r\n\r\n断言响应不包含给定的 cookie:\r\n\r\n    $response->assertCookieMissing($cookieName);\r\n\r\n<a name=\"assert-created\"></a>\r\n#### assertCreated\r\n\r\n断言做状态代码为 201 的响应：\r\n\r\n    $response->assertCreated();\r\n\r\n<a name=\"assert-dont-see\"></a>\r\n#### assertDontSee\r\n\r\n断言给定的字符串不包含在响应中。除非传递第二个参数 `false`，否则此断言将给定字符串进行转义后匹配：\r\n\r\n    $response->assertDontSee($value, $escaped = true);\r\n\r\n<a name=\"assert-dont-see-text\"></a>\r\n#### assertDontSeeText\r\n\r\n断言给定的字符串不包含在响应文本中。除非你传递第二个参数 `false`，否则该断言将自动转义给定的字符串。该方法将在做出断言之前将响应内容传递给 PHP 的 `strip_tags` 函数：\r\n\r\n    $response->assertDontSeeText($value, $escaped = true);\r\n\r\n<a name=\"assert-download\"></a>\r\n#### assertDownload\r\n\r\n断言响应是「下载」。通常，这意味着返回响应的调用路由返回了 `Response::download` 响应、`BinaryFileResponse` 或 `Storage::download` 响应：\r\n\r\n    $response->assertDownload();\r\n\r\n如果你愿意，你可以断言可下载的文件被分配了一个给定的文件名：\r\n\r\n    $response->assertDownload('image.jpg');\r\n\r\n<a name=\"assert-exact-json\"></a>\r\n#### assertExactJson\r\n\r\n断言响应包含与给定 JSON 数据的完全匹配：\r\n\r\n    $response->assertExactJson(array $data);\r\n\r\n<a name=\"assert-forbidden\"></a>\r\n#### assertForbidden\r\n\r\n断言响应中有禁止访问 (403) 状态码：\r\n\r\n    $response->assertForbidden();\r\n\r\n<a name=\"assert-header\"></a>\r\n#### assertHeader\r\n\r\n断言给定的 header 在响应中存在：\r\n\r\n    $response->assertHeader($headerName, $value = null);\r\n\r\n<a name=\"assert-header-missing\"></a>\r\n#### assertHeaderMissing\r\n\r\n断言给定的 header 在响应中不存在：\r\n\r\n    $response->assertHeaderMissing($headerName);\r\n\r\n<a name=\"assert-json\"></a>\r\n#### assertJson\r\n\r\n断言响应包含给定的 JSON 数据：\r\n\r\n    $response->assertJson(array $data, $strict = false);\r\n\r\n`AssertJson` 方法将响应转换为数组，并利用 `PHPUnit::assertArraySubset` 验证给定数组是否存在于应用程序返回的 JSON 响应中。因此，如果 JSON 响应中还有其他属性，则只要存在给定的片段，此测试仍将通过。\r\n\r\n<a name=\"assert-json-count\"></a>\r\n#### assertJsonCount\r\n\r\n断言响应 JSON 中有一个数组，其中包含给定键的预期元素数量：\r\n\r\n    $response->assertJsonCount($count, $key = null);\r\n\r\n<a name=\"assert-json-fragment\"></a>\r\n#### assertJsonFragment\r\n\r\n断言响应包含给定 JSON 片段：\r\n\r\n    Route::get('/users', function () {\r\n        return [\r\n            'users' => [\r\n                [\r\n                    'name' => 'Taylor Otwell',\r\n                ],\r\n            ],\r\n        ];\r\n    });\r\n\r\n    $response->assertJsonFragment(['name' => 'Taylor Otwell']);\r\n\r\n<a name=\"assert-json-is-array\"></a>\r\n#### assertJsonIsArray\r\n\r\n断言响应的 JSON 是一个数组。\r\n\r\n    $response->assertJsonIsArray();\r\n\r\n<a name=\"assert-json-is-object\"></a>\r\n#### assertJsonIsObject\r\n\r\n断言响应的 JSON 是一个对象。\r\n\r\n    $response->assertJsonIsObject();\r\n\r\n<a name=\"assert-json-missing\"></a>\r\n#### assertJsonMissing\r\n\r\n断言响应未包含给定的 JSON 片段：\r\n\r\n    $response->assertJsonMissing(array $data);\r\n\r\n<a name=\"assert-json-missing-exact\"></a>\r\n#### assertJsonMissingExact\r\n\r\n断言响应不包含确切的 JSON 片段：\r\n\r\n    $response->assertJsonMissingExact(array $data);\r\n\r\n<a name=\"assert-json-missing-validation-errors\"></a>\r\n#### assertJsonMissingValidationErrors\r\n\r\n断言响应响应对于给定的键没有 JSON 验证错误：\r\n\r\n    $response->assertJsonMissingValidationErrors($keys);\r\n\r\n> **提示**\r\n> 更通用的 [assertValid](#assert-valid) 方法可用于断言响应没有以 JSON 形式返回的验证错误**并且**没有错误被闪现到会话存储中。\r\n\r\n<a name=\"assert-json-path\"></a>\r\n#### assertJsonPath\r\n\r\n断言响应包含指定路径上的给定数据：\r\n\r\n    $response->assertJsonPath($path, $expectedValue);\r\n\r\n例如，如果你的应用程序返回的 JSON 响应包含以下数据：\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"name\": \"Steve Schoger\"\r\n    }\r\n}\r\n```\r\n\r\n你可以断言 `user` 对象的 `name` 属性匹配给定值，如下所示：\r\n\r\n    $response->assertJsonPath('user.name', 'Steve Schoger');\r\n\r\n<a name=\"assert-json-missing-path\"></a>\r\n#### assertJsonMissingPath\r\n\r\n断言响应具有给定的 JSON 结构：\r\n\r\n    $response->assertJsonMissingPath($path);\r\n\r\n例如，如果你的应用程序返回的 JSON 响应包含以下数据：\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"name\": \"Steve Schoger\"\r\n    }\r\n}\r\n```\r\n\r\n你可以断言它不包含 `user` 对象的 `email` 属性。\r\n\r\n    $response->assertJsonMissingPath('user.email');\r\n\r\n<a name=\"assert-json-structure\"></a>\r\n#### assertJsonStructure\r\n\r\n断言响应具有给定的 JSON 结构：\r\n\r\n    $response->assertJsonStructure(array $structure);\r\n\r\n例如，如果你的应用程序返回的 JSON 响应包含以下数据：\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"name\": \"Steve Schoger\"\r\n    }\r\n}\r\n```\r\n\r\n你可以断言 JSON 结构符合你的期望，如下所示：\r\n\r\n    $response->assertJsonStructure([\r\n        'user' => [\r\n            'name',\r\n        ]\r\n    ]);\r\n\r\n有时，你的应用程序返回的 JSON 响应可能包含对象数组：\r\n\r\n```json\r\n{\r\n    \"user\": [\r\n        {\r\n            \"name\": \"Steve Schoger\",\r\n            \"age\": 55,\r\n            \"location\": \"Earth\"\r\n        },\r\n        {\r\n            \"name\": \"Mary Schoger\",\r\n            \"age\": 60,\r\n            \"location\": \"Earth\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n在这种情况下，你可以使用 `*` 字符来断言数组中所有对象的结构：\r\n\r\n    $response->assertJsonStructure([\r\n        'user' => [\r\n            '*' => [\r\n                 'name',\r\n                 'age',\r\n                 'location'\r\n            ]\r\n        ]\r\n    ]);\r\n\r\n<a name=\"assert-json-validation-errors\"></a>\r\n#### assertJsonValidationErrors\r\n\r\n断言响应具有给定键的给定 JSON 验证错误。在断言验证错误作为 JSON 结构返回而不是闪现到会话的响应时，应使用此方法：\r\n\r\n    $response->assertJsonValidationErrors(array $data, $responseKey = 'errors');\r\n\r\n> **技巧**\r\n> 更通用的 [assertInvalid](#assert-invalid) 方法可用于断言响应具有以 JSON 形式返回的验证错误**或**错误已闪存到会话存储。\r\n\r\n<a name=\"assert-json-validation-error-for\"></a>\r\n#### assertJsonValidationErrorFor\r\n\r\n断言响应对给定键有任何 JSON 验证错误：\r\n\r\n    $response->assertJsonValidationErrorFor(string $key, $responseKey = 'errors');\r\n\r\n<a name=\"assert-location\"></a>\r\n#### assertLocation\r\n\r\n断言响应在 `Location` 头部中具有给定的 URI 值：\r\n\r\n    $response->assertLocation($uri);\r\n\r\n<a name=\"assert-content\"></a>\r\n#### assertContent\r\n\r\n断言给定的字符串与响应内容匹配。\r\n\r\n    $response->assertContent($value);\r\n\r\n<a name=\"assert-no-content\"></a>\r\n#### assertNoContent\r\n\r\n断言响应具有给定的 HTTP 状态码且没有内容：\r\n\r\n    $response->assertNoContent($status = 204);\r\n\r\n<a name=\"assert-streamed-content\"></a>\r\n#### assertStreamedContent\r\n\r\n断言给定的字符串与流式响应的内容相匹配。\r\n\r\n    $response->assertStreamedContent($value);\r\n\r\n<a name=\"assert-not-found\"></a>\r\n#### assertNotFound\r\n\r\n断言响应具有未找到（404）HTTP 状态码：\r\n\r\n    $response->assertNotFound();\r\n\r\n<a name=\"assert-ok\"></a>\r\n#### assertOk\r\n\r\n断言响应有 200 状态码：\r\n\r\n    $response->assertOk();\r\n\r\n<a name=\"assert-plain-cookie\"></a>\r\n#### assertPlainCookie\r\n\r\n断言响应包含给定的 cookie（未加密）:\r\n\r\n    $response->assertPlainCookie($cookieName, $value = null);\r\n\r\n<a name=\"assert-redirect\"></a>\r\n#### assertRedirect\r\n\r\n断言响应会重定向到给定的 URI：\r\n\r\n    $response->assertRedirect($uri);\r\n\r\n<a name=\"assert-redirect-contains\"></a>\r\n#### assertRedirectContains\r\n\r\n断言响应是否重定向到包含给定字符串的 URI：\r\n\r\n    $response->assertRedirectContains($string);\r\n\r\n<a name=\"assert-redirect-to-route\"></a>\r\n#### assertRedirectToRoute\r\n\r\n断言响应是对给定的[命名路由](/docs/laravel/10.x/routing#named-routes)的重定向。\r\n\r\n    $response->assertRedirectToRoute($name = null, $parameters = []);\r\n\r\n<a name=\"assert-redirect-to-signed-route\"></a>\r\n#### assertRedirectToSignedRoute\r\n\r\n断言响应是对给定[签名路由](/docs/laravel/10.x/urls#signed-urls)的重定向：\r\n\r\n    $response->assertRedirectToSignedRoute($name = null, $parameters = []);\r\n\r\n<a name=\"assert-see\"></a>\r\n#### assertSee\r\n\r\n断言给定的字符串包含在响应中。除非传递第二个参数 `false`，否则此断言将给定字符串进行转义后匹配：\r\n\r\n    $response->assertSee($value, $escaped = true);\r\n\r\n<a name=\"assert-see-in-order\"></a>\r\n#### assertSeeInOrder\r\n\r\n断言给定的字符串按顺序包含在响应中。除非传递第二个参数 `false`，否则此断言将给定字符串进行转义后匹配：\r\n\r\n    $response->assertSeeInOrder(array $values, $escaped = true);\r\n\r\n<a name=\"assert-see-text\"></a>\r\n#### assertSeeText\r\n\r\n断言给定字符串包含在响应文本中。除非传递第二个参数 `false`，否则此断言将给定字符串进行转义后匹配。在做出断言之前，响应内容将被传递到 PHP 的 `strip_tags` 函数：\r\n\r\n    $response->assertSeeText($value, $escaped = true);\r\n\r\n<a name=\"assert-see-text-in-order\"></a>\r\n#### assertSeeTextInOrder\r\n\r\n断言给定的字符串按顺序包含在响应的文本中。除非传递第二个参数 `false`，否则此断言将给定字符串进行转义后匹配。在做出断言之前，响应内容将被传递到 PHP 的 `strip_tags` 函数：\r\n\r\n    $response->assertSeeTextInOrder(array $values, $escaped = true);\r\n\r\n<a name=\"assert-session-has\"></a>\r\n#### assertSessionHas\r\n\r\n断言 Session 包含给定的数据段：\r\n\r\n    $response->assertSessionHas($key, $value = null);\r\n\r\n如果需要，可以提供一个闭包作为 `assertSessionHas` 方法的第二个参数。如果闭包返回 `true`，则断言将通过：\r\n\r\n    $response->assertSessionHas($key, function (User $value) {\r\n        return $value->name === 'Taylor Otwell';\r\n    });\r\n\r\n<a name=\"assert-session-has-input\"></a>\r\n#### assertSessionHasInput\r\n\r\nsession 在 [闪存输入数组](/docs/laravel/9.x/responses#redirecting-with-flashed-session-data) 中断言具有给定值：\r\n\r\n    $response->assertSessionHasInput($key, $value = null);\r\n\r\n如果需要，可以提供一个闭包作为 `assertSessionHasInput` 方法的第二个参数。如果闭包返回 `true`，则断言将通过：\r\n\r\n    $response->assertSessionHasInput($key, function (string $value) {\r\n        return Crypt::decryptString($value) === 'secret';\r\n    });\r\n\r\n<a name=\"assert-session-has-all\"></a>\r\n#### assertSessionHasAll\r\n\r\n断言 Session 中具有给定的键 / 值对列表：\r\n\r\n    $response->assertSessionHasAll(array $data);\r\n\r\n例如，如果你的应用程序会话包含 `name` 和 `status` 键，则可以断言它们存在并且具有指定的值，如下所示：\r\n\r\n    $response->assertSessionHasAll([\r\n        'name' => 'Taylor Otwell',\r\n        'status' => 'active',\r\n    ]);\r\n\r\n<a name=\"assert-session-has-errors\"></a>\r\n#### assertSessionHasErrors\r\n\r\n断言 session 包含给定 `$keys` 的 Laravel 验证错误。如果 `$keys` 是关联数组，则断言 session 包含每个字段（key）的特定错误消息（value）。测试将闪存验证错误到 session 的路由时，应使用此方法，而不是将其作为 JSON 结构返回：\r\n\r\n    $response->assertSessionHasErrors(\r\n        array $keys, $format = null, $errorBag = 'default'\r\n    );\r\n\r\n例如，要断言 `name` 和 `email` 字段具有已闪存到 session 的验证错误消息，可以调用 `assertSessionHasErrors` 方法，如下所示：\r\n\r\n    $response->assertSessionHasErrors(['name', 'email']);\r\n\r\n或者，你可以断言给定字段具有特定的验证错误消息：\r\n\r\n    $response->assertSessionHasErrors([\r\n        'name' => 'The given name was invalid.'\r\n    ]);\r\n\r\n> **注意**\r\n> 更加通用的 [assertInvalid](#assert-invalid) 方法可以用来断言一个响应有验证错误，以JSON形式返回，**或** 将错误被闪存到会话存储中。\r\n\r\n<a name=\"assert-session-has-errors-in\"></a>\r\n#### assertSessionHasErrorsIn\r\n\r\n断言会话在特定的[错误包](/docs/laravel/10.x/validation#named-error-bags)中包含给定 `$keys` 的错误。如果 `$keys` 是一个关联数组，则断言该 session 在错误包内包含每个字段（键）的特定错误消息（值）：\r\n\r\n    $response->assertSessionHasErrorsIn($errorBag, $keys = [], $format = null);\r\n\r\n<a name=\"assert-session-has-no-errors\"></a>\r\n#### assertSessionHasNoErrors\r\n\r\n断言 session 没有验证错误：\r\n\r\n    $response->assertSessionHasNoErrors();\r\n\r\n<a name=\"assert-session-doesnt-have-errors\"></a>\r\n#### assertSessionDoesntHaveErrors\r\n\r\n断言会话对给定键没有验证错误：\r\n\r\n    $response->assertSessionDoesntHaveErrors($keys = [], $format = null, $errorBag = 'default');\r\n\r\n> **注意**\r\n> 更加通用的 [assertValid](#assert-valid) 方法可以用来断言一个响应没有以JSON形式返回的验证错误，**同时** 不会将错误被闪存到会话存储中。\r\n\r\n<a name=\"assert-session-missing\"></a>\r\n#### assertSessionMissing\r\n\r\n断言 session 中缺少指定的 $key：\r\n\r\n    $response->assertSessionMissing($key);\r\n\r\n<a name=\"assert-status\"></a>\r\n#### assertStatus\r\n\r\n断言响应指定的 http 状态码：\r\n\r\n    $response->assertStatus($code);\r\n\r\n<a name=\"assert-successful\"></a>\r\n#### assertSuccessful\r\n\r\n断言响应一个成功的状态码 (>= 200 且 < 300) :\r\n\r\n    $response->assertSuccessful();\r\n\r\n<a name=\"assert-unauthorized\"></a>\r\n#### assertUnauthorized\r\n\r\n断言一个未认证的状态码 (401)：\r\n\r\n    $response->assertUnauthorized();\r\n\r\n<a name=\"assert-unprocessable\"></a>\r\n#### assertUnprocessable\r\n\r\n断言响应具有不可处理的实体 (422) HTTP 状态代码：\r\n\r\n    $response->assertUnprocessable();\r\n\r\n<a name=\"assert-valid\"></a>\r\n#### assertValid\r\n\r\n断言响应对给定键没有验证错误。此方法可用于断言验证错误作为 JSON 结构返回或验证错误已闪现到会话的响应：\r\n\r\n    // 断言不存在验证错误...\r\n    $response->assertValid();\r\n\r\n    // 断言给定的键没有验证错误...\r\n    $response->assertValid(['name', 'email']);\r\n\r\n<a name=\"assert-invalid\"></a>\r\n#### assertInvalid\r\n\r\n断言响应对给定键有验证错误。此方法可用于断言验证错误作为 JSON 结构返回或验证错误已闪存到会话的响应：\r\n\r\n    $response->assertInvalid(['name', 'email']);\r\n\r\n你还可以断言给定键具有特定的验证错误消息。这样做时，你可以提供整条消息或仅提供一部分消息：\r\n\r\n    $response->assertInvalid([\r\n        'name' => 'The name field is required.',\r\n        'email' => 'valid email address',\r\n    ]);\r\n\r\n<a name=\"assert-view-has\"></a>\r\n#### assertViewHas\r\n\r\n断言为响应视图提供了一个键值对数据：\r\n\r\n    $response->assertViewHas($key, $value = null);\r\n\r\n将闭包作为第二个参数传递给 `assertViewHas` 方法将允许你检查并针对特定的视图数据做出断言：\r\n\r\n    $response->assertViewHas('user', function (User $user) {\r\n        return $user->name === 'Taylor';\r\n    });\r\n\r\n此外，视图数据可以作为数组变量访问响应，让你可以方便地检查它：\r\n\r\n    $this->assertEquals('Taylor', $response['name']);\r\n\r\n<a name=\"assert-view-has-all\"></a>\r\n#### assertViewHasAll\r\n\r\n断言响应视图具有给定的数据列表：\r\n\r\n    $response->assertViewHasAll(array $data);\r\n\r\n该方法可用于断言该视图仅包含与给定键匹配的数据：\r\n\r\n    $response->assertViewHasAll([\r\n        'name',\r\n        'email',\r\n    ]);\r\n\r\n或者，你可以断言该视图数据存在并且具有特定值：\r\n\r\n    $response->assertViewHasAll([\r\n        'name' => 'Taylor Otwell',\r\n        'email' => 'taylor@example.com,',\r\n    ]);\r\n\r\n<a name=\"assert-view-is\"></a>\r\n#### assertViewIs\r\n\r\n断言当前路由返回的的视图是给定的视图：\r\n\r\n    $response->assertViewIs($value);\r\n\r\n<a name=\"assert-view-missing\"></a>\r\n#### assertViewMissing\r\n\r\n断言给定的数据键不可用于应用程序响应中返回的视图：\r\n\r\n    $response->assertViewMissing($key);\r\n\r\n<a name=\"authentication-assertions\"></a>\r\n### 身份验证断言\r\n\r\nLaravel 还提供了各种与身份验证相关的断言，你可以在应用程序的功能测试中使用它们。请注意，这些方法是在测试类本身上调用的，而不是由诸如 `get` 和 `post` 等方法返回的 `Illuminate\\Testing\\TestResponse` 实例。\r\n\r\n<a name=\"assert-authenticated\"></a>\r\n#### assertAuthenticated\r\n\r\n断言用户已通过身份验证：\r\n\r\n    $this->assertAuthenticated($guard = null);\r\n\r\n<a name=\"assert-guest\"></a>\r\n#### assertGuest\r\n\r\n断言用户未通过身份验证：\r\n\r\n    $this->assertGuest($guard = null);\r\n\r\n<a name=\"assert-authenticated-as\"></a>\r\n#### assertAuthenticatedAs\r\n\r\n断言特定用户已通过身份验证：\r\n\r\n    $this->assertAuthenticatedAs($user, $guard = null);\r\n\r\n<a name=\"validation-assertions\"></a>\r\n## 验证断言\r\n\r\nLaravel 提供了两个主要的验证相关的断言，你可以用它来确保在你的请求中提供的数据是有效或无效的。\r\n\r\n<a name=\"validation-assert-valid\"></a>\r\n#### assertValid\r\n\r\n断言响应对于给定的键没有验证错误。该方法可用于断言响应中的验证错误是以 JSON 结构返回的，或者验证错误已经闪现到会话中。\r\n\r\n    // 断言没有验证错误存在...\r\n    $response->assertValid();\r\n\r\n    //断言给定的键没有验证错误...\r\n    $response->assertValid(['name', 'email']);\r\n\r\n<a name=\"validation-assert-invalid\"></a>\r\n#### assertInvalid\r\n\r\n断言响应对给定的键有验证错误。这个方法可用于断言响应中的验证错误是以 JSON 结构返回的，或者验证错误已经被闪现到会话中。\r\n\r\n    $response->assertInvalid(['name', 'email']);\r\n\r\n你也可以断言一个给定的键有一个特定的验证错误信息。当这样做时，你可以提供整个消息或只提供消息的一小部分。\r\n\r\n    $response->assertInvalid([\r\n        'name' => 'The name field is required.',\r\n        'email' => 'valid email address',\r\n    ]);","p":"docs/http-tests.html"},{"t":"console-tests (控制台测试)","d":"\n# 控制台测试\r\n\r\n- [介绍](#introduction)\r\n- [期望成功/失败](#success-failure-expectations)\r\n- [期望输入/输出](#input-output-expectations)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n除了简化 HTTP 测试之外，Laravel 还提供了一个简单的 API 来测试应用程序的 [自定义控制台命令](/docs/laravel/10.x/artisan)。\r\n\r\n<a name=\"success-failure-expectations\"></a>\r\n## 期望成功/失败\r\n\r\n首先，让我们探索如何对 Artisan 命令的退出代码进行断言。为此，我们将使用 `artisan` 方法从我们的测试中调用 Artisan 命令。然后，我们将使用 `assertExitCode` 方法断言该命令以给定的退出代码完成：\r\n\r\n    /**\r\n     * 测试控制台命令。\r\n     */\r\n    public function test_console_command(): void\r\n    {\r\n        $this->artisan('inspire')->assertExitCode(0);\r\n    }\r\n\r\n你可以使用 `assertNotExitCode` 方法断言命令没有以给定的退出代码退出：\r\n\r\n    $this->artisan('inspire')->assertNotExitCode(1);\r\n\r\n当然，所有终端命令通常在成功时以 `0` 状态码退出，在不成功时以非零退出码退出。因此，为方便起见，你可以使用 `assertSuccessful` 和 `assertFailed` 断言来断言给定命令是否以成功的退出代码退出：\r\n\r\n    $this->artisan('inspire')->assertSuccessful();\r\n\r\n    $this->artisan('inspire')->assertFailed();\r\n\r\n<a name=\"input-output-expectations\"></a>\r\n## 期望输入/输出\r\n\r\nLaravel 允许你使用 `expectsQuestion` 方法轻松 「mock」控制台命令的用户输入。此外，你可以使用 `assertExitCode` 和 `expectsOutput` 方法指定你希望通过控制台命令输出的退出代码和文本。例如，考虑以下控制台命令：\r\n\r\n    Artisan::command('question', function () {\r\n        $name = $this->ask('What is your name?');\r\n\r\n        $language = $this->choice('Which language do you prefer?', [\r\n            'PHP',\r\n            'Ruby',\r\n            'Python',\r\n        ]);\r\n\r\n        $this->line('Your name is '.$name.' and you prefer '.$language.'.');\r\n    });\r\n\r\n\n\n你可以用下面的测试来测试这个命令，该测试利用了 `expectsQuestion`、`expectsOutput`、`doesntExpectOutput`、`expectsOutputToContain`、`doesntExpectOutputToContain` 和 `assertExitCode` 方法。\r\n\r\n    /**\r\n     * 测试控制台命令。\r\n     */\r\n    public function test_console_command(): void\r\n    {\r\n        $this->artisan('question')\r\n             ->expectsQuestion('What is your name?', 'Taylor Otwell')\r\n             ->expectsQuestion('Which language do you prefer?', 'PHP')\r\n             ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')\r\n             ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')\r\n             ->expectsOutputToContain('Taylor Otwell')\r\n             ->doesntExpectOutputToContain('you prefer Ruby')\r\n             ->assertExitCode(0);\r\n    }\r\n\r\n<a name=\"confirmation-expectations\"></a>\r\n#### 确认期望\r\n\r\n当编写一个期望以「是」或「否」答案形式确认的命令时，你可以使用 `expectsConfirmation` 方法：\r\n\r\n    $this->artisan('module:import')\r\n        ->expectsConfirmation('Do you really wish to run this command?', 'no')\r\n        ->assertExitCode(1);\r\n\r\n<a name=\"table-expectations\"></a>\r\n#### 表格期望\r\n\r\n如果你的命令使用 Artisan 的 `table` 方法显示信息表，则为整个表格编写输出预期会很麻烦。相反，你可以使用 `expectsTable` 方法。此方法接受表格的标题作为它的第一个参数和表格的数据作为它的第二个参数：\r\n\r\n    $this->artisan('users:all')\r\n        ->expectsTable([\r\n            'ID',\r\n            'Email',\r\n        ], [\r\n            [1, 'taylor@example.com'],\r\n            [2, 'abigail@example.com'],\r\n        ]);\r\n\n","p":"docs/console-tests.html"},{"t":"dusk (Laravel Dusk)","d":"# Laravel Dusk\r\n\r\n- [介绍](#introduction)\r\n- [安装](#installation)\r\n  - [管理 ChromeDriver 安装](#managing-chromedriver-installations)\r\n  - [使用其他浏览器](#using-other-browsers)\r\n- [入门](#getting-started)\r\n  - [生成测试](#generating-tests)\r\n  - [每个测试后重置数据库](#resetting-the-database-after-each-test)\r\n  - [运行测试](#running-tests)\r\n  - [环境处理](#environment-handling)\r\n- [浏览器基础知识](#browser-basics)\r\n  - [创建浏览器](#creating-browsers)\r\n  - [导航](#navigation)\r\n  - [调整浏览器窗口大小](#resizing-browser-windows)\r\n  - [浏览器宏](#browser-macros)\r\n  - [认证](#authentication)\r\n  - [Cookies](#cookies)\r\n  - [执行 JavaScript](#executing-javascript)\r\n  - [截屏](#taking-a-screenshot)\r\n  - [将控制台输出存储到磁盘](#storing-console-output-to-disk)\r\n  - [将页面源代码存储到磁盘](#storing-page-source-to-disk)\r\n- [与元素交互](#interacting-with-elements)\r\n  - [Dusk 选择器](#dusk-selectors)\r\n  - [文本、值和属性](#text-values-and-attributes)\r\n  - [与表单交互](#interacting-with-forms)\r\n  - [上传文件](#attaching-files)\r\n  - [点击按钮](#pressing-buttons)\r\n  - [点击链接](#clicking-links)\r\n  - [使用键盘](#using-the-keyboard)\r\n  - [使用鼠标](#using-the-mouse)\r\n  - [JavaScript 对话框](#javascript-dialogs)\r\n  - [选择器作用域](#scoping-selectors)\r\n  - [等待元素](#waiting-for-elements)\r\n  - [滚动元素到视图](#scrolling-an-element-into-view)\r\n- [可用的断言](#available-assertions)\r\n- [页面](#pages)\r\n  - [生成页面](#generating-pages)\r\n  - [配置页面](#configuring-pages)\r\n  - [导航到页面](#navigating-to-pages)\r\n  - [速记选择器](#shorthand-selectors)\r\n  - [页面方法](#page-methods)\r\n- [组件](#components)\r\n  - [生成组件](#generating-components)\r\n  - [使用组件](#using-components)\r\n- [持续集成](#continuous-integration)\r\n  - [Heroku CI](#running-tests-on-heroku-ci)\r\n  - [Travis CI](#running-tests-on-travis-ci)\r\n  - [GitHub Actions](#running-tests-on-github-actions)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Dusk](https://github.com/laravel/dusk) 提供了一套富有表现力、易于使用的浏览器自动化和测试 API。默认情况下，Dusk 不需要在本地计算机上安装 JDK 或 Selenium。相反，Dusk 使用一个独立的 [ChromeDriver](https://sites.google.com/chromium.org/driver) 安装包。你可以自由地使用任何其他兼容 Selenium 的驱动程序。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n为了开始使用，你需要先安装 [Google Chrome](https://www.google.com/chrome) 并将 `laravel/dusk` Composer 依赖添加到你的项目中：\r\n\r\n```shell\r\ncomposer require --dev laravel/dusk\r\n```\r\n\r\n> **警告**\r\n> 如果你手动注册 Dusk 的服务提供者，在生产环境中 **绝不要** 注册，因为这可能导致任意用户能够认证你的应用程序。\r\n\r\n安装 Dusk 包后，执行 `dusk:install` Artisan 命令。`dusk:install` 命令将会创建一个 `tests/Browser` 目录，一个示例 Dusk 测试，并为你的操作系统安装 Chrome 驱动程序二进制文件：\r\n\r\n```shell\r\nphp artisan dusk:install\r\n```\r\n\r\n接下来，在应用程序的 `.env` 文件中设置 `APP_URL` 环境变量。该值应该与你用于在浏览器中访问应用程序的 URL 匹配。\r\n\r\n> **注意**\r\n> 如果你正在使用 [Laravel Sail](/docs/laravel/10.x/sail) 管理你的本地开发环境，请参阅 Sail 文档中有关[配置和运行 Dusk 测试](/docs/laravel/10.x/sail#laravel-dusk)的内容。\r\n\r\n<a name=\"managing-chromedriver-installations\"></a>\r\n### 管理 ChromeDriver 安装\r\n\r\n如果你想安装与 Laravel Dusk 通过 `dusk:install` 命令安装的不同版本的 ChromeDriver，则可以使用 `dusk:chrome-driver` 命令：\r\n\r\n```shell\r\n# 为你的操作系统安装最新版本的 ChromeDriver...\r\nphp artisan dusk:chrome-driver\r\n\r\n# 为你的操作系统安装指定版本的 ChromeDriver...\r\nphp artisan dusk:chrome-driver 86\r\n\r\n# 为所有支持的操作系统安装指定版本的 ChromeDriver...\r\nphp artisan dusk:chrome-driver --all\r\n\r\n# 为你的操作系统安装与 Chrome / Chromium 检测到的版本匹配的 ChromeDriver...\r\nphp artisan dusk:chrome-driver --detect\r\n```\r\n\r\n> **警告**\r\n> Dusk 需要 `chromedriver` 二进制文件可执行。如果你无法运行 Dusk，你应该使用以下命令确保二进制文件可执行：`chmod -R 0755 vendor/laravel/dusk/bin/`。\r\n\r\n<a name=\"using-other-browsers\"></a>\r\n### 使用其他浏览器\r\n\r\n默认情况下，Dusk 使用 Google Chrome 和独立的 [ChromeDriver](https://sites.google.com/chromium.org/driver) 安装来运行你的浏览器测试。但是，你可以启动自己的 Selenium 服务器，并运行你希望的任何浏览器来运行测试。\r\n\r\n要开始，请打开你的 `tests/DuskTestCase.php` 文件，该文件是你的应用程序的基本 Dusk 测试用例。在这个文件中，你可以删除对 `startChromeDriver` 方法的调用。这将停止 Dusk 自动启动 ChromeDriver：\r\n\r\n    /**\r\n     * 准备执行 Dusk 测试。\r\n     *\r\n     * @beforeClass\r\n     */\r\n    public static function prepare(): void\r\n    {\r\n        // static::startChromeDriver();\r\n    }\r\n\r\n接下来，你可以修改 `driver` 方法来连接到你选择的 URL 和端口。此外，你可以修改应该传递给 WebDriver 的“期望能力”：\r\n\r\n    use Facebook\\WebDriver\\Remote\\RemoteWebDriver;\r\n\r\n    /**\r\n     * 创建 RemoteWebDriver 实例。\r\n     */\r\n    protected function driver(): RemoteWebDriver\r\n    {\r\n        return RemoteWebDriver::create(\r\n            'http://localhost:4444/wd/hub', DesiredCapabilities::phantomjs()\r\n        );\r\n    }\r\n\r\n<a name=\"getting-started\"></a>\r\n## 入门\r\n\r\n<a name=\"generating-tests\"></a>\r\n### 生成测试\r\n\r\n要生成 Dusk 测试，请使用 `dusk:make` Artisan 命令。生成的测试将放在 `tests/Browser` 目录中：\r\n\r\n```shell\r\nphp artisan dusk:make LoginTest\r\n```\r\n\r\n<a name=\"resetting-the-database-after-each-test\"></a>\r\n\r\n### 在每次测试后重置数据库\r\n\r\n你编写的大多数测试将与从应用程序数据库检索数据的页面交互；然而，你的 Dusk 测试不应该使用 `RefreshDatabase` trait。`RefreshDatabase` trait 利用数据库事务，这些事务将不适用或不可用于 HTTP 请求。相反，你有两个选项：`DatabaseMigrations` trait 和 `DatabaseTruncation` trait。\r\n\r\n<a name=\"reset-migrations\"></a>\r\n#### 使用数据库迁移\r\n\r\n`DatabaseMigrations` trait 会在每次测试之前运行你的数据库迁移。但是，为了每次测试而删除和重新创建数据库表通常比截断表要慢：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Foundation\\Testing\\DatabaseMigrations;\r\n    use Laravel\\Dusk\\Chrome;\r\n    use Tests\\DuskTestCase;\r\n\r\n    class ExampleTest extends DuskTestCase\r\n    {\r\n        use DatabaseMigrations;\r\n    }\r\n\r\n> **警告**\r\n> 当执行 Dusk 测试时，不能使用 SQLite 内存数据库。由于浏览器在其自己的进程中执行，因此它将无法访问其他进程的内存数据库。\r\n\r\n<a name=\"reset-truncation\"></a>\r\n#### 使用数据库截断\r\n\r\n在使用 `DatabaseTruncation` trait 之前，你必须使用 Composer 包管理器安装 `doctrine/dbal` 包：\r\n\r\n```shell\r\ncomposer require --dev doctrine/dbal\r\n```\r\n\r\n`DatabaseTruncation` trait 将在第一次测试时迁移你的数据库，以确保你的数据库表已经被正确创建。但是，在后续测试中，数据库表将仅被截断 - 相比重新运行所有的数据库迁移，这样做可以提高速度：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Foundation\\Testing\\DatabaseTruncation;\r\n    use Laravel\\Dusk\\Chrome;\r\n    use Tests\\DuskTestCase;\r\n\r\n    class ExampleTest extends DuskTestCase\r\n    {\r\n        use DatabaseTruncation;\r\n    }\r\n\r\n\r\n默认情况下，此 trait 将截断除 `migrations` 表以外的所有表。如果你想自定义应该截断的表，则可以在测试类上定义 `$tablesToTruncate` 属性：\r\n\r\n    /**\r\n     * 表示应该截断哪些表。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $tablesToTruncate = ['users'];\r\n\r\n\r\n或者，你可以在测试类上定义 `$exceptTables` 属性，以指定应该从截断中排除的表：\r\n\r\n    /**\r\n     * 表示应该从截断中排除哪些表。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $exceptTables = ['users'];\r\n\r\n\r\n为了指定需要清空表格的数据库连接，你可以在测试类中定义一个 `$connectionsToTruncate` 属性：\r\n\r\n    /**\r\n     * 表示哪些连接需要清空表格。\r\n     *\r\n     * @var array\r\n     */\r\n    protected $connectionsToTruncate = ['mysql'];\r\n\r\n<a name=\"running-tests\"></a>\r\n\r\n### 运行测试\r\n\r\n要运行浏览器测试，执行 `dusk` Artisan 命令：\r\n\r\n```shell\r\nphp artisan dusk\r\n```\r\n\r\n如果上一次运行 `dusk` 命令时出现了测试失败，你可以通过 `dusk:fails` 命令先重新运行失败的测试，以节省时间：\r\n\r\n```shell\r\nphp artisan dusk:fails\r\n```\r\n\r\n`dusk` 命令接受任何 PHPUnit 测试运行器通常接受的参数，例如你可以只运行给定[组](https://phpunit.readthedocs.io/en/9.5/annotations.html#group)的测试：\r\n\r\n```shell\r\nphp artisan dusk --group=foo\r\n```\r\n\r\n> **注意**\r\n> 如果你正在使用 [Laravel Sail](/docs/laravel/10.x/sail) 来管理本地开发环境，请参考 Sail 文档中有关[配置和运行 Dusk 测试](/docs/laravel/10.x/sail#laravel-dusk)的部分。\r\n\r\n<a name=\"manually-starting-chromedriver\"></a>\r\n#### 手动启动 ChromeDriver\r\n\r\n默认情况下，Dusk 会自动尝试启动 ChromeDriver。如果对于你的特定系统无法自动启动，你可以在运行 `dusk` 命令之前手动启动 ChromeDriver。如果你选择手动启动 ChromeDriver，则应该注释掉 `tests/DuskTestCase.php` 文件中的以下代码：\r\n\r\n    /**\r\n     * 为 Dusk 测试执行做准备。\r\n     *\r\n     * @beforeClass\r\n     */\r\n    public static function prepare(): void\r\n    {\r\n        // static::startChromeDriver();\r\n    }\r\n\r\n此外，如果你在端口 9515 以外的端口上启动 ChromeDriver，你需要修改同一类中的 `driver` 方法以反映正确的端口：\r\n\r\n    use Facebook\\WebDriver\\Remote\\RemoteWebDriver;\r\n\r\n    /**\r\n     * 创建 RemoteWebDriver 实例。\r\n     */\r\n    protected function driver(): RemoteWebDriver\r\n    {\r\n        return RemoteWebDriver::create(\r\n            'http://localhost:9515', DesiredCapabilities::chrome()\r\n        );\r\n    }\r\n\r\n<a name=\"environment-handling\"></a>\r\n### 环境处理\r\n\r\n如果要在运行测试时强制 Dusk 使用自己的环境文件，请在项目根目录中创建一个 `.env.dusk.{当前环境}` 文件。例如，如果你将从你的 `local` 环境启动 `dusk` 命令，你应该创建一个 `.env.dusk.local` 文件。\r\n\r\n在运行测试时，Dusk 将备份你的 `.env` 文件，并将你的 Dusk 环境重命名为 `.env`。测试完成后，会将你的 `.env` 文件还原。\r\n\r\n<a name=\"browser-basics\"></a>\r\n## 浏览器基础知识\r\n\r\n<a name=\"creating-browsers\"></a>\r\n### 创建浏览器\r\n\r\n为了开始学习，我们编写一个测试，验证我们能否登录到我们的应用程序。生成测试后，我们可以修改它以导航到登录页面，输入一些凭据并点击“登录”按钮。为了创建一个浏览器实例，你可以在 Dusk 测试中调用 `browse` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser;\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Foundation\\Testing\\DatabaseMigrations;\r\n    use Laravel\\Dusk\\Browser;\r\n    use Laravel\\Dusk\\Chrome;\r\n    use Tests\\DuskTestCase;\r\n\r\n    class ExampleTest extends DuskTestCase\r\n    {\r\n        use DatabaseMigrations;\r\n\r\n        /**\r\n         * 一个基本的浏览器测试示例。\r\n         */\r\n        public function test_basic_example(): void\r\n        {\r\n            $user = User::factory()->create([\r\n                'email' => 'taylor@laravel.com',\r\n            ]);\r\n\r\n            $this->browse(function (Browser $browser) use ($user) {\r\n                $browser->visit('/login')\r\n                        ->type('email', $user->email)\r\n                        ->type('password', 'password')\r\n                        ->press('Login')\r\n                        ->assertPathIs('/home');\r\n            });\r\n        }\r\n    }\r\n\r\n如上面的例子所示，`browse` 方法接受一个闭包。浏览器实例将由 Dusk 自动传递给此闭包，并且是与应用程序交互和进行断言的主要对象。\r\n\r\n<a name=\"creating-multiple-browsers\"></a>\r\n#### 创建多个浏览器\r\n\r\n有时你可能需要多个浏览器来正确地进行测试。例如，测试与 WebSockets 交互的聊天屏幕可能需要多个浏览器。要创建多个浏览器，只需将更多的浏览器参数添加到传递给 `browse` 方法的闭包签名中即可：\r\n\r\n    $this->browse(function (Browser $first, Browser $second) {\r\n        $first->loginAs(User::find(1))\r\n              ->visit('/home')\r\n              ->waitForText('Message');\r\n\r\n        $second->loginAs(User::find(2))\r\n               ->visit('/home')\r\n               ->waitForText('Message')\r\n               ->type('message', 'Hey Taylor')\r\n               ->press('Send');\r\n\r\n        $first->waitForText('Hey Taylor')\r\n              ->assertSee('Jeffrey Way');\r\n    });\r\n\r\n<a name=\"navigation\"></a>\r\n### 导航\r\n\r\n`visit` 方法可用于在应用程序中导航到给定的 URI：\r\n\r\n    $browser->visit('/login');\r\n\r\n你可以使用 `visitRoute` 方法来导航到 [命名路由](/docs/laravel/10.x/routing#named-routes)：\r\n\r\n    $browser->visitRoute('login');\r\n\r\n你可以使用 `back` 和 `forward` 方法来导航「后退」和「前进」：\r\n\r\n    $browser->back();\r\n\r\n    $browser->forward();\r\n\r\n你可以使用 `refresh` 方法来刷新页面：\r\n\r\n    $browser->refresh();\r\n\r\n<a name=\"resizing-browser-windows\"></a>\r\n\r\n### 调整浏览器窗口大小\r\n\r\n你可以使用 `resize` 方法来调整浏览器窗口的大小：\r\n\r\n    $browser->resize(1920, 1080);\r\n\r\n你可以使用 `maximize` 方法来最大化浏览器窗口：\r\n\r\n    $browser->maximize();\r\n\r\n`fitContent` 方法将调整浏览器窗口的大小以匹配其内容的大小：\r\n\r\n    $browser->fitContent();\r\n\r\n当测试失败时，Dusk 将在截取屏幕截图之前自动调整浏览器大小以适合内容。你可以在测试中调用 `disableFitOnFailure` 方法来禁用此功能：\r\n\r\n    $browser->disableFitOnFailure();\r\n\r\n你可以使用`move`方法将浏览器窗口移动到屏幕上的其他位置：\r\n\r\n    $browser->move($x = 100, $y = 100);\r\n\r\n<a name=\"browser-macros\"></a>\r\n### 浏览器宏\r\n\r\n如果你想定义一个可以在各种测试中重复使用的自定义浏览器方法，可以在`Browser`类中使用`macro`方法。通常，你应该从[服务提供者](/docs/laravel/10.x/providers)的`boot`方法中调用它：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Laravel\\Dusk\\Browser;\r\n\r\n    class DuskServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * 注册 《Dusk》 的浏览器宏。\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Browser::macro('scrollToElement', function (string $element = null) {\r\n                $this->script(\"$('html, body').animate({ scrollTop: $('$element').offset().top }, 0);\");\r\n\r\n                return $this;\r\n            });\r\n        }\r\n    }\r\n\r\n该 `macro` 函数接收方法名作为其第一个参数，并接收闭包作为其第二个参数。 将宏作为`Browser`实现上的方法调用宏时，将执行宏的闭包：\r\n\r\n    $this->browse(function (Browser $browser) use ($user) {\r\n        $browser->visit('/pay')\r\n                ->scrollToElement('#credit-card-details')\r\n                ->assertSee('Enter Credit Card Details');\r\n    });\r\n\r\n<a name=\"authentication\"></a>\r\n### 用户认证\r\n\r\n我们经常会测试需要身份验证的页面，你可以使用 Dusk 的`loginAs`方法来避免在每次测试期间与登录页面进行交互。该`loginAs`方法接收用户 ID 或者用户模型实例\r\n\r\n    use App\\Models\\User;\r\n    use Laravel\\Dusk\\Browser;\r\n\r\n    $this->browse(function (Browser $browser) {\r\n        $browser->loginAs(User::find(1))\r\n              ->visit('/home');\r\n    });\r\n\r\n> **注意**\r\n> 使用`loginAs`方法后，用户会话在文件中的所有测试被维护。\r\n\r\n\r\n\r\n<a name=\"cookies\"></a>\r\n### Cookies\r\n\r\n你可以使用`cookie`方法来获取或者设置加密过的 cookie 的值：\r\n\r\n    $browser->cookie('name');\r\n\r\n    $browser->cookie('name', 'Taylor');\r\n\r\n使用`plainCookie`则可以获取或者设置未加密过的 cookie 的值：\r\n\r\n    $browser->plainCookie('name');\r\n\r\n    $browser->plainCookie('name', 'Taylor');\r\n\r\n你可以使用`deleteCookie`方法删除指定的 cookie：\r\n\r\n    $browser->deleteCookie('name');\r\n\r\n<a name=\"executing-javascript\"></a>\r\n### 运行 JavaScript\r\n\r\n可以使用`script`方法在浏览器中执行任意 JavaScript 语句：\r\n\r\n    $browser->script('document.documentElement.scrollTop = 0');\r\n\r\n    $browser->script([\r\n        'document.body.scrollTop = 0',\r\n        'document.documentElement.scrollTop = 0',\r\n    ]);\r\n\r\n    $output = $browser->script('return window.location.pathname');\r\n\r\n<a name=\"taking-a-screenshot\"></a>\r\n### 获取截图\r\n\r\n你可以使用`screenshot`方法来截图并将其指定文件名存储，所有截图都将存放在`tests/Browser/screenshots`目录下：\r\n\r\n    $browser->screenshot('filename');\r\n\r\n`responsiveScreenshots`方法可用于在不同断点处截取一系列截图:\r\n\r\n    $browser->responsiveScreenshots('filename');\r\n\r\n<a name=\"storing-console-output-to-disk\"></a>\r\n### 控制台输出结果保存到硬盘\r\n\r\n你可以使用`storeConsoleLog`方法将控制台输出指定文件名并写入磁盘，控制台输出默认存放在`tests/Browser/console`目录下：\r\n\r\n    $browser->storeConsoleLog('filename');\r\n\r\n<a name=\"storing-page-source-to-disk\"></a>\r\n### 页面源码保存到硬盘\r\n\r\n你可以使用`storeSource`方法将页面当前源代码指定文件名并写入磁盘，页面源代码默认会存放到`tests/Browser/source`目录：\r\n\r\n    $browser->storeSource('filename');\r\n\r\n<a name=\"interacting-with-elements\"></a>\r\n## 与元素交互\r\n\r\n<a name=\"dusk-selectors\"></a>\r\n### Dusk 选择器\r\n\r\n编写 Dusk 测试最困难的部分之一就是选择良好的 CSS 选择器与元素进行交互。 随着时间的推移，前端的更改可能会导致如下所示的 CSS 选择器无法通过测试：\r\n\r\n    // HTML...\r\n\r\n    <button>Login</button>\r\n\r\n    // Test...\r\n\r\n    $browser->click('.login-page .container div > button');\r\n\r\nDusk 选择器可以让你专注于编写有效的测试，而不必记住 CSS 选择器。要定义一个选择器，你需要添加一个`dusk`属性在 HTML 元素中。然后在选择器前面加上`@`用来在 Dusk 测试中操作元素：\r\n\r\n    // HTML...\r\n\r\n    <button dusk=\"login-button\">Login</button>\r\n\r\n    // Test...\r\n\r\n    $browser->click('@login-button');\r\n\r\n<a name=\"text-values-and-attributes\"></a>\r\n### 文本、值 & 属性\r\n\r\n<a name=\"retrieving-setting-values\"></a>\r\n#### 获取 & 设置值\r\n\r\nDusk 提供了多个方法用于和页面元素的当前显示文本、值和属性进行交互，例如，要获取匹配指定选择器的元素的「值」，使用`value`方法：\r\n\r\n    // 获取值...\r\n    $value = $browser->value('selector');\r\n\r\n    // 设置值...\r\n    $browser->value('selector', 'value');\r\n\r\n你可以使用`inputValue`方法来获取包含指定字段名称的输入元素的「值」：\r\n\r\n    $value = $browser->inputValue('field');\r\n\r\n<a name=\"retrieving-text\"></a>\r\n#### 获取文本\r\n\r\n该`text`方法可以用于获取匹配指定选择器元素文本：\r\n\r\n    $text = $browser->text('selector');\r\n\r\n<a name=\"retrieving-attributes\"></a>\r\n#### 获取属性\r\n\r\n最后，该`attribute`方法可以用于获取匹配指定选择器元素属性：\r\n\r\n    $attribute = $browser->attribute('selector', 'value');\r\n\r\n<a name=\"interacting-with-forms\"></a>\r\n### 使用表单\r\n\r\n<a name=\"typing-values\"></a>\r\n#### 输入值\r\n\r\nDusk 提供了多种方法来与表单和输入元素进行交互。首先，让我们看一个在字段中输入值的示例：\r\n\r\n    $browser->type('email', 'taylor@laravel.com');\r\n\r\n注意，尽管该方法在需要时接收，但是我们不需要将 CSS 选择器传递给`type`方法。如果没有提供 CSS 选择器，Dusk 会搜索包含指定`name`属性的`input`或`textarea`字段。\r\n\r\n要想将文本附加到一个字段之后而且不清除其内容， 你可以使用`append`方法：\r\n\r\n    $browser->type('tags', 'foo')\r\n            ->append('tags', ', bar, baz');\r\n\r\n你可以使用`clear`方法清除输入值：\r\n\r\n    $browser->clear('email');\r\n\r\n你可以使用`typeSlowly`方法指示 Dusk 缓慢键入。 默认情况下，Dusk 在两次按键之间将暂停 100 毫秒。 要自定义按键之间的时间量，你可以将适当的毫秒数作为方法的第二个参数传递：\r\n\r\n    $browser->typeSlowly('mobile', '+1 (202) 555-5555');\r\n\r\n    $browser->typeSlowly('mobile', '+1 (202) 555-5555', 300);\r\n\r\n你可以使用`appendSlowly`方法缓慢添加文本：\r\n\r\n    $browser->type('tags', 'foo')\r\n            ->appendSlowly('tags', ', bar, baz');\r\n\r\n<a name=\"dropdowns\"></a>\r\n#### 下拉菜单\r\n\r\n需要在下拉菜单中选择值，你可以使用`select`方法。 类似于`type`方法， 该`select`方法并不是一定要传入 CSS 选择器。 当使用`select`方法时，你应该传递选项实际的值而不是它的显示文本：\r\n\r\n    $browser->select('size', 'Large');\r\n\r\n你也可以通过省略第二个参数来随机选择一个选项：\r\n\r\n    $browser->select('size');\r\n\r\n通过将数组作为`select`方法的第二个参数，可以指示该方法选择多个选项：\r\n\r\n    $browser->select('categories', ['Art', 'Music']);\r\n\r\n<a name=\"checkboxes\"></a>\r\n#### 复选框\r\n\r\n使用「check」 复选框时，你可以使用`check`方法。 像其他许多与 input 相关的方法，并不是必须传入 CSS 选择器。 如果准确的选择器无法找到的时候，Dusk 会搜索能够与`name`属性匹配的复选框：\r\n\r\n    $browser->check('terms');\r\n\r\n该`uncheck`方法可用于「取消选中」复选框输入：\r\n\r\n    $browser->uncheck('terms');\r\n\r\n<a name=\"radio-buttons\"></a>\r\n#### 单选按钮\r\n\r\n使用 「select」中单选按钮选项时，你可以使用`radio`这个方法。 像很多其他的与输入相关的方法一样， 它也并不是必须传入 CSS 选择器。如果准确的选择器无法被找到的时候， Dusk 会搜索能够与`name`属性或者`value`属性相匹配的`radio`单选按钮：\r\n\r\n    $browser->radio('size', 'large');\r\n\r\n<a name=\"attaching-files\"></a>\r\n### 附件\r\n\r\n该`attach`方法可以附加一个文件到`file`input 元素中。 像很多其他的与输入相关的方法一样，他也并不是必须传入 CSS 选择器。如果准确的选择器没有被找到的时候，Dusk 会搜索与`name`属性匹配的文件输入框：\r\n\r\n    $browser->attach('photo', __DIR__.'/photos/mountains.png');\r\n\r\n> **注意**\r\n> attach 方法需要使用 PHP`Zip`扩展，你的服务器必须安装了此扩展。\r\n\r\n<a name=\"pressing-buttons\"></a>\r\n### 点击按钮\r\n\r\n可以使用`press`方法来单击页面上的按钮元素。该`press`方法的第一个参数可以是按钮的显示文本，也可以是 CSS/ Dusk 选择器：\r\n\r\n    $browser->press('Login');\r\n\r\n提交表单时，许多应用程序在按下表单后会禁用表单的提交按钮，然后在表单提交的 HTTP 请求完成后重新启用该按钮。要按下按钮并等待按钮被重新启用，可以使用`pressAndWaitFor`方法：\r\n\r\n    // 按下按钮并等待最多5秒，它将被启用…\r\n    $browser->pressAndWaitFor('Save');\r\n\r\n    // 按下按钮并等待最多1秒，它将被启用…\r\n    $browser->pressAndWaitFor('Save', 1);\r\n\r\n<a name=\"clicking-links\"></a>\r\n### 点击链接\r\n\r\n要点击链接，可以在浏览器实例下使用`clickLink`方法。该`clickLink`方法将点击指定文本的链接：\r\n\r\n    $browser->clickLink($linkText);\r\n\r\n你可以使用`seeLink`方法来确定具有给定显示文本的链接在页面上是否可见：\r\n\r\n    if ($browser->seeLink($linkText)) {\r\n        // ...\r\n    }\r\n\r\n> **注意**\r\n> 这些方法与 jQuery 交互。 如果页面上没有 jQuery，Dusk 会自动将其注入到页面中，以便在测试期间可用。\r\n\r\n<a name=\"using-the-keyboard\"></a>\r\n### 使用键盘\r\n\r\n该`keys`方法让你可以再指定元素中输入比`type`方法更加复杂的输入序列。例如，你可以在输入值的同时按下按键。在这个例子中，输入`taylor`时，`shift`键也同时被按下。当`taylor`输入完之后， 将会输入`swift`而不会按下任何按键：\r\n\r\n    $browser->keys('selector', ['{shift}', 'taylor'], 'swift');\r\n\r\n`keys`方法的另一个有价值的用例是向你的应用程序的主要 CSS 选择器发送「键盘快捷键」组合：\r\n\r\n    $browser->keys('.app', ['{command}', 'j']);\r\n\r\n> **技巧**\r\n> 所有修饰符键如`{command}`都包裹在`{}`字符中，并且与在 `Facebook\\WebDriver\\WebDriverKeys`类中定义的常量匹配，该类可以[在 GitHub 上找到](https://github.com/php-webdriver/php-webdriver/blob/master/lib/WebDriverKeys.php).\r\n\r\n<a name=\"using-the-mouse\"></a>\r\n### 使用鼠标\r\n\r\n<a name=\"clicking-on-elements\"></a>\r\n#### 点击元素\r\n\r\n该`click`方法可用于「点击」与给定选择器匹配的元素：\r\n\r\n    $browser->click('.selector');\r\n\r\n该`clickAtXPath`方法可用于「单击」与给定 XPath 表达式匹配的元素：\r\n\r\n    $browser->clickAtXPath('//div[@class = \"selector\"]');\r\n\r\n该`clickAtPoint`方法可用于「点击」相对于浏览器可视区域的给定坐标对上的最高元素：\r\n\r\n    $browser->clickAtPoint($x = 0, $y = 0);\r\n\r\n该`doubleClick`方法可用于模拟鼠标的双击：\r\n\r\n    $browser->doubleClick();\r\n\r\n该`rightClick`方法可用于模拟鼠标的右击：\r\n\r\n    $browser->rightClick();\r\n\r\n    $browser->rightClick('.selector');\r\n\r\n该`clickAndHold`方法可用于模拟被单击并按住的鼠标按钮。 随后调用 `releaseMouse` 方法将撤消此行为并释放鼠标按钮：\r\n\r\n    $browser->clickAndHold()\r\n            ->pause(1000)\r\n            ->releaseMouse();\r\n\r\n<a name=\"mouseover\"></a>\r\n#### 鼠标悬停\r\n\r\n该`mouseover`方法可用于与给定选择器匹配的元素的鼠标悬停动作：\r\n\r\n    $browser->mouseover('.selector');\r\n\r\n<a name=\"drag-drop\"></a>\r\n#### 拖放\r\n\r\n该`drag`方法用于将与指定选择器匹配的元素拖到其它元素：\r\n\r\n    $browser->drag('.from-selector', '.to-selector');\r\n\r\n或者，可以在单一方向上拖动元素：\r\n\r\n    $browser->dragLeft('.selector', $pixels = 10);\r\n    $browser->dragRight('.selector', $pixels = 10);\r\n    $browser->dragUp('.selector', $pixels = 10);\r\n    $browser->dragDown('.selector', $pixels = 10);\r\n\r\n最后，你可以将元素拖动给定的偏移量：\r\n\r\n    $browser->dragOffset('.selector', $x = 10, $y = 10);\r\n\r\n<a name=\"javascript-dialogs\"></a>\r\n### JavaScript 对话框\r\n\r\nDusk 提供了各种与 JavaScript 对话框进行交互的方法。例如，你可以使用`waitForDialog`方法来等待 JavaScript 对话框的出现。此方法接受一个可选参数，该参数指示等待对话框出现多少秒：\r\n\r\n    $browser->waitForDialog($seconds = null);\r\n\r\n该`assertDialogOpened`方法，断言对话框已经显示，并且其消息与给定值匹配：\r\n\r\n    $browser->assertDialogOpened('Dialog message');\r\n\r\n`typeInDialog`方法，在打开的 JavaScript 提示对话框中输入给定值：\r\n\r\n    $browser->typeInDialog('Hello World');\r\n\r\n`acceptDialog`方法，通过点击确定按钮关闭打开的 JavaScript 对话框：\r\n\r\n    $browser->acceptDialog();\r\n\r\n`dismissDialog`方法，通过点击取消按钮关闭打开的 JavaScript 对话框（仅对确认对话框有效）：\r\n\r\n    $browser->dismissDialog();\r\n\r\n<a name=\"scoping-selectors\"></a>\r\n### 选择器作用范围\r\n\r\n有时可能希望在给定的选择器范围内执行多个操作。比如，可能想要断言表格中存在某些文本，然后点击表格中的一个按钮。那么你可以使用`with`方法实现此需求。在传递给`with`方法的闭包内执行的所有操作都将限于原始选择器：\r\n\r\n    $browser->with('.table', function (Browser $table) {\r\n        $table->assertSee('Hello World')\r\n              ->clickLink('Delete');\r\n    });\r\n\r\n你可能偶尔需要在当前范围之外执行断言。 你可以使用`elsewhere`和`elsewhereWhenAvailable`方法来完成此操作：\r\n\r\n     $browser->with('.table', function ($table) {\r\n        // 当前范围是 `body .table`...\r\n\r\n        $browser->elsewhere('.page-title', function ($title) {\r\n            // 当前范围是 `body .page-title`...\r\n            $title->assertSee('Hello World');\r\n        });\r\n\r\n        $browser->elsewhereWhenAvailable('.page-title', function ($title) {\r\n            // 当前范围是 `body .page-title`...\r\n            $title->assertSee('Hello World');\r\n        });\r\n     });\r\n\r\n<a name=\"waiting-for-elements\"></a>\r\n### 等待元素\r\n\r\n在测试大面积使用 JavaScript 的应用时，在进行测试之前，通常有必要 「等待」 某些元素或数据可用。Dusk 可轻松实现。使用一系列方法，可以等到页面元素可用，甚至给定的 JavaScript 表达式执行结果为`true`。\r\n\r\n<a name=\"waiting\"></a>\r\n#### 等待\r\n\r\n如果需要测试暂停指定的毫秒数， 使用`pause`方法：\r\n\r\n    $browser->pause(1000);\r\n\r\n如果你只需要在给定条件为`true`时暂停测试，请使用`pauseIf`方法:\r\n\r\n    $browser->pauseIf(App::environment('production'), 1000);\r\n\r\n同样地，如果你需要暂停测试，除非给定的条件是`true`，你可以使用`pauseUnless`方法:\r\n\r\n    $browser->pauseUnless(App::environment('testing'), 1000);\r\n\r\n<a name=\"waiting-for-selectors\"></a>\r\n#### 等待选择器\r\n\r\n该`waitFor`方法可以用于暂停执行测试，直到页面上与给定 CSS 选择器匹配的元素被显示。默认情况下，将在暂停超过 5 秒后抛出异常。如有必要，可以传递自定义超时时长作为其第二个参数：\r\n\r\n    // 等待选择器不超过 5 秒...\r\n    $browser->waitFor('.selector');\r\n\r\n    // 等待选择器不超过 1 秒...\r\n    $browser->waitFor('.selector', 1);\r\n\r\n你也可以等待选择器显示给定文字：\r\n\r\n    //  等待选择器不超过 5 秒包含给定文字...\r\n    $browser->waitForTextIn('.selector', 'Hello World');\r\n\r\n    //  等待选择器不超过 1 秒包含给定文字...\r\n    $browser->waitForTextIn('.selector', 'Hello World', 1);\r\n\r\n你也可以等待指定选择器从页面消失:\r\n\r\n    // 等待不超过 5 秒 直到选择器消失...\r\n    $browser->waitUntilMissing('.selector');\r\n\r\n    // 等待不超过 1 秒 直到选择器消失...\r\n    $browser->waitUntilMissing('.selector', 1);\r\n\r\n或者，你可以等待与给定选择器匹配的元素被启用或禁用：\r\n\r\n    // 最多等待 5 秒钟，直到选择器启用...\r\n    $browser->waitUntilEnabled('.selector');\r\n\r\n    // 最多等待 1 秒钟，直到选择器启用...\r\n    $browser->waitUntilEnabled('.selector', 1);\r\n\r\n    // 最多等待 5 秒钟，直到选择器被禁用...\r\n    $browser->waitUntilDisabled('.selector');\r\n\r\n    // 最多等待 1 秒钟，直到选择器被禁用...\r\n    $browser->waitUntilDisabled('.selector', 1);\r\n\r\n<a name=\"scoping-selectors-when-available\"></a>\r\n#### 限定作用域范围（可用时）\r\n\r\n有时，你或许希望等待给定选择器出现，然后与匹配选择器的元素进行交互。例如，你可能希望等到模态窗口可用，然后在模态窗口中点击「确定」按钮。在这种情况下，可以使用`whenAvailable`方法。给定回调内的所有要执行的元素操作都将被限定在起始选择器上:\r\n\r\n    $browser->whenAvailable('.modal', function (Browser $modal) {\r\n        $modal->assertSee('Hello World')\r\n              ->press('OK');\r\n    });\r\n\r\n<a name=\"waiting-for-text\"></a>\r\n#### 等待文本\r\n\r\n`waitForText`方法可以用于等待页面上给定文字被显示：\r\n\r\n    // 等待指定文本不超过 5 秒...\r\n    $browser->waitForText('Hello World');\r\n\r\n    // 等待指定文本不超过 1 秒...\r\n    $browser->waitForText('Hello World', 1);\r\n\r\n你可以使用`waitUntilMissingText`方法来等待，直到显示的文本已从页面中删除为止:\r\n\r\n    // 等待 5 秒删除文本...\r\n    $browser->waitUntilMissingText('Hello World');\r\n\r\n    // 等待 1 秒删除文本...\r\n    $browser->waitUntilMissingText('Hello World', 1);\r\n\r\n<a name=\"waiting-for-links\"></a>\r\n#### 等待链接\r\n\r\n`waitForLink`方法用于等待给定链接文字在页面上显示:\r\n\r\n    // 等待链接 5 秒...\r\n    $browser->waitForLink('Create');\r\n\r\n    // 等待链接 1 秒...\r\n    $browser->waitForLink('Create', 1);\r\n\r\n<a name=\"waiting-for-inputs\"></a>\r\n#### 等待输入\r\n\r\n`waitForInput`方法可用于等待，直到给定的输入字段在页面上可见:\r\n\r\n    // 等待 5 秒的输入…\r\n    $browser->waitForInput($field);\r\n\r\n    // 等待 1 秒的输入…\r\n    $browser->waitForInput($field, 1);\r\n\r\n<a name=\"waiting-on-the-page-location\"></a>\r\n#### 等待页面跳转\r\n\r\n当给出类似`$browser->assertPathIs('/home')`的路径断言时，如果`window.location.pathname`被异步更新，断言就会失败。可以使用`waitForLocation`方法等待页面跳转到给定路径：\r\n\r\n    $browser->waitForLocation('/secret');\r\n\r\n`waitForLocation`方法还可用于等待当前窗口位置成为完全限定的 URL：\r\n\r\n    $browser->waitForLocation('https://example.com/path');\r\n\r\n还可以使用[被命名的路由](/docs/laravel/10.x/routing#named-routes)等待跳转：\r\n\r\n    $browser->waitForRoute($routeName, $parameters);\r\n\r\n<a name=\"waiting-for-page-reloads\"></a>\r\n#### 等待页面重新加载\r\n\r\n如果要在页面重新加载后断言，可以使用`waitForReload`方法：\r\n\r\n    use Laravel\\Dusk\\Browser;\r\n\r\n    $browser->waitForReload(function (Browser $browser) {\r\n        $browser->press('Submit');\r\n    })\r\n    ->assertSee('Success!');\r\n\r\n由于需要等待页面重新加载通常发生在单击按钮之后，为了方便起见，你可以使用`clickAndWaitForReload`方法：\r\n\r\n    $browser->clickAndWaitForReload('.selector')\r\n            ->assertSee('something');\r\n\r\n<a name=\"waiting-on-javascript-expressions\"></a>\r\n#### 等待 JavaScript 表达式\r\n\r\n有时候会希望暂停测试的执行，直到给定的 JavaScript 表达式执行结果为`true`。可以使用`waitUntil`方法轻松地达成此目的。 通过这个方法执行表达式，不需要包含`return`关键字或者结束分号：\r\n\r\n    // 等待表达式为 true 5 秒时间...\r\n    $browser->waitUntil('App.data.servers.length > 0');\r\n\r\n    // 等待表达式为 true 1 秒时间...\r\n    $browser->waitUntil('App.data.servers.length > 0', 1);\r\n\r\n<a name=\"waiting-on-vue-expressions\"></a>\r\n#### 等待 Vue 表达式\r\n\r\n`waitUntilVue`和`waitUntilVueIsNot`方法可以一直等待，直到 [Vue 组件](https://vuejs.org) 的属性包含给定的值：\r\n\r\n    // 一直等待，直到组件属性包含给定的值...\r\n    $browser->waitUntilVue('user.name', 'Taylor', '@user');\r\n\r\n    // 一直等待，直到组件属性不包含给定的值...\r\n    $browser->waitUntilVueIsNot('user.name', null, '@user');\r\n\r\n<a name=\"waiting-for-javascript-events\"></a>\r\n#### 等待 JavaScript 事件\r\n\r\n`waitForEvent`方法可用于暂停测试的执行，直到 JavaScript 事件发生:\r\n\r\n    $browser->waitForEvent('load');\r\n\r\n事件监听器附加到当前作用域，默认情况下是`body`元素。当使用范围选择器时，事件监听器将被附加到匹配的元素上:\r\n\r\n    $browser->with('iframe', function (Browser $iframe) {\r\n        // 等待 iframe 的加载事件…\r\n        $iframe->waitForEvent('load');\r\n    });\r\n\r\n你也可以提供一个选择器作为`waitForEvent`方法的第二个参数，将事件监听器附加到特定的元素上:\r\n\r\n    $browser->waitForEvent('load', '.selector');\r\n\r\n你也可以等待`document`和`window`对象上的事件:\r\n\r\n    // 等待文档被滚动…\r\n    $browser->waitForEvent('scroll', 'document');\r\n\r\n    // 等待 5 秒，直到窗口大小被调整…\r\n    $browser->waitForEvent('resize', 'window', 5);\r\n\r\n<a name=\"waiting-with-a-callback\"></a>\r\n#### 等待回调\r\n\r\nDusk 中的许多 「wait」 方法都依赖于底层方法 waitUsing。你可以直接用这个方法去等待一个回调函数返回`waitUsing`。你可以直接用这个方法去等待一个回调函数返回`true`。该`waitUsing`方法接收一个最大的等待秒数，闭包执行间隔时间，闭包，以及一个可选的失败信息：\r\n\r\n    $browser->waitUsing(10, 1, function () use ($something) {\r\n        return $something->isReady();\r\n    }, \"有些东西没有及时准备好。\");\r\n\r\n<a name=\"scrolling-an-element-into-view\"></a>\r\n### 滚动元素到视图中\r\n\r\n有时你可能无法单击某个元素，因为该元素在浏览器的可见区域之外。该`scrollIntoView`方法可以将元素滚动到浏览器可视窗口内：\r\n\r\n    $browser->scrollIntoView('.selector')\r\n            ->click('.selector');\r\n\r\n<a name=\"available-assertions\"></a>\r\n## 可用的断言\r\n\r\nDusk 提供了各种你可以对应用使用的断言。所有可用的断言罗列如下：\r\n\r\n<style>\r\n    .collection-method-list > p {\r\n        columns: 10.8em 3; -moz-columns: 10.8em 3; -webkit-columns: 10.8em 3;\r\n    }\r\n\r\n    .collection-method-list a {\r\n        display: block;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n    }\r\n</style>\r\n\r\n<div class=\"collection-method-list\" markdown=\"1\">\r\n\r\n[assertTitle](#assert-title)\r\n[assertTitleContains](#assert-title-contains)\r\n[assertUrlIs](#assert-url-is)\r\n[assertSchemeIs](#assert-scheme-is)\r\n[assertSchemeIsNot](#assert-scheme-is-not)\r\n[assertHostIs](#assert-host-is)\r\n[assertHostIsNot](#assert-host-is-not)\r\n[assertPortIs](#assert-port-is)\r\n[assertPortIsNot](#assert-port-is-not)\r\n[assertPathBeginsWith](#assert-path-begins-with)\r\n[assertPathIs](#assert-path-is)\r\n[assertPathIsNot](#assert-path-is-not)\r\n[assertRouteIs](#assert-route-is)\r\n[assertQueryStringHas](#assert-query-string-has)\r\n[assertQueryStringMissing](#assert-query-string-missing)\r\n[assertFragmentIs](#assert-fragment-is)\r\n[assertFragmentBeginsWith](#assert-fragment-begins-with)\r\n[assertFragmentIsNot](#assert-fragment-is-not)\r\n[assertHasCookie](#assert-has-cookie)\r\n[assertHasPlainCookie](#assert-has-plain-cookie)\r\n[assertCookieMissing](#assert-cookie-missing)\r\n[assertPlainCookieMissing](#assert-plain-cookie-missing)\r\n[assertCookieValue](#assert-cookie-value)\r\n[assertPlainCookieValue](#assert-plain-cookie-value)\r\n[assertSee](#assert-see)\r\n[assertDontSee](#assert-dont-see)\r\n[assertSeeIn](#assert-see-in)\r\n[assertDontSeeIn](#assert-dont-see-in)\r\n[assertSeeAnythingIn](#assert-see-anything-in)\r\n[assertSeeNothingIn](#assert-see-nothing-in)\r\n[assertScript](#assert-script)\r\n[assertSourceHas](#assert-source-has)\r\n[assertSourceMissing](#assert-source-missing)\r\n[assertSeeLink](#assert-see-link)\r\n[assertDontSeeLink](#assert-dont-see-link)\r\n[assertInputValue](#assert-input-value)\r\n[assertInputValueIsNot](#assert-input-value-is-not)\r\n[assertChecked](#assert-checked)\r\n[assertNotChecked](#assert-not-checked)\r\n[assertIndeterminate](#assert-indeterminate)\r\n[assertRadioSelected](#assert-radio-selected)\r\n[assertRadioNotSelected](#assert-radio-not-selected)\r\n[assertSelected](#assert-selected)\r\n[assertNotSelected](#assert-not-selected)\r\n[assertSelectHasOptions](#assert-select-has-options)\r\n[assertSelectMissingOptions](#assert-select-missing-options)\r\n[assertSelectHasOption](#assert-select-has-option)\r\n[assertSelectMissingOption](#assert-select-missing-option)\r\n[assertValue](#assert-value)\r\n[assertValueIsNot](#assert-value-is-not)\r\n[assertAttribute](#assert-attribute)\r\n[assertAttributeContains](#assert-attribute-contains)\r\n[assertAriaAttribute](#assert-aria-attribute)\r\n[assertDataAttribute](#assert-data-attribute)\r\n[assertVisible](#assert-visible)\r\n[assertPresent](#assert-present)\r\n[assertNotPresent](#assert-not-present)\r\n[assertMissing](#assert-missing)\r\n[assertInputPresent](#assert-input-present)\r\n[assertInputMissing](#assert-input-missing)\r\n[assertDialogOpened](#assert-dialog-opened)\r\n[assertEnabled](#assert-enabled)\r\n[assertDisabled](#assert-disabled)\r\n[assertButtonEnabled](#assert-button-enabled)\r\n[assertButtonDisabled](#assert-button-disabled)\r\n[assertFocused](#assert-focused)\r\n[assertNotFocused](#assert-not-focused)\r\n[assertAuthenticated](#assert-authenticated)\r\n[assertGuest](#assert-guest)\r\n[assertAuthenticatedAs](#assert-authenticated-as)\r\n[assertVue](#assert-vue)\r\n[assertVueIsNot](#assert-vue-is-not)\r\n[assertVueContains](#assert-vue-contains)\r\n[assertVueDoesNotContain](#assert-vue-does-not-contain)\r\n\r\n</div>\r\n\r\n<a name=\"assert-title\"></a>\r\n#### assertTitle\r\n\r\n断言页面标题为给定文本：\r\n\r\n    $browser->assertTitle($title);\r\n\r\n<a name=\"assert-title-contains\"></a>\r\n#### assertTitleContains\r\n\r\n断言页面标题包含给定文本：\r\n\r\n    $browser->assertTitleContains($title);\r\n\r\n<a name=\"assert-url-is\"></a>\r\n#### assertUrlIs\r\n\r\n断言当前的 URL（不包含 query string）是给定的字符串：\r\n\r\n    $browser->assertUrlIs($url);\r\n\r\n<a name=\"assert-scheme-is\"></a>\r\n#### assertSchemeIs\r\n\r\n断言当前的 URL scheme 是给定的 scheme：\r\n\r\n    $browser->assertSchemeIs($scheme);\r\n\r\n<a name=\"assert-scheme-is-not\"></a>\r\n#### assertSchemeIsNot\r\n\r\n断言当前的 URL scheme 不是给定的 scheme：\r\n\r\n    $browser->assertSchemeIsNot($scheme);\r\n\r\n<a name=\"assert-host-is\"></a>\r\n#### assertHostIs\r\n\r\n断言当前的 URL host 是给定的 host：\r\n\r\n    $browser->assertHostIs($host);\r\n\r\n<a name=\"assert-host-is-not\"></a>\r\n#### assertHostIsNot\r\n\r\n断言当前的 URL host 不是给定的 host：\r\n\r\n    $browser->assertHostIsNot($host);\r\n\r\n<a name=\"assert-port-is\"></a>\r\n#### assertPortIs\r\n\r\n断言当前的 URL 端口是给定的端口：\r\n\r\n    $browser->assertPortIs($port);\r\n\r\n<a name=\"assert-port-is-not\"></a>\r\n#### assertPortIsNot\r\n\r\n断言当前的 URL 端口不是给定的端口：\r\n\r\n    $browser->assertPortIsNot($port);\r\n\r\n<a name=\"assert-path-begins-with\"></a>\r\n#### assertPathBeginsWith\r\n\r\n断言当前的 URL 路径以给定的路径开始：\r\n\r\n    $browser->assertPathBeginsWith('/home');\r\n\r\n<a name=\"assert-path-is\"></a>\r\n#### assertPathIs\r\n\r\n断言当前的路径是给定的路径：\r\n\r\n    $browser->assertPathIs('/home');\r\n\r\n<a name=\"assert-path-is-not\"></a>\r\n#### assertPathIsNot\r\n\r\n断言当前的路径不是给定的路径：\r\n\r\n    $browser->assertPathIsNot('/home');\r\n\r\n<a name=\"assert-route-is\"></a>\r\n#### assertRouteIs\r\n\r\n断言给定的 URL 是给定的[命名路由](/docs/laravel/10.x/routing#named-routes)的 URL:\r\n\r\n    $browser->assertRouteIs($name, $parameters);\r\n\r\n<a name=\"assert-query-string-has\"></a>\r\n#### assertQueryStringHas\r\n\r\n断言给定的查询字符串参数存在：\r\n\r\n    $browser->assertQueryStringHas($name);\r\n\r\n断言给定的查询字符串参数存在并且具有给定的值：\r\n\r\n    $browser->assertQueryStringHas($name, $value);\r\n\r\n<a name=\"assert-query-string-missing\"></a>\r\n#### assertQueryStringMissing\r\n\r\n断言缺少给定的查询字符串参数：\r\n\r\n    $browser->assertQueryStringMissing($name);\r\n\r\n<a name=\"assert-fragment-is\"></a>\r\n#### assertFragmentIs\r\n\r\n断言 URL 的当前哈希片段与给定的片段匹配：\r\n\r\n    $browser->assertFragmentIs('anchor');\r\n\r\n<a name=\"assert-fragment-begins-with\"></a>\r\n#### assertFragmentBeginsWith\r\n\r\n断言 URL 的当前哈希片段以给定片段开头：\r\n\r\n    $browser->assertFragmentBeginsWith('anchor');\r\n\r\n<a name=\"assert-fragment-is-not\"></a>\r\n#### assertFragmentIsNot\r\n\r\n断言 URL 的当前哈希片段与给定的片段不匹配：\r\n\r\n    $browser->assertFragmentIsNot('anchor');\r\n\r\n<a name=\"assert-has-cookie\"></a>\r\n#### assertHasCookie\r\n\r\n断言给定的加密 cookie 存在:\r\n\r\n    $browser->assertHasCookie($name);\r\n\r\n<a name=\"assert-has-plain-cookie\"></a>\r\n#### assertHasPlainCookie\r\n\r\n断言给定的未加密 cookie 存在：\r\n\r\n    $browser->assertHasPlainCookie($name);\r\n\r\n<a name=\"assert-cookie-missing\"></a>\r\n#### assertCookieMissing\r\n\r\n断言给定的加密 cookie 不存在：\r\n\r\n    $browser->assertCookieMissing($name);\r\n\r\n<a name=\"assert-plain-cookie-missing\"></a>\r\n#### assertPlainCookieMissing\r\n\r\n断言给定的未加密 cookie 不存在：\r\n\r\n    $browser->assertPlainCookieMissing($name);\r\n\r\n<a name=\"assert-cookie-value\"></a>\r\n#### assertCookieValue\r\n\r\n断言加密的 cookie 具有给定值：\r\n\r\n    $browser->assertCookieValue($name, $value);\r\n\r\n<a name=\"assert-plain-cookie-value\"></a>\r\n#### assertPlainCookieValue\r\n\r\n断言未加密的 cookie 具有给定值：\r\n\r\n    $browser->assertPlainCookieValue($name, $value);\r\n\r\n<a name=\"assert-see\"></a>\r\n#### assertSee\r\n\r\n断言在页面中有给定的文本：\r\n\r\n    $browser->assertSee($text);\r\n\r\n<a name=\"assert-dont-see\"></a>\r\n#### assertDontSee\r\n\r\n断言在页面中没有给定的文本：\r\n\r\n    $browser->assertDontSee($text);\r\n\r\n<a name=\"assert-see-in\"></a>\r\n#### assertSeeIn\r\n\r\n断言在选择器中有给定的文本：\r\n\r\n    $browser->assertSeeIn($selector, $text);\r\n\r\n<a name=\"assert-dont-see-in\"></a>\r\n#### assertDontSeeIn\r\n\r\n断言在选择器中不存在给定的文本：\r\n\r\n    $browser->assertDontSeeIn($selector, $text);\r\n\r\n<a name=\"assert-see-anything-in\"></a>\r\n#### assertSeeAnythingIn\r\n\r\n断言在选择器中存在任意的文本：\r\n\r\n    $browser->assertSeeAnythingIn($selector);\r\n\r\n断言在选择器中不存在文本：\r\n\r\n    $browser->assertSeeNothingIn($selector);\r\n\r\n<a name=\"assert-script\"></a>\r\n#### assertScript\r\n\r\n断言给定的 JavaScript 表达式结果为给定的值：\r\n\r\n    $browser->assertScript('window.isLoaded')\r\n            ->assertScript('document.readyState', 'complete');\r\n\r\n<a name=\"assert-source-has\"></a>\r\n#### assertSourceHas\r\n\r\n断言在页面中存在给定的源码：\r\n\r\n    $browser->assertSourceHas($code);\r\n\r\n<a name=\"assert-source-missing\"></a>\r\n#### assertSourceMissing\r\n\r\n断言页面中没有给定的源码：\r\n\r\n    $browser->assertSourceMissing($code);\r\n\r\n<a name=\"assert-see-link\"></a>\r\n#### assertSeeLink\r\n\r\n断言在页面中存在指定的链接：\r\n\r\n    $browser->assertSeeLink($linkText);\r\n\r\n<a name=\"assert-dont-see-link\"></a>\r\n#### assertDontSeeLink\r\n\r\n断言页面中没有指定的链接：\r\n\r\n    $browser->assertDontSeeLink($linkText);\r\n\r\n<a name=\"assert-input-value\"></a>\r\n#### assertInputValue\r\n\r\n断言输入框（input）有给定的值：\r\n\r\n    $browser->assertInputValue($field, $value);\r\n\r\n<a name=\"assert-input-value-is-not\"></a>\r\n#### assertInputValueIsNot\r\n\r\n断言输入框没有给定的值：\r\n\r\n    $browser->assertInputValueIsNot($field, $value);\r\n\r\n<a name=\"assert-checked\"></a>\r\n#### assertChecked\r\n\r\n断言复选框（checkbox）被选中：\r\n\r\n    $browser->assertChecked($field);\r\n\r\n<a name=\"assert-not-checked\"></a>\r\n#### assertNotChecked\r\n\r\n断言复选框没有被选中：\r\n\r\n    $browser->assertNotChecked($field);\r\n\r\n<a name=\"assert-radio-selected\"></a>\r\n#### assertRadioSelected\r\n\r\n断言单选框（radio）被选中：\r\n\r\n    $browser->assertRadioSelected($field, $value);\r\n\r\n<a name=\"assert-radio-not-selected\"></a>\r\n#### assertRadioNotSelected\r\n\r\n断言单选框（radio）没有被选中：\r\n\r\n    $browser->assertRadioNotSelected($field, $value);\r\n\r\n<a name=\"assert-selected\"></a>\r\n#### assertSelected\r\n\r\n断言下拉框有给定的值:\r\n\r\n    $browser->assertSelected($field, $value);\r\n\r\n\r\n断言下拉框没有给定的值：\r\n\r\n    $browser->assertNotSelected($field, $value);\r\n\r\n<a name=\"assert-select-has-options\"></a>\r\n#### assertSelectHasOptions\r\n\r\n断言给定的数组值是可选的：\r\n\r\n    $browser->assertSelectHasOptions($field, $values);\r\n\r\n<a name=\"assert-select-missing-options\"></a>\r\n#### assertSelectMissingOptions\r\n\r\n断言给定的数组值是不可选的：\r\n\r\n    $browser->assertSelectMissingOptions($field, $values);\r\n\r\n<a name=\"assert-select-has-option\"></a>\r\n#### assertSelectHasOption\r\n\r\n断言给定的值在给定的地方是可供选择的：\r\n\r\n    $browser->assertSelectHasOption($field, $value);\r\n\r\n<a name=\"assert-select-missing-option\"></a>\r\n#### assertSelectMissingOption\r\n\r\n断言给定的值不可选：\r\n\r\n    $browser->assertSelectMissingOption($field, $value);\r\n\r\n<a name=\"assert-value\"></a>\r\n#### assertValue\r\n\r\n断言选择器范围内的元素存在指定的值：\r\n\r\n    $browser->assertValue($selector, $value);\r\n\r\n<a name=\"assert-value-is-not\"></a>\r\n#### assertValueIsNot\r\n\r\n断言选择器范围内的元素不存在指定的值：\r\n\r\n    $browser->assertValueIsNot($selector, $value);\r\n\r\n<a name=\"assert-attribute\"></a>\r\n#### assertAttribute\r\n\r\n断言与给定选择器匹配的元素在提供的属性中具有给定的值：\r\n\r\n    $browser->assertAttribute($selector, $attribute, $value);\r\n\r\n<a name=\"assert-attribute-contains\"></a>\r\n#### assertAttributeContains\r\n\r\n断言匹配给定选择器的元素在提供的属性中包含给定值：\r\n\r\n    $browser->assertAttributeContains($selector, $attribute, $value);\r\n\r\n<a name=\"assert-aria-attribute\"></a>\r\n#### assertAriaAttribute\r\n\r\n断言与给定选择器匹配的元素在给定的 aria 属性中具有给定的值：\r\n\r\n    $browser->assertAriaAttribute($selector, $attribute, $value);\r\n\r\n例如，给定标记`<button aria-label=\"Add\"></button>`，你可以像这样声明`aria-label`属性：\r\n\r\n    $browser->assertAriaAttribute('button', 'label', 'Add')\r\n\r\n<a name=\"assert-data-attribute\"></a>\r\n#### assertDataAttribute\r\n\r\n断言与给定选择器匹配的元素在提供的 data 属性中具有给定的值：\r\n\r\n    $browser->assertDataAttribute($selector, $attribute, $value);\r\n\r\n例如，给定标记`<tr id=\"row-1\" data-content=\"attendees\"></tr>`，你可以像这样断言`data-label`属性：\r\n\r\n    $browser->assertDataAttribute('#row-1', 'content', 'attendees')\r\n\r\n<a name=\"assert-visible\"></a>\r\n#### assertVisible\r\n\r\n断言匹配给定选择器的元素可见:\r\n\r\n    $browser->assertVisible($selector);\r\n\r\n<a name=\"assert-present\"></a>\r\n#### assertPresent\r\n\r\n断言匹配给定选择器的元素存在：\r\n\r\n    $browser->assertPresent($selector);\r\n\r\n<a name=\"assert-not-present\"></a>\r\n#### assertNotPresent\r\n\r\n断言源中不存在与给定选择器匹配的元素：\r\n\r\n    $browser->assertNotPresent($selector);\r\n\r\n<a name=\"assert-missing\"></a>\r\n#### assertMissing\r\n\r\n断言匹配给定选择器的元素不可见：\r\n\r\n    $browser->assertMissing($selector);\r\n\r\n<a name=\"assert-input-present\"></a>\r\n#### assertInputPresent\r\n\r\n断言具有给定名称的输入存在：\r\n\r\n    $browser->assertInputPresent($name);\r\n\r\n<a name=\"assert-input-missing\"></a>\r\n#### assertInputMissing\r\n\r\n断言源中不存在具有给定名称的输入：\r\n\r\n    $browser->assertInputMissing($name);\r\n\r\n<a name=\"assert-dialog-opened\"></a>\r\n#### assertDialogOpened\r\n\r\n断言已打开带有给定消息的 JavaScript 对话框：\r\n\r\n    $browser->assertDialogOpened($message);\r\n\r\n<a name=\"assert-enabled\"></a>\r\n#### assertEnabled\r\n\r\n断言给定的字段已启用：\r\n\r\n    $browser->assertEnabled($field);\r\n\r\n<a name=\"assert-disabled\"></a>\r\n#### assertDisabled\r\n\r\n断言给定的字段被禁用：\r\n\r\n    $browser->assertDisabled($field);\r\n\r\n<a name=\"assert-button-enabled\"></a>\r\n#### assertButtonEnabled\r\n\r\n断言给定的按钮已启用：\r\n\r\n    $browser->assertButtonEnabled($button);\r\n\r\n<a name=\"assert-button-disabled\"></a>\r\n#### assertButtonDisabled\r\n\r\n断言给定的按钮被禁用：\r\n\r\n    $browser->assertButtonDisabled($button);\r\n\r\n<a name=\"assert-focused\"></a>\r\n#### assertFocused\r\n\r\n断言给定的字段是焦点：\r\n\r\n    $browser->assertFocused($field);\r\n\r\n<a name=\"assert-not-focused\"></a>\r\n#### assertNotFocused\r\n\r\n断言给定字段未聚焦：\r\n\r\n    $browser->assertNotFocused($field);\r\n\r\n<a name=\"assert-authenticated\"></a>\r\n#### assertAuthenticated\r\n\r\n断言用户已通过身份验证：\r\n\r\n    $browser->assertAuthenticated();\r\n\r\n<a name=\"assert-guest\"></a>\r\n#### assertGuest\r\n\r\n断言用户未通过身份验证：\r\n\r\n    $browser->assertGuest();\r\n\r\n<a name=\"assert-authenticated-as\"></a>\r\n#### assertAuthenticatedAs\r\n\r\n断言用户已作为给定用户进行身份验证：\r\n\r\n    $browser->assertAuthenticatedAs($user);\r\n\r\n<a name=\"assert-vue\"></a>\r\n#### assertVue\r\n\r\nDusk 甚至允许你对 [Vue 组件](https://vuejs.org)数据的状态进行断言。例如，假设你的应用程序包含以下 Vue 组件：\r\n\r\n    // HTML...\r\n\r\n    <profile dusk=\"profile-component\"></profile>\r\n\r\n    // 组件定义...\r\n\r\n    Vue.component('profile', {\r\n        template: '<div>{{ user.name }}</div>',\r\n\r\n        data: function () {\r\n            return {\r\n                user: {\r\n                    name: 'Taylor'\r\n                }\r\n            };\r\n        }\r\n    });\r\n\r\n你可以像这样断言 Vue 组件的状态：\r\n\r\n    /**\r\n     * 一个基本的 Vue 测试示例\r\n     *\r\n     * @return void\r\n     */\r\n    public function testVue()\r\n    {\r\n        $this->browse(function (Browser $browser) {\r\n            $browser->visit('/')\r\n                    ->assertVue('user.name', 'Taylor', '@profile-component');\r\n        });\r\n    }\r\n\r\n<a name=\"assert-vue-is-not\"></a>\r\n#### assertVueIsNot\r\n\r\n断言 Vue 组件数据的属性不匹配给定的值：\r\n\r\n    $browser->assertVueIsNot($property, $value, $componentSelector = null);\r\n\r\n<a name=\"assert-vue-contains\"></a>\r\n#### assertVueContains\r\n\r\n断言 Vue 组件数据的属性是一个数组，并包含给定的值：\r\n\r\n    $browser->assertVueContains($property, $value, $componentSelector = null);\r\n\r\n<a name=\"assert-vue-does-not-contain\"></a>\r\n#### assertVueDoesNotContain\r\n\r\n断言 Vue 组件数据的属性是一个数组，且不包含给定的值：\r\n\r\n    $browser->assertVueDoesNotContain($property, $value, $componentSelector = null);\r\n\r\n<a name=\"pages\"></a>\r\n## Pages\r\n\r\n有时，测试需要按顺序执行几个复杂的操作。这会使测试代码更难阅读和理解。 Dusk Pages 允许你定义语义化的操作，然后可以通过单一方法在给定页面上执行这些操作。Pages 还可以为应用或单个页面定义通用选择器的快捷方式。\r\n\r\n<a name=\"generating-pages\"></a>\r\n### 生成 Pages\r\n\r\n`dusk:page`Artisan 命令可以生成页面对象。所有的页面对象都位于`tests/Browser/Pages`目录：\r\n\r\n    php artisan dusk:page Login\r\n\r\n<a name=\"configuring-pages\"></a>\r\n### 配置 Pages\r\n\r\n默认情况下，页面具有三种方法：`url`、`assert`和`elements`。我们现在将讨论 `url`和`assert`方法。`elements`方法将[在下面更详细地讨论](#shorthand-selectors)。\r\n\r\n<a name=\"the-url-method\"></a>\r\n#### `url` 方法\r\n\r\n`url`方法应该返回表示页面 URL 的路径。 Dusk 将会在浏览器中使用这个 URL 来导航到具体页面：\r\n\r\n    /**\r\n     * 获取页面的 URL。\r\n     *\r\n     * @return string\r\n     */\r\n    public function url()\r\n    {\r\n        return '/login';\r\n    }\r\n\r\n<a name=\"the-assert-method\"></a>\r\n#### `assert` 方法\r\n\r\n`assert`方法可以作出任何断言来验证浏览器是否在指定页面上。实际上没有必要在这个方法中放置任何东西；但是，你可以按自己的需求来做出这些断言。导航到页面时，这些断言将自动运行：\r\n\r\n    /**\r\n     * 断言浏览器当前处于指定页面。\r\n     */\r\n    public function assert(Browser $browser): void\r\n    {\r\n        $browser->assertPathIs($this->url());\r\n    }\r\n\r\n<a name=\"navigating-to-pages\"></a>\r\n### 导航至页面\r\n\r\n一旦页面定义好之后，你可以使用`visit`方法导航至页面：\r\n\r\n    use Tests\\Browser\\Pages\\Login;\r\n\r\n    $browser->visit(new Login);\r\n\r\n有时你可能已经在给定的页面上，需要将页面的选择器和方法「加载」到当前的测试上下文中。 这在通过按钮重定向到指定页面而没有明确导航到该页面时很常见。 在这种情况下，你可以使用`on`方法加载页面：\r\n\r\n    use Tests\\Browser\\Pages\\CreatePlaylist;\r\n\r\n    $browser->visit('/dashboard')\r\n            ->clickLink('Create Playlist')\r\n            ->on(new CreatePlaylist)\r\n            ->assertSee('@create');\r\n\r\n<a name=\"shorthand-selectors\"></a>\r\n### 选择器简写\r\n\r\n该`elements`方法允许你为页面中的任何 CSS 选择器定义简单易记的简写。例如，让我们为应用登录页中的 email 输入框定义一个简写：\r\n\r\n    /**\r\n     * 获取页面元素的简写。\r\n     *\r\n     * @return array<string, string>\r\n     */\r\n    public function elements(): array\r\n    {\r\n        return [\r\n            '@email' => 'input[name=email]',\r\n        ];\r\n    }\r\n\r\n一旦定义了简写，你就可以用这个简写来代替之前在页面中使用的完整 CSS 选择器：\r\n\r\n    $browser->type('@email', 'taylor@laravel.com');\r\n\r\n<a name=\"global-shorthand-selectors\"></a>\r\n#### 全局的选择器简写\r\n\r\n安装 Dusk 之后，`Page`基类存放在你的`tests/Browser/Pages`目录。该类中包含一个`siteElements`方法，这个方法可以用来定义全局的选择器简写，这样在你应用中每个页面都可以使用这些全局选择器简写了：\r\n\r\n    /**\r\n     * 获取站点全局的选择器简写。\r\n     *\r\n     * @return array<string, string>\r\n     */\r\n    public static function siteElements(): array\r\n    {\r\n        return [\r\n            '@element' => '#selector',\r\n        ];\r\n    }\r\n\r\n<a name=\"page-methods\"></a>\r\n### 页面方法\r\n\r\n除了页面中已经定义的默认方法之外，你还可以定义在整个测试过程中会使用到的其他方法。例如，假设我们正在开发一个音乐管理应用，在应用中每个页面都可能需要一个公共的方法来创建播放列表，而不是在每一个测试类中都重写一遍创建播放列表的逻辑，这时候你可以在你的页面类中定义一个`createPlaylist`方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser\\Pages;\r\n\r\n    use Laravel\\Dusk\\Browser;\r\n\r\n    class Dashboard extends Page\r\n    {\r\n        // 其他页面方法...\r\n\r\n        /**\r\n         * 创建一个新的播放列表。\r\n         */\r\n        public function createPlaylist(Browser $browser, string $name): void\r\n        {\r\n            $browser->type('name', $name)\r\n                    ->check('share')\r\n                    ->press('Create Playlist');\r\n        }\r\n    }\r\n\r\n方法被定义之后，你可以在任何使用到该页的测试中使用它了。浏览器实例会自动作为第一个参数传递给自定义页面方法：\r\n\r\n    use Tests\\Browser\\Pages\\Dashboard;\r\n\r\n    $browser->visit(new Dashboard)\r\n            ->createPlaylist('My Playlist')\r\n            ->assertSee('My Playlist');\r\n\r\n<a name=\"components\"></a>\r\n## 组件\r\n\r\n组件类似于 Dusk 的 「页面对象」，不过它更多的是贯穿整个应用程序中频繁重用的 UI 和功能片断，比如说导航条或信息通知弹窗。因此，组件并不会绑定于某个明确的 URL。\r\n\r\n<a name=\"generating-components\"></a>\r\n### 生成组件\r\n\r\n使用`dusk:component`Artisan 命令即可生成组件。新生成的组件位于`tests/Browser/Components`目录下：\r\n\r\n    php artisan dusk:component DatePicker\r\n\r\n如上所示，这是生成一个「日期选择器」（date picker）组件的示例，这个组件可能会贯穿使用在你应用程序的许多页面中。在整个测试套件的大量测试页面中，手动编写日期选择的浏览器自动化逻辑会非常麻烦。 更方便的替代办法是，定义一个表示日期选择器的 Dusk 组件，然后把自动化逻辑封装在该组件内：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser\\Components;\r\n\r\n    use Laravel\\Dusk\\Browser;\r\n    use Laravel\\Dusk\\Component as BaseComponent;\r\n\r\n    class DatePicker extends BaseComponent\r\n    {\r\n        /**\r\n         * 获取组件的 root selector。\r\n         */\r\n        public function selector(): string\r\n        {\r\n            return '.date-picker';\r\n        }\r\n\r\n        /**\r\n         * 断言浏览器包含组件。\r\n         */\r\n        public function assert(Browser $browser): void\r\n        {\r\n            $browser->assertVisible($this->selector());\r\n        }\r\n\r\n        /**\r\n         * 读取组件的元素简写。\r\n         *\r\n         * @return array<string, string>\r\n         */\r\n        public function elements(): array\r\n        {\r\n            return [\r\n                '@date-field' => 'input.datepicker-input',\r\n                '@year-list' => 'div > div.datepicker-years',\r\n                '@month-list' => 'div > div.datepicker-months',\r\n                '@day-list' => 'div > div.datepicker-days',\r\n            ];\r\n        }\r\n\r\n        /**\r\n         * 选择给定日期。\r\n         */\r\n        public function selectDate(Browser $browser, int $year, int $month, int $day): void\r\n        {\r\n            $browser->click('@date-field')\r\n                    ->within('@year-list', function (Browser $browser) use ($year) {\r\n                        $browser->click($year);\r\n                    })\r\n                    ->within('@month-list', function (Browser $browser) use ($month) {\r\n                        $browser->click($month);\r\n                    })\r\n                    ->within('@day-list', function (Browser $browser) use ($day) {\r\n                        $browser->click($day);\r\n                    });\r\n        }\r\n    }\r\n\r\n<a name=\"using-components\"></a>\r\n### 使用组件\r\n\r\n当组件被定义了之后，我们就可以轻松的在任意测试页面通过日期选择器选择一个日期。并且，如果选择日期的逻辑发生了变化，我们只需要更新组件即可：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Browser;\r\n\r\n    use Illuminate\\Foundation\\Testing\\DatabaseMigrations;\r\n    use Laravel\\Dusk\\Browser;\r\n    use Tests\\Browser\\Components\\DatePicker;\r\n    use Tests\\DuskTestCase;\r\n\r\n    class ExampleTest extends DuskTestCase\r\n    {\r\n        /**\r\n         * 一个基础的组件测试用例.\r\n         */\r\n        public function test_basic_example(): void\r\n        {\r\n            $this->browse(function (Browser $browser) {\r\n                $browser->visit('/')\r\n                        ->within(new DatePicker, function (Browser $browser) {\r\n                            $browser->selectDate(2019, 1, 30);\r\n                        })\r\n                        ->assertSee('January');\r\n            });\r\n        }\r\n    }\r\n\r\n<a name=\"continuous-integration\"></a>\r\n## 持续集成\r\n\r\n> **注意**\r\n> 大多数 Dusk 持续集成配置都希望你的 Laravel 应用程序使用端口 8000 上的内置 PHP 开发服务器提供服务。因此，你应该确保持续集成环境有一个值为 `http://127.0.0.1:8000` 的 `APP_URL` 环境变量。\r\n\r\n<a name=\"running-tests-on-heroku-ci\"></a>\r\n### Heroku CI\r\n\r\n要在 [Heroku CI](https://www.heroku.com/continuous-integration) 中运行 Dusk 测试，请将以下 Google Chrome buildpack 和 脚本添加到 Heroku 的 `app.json` 文件中：\r\n\r\n    {\r\n      \"environments\": {\r\n        \"test\": {\r\n          \"buildpacks\": [\r\n            { \"url\": \"heroku/php\" },\r\n            { \"url\": \"https://github.com/heroku/heroku-buildpack-google-chrome\" }\r\n          ],\r\n          \"scripts\": {\r\n            \"test-setup\": \"cp .env.testing .env\",\r\n            \"test\": \"nohup bash -c './vendor/laravel/dusk/bin/chromedriver-linux > /dev/null 2>&1 &' && nohup bash -c 'php artisan serve --no-reload > /dev/null 2>&1 &' && php artisan dusk\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n<a name=\"running-tests-on-travis-ci\"></a>\r\n### Travis CI\r\n\r\n要在 [Travis CI](https://travis-ci.org) 运行 Dusk 测试，可以使用下面这个 `.travis.yml` 配置。由于 Travis CI 不是一个图形化的环境，我们还需要一些额外的步骤以便启动 Chrome 浏览器。此外，我们将会使用 `php artisan serve` 来启动 PHP 自带的 Web 服务器：\r\n\r\n```yaml\r\nlanguage: php\r\n\r\nphp:\r\n  - 7.3\r\n\r\naddons:\r\n  chrome: stable\r\n\r\ninstall:\r\n  - cp .env.testing .env\r\n  - travis_retry composer install --no-interaction --prefer-dist\r\n  - php artisan key:generate\r\n  - php artisan dusk:chrome-driver\r\n\r\nbefore_script:\r\n  - google-chrome-stable --headless --disable-gpu --remote-debugging-port=9222 http://localhost &\r\n  - php artisan serve --no-reload &\r\n\r\nscript:\r\n  - php artisan dusk\r\n```\r\n\r\n<a name=\"running-tests-on-github-actions\"></a>\r\n### GitHub Actions\r\n\r\n如果你正在使用 [Github Actions](https://github.com/features/actions) 来运行你的 Dusk 测试，你应该使用以下这份配置文件为模版。像 TravisCI 一样，我们使用 `php artisan serve` 命令来启动 PHP 的内置 Web 服务：\r\n\r\n```yaml\r\nname: CI\r\non: [push]\r\njobs:\r\n\r\n  dusk-php:\r\n    runs-on: ubuntu-latest\r\n    env:\r\n      APP_URL: \"http://127.0.0.1:8000\"\r\n      DB_USERNAME: root\r\n      DB_PASSWORD: root\r\n      MAIL_MAILER: log\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Prepare The Environment\r\n        run: cp .env.example .env\r\n      - name: Create Database\r\n        run: |\r\n          sudo systemctl start mysql\r\n          mysql --user=\"root\" --password=\"root\" -e \"CREATE DATABASE \\`my-database\\` character set UTF8mb4 collate utf8mb4_bin;\"\r\n      - name: Install Composer Dependencies\r\n        run: composer install --no-progress --prefer-dist --optimize-autoloader\r\n      - name: Generate Application Key\r\n        run: php artisan key:generate\r\n      - name: Upgrade Chrome Driver\r\n        run: php artisan dusk:chrome-driver --detect\r\n      - name: Start Chrome Driver\r\n        run: ./vendor/laravel/dusk/bin/chromedriver-linux &\r\n      - name: Run Laravel Server\r\n        run: php artisan serve --no-reload &\r\n      - name: Run Dusk Tests\r\n        run: php artisan dusk\r\n      - name: Upload Screenshots\r\n        if: failure()\r\n        uses: actions/upload-artifact@v2\r\n        with:\r\n          name: screenshots\r\n          path: tests/Browser/screenshots\r\n      - name: Upload Console Logs\r\n        if: failure()\r\n        uses: actions/upload-artifact@v2\r\n        with:\r\n          name: console\r\n          path: tests/Browser/console\r\n```","p":"docs/dusk.html"},{"t":"database-testing (数据库测试)","d":"# 数据库测试\r\n\r\n- [介绍](#introduction)\r\n    - [每次测试后重置数据库](#resetting-the-database-after-each-test)\r\n- [模型工厂](#model-factories)\r\n- [运行 Seeders](#running-seeders)\r\n- [可用的断言](#available-assertions)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\nLaravel 提供了各种有用的工具和断言，从而让测试数据库驱动变得更加容易。除此之外，Laravel 模型工厂和 Seeders 可以轻松地使用应用程序的 Eloquent 模型和关系来创建测试数据库记录。\r\n\r\n<a name=\"resetting-the-database-after-each-test\"></a>\r\n### 每次测试后重置数据库\r\n\r\n在进行测试之前，让我们讨论一下如何在每次测试后重置数据库，以便让先前测试的数据不会干扰后续测试。 Laravel 包含的 `Illuminate\\Foundation\\Testing\\RefreshDatabase` trait 会为你解决这个问题。只需在您的测试类上使用该 Trait：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        use RefreshDatabase;\r\n\r\n        /**\r\n         * 一个基本的功能测试例子。\r\n         */\r\n        public function test_basic_example(): void\r\n        {\r\n            $response = $this->get('/');\r\n\r\n            // ...\r\n        }\r\n    }\r\n\r\n如果你的数据库结构是最新的，那么这个 Trait`Illuminate\\Foundation\\Testing\\RefreshDatabase` 并不会迁移数据库。相反，它只会在一个数据库事务中执行测试。因此，任何由测试用例添加到数据库的记录，如果不使用这个 Trait，可能仍然存在于数据库中。\r\n\r\n如果你想使用迁移来完全重置数据库，可以使用这个 Trait `Illuminate\\Foundation\\Testing\\DatabaseMigrations` 来替代。然而，`DatabaseMigrations` 这个 Trait 明显比 `RefreshDatabase` Trait 要慢。\r\n\r\n\r\n\r\n<a name=\"model-factories\"></a>\r\n## 模型工厂\r\n\r\n当我们测试的时候，可能需要在执行测试之前向数据库插入一些数据。Laravel 允许你使用 [模型工厂](/docs/laravel/10.x/eloquent-factories) 为每个 [Eloquent 模型](/docs/laravel/10.x/eloquent) 定义一组默认值，而不是在创建测试数据时手动指定每一列的值。\r\n\r\n要学习有关创建和使用模型工厂来创建模型的更多信息，请参阅完整的 [模型工厂文档](/docs/laravel/10.x/eloquent-factories)。定义模型工厂后，你可以在测试中使用该工厂来创建模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    public function test_models_can_be_instantiated(): void\r\n    {\r\n        $user = User::factory()->create();\r\n\r\n        // ...\r\n    }\r\n\r\n<a name=\"running-seeders\"></a>\r\n## 运行 seeders\r\n\r\n如果你在功能测试时希望使用 [数据库 seeders](/docs/laravel/10.x/seeding) 来填充你的数据库， 你可以调用 `seed` 方法。 默认情况下，  `seed` 方法将会执行 `DatabaseSeeder`， 它将会执行你的所有其他 seeders。或者，你传递指定的 seeder 类名给 `seed` 方法：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Database\\Seeders\\OrderStatusSeeder;\r\n    use Database\\Seeders\\TransactionStatusSeeder;\r\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\r\n    use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\r\n    use Tests\\TestCase;\r\n\r\n    class ExampleTest extends TestCase\r\n    {\r\n        use RefreshDatabase;\r\n\r\n        /**\r\n         * 测试创建新订单。\r\n         */\r\n        public function test_orders_can_be_created(): void\r\n        {\r\n            // 运行 DatabaseSeeder...\r\n            $this->seed();\r\n\r\n            // 运行指定 seeder...\r\n            $this->seed(OrderStatusSeeder::class);\r\n\r\n            // ...\r\n\r\n            // 运行指定的 seeders...\r\n            $this->seed([\r\n                OrderStatusSeeder::class,\r\n                TransactionStatusSeeder::class,\r\n                // ...\r\n            ]);\r\n        }\r\n    }\r\n\r\n或者通过 `RefreshDatabase` trait 在每次测试之前自动为数据库填充数据。你也可以通过在测试类上定义 `$seed` 属性来实现：\r\n\r\n    <?php\r\n\r\n    namespace Tests;\r\n\r\n    use Illuminate\\Foundation\\Testing\\TestCase as BaseTestCase;\r\n\r\n    abstract class TestCase extends BaseTestCase\r\n    {\r\n        use CreatesApplication;\r\n\r\n        /**\r\n         * Indicates whether the default seeder should run before each test.\r\n         *\r\n         * @var bool\r\n         */\r\n        protected $seed = true;\r\n    }\r\n\r\n\r\n\r\n当 `$seed` 属性为 `true` 时，这个测试将在每个使用 `RefreshDatabase` trait 的测试之前运行 `Database\\Seeders\\DatabaseSeeder` 类。但是，你可以通过在测试类上定义 `$seeder` 属性来指定要执行的 seeder：\r\n\r\n    use Database\\Seeders\\OrderStatusSeeder;\r\n\r\n    /**\r\n     * 在测试前指定要运行的 seeder\r\n     *\r\n     * @var string\r\n     */\r\n    protected $seeder = OrderStatusSeeder::class;\r\n\r\n<a name=\"available-assertions\"></a>\r\n## 可用的断言\r\n\r\nLaravel 为你的 [PHPUnit](https://phpunit.de/) 功能测试提供了几个数据库断言。我们将在下面逐个讨论。\r\n\r\n<a name=\"assert-database-count\"></a>\r\n#### assertDatabaseCount\r\n\r\n断言数据库中的表包含给定数量的记录：\r\n\r\n    $this->assertDatabaseCount('users', 5);\r\n\r\n<a name=\"assert-database-has\"></a>\r\n#### assertDatabaseHas\r\n\r\n断言数据库中的表包含给定键/值查询约束的记录：\r\n\r\n    $this->assertDatabaseHas('users', [\r\n        'email' => 'sally@example.com',\r\n    ]);\r\n\r\n<a name=\"assert-database-missing\"></a>\r\n#### assertDatabaseMissing\r\n\r\n断言数据库中的表不包含给定键/值查询约束的记录：\r\n\r\n    $this->assertDatabaseMissing('users', [\r\n        'email' => 'sally@example.com',\r\n    ]);\r\n\r\n<a name=\"assert-deleted\"></a>\r\n#### assertSoftDeleted\r\n\r\n `assertSoftDeleted` 方法断言给定的 Eloquent 模型已被「软删除」的记录：\r\n\r\n    $this->assertSoftDeleted($user);\r\n    \r\n<a name=\"assert-not-deleted\"></a>\r\n#### assertNotSoftDeleted\r\n\r\n`assertNotSoftDeleted` 方法断言给定的 Eloquent 模型没有被「软删除」的记录：\r\n\r\n    $this->assertNotSoftDeleted($user);\r\n\r\n<a name=\"assert-model-exists\"></a>\r\n#### assertModelExists\r\n\r\n断言数据库中存在给定的模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()->create();\r\n\r\n    $this->assertModelExists($user);\r\n\r\n<a name=\"assert-model-missing\"></a>\r\n#### assertModelMissing\r\n\r\n断言数据库中不存在给定的模型：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::factory()->create();\r\n\r\n    $user->delete();\r\n\r\n    $this->assertModelMissing($user);\r\n\r\n<a name=\"expects-database-query-count\"></a>\r\n#### expectsDatabaseQueryCount\r\n\r\n可以在测试开始时调用 `expectsDatabaseQueryCount` 方法，以指定你希望在测试期间运行的数据库查询总数。如果实际执行的查询数量与这个预期不完全匹配，那么测试将失败：\r\n\r\n    $this->expectsDatabaseQueryCount(5);\r\n\r\n    // Test...\r\n\r\n","p":"docs/database-testing.html"},{"t":"mocking (Mocking)","d":"\n# Mocking\r\n\r\n- [简介](#introduction)\r\n- [模拟对象](#mocking-objects)\r\n- [模拟 Facades](#mocking-facades)\r\n    - [Facade Spies](#facade-spies)\r\n- [设置时间](#interacting-with-time)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n在 Laravel 应用程序测试中，你可能希望「模拟」应用程序的某些功能的行为，从而避免该部分在测试中真正执行。例如：在控制器执行过程中会触发事件，您可能希望模拟事件监听器，从而避免该事件在测试时真正执行。这允许你在仅测试控制器 HTTP 响应的情况时，而不必担心触发事件，因为事件侦听器可以在它们自己的测试用例中进行测试。\r\n\r\nLaravel 针对事件、任务和 Facades 的模拟，提供了开箱即用的辅助函数。这些函数基于 `Mockery` 封装而成，使用非常方便，无需手动调用复杂的 `Mockery` 函数。\r\n\r\n<a name=\"mocking-objects\"></a>\r\n## 模拟对象\r\n\r\n当模拟一个对象将通过 Laravel 的 [服务容器](/docs/laravel/10.x/container) 注入到应用中时，你将需要将模拟实例作为 `instance` 绑定到容器中。这将告诉容器使用对象的模拟实例，而不是构造对象的本身：\r\n\r\n    use App\\Service;\r\n    use Mockery;\r\n    use Mockery\\MockInterface;\r\n\r\n    public function test_something_can_be_mocked(): void\r\n    {\r\n        $this->instance(\r\n            Service::class,\r\n            Mockery::mock(Service::class, function (MockInterface $mock) {\r\n                $mock->shouldReceive('process')->once();\r\n            })\r\n        );\r\n    }\r\n\r\n为了让以上过程更便捷，你可以使用 Laravel 的基本测试用例类提供的 `mock` 方法。例如，下面的例子跟上面的例子的执行效果是一样的：\r\n\r\n    use App\\Service;\r\n    use Mockery\\MockInterface;\r\n\r\n    $mock = $this->mock(Service::class, function (MockInterface $mock) {\r\n        $mock->shouldReceive('process')->once();\r\n    });\r\n\r\n\n\n当你只需要模拟对象的几个方法时，可以使用 `partialMock` 方法。 未被模拟的方法将在调用时正常执行：\r\n\r\n    use App\\Service;\r\n    use Mockery\\MockInterface;\r\n\r\n    $mock = $this->partialMock(Service::class, function (MockInterface $mock) {\r\n        $mock->shouldReceive('process')->once();\r\n    });\r\n\r\n同样，如果你想 [监控](http://docs.mockery.io/en/latest/reference/spies.html) 一个对象，Laravel 的基本测试用例类提供了一个便捷的 `spy` 方法作为 `Mockery::spy` 的替代方法。`spies` 与模拟类似。但是，`spies` 会记录 `spy` 与被测试代码之间的所有交互，从而允许您在执行代码后做出断言：\r\n\r\n    use App\\Service;\r\n\r\n    $spy = $this->spy(Service::class);\r\n\r\n    // ...\r\n\r\n    $spy->shouldHaveReceived('process');\r\n\r\n<a name=\"mocking-facades\"></a>\r\n## Facades 模拟\r\n\r\n与传统静态方法调用不同的是，[facades](/docs/laravel/10.x/facades) (包含的 [real-time facades](/docs/laravel/10.x/facades#real-time-facades)) 也可以被模拟。相较传统的静态方法而言，它具有很大的优势，同时提供了与传统依赖注入相同的可测试性。在测试中，你可能想在控制器中模拟对 Laravel Facade 的调用。比如下面控制器中的行为：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Controllers;\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    class UserController extends Controller\r\n    {\r\n        /**\r\n         * 显示该应用程序的所有用户的列表。\r\n         */\r\n        public function index(): array\r\n        {\r\n            $value = Cache::get('key');\r\n\r\n            return [\r\n                // ...\r\n            ];\r\n        }\r\n    }\r\n\r\n我们可以使用 `shouldReceive` 方法模拟对 `Cache` Facade 的调用，该方法将返回一个 [Mockery](https://github.com/padraic/mockery) 模拟的实例。由于 Facades 实际上是由 Laravel [服务容器](/docs/laravel/10.x/container) 解析和管理的，因此它们比传统的静态类具有更好的可测试性。例如，让我们模拟对 `Cache` Facade 的 `get` 方法的调用：\r\n\r\n    <?php\r\n\r\n    namespace Tests\\Feature;\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n    use Tests\\TestCase;\r\n\r\n    class UserControllerTest extends TestCase\r\n    {\r\n        public function test_get_index(): void\r\n        {\r\n            Cache::shouldReceive('get')\r\n                        ->once()\r\n                        ->with('key')\r\n                        ->andReturn('value');\r\n\r\n            $response = $this->get('/users');\r\n\r\n            // ...\r\n        }\r\n    }\r\n\r\n> **注意**\r\n> 你不应该模拟 `Request` facade。相反，在运行测试时将你想要的输入传递到 [HTTP 测试方法](/docs/laravel/10.x/http-tests) 中，例如 `get` 和 `post` 方法。同样也不要模拟 `Config` facade，而是在测试中调用 `Config::set` 方法。\r\n\n\n<a name=\"facade-spies\"></a>\r\n### Facade Spies\r\n\r\n如果你想 [监控](http://docs.mockery.io/en/latest/reference/spies.html) 一个 facade，你可以在相应的 facade 上调用 `spy` 方法。`spies` 类似于 `mocks`；但是，`spies` 会记录 `spy` 和被测试代码之间的所有交互，允许你在代码执行后做出断言：\r\n\r\n    use Illuminate\\Support\\Facades\\Cache;\r\n\r\n    public function test_values_are_be_stored_in_cache(): void\r\n    {\r\n        Cache::spy();\r\n\r\n        $response = $this->get('/');\r\n\r\n        $response->assertStatus(200);\r\n\r\n        Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);\r\n    }\r\n\r\n<a name=\"interacting-with-time\"></a>\r\n## 设置时间\r\n\r\n当我们测试时，有时可能需要修改诸如 `now` 或 `Illuminate\\Support\\Carbon::now()` 之类的助手函数返回的时间。 Laravel 的基本功能测试类包中包含了一些助手函数，可以让你设置当前时间：\r\n\r\n    use Illuminate\\Support\\Carbon;\r\n\r\n    public function test_time_can_be_manipulated(): void\r\n    {\r\n        // 设置未来的时间...\r\n        $this->travel(5)->milliseconds();\r\n        $this->travel(5)->seconds();\r\n        $this->travel(5)->minutes();\r\n        $this->travel(5)->hours();\r\n        $this->travel(5)->days();\r\n        $this->travel(5)->weeks();\r\n        $this->travel(5)->years();\r\n\r\n        // 设置过去的时间...\r\n        $this->travel(-5)->hours();\r\n\r\n        // 设置一个确切的时间...\r\n        $this->travelTo(now()->subHours(6));\r\n\r\n        // 返回现在的时间...\r\n        $this->travelBack();\r\n    }\r\n\r\n你还可以为各种设置时间方法写一个闭包。闭包将在指定的时间被冻结调用。一旦闭包执行完毕，时间将恢复正常:\r\n\r\n    $this->travel(5)->days(function () {\r\n        // 在5天之后测试...\r\n    });\r\n    \r\n    $this->travelTo(now()->subDays(10), function () {\r\n        // 在指定的时间测试...\r\n    });\r\n\r\n\n\n`freezeTime` 方法可用于冻结当前时间。与之类似地，`freezeSecond` 方法也可以秒为单位冻结当前时间：\r\n\r\n    use Illuminate\\Support\\Carbon;\r\n\r\n    // 冻结时间并在完成后恢复正常时间...\r\n    $this->freezeTime(function (Carbon $time) {\r\n        // ...\r\n    });\r\n\r\n    // 冻结以秒为单位的时间并在完成后恢复正常时间...\r\n    $this->freezeSecond(function (Carbon $time) {\r\n        // ...\r\n    })\r\n\r\n正如你期望的一样，上面讨论的所有方法都主要用于测试对时间敏感的应用程序的行为，比如锁定论坛上不活跃的帖子:\r\n\r\n    use App\\Models\\Thread;\r\n    \r\n    public function test_forum_threads_lock_after_one_week_of_inactivity()\r\n    {\r\n        $thread = Thread::factory()->create();\r\n        \r\n        $this->travel(1)->week();\r\n        \r\n        $this->assertTrue($thread->isLockedByInactivity());\r\n    }\r\n\n","p":"docs/mocking.html"},{"t":"billing (Laravel Cashier (Stripe))","d":"# Laravel Cashier (Stripe)\r\n\r\n- [简介](#introduction)\r\n- [升级 Cashier](#upgrading-cashier)\r\n- [安装](#installation)\r\n    - [数据库迁移](#database-migrations)\r\n- [配置信息](#configuration)\r\n    - [计费模型](#billable-model)\r\n    - [API 密钥](#api-keys)\r\n    - [货币配置](#currency-configuration)\r\n    - [税务配置](#tax-configuration)\r\n    - [日志](#logging)\r\n    - [使用自定义模型](#using-custom-models)\r\n- [消费者](#customers)\r\n    - [获取消费者](#retrieving-customers)\r\n    - [创建消费者](#creating-customers)\r\n    - [更新消费者](#updating-customers)\r\n    - [余额](#balances)\r\n    - [税号](#tax-ids)\r\n    - [使用 Stripe 同步客户数据](#syncing-customer-data-with-stripe)\r\n    - [计费门户](#billing-portal)\r\n- [支付方式](#payment-methods)\r\n    - [存储支付方式](#storing-payment-methods)\r\n    - [检索支付方式](#retrieving-payment-methods)\r\n    - [判断用户是否有支付方式](#check-for-a-payment-method)\r\n    - [更新默认支付方式](#updating-the-default-payment-method)\r\n    - [添加支付方式](#adding-payment-methods)\r\n    - [删除支付方式](#deleting-payment-methods)\r\n- [订阅内容](#subscriptions)\r\n    - [创建订阅](#creating-subscriptions)\r\n    - [检查订阅状态](#checking-subscription-status)\r\n    - [修改价格](#changing-prices)\r\n    - [订阅数量](#subscription-quantity)\r\n    - [多个产品的订阅](#subscriptions-with-multiple-products)\r\n    - [多方案订阅计划](#multiprice-subscriptions)\r\n    - [计量计费](#metered-billing)\r\n    - [订阅税](#subscription-taxes)\r\n    - [订阅锚定日期](#subscription-anchor-date)\r\n    - [取消订阅](#cancelling-subscriptions)\r\n    - [恢复订阅](#resuming-subscriptions)\r\n- [订阅试用](#subscription-trials)\r\n    - [预先使用付款方式](#with-payment-method-up-front)\r\n    - [没有预先付款方式](#without-payment-method-up-front)\r\n    - [延长试用期](#extending-trials)\r\n- [处理 Stripe Webhooks](#handling-stripe-webhooks)\r\n    - [定义 Webhook 事件处理器](#defining-webhook-event-handlers)\r\n    - [验证 Webhook 签名](#verifying-webhook-signatures)\r\n- [单次收费](#single-charges)\r\n    - [基本使用](#simple-charge)\r\n    - [带发票的支付](#charge-with-invoice)\r\n    - [创建支付意向](#creating-payment-intents)\r\n    - [退款](#refunding-charges)\r\n- [结账](#checkout)\r\n    - [产品结账](#product-checkouts)\r\n    - [单次支付结账](#single-charge-checkouts)\r\n    - [订阅结账](#subscription-checkouts)\r\n    - [收集税号](#collecting-tax-ids)\r\n    - [访客结账](#guest-checkouts)\r\n- [发票](#invoices)\r\n    - [获取发票](#retrieving-invoices)\r\n    - [即将发布的发票](#upcoming-invoices)\r\n    - [预览订阅发票](#previewing-subscription-invoices)\r\n    - [生成发票 PDF](#generating-invoice-pdfs)\r\n- [处理支付失败](#handling-failed-payments)\r\n- [强大的客户身份验证 (SCA)](#strong-customer-authentication)\r\n    - [需要额外确认的支付](#payments-requiring-additional-confirmation)\r\n    - [非会话支付通知](#off-session-payment-notifications)\r\n- [Stripe SDK](#stripe-sdk)\r\n- [测试](#testing)\r\n\r\n\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Cashier Stripe](https://github.com/laravel/cashier-stripe) 为 [Stripe](https://stripe.com) 的订阅计费服务提供了一个富有表现力、流畅的接口。它处理了几乎所有你害怕编写的订阅计费样板代码。除了基本的订阅管理，Cashier 还可以处理优惠券、交换订阅、订阅 「数量」、取消宽限期，甚至生成发票 PDF。\r\n\r\n<a name=\"upgrading-cashier\"></a>\r\n## 升级 Cashier\r\n\r\n升级到新版本的 Cashier 时，请务必仔细阅读[升级指南](https://github.com/laravel/cashier-stripe/blob/master/UPGRADE.)。\r\n\r\n> **注意**\r\n> 为了防止破坏性变更，Cashier 使用固定的 Stripe API 版本。 Cashier 14 使用 Stripe API 版本 `2022-11-15` 。Stripe API 版本将在次要版本上更新，以利用新的 Stripe 功能和改进。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，使用 Composer 为 Stripe 安装 Cashier 扩展包：\r\n\r\n```shell\r\ncomposer require laravel/cashier\r\n```\r\n> **注意**\r\n> 为确保 Cashier 正确处理所有 Stripe 事件，请记得[设置 Cashier 的 webhook](#handling-stripe-webhooks)。\r\n\r\n<a name=\"database-migrations\"></a>\r\n### 数据库迁移\r\n\r\nCashier 的服务提供器注册了自己的数据库迁移目录，因此请记住在安装此包后迁移数据库。Cashier 迁移将向 `users` 表中添加多个列，并创建一个新的 `subscriptions` 表来保存客户的所有订阅：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n如果需要覆盖 Cashier 附带的迁移，可以使用 `vendor:publish` Artisan 命令发布它们：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=\"cashier-migrations\"\r\n```\r\n\r\n如果你想阻止 Cashier 的迁移完全运行，可以使用 Cashier 提供的`ignoreMigrations` 方法。通常应在 `AppServiceProvider` 类的 `register` 方法中调用此方法：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    /**\r\n     * 注册任何应用程序服务。\r\n     *\r\n     */\r\n    public function register(): void\r\n    {\r\n        Cashier::ignoreMigrations();\r\n    }\r\n\r\n> **注意**\r\n>  Stripe 建议用于存储 Stripe 标识符的任何列都应区分大小写。因此，在使用 MySQL 时，应该确保将 `stripe_id` 列排序规则设置为 `utf8_bin` 。更多关于这方面的信息可以在 [Stripe 文档](https://stripe.com/docs/upgrades#what-changes-does-stripe-consider-to-be-backwards-compatible)中找到。\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"billable-model\"></a>\r\n### 订单模型\r\n\r\n在使用 Cashier 之前，需要将 `Billable` trait 添加到可订单模型定义中。通常会放在 `App\\Models\\User` 模型中。这个特性提供了多个方法以便执行常用支付任务，如创建订阅、应用优惠券和更新支付方法信息：\r\n\r\n    use Laravel\\Cashier\\Billable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Billable;\r\n    }\r\n\r\nCashier 默认假设你的 Billable 模型是 Laravel 自带的 `App\\Models\\User` 类。如果需要修改可以在 `useCustomerModel` 方法定义一个不同的模型。通常此方法在 `AppServiceProvider` 类的`boot`方法中被调用：\r\n\r\n    use App\\Models\\Cashier\\User;\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Cashier::useCustomerModel(User::class);\r\n    }\r\n\r\n> **注意**\r\n> 如果你使用的不是 Laravel 自带的 `App\\Models\\User` 模型，需要发布并修改默认的 [Cashier 迁移](#installation)文件以匹配你使用模型对应的表名。\r\n\r\n<a name=\"api-keys\"></a>\r\n### API 秘钥\r\n\r\n接下来需要在 `.env` 文件中配置 Stripe 秘钥，可以在 Stripe 后台控制面板中获取Stripe API 秘钥：\r\n\r\n```ini\r\nSTRIPE_KEY=your-stripe-key\r\nSTRIPE_SECRET=your-stripe-secret\r\nSTRIPE_WEBHOOK_SECRET=your-stripe-webhook-secret\r\n```\r\n> **注意**\r\n> 你应该确保在应用程序的`.env`文件中定义了`STRIPE_WEBHOOK_SECRET`环境变量，因为该变量用于确保传入的 Webhook 确实来自 Stripe。\r\n\r\n<a name=\"currency-configuration\"></a>\r\n### 货币配置\r\n\r\nCashier 默认货币是美元 (USD)，可以在 `.env` 中设置 `CASHIER_CURRENCY` 环境变量来修改默认的货币配置：\r\n\r\n```ini\r\nCASHIER_CURRENCY=eur\r\n```\r\n\r\n除了配置 Cashier 的货币之外，还可以在格式化用于显示在发票上的金额时指定本地化配置。在底层，Cashier 使用了 [PHP 的 `NumberFormatter` 类](https://www.php.net/manual/en/class.numberformatter.php)来设置本地货币：\r\n\r\n```ini\r\nCASHIER_CURRENCY_LOCALE=nl_BE\r\n```\r\n\r\n> **注意**\r\n> 为了使用本地化配置而不是 `en`，需要确保安装了 PHP `ext-intl` PHP 扩展并在服务器上启用配置。\r\n\r\n<a name=\"tax-configuration\"></a>\r\n### 税务配置\r\n\r\n感谢[Stripe  税务](https://stripe.com/tax)，可以自动计算 Stripe 生成的所有发票的税费。 可以通过应用程序的 `App\\Providers\\AppServiceProvider`类的 `boot` 方法中调用 `calculateTaxes` 来启用自动税务计算：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Cashier::calculateTaxes();\r\n    }\r\n\r\n启动税务计算后，任何新订阅和生成的一次性发票都会进行自动税务计算。\r\n\r\n为了使这个功能正常使用，客户的账单明细中例如客户姓名、住址、发票 ID 需要同步到 Stripe。你可以使用 Cashier 提供的[客户数据同步](#syncing-customer-data-with-stripe)和 [Tax ID](#tax-ids) 方法来完成此操作。\r\n\r\n> **注意**\r\n> 对于[单次收费](#single-charges)或[单次支付结账](#single-charge-checkouts)，不支持计算税费。\r\n\r\n<a name=\"logging\"></a>\r\n### 日志\r\n\r\nCashier 允许你指定日志通道来记录所有与 Stripe 相关的异常。可以通过在  `.env` 中配置 `CASHIER_LOGGER` 来指定：\r\n\r\n```ini\r\nCASHIER_LOGGER=stack\r\n```\r\n\r\n对 Stripe 的 API 调用生成的异常将通过应用程序的默认日志通道记录。\r\n\r\n<a name=\"using-custom-models\"></a>\r\n### 使用自定义模型\r\n\r\n你可以通过定义自己的模型并扩展相应的 `Cashier` 模型来自由扩展 Cashier 内部的模型，增加一些方法：\r\n\r\n    use Laravel\\Cashier\\Subscription as CashierSubscription;\r\n\r\n    class Subscription extends CashierSubscription\r\n    {\r\n        // ...\r\n    }\r\n\r\n定义模型后，可以通过 `Laravel\\Cashier\\Cashier` 类配置 Cashier 使用自定义的模型。通常还需要在 `App\\Providers\\AppServiceProvider` 类的 `boot` 中注册一下：\r\n\r\n    use App\\Models\\Cashier\\Subscription;\r\n    use App\\Models\\Cashier\\SubscriptionItem;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Cashier::useSubscriptionModel(Subscription::class);\r\n        Cashier::useSubscriptionItemModel(SubscriptionItem::class);\r\n    }\r\n\r\n<a name=\"customers\"></a>\r\n## 消费者\r\n\r\n<a name=\"retrieving-customers\"></a>\r\n### 获取消费者\r\n\r\n你可以使用 `Cashier::findBillable` 方法通过 Stripe ID 查询消费者信息。该方法返回的是一个 billable 模型实例：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    $user = Cashier::findBillable($stripeId);\r\n\r\n<a name=\"creating-customers\"></a>\r\n### 创建客户\r\n\r\n有时，你可能希望在不开始订阅的情况下创建一个 Stripe 客户。 你可以使用 `createAsStripeCustomer` 方法完成此操作：\r\n\r\n    $stripeCustomer = $user->createAsStripeCustomer();\r\n\r\n在 Stripe 中创建客户后，你可以在以后开始订阅。 你可以提供一个可选的 `$options` 数组来传递任何额外的 [Stripe API 支持的客户创建参数](https://stripe.com/docs/api/customers/create)：\r\n\r\n    $stripeCustomer = $user->createAsStripeCustomer($options);\r\n\r\n如果你想为计费模型返回 Stripe 客户对象，你可以使用 `asStripeCustomer` 方法：\r\n\r\n    $stripeCustomer = $user->asStripeCustomer();\r\n\r\n如果你想为给定的计费模型检索 Stripe 客户对象，但不确定该计费模型是否已经是 Stripe 中的客户，则可以使用 createOrGetStripeCustomer 方法。 如果尚不存在，此方法将在 Stripe 中创建一个新客户：\r\n\r\n    $stripeCustomer = $user->createOrGetStripeCustomer();\r\n\r\n<a name=\"updating-customers\"></a>\r\n### 更新客户\r\n\r\n有时，你可能希望直接向 Stripe 客户更新其他信息。 你可以使用 `updateStripeCustomer` 方法完成此操作。 此方法接受一组 [Stripe API 支持的客户更新选项](https://stripe.com/docs/api/customers/update)：\r\n\r\n    $stripeCustomer = $user->updateStripeCustomer($options);\r\n\r\n<a name=\"balances\"></a>\r\n### 余额\r\n\r\nStripe 允许你贷记或借记客户的「余额」。 稍后，此余额将在新发票上贷记或借记。 要检查客户的总余额，你可以使用计费模型上提供的「余额」方法。 `balance` 方法将返回以客户货币表示的余额的格式化字符串表示形式：\r\n\r\n    $balance = $user->balance();\r\n\r\n要记入客户的余额，可以为该 `creditBalance` 方法提供一个值。如果你愿意，还可以提供描述：\r\n\r\n    $user->creditBalance(500, 'Premium customer top-up.');\r\n\r\n为该方法提供一个值 `debitBalance` 将从客户的余额中扣除：\r\n\r\n    $user->debitBalance(300, 'Bad usage penalty.');\r\n\r\n`applyBalance` 方法会创建一条客户余额流水记录。可以通过调用 `balanceTransactions` 方法获取余额交易记录，这有助于提供借记或贷记记录给客户查看：\r\n\r\n    // 检索所有交易...\r\n    $transactions = $user->balanceTransactions();\r\n\r\n    foreach ($transactions as $transaction) {\r\n        // 交易量...\r\n        $amount = $transaction->amount(); // $2.31\r\n\r\n        // 在可用的情况下检索相关发票...\r\n        $invoice = $transaction->invoice();\r\n    }\r\n\r\n<a name=\"tax-ids\"></a>\r\n### 税号\r\n\r\nCashier 提供了一种管理客户税号的简便方法。`taxIds` 例如，`taxIds` 方法可用于检索作为集合分配给客户的所有[税号](https://stripe.com/docs/api/customer_tax_ids/object)：\r\n\r\n    $taxIds = $user->taxIds();\r\n\r\n你还可以通过标识符检索客户的特定税号：\r\n\r\n    $taxId = $user->findTaxId('txi_belgium');\r\n\r\n你可以通过向 `createTaxId` 方法提供有效的 [type](https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object-type) 和值来创建新的税号：\r\n\r\n    $taxId = $user->createTaxId('eu_vat', 'BE0123456789');\r\n\r\n`createTaxId` 方法将立即将增值税 ID 添加到客户的帐户中。 [增值税 ID 的验证也由 Stripe 完成](https://stripe.com/docs/invoicing/customer/tax-ids#validation)； 然而，这是一个异步的过程。 你可以通过订阅 `customer.tax_id.updated` webhook 事件并检查 [增值税 ID `verification` 参数](https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object-verification)。 有关处理 webhook 的更多信息，请参阅[有关定义 webhook 处理程序的文档](#handling-stripe-webhooks)。\r\n\r\n你可以使用 `deleteTaxId` 方法删除税号：\r\n\r\n    $user->deleteTaxId('txi_belgium');\r\n\r\n<a name=\"syncing-customer-data-with-stripe\"></a>\r\n### 使用 Stripe 同步客户数据\r\n\r\n通常，当你的应用程序的用户更新他们的姓名、电子邮件地址或其他也由 Stripe 存储的信息时，你应该通知 Stripe 更新。 这样一来，Stripe 的信息副本将与你的应用程序同步。\r\n\r\n要自动执行此操作，你可以在计费模型上定义一个事件侦听器，以响应模型的`updated` 事件。然后，在你的事件监听器中，你可以在模型上调用 `syncStripeCustomerDetails` 方法：\r\n\r\n    use App\\Models\\User;\r\n    use function Illuminate\\Events\\queueable;\r\n\r\n    /**\r\n     * 模型的「引导」方法。\r\n     */\r\n    protected static function booted(): void\r\n    {\r\n        static::updated(queueable(function (User $customer) {\r\n            if ($customer->hasStripeId()) {\r\n                $customer->syncStripeCustomerDetails();\r\n            }\r\n        }));\r\n    }\r\n\r\n现在，每次更新你的客户模型时，其信息都会与 Stripe 同步。 为方便起见，Cashier 会在初始创建客户时自动将你客户的信息与 Stripe 同步。\r\n\r\n你可以通过覆盖 Cashier 提供的各种方法来自定义用于将客户信息同步到 Stripe 的列。 例如，当 Cashier 将客户信息同步到 Stripe 时，你可以重写 `stripeName` 方法来自定义应该被视为客户「姓名」的属性：\r\n\r\n    /**\r\n     * 获取应同步到 Stripe 的客户名称。\r\n     */\r\n    public function stripeName(): string|null\r\n    {\r\n        return $this->company_name;\r\n    }\r\n\r\n同样，你可以复写 `stripeEmail`、`stripePhone` 和 `stripeAddress` 方法。 当[更新 Stripe 客户对象](https://stripe.com/docs/api/customers/update)时，这些方法会将信息同步到其相应的客户参数。 如果你希望完全控制客户信息同步过程，你可以复写 `syncStripeCustomerDetails` 方法。\r\n\r\n<a name=\"billing-portal\"></a>\r\n### 订单入口\r\n\r\nStripe 提供了一个简单的方式来[设置订单入口](https://stripe.com/docs/billing/subscriptions/customer-portal)以便用户可以管理订阅、支付方法、以及查看历史账单。你可以在控制器或路由中使用 `redirectToBillingPortal` 方法将用户重定向到账单入口：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/billing-portal', function (Request $request) {\r\n        return $request->user()->redirectToBillingPortal();\r\n    });\r\n\r\n默认情况下，当用户完成对订阅的管理后，会将能够通过 Stripe 计费门户中的链接返回到应用的 home 路由，你可以通过传递 URL 作为 `redirectToBillingPortal` 方法的参数来自定义用户返回的 URL：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/billing-portal', function (Request $request) {\r\n        return $request->user()->redirectToBillingPortal(route('billing'));\r\n    });\r\n\r\n如果你只想要生成订单入口的 URL，可以使用 `billingPortalUrl` 方法：\r\n\r\n    $url = $request->user()->billingPortalUrl(route('billing'));\r\n\r\n<a name=\"payment-methods\"></a>\r\n## 支付方式\r\n\r\n<a name=\"storing-payment-methods\"></a>\r\n### 存储支付方式\r\n\r\n为了使用 Stripe 创建订阅或者进行「一次性」支付，你需要存储支付方法并从 Stripe 中获取对应的标识符。这种方式可用于实现你是否计划使用这个支付方法进行订阅还是单次收费，下面我们分别来介绍这两种方法。\r\n\r\n<a name=\"payment-methods-for-subscriptions\"></a>\r\n#### 订阅付款方式\r\n\r\n当存储客户的信用卡信息以备将来订阅使用时，必须使用 Stripe「Setup Intents」API 来安全地收集客户的支付方式详细信息。 「Setup Intent」向 Stripe 指示向客户的付款方式收费的目的。 Cashier 的 `Billable` 特性包括 `createSetupIntent` 方法，可轻松创建新的设置目的。 你应该从将呈现收集客户付款方式详细信息的表单的路由或控制器调用此方法：\r\n\r\n    return view('update-payment-method', [\r\n        'intent' => $user->createSetupIntent()\r\n    ]);\r\n\r\n创建设置目的并将其传递给视图后，你应该将其秘密附加到将收集付款方式的元素。 例如，考虑这个「更新付款方式」表单：\r\n\r\n```html\r\n<input id=\"card-holder-name\" type=\"text\">\r\n\r\n<!-- Stripe 元素占位符 -->\r\n<div id=\"card-element\"></div>\r\n\r\n<button id=\"card-button\" data-secret=\"{{ $intent->client_secret }}\">\r\n    更新付款方式\r\n</button>\r\n```\r\n\r\n接下来，可以使用 Stripe.js 库将 [Stripe 元素](https://stripe.com/docs/stripe-js) 附加到表单并安全地收集客户的付款详细信息：\r\n\r\n```html\r\n<script src=\"https://js.stripe.com/v3/\"></script>\r\n\r\n<script>\r\n    const stripe = Stripe('stripe-public-key');\r\n\r\n    const elements = stripe.elements();\r\n    const cardElement = elements.create('card');\r\n\r\n    cardElement.mount('#card-element');\r\n</script>\r\n```\r\n\r\n接下来，可以验证卡并使用 [Stripe 的 `confirmCardSetup` 方法](https://stripe.com/docs/js/setup_intents/confirm_card_setup)从 Stripe 检索安全的「支付方式标识符」：\r\n\r\n```js\r\nconst cardHolderName = document.getElementById('card-holder-name');\r\nconst cardButton = document.getElementById('card-button');\r\nconst clientSecret = cardButton.dataset.secret;\r\n\r\ncardButton.addEventListener('click', async (e) => {\r\n    const { setupIntent, error } = await stripe.confirmCardSetup(\r\n        clientSecret, {\r\n            payment_method: {\r\n                card: cardElement,\r\n                billing_details: { name: cardHolderName.value }\r\n            }\r\n        }\r\n    );\r\n\r\n    if (error) {\r\n        // 向用户显示「error.message」...\r\n    } else {\r\n        // 卡已验证成功...\r\n    }\r\n});\r\n```\r\n\r\n#### 订阅付款方式\r\n\r\n存储客户的银行卡信息以备将来订阅时使用，必须使用 Stripe「Setup Intents」API 来安全地收集客户的支付方式详细信息。 「设置意图」 向Stripe 指示向客户的付款方式收费的目的。 Cashier 的 `Billable` 特性包括 `createSetupIntent` 方法，可轻松创建新的设置意图。你应该从路由或控制器调用此方法，该路由或控制器将呈现收集客户付款方法详细信息的表单:\r\n\r\n    return view('update-payment-method', [\r\n        'intent' => $user->createSetupIntent()\r\n    ]);\r\n\r\n创建设置意图并将其传递给视图后，你应该将其秘密附加到将收集付款方式的元素。 例如，考虑这个「更新付款方式」表单:\r\n\r\n```html\r\n<input id=\"card-holder-name\" type=\"text\">\r\n\r\n<!-- Stripe 元素占位符 -->\r\n<div id=\"card-element\"></div>\r\n\r\n<button id=\"card-button\" data-secret=\"{{ $intent->client_secret }}\">\r\n    更新付款方式\r\n</button>\r\n```\r\n\r\n接下来，可以使用 Stripe.js 库将 [Stripe 元素](https://stripe.com/docs/stripe-js)附加到表单并安全地收集客户的付款详细信息:\r\n\r\n```html\r\n<script src=\"https://js.stripe.com/v3/\"></script>\r\n\r\n<script>\r\n    const stripe = Stripe('stripe-public-key');\r\n\r\n    const elements = stripe.elements();\r\n    const cardElement = elements.create('card');\r\n\r\n    cardElement.mount('#card-element');\r\n</script>\r\n```\r\n\r\n接下来，可以从 Stripe 搜索安全的「支付方式标识符」验证银行卡并使用 [Stripe 的 `confirmCardSetup` 方法](https://stripe.com/docs/js/setup_intents/confirm_card_setup):\r\n\r\n```js\r\nconst cardHolderName = document.getElementById('card-holder-name');\r\nconst cardButton = document.getElementById('card-button');\r\nconst clientSecret = cardButton.dataset.secret;\r\n\r\ncardButton.addEventListener('click', async (e) => {\r\n    const { setupIntent, error } = await stripe.confirmCardSetup(\r\n        clientSecret, {\r\n            payment_method: {\r\n                card: cardElement,\r\n                billing_details: { name: cardHolderName.value }\r\n            }\r\n        }\r\n    );\r\n\r\n    if (error) {\r\n        // 向用户显示「error.message」...\r\n    } else {\r\n        // 该银行卡已验证成功...\r\n    }\r\n});\r\n```\r\n\r\n银行卡通过 Stripe 验证后，你可以将生成的 `setupIntent.payment_method` 标识符传递给你的 Laravel 应用程序，在那里它可以附加到客户。 付款方式可以[添加为新付款方式](#adding-payment-methods)或[用于更新默认付款方式](#updating-the-default-payment-method)。 你还可以立即使用付款方式标识符来[创建新订阅](#creating-subscriptions)。\r\n\r\n> **技巧**  \r\n> 如果你想了解有关设置目的和收集客户付款详细信息的更多信息，请[查看 Stripe 提供的概述](https://stripe.com/docs/payments/save-and-reuse#php)。\r\n\r\n<a name=\"payment-methods-for-single-charges\"></a>\r\n#### 单笔费用的支付方式\r\n\r\n当然，在针对客户的支付方式进行单笔收费时，我们只需要使用一次支付方式标识符。 由于 Stripe 的限制，你不能使用客户存储的默认付款方式进行单笔收费。 你必须允许客户使用 Stripe.js 库输入他们的付款方式详细信息。 例如，考虑以下形式：\r\n\r\n```html\r\n<input id=\"card-holder-name\" type=\"text\">\r\n\r\n<!-- Stripe 元素占位符 -->\r\n<div id=\"card-element\"></div>\r\n\r\n<button id=\"card-button\">\r\n    处理付款\r\n</button>\r\n```\r\n\r\n定义这样的表单后，可以使用 Stripe.js 库将[Stripe 元素](https://stripe.com/docs/stripe-js)附加到表单并安全地收集客户的付款详细信息：\r\n\r\n```html\r\n<script src=\"https://js.stripe.com/v3/\"></script>\r\n\r\n<script>\r\n    const stripe = Stripe('stripe-public-key');\r\n\r\n    const elements = stripe.elements();\r\n    const cardElement = elements.create('card');\r\n\r\n    cardElement.mount('#card-element');\r\n</script>\r\n```\r\n\r\n接下来，可以验证卡并使用 [Stripe 的 `createPaymentMethod` 方法](https://stripe.com/docs/stripe-js/reference#stripe-create-payment) 从 Stripe 检索安全的「支付方式标识符」-方法）：\r\n\r\n```js\r\nconst cardHolderName = document.getElementById('card-holder-name');\r\nconst cardButton = document.getElementById('card-button');\r\n\r\ncardButton.addEventListener('click', async (e) => {\r\n    const { paymentMethod, error } = await stripe.createPaymentMethod(\r\n        'card', cardElement, {\r\n            billing_details: { name: cardHolderName.value }\r\n        }\r\n    );\r\n\r\n    if (error) {\r\n        // 向用户显示「error.message」...\r\n    } else {\r\n        // 卡已验证成功...\r\n    }\r\n});\r\n```\r\n\r\n银行卡通过 Stripe 验证后，你可以将生成的 `setupIntent.payment_method` 标识符传递给你的 Laravel 应用程序，在那里它可以附加到客户。付款方式可以[添加为新付款方式](#adding-payment-methods)或[用于更新默认付款方式](#updating-the-default-payment-method)。 你还可以立即使用付款方式标识符来[创建新订阅](#creating-subscriptions)。\r\n\r\n> **笔记**\r\n> 如果你想了解有关设置目的和收集客户付款详细信息的更多信息，请[查看 Stripe 提供的概述](https://stripe.com/docs/payments/save-and-reuse#php).\r\n\r\n<a name=\"payment-methods-for-single-charges\"></a>\r\n#### 单笔费用的支付方式\r\n\r\n当然，在针对客户的支付方式进行单笔收费时，我们只需要使用一次支付方式标识符。 由于 Stripe 的限制，你不能使用客户存储的默认付款方式进行单笔收费。 你必须允许客户使用 Stripe.js 库输入他们的付款方式详细信息。 例如，考虑以下形式：\r\n\r\n```html\r\n<input id=\"card-holder-name\" type=\"text\">\r\n\r\n<!-- Stripe 元素占位符 -->\r\n<div id=\"card-element\"></div>\r\n\r\n<button id=\"card-button\">\r\n    付款流程\r\n</button>\r\n```\r\n\r\n在定义了这样一个表单之后，可以使用 Stripe.js 库将 [Stripe Element](https://stripe.com/docs/stripe-js) 附加到表单并安全地收集客户的付款详细信息：\r\n\r\n```html\r\n<script src=\"https://js.stripe.com/v3/\"></script>\r\n\r\n<script>\r\n    const stripe = Stripe('stripe-public-key');\r\n\r\n    const elements = stripe.elements();\r\n    const cardElement = elements.create('card');\r\n\r\n    cardElement.mount('#card-element');\r\n</script>\r\n```\r\n\r\n接下来，可以验证银行卡并使用 [Stripe 的 `createPaymentMethod` 方法](https://stripe.com/docs/stripe-js/reference#stripe-create-payment-method):\r\n\r\n```js\r\nconst cardHolderName = document.getElementById('card-holder-name');\r\nconst cardButton = document.getElementById('card-button');\r\n\r\ncardButton.addEventListener('click', async (e) => {\r\n    const { paymentMethod, error } = await stripe.createPaymentMethod(\r\n        'card', cardElement, {\r\n            billing_details: { name: cardHolderName.value }\r\n        }\r\n    );\r\n\r\n    if (error) {\r\n        // 向用户显示「error.message」...\r\n    } else {\r\n        // 该银行卡已验证成功...\r\n    }\r\n});\r\n```\r\n\r\n如果卡验证成功，你可以将 `paymentMethod.id` 传递给你的 Laravel 应用程序并处理[单次收费](#simple-charge)。\r\n\r\n<a name=\"retrieving-payment-methods\"></a>\r\n### 检索付款方式\r\n\r\n计费模型实例上的 `paymentMethods` 方法返回 `Laravel\\Cashier\\PaymentMethod` 实例的集合：\r\n\r\n    $paymentMethods = $user->paymentMethods();\r\n\r\n默认情况下，此方法将返回 `card` 类型的支付方式。要检索不同类型的付款方式，你可以将 `type` 作为参数传递给该方法：\r\n\r\n    $paymentMethods = $user->paymentMethods('sepa_debit');\r\n\r\n要检索客户的默认付款方式，可以使用 `defaultPaymentMethod` 方法：\r\n\r\n    $paymentMethod = $user->defaultPaymentMethod();\r\n\r\n你可以使用 `findPaymentMethod` 方法检索附加到计费模型的特定付款方式：\r\n\r\n    $paymentMethod = $user->findPaymentMethod($paymentMethodId);\r\n\r\n<a name=\"check-for-a-payment-method\"></a>\r\n### 确定用户是否有付款方式\r\n\r\n要确定计费模型是否有附加到其帐户的默认付款方式，请调用 `hasDefaultPaymentMethod` 方法：\r\n\r\n    if ($user->hasDefaultPaymentMethod()) {\r\n        // ...\r\n    }\r\n\r\n你可以使用 `hasPaymentMethod` 方法来确定计费模型是否至少有一种支付方式附加到他们的账户：\r\n\r\n    if ($user->hasPaymentMethod()) {\r\n        // ...\r\n    }\r\n\r\n此方法将确定计费模型是否具有 `card` 类型的支付方式。 要确定该模型是否存在另一种类型的支付方式，你可以将 `type` 作为参数传递给该方法：\r\n\r\n    if ($user->hasPaymentMethod('sepa_debit')) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"updating-the-default-payment-method\"></a>\r\n### 更新默认付款方式\r\n\r\n`updateDefaultPaymentMethod` 方法可用于更新客户的默认支付方式信息。 此方法接受 Stripe 支付方式标识符，并将新支付方式指定为默认支付方式：\r\n\r\n    $user->updateDefaultPaymentMethod($paymentMethod);\r\n\r\n如果银行卡验证成功，你可以将`paymentMethod.id` 传递给你的 Laravel 应用程序并处理 [单次收费](#simple-charge).\r\n\r\n<a name=\"retrieving-payment-methods\"></a>\r\n### 搜索付款方式\r\n\r\n计费模型实例上的 `paymentMethods` 方法返回一组 `Laravel\\Cashier\\PaymentMethod` 实例：\r\n\r\n    $paymentMethods = $user->paymentMethods();\r\n\r\n默认情况下，此方法将返回 `card` 类型的支付方式。 要搜索不同类型的付款方式，你可以将 `type` 作为参数传递给该方法：\r\n\r\n    $paymentMethods = $user->paymentMethods('sepa_debit');\r\n\r\n要搜索客户的默认付款方式，可以使用 `defaultPaymentMethod` 方法：\r\n\r\n    $paymentMethod = $user->defaultPaymentMethod();\r\n\r\n你可以使用 `findPaymentMethod` 方法搜索附加到计费模型的特定付款方式：\r\n\r\n    $paymentMethod = $user->findPaymentMethod($paymentMethodId);\r\n\r\n<a name=\"check-for-a-payment-method\"></a>\r\n### 确定用户是否有付款方式\r\n\r\n要确定计费模型是否有附加到其帐户的默认付款方式，请调用 `hasDefaultPaymentMethod` 方法：\r\n\r\n    if ($user->hasDefaultPaymentMethod()) {\r\n        // ...\r\n    }\r\n\r\n你可以 `hasPaymentMethod` 方法来确定计费模型是否至少有一种支付方式附加到他们的帐户：\r\n\r\n    if ($user->hasPaymentMethod()) {\r\n        // ...\r\n    }\r\n\r\n此方法将确定计费模型是否具有 `card` 类型的支付方式。 要确定该模型是否存在另一种类型的支付方式，你可以将 `type` 作为参数传递给该方法：\r\n\r\n    if ($user->hasPaymentMethod('sepa_debit')) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"updating-the-default-payment-method\"></a>\r\n### 更新默认付款方式\r\n\r\n`updateDefaultPaymentMethod` 方法可用于更新客户的默认支付方式信息。 此方法接受 Stripe 付款方式标识符，并将新付款方式指定为默认付款方式：\r\n\r\n    $user->updateDefaultPaymentMethod($paymentMethod);\r\n\r\n要将你的默认支付方式信息与客户在 Stripe 中的默认支付方式信息同步，你可以使用 `updateDefaultPaymentMethodFromStripe` 方法：\r\n\r\n    $user->updateDefaultPaymentMethodFromStripe();\r\n\r\n> **注意**  \r\n> 客户的默认付款方式只能用于开具发票和创建新订阅。 由于 Stripe 施加的限制，它可能无法用于单次收费。\r\n\r\n<a name=\"adding-payment-methods\"></a>\r\n### 添加付款方式\r\n\r\n要添加新的支付方式，你可以在计费模型上调用 `addPaymentMethod` 方法，并传递支付方式标识符：\r\n\r\n    $user->addPaymentMethod($paymentMethod);\r\n\r\n> **技巧**  \r\n> 要了解如何检索付款方式标识符，请查看[付款方式存储文档](#storing-payment-methods)。\r\n\r\n<a name=\"deleting-payment-methods\"></a>\r\n### 删除付款方式\r\n\r\n要删除付款方式，你可以在要删除的 `Laravel\\Cashier\\PaymentMethod` 实例上调用 `delete` 方法：\r\n\r\n    $paymentMethod->delete();\r\n\r\n`deletePaymentMethod` 方法将从计费模型中删除特定的支付方式：\r\n\r\n    $user->deletePaymentMethod('pm_visa');\r\n\r\n`deletePaymentMethods` 方法将删除计费模型的所有付款方式信息：\r\n\r\n    $user->deletePaymentMethods();\r\n\r\n默认情况下，此方法将删除 `card` 类型的支付方式。 要删除不同类型的付款方式，你可以将 `type` 作为参数传递给该方法：\r\n\r\n    $user->deletePaymentMethods('sepa_debit');\r\n\r\n> **注意**  \r\n> 如果用户有一个有效的订阅，你的应用程序不应该允许他们删除他们的默认支付方式。\r\n\r\n<a name=\"subscriptions\"></a>\r\n## 订阅\r\n\r\n订阅提供了一种为你的客户设置定期付款的方法。 Cashier 管理的 Stripe 订阅支持多种订阅价格、订阅数量、试用等。\r\n\r\n<a name=\"creating-subscriptions\"></a>\r\n### 创建订阅\r\n\r\n要创建订阅，首先检索你的计费模型的实例，通常是 `App\\Models\\User` 的实例。 检索到模型实例后，你可以使用 `newSubscription` 方法创建模型的订阅：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription(\r\n            'default', 'price_monthly'\r\n        )->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n传递给 `newSubscription` 方法的第一个参数应该是订阅的内部名称。 如果你的应用程序仅提供单一订阅，你可以称其为 `default` 或 `primary`。 此订阅名称仅供内部应用程序使用，无意向用户显示。 此外，它不应包含空格，并且在创建订阅后绝不能更改。 第二个参数是用户订阅的具体价格。 该值应对应于 Stripe 中的价格标识符。\r\n\r\n`create` 方法接受 [Stripe 支付方式标识](#storing-payment-methods)或 Stripe `PaymentMethod` 对象，将开始订阅并使用计费模型的 Stripe 客户 ID 和其他相关信息更新你的数据库账单信息。\r\n\r\n> **注意**  \r\n> 将支付方式标识符直接传递给 `create` 订阅方法也会自动将其添加到用户存储的支付方式中。\r\n\r\n<a name=\"collecting-recurring-payments-via-invoice-emails\"></a>\r\n#### 通过发票电子邮件收取定期付款\r\n\r\n你可以指示 Stripe 在每次定期付款到期时通过电子邮件向客户发送发票，而不是自动收取客户的经常性付款。 然后，客户可以在收到发票后手动支付。 通过发票收取经常性付款时，客户无需预先提供付款方式：\r\n\r\n    $user->newSubscription('default', 'price_monthly')->createAndSendInvoice();\r\n\r\n客户在取消订阅之前必须支付发票的时间由 `days_until_due` 选项决定。 默认情况下，这是 30 天； 但是，如果你愿意，可以为此选项提供特定值：\r\n\r\n    $user->newSubscription('default', 'price_monthly')->createAndSendInvoice([], [\r\n        'days_until_due' => 30\r\n    ]);\r\n\r\n<a name=\"subscription-quantities\"></a>\r\n#### 数量\r\n\r\n如果你想在创建订阅时为价格设置特定的[数量](https://stripe.com/docs/billing/subscriptions/quantities)，你应该在创建之前调用订阅构建器上的 `quantity` 方法 订阅：\r\n\r\n    $user->newSubscription('default', 'price_monthly')\r\n         ->quantity(5)\r\n         ->create($paymentMethod);\r\n\r\n<a name=\"additional-details\"></a>\r\n#### 其它详细信息\r\n\r\n如果你想指定支持的其他[客户](https://stripe.com/docs/api/customers/create)或[订阅](https://stripe.com/docs/api/subscriptions/create)选项 通过 Stripe，你可以通过将它们作为第二个和第三个参数传递给 `create` 方法来实现：\r\n\r\n    $user->newSubscription('default', 'price_monthly')->create($paymentMethod, [\r\n        'email' => $email,\r\n    ], [\r\n        'metadata' => ['note' => 'Some extra information.'],\r\n    ]);\r\n\r\n<a name=\"coupons\"></a>\r\n#### 优惠券\r\n\r\n如果你想在创建订阅时使用优惠券，你可以使用 `withCoupon` 方法：\r\n\r\n    $user->newSubscription('default', 'price_monthly')\r\n         ->withCoupon('code')\r\n         ->create($paymentMethod);\r\n\r\n或者，如果你想应用 [Stripe 促销代码](https://stripe.com/docs/billing/subscriptions/discounts/codes)，你可以使用 `withPromotionCode` 方法：\r\n\r\n    $user->newSubscription('default', 'price_monthly')\r\n         ->withPromotionCode('promo_code_id')\r\n         ->create($paymentMethod);\r\n\r\n给定的促销代码 ID 应该是分配给促销代码的 Stripe API ID，而不是面向客户的促销代码。 如果你需要根据给定的面向客户的促销代码查找促销代码 ID，你可以使用 `findPromotionCode` 方法：\r\n\r\n    // 通过面向客户的代码查找促销代码 ID...\r\n    $promotionCode = $user->findPromotionCode('SUMMERSALE');\r\n\r\n    // 通过面向客户的代码查找有效的促销代码 ID...\r\n    $promotionCode = $user->findActivePromotionCode('SUMMERSALE');\r\n\r\n\r\n\r\n在上面的示例中，返回的 `$promotionCode` 对象是 `Laravel\\Cashier\\PromotionCode` 的一个实例。 这个类装饰了一个底层的 `Stripe\\PromotionCode` 对象。 你可以通过调用 `coupon` 方法来检索与促销代码相关的优惠券：\r\n\r\n    $coupon = $user->findPromotionCode('SUMMERSALE')->coupon();\r\n\r\n优惠券实例允许你确定折扣金额以及优惠券是代表固定折扣还是基于百分比的折扣：\r\n\r\n    if ($coupon->isPercentage()) {\r\n        return $coupon->percentOff().'%'; // 21.5%\r\n    } else {\r\n        return $coupon->amountOff(); // $5.99\r\n    }\r\n\r\n你还可以检索当前应用于客户或订阅的折扣：\r\n\r\n    $discount = $billable->discount();\r\n\r\n    $discount = $subscription->discount();\r\n\r\n返回的 `Laravel\\Cashier\\Discount` 实例装饰底层的 `Stripe\\Discount` 对象实例。 你可以通过调用 `coupon` 方法获取与此折扣相关的优惠券：\r\n\r\n    $coupon = $subscription->discount()->coupon();\r\n\r\n如果你想将新的优惠券或促销代码应用于客户或订阅，你可以通过 `applyCoupon` 或 `applyPromotionCode` 方法进行：\r\n\r\n    $billable->applyCoupon('coupon_id');\r\n    $billable->applyPromotionCode('promotion_code_id');\r\n\r\n    $subscription->applyCoupon('coupon_id');\r\n    $subscription->applyPromotionCode('promotion_code_id');\r\n\r\n请记住，你应该使用分配给促销代码的 Stripe API ID，而不是面向客户的促销代码。 在给定时间只能将一个优惠券或促销代码应用于客户或订阅。\r\n\r\n有关此主题的更多信息，请参阅有关[优惠券](https://stripe.com/docs/billing/subscriptions/coupons)和[促销代码](https://stripe.com/docs/billing)的 Stripe 文档 /订阅/优惠券/代码）。\r\n\r\n<a name=\"adding-subscriptions\"></a>\r\n#### 添加订阅\r\n\r\n如果你想向已有默认付款方式的客户添加订阅，你可以在订阅构建器上调用 `add` 方法：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->newSubscription('default', 'price_monthly')->add();\r\n\r\n<a name=\"creating-subscriptions-from-the-stripe-dashboard\"></a>\r\n#### 从 Stripe 仪表板创建订阅\r\n\r\n你还可以从 Stripe 仪表板本身创建订阅。 这样做时，Cashier 将同步新添加的订阅并为其分配一个名称 `default`。 要自定义分配给仪表板创建的订阅的订阅名称，[扩展 `WebhookController`](#defining-webhook-event-handlers)并覆盖 `newSubscriptionName` 方法。\r\n\r\n此外，你只能通过 Stripe 仪表板创建一种类型的订阅。 如果你的应用程序提供多个使用不同名称的订阅，则只能通过 Stripe 仪表板添加一种类型的订阅。\r\n\r\n最后，你应该始终确保你的应用程序提供的每种订阅类型只添加一个活动订阅。 如果客户有两个 `default` 订阅，Cashier 只会使用最近添加的订阅，即使两者都会与你的应用程序数据库同步。\r\n\r\n<a name=\"checking-subscription-status\"></a>\r\n### 检查订阅状态\r\n\r\n客户订阅你的应用程序后，你可以使用各种方便的方法轻松检查他们的订阅状态。 首先，如果客户有有效订阅， `subscribed` 方法会返回 `true` ，即使该订阅当前处于试用期内。 `subscribed` 方法接受订阅的名称作为它的第一个参数：\r\n\r\n    if ($user->subscribed('default')) {\r\n        // ...\r\n    }\r\n\r\n`subscribed` 方法也非常适合[路由中间件](/docs/laravel/10.x/middleware)，允许你根据用户的订阅状态过滤对路由和控制器的访问：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class EnsureUserIsSubscribed\r\n    {\r\n        /**\r\n         * 处理传入请求。\r\n         *\r\n         * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n         */\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            if ($request->user() && ! $request->user()->subscribed('default')) {\r\n                // 该用户不是付费客户...\r\n                return redirect('billing');\r\n            }\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n如果你想确定用户是否仍在试用期内，你可以使用 `onTrial` 方法。 此方法可用于确定是否应向用户显示他们仍在试用期的警告：\r\n\r\n    if ($user->subscription('default')->onTrial()) {\r\n        // ...\r\n    }\r\n\r\n`subscribedToProduct` 方法可用于根据给定的 Stripe 产品标识符确定用户是否订阅了给定的产品。 在 Stripe 中，产品是价格的集合。 在此示例中，我们将确定用户的 `default` 订阅是否主动订阅了应用程序的「高级」产品。 给定的 Stripe 产品标识符应与你在 Stripe 仪表板中的产品标识符之一相对应：\r\n\r\n    if ($user->subscribedToProduct('prod_premium', 'default')) {\r\n        // ...\r\n    }\r\n\r\n通过将数组传递给 `subscribedToProduct` 方法，你可以确定用户的 `default` 订阅是否主动订阅了应用程序的「基本」或「高级」产品：\r\n\r\n    if ($user->subscribedToProduct(['prod_basic', 'prod_premium'], 'default')) {\r\n        // ...\r\n    }\r\n\r\n`subscribedToPrice` 方法可用于确定客户的订阅是否对应于给定的价格 ID：\r\n\r\n    if ($user->subscribedToPrice('price_basic_monthly', 'default')) {\r\n        // ...\r\n    }\r\n\r\n`recurring` 方法可用于确定用户当前是否已订阅并且不再处于试用期内：\r\n\r\n    if ($user->subscription('default')->recurring()) {\r\n        // ...\r\n    }\r\n\r\n> **注意**  \r\n> 如果用户有两个同名订阅，则 `subscription` 方法将始终返回最近的订阅。 例如，一个用户可能有两个名为 `default`的订阅记录； 但是，其中一个订阅可能是旧的、过期的订阅，而另一个是当前的、有效的订阅。 最近的订阅将始终返回，而较旧的订阅将保留在数据库中以供历史审查。\r\n\r\n<a name=\"cancelled-subscription-status\"></a>\r\n#### 取消订阅状态\r\n\r\n要确定用户是否曾经是活跃订阅者但已取消订阅，你可以使用 `canceled` 方法：\r\n\r\n    if ($user->subscription('default')->canceled()) {\r\n        // ...\r\n    }\r\n\r\n你还可以确定用户是否已取消他们的订阅，但在订阅完全到期之前是否仍处于「宽限期」。 例如，如果用户在 3 月 5 日取消了原定于 3 月 10 日到期的订阅，则用户在 3 月 10 日之前处于「宽限期」。 请注意，`subscribed` 方法在此期间仍会返回 `true`：\r\n\r\n    if ($user->subscription('default')->onGracePeriod()) {\r\n        // ...\r\n    }\r\n\r\n要确定用户是否已取消订阅并且不再处于「宽限期」内，你可以使用 `ended` 方法：\r\n\r\n    if ($user->subscription('default')->ended()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"incomplete-and-past-due-status\"></a>\r\n#### 不完整和逾期状态\r\n\r\n如果订阅在创建后需要二次支付操作，订阅将被标记为「不完整」。 订阅状态存储在 Cashier 的 `subscriptions` 数据库表的 `stripe_status` 列中。\r\n\r\n同样，如果在交换价格时需要二次支付操作，订阅将被标记为 `past_due` 。 当你的订阅处于这些状态中的任何一种时，在客户确认付款之前，它不会激活。 可以使用计费模型或订阅实例上的  `hasIncompletePayment` 方法来确定订阅是否有未完成的付款：\r\n\r\n    if ($user->hasIncompletePayment('default')) {\r\n        // ...\r\n    }\r\n\r\n    if ($user->subscription('default')->hasIncompletePayment()) {\r\n        // ...\r\n    }\r\n\r\n当订阅有未完成的付款时，你应该将用户引导至 Cashier 的付款确认页面，并传递 `latestPayment` 标识符。 你可以使用订阅实例上可用的 `latestPayment` 方法来检索此标识符：\r\n\r\n```html\r\n<a href=\"{{ route('cashier.payment', $subscription->latestPayment()->id) }}\">\r\n    请确认你的付款。\r\n</a>\r\n```\r\n\r\n如果你希望订阅在处于 `past_due` 或 `incomplete` 状态时仍被视为有效，你可以使用 Cashier 提供的 `keepPastDueSubscriptionsActive` 和 `keepIncompleteSubscriptionsActive` 方法。 通常，应在 `App\\Providers\\AppServiceProvider` 的 `register` 方法中调用这些方法：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    /**\r\n     * 注册任何应用程序服务。\r\n     */\r\n    public function register(): void\r\n    {\r\n        Cashier::keepPastDueSubscriptionsActive();\r\n        Cashier::keepIncompleteSubscriptionsActive();\r\n    }\r\n\r\n> **注意**  \r\n> 当订阅处于 `incomplete` 状态时，在确认付款之前无法更改。 因此，当订阅处于 `incomplete` 状态时， `swap` 和 `updateQuantity` 方法将抛出异常。\r\n\r\n<a name=\"subscription-scopes\"></a>\r\n#### 订阅范围\r\n\r\n大多数订阅状态也可用作查询范围，以便你可以轻松查询数据库以查找处于给定状态的订阅：\r\n\r\n    // 获取所有活动订阅...\r\n    $subscriptions = Subscription::query()->active()->get();\r\n\r\n    // 获取用户所有已取消的订阅...\r\n    $subscriptions = $user->subscriptions()->canceled()->get();\r\n\r\n可用范围的完整列表如下：\r\n\r\n    Subscription::query()->active();\r\n    Subscription::query()->canceled();\r\n    Subscription::query()->ended();\r\n    Subscription::query()->incomplete();\r\n    Subscription::query()->notCanceled();\r\n    Subscription::query()->notOnGracePeriod();\r\n    Subscription::query()->notOnTrial();\r\n    Subscription::query()->onGracePeriod();\r\n    Subscription::query()->onTrial();\r\n    Subscription::query()->pastDue();\r\n    Subscription::query()->recurring();\r\n\r\n<a name=\"changing-prices\"></a>\r\n### 更改价格\r\n\r\n客户订阅你的应用程序后，他们可能偶尔想要更改为新的订阅价格。 要将客户换成新价格，请将 Stripe 价格的标识符传递给 `swap` 方法。 交换价格时，假设用户想要重新激活他们的订阅（如果之前已取消订阅）。 给定的价格标识符应对应于 Stripe 仪表板中可用的 Stripe 价格标识符：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    $user->subscription('default')->swap('price_yearly');\r\n\r\n如果客户处于试用期，则将保持试用期。 此外，如果订阅存在「数量」，则也将保留该数量。\r\n\r\n如果你想交换价格并取消客户当前的任何试用期，你可以调用 `skipTrial` 方法：\r\n\r\n    $user->subscription('default')\r\n            ->skipTrial()\r\n            ->swap('price_yearly');\r\n\r\n如果你想交换价格并立即向客户开具发票而不是等待他们的下一个结算周期，你可以使用 `swapAndInvoice` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swapAndInvoice('price_yearly');\r\n\r\n<a name=\"prorations\"></a>\r\n#### 按比例分配\r\n\r\n默认情况下，Stripe 在价格之间交换时按比例分配费用。 `noProrate` 方法可用于在不按比例分配费用的情况下更新订阅价格：\r\n\r\n    $user->subscription('default')->noProrate()->swap('price_yearly');\r\n\r\n有关订阅按比例分配的更多信息，请参阅 [Stripe 文档](https://stripe.com/docs/billing/subscriptions/prorations)。\r\n\r\n> **注意**  \r\n> 在 `swapAndInvoice` 方法之前执行 `noProrate` 方法将不会影响按比例分配。 将始终开具发票。\r\n\r\n<a name=\"subscription-quantity\"></a>\r\n### 认购数量\r\n\r\n有时订阅会受到「数量」的影响。 例如，项目管理应用程序可能对每个项目收取每月 10 美元的费用。 你可以使用 `incrementQuantity` 和 `decrementQuantity` 方法轻松增加或减少你的订阅数量：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->incrementQuantity();\r\n\r\n    // 向订阅的当前数量添加五个...\r\n    $user->subscription('default')->incrementQuantity(5);\r\n\r\n    $user->subscription('default')->decrementQuantity();\r\n\r\n    // 从订阅的当前数量中减去五...\r\n    $user->subscription('default')->decrementQuantity(5);\r\n\r\n或者，你可以使用 `updateQuantity` 方法设置特定数量：\r\n\r\n    $user->subscription('default')->updateQuantity(10);\r\n\r\n`noProrate` 方法可用于在不按比例分配费用的情况下更新订阅的数量：\r\n\r\n    $user->subscription('default')->noProrate()->updateQuantity(10);\r\n\r\n有关订阅数量的更多信息，请参阅 [Stripe 文档](https://stripe.com/docs/subscriptions/quantities)。\r\n\r\n<a name=\"quantities-for-subscription-with-multiple-products\"></a>\r\n#### 多个产品的订阅数量\r\n\r\n如果你的订阅是[包含多个产品的订阅](#subscriptions-with-multiple-products)，你应该将你希望增加或减少的数量的价格 ID 作为第二个参数传递给增量/减量方法：\r\n\r\n    $user->subscription('default')->incrementQuantity(1, 'price_chat');\r\n\r\n<a name=\"subscriptions-with-multiple-products\"></a>\r\n### 订阅多个产品\r\n\r\n[订阅多个产品](https://stripe.com/docs/billing/subscriptions/multiple-products)允许你将多个计费产品分配给一个订阅。 例如，假设你正在构建一个客户服务「帮助台」应用程序，其基本订阅价格为每月 10 美元，但提供实时聊天附加产品，每月额外收费 15 美元。 包含多个产品的订阅信息存储在 Cashier 的 `subscription_items` 数据库表中。\r\n\r\n你可以通过将价格数组作为第二个参数传递给 `newSubscription` 方法来为给定订阅指定多个产品：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription('default', [\r\n            'price_monthly',\r\n            'price_chat',\r\n        ])->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n在上面的例子中，客户将有两个附加到他们的 `default` 订阅的价格。 两种价格都将按各自的计费间隔收取。 如有必要，你可以使用 `quantity` 方法为每个价格指定具体数量：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->newSubscription('default', ['price_monthly', 'price_chat'])\r\n        ->quantity(5, 'price_chat')\r\n        ->create($paymentMethod);\r\n\r\n如果你想为现有订阅添加另一个价格，你可以调用订阅的 `addPrice` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->addPrice('price_chat');\r\n\r\n上面的示例将添加新价格，客户将在下一个计费周期为此付费。 如果你想立即向客户开具账单，你可以使用 `addPriceAndInvoice` 方法：\r\n\r\n    $user->subscription('default')->addPriceAndInvoice('price_chat');\r\n\r\n如果你想添加具有特定数量的价格，你可以将数量作为 `addPrice` 或 `addPriceAndInvoice` 方法的第二个参数传递：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->addPrice('price_chat', 5);\r\n\r\n你可以使用 `removePrice` 方法从订阅中删除价格：\r\n\r\n    $user->subscription('default')->removePrice('price_chat');\r\n\r\n> **注意**  \r\n> 你不得删除订阅的最后价格。 相反，你应该简单地取消订阅。\r\n\r\n<a name=\"swapping-prices\"></a>\r\n#### 交换价格\r\n\r\n你还可以更改附加到具有多个产品的订阅的价格。 例如，假设客户订阅了带有 `price_chat` 附加产品的 `price_basic` 订阅，而你想要将客户从 `price_basic` 升级到 `price_pro` 价格：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swap(['price_pro', 'price_chat']);\r\n\r\n执行上述示例时，删除带有 `price_basic` 的基础订阅项，保留带有 `price_chat` 的订阅项。 此外，还会为 `price_pro` 创建一个新的订阅项目。\r\n\r\n你还可以通过将键/值对数组传递给 `swap` 方法来指定订阅项选项。 例如，你可能需要指定订阅价格数量：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swap([\r\n        'price_pro' => ['quantity' => 5],\r\n        'price_chat'\r\n    ]);\r\n\r\n如果你想交换订阅的单一价格，你可以在订阅项目本身上使用 `swap` 方法。 如果你想保留订阅的其他价格的所有现有元数据，此方法特别有用：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')\r\n            ->findItemOrFail('price_basic')\r\n            ->swap('price_pro');\r\n\r\n<a name=\"proration\"></a>\r\n#### 按比例分配\r\n\r\n默认情况下，Stripe 会在为多个产品的订阅添加或删除价格时按比例收费。 如果你想在不按比例分配的情况下进行价格调整，你应该将 `noProrate` 方法链接到你的价格操作中：\r\n\r\n    $user->subscription('default')->noProrate()->removePrice('price_chat');\r\n\r\n<a name=\"swapping-quantities\"></a>\r\n#### 数量\r\n\r\n如果你想更新单个订阅价格的数量，你可以使用[现有数量方法](#subscription-quantity) 将价格名称作为附加参数传递给该方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->incrementQuantity(5, 'price_chat');\r\n\r\n    $user->subscription('default')->decrementQuantity(3, 'price_chat');\r\n\r\n    $user->subscription('default')->updateQuantity(10, 'price_chat');\r\n\r\n> **注意**  \r\n> 当订阅有多个价格时，`Subscription` 模型上的 `stripe_price` 和 `quantity` 属性将为 `null`。 要访问单个价格属性，你应该使用 `Subscription` 模型上可用的 `items` 关系。\r\n\r\n<a name=\"subscription-items\"></a>\r\n#### 订阅项目\r\n\r\n当订阅有多个价格时，它会在数据库的 `subscription_items` 表中存储多个订阅 `items`。 你可以通过订阅上的 `items` 关系访问这些：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $subscriptionItem = $user->subscription('default')->items->first();\r\n\r\n    // 检索特定商品的 Stripe 价格和数量...\r\n    $stripePrice = $subscriptionItem->stripe_price;\r\n    $quantity = $subscriptionItem->quantity;\r\n\r\n你还可以使用 `findItemOrFail` 方法检索特定价格：\r\n\r\n    $user = User::find(1);\r\n\r\n    $subscriptionItem = $user->subscription('default')->findItemOrFail('price_chat');\r\n\r\n<a name=\"multiple-subscriptions\"></a>\r\n### 多个订阅\r\n\r\nStripe 允许你的客户同时拥有多个订阅。 例如，你可能经营一家提供游泳订阅和举重订阅的健身房，并且每个订阅可能有不同的定价。 当然，客户应该能够订阅其中一个或两个计划。\r\n\r\n当你的应用程序创建订阅时，你可以将订阅的名称提供给 `newSubscription` 方法。 该名称可以是表示用户正在启动的订阅类型的任何字符串：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/swimming/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription('swimming')\r\n            ->price('price_swimming_monthly')\r\n            ->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n在此示例中，我们为客户发起了每月一次的游泳订阅。 但是，他们以后可能想换成按年订阅。 在调整客户的订阅时，我们可以简单地交换 `swimming` 订阅的价格：\r\n\r\n    $user->subscription('swimming')->swap('price_swimming_yearly');\r\n\r\n当然，你也可以完全取消订阅：\r\n\r\n    $user->subscription('swimming')->cancel();\r\n\r\n<a name=\"metered-billing\"></a>\r\n### 计量计费\r\n\r\n[计量计费](https://stripe.com/docs/billing/subscriptions/metered-billing) 允许你根据客户在计费周期内的产品使用情况向客户收费。 例如，你可以根据客户每月发送的短信或电子邮件的数量向客户收费。\r\n\r\n要开始使用计量计费，你首先需要在 Stripe 控制面板中创建一个具有计量价格的新产品。 然后，使用 `meteredPrice` 将计量价格 ID 添加到客户订阅：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription('default')\r\n            ->meteredPrice('price_metered')\r\n            ->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n你还可以通过 [Stripe Checkout](#checkout) 开始计量订阅：\r\n\r\n    $checkout = Auth::user()\r\n            ->newSubscription('default', [])\r\n            ->meteredPrice('price_metered')\r\n            ->checkout();\r\n\r\n    return view('your-checkout-view', [\r\n        'checkout' => $checkout,\r\n    ]);\r\n\r\n<a name=\"reporting-usage\"></a>\r\n#### 报告使用情况\r\n\r\n当你的客户使用你的应用程序时，你将向 Stripe 报告他们的使用情况，以便他们可以准确地计费。 要增加计量订阅的使用，你可以使用 `reportUsage` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->reportUsage();\r\n\r\n默认情况下，「使用数量」1 会添加到计费周期。 或者，你可以传递特定数量的「使用量」以添加到客户在计费期间的使用量中：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->reportUsage(15);\r\n\r\n如果你的应用程序在单个订阅中提供多个价格，你将需要使用 `reportUsageFor` 方法来指定你要报告使用情况的计量价格：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->reportUsageFor('price_metered', 15);\r\n\r\n有时，你可能需要更新之前报告的使用情况。 为此，你可以将时间戳或 `DateTimeInterface` 实例作为第二个参数传递给 `reportUsage`。 这样做时，Stripe 将更新在给定时间报告的使用情况。 你可以继续更新以前的使用记录，因为给定的日期和时间仍在当前计费周期内：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->reportUsage(5, $timestamp);\r\n\r\n<a name=\"retrieving-usage-records\"></a>\r\n#### 检索使用记录\r\n\r\n要检索客户过去的使用情况，你可以使用订阅实例的 `usageRecords` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $usageRecords = $user->subscription('default')->usageRecords();\r\n\r\n如果你的应用程序为单个订阅提供多个价格，你可以使用 `usageRecordsFor` 方法指定你希望检索使用记录的计量价格：\r\n\r\n    $user = User::find(1);\r\n\r\n    $usageRecords = $user->subscription('default')->usageRecordsFor('price_metered');\r\n\r\n`usageRecords` 和 `usageRecordsFor` 方法返回一个包含使用记录关联数组的 Collection 实例。 你可以遍历此数组以显示客户的总使用量：\r\n\r\n    @foreach ($usageRecords as $usageRecord)\r\n        - Period Starting: {{ $usageRecord['period']['start'] }}\r\n        - Period Ending: {{ $usageRecord['period']['end'] }}\r\n        - Total Usage: {{ $usageRecord['total_usage'] }}\r\n    @endforeach\r\n\r\n有关返回的所有使用数据的完整参考以及如何使用 Stripe 基于游标的分页，请参阅[官方 Stripe API 文档](https://stripe.com/docs/api/usage_records/subscription_item_summary_list)。\r\n\r\n<a name=\"subscription-taxes\"></a>\r\n### 订阅税\r\n\r\n> **注意**  \r\n> 你可以[使用 Stripe Tax 自动计算税费](#tax-configuration)，而不是手动计算税率\r\n\r\n要指定用户为订阅支付的税率，你应该在计费模型上实施 `taxRates` 方法并返回一个包含 Stripe 税率 ID 的数组。你可以在[你的 Stripe 控制面板](https://dashboard.stripe.com/test/tax-rates) 中定义这些税率：\r\n\r\n    /**\r\n     * 适用于客户订阅的税率。\r\n     *\r\n     * @return array<int, string>\r\n     */\r\n    public function taxRates(): array\r\n    {\r\n        return ['txr_id'];\r\n    }\r\n\r\n`taxRates` 方法使你能够在逐个客户的基础上应用税率，这对于跨越多个国家和税率的用户群可能会有所帮助。\r\n\r\n如果你提供多种产品的订阅，你可以通过在计费模型上实施 `priceTaxRates` 方法为每个价格定义不同的税率：\r\n\r\n    /**\r\n     * 适用于客户订阅的税率。\r\n     *\r\n     * @return array<string, array<int, string>>\r\n     */\r\n    public function priceTaxRates(): array\r\n    {\r\n        return [\r\n            'price_monthly' => ['txr_id'],\r\n        ];\r\n    }\r\n\r\n> **注意**  \r\n> `taxRates` 方法仅适用于订阅费用。 如果你使用 Cashier 进行「一次性」收费，你将需要手动指定当时的税率。\r\n\r\n<a name=\"syncing-tax-rates\"></a>\r\n#### 同步税率\r\n\r\n当更改由 `taxRates` 方法返回的硬编码税率 ID 时，用户任何现有订阅的税收设置将保持不变。 如果你希望使用新的 `taxRates` 值更新现有订阅的税值，你应该在用户的订阅实例上调用  `syncTaxRates` 方法：\r\n\r\n    $user->subscription('default')->syncTaxRates();\r\n\r\n这还将同步具有多个产品的订阅的任何项目税率。 如果你的应用程序提供多种产品的订阅，你应该确保你的计费模型实施 `priceTaxRates` 方法[如上所述](#subscription-taxes)。\r\n\r\n<a name=\"tax-exemption\"></a>\r\n#### 免税\r\n\r\nCashier 还提供 `isNotTaxExempt`、`isTaxExempt` 和 `reverseChargeApplies` 方法来确定客户是否免税。 这些方法将调用 Stripe API 来确定客户的免税状态：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->isTaxExempt();\r\n    $user->isNotTaxExempt();\r\n    $user->reverseChargeApplies();\r\n\r\n> **注意**  \r\n> 这些方法也适用于任何 `Laravel\\Cashier\\Invoice` 对象。 但是，当在 `Invoice` 对象上调用时，这些方法将确定发票创建时的豁免状态。\r\n\r\n<a name=\"subscription-anchor-date\"></a>\r\n### 订阅锚定日期\r\n\r\n默认情况下，计费周期锚是创建订阅的日期，或者如果使用试用期，则为试用结束的日期。 如果你想修改计费锚点日期，你可以使用 `anchorBillingCycleOn` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $anchor = Carbon::parse('first day of next month');\r\n\r\n        $request->user()->newSubscription('default', 'price_monthly')\r\n                    ->anchorBillingCycleOn($anchor->startOfDay())\r\n                    ->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n有关管理订阅计费周期的更多信息，请参阅 [Stripe 计费周期文档](https://stripe.com/docs/billing/subscriptions/billing-cycle)\r\n\r\n<a name=\"cancelling-subscriptions\"></a>\r\n### 取消订阅\r\n\r\n要取消订阅，请在用户的订阅上调用 `cancel` 方法：\r\n\r\n    $user->subscription('default')->cancel();\r\n\r\n当订阅被取消时，Cashier 将自动在你的 `subscriptions` 数据库表中设置 `ends_at` 列。 此列用于了解 `subscribed` 方法何时应开始返回 `false`。\r\n\r\n例如，如果客户在 3 月 1 日取消订阅，但订阅计划要到 3 月 5 日才结束，则 `subscribed` 方法将继续返回 `true` 直到 3 月 5 日。 这样做是因为通常允许用户继续使用应用程序，直到他们的计费周期结束。\r\n\r\n你可以使用 `onGracePeriod` 方法确定用户是否已取消订阅但仍处于「宽限期」：\r\n\r\n    if ($user->subscription('default')->onGracePeriod()) {\r\n        // ...\r\n    }\r\n\r\n如果你希望立即取消订阅，请在用户的订阅上调用 `cancelNow` 方法：\r\n\r\n    $user->subscription('default')->cancelNow();\r\n\r\n如果你希望立即取消订阅并为任何剩余的未开具发票的计量使用或新的/待定的按比例分配发票项目开具发票，请在用户的订阅上调用 `cancelNowAndInvoice` 方法：\r\n\r\n    $user->subscription('default')->cancelNowAndInvoice();\r\n\r\n你也可以选择在特定时间取消订阅：\r\n\r\n    $user->subscription('default')->cancelAt(\r\n        now()->addDays(10)\r\n    );\r\n\r\n<a name=\"resuming-subscriptions\"></a>\r\n### 恢复订阅\r\n\r\n如果客户取消了他们的订阅，而你希望恢复订阅，你可以在订阅上调用 `resume` 方法。 客户必须仍在「宽限期」内才能恢复订阅：\r\n\r\n    $user->subscription('default')->resume();\r\n\r\n如果客户取消订阅，然后在订阅完全到期之前恢复订阅，则不会立即向客户收费。 相反，他们的订阅将被重新激活，并且他们将按照原始计费周期进行计费。\r\n\r\n<a name=\"subscription-trials\"></a>\r\n## 订阅试用\r\n\r\n<a name=\"with-payment-method-up-front\"></a>\r\n### 预先支付方式\r\n\r\n如果你想为客户提供试用期，同时仍然预先收集付款方式信息，则应在创建订阅时使用 `trialDays` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/user/subscribe', function (Request $request) {\r\n        $request->user()->newSubscription('default', 'price_monthly')\r\n                    ->trialDays(10)\r\n                    ->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n此方法将在数据库中的订阅记录上设置试用期结束日期，并指示 Stripe 在该日期之前不要开始向客户收费。 使用 `trialDays` 方法时，Cashier 将覆盖为 Stripe 中的价格配置的任何默认试用期。\r\n\r\n> **注意**  \r\n> 如果客户的订阅在试用结束日期之前没有取消，他们将在试用期满后立即收费，因此你应该确保通知你的用户他们的试用结束日期。\r\n\r\n`trialUntil` 方法允许你提供一个 `DateTime` 实例，指定试用期何时结束：\r\n\r\n    use Carbon\\Carbon;\r\n\r\n    $user->newSubscription('default', 'price_monthly')\r\n                ->trialUntil(Carbon::now()->addDays(10))\r\n                ->create($paymentMethod);\r\n\r\n你可以使用用户实例的 `onTrial` 方法或订阅实例的 `onTrial` 方法来确定用户是否在试用期内。 下面的两个例子是等价的：\r\n\r\n    if ($user->onTrial('default')) {\r\n        // ...\r\n    }\r\n\r\n    if ($user->subscription('default')->onTrial()) {\r\n        // ...\r\n    }\r\n\r\n你可以使用 `endTrial` 方法立即结束订阅试用：\r\n\r\n    $user->subscription('default')->endTrial();\r\n\r\n要确定现有试用版是否已过期，你可以使用 `hasExpiredTrial` 方法：\r\n\r\n    if ($user->hasExpiredTrial('default')) {\r\n        // ...\r\n    }\r\n\r\n    if ($user->subscription('default')->hasExpiredTrial()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"defining-trial-days-in-stripe-cashier\"></a>\r\n#### 在 Stripe / Cashier 中定义试用日\r\n\r\n你可以选择在 Stripe 仪表板中定义你的价格接收的试用天数，或者始终使用 Cashier 明确传递它们。 如果你选择在 Stripe 中定义价格的试用日，你应该知道新订阅，包括过去有订阅的客户的新订阅，将始终收到试用期，除非你明确调用 `skipTrial()` 方法 。\r\n\r\n<a name=\"without-payment-method-up-front\"></a>\r\n### 没有预先付款方式\r\n\r\n如果你想在不预先收集用户付款方式信息的情况下提供试用期，你可以将用户记录中的 `trial_ends_at` 列设置为你想要的试用结束日期。 这通常在用户注册期间完成：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::create([\r\n        // ...\r\n        'trial_ends_at' => now()->addDays(10),\r\n    ]);\r\n\r\n> **注意**  \r\n> 请务必在计费模型的类定义中为 `trial_ends_at` 属性添加 [date cast](/docs/laravel/10.x/eloquent-mutators#date-casting)。\r\n\r\nCashier 将这种类型的试用称为「通用试用」，因为它不附加到任何现有订阅。 如果当前日期没有超过 `trial_ends_at` 的值，计费模型实例上的 `onTrial` 方法将返回 `true`：\r\n\r\n    if ($user->onTrial()) {\r\n        // 用户在试用期内…\r\n    }\r\n\r\n一旦你准备好为用户创建一个实际的订阅，你可以像往常一样使用 `newSubscription` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->newSubscription('default', 'price_monthly')->create($paymentMethod);\r\n\r\n要检索用户的试用结束日期，你可以使用 `trialEndsAt` 方法。 如果用户正在试用，此方法将返回一个 Carbon 日期实例，否则将返回 `null`。 如果你想获取特定订阅而非默认订阅的试用结束日期，你还可以传递一个可选的订阅名称参数：\r\n\r\n    if ($user->onTrial()) {\r\n        $trialEndsAt = $user->trialEndsAt('main');\r\n    }\r\n\r\n如果你希望明确知道用户处于他们的「通用」试用期并且尚未创建实际订阅，你也可以使用 `onGenericTrial` 方法：\r\n\r\n    if ($user->onGenericTrial()) {\r\n        // 用户正处于「通用」试用期内…\r\n    }\r\n\r\n<a name=\"extending-trials\"></a>\r\n### 延长试验\r\n\r\n`extendTrial` 方法允许你在创建订阅后延长订阅的试用期。 如果试用期已经过期并且已经向客户收取订阅费用，你仍然可以为他们提供延长试用期。 在试用期内花费的时间将从客户的下一张发票中扣除：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $subscription = User::find(1)->subscription('default');\r\n\r\n    // 从现在起 7 天结束试用...\r\n    $subscription->extendTrial(\r\n        now()->addDays(7)\r\n    );\r\n\r\n    // 试用期再延长 5 天...\r\n    $subscription->extendTrial(\r\n        $subscription->trial_ends_at->addDays(5)\r\n    );\r\n\r\n<a name=\"handling-stripe-webhooks\"></a>\r\n## 处理 Stripe Webhook\r\n\r\n> **技巧**  \r\n> 你可以使用 [Stripe CLI](https://stripe.com/docs/stripe-cli) 在本地开发期间帮助测试 webhook。\r\n\r\nStripe 可以通过 webhook 通知你的应用程序各种事件。 默认情况下，指向 Cashier 的 webhook 控制器的路由由 Cashier 服务提供商自动注册。 该控制器将处理所有传入的 webhook 请求。\r\n\r\n默认情况下，Cashier webhook 控制器将自动处理取消订阅失败次数过多（由你的 Stripe 设置定义）、客户更新、客户删除、订阅更新和付款方式更改； 然而，我们很快就会发现，你可以扩展这个控制器来处理你喜欢的任何 Stripe webhook 事件。\r\n\r\n为确保你的应用程序可以处理 Stripe webhook，请务必在 Stripe 控制面板中配置 webhook URL。 默认情况下，Cashier 的 webhook 控制器响应 `/stripe/webhook` URL 路径。 你应该在 Stripe 控制面板中启用的所有 webhooks 的完整列表是：\r\n\r\n- `customer.subscription.created`\r\n- `customer.subscription.updated`\r\n- `customer.subscription.deleted`\r\n- `customer.updated`\r\n- `customer.deleted`\r\n- `invoice.payment_succeeded`\r\n- `invoice.payment_action_required`\r\n\r\n为方便起见，Cashier 包含一个 `cashier:webhook` Artisan 命令。 此命令将在 Stripe 中创建一个 webhook，用于侦听 Cashier 所需的所有事件：\r\n\r\n```shell\r\nphp artisan cashier:webhook\r\n```\r\n\r\n默认情况下，创建的 webhook 将指向由 `APP_URL` 环境变量和 Cashier 包含的 `cashier.webhook` 路由定义的 URL。 如果你想使用不同的 URL，你可以在调用命令时提供 `--url` 选项：\r\n\r\n```shell\r\nphp artisan cashier:webhook --url \"https://example.com/stripe/webhook\"\r\n```\r\n\r\n创建的 webhook 将使用与你的 Cashier 版本兼容的 Stripe API 版本。 如果你想使用不同的 Stripe 版本，你可以提供 `--api-version` 选项：\r\n\r\n```shell\r\nphp artisan cashier:webhook --api-version=\"2019-12-03\"\r\n```\r\n\r\n创建后，webhook 将立即激活。 如果你想创建 webhook 但在你准备好之前将其禁用，你可以在调用命令时提供 `--disabled` 选项：\r\n\r\n```shell\r\nphp artisan cashier:webhook --disabled\r\n```\r\n\r\n> **注意**  \r\n> 确保使用 Cashier 包含的 [webhook 签名验证](#verifying-webhook-signatures)中间件保护传入的 Stripe webhook 请求。\r\n\r\n<a name=\"webhooks-csrf-protection\"></a>\r\n#### Webhook 和 CSRF 保护\r\n\r\n由于 Stripe webhooks 需要绕过 Laravel 的 [CSRF 保护](/docs/laravel/10.x/csrf)，请务必在应用程序的 `App\\Http\\Middleware\\VerifyCsrfToken` 中间件中将 URI 列为异常或列出路由 在 `web` 中间件组之外：\r\n\r\n    protected $except = [\r\n        'stripe/*',\r\n    ];\r\n\r\n<a name=\"defining-webhook-event-handlers\"></a>\r\n### 定义 Webhook 事件处理程序\r\n\r\nCashier 自动处理失败收费和其他常见 Stripe webhook 事件的订阅取消。 但是，如果你有其他想要处理的 webhook 事件，你可以通过收听以下由 Cashier 调度的事件来实现：\r\n\r\n- `Laravel\\Cashier\\Events\\WebhookReceived`\r\n- `Laravel\\Cashier\\Events\\WebhookHandled`\r\n\r\n这两个事件都包含 Stripe webhook 的完整负载。 例如，如果你希望处理 `invoice.payment_succeeded` webhook，你可以注册一个 [listener](/docs/laravel/10.x/events#defining-listeners) 来处理该事件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Laravel\\Cashier\\Events\\WebhookReceived;\r\n\r\n    class StripeEventListener\r\n    {\r\n        /**\r\n         * 处理收到的 Stripe webhooks。\r\n         */\r\n        public function handle(WebhookReceived $event): void\r\n        {\r\n            if ($event->payload['type'] === 'invoice.payment_succeeded') {\r\n                // 处理传入事件...\r\n            }\r\n        }\r\n    }\r\n\r\n定义监听器后，你可以在应用程序的 `EventServiceProvider` 中注册它：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Listeners\\StripeEventListener;\r\n    use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\n    use Laravel\\Cashier\\Events\\WebhookReceived;\r\n\r\n    class EventServiceProvider extends ServiceProvider\r\n    {\r\n        protected $listen = [\r\n            WebhookReceived::class => [\r\n                StripeEventListener::class,\r\n            ],\r\n        ];\r\n    }\r\n\r\n<a name=\"verifying-webhook-signatures\"></a>\r\n### 验证 Webhook 签名\r\n\r\n为了保护你的 webhook，你可以使用 [Stripe 的 webhook 签名](https://stripe.com/docs/webhooks/signatures)。为方便起见，Cashier 自动包含一个中间件，用于验证传入的 Stripe webhook 请求是否有效。\r\n\r\n要启用 webhook 验证，请确保在应用程序的 `.env` 文件中设置了 `STRIPE_WEBHOOK_SECRET` 环境变量。 Webhook `secret` 可以从你的 Stripe 帐户仪表板中检索。\r\n\r\n<a name=\"single-charges\"></a>\r\n## 单次收费\r\n\r\n<a name=\"simple-charge\"></a>\r\n### 简单收费\r\n\r\n如果你想对客户进行一次性收费，你可以在计费模型实例上使用 charge 方法。 你需要[提供支付方式标识符](#payment-methods-for-single-charges)作为 `charge` 方法的第二个参数：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/purchase', function (Request $request) {\r\n        $stripeCharge = $request->user()->charge(\r\n            100, $request->paymentMethodId\r\n        );\r\n\r\n        // ...\r\n    });\r\n\r\n`charge` 方法接受一个数组作为它的第三个参数，允许你将你希望的任何选项传递给底层的 Stripe 费用创建。 有关创建费用时可用选项的更多信息，请参见 [Stripe 文档](https://stripe.com/docs/api/charges/create)：\r\n\r\n    $user->charge(100, $paymentMethod, [\r\n        'custom_option' => $value,\r\n    ]);\r\n\r\n你也可以在没有基础客户或用户的情况下使用 `charge` 方法。 为此，请在应用程序的计费模型的新实例上调用 `charge` 方法：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $stripeCharge = (new User)->charge(100, $paymentMethod);\r\n\r\n如果收费失败， `charge` 方法将抛出异常。 如果收费成功，`Laravel\\Cashier\\Payment` 的实例将从该方法返回：\r\n\r\n    try {\r\n        $payment = $user->charge(100, $paymentMethod);\r\n    } catch (Exception $e) {\r\n        // ...\r\n    }\r\n\r\n> **注意**  \r\n> `charge` 方法接受以你的应用程序使用的货币的最低分母表示的付款金额。 例如，如果客户以美元付款，则应以美分指定金额。\r\n\r\n<a name=\"charge-with-invoice\"></a>\r\n### 用发票收费\r\n\r\n有时你可能需要一次性收费并向客户提供 PDF 收据。 `invoicePrice` 方法可以让你做到这一点。例如，让我们为客户开具5件新衬衫的发票：\r\n\r\n    $user->invoicePrice('price_tshirt', 5);\r\n\r\n发票将立即根据用户的默认付款方式收取。`invoicePrice` 方法也接受一个数组作为它的第三个参数。 此数组包含发票项目的计费选项。该方法接受的第四个参数也是一个数组，其中应包含发票本身的计费选项：\r\n\r\n    $user->invoicePrice('price_tshirt', 5, [\r\n        'discounts' => [\r\n            ['coupon' => 'SUMMER21SALE']\r\n        ],\r\n    ], [\r\n        'default_tax_rates' => ['txr_id'],\r\n    ]);\r\n\r\n与 `invoicePrice` 类似，你可以使用 `tabPrice` 方法为多个项目（每张发票最多250个项目）创建一次性收费，将它们添加到客户的「标签」，然后向客户开具发票。例如，我们可以为客户开具5件衬衫和2个杯子的发票：\r\n\r\n    $user->tabPrice('price_tshirt', 5);\r\n    $user->tabPrice('price_mug', 2);\r\n    $user->invoice();\r\n\r\n或者，你可以使用 `invoiceFor` 方法对客户的默认付款方式进行「一次性」收费：\r\n\r\n    $user->invoiceFor('One Time Fee', 500);\r\n\r\n虽然 `invoiceFor` 方法可供你使用，但建议你使用具有预定义价格的 `invoicePrice` 和 `tabPrice` 方法。通过这样做，你可以在 Stripe 仪表板中获得更好的分析和数据，以了解你在每个产品的基础上的销售情况。\r\n\r\n> **注意**  \r\n> `invoice`、`invoicePrice` 和 `invoiceFor` 方法将创建一个 Stripe 发票，失败的发票会继续尝试扣费。如果你不希望失败的发票继续尝试扣费，则需要在第一次扣费失败后使用 Stripe API 关闭它们。\r\n\r\n<a name=\"creating-payment-intents\"></a>\r\n### 创建付款意向\r\n\r\n你可以通过在计费模型实例上调用 `pay` 方法来创建新的 Stripe 支付意图。 调用此方法将创建一个包装在 `Laravel\\Cashier\\Payment` 实例中的支付意图：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/pay', function (Request $request) {\r\n        $payment = $request->user()->pay(\r\n            $request->get('amount')\r\n        );\r\n\r\n        return $payment->client_secret;\r\n    });\r\n\r\n创建支付意图后，你可以将客户端密码返回到应用程序的前端，以便用户可以在其浏览器中完成支付。 要阅读有关使用 Stripe 支付意图构建整个支付流程的更多信息，请参阅 [Stripe 文档](https://stripe.com/docs/payments/accept-a-payment?platform=web)。\r\n\r\n使用 `pay` 方法时，你的 Stripe 控制面板中启用的默认付款方式将可供客户使用。 或者，如果你只想允许使用某些特定的支付方式，你可以使用 `payWith` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/pay', function (Request $request) {\r\n        $payment = $request->user()->payWith(\r\n            $request->get('amount'), ['card', 'bancontact']\r\n        );\r\n\r\n        return $payment->client_secret;\r\n    });\r\n\r\n> **注意**  \r\n> `pay` 和 `payWith` 方法接受以你的应用程序使用的货币的最低分母表示的付款金额。 例如，如果客户以美元付款，则应以美分指定金额。\r\n\r\n<a name=\"refunding-charges\"></a>\r\n### 退还费用\r\n\r\n如果你需要退还 Stripe 费用，你可以使用 refund 方法。 此方法接受 Stripe [payment intent ID](#payment-methods-for-single-charges) 作为其第一个参数：\r\n\r\n    $payment = $user->charge(100, $paymentMethodId);\r\n\r\n    $user->refund($payment->id);\r\n\r\n<a name=\"invoices\"></a>\r\n## 发票\r\n\r\n<a name=\"retrieving-invoices\"></a>\r\n### 检索发票\r\n\r\n你可以使用 `invoices` 方法轻松检索可计费模型的发票数组。 `invoices` 方法返回 `Laravel\\Cashier\\Invoice` 实例的集合：\r\n\r\n    $invoices = $user->invoices();\r\n\r\n如果你想在结果中包含待处理的发票，你可以使用 `invoicesIncludingPending` 方法：\r\n\r\n    $invoices = $user->invoicesIncludingPending();\r\n\r\n你可以使用 `findInvoice` 方法通过其 ID 检索特定发票：\r\n\r\n    $invoice = $user->findInvoice($invoiceId);\r\n\r\n<a name=\"displaying-invoice-information\"></a>\r\n#### 显示发票信息\r\n\r\n在为客户列出发票时，你可以使用发票的方法显示相关的发票信息。 例如，你可能希望在表格中列出每张发票，以便用户轻松下载其中任何一张：\r\n\r\n    <table>\r\n        @foreach ($invoices as $invoice)\r\n            <tr>\r\n                <td>{{ $invoice->date()->toFormattedDateString() }}</td>\r\n                <td>{{ $invoice->total() }}</td>\r\n                <td><a href=\"/user/invoice/{{ $invoice->id }}\">Download</a></td>\r\n            </tr>\r\n        @endforeach\r\n    </table>\r\n\r\n<a name=\"upcoming-invoices\"></a>\r\n### 即将收到的发票\r\n\r\n要检索客户即将收到的发票，你可以使用 `upcomingInvoice` 方法：\r\n\r\n    $invoice = $user->upcomingInvoice();\r\n\r\n类似地，如果客户有多个订阅，你还可以检索特定订阅的即将到来的发票：\r\n\r\n    $invoice = $user->subscription('default')->upcomingInvoice();\r\n\r\n<a name=\"previewing-subscription-invoices\"></a>\r\n### 预览订阅发票\r\n\r\n使用 `previewInvoice` 方法，你可以在更改价格之前预览发票。 这将允许你确定在进行给定价格更改时客户发票的外观：\r\n\r\n    $invoice = $user->subscription('default')->previewInvoice('price_yearly');\r\n\r\n你可以将一组价格传递给 `previewInvoice` 方法，以便预览具有多个新价格的发票：\r\n\r\n    $invoice = $user->subscription('default')->previewInvoice(['price_yearly', 'price_metered']);\r\n\r\n<a name=\"generating-invoice-pdfs\"></a>\r\n### 生成发票 PDF\r\n\r\n在生成发票 PDF 之前，你应该用 Composer 安装 Dompdf 库，它是 Cashier 的默认发票渲染器：\r\n\r\n```php\r\ncomposer require dompdf/dompdf\r\n```\r\n\r\n在路由或控制器中，你可以使用 `downloadInvoice` 方法生成给定发票的 PDF 下载。此方法将自动生成下载发票所需的正确 HTTP 响应：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/invoice/{invoice}', function (Request $request, string $invoiceId) {\r\n        return $request->user()->downloadInvoice($invoiceId);\r\n    });\r\n\r\n默认情况下，发票上的所有数据都来自存储在 Stripe 中的客户和发票数据。文件名是基于你的 `app.name` 配置值。但是，你可以通过提供一个数组作为 `downloadInvoice` 方法的第二个参数来自定义其中的一些数据。 此数组允许你自定义信息，例如你的公司和产品详细信息：\r\n\r\n    return $request->user()->downloadInvoice($invoiceId, [\r\n        'vendor' => 'Your Company',\r\n        'product' => 'Your Product',\r\n        'street' => 'Main Str. 1',\r\n        'location' => '2000 Antwerp, Belgium',\r\n        'phone' => '+32 499 00 00 00',\r\n        'email' => 'info@example.com',\r\n        'url' => 'https://example.com',\r\n        'vendorVat' => 'BE123456789',\r\n    ]);\r\n\r\n`downloadInvoice` 方法还允许通过其第三个参数自定义文件名。此文件名将自动以 `.pdf` 为后缀：\r\n\r\n    return $request->user()->downloadInvoice($invoiceId, [], 'my-invoice');\r\n\r\n<a name=\"custom-invoice-render\"></a>\r\n#### 自定义发票渲染器\r\n\r\nCashier 还可以使用自定义发票渲染器。 默认情况下，Cashier 使用 `DompdfInvoiceRenderer` 实现，它利用 [dompdf](https://github.com/dompdf/dompdf) PHP 库来生成 Cashier 的发票。但是，你可以通过实现 `Laravel\\Cashier\\Contracts\\InvoiceRenderer` 接口来使用任何你想要的渲染器。 例如，你可能希望使用对第三方 PDF 呈现服务的 API 调用来呈现发票 PDF：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n    use Laravel\\Cashier\\Contracts\\InvoiceRenderer;\r\n    use Laravel\\Cashier\\Invoice;\r\n\r\n    class ApiInvoiceRenderer implements InvoiceRenderer\r\n    {\r\n        /**\r\n         * 呈现给定的发票并返回原始 PDF 字节。\r\n         */\r\n        public function render(Invoice $invoice, array $data = [], array $options = []): string\r\n        {\r\n            $html = $invoice->view($data)->render();\r\n\r\n            return Http::get('https://example.com/html-to-pdf', ['html' => $html])->get()->body();\r\n        }\r\n    }\r\n\r\n一旦你实现了发票渲染器合约，你应该在你的应用程序的 `config/cashier.php` 配置文件中更新 `cashier.invoices.renderer` 配置值。 此配置值应设置为自定义渲染器实现的类名。\r\n\r\n<a name=\"checkout\"></a>\r\n## 结账\r\n\r\nCashier Stripe 还提供对 [Stripe Checkout](https://stripe.com/payments/checkout) 的支持。 Stripe Checkout 通过提供预构建的托管支付页面，消除了实施自定义页面以接受付款的痛苦。\r\n\r\n以下文档包含有关如何开始使用 Stripe Checkout with Cashier 的信息。 要了解有关 Stripe Checkout 的更多信息，你还应该考虑查看 [Stripe 自己的 Checkout 文档](https://stripe.com/docs/payments/checkout) 。\r\n\r\n<a name=\"product-checkouts\"></a>\r\n### 产品结账\r\n\r\n你可以在计费模型上使用 `checkout` 方法对已在 Stripe 仪表板中创建的现有产品执行结帐。 `checkout` 方法将启动一个新的 Stripe Checkout 会话。 默认情况下，你需要传递 Stripe Price ID：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()->checkout('price_tshirt');\r\n    });\r\n\r\n如果需要，你还可以指定产品数量：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()->checkout(['price_tshirt' => 15]);\r\n    });\r\n\r\n当客户访问此路由时，他们将被重定向到 Stripe 的结帐页面。 默认情况下，当用户成功完成或取消购买时，他们将被重定向到你的 `home` 路由位置，但你可以使用 `success_url` 和 `cancel_url` 参数指定自定义回调 URL：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()->checkout(['price_tshirt' => 1], [\r\n            'success_url' => route('your-success-route'),\r\n            'cancel_url' => route('your-cancel-route'),\r\n        ]);\r\n    });\r\n\r\n在定义 `success_url` 结帐选项时，你可以指示 Stripe 在调用 URL 时将结帐会话 ID 添加为查询字符串参数。为此，请将文字字符串 `{CHECKOUT_SESSION_ID}` 添加到你的 `success_url` 查询字符串。Stripe 将用实际的结帐会话 ID 替换此占位符：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Stripe\\Checkout\\Session;\r\n    use Stripe\\Customer;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()->checkout(['price_tshirt' => 1], [\r\n            'success_url' => route('checkout-success').'?session_id={CHECKOUT_SESSION_ID}',\r\n            'cancel_url' => route('checkout-cancel'),\r\n        ]);\r\n    });\r\n\r\n    Route::get('/checkout-success', function (Request $request) {\r\n        $checkoutSession = $request->user()->stripe()->checkout->sessions->retrieve($request->get('session_id'));\r\n\r\n        return view('checkout.success', ['checkoutSession' => $checkoutSession]);\r\n    })->name('checkout-success');\r\n\r\n<a name=\"checkout-promotion-codes\"></a>\r\n#### 优惠码\r\n\r\n默认情况下，Stripe Checkout 不允许[用户可兑换促销代码](https://stripe.com/docs/billing/subscriptions/discounts/codes) 。幸运的是，有一种简单的方法可以为你的结帐页面启用这些功能。为此，你可以调用 `allowPromotionCodes` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return $request->user()\r\n            ->allowPromotionCodes()\r\n            ->checkout('price_tshirt');\r\n    });\r\n\r\n<a name=\"single-charge-checkouts\"></a>\r\n### 单次收费结账\r\n\r\n你还可以对尚未在 Stripe 仪表板中创建的临时产品进行简单收费。为此，你可以在计费模型上使用 `checkoutCharge` 方法，并向其传递可计费金额、产品名称和可选数量。当客户访问此路由时，他们将被重定向到 Stripe 的结帐页面：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/charge-checkout', function (Request $request) {\r\n        return $request->user()->checkoutCharge(1200, 'T-Shirt', 5);\r\n    });\r\n\r\n> **注意**  \r\n> 当使用 `checkoutCharge` 方法时，Stripe 将始终在你的 Stripe 仪表板中创建新产品和价格。因此，我们建议你在 Stripe 仪表板中预先创建产品，并改用 `checkout` 方法。\r\n\r\n<a name=\"subscription-checkouts\"></a>\r\n### 订阅结帐\r\n\r\n> **注意**  \r\n> 使用 Stripe Checkout 进行订阅需要你在 Stripe 仪表板中启用 `customer.subscription.created` webhook。 此 webhook 将在你的数据库中创建订阅记录并存储所有相关的订阅项。\r\n\r\n你也可以使用 Stripe Checkout 来启动订阅。 在使用 Cashier 的订阅构建器方法定义你的订阅后，你可以调用 `checkout` 方法。 当客户访问此路由时，他们将被重定向到 Stripe 的结帐页面：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/subscription-checkout', function (Request $request) {\r\n        return $request->user()\r\n            ->newSubscription('default', 'price_monthly')\r\n            ->checkout();\r\n    });\r\n\r\n与产品结帐一样，你可以自定义成功和取消 URL：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/subscription-checkout', function (Request $request) {\r\n        return $request->user()\r\n            ->newSubscription('default', 'price_monthly')\r\n            ->checkout([\r\n                'success_url' => route('your-success-route'),\r\n                'cancel_url' => route('your-cancel-route'),\r\n            ]);\r\n    });\r\n\r\n当然，你也可以为订阅结帐启用优惠码：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/subscription-checkout', function (Request $request) {\r\n        return $request->user()\r\n            ->newSubscription('default', 'price_monthly')\r\n            ->allowPromotionCodes()\r\n            ->checkout();\r\n    });\r\n\r\n> **注意**  \r\n> 不幸的是，在开始订阅时，Stripe Checkout 不支持所有订阅计费选项。在订阅生成器上使用 `anchorBillingCycleOn` 方法、设置按比例分配行为或设置支付行为在 Stripe Checkout 会话期间不会有任何影响。请查阅 [Stripe Checkout Session API 文档](https://stripe.com/docs/api/checkout/sessions/create)以查看可用的参数。\r\n\r\n<a name=\"stripe-checkout-trial-periods\"></a>\r\n#### Stripe Checkout 和试用期\r\n\r\n当然，你可以在构建将使用 Stripe Checkout 完成的订阅时定义一个试用期：\r\n\r\n    $checkout = Auth::user()->newSubscription('default', 'price_monthly')\r\n        ->trialDays(3)\r\n        ->checkout();\r\n\r\n但是，试用期必须至少为 48 小时，这是 Stripe Checkout 支持的最短试用时间。\r\n\r\n<a name=\"stripe-checkout-subscriptions-and-webhooks\"></a>\r\n#### 订阅和 Webhooks\r\n\r\n请记住，Stripe 和 Cashier 通过 webhook 更新订阅状态，因此当客户在输入付款信息后返回应用程序时，订阅可能尚未激活。要处理这种情况，你可能希望显示一条消息，通知用户他们的付款或订阅处于待处理状态。\r\n\r\n<a name=\"collecting-tax-ids\"></a>\r\n### 收集税号 ID\r\n\r\nCheckout 还支持收集客户的税号。要在结帐会话上启用此功能，请在创建会话时调用 `collectTaxIds` 方法：\r\n\r\n    $checkout = $user->collectTaxIds()->checkout('price_tshirt');\r\n\r\n调用此方法时，客户会显示一个新的复选框，允许他们选择是否作为公司进行采购。如果选择是，他们可以提供他们的税号。\r\n\r\n> **注意**  \r\n> 如果你已经在应用程序的服务提供者中配置了 [自动征税](#tax-configuration) ，那么该功能将自动启用，无需调用 `collectTaxIds` 方法。\r\n\r\n<a name=\"guest-checkouts\"></a>\r\n### 访客结账\r\n\r\n使用 `Checkout::guest` 方法，你可以为你的应用程序中没有注册过「账户」的访客启动结账会话：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Laravel\\Cashier\\Checkout;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return Checkout::guest()->create('price_tshirt', [\r\n            'success_url' => route('your-success-route'),\r\n            'cancel_url' => route('your-cancel-route'),\r\n        ]);\r\n    });\r\n\r\n与为现有用户创建结账会话类似，你可以利用 `Laravel\\Cashier\\CheckoutBuilder` 实例上的其他方法来定制访客结账会话：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Laravel\\Cashier\\Checkout;\r\n\r\n    Route::get('/product-checkout', function (Request $request) {\r\n        return Checkout::guest()\r\n            ->withPromotionCode('promo-code')\r\n            ->create('price_tshirt', [\r\n                'success_url' => route('your-success-route'),\r\n                'cancel_url' => route('your-cancel-route'),\r\n            ]);\r\n    });\r\n\r\n在访客结账完成后，Stripe 会发送一个 `checkout.session.completed` 的 webhook 事件，所以请确保[配置你的 Stripe webhook](https://dashboard.stripe.com/webhooks) 以实际发送这个事件到你的应用程序。一旦 webhook 在 Stripe 仪表板中被启用，你就可以[用 Cashier 处理 webhook ](#handling-stripe-webhooks) 。webhook 负载中包含的对象将是一个[`checkout` 对象](https://stripe.com/docs/api/checkout/sessions/object) ，你可以检查它以完成你的客户的订单。\r\n\r\n<a name=\"handling-failed-payments\"></a>\r\n## 处理失败的付款\r\n\r\n有时，订阅或单笔费用的付款可能会失败。当这种情况发生时，Cashier 会抛出一个 `Laravel\\Cashier\\Exceptions\\IncompletePayment` 异常，通知你发生了这种情况。捕获此异常后，你有两个选择如何继续。\r\n\r\n首先，你可以将你的客户重定向到 Cashier 附带的专用付款确认页面。该页面已经有一个通过 Cashier 的服务提供商注册的关联命名路由。因此，你可能会捕获 `IncompletePayment` 异常并将用户重定向到付款确认页面：\r\n\r\n    use Laravel\\Cashier\\Exceptions\\IncompletePayment;\r\n\r\n    try {\r\n        $subscription = $user->newSubscription('default', 'price_monthly')\r\n                                ->create($paymentMethod);\r\n    } catch (IncompletePayment $exception) {\r\n        return redirect()->route(\r\n            'cashier.payment',\r\n            [$exception->payment->id, 'redirect' => route('home')]\r\n        );\r\n    }\r\n\r\n在付款确认页面上，将提示客户再次输入他们的信用卡信息并执行 Stripe 要求的任何其他操作，例如 「3D Secure」确认。 确认付款后，用户将被重定向到上面指定的 `redirect` 参数提供的 URL 。重定向后， `message` （字符串）和 `success` （整数）查询字符串变量将被添加到 URL 。支付页面目前支持以下支付方式类型：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- Credit Cards\r\n- Alipay\r\n- Bancontact\r\n- BECS Direct Debit\r\n- EPS\r\n- Giropay\r\n- iDEAL\r\n- SEPA Direct Debit\r\n\r\n</div>\r\n\r\n或者，你可以让 Stripe 为你处理付款确认。 在这种情况下，你可以在 Stripe 控制面板中[设置 Stripe 的自动计费电子邮件](https://dashboard.stripe.com/account/billing/automatic) ，而不是重定向到付款确认页面。 但是，如果捕获到 `IncompletePayment` 异常，你仍应通知用户他们将收到一封包含进一步付款确认说明的电子邮件。\r\n\r\n以下方法可能会抛出支付异常：使用 `Billable` 特性的模型上的 `charge` 、 `invoiceFor` 和 `invoice`。 与订阅交互时，`SubscriptionBuilder` 上的`create` 方法以及`Subscription` 和`SubscriptionItem` 模型上的`incrementAndInvoice` 和`swapAndInvoice` 方法可能会抛出未完成支付异常。\r\n\r\n可以使用计费模型或订阅实例上的 `hasIncompletePayment` 方法来确定现有订阅是否有未完成的付款：\r\n\r\n    if ($user->hasIncompletePayment('default')) {\r\n        // ...\r\n    }\r\n\r\n    if ($user->subscription('default')->hasIncompletePayment()) {\r\n        // ...\r\n    }\r\n\r\n你可以通过检查异常实例上的 `payment` 属性来获取未完成付款的具体状态：\r\n\r\n    use Laravel\\Cashier\\Exceptions\\IncompletePayment;\r\n\r\n    try {\r\n        $user->charge(1000, 'pm_card_threeDSecure2Required');\r\n    } catch (IncompletePayment $exception) {\r\n        // 获取支付意目标状态...\r\n        $exception->payment->status;\r\n\r\n        // 检查具体条件...\r\n        if ($exception->payment->requiresPaymentMethod()) {\r\n            // ...\r\n        } elseif ($exception->payment->requiresConfirmation()) {\r\n            // ...\r\n        }\r\n    }\r\n\r\n<a name=\"strong-customer-authentication\"></a>\r\n## 强大的客户认证\r\n\r\n如果你的企业或你的客户之一位于欧洲，你将需要遵守欧盟的强客户认证 (SCA) 法规。 欧盟于 2019 年 9 月实施了这些规定，以防止支付欺诈。 幸运的是，Stripe 和 Cashier 已准备好构建符合 SCA 的应用程序。\r\n\r\n> **注意**\r\n> 在开始之前，请查看 [Stripe 关于 PSD2 和 SCA 的指南](https://stripe.com/guides/strong-customer-authentication)以及他们的[关于新 SCA API 的文档](https://stripe.com/docs/strong-customer-authentication).\r\n\r\n<a name=\"payments-requiring-additional-confirmation\"></a>\r\n### 需要额外确认的付款\r\n\r\nSCA 法规通常需要额外验证以确认和处理付款。 发生这种情况时，Cashier 将抛出一个 `Laravel\\Cashier\\Exceptions\\IncompletePayment` 异常，通知你需要额外的验证。 有关如何处理这些异常的更多信息，请参阅有关的 [handling failed payments](#handling-failed-payments) 文档。\r\n\r\nStripe 或 Cashier 显示的支付确认屏幕可能会根据特定银行或发卡机构的支付流程进行定制，并且可能包括额外的银行卡确认、临时小额收费、单独的设备身份验证或其他形式的验证。\r\n\r\n<a name=\"incomplete-and-past-due-state\"></a>\r\n#### 未完成和逾期状态\r\n\r\n当付款需要额外确认时，订阅将保持在 `incomplete` 或 `past_due` 状态，如其  `stripe_status` 数据库列所示。 付款确认完成后，Cashier 将自动激活客户的订阅，并且 Stripe 通过 webhook 通知你的应用程序已完成。\r\n\r\n有关 `incomplete` 和 `past_due` 状态的更多信息，请参阅[我们关于这些状态的附加文档](#incomplete-and-past-due-status)。\r\n\r\n<a name=\"off-session-payment-notifications\"></a>\r\n### 非会话付款通知\r\n\r\n由于 SCA 法规要求客户偶尔验证他们的付款细节，即使他们的订阅处于活动状态，Cashier 也可以在需要非会话付款确认时向客户发送通知。 例如，这可能在订阅续订时发生。 可以通过将 `CASHIER_PAYMENT_NOTIFICATION` 环境变量设置为通知类来启用收银员的付款通知。 默认情况下，此通知处于禁用状态。 当然，Cashier 包含一个你可以用于此目的的通知类，但如果需要，你可以自由提供自己的通知类：\r\n\r\n```ini\r\nCASHIER_PAYMENT_NOTIFICATION=Laravel\\Cashier\\Notifications\\ConfirmPayment\r\n```\r\n\r\n为确保发送会话外付款确认通知，请验证你的应用程序的 [Stripe webhooks 已配置](#handling-stripe-webhooks)并且在你的 Stripe 仪表板中启用了 `invoice.payment_action_required` 。 此外，你的 `Billable` 模型还应该使用 Laravel 的 `Illuminate\\Notifications\\Notifiable` 特性。\r\n\r\n> **注意**\r\n> 即使客户手动进行需要额外确认的付款，也会发送通知。 不幸的是，Stripe 无法知道付款是手动完成的还是「离线」完成的。 但是，如果客户在确认付款后访问付款页面，他们只会看到「付款成功」消息。 不允许客户不小心确认两次相同的付款而招致意外的二次扣款。\r\n\r\n<a name=\"stripe-sdk\"></a>\r\n## Stripe SDK\r\n\r\nCashier 的许多对象都是 Stripe SDK 对象的包装器。 如果你想直接与 Stripe 对象交互，你可以使用 `asStripe` 方法方便地搜索它们：:\r\n\r\n    $stripeSubscription = $subscription->asStripeSubscription();\r\n\r\n    $stripeSubscription->application_fee_percent = 5;\r\n\r\n    $stripeSubscription->save();\r\n\r\n你还可以使用 `updateStripeSubscription` 方法直接更新 Stripe 订阅：\r\n\r\n    $subscription->updateStripeSubscription(['application_fee_percent' => 5]);\r\n\r\n如果你想直接使用 `Stripe\\StripeClient` 客户端，你可以调用 `Cashier` 类的 `stripe` 方法。 例如，你可以使用此方法访问「StripeClient」实例并从你的 Stripe 帐户中搜索价格列表：\r\n\r\n    use Laravel\\Cashier\\Cashier;\r\n\r\n    $prices = Cashier::stripe()->prices->all();\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n在测试使用 Cashier 的应用程序时，你可以模拟对 Stripe API 的实际 HTTP 请求； 但是，这需要你重新实现部分地 Cashier 自己的行为。 因此，我们建议让你的测试命中实际的 Stripe API。 虽然速度较慢，但它可以让你更加确信你的应用程序正在按预期工作，并且任何缓慢的测试都可以放在他们自己的 PHPUnit 测试组中。\r\n\r\n测试时，请记住 Cashier 本身已经有一个很棒的测试套件，因此你应该只专注于测试自己的应用程序的订阅和支付流程，而不是每个底层的 Cashier 行为。\r\n\r\n首先，将 Stripe 密钥的 **testing** 版本添加到你的 `phpunit.xml` 文件中：\r\n\r\n    <env name=\"STRIPE_SECRET\" value=\"sk_test_<your-key>\"/>\r\n\r\n现在，每当你在测试时与 Cashier 交互时，它都会向你的 Stripe 测试环境发送实际的 API 请求。为方便起见，你应该使用可能在测试期间使用的订阅 / 计划预先填写你的 Stripe 测试帐户。\r\n\r\n> **技巧**  \r\n> 为了测试各种计费场景，例如信用卡拒付和失败，你可以使用 Stripe 提供的大量的[测试卡号和令牌](https://stripe.com/docs/testing) 。\r\n\r\n","p":"docs/billing.html"},{"t":"cashier-paddle (Laravel 交易工具包 (Paddle))","d":"\n# Laravel 交易工具包 (Paddle)\r\n\r\n- [介绍](#introduction)\r\n- [升级 Cashier](#upgrading-cashier)\r\n- [安装](#installation)\r\n    - [Paddle 沙盒](#paddle-sandbox)\r\n    - [数据迁移](#database-migrations)\r\n- [配置](#configuration)\r\n    - [Billable 模型](#billable-model)\r\n    - [API Keys](#api-keys)\r\n    - [Paddle JS](#paddle-js)\r\n    - [货币配置](#currency-configuration)\r\n    - [扩展默认模型](#overriding-default-models)\r\n- [核心概念](#core-concepts)\r\n    - [支付链接](#pay-links)\r\n    - [內联结账](#inline-checkout)\r\n    - [用户鉴定](#user-identification)\r\n- [价格](#prices)\r\n- [用户](#customers)\r\n    - [用户默认设置](#customer-defaults)\r\n- [订阅](#subscriptions)\r\n    - [创建订阅](#creating-subscriptions)\r\n    - [检查订阅状态](#checking-subscription-status)\r\n    - [订阅一次性收费](#subscription-single-charges)\r\n    - [更新交易信息](#updating-payment-information)\r\n    - [更新计划](#changing-plans)\r\n    - [订阅量](#subscription-quantity)\r\n    - [更新订阅](#subscription-modifiers)\r\n    - [多个订阅](#multiple-subscriptions)\r\n    - [暂停订阅](#pausing-subscriptions)\r\n    - [取消订阅](#cancelling-subscriptions)\r\n- [订阅试用](#subscription-trials)\r\n    - [预付款方式](#with-payment-method-up-front)\r\n    - [非预付款方式](#without-payment-method-up-front)\r\n- [处理 Paddle Webhooks](#handling-paddle-webhooks)\r\n    - [定义 Webhook 事件处理程序](#defining-webhook-event-handlers)\r\n    - [校验 Webhook 签名](#verifying-webhook-signatures)\r\n- [一次性收费](#single-charges)\r\n    - [简单收费](#simple-charge)\r\n    - [收费产品](#charging-products)\r\n    - [退款订单](#refunding-orders)\r\n- [收据](#receipts)\r\n    - [过去和未来的付款](#past-and-upcoming-payments)\r\n- [处理失败交易](#handling-failed-payments)\r\n- [测试](#testing)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Cashier Paddle](https://github.com/laravel/cashier-paddle) 为 [Paddle's](https://paddle.com) 订阅计费服务提供了一个富有表现力、流畅的界面。它几乎能够处理所有你所恐惧的各种订阅计费逻辑和代码。除了基本的订阅管理，Cashier 还可以处理：优惠券、交换订阅、订阅「数量」、取消宽限期等。\r\n\r\n在使用 Cashier 时，推荐你回顾一下 Paddle 的[用户手册](https://developer.paddle.com/guides) and [API 文档](https://developer.paddle.com/api-reference/intro)。\r\n\n\n<a name=\"upgrading-cashier\"></a>\r\n## 升级 Cashier\r\n\r\n当升级到一个新版本的 Cashier 时，推荐仔细回顾下 [升级指南](https://github.com/laravel/cashier-paddle/blob/master/UPGRADE.) 这非常重要。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，使用 Composer 包管理器安装 Paddle 的 Cashier 包：\r\n\r\n```shell\r\ncomposer require laravel/cashier-paddle\r\n```\r\n\r\n> 注意：为了确保 Cashier 正确处理所有 Paddle 事件，请记得 [配置 Cashier 的 webhook 处理](#handling-paddle-webhooks)。\r\n\r\n<a name=\"paddle-sandbox\"></a>\r\n### Paddle 沙盒\r\n\r\n在本地和预发布开发环境中，应该 [注册一个 Paddle 沙盒账号](https://developer.paddle.com/getting-started/sandbox)。这个账号将为你提供一个沙盒环境来测试和开发你的应用，而不会产生真实的交易。你也许会使用 Paddle 的 [测试卡号](https://developer.paddle.com/getting-started/sandbox#test-cards) 来模拟各种交易场景。\r\n\r\n在使用 Pable 沙盒环境时，你应在应用程序的 `.env` 环境文件中将 `PADDLE_SANDBOX` 环境变量设置为 `true` ：\r\n\r\n```ini\r\nPADDLE_SANDBOX=true\r\n```\r\n\r\n在你已经完成你的应用开发之后，你也许会 [申请一个 Paddle 正式账号](https://paddle.com/) 。 在你的应用程序投入生产环境之前，Paddle 需要批准你的应用程序的域。\r\n\r\n<a name=\"database-migrations\"></a>\r\n### 数据迁移\r\n\r\nCashier 服务提供者注册它自己的数据迁移目录，所以你记得在安装扩展包之后执行数据迁移。Cashier 数据迁移将生成新的 `customers` 表。另外，新的 `subscriptions` 表将被创建，来存储所有你的用户的订阅。最后，新的 `receipts` 表也将被创建，来存储所有你的收据信息:\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n\n\n如果你需要重写 Cashier 中的数据迁移，你可以使用 `vendor:publish` Artisan 命令来发布它们：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=\"cashier-migrations\"\r\n```\r\n\r\n如果你想阻止 Cashier 的数据迁移全部执行，你可以使用 Cashier 提供的 `ignoreMigrations`。通常，这个方法会在 `AppServiceProvider` 的 `register` 方法中被调用：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    /**\r\n     * 注册服务。\r\n     */\r\n    public function register(): void\r\n    {\r\n        Cashier::ignoreMigrations();\r\n    }\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"billable-model\"></a>\r\n### Billable 模型\r\n\r\n在使用 Cashier 之前，你必须将 `Billable` trait 添加到你的用户模型定义中。 这里的 trait 提供了多种方法来允许你执行常见的计费任务，例如创建订阅、应用优惠券和更新付款方式信息：\r\n\r\n    use Laravel\\Paddle\\Billable;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use Billable;\r\n    }\r\n\r\n如果你有非用户的计费实体，你还可以将特征添加到这些类中：\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Paddle\\Billable;\r\n\r\n    class Team extends Model\r\n    {\r\n        use Billable;\r\n    }\r\n\r\n<a name=\"api-keys\"></a>\r\n### API Keys\r\n\r\n接下来，你应该在应用程序的 `.env` 文件中配置你的 Paddle 。 你可以从 Paddle 控制面板检索你的 Paddle API 密钥：\r\n\r\n```ini\r\nPADDLE_VENDOR_ID=your-paddle-vendor-id\r\nPADDLE_VENDOR_AUTH_CODE=your-paddle-vendor-auth-code\r\nPADDLE_PUBLIC_KEY=\"your-paddle-public-key\"\r\nPADDLE_SANDBOX=true\r\n```\r\n\r\n当你使用 [Paddle 的沙箱环境](#paddle-sandbox) 时，`PADDLE_SANDBOX` 环境变量应该设置为 `true`。如果你将应用程序部署到生产环境并使用 Paddle 的实时供应商环境，则 `PADDLE_SANDBOX` 变量应该设置为 `false`。\r\n\n\n<a name=\"paddle-js\"></a>\r\n### Paddle JS\r\n\r\nPaddle 依赖其自己的 JavaScript 库来启动 Paddle 结账小部件。你可以通过在应用程序布局中的 `</head>` 标签关闭之前放置 `@paddleJS` Blade 指令来加载 JavaScript 库：\r\n\r\n```blade\r\n<head>\r\n    ...\r\n\r\n    @paddleJS\r\n</head>\r\n```\r\n\r\n<a name=\"currency-configuration\"></a>\r\n### 货币配置\r\n\r\n默认 Cashier 货币是美元（USD）。你可以在 `.env` 文件中定义 `CASHIER_CURRENCY` 环境变量来更改默认货币：\r\n\r\n```ini\r\nCASHIER_CURRENCY=EUR\r\n```\r\n\r\n除了配置 Cashier 的货币之外，你还可以指定在格式化货币值以显示在发票上时要使用的区域。Cashier 内部利用 [PHP 的 NumberFormatter 类](https://www.php.net/manual/en/class.numberformatter.php)来设置货币区域：\r\n\r\n```ini\r\nCASHIER_CURRENCY_LOCALE=nl_BE\r\n```\r\n\r\n> 注意：为了使用 `en` 以外的语言环境，请确保你的服务器上安装并配置了 `ext-intl` PHP 扩展。\r\n\r\n<a name=\"overriding-default-models\"></a>\r\n### 覆盖默认模型\r\n\r\n你可以通过定义自己的模型并继承相应的 Cashier 模型来自由扩展 Cashier 模型：\r\n\r\n    use Laravel\\Paddle\\Subscription as CashierSubscription;\r\n\r\n    class Subscription extends CashierSubscription\r\n    {\r\n        // ...\r\n    }\r\n\r\n定义模型后，你可以通过 `Laravel\\Paddle\\Cashier` 类指示 Cashier 使用你的自定义模型。通常，你应该在应用的 `App\\Providers\\AppServiceProvider` 类的 `boot` 方法中通知 Cashier 关于你的自定义模型：\r\n\r\n    use App\\Models\\Cashier\\Receipt;\r\n    use App\\Models\\Cashier\\Subscription;\r\n\r\n    /**\r\n     * 启动应用服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Cashier::useReceiptModel(Receipt::class);\r\n        Cashier::useSubscriptionModel(Subscription::class);\r\n    }\r\n\r\n\n\n<a name=\"core-concepts\"></a>\r\n## 核心概念\r\n\r\n<a name=\"pay-links\"></a>\r\n### 支付链接\r\n\r\nPaddle 缺乏广泛的 CRUD API 来执行订阅状态更改。因此，与 Paddle 的大多数交互都是通过其 [结帐小部件](https://developer.paddle.com/guides/how-tos/checkout/paddle-checkout) 完成的。在使用结账小部件之前，我们必须使用 Cashier 生成一个 「支付链接」。 「支付链接」将通知结账小部件我们希望执行的计费操作：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/subscribe', function (Request $request) {\r\n        $payLink = $request->user()->newSubscription('default', $premium = 34567)\r\n            ->returnTo(route('home'))\r\n            ->create();\r\n\r\n        return view('billing', ['payLink' => $payLink]);\r\n    });\r\n\r\nCashier 包括一个 `paddle-button` [Blade 组件](/docs/laravel/10.x/blade#components)。 我们可以将支付链接 URL 作为 「prop」传递给该组件。 单击此按钮时，将显示 Paddle 的结帐小部件：\r\n\r\n```html\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\">\r\n    订阅\r\n</x-paddle-button>\r\n```\r\n\r\n默认情况下，这将显示一个具有标准 Paddle 样式的按钮。 你可以通过向组件添加 `data-theme=\"none\"` 属性来删除所有 Paddle 样式：\r\n\r\n```html\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\" data-theme=\"none\">\r\n    订阅\r\n</x-paddle-button>\r\n```\r\n\r\nPaddle 结账小部件是异步的。 一旦用户在小部件中创建或更新订阅，Paddle 将发送你的应用程序 webhook，以便你可以在我们自己的数据库中正确更新订阅状态。 因此，正确 [设置 webhooks](#handling-paddle-webhook) 以同步 Paddle 的状态变化非常重要。\r\n\r\n有关支付链接的更多信息，你可以查看 [有关支付链接生成的 Paddle API 文档](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink)。\r\n\r\n> 注意：订阅状态更改后，接收相应 webhook 的延迟通常很小，但你应该在应用程序中考虑到这一点，因为你的用户订阅在完成结帐后可能不会立即生效。\r\n\r\n\n\n<a name=\"manually-rendering-pay-links\"></a>\r\n#### 手动呈现支付链接\r\n\r\n你也可以在不使用 Laravel 内置的 Blade 组件的情况下手动渲染支付链接。 首先，生成支付链接 URL，如先前所示：\r\n\r\n    $payLink = $request->user()->newSubscription('default', $premium = 34567)\r\n        ->returnTo(route('home'))\r\n        ->create();\r\n\r\n接下来，只需将支付链接 URL 附加到 HTML 中的 `a` 元素：\r\n\r\n    <a href=\"#!\" class=\"ml-4 paddle_button\" data-override=\"{{ $payLink }}\">\r\n        Paddle 支付\r\n    </a>\r\n\r\n<a name=\"payments-requiring-additional-confirmation\"></a>\r\n#### 需要额外确认的付款\r\n\r\n有时需要额外的验证才能确认和处理付款。发生这种情况时，Paddle 将显示付款确认屏幕。Paddle 或 Cashier 显示的付款确认屏幕可能会针对特定银行或发卡机构的付款流程进行定制，并且可能包括额外的卡确认、临时小额费用、单独的设备身份验证或其他形式的验证。\r\n\r\n<a name=\"inline-checkout\"></a>\r\n### 内联结账\r\n\r\n如果你不想使用 Paddle 的 「叠加」样式结帐小部件，Paddle 还提供了内嵌显示小部件的选项。 虽然这种方法不允许你调整任何结帐的 HTML 字段，但它允许你将小部件嵌入到你的应用中。\r\n\r\n为了让你轻松开始内联结账，Cashier 包含一个 `paddle-checkout` Blade 组件。 首先，你应该 [生成支付链接](#pay-links)并将支付链接传递给组件的 `override` 属性：\r\n\r\n```blade\r\n<x-paddle-checkout :override=\"$payLink\" class=\"w-full\" />\r\n```\r\n\r\n要调整内联结帐组件的高度，你可以将 `height` 属性传递给 Blade 组件：\r\n\r\n```blade\r\n<x-paddle-checkout :override=\"$payLink\" class=\"w-full\" height=\"500\" />\r\n```\r\n\r\n\n\n<a name=\"inline-checkout-without-pay-links\"></a>\r\n#### 没有支付链接的内联结账\r\n\r\n或者，你可以使用自定义选项而不是使用支付链接来自定义小部件：\r\n\r\n```blade\r\n@php\r\n$options = [\r\n    'product' => $productId,\r\n    'title' => 'Product Title',\r\n];\r\n@endphp\r\n\r\n<x-paddle-checkout :options=\"$options\" class=\"w-full\" />\r\n```\r\n\r\n请参阅 Paddle 的 [Inline Checkout 指南](https://developer.paddle.com/guides/how-tos/checkout/inline-checkout) 以及他们的 [参数参考](https://developer.paddle.com/reference/paddle-js/parameters) 以获取有关内联结帐可用选项的更多详细信息。\r\n\r\n> 注意：如果你想在指定自定义选项时也使用 passthrough 选项，你应该提供一个键 / 值数组作为其值。Cashier 将自动处理将数组转换为 JSON 字符串。 此外，`customer_id` passthrough 选项保留供内部 Cashier 使用。\r\n\r\n<a name=\"manually-rendering-an-inline-checkout\"></a>\r\n#### 手动呈现内联结账\r\n\r\n你也可以在不使用 Laravel 的内置 Blade 组件的情况下手动渲染内联结账。 首先，生成支付链接 URL [如前面示例中所示](#pay-links)。\r\n\r\n接下来，你可以使用 Paddle.js 来初始化结帐。 为了让这个例子简单，我们将使用 [Alpine.js](https://github.com/alpinejs/alpine) 来演示； 但是，你可以自由地将此示例转换为你自己的前端技术栈：\r\n\r\n```alpine\r\n<div class=\"paddle-checkout\" x-data=\"{}\" x-init=\"\r\n    Paddle.Checkout.open({\r\n        override: {{ $payLink }},\r\n        method: 'inline',\r\n        frameTarget: 'paddle-checkout',\r\n        frameInitialHeight: 366,\r\n        frameStyle: 'width: 100%; background-color: transparent; border: none;'\r\n    });\r\n\">\r\n</div>\r\n```\r\n\r\n<a name=\"user-identification\"></a>\r\n### 用户识别\r\n\r\n与 Stripe 相比，Paddle 用户在所有 Paddle 中都是独一无二的，而不是每个 Paddle 帐户都是独一无二的。因此，Paddle 的 API 目前不提供更新用户详细信息（例如电子邮件地址）的方法。在生成支付链接时，Paddle 使用 `customer_email` 参数识别用户。创建订阅时，Paddle 将尝试将用户提供的电子邮件与现有 Paddle 用户进行匹配。\r\n\n\n鉴于这种行为，在使用 Cashier 和 Paddle 时需要记住一些重要的事情。首先，你应该知道，即使 Cashier 中的订阅绑定到同一个应用程序用户，**它们也可能绑定到 Paddle 内部系统中的不同用户**。其次，每个订阅都有自己的连接支付方式信息，并且在 Paddle 的内部系统中也可能有不同的电子邮件地址（取决于创建订阅时分配给用户的电子邮件）。\r\n\r\n因此，在显示订阅时，你应该始终告知用户哪些电子邮件地址或付款方式信息与订阅相关联。可以使用 `Laravel\\Paddle\\Subscription` 模型提供的以下方法检索这些信息：\r\n\r\n    $subscription = $user->subscription('default');\r\n\r\n    $subscription->paddleEmail();\r\n    $subscription->paymentMethod();\r\n    $subscription->cardBrand();\r\n    $subscription->cardLastFour();\r\n    $subscription->cardExpirationDate();\r\n\r\n当前，没有办法通过 Paddle API 修改用户的电子邮件地址。当用户想在 Paddle 内更新他们的电子邮件地址时，他们唯一的方法是联系 Paddle 客户支持。在与 Paddle 沟通时，他们需要提供订阅的 `paddleEmail`，这样 Paddle 就可以更新正确的用户。\r\n\r\n<a name=\"prices\"></a>\r\n## 定价\r\n\r\nPaddle 允许你自定义每种货币对应的价格，也就是说 Paddle 允许你为不同国家和地区配置不同的价格。Cashier Paddle 允许你使用 `productPrices` 方法检索一个特定产品的所有价格。这个方法接受你希望检索价格的产品的产品 ID：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    $prices = Cashier::productPrices([123, 456]);\r\n\r\n\n\n货币将根据请求的 IP 地址来确定，当然你也可以传入一个可选的国家和地区参数来检索特定国家和地区的价格：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    $prices = Cashier::productPrices([123, 456], ['customer_country' => 'BE']);\r\n\r\n检索出价格后，你可以根据需要显示它们：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - {{ $price->price()->gross() }}</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n你也可以显示净价（不含税）并将税额显示分离：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - {{ $price->price()->net() }} (+ {{ $price->price()->tax() }} tax)</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n如果你检索了订阅的价格，你可以分别显示其原始价格和连续订阅价格：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - Initial: {{ $price->initialPrice()->gross() }} - Recurring: {{ $price->recurringPrice()->gross() }}</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n更多相关信息，请 [查看 Paddle 的价格 API 文档](https://developer.paddle.com/api-reference/checkout-api/prices/getprices)。\r\n\r\n<a name=\"prices-customers\"></a>\r\n#### 客户\r\n\r\n如果用户已经是客户并且你希望显示适用于该客户的价格，你可以通过直接从客户实例检索价格来实现：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $prices = User::find(1)->productPrices([123, 456]);\r\n\r\n在内部，Cashier 将使用用户的 [`paddleCountry` 方法](#customer-defaults) 来检索以他们的货币表示的价格。例如，居住在美国的用户将看到以美元为单位的价格，而位于比利时的用户将看到以欧元为单位的价格。如果找不到匹配的货币，则将使用产品的默认货币。你可以在 Paddle 控制面板中自定义产品或订阅计划的所有价格。\r\n\r\n\n\n<a name=\"prices-coupons\"></a>\r\n#### 优惠券\r\n\r\n你也可以展示选择优惠券后的折扣价。 在调用 `productPrices` 方法时，优惠券可以作为逗号分隔的字符串传递：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    $prices = Cashier::productPrices([123, 456], [\r\n        'coupons' => 'SUMMERSALE,20PERCENTOFF'\r\n    ]);\r\n\r\n然后，使用 `price` 方法显示计算出的价格：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - {{ $price->price()->gross() }}</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n你可以使用 `listPrice` 方法显示原价（没有优惠券折扣）：\r\n\r\n```blade\r\n<ul>\r\n    @foreach ($prices as $price)\r\n        <li>{{ $price->product_title }} - {{ $price->listPrice()->gross() }}</li>\r\n    @endforeach\r\n</ul>\r\n```\r\n\r\n> 注意：使用价格 API 时，Paddle 仅允许将优惠券应用于一次性购买的产品，而不允许应用于订阅计划。\r\n\r\n<a name=\"customers\"></a>\r\n## 客户\r\n\r\n<a name=\"customer-defaults\"></a>\r\n### 客户默认值\r\n\r\nCashier 允许你在创建支付链接时为你的客户定义一些默认值。 设置这些默认值允许你预先填写客户的电子邮件地址、国家 / 地区和邮政编码，以便他们可以立即转到结帐小部件的付款部分。 你可以通过覆盖计费模型上的以下方法来设置这些默认值：\r\n\r\n    /**\r\n     * 获取客户的电子邮件地址以与 Paddle 关联。\r\n     */\r\n    public function paddleEmail(): string|null\r\n    {\r\n        return $this->email;\r\n    }\r\n\r\n    /**\r\n     * 获取客户的国家与 Paddle 关联。\r\n     *\r\n     * 这需要一个 2 个字母的代码。 有关支持的国家 / 地区，请参阅以下链接。\r\n     *\r\n     * @link https://developer.paddle.com/reference/platform-parameters/supported-countries\r\n     */\r\n    public function paddleCountry(): string|null\r\n    {\r\n        // ...\r\n    }\r\n\r\n    /**\r\n     * 获取客户的邮政编码以与 Paddle 关联。\r\n     *\r\n     * 有关需要此功能的国家 / 地区，请参阅以下链接。\r\n     *\r\n     * @link https://developer.paddle.com/reference/platform-parameters/supported-countries#countries-requiring-postcode\r\n     */\r\n    public function paddlePostcode(): string|null\r\n    {\r\n        // ...\r\n    }\r\n\r\n\n\n这些默认值将用于 Cashier 中生成 [支付链接](#pay-links) 的每个操作。\r\n\r\n<a name=\"subscriptions\"></a>\r\n## 订阅\r\n\r\n<a name=\"creating-subscriptions\"></a>\r\n### 创建订阅\r\n\r\n要创建订阅，请首先检索计费模型的实例，该实例通常是 `App\\Models\\User` 的实例。检索模型实例后，你可以使用 `newSubscription` 方法来创建模型的订阅支付链接：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/subscribe', function (Request $request) {\r\n        $payLink = $request->user()->newSubscription('default', $premium = 12345)\r\n            ->returnTo(route('home'))\r\n            ->create();\r\n\r\n        return view('billing', ['payLink' => $payLink]);\r\n    });\r\n\r\n传递给 `newSubscription` 方法的第一个参数应该是订阅的名称。 如果你的应用只提供一个订阅，你可以将其称为 `default` 或 `primary`。第二个参数是用户订阅的特定计划。 该值应对应于 Paddle 中的计划标识符。`returnTo` 方法接受一个 URL，你的用户在成功完成结帐后将被重定向到该 URL。\r\n\r\n`create` 方法将创建一个支付链接，你可以使用它来生成一个支付按钮。可以使用 Cashier Paddle 附带的 `paddle-button` [Blade 组件](/docs/laravel/10.x/blade#components) 生成支付按钮：\r\n\r\n```blade\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\">\r\n    订阅\r\n</x-paddle-button>\r\n```\r\n\r\n\n\n用户完成结帐后，将从 Paddle 发送一个 `subscription_created` webhook。 Cashier 将收到此 webhook 并为你的客户设置订阅。为了确保你的应用程序正确接收和处理所有 webhook，请确保你正确地 [设置 webhook 处理](#handling-paddle-webhooks)。\r\n\r\n<a name=\"additional-details\"></a>\r\n#### 额外细节\r\n\r\n如果你想指定额外的客户或订阅详细信息，你可以通过将它们作为键 / 值对数组传递给 `create` 方法来实现。要了解有关 Paddle 支持的其他字段的更多信息，请查看 Paddle 关于 [生成支付链接](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink) 的文档：\r\n\r\n    $payLink = $user->newSubscription('default', $monthly = 12345)\r\n        ->returnTo(route('home'))\r\n        ->create([\r\n            'vat_number' => $vatNumber,\r\n        ]);\r\n\r\n<a name=\"subscriptions-coupons\"></a>\r\n#### 优惠券\r\n\r\n如果你想在创建订阅时申请优惠券，你可以使用 `withCoupon` 方法：\r\n\r\n    $payLink = $user->newSubscription('default', $monthly = 12345)\r\n        ->returnTo(route('home'))\r\n        ->withCoupon('code')\r\n        ->create();\r\n\r\n<a name=\"metadata\"></a>\r\n#### 元数据\r\n\r\n你还可以使用 `withMetadata` 方法传递元数据数组：\r\n\r\n    $payLink = $user->newSubscription('default', $monthly = 12345)\r\n        ->returnTo(route('home'))\r\n        ->withMetadata(['key' => 'value'])\r\n        ->create();\r\n\r\n> 注意：提供元数据时，请避免使用 `subscription_name` 作为元数据键。 此密钥保留供 Cashier 内部使用。\r\n\r\n<a name=\"checking-subscription-status\"></a>\r\n### 检查订阅状态\r\n\r\n一旦用户订阅了你的应用程序，你就可以使用各种便利的方法检查他们的订阅状态。 首先，如果用户有活动订阅，`subscribed` 方法返回 `true`，即使订阅当前处于试用期：\r\n\r\n    if ($user->subscribed('default')) {\r\n        // ...\r\n    }\r\n\r\n\n\n该 `subscribed` 方法也非常适合 [路由中间件](/docs/laravel/10.x/middleware)，允许你根据用户的订阅状态来过滤对路由和控制器的访问：\r\n\r\n    <?php\r\n\r\n    namespace App\\Http\\Middleware;\r\n\r\n    use Closure;\r\n    use Illuminate\\Http\\Request;\r\n    use Symfony\\Component\\HttpFoundation\\Response;\r\n\r\n    class EnsureUserIsSubscribed\r\n    {\r\n        /**\r\n         * 处理请求。\r\n         *\r\n         * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n         */\r\n        public function handle(Request $request, Closure $next): Response\r\n        {\r\n            if ($request->user() && ! $request->user()->subscribed('default')) {\r\n                // 该用户不是付费用户。。。\r\n                return redirect('billing');\r\n            }\r\n\r\n            return $next($request);\r\n        }\r\n    }\r\n\r\n如果你想确定用户是否仍在试用期内，你可以使用 `onTrial` 方法。这个方法用于确定是否应向用户显示他们仍在试用期的警告：\r\n\r\n    if ($user->subscription('default')->onTrial()) {\r\n        // ...\r\n    }\r\n\r\n该 `subscribedToPlan` 方法可用于根据给定的 Paddle 计划 ID 来确定用户是否订阅了给定的计划。 在这个例子中，我们将确定用户的 `default` 订阅是否订阅了包月计划：\r\n\r\n    if ($user->subscribedToPlan($monthly = 12345, 'default')) {\r\n        // ...\r\n    }\r\n\r\n通过将数组传递给 `subscribedToPlan` 方法，你可以确定用户的 `default` 订阅是订阅月度计划或是年度计划：\r\n\r\n    if ($user->subscribedToPlan([$monthly = 12345, $yearly = 54321], 'default')) {\r\n        // ...\r\n    }\r\n\r\n该 `recurring` 方法可用于确定用户当前是否已订阅并且不是处于试用期：\r\n\r\n    if ($user->subscription('default')->recurring()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"cancelled-subscription-status\"></a>\r\n\n\n#### 已取消订阅状态\r\n\r\n要确定用户是否曾经是订阅者但现在已取消订阅，你可以使用 `cancelled` 方法：\r\n\r\n    if ($user->subscription('default')->cancelled()) {\r\n        // ...\r\n    }\r\n\r\n你还可以确定用户是否已取消订阅，但在订阅完全到期之前会处于 「宽限期」。 例如，如果用户在 3 月 5 日取消原定于 3 月 10 日到期的订阅，则用户将处于「宽限期」，直到 3 月 10 日。 请注意，在此期间 `subscribed` 方法仍然返回 `true`：\r\n\r\n    if ($user->subscription('default')->onGracePeriod()) {\r\n        // ...\r\n    }\r\n\r\n确定用户是否已取消订阅并且不处于「宽限期」内，你可以使用 `ended` 方法：\r\n\r\n    if ($user->subscription('default')->ended()) {\r\n        // ...\r\n    }\r\n\r\n<a name=\"past-due-status\"></a>\r\n#### 逾期状态\r\n\r\n如果订阅的付款失败，它将被标记为 `past_due`。当你的订阅处于此状态时，在客户更新其付款信息之前，它不会处于活动状态。你可以使用订阅实例上的 `pastDue` 方法来确定订阅是否过期：\r\n\r\n    if ($user->subscription('default')->pastDue()) {\r\n        // ...\r\n    }\r\n\r\n当订阅过期时，你应该指示用户 [更新他们的付款信息](#updating-payment-information)。 你可以在 [Paddle 订阅设置](https://vendors.paddle.com/subscription-settings) 中配置逾期订阅的处理方式。\r\n\r\n如果你希望订阅在 `past_due` 时仍被视为活动，你可以使用 Cashier 提供的 `keepPastDueSubscriptionsActive` 方法。通常，此方法应在你的 `AppServiceProvider` 的 `register` 方法中调用：\r\n\r\n    use Laravel\\Paddle\\Cashier;\r\n\r\n    /**\r\n     * 注册应用服务。\r\n     */\r\n    public function register(): void\r\n    {\r\n        Cashier::keepPastDueSubscriptionsActive();\r\n    }\r\n\r\n> 注意：当订阅处于 `past_due` 状态时，在付款信息更新之前无法更改。 因此，当订阅处于 `past_due` 状态时，`swap` 和 `updateQuantity` 方法将抛出异常。\r\n\r\n\n\n<a name=\"subscription-scopes\"></a>\r\n#### 订阅范围\r\n\r\n大多数订阅状态也可用作查询范围，以便你可以轻松查询数据库中处于给定状态的订阅：\r\n\r\n    // 获取所有有效订阅。。。\r\n    $subscriptions = Subscription::query()->active()->get();\r\n\r\n    // 获取给定用户的所有已取消订阅。。。\r\n    $subscriptions = $user->subscriptions()->cancelled()->get();\r\n\r\n可用范围的完整列表如下：\r\n\r\n    Subscription::query()->active();\r\n    Subscription::query()->onTrial();\r\n    Subscription::query()->notOnTrial();\r\n    Subscription::query()->pastDue();\r\n    Subscription::query()->recurring();\r\n    Subscription::query()->ended();\r\n    Subscription::query()->paused();\r\n    Subscription::query()->notPaused();\r\n    Subscription::query()->onPausedGracePeriod();\r\n    Subscription::query()->notOnPausedGracePeriod();\r\n    Subscription::query()->cancelled();\r\n    Subscription::query()->notCancelled();\r\n    Subscription::query()->onGracePeriod();\r\n    Subscription::query()->notOnGracePeriod();\r\n\r\n<a name=\"subscription-single-charges\"></a>\r\n### 订阅单次收费\r\n\r\n订阅单次收费允许你在订阅的基础上向订阅者收取一次性费用：\r\n\r\n    $response = $user->subscription('default')->charge(12.99, 'Support Add-on');\r\n\r\n与 [单一费用](#single-charges) 相比，此方法将立即向客户存储的订阅付款方式收费。 收费金额应始终以订阅的货币定义。\r\n\r\n<a name=\"updating-payment-information\"></a>\r\n### 更新付款信息\r\n\r\nPaddle 始终为每个订阅保存一种付款方式。 如果要更新订阅的默认付款方式，则应首先使用订阅模型上的 `updateUrl` 方法生成订阅 「更新 URL」：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $updateUrl = $user->subscription('default')->updateUrl();\r\n\r\n然后，你可以将生成的 URL 与 Cashier 提供的 `paddle-button` Blade 组件结合使用，以允许用户启动 Paddle 小部件并更新他们的付款信息：\r\n\r\n```html\r\n<x-paddle-button :url=\"$updateUrl\" class=\"px-8 py-4\">\r\n    更新付款信息\r\n</x-paddle-button>\r\n```\r\n\r\n\n\n当用户更新完他们的信息后，Paddle 将发送一个 `subscription_updated` webhook，订阅详细信息将在你的应用数据库中更新。\r\n\r\n<a name=\"changing-plans\"></a>\r\n### 改变计划\r\n\r\n用户订阅你的应用程序后，他们可能偶尔想要更改为新的订阅计划。 要为用户更新订阅计划时，你应该将 Paddle 计划的标识符传递给订阅的 `swap` 方法：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swap($premium = 34567);\r\n\r\n如果你想变更计划并立即为用户开具发票，而不是等待他们的下一个计费周期，你可以使用 `swapAndInvoice` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->swapAndInvoice($premium = 34567);\r\n\r\n> 注意：试用活动期间不能变更计划。有关此限制的更多信息，请参阅 [Paddle 文档](https://developer.paddle.com/api-reference/subscription-api/users/updateuser#usage-notes)。\r\n\r\n<a name=\"prorations\"></a>\r\n#### 按比例分配\r\n\r\n默认情况下，Paddle 在计划变更时按比例分配费用。 `noProrate` 方法可用于在不按比例分配费用的情况下更新订阅：\r\n\r\n    $user->subscription('default')->noProrate()->swap($premium = 34567);\r\n\r\n<a name=\"subscription-quantity\"></a>\r\n### 订阅数量\r\n\r\n有时订阅会受到 「数量」的影响。例如，项目管理应用可能对每个项目每月收费 10 美元。 要增加或减少订阅数量，请使用 `incrementQuantity` 和 `decrementQuantity` 方法：\r\n\r\n    $user = User::find(1);\r\n\r\n    $user->subscription('default')->incrementQuantity();\r\n\r\n    // 订阅增加 5 个。。。\r\n    $user->subscription('default')->incrementQuantity(5);\r\n\r\n    $user->subscription('default')->decrementQuantity();\r\n\r\n    // 订阅减少 5 个。。。\r\n    $user->subscription('default')->decrementQuantity(5);\r\n\r\n\n\n或者，你以使用 `updateQuantity` 方法设置特定数量：\r\n\r\n    $user->subscription('default')->updateQuantity(10);\r\n\r\n该 `noProrate` 方法可用于更新订阅数量而不按比例分配费用：\r\n\r\n    $user->subscription('default')->noProrate()->updateQuantity(10);\r\n\r\n<a name=\"subscription-modifiers\"></a>\r\n### 订阅修改器\r\n\r\n订阅修改器允许你实施 [按量计费](https://developer.paddle.com/guides/how-tos/subscriptions/metered-billing#using-subscription-price-modifiers) 或使用附加组件扩展订阅。\r\n\r\n例如，你可能想为标准订阅提供 「高级支持」附加组件。 你可以像这样创建这个修改器：\r\n\r\n    $modifier = $user->subscription('default')->newModifier(12.99)->create();\r\n\r\nThe example above will add a $12.99 add-on to the subscription. By default, this charge will recur on every interval you have configured for the subscription. If you would like, you can add a readable description to the modifier using the modifier's `description` method:\r\n上例将向订阅添加 $12.99 的附加组件。默认情况下，此费用将在你为订阅配置的每个时间周期内重复收取。 如果你愿意，可以使用修改器的 `description` 方法向修改器添加可读的描述：\r\n\r\n    $modifier = $user->subscription('default')->newModifier(12.99)\r\n        ->description('Premium Support')\r\n        ->create();\r\n\r\n为了说明如何使用修改器实现计量计费，假设你的应用程序要对用户发送的每条 SMS 消息收费。首先，你应该在 Paddle 仪表板中创建一个 $0 的计划。 用户订阅此计划后，你可以向订阅添加代表每个单独费用的修改器：\r\n\r\n    $modifier = $user->subscription('default')->newModifier(0.99)\r\n        ->description('New text message')\r\n        ->oneTime()\r\n        ->create();\r\n\r\n如你所见，我们在创建此调节器时调用了 `oneTime` 方法。此方法将确保修改器只收费一次，并且不会在每个计费周期重复。\r\n\r\n<a name=\"retrieving-modifiers\"></a>\r\n#### 检索修改器\r\n\r\n\n\n你可以通过 `modifiers` 方法检索订阅的所有修改器列表：\r\n\r\n    $modifiers = $user->subscription('default')->modifiers();\r\n\r\n    foreach ($modifiers as $modifier) {\r\n        $modifier->amount(); // $0.99\r\n        $modifier->description; // 新的短信。\r\n    }\r\n\r\n<a name=\"deleting-modifiers\"></a>\r\n#### 删除修改器\r\n\r\n修改器可以通过调用 `Laravel\\Paddle\\Modifier` 实例上的 `delete` 方法来删除：\r\n\r\n    $modifier->delete();\r\n\r\n<a name=\"multiple-subscriptions\"></a>\r\n### 多个订阅\r\n\r\nPaddle 允许你的客户同时拥有多个订阅。例如，你可能经营一家健身房，提供游泳订阅和举重订阅，每个订阅可能有不同的定价。当然，客户应该能够订阅其中一项或两项计划。\r\n\r\n当你的应用程序创建订阅时，你可以向 `newSubscription` 方法提供订阅的名称。该名称可以是表示用户正在发起的订阅类型的任何字符串：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::post('/swimming/subscribe', function (Request $request) {\r\n        $request->user()\r\n            ->newSubscription('swimming', $swimmingMonthly = 12345)\r\n            ->create($request->paymentMethodId);\r\n\r\n        // ...\r\n    });\r\n\r\n在本例中，我们为客户发起了每月一次的游泳订阅。然而，他们可能想在以后换成每年订阅一次。当调整客户的订阅时，我们可以简单地交换`游泳`订阅的价格：\r\n\r\n    $user->subscription('swimming')->swap($swimmingYearly = 34567);\r\n\r\n当然，你也可以完全取消订阅：\r\n\r\n    $user->subscription('swimming')->cancel();\r\n\r\n<a name=\"pausing-subscriptions\"></a>\r\n### 暂停订阅\r\n\r\n要暂停订阅，请调用用户订阅的 `pause` 方法：\r\n\r\n    $user->subscription('default')->pause();\r\n\r\n当订阅暂停时，Cashier 将自动在你的数据库中设置 `paused_from` 列。此列用于确定 `paused` 方法何时应该开始返回 `true`。例如，如果客户在 3 月 1 日暂停订阅，但该订阅直到 3 月 5 日才计划重复发生，则 `paused` 方法将继续返回 `false` ，直到 3 月 5 日。这样做是因为用户可以继续使用应用程序，直到他们的计费周期结束。\r\n\n\n你可以使用 `onPausedGracePeriod` 方法确定用户是否已暂停订阅但仍处于 「宽限期」：\r\n\r\n    if ($user->subscription('default')->onPausedGracePeriod()) {\r\n        // ...\r\n    }\r\n\r\n要恢复暂停的订阅，你可以调用用户订阅的 `unpause` 方法：\r\n\r\n    $user->subscription('default')->unpause();\r\n\r\n> 注意：订阅暂停时无法修改。 如果你想切换到不同的计划或更新数量，你必须先恢复订阅。\r\n\r\n<a name=\"cancelling-subscriptions\"></a>\r\n### 取消订阅\r\n\r\n要取消订阅，请调用用户订阅的 `cancel` 方法：\r\n\r\n    $user->subscription('default')->cancel();\r\n\r\n当订阅被取消时，Cashier 将自动在你的数据库中设置 `ends_at` 列。 此列用于确定 `subscribed` 方法应该何时开始返回 `false`。例如，如果客户在 3 月 1 日取消订阅，但订阅计划在 3 月 5 日之前结束，则 `subscribed` 方法将在 3 月 5 日之前继续返回 `true`。这样做是因为通常允许用户继续使用应用程序，直到他们的计费周期结束。\r\n\r\n你可以使用 `onGracePeriod` 方法确定用户是否已取消订阅但仍处于「宽限期」：\r\n\r\n    if ($user->subscription('default')->onGracePeriod()) {\r\n        // ...\r\n    }\r\n\r\n如果你想立即取消订阅，你可以调用用户订阅的 `cancelNow` 方法：\r\n\r\n    $user->subscription('default')->cancelNow();\r\n\r\n> 注意：取消后无法恢复 Paddle 的订阅。 如果你的客户希望恢复订阅，则他们必须重新订阅。\r\n\r\n\n\n<a name=\"subscription-trials\"></a>\r\n## 订阅试用\r\n\r\n<a name=\"with-payment-method-up-front\"></a>\r\n### 预先收集付费方式\r\n\r\n> 注意：在预先试用和收集付款方式详细信息时，Paddle 会阻止任何订阅更改，例如更换计划或更新数量。 如果你想允许客户在试用期间更换计划，则必须取消并重新创建订阅。\r\n\r\n如果你想为你的客户提供试用期，同时仍然预先收集付款方式信息，你应该在创建订阅付款链接时使用 `trialDays` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/subscribe', function (Request $request) {\r\n        $payLink = $request->user()->newSubscription('default', $monthly = 12345)\r\n                    ->returnTo(route('home'))\r\n                    ->trialDays(10)\r\n                    ->create();\r\n\r\n        return view('billing', ['payLink' => $payLink]);\r\n    });\r\n\r\n此方法将在你的应用数据库中的订阅记录上设置试用期结束日期，并指示 Paddle 在此日期之后才开始向客户收费。\r\n\r\n> 注意：如果客户的订阅未在试用结束日期之前取消，他们将在试用到期后立即收费，因此你务必将试用结束日期通知你的用户。\r\n\r\n你可以使用用户实例的 `onTrial` 方法或订阅实例的 `onTrial` 方法来确定用户是否在试用期内。 下面的两个例子是一样的：\r\n\r\n    if ($user->onTrial('default')) {\r\n        // ...\r\n    }\r\n\r\n    if ($user->subscription('default')->onTrial()) {\r\n        // ...\r\n    }\r\n\r\n要确定试用期是否已过期，你可以使用 `hasExpiredTrial` 方法：\r\n\r\n    if ($user->hasExpiredTrial('default')) {\r\n        // ...\r\n    }\r\n\r\n    if ($user->subscription('default')->hasExpiredTrial()) {\r\n        // ...\r\n    }\r\n\r\n\n\n<a name=\"defining-trial-days-in-paddle-cashier\"></a>\r\n#### 在 Paddle / Cashier 中定义试用天数\r\n\r\n你可以选择在 Paddle 仪表板中定义你的计划接收的试用天数，或者始终使用 Cashier 明确传递它们。如果你选择在 Paddle 中定义计划的试用天数，你应该知道新订阅，包括过去订阅过的客户的新订阅，将始终获得试用期，除非你明确调用 `trialDays(0)` 方法。\r\n\r\n<a name=\"without-payment-method-up-front\"></a>\r\n### 未预先收集付款方式\r\n\r\n如果你想提供试用期而不预先收集用户的付款方式信息，你可以将附加到你的用户的客户记录上的 `trial_ends_at` 列设置为你想要的试用结束日期。这通常在用户注册期间完成：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::create([\r\n        // ...\r\n    ]);\r\n\r\n    $user->createAsCustomer([\r\n        'trial_ends_at' => now()->addDays(10)\r\n    ]);\r\n\r\nCashier 将这种类型的试用称为「通用试用」，因为它不附属于任何现有订阅。如果当前日期未超过 `trial_ends_at` 的值，则 `User` 实例上的 `onTrial` 方法将返回 `true`：\r\n\r\n    if ($user->onTrial()) {\r\n        // 用户在试用期内。。。\r\n    }\r\n\r\n一旦你准备好为用户创建一个实际的订阅，你可以像往常一样使用 `newSubscription` 方法：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/user/subscribe', function (Request $request) {\r\n        $payLink = $user->newSubscription('default', $monthly = 12345)\r\n            ->returnTo(route('home'))\r\n            ->create();\r\n\r\n        return view('billing', ['payLink' => $payLink]);\r\n    });\r\n\r\n要检索用户的试用结束日期，你可以使用 `trialEndsAt` 方法。如果用户正在试用，则此方法将返回一个 Carbon 日期实例，否则将返回 `null` 。如果你想获取特定订阅而不是默认订阅的试用结束日期，你还可以传递一个可选的订阅名称参数：\r\n\r\n    if ($user->onTrial()) {\r\n        $trialEndsAt = $user->trialEndsAt('main');\r\n    }\r\n\r\n\n\n如果你希望明确知道用户处于 「通用」试用期内并且尚未创建实际订阅，则可以使用 `onGenericTrial` 方法：\r\n\r\n    if ($user->onGenericTrial()) {\r\n        // 用户在通用试用期内。。。\r\n    }\r\n\r\n> 注意：创建 Paddle 订阅后，无法延长或修改其试用期。\r\n\r\n<a name=\"handling-paddle-webhooks\"></a>\r\n## 处理 Paddle Webhooks\r\n\r\nPaddle 可以通过 webhook 通知你的应用各种事件。默认情况下，指向 Cashier 的 webhook 控制器的路由由 Cashier 服务提供商注册。\r\n该控制器将处理所有传入的 webhook 请求。\r\n\r\n默认情况下，此控制器将自动处理付费失败过多的取消订阅（[由你的 Paddle 订阅设置定义](https://vendors.paddle.com/subscription-settings)）、订阅更新和付款方式更改；但是，我们很快就会发现，你可以扩展这个控制器来处理你喜欢的任何 Paddle webhook 事件。\r\n\r\n为确保你的应用可以处理 Paddle webhooks，请务必 [在 Paddle 控制面板中配置 webhook URL](https://vendors.paddle.com/alerts-webhooks)。默认情况下，Cashier 的 webhook 控制器响应 `/paddle/webhook` URL 路径。你应该在 Paddle 控制面板中启用的所有 webhook 的完整列表是：\r\n\r\n- 订阅创建\r\n- 订阅更新\r\n- 订阅取消\r\n- 付款成功\r\n- 订阅付款成功\r\n\r\n> 注意：确保使用 Cashier 包含的 [webhook 签名验证](/docs/laravel/10.x/cashier-paddle#verifying-webhook-signatures) 中间件保护传入请求。\r\n\r\n<a name=\"webhooks-csrf-protection\"></a>\r\n#### Webhook 和 CSRF 保护\r\n\r\n由于 Paddle webhooks 需要绕过 Laravel 的 [CSRF 保护](/docs/laravel/10.x/csrf)，请务必在你的 `App\\Http\\Middleware\\VerifyCsrfToken` 中间件中将 URI 作为例外列出或列出外面的路由 `web` 中间件组的：\r\n\r\n    protected $except = [\r\n        'paddle/*',\r\n    ];\r\n\r\n\n\n<a name=\"webhooks-local-development\"></a>\r\n#### Webhook 和本地开发\r\n\r\n为了让 Paddle 能够在本地开发期间发送你的应用程序 webhook，你需要通过站点共享服务公开你的应用程序，例如 [Ngrok](https://ngrok.com/) 或 [Expose](https://expose.dev/docs/introduction)。如果你使用 [Laravel Sail](/docs/laravel/10.x/sail) 在本地开发应用程序，你可以使用 Sail 的 [站点共享命令](/docs/laravel/10.x/sail#sharing-your-site)。\r\n\r\n<a name=\"defining-webhook-event-handlers\"></a>\r\n### 定义 webhook 事件处理程序\r\n\r\nCashier 会自动处理因收费失败和其他常见的 paddle webhook 取消订阅。 但是，如果你有其他想要处理的 webhook 事件，你可以通过监听 Cashier 调度的以下事件来实现：\r\n\r\n- `Laravel\\Paddle\\Events\\WebhookReceived`\r\n- `Laravel\\Paddle\\Events\\WebhookHandled`\r\n\r\n这两个事件都包含 Paddle webhook 的完整负载。例如，如果你想处理 `invoice.payment_succeeded` webhook，你可以注册一个 [listener](/docs/laravel/10.x/events#defining-listeners) 来处理事件：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Laravel\\Paddle\\Events\\WebhookReceived;\r\n\r\n    class PaddleEventListener\r\n    {\r\n        /**\r\n         * 处理收到的 Paddle webhook。\r\n         */\r\n        public function handle(WebhookReceived $event): void\r\n        {\r\n            if ($event->payload['alert_name'] === 'payment_succeeded') {\r\n                // 处理传入事件。。。\r\n            }\r\n        }\r\n    }\r\n\r\n一旦你的监听器被定义，你可以在你的应用程序的 `EventServiceProvider` 中注册它：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Listeners\\PaddleEventListener;\r\n    use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\n    use Laravel\\Paddle\\Events\\WebhookReceived;\r\n\r\n    class EventServiceProvider extends ServiceProvider\r\n    {\r\n        protected $listen = [\r\n            WebhookReceived::class => [\r\n                PaddleEventListener::class,\r\n            ],\r\n        ];\r\n    }\r\n\r\nCashier 还会发出专用于接收到的 webhook 类型的事件。除了来自 Paddle 的完整有效负载之外，它们还包含用于处理 webhook 的相关模型，例如计费模型、订阅或收据：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- `Laravel\\Paddle\\Events\\PaymentSucceeded`\r\n- `Laravel\\Paddle\\Events\\SubscriptionPaymentSucceeded`\r\n- `Laravel\\Paddle\\Events\\SubscriptionCreated`\r\n- `Laravel\\Paddle\\Events\\SubscriptionUpdated`\r\n- `Laravel\\Paddle\\Events\\SubscriptionCancelled`\r\n\r\n</div>\r\n\r\n\n\n你还可以通过在应用程序的 `.env` 文件中定义 `CASHIER_WEBHOOK` 环境变量来覆盖默认的内置 webhook 路由。此值应该是你的 webhook 路由中的完整 URL，并且需要和你在 Paddle 控制面板中设置的 URL 相匹配：\r\n\r\n```ini\r\nCASHIER_WEBHOOK=https://example.com/my-paddle-webhook-url\r\n```\r\n\r\n<a name=\"verifying-webhook-signatures\"></a>\r\n### 验证 Webhook 签名\r\n\r\n为了保护你的 webhook，你可以使用 [Paddle 的 webhook 签名](https://developer.paddle.com/webhook-reference/verifying-webhooks)。 为方便起见，Cashier 自动包含一个中间件，用于验证传入的 Paddle webhook 请求是否有效。\r\n\r\n要启用 webhook 验证，请确保在应用程序的 .env 文件中定义了`PADDLE_PUBLIC_KEY` 环境变量。 可以从你的 Paddle 帐户仪表板中检索公钥。\r\n\r\n<a name=\"single-charges\"></a>\r\n## 一次性收费\r\n\r\n<a name=\"simple-charge\"></a>\r\n### 简单收费\r\n\r\n如果你想对客户进行一次性收费，你可以在可计费模型实例上使用 `charge` 方法来生成收费的支付链接。`charge` 方法接受费用金额（浮点数）作为它的第一个参数和一个费用描述作为它的第二个参数：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/store', function (Request $request) {\r\n        return view('store', [\r\n            'payLink' => $user->charge(12.99, 'Action Figure')\r\n        ]);\r\n    });\r\n\r\n生成支付链接后，你可以使用 Cashier 提供的 `paddle-button` Blade 组件让用户启动 Paddle 小部件并完成收费：\r\n\r\n```blade\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\">\r\n    Buy\r\n</x-paddle-button>\r\n```\r\n\r\n`charge` 方法接受一个数组作为其第三个参数，允许你将任何你希望的选项传递给底层 Paddle 支付链接创建。请查阅 [Paddle 文档](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink) 了解更多关于创建费用时可用的选项：\r\n\r\n    $payLink = $user->charge(12.99, 'Action Figure', [\r\n        'custom_option' => $value,\r\n    ]);\r\n\r\n\n\n费用以 `cashier.currency` 配置选项中指定的货币进行。 默认设置是美元。 你可以通过在应用程序的 `.env` 文件中定义 `CASHIER_CURRENCY` 环境变量来覆盖默认货币：\r\n\r\n```ini\r\nCASHIER_CURRENCY=EUR\r\n```\r\n\r\n你还可以使用 Paddle 的动态定价匹配系统 [覆盖每种货币的价格](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink#price-overrides)。为此，请通过价格数组而不是固定金额：\r\n\r\n    $payLink = $user->charge([\r\n        'USD:19.99',\r\n        'EUR:15.99',\r\n    ], 'Action Figure');\r\n\r\n<a name=\"charging-products\"></a>\r\n### 收费产品\r\n\r\n如果你想对 Paddle 中配置的特定产品进行一次性收费，你可以在计费模型实例上使用 `chargeProduct` 方法来生成付款链接：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/store', function (Request $request) {\r\n        return view('store', [\r\n            'payLink' => $request->user()->chargeProduct($productId = 123)\r\n        ]);\r\n    });\r\n\r\n然后，你可以提供 `paddle-button` 组件的支付链接，以允许用户初始化 Paddle 小部件：\r\n\r\n```blade\r\n<x-paddle-button :url=\"$payLink\" class=\"px-8 py-4\">\r\n    购买\r\n</x-paddle-button>\r\n```\r\n\r\n`chargeProduct` 方法接受一个数组作为其第二个参数，允许你将任何你希望的选项传递给底层 Paddle 支付链接创建。 请查阅 [Paddle 文档](https://developer.paddle.com/api-reference/product-api/pay-links/createpaylink) 关于创建费用时可用的选项：\r\n\r\n    $payLink = $user->chargeProduct($productId, [\r\n        'custom_option' => $value,\r\n    ]);\r\n\r\n<a name=\"refunding-orders\"></a>\r\n### 退款订单\r\n\r\n如果你需要对桨订单进行退款，你可以使用 `refund` 方法。 此方法接受 Paddle 订单 ID 作为其第一个参数。 你可以使用 `receipts` 方法检索给定计费模型的收据：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $receipt = $user->receipts()->first();\r\n\r\n    $refundRequestId = $user->refund($receipt->order_id);\r\n\r\n\n\n你可以选择指定具体的退款金额以及退款原因：\r\n\r\n    $receipt = $user->receipts()->first();\r\n\r\n    $refundRequestId = $user->refund(\r\n        $receipt->order_id, 5.00, 'Unused product time'\r\n    );\r\n\r\n> 技巧：联系 Paddle 支持时，你可以使用 `$refundRequestId` 作为退款参考。\r\n\r\n<a name=\"receipts\"></a>\r\n## 收据\r\n你可以通过 `receipts` 属性轻松检索可计费模型的收据数组：\r\n\r\nuse App\\Models\\User;\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $receipts = $user->receipts;\r\n\r\n在为客户列出收据时，你可以使用收据实例的方法来显示相关的收据信息。 例如，你可能希望在表格中列出每张收据，以便用户轻松下载任何收据：\r\n\r\n```html\r\n<table>\r\n    @foreach ($receipts as $receipt)\r\n        <tr>\r\n            <td>{{ $receipt->paid_at->toFormattedDateString() }}</td>\r\n            <td>{{ $receipt->amount() }}</td>\r\n            <td><a href=\"{{ $receipt->receipt_url }}\" target=\"_blank\">Download</a></td>\r\n        </tr>\r\n    @endforeach\r\n</table>\r\n```\r\n\r\n<a name=\"past-and-upcoming-payments\"></a>\r\n### 过去和未来的付款\r\n\r\n你可以使用 `lastPayment` 和 `nextPayment` 方法来检索和显示客户过去或即将进行的定期订阅付款：\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    $subscription = $user->subscription('default');\r\n\r\n    $lastPayment = $subscription->lastPayment();\r\n    $nextPayment = $subscription->nextPayment();\r\n\r\n这两种方法都会返回一个 `Laravel\\Paddle\\Payment` 的实例； 但是，当计费周期结束时（例如取消订阅时），`nextPayment` 将返回 `null`：\r\n\r\n```blade\r\nNext payment: {{ $nextPayment->amount() }} due on {{ $nextPayment->date()->format('d/m/Y') }}\r\n```\r\n\r\n<a name=\"handling-failed-payments\"></a>\r\n## 处理失败的付款\r\n\r\n订阅支付失败的原因有多种，例如卡过期或卡资金不足。 发生这种情况时，我们建议你让 Paddle 为你处理付款失败。具体来说，你可以在你的 Paddle 仪表板中 [设置 Paddle 的自动计费电子邮件](https://vendors.paddle.com/subscription-settings)\r\n\r\n\r\n\n\n\r\n或者，你可以通过捕获 [`subscription_payment_failed`](https://developer.paddle.com/webhook-reference/subscription-alerts/subscription-payment-failed) webhook 并启用 “订阅付款失败” 来执行更精确的自定义 Paddle 仪表板的 Webhook 设置中的选项：\r\n\r\n    <?php\r\n\r\n    namespace App\\Listeners;\r\n\r\n    use Laravel\\Paddle\\Events\\WebhookReceived;\r\n\r\n    class PaddleEventListener\r\n    {\r\n        /**\r\n         * 处理订阅付款失败。\r\n         */\r\n        public function handle(WebhookReceived $event): void\r\n        {\r\n            if ($event->payload['alert_name'] === 'subscription_payment_failed') {\r\n                // 处理订阅付款失败。。。\r\n            }\r\n        }\r\n    }\r\n\r\n一旦定义了监听器，就得在应用程序的 `EventServiceProvider` 中注册它：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use App\\Listeners\\PaddleEventListener;\r\n    use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\n    use Laravel\\Paddle\\Events\\WebhookReceived;\r\n\r\n    class EventServiceProvider extends ServiceProvider\r\n    {\r\n        protected $listen = [\r\n            WebhookReceived::class => [\r\n                PaddleEventListener::class,\r\n            ],\r\n        ];\r\n    }\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n在测试时，你应该手动测试你的计费流程，以确保你的集成按预期工作。\r\n\r\n对于自动化测试，包括在 CI 环境中执行的测试，你可以使用 [Laravel 的 HTTP 客户端](/docs/laravel/10.x/http-client#testing) 来伪造对 Paddle 的 HTTP 调用。 尽管这不会测试来自 Paddle 的实际响应，但它确实提供了一种无需实际调用 Paddle API 即可测试你应用程序的方法。\n","p":"docs/cashier-paddle.html"},{"t":"envoy (Laravel Envoy)","d":"# Laravel Envoy\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n- [编写任务](#writing-tasks)\r\n    - [定义任务](#defining-tasks)\r\n    - [多服务器](#multiple-servers)\r\n    - [配置](#setup)\r\n    - [变量](#variables)\r\n    - [脚本故事](#stories)\r\n    - [任务钩子](#completion-hooks)\r\n- [运行任务](#running-tasks)\r\n    - [任务确认](#confirming-task-execution)\r\n- [消息通知](#notifications)\r\n    - [Slack](#slack)\r\n    - [Discord](#discord)\r\n    - [Telegram](#telegram)\r\n    - [Microsoft Teams](#microsoft-teams)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Envoy](https://github.com/laravel/envoy) 是一套在远程服务器上执行日常任务的工具。 使用 [Blade](/docs/laravel/10.x/blade) 风格语法，你可以轻松地配置部署任务、Artisan  命令的执行等。目前， Envoy 仅支持 Mac 和 Linux 操作系统。但是， Windows 上可以使用  [WSL2](https://docs.microsoft.com/en-us/windows/wsl/install-win10) 来实现支持。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，运行 Composer 将 Envoy 安装到你的项目中：\r\n\r\n```shell\r\ncomposer require laravel/envoy --dev\r\n```\r\n\r\n安装 Envoy 之后， Envoy 的可执行文件将出现在项目的 `vendor/bin` 目录下：\r\n\r\n```shell\r\nphp vendor/bin/envoy\r\n```\r\n\r\n<a name=\"writing-tasks\"></a>\r\n## 编写任务\r\n\r\n<a name=\"defining-tasks\"></a>\r\n### 定义任务\r\n\r\n任务是 Envoy 的基础构建元素。任务定义了你想在远程服务器上当任务被调用时所执行的 Shell 命令。例如，你定义了一个任务：在队列服务器上执行 `php artisan queue:restart` 命令。\r\n\r\n你所有的 Envoy 任务都应该在项目根目录中的 `Envoy.blade.php` 文件中定义。下面是一个帮助你入门的例子：\r\n\r\n```blade\r\n@servers(['web' => ['user@192.168.1.1'], 'workers' => ['user@192.168.1.2']])\r\n\r\n@task('restart-queues', ['on' => 'workers'])\r\n    cd /home/user/example.com\r\n    php artisan queue:restart\r\n@endtask\r\n```\r\n\r\n正如你所见，在文件顶部定义了一个 `@servers` 数组，使你可以通过任务声明的 `on` 选项引用这些服务器。`@servers` 声明应始终放置在单行中。在你的 `@task` 声明中，你应该放置任务被调用执行时你期望在服务器上运行的 Shell 命令。\r\n\r\n<a name=\"local-tasks\"></a>\r\n#### 本地任务\r\n\r\n你可以通过将服务器的 IP 地址指定为  `127.0.0.1`  来强制脚本在本地运行：\r\n\r\n```blade\r\n@servers(['localhost' => '127.0.0.1'])\r\n```\r\n\r\n<a name=\"importing-envoy-tasks\"></a>\r\n#### 导入 Envoy 任务\r\n\r\n使用 `@import` 指令，你可以从其他的 Envoy 文件导入它们的故事与任务并添加到你的文件中。导入文件后，你可以像定义在自己的 Envoy 文件中一样执行其中包含的任务：\r\n\r\n```blade\r\n@import('vendor/package/Envoy.blade.php')\r\n```\r\n\r\n<a name=\"multiple-servers\"></a>\r\n### 多服务器\r\n\r\nEnvoy 允许你轻松地在多台服务器上运行任务。 首先，在  `@servers` 声明中添加其他服务器。每台服务器都应分配一个唯一的名称。一旦定义了其他服务器，你可以在任务的 `on` 数组中列出每个服务器：\r\n\r\n```blade\r\n@servers(['web-1' => '192.168.1.1', 'web-2' => '192.168.1.2'])\r\n\r\n@task('deploy', ['on' => ['web-1', 'web-2']])\r\n    cd /home/user/example.com\r\n    git pull origin {{ $branch }}\r\n    php artisan migrate --force\r\n@endtask\r\n```\r\n\r\n<a name=\"parallel-execution\"></a>\r\n#### 并行执行\r\n\r\n默认情况下，任务将在每个服务器上串行执行。 换句话说，任务将在第一台服务器上完成运行后，再继续在第二台服务器上执行。如果你想在多个服务器上并行运行任务，请在任务声明中添加 `parallel` 选项：\r\n\r\n```blade\r\n@servers(['web-1' => '192.168.1.1', 'web-2' => '192.168.1.2'])\r\n\r\n@task('deploy', ['on' => ['web-1', 'web-2'], 'parallel' => true])\r\n    cd /home/user/example.com\r\n    git pull origin {{ $branch }}\r\n    php artisan migrate --force\r\n@endtask\r\n```\r\n\r\n\r\n\r\n如你所见，文件顶部定义了一个 `@server` 数组，允许你在任务声明的 `on` 选项中引用这些服务器。`@server` 声明应始终放在一行中。在你的 `@task` 声明中，你应该放置任务被调用执行时你期望在服务器上运行的 Shell 命令。\r\n\r\n<a name=\"local-tasks\"></a>\r\n#### 本地任务\r\n\r\n你可以通过将服务器的 IP 地址指定为 `127.0.0.1` 来强制脚本在本地运行：\r\n\r\n```blade\r\n@servers(['localhost' => '127.0.0.1'])\r\n```\r\n\r\n<a name=\"importing-envoy-tasks\"></a>\r\n#### 导入 Envoy 任务\r\n\r\n使用 `@import` 指令，你可以从其他的 Envoy 文件导入它们的故事与任务并添加到你的文件中。文件导入后，你可以执行他们所定义的任务，就像这些任务是在你的 Envoy 文件中被定义的一样：\r\n\r\n```blade\r\n@import('vendor/package/Envoy.blade.php')\r\n```\r\n\r\n<a name=\"setup\"></a>\r\n### 配置\r\n\r\n有时，你可能需要在执行 Envoy 任务之前执行一些 PHP 代码。你可以使用 `@setup` 指令来定义一段 PHP 代码块，在任务执行之前执行这段代码：\r\n\r\n```php\r\n@setup\r\n    $now = new DateTime;\r\n@endsetup\r\n```\r\n\r\n如果你需要在任务执行之前引入其他的 PHP 文件，你可以在 `Envoy.blade.php` 文件的顶部使用 `@include` 指令：\r\n\r\n```blade\r\n@include('vendor/autoload.php')\r\n\r\n@task('restart-queues')\r\n    # ...\r\n@endtask\r\n```\r\n\r\n<a name=\"variables\"></a>\r\n### 变量\r\n\r\n如果需要的话，你可以在调用 Envoy 任务时通过在命令行中指定参数，将参数传递给 Envoy 任务：\r\n\r\n```shell\r\nphp vendor/bin/envoy run deploy --branch=master\r\n```\r\n\r\n你可以使用 Blade 的「echo」语法访问传入任务中的命令行参数。你也可以在任务中使用 `if` 语句和循环。 例如，在执行 `git pull` 命令之前，我们先验证 `$branch` 变量是否存在：\r\n\r\n```blade\r\n@servers(['web' => ['user@192.168.1.1']])\r\n\r\n@task('deploy', ['on' => 'web'])\r\n    cd /home/user/example.com\r\n\r\n    @if ($branch)\r\n        git pull origin {{ $branch }}\r\n    @endif\r\n\r\n    php artisan migrate --force\r\n@endtask\r\n```\r\n\r\n<a name=\"stories\"></a>\r\n### 故事\r\n\r\n通过「故事」功能，你可以给一组任务起个名字，以便后续调用。例如，一个 `deploy` 故事可以运行 `update-code` 和 `install-dependencies` 等定义好的任务：\r\n\r\n```blade\r\n@servers(['web' => ['user@192.168.1.1']])\r\n\r\n@story('deploy')\r\n    update-code\r\n    install-dependencies\r\n@endstory\r\n\r\n@task('update-code')\r\n    cd /home/user/example.com\r\n    git pull origin master\r\n@endtask\r\n\r\n@task('install-dependencies')\r\n    cd /home/user/example.com\r\n    composer install\r\n@endtask\r\n```\r\n\r\n一旦编写好了故事，你可以像调用任务一样调用它：\r\n\r\n```shell\r\nphp vendor/bin/envoy run deploy\r\n```\r\n\r\n\r\n\r\n<a name=\"completion-hooks\"></a>\r\n### 任务钩子\r\n\r\n当任务和故事脚本运行时，会执行很多钩子。Envoy 支持的钩子类型有`@before`, `@after`, `@error`, `@success`, and `@finished`。 这些钩子中的所有代码都被解释为 PHP 并在本地执行，而不是在你的任务与之交互的远程服务器上执行。\r\n\r\n你可以根据需要定义任意数量的这些。这些钩子将按照它们在您的 Envoy 脚本中出现的顺序执行。\r\n\r\n<a name=\"hook-before\"></a>\r\n#### `@before`\r\n\r\n在每个任务执行之前，Envoy 脚本中注册的所有 `@before` 钩子都会执行。 `@before` 钩子负责接收将要执行的任务的名称：\r\n\r\n```blade\r\n@before\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@endbefore\r\n```\r\n\r\n<a name=\"completion-after\"></a>\r\n#### `@after`\r\n\r\n每次任务执行后，Envoy 脚本中注册的所有 `@after` 钩子都会执行。 `@after` 钩子负责接收已执行任务的名称：\r\n\r\n```blade\r\n@after\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@endafter\r\n```\r\n\r\n<a name=\"completion-error\"></a>\r\n#### `@error`\r\n\r\n在每次任务失败后（以大于 `0` 的状态码退出执行），Envoy 脚本中注册的所有 `@error` 钩子都将执行。 `@error` 钩子负责接收已执行任务的名称：\r\n\r\n```blade\r\n@error\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@enderror\r\n```\r\n\r\n<a name=\"completion-success\"></a>\r\n#### `@success`\r\n\r\n如果所有任务都已正确执行，则 Envoy 脚本中注册的所有 `@success` 钩子都将执行：\r\n\r\n```blade\r\n@success\r\n    // ...\r\n@endsuccess\r\n```\r\n\r\n<a name=\"completion-finished\"></a>\r\n#### `@finished`\r\n\r\n在所有任务都执行完毕后（不管退出状态如何），所有的 `@finished` 钩子都会被执行。 `@finished` 钩子负责接收已完成任务的状态码，它可能是 `null` 或大于或等于 `0` 的 `integer`：\r\n\r\n```blade\r\n@finished\r\n    if ($exitCode > 0) {\r\n        // There were errors in one of the tasks...\r\n    }\r\n@endfinished\r\n```\r\n\r\n\r\n\r\n<a name=\"completion-hooks\"></a>\r\n### 钩子\r\n\r\n当任务和故事运行时，会执行许多钩子。 Envoy 支持的钩子类型有 `@before`、`@after`、`@error`、`@success` 和 `@finished`。这些钩子中的所有代码都被解释为 PHP 并在本地执行，而不是在与你的任务交互的远程服务器上执行。\r\n\r\n你可以根据需要定义任意数量的钩子。 它们将按照它们在你的 Envoy 脚本中出现的顺序执行。\r\n\r\n<a name=\"hook-before\"></a>\r\n#### `@before`\r\n\r\n在每个任务执行之前，将执行在你的 Envoy 脚本中注册的所有 `@before` 钩子。 `@before` 钩子接收将要执行的任务的名称：\r\n\r\n```blade\r\n@before\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@endbefore\r\n```\r\n\r\n<a name=\"completion-after\"></a>\r\n#### `@after`\r\n\r\n每次任务执行后，将执行在你的 Envoy 脚本中注册的所有 `@after` 钩子。 `@after` 钩子接收已执行任务的名称：\r\n\r\n```blade\r\n@after\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@endafter\r\n```\r\n\r\n<a name=\"completion-error\"></a>\r\n#### `@error`\r\n\r\n在每个任务失败后（退出时的状态大于 `0`），在你的 Envoy 脚本中注册的所有 `@error` 钩子都将执行。 `@error` 钩子接收已执行任务的名称：\r\n\r\n```blade\r\n@error\r\n    if ($task === 'deploy') {\r\n        // ...\r\n    }\r\n@enderror\r\n```\r\n\r\n<a name=\"completion-success\"></a>\r\n#### `@success`\r\n\r\n如果所有任务都没有出现错误，那么在你的 Envoy 脚本中注册的所有 `@success` 钩子都将执行：\r\n\r\n```blade\r\n@success\r\n    // ...\r\n@endsuccess\r\n```\r\n\r\n<a name=\"completion-finished\"></a>\r\n#### `@finished`\r\n\r\n在执行完所有任务后（无论退出状态如何），所有的 `@finished` 钩子都将被执行。 `@finished` 钩子接收已完成任务的状态代码，它可以是 `null` 或大于或等于 `0` 的 `integer`：\r\n\r\n```blade\r\n@finished\r\n    if ($exitCode > 0) {\r\n        // There were errors in one of the tasks...\r\n    }\r\n@endfinished\r\n```\r\n\r\n\r\n\r\n<a name=\"running-tasks\"></a>\r\n## 运行任务\r\n\r\n要运行在应用程序的 `Envoy.blade.php` 文件中定义的任务或 story，请执行 Envoy 的 `run` 命令，传递你想要执行的任务或 story 的名称。Envoy 将执行该任务，并在任务运行时显示来自远程服务器的输出：\r\n\r\n```shell\r\nphp vendor/bin/envoy run deploy\r\n```\r\n\r\n<a name=\"confirming-task-execution\"></a>\r\n### 确认任务执行\r\n\r\n如果你想在在服务器上运行给定任务之前进行确认，请将 `confirm` 指令添加到您的任务声明中。此选项特别适用于破坏性操作：\r\n\r\n```blade\r\n@task('deploy', ['on' => 'web', 'confirm' => true])\r\n    cd /home/user/example.com\r\n    git pull origin {{ $branch }}\r\n    php artisan migrate\r\n@endtask\r\n```\r\n\r\n<a name=\"notifications\"></a>\r\n## 通知\r\n\r\n<a name=\"slack\"></a>\r\n### Slack\r\n\r\nEnvoy 支持在每次任务执行后向 [Slack](https://slack.com/) 发送通知。`@slack` 指令接受一个 Slack 钩子 URL 和一个频道/用户名称。您可以通过在 Slack 控制面板中创建 「Incoming WebHooks」 集成来检索您的 webhook URL。\r\n\r\n你应该将整个 webhook URL 作为传递给 `@slack` 指令的第一个参数。`@slack` 指令给出的第二个参数应该是频道名称 (`#channel`) 或用户名称 (`@user`)：\r\n\r\n```blade\r\n@finished\r\n    @slack('webhook-url', '#bots')\r\n@endfinished\r\n```\r\n\r\n默认情况下，Envoy 通知将向通知频道发送一条消息，描述已执行的任务。但是，你可以通过将第三个参数传递给 `@slack` 指令来覆盖此消息，以自定义自己的消息：\r\n\r\n```blade\r\n@finished\r\n    @slack('webhook-url', '#bots', 'Hello, Slack.')\r\n@endfinished\r\n```\r\n\r\n\r\n\r\n<a name=\"discord\"></a>\r\n### Discord\r\n\r\nEnvoy 还支持在每个任务执行后向 [Discord](https://discord.com/) 发送通知。`@discord` 指令接受一个 Discord Webhook URL 和一条消息。您可以在服务器设置中创建「Webhook」，并选择 Webhook 应该发布到哪个频道来检索 Webhook URL。您应该将整个 Webhook URL 传递到 `@discord` 指令中：\r\n```blade\r\n@finished\r\n    @discord('discord-webhook-url')\r\n@endfinished\r\n```\r\n\r\n<a name=\"telegram\"></a>\r\n### Telegram\r\n\r\nEnvoy 还支持在每个任务执行后向 [Telegram](https://telegram.org/) 发送通知。`@telegram` 指令接受一个 Telegram Bot ID 和一个 Chat ID。你可以使用 [BotFather](https://t.me/botfather) 创建一个新的机器人来检索Bot ID。你可以使用 [@username_to_id_bot](https://t.me/username_to_id_bot) 检索有效的 Chat ID。你应该将整个Bot ID和Chat ID传递到 `@telegram` 指令中：\r\n\r\n```blade\r\n@finished\r\n    @telegram('bot-id','chat-id')\r\n@endfinished\r\n```\r\n\r\n<a name=\"microsoft-teams\"></a>\r\n### Microsoft Teams\r\n\r\nEnvoy 还支持在每个任务执行后向 [Microsoft Teams](https://www.microsoft.com/en-us/microsoft-teams) 发送通知。`@microsoftTeams` 指令接受Teams Webhook（必填）、消息、主题颜色（成功、信息、警告、错误）和一组选项。你可以通过创建新的 [incoming webhook](https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/add-incoming-webhook) 来检索Teams Webhook。Teams API 有许多其他属性可以自定义消息框，例如标题、摘要和部分。你可以在 [Microsoft Teams文档](https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/connectors-using?tabs=cURL#example-of-connector-message) 中找到更多信息。你应该将整个Webhook URL 传递到 `@microsoftTeams` 指令中：\r\n\r\n```blade\r\n@finished\r\n    @microsoftTeams('webhook-url')\r\n@endfinished\r\n```\r\n\r\n","p":"docs/envoy.html"},{"t":"fortify (Laravel Fortify)","d":"\n# Laravel Fortify\r\n\r\n- [介绍](#introduction)\r\n    - [Fortify 是什么？](#what-is-fortify)\r\n    - [何时使用 Fortify?](#when-should-i-use-fortify)\r\n- [安装](#installation)\r\n    - [Fortify 服务提供者](#the-fortify-service-provider)\r\n    - [Fortify 功能](#fortify-features)\r\n    - [禁用视图](#disabling-views)\r\n- [认证](#authentication)\r\n    - [自定义用户身份验证](#customizing-user-authentication)\r\n    - [自定义身份验证渠道](#customizing-the-authentication-pipeline)\r\n    - [自定义重定向](#customizing-authentication-redirects)\r\n- [双重认证](#two-factor-authentication)\r\n    - [启用双重认证](#enabling-two-factor-authentication)\r\n    - [使用双重认证](#authenticating-with-two-factor-authentication)\r\n    - [禁用双重认证](#disabling-two-factor-authentication)\r\n- [注册](#registration)\r\n    - [自定义注册](#customizing-registration)\r\n- [重置密码](#password-reset)\r\n    - [请求密码重置链接](#requesting-a-password-reset-link)\r\n    - [重置密码](#resetting-the-password)\r\n    - [自定义重置密码](#customizing-password-resets)\r\n- [邮件认证](#email-verification)\r\n    - [保护路由](#protecting-routes)\r\n- [确认密码](#password-confirmation)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Fortify](https://github.com/laravel/fortify) 是一个在Laravel中与前端无关的身份认证后端实现。 Fortify 注册了所有实现 Laravel 身份验证功能所需的路由和控制器, 包括登录、注册、重置密码、邮件验证等。安装 Fortify 后，你可以运行 Artisan 命令 `route:list` 来查看 Fortify 已注册的路由。\r\n\r\n由于 Fortify 不提供其自己的用户界面，因此它应该与你自己的用户界面配对，该用户界面向其注册的路由发出请求。在本文档的其余部分中，我们将进一步讨论如何向这些路由发出请求。\r\n\r\n> **提示**  \r\n> 请记住， Fortify 是一个软件包，旨在使你能够快速开始实现 Laravel 的身份验证功能。 **你并非一定要使用它。**  你始终可以按照以下说明中提供的文档，自由地与 Laravel 的身份认证服务进行交互， [用户认证](/docs/laravel/10.x/authentication)， [重置密码](/docs/laravel/10.x/passwords) 和  [邮箱认证](/docs/laravel/10.x/verification) 文档。\r\n\r\n\n\n<a name=\"what-is-fortify\"></a>\r\n### Fortify 是什么？\r\n\r\n如上所述，Laravel Fortify 是一个与前端无关的身份认证后端实现，Fortify 注册了所有实现 Laravel 身份验证功能所需的路由和控制器，包括登录，注册，重置密码，邮件认证等。\r\n\r\n**你不必使用 Fortify，也可以使用 Laravel 的身份认证功能。** 你始终可以按照 [用户认证](/docs/laravel/10.x/authentication)，[重置密码](/docs/laravel/10.x/passwords) 和 [邮箱认证](/docs/laravel/10.x/verification) 文档中提供的文档来手动与 Laravel 的身份验证服务进行交互。\r\n\r\n如果你是一名新手，在使用 Laravel Fortify 之前不妨尝试使用 [Laravel Breeze](/docs/laravel/10.x/starter-kits) 应用入门套件。Laravel Breeze 为你的应用提供身份认证支架，其中包括使用 [Tailwind CSS](https://tailwindcss.com)。与 Fortify 不同，Breeze 将其路由和控制器直接发布到你的应用程序中。这使你可以学习并熟悉 Laravel 的身份认证功能，然后再允许 Laravel Fortify 为你实现这些功能。\r\n\r\nLaravel Fortify 本质上是采用了 Laravel Breeze 的路由和控制器，且提供了不包含用户界面的扩展。这样，你可以快速搭建应用程序身份认证层的后端实现，而不必依赖于任何特定的前端实现。\r\n\r\n<a name=\"when-should-i-use-fortify\"></a>\r\n### 何时使用 Fortify？\r\n\r\n你可能想知道何时使用 Laravel Fortify。首先，如果你正在使用 Laravel 的 [应用入门套件](/docs/laravel/10.x/starter-kits)，你不需要安装 Laravel Fortify，因为它已经提供了完整的身份认证实现。\r\n\r\n\n\n如果你不使用应用入门套件，并且你的应用需要身份认证功能，则有两个选择：手动实现应用的身份认证功能或使用由 Laravel Fortify 提供这些功能的后端实现。\r\n\r\n如果你选择安装 Fortify，你的用户界面将向 Fortify 的身份验证路由发出请求，本文档中对此进行了详细介绍，以便对用户进行身份认证和注册。\r\n\r\n如果你选择手动与 Laravel 的身份认证服务进行交互而不是使用 Fortify，可以按照 [用户认证](/docs/laravel/10.x/authentication)，[重置密码](/docs/laravel/10.x/passwords) 和 [邮箱认证](/docs/laravel/10.x/verification) 文档中提供的说明进行操作。\r\n\r\n<a name=\"laravel-fortify-and-laravel-sanctum\"></a>\r\n#### Laravel Fortify & Laravel Sanctum\r\n\r\n一些开发人员对 [Laravel Sanctum](/docs/laravel/10.x/sanctum) 和 Laravel Fortify 两者之间的区别感到困惑。由于这两个软件包解决了两个不同但相关的问题，因此 Laravel Fortify 和 Laravel Sanctum 并非互斥或竞争的软件包。\r\n\r\nLaravel Sanctum 只关心管理 API 令牌和使用会话 cookie 或令牌来认证现有用户。Sanctum 不提供任何处理用户注册，重置密码等相关的路由。\r\n\r\n如果你尝试为提供 API 或用作单页应用的后端的应用手动构建身份认证层，那么完全有可能同时使用 Laravel Fortify（用于用户注册，重置密码等）和 Laravel Sanctum（API 令牌管理，会话身份认证）。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，使用 Composer 软件包管理器安装 Fortify：\r\n\r\n```shell\r\ncomposer require laravel/fortify\r\n```\r\n\r\n\n\n下一步，使用 `vendor:publish` 命令来发布 Fortify 的资源：\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Fortify\\FortifyServiceProvider\"\r\n```\r\n\r\n该命令会将 Fortify 的行为类发布到你的 `app/Actions` 目录，如果该目录不存在，则会创建该目录。此外，还将发布 Fortify 的配置（`FortifyServiceProvider`）和迁移文件。\r\n\r\n下一步，你应该迁移数据库：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"the-fortify-service-provider\"></a>\r\n### Fortify 服务提供商\r\n\r\n上面讨论的 `vendor:publish` 命令还将发布 `App\\Providers\\FortifyServiceProvider` 类。你应该确保该类已在应用程序的 `config/app.php` 配置文件的 `providers` 数组中注册。\r\n\r\nFortify 服务提供商注册了 Fortify 所发布的行为类，并指导 Fortify 在执行各自的任务时使用它们。\r\n\r\n<a name=\"fortify-features\"></a>\r\n### Fortify 包含的功能\r\n\r\n该 `fortify` 配置文件包含一个 `features` 配置数组。该数组默路定义了 Fortify 的路由和功能。如果你不打算将 Fortify 与 [Laravel Jetstream](https://jetstream.laravel.com) 配合使用，我们建议你仅启用以下功能，这是大多数 Laravel 应用提供的基本身份认证功能：\r\n\r\n```php\r\n'features' => [\r\n    Features::registration(),\r\n    Features::resetPasswords(),\r\n    Features::emailVerification(),\r\n],\r\n```\r\n\r\n<a name=\"disabling-views\"></a>\r\n### 禁用视图\r\n\r\n默认情况下，Fortify 定义用于返回视图的路由，例如登录或注册。但是，如果要构建 JavaScript 驱动的单页应用，那么可能不需要这些路由。因此，你可以通过将 `config/fortify.php` 配置文件中的  `views` 配置值设为 `false` 来禁用这些路由：\r\n\r\n```php\r\n'views' => false,\r\n```\r\n\r\n\n\n<a name=\"disabling-views-and-password-reset\"></a>\r\n#### 禁用视图 & 重置密码\r\n\r\n如果你选择禁用 Fortify 的视图，并且将为你的应用实现重置密码功能，这时你仍然需要定义一个名为 `password.reset` 的路由，该路由负责显示应用的「重置密码」视图。这是必要的，因为 Laravel 的 `Illuminate\\Auth\\Notifications\\ResetPassword` 通知将通过名为 `password.reset` 的路由生成重置密码 URL。\r\n\r\n<a name=\"authentication\"></a>\r\n## 身份认证\r\n\r\n首先，我们需要指导 Fortify 如何返回「登录」视图。记住，Fortify 是一个无头认证扩展。如果你想要一个已经为你完成的 Laravel 身份认证功能的前端实现，你应该使用 [应用入门套件](/docs/laravel/9.x/starter-kits)。\r\n\r\n所有的身份认证视图逻辑，都可以使用 `Laravel\\Fortify\\Fortify` 类提供的方法来自定义。通常，你应该从应用的 `App\\Providers\\FortifyServiceProvider` 的 `boot` 方法中调用此方法。Fortify 将负责定义返回此视图的 `/login` 路由：\r\n\r\n    use Laravel\\Fortify\\Fortify;\r\n\r\n    /**\r\n     * 引导任何应用服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Fortify::loginView(function () {\r\n            return view('auth.login');\r\n        });\r\n\r\n        // ...\r\n    }\r\n\r\n你的登录模板应包括一个向 `/login` 发出 POST 请求的表单。 `/login` 表单需要一个 `email` / `username` 和 `password`。 `email` / `username` 字段与 `config/fortify.php` 配置文件中的 `username` 值相匹配。另外，可以提供布尔值 `remember` 字段来指导用户想要使用 Laravel 提供的「记住我」功能。\r\n\r\n\n\n如果登录尝试成功，Fortify 会将你重定向到通过应用程序 `fortify` 配置文件中的 `home` 配置选项配置的 URI。如果登录请求是 XHR 请求，将返回 200 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回登录页，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/10.x/validation#quick-displaying-the-validation-errors) 提供给你。或者，在 XHR 请求的情况下，验证错误将与 422 HTTP 响应一起返回。\r\n\r\n<a name=\"customizing-user-authentication\"></a>\r\n### 自定义用户认证\r\n\r\nFortify 将根据提供的凭据和为你的应用程序配置的身份验证保护自动检索和验证用户。但是，你有时可能希望对登录凭据的身份验证和用户的检索方式进行完全自定义。幸运的是，Fortify 允许你使用 `Fortify::authenticateUsing` 方法轻松完成此操作。\r\n\r\n此方法接受接收传入 HTTP 请求的闭包。闭包负责验证附加到请求的登录凭据并返回关联的用户实例。如果凭据无效或找不到用户，则闭包应返回 `null` 或 `false` 。通常，这个方法应该从你的 `FortifyServiceProvider` 的 `boot` 方法中调用：\r\n\r\n```php\r\nuse App\\Models\\User;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Facades\\Hash;\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导应用服务\r\n */\r\npublic function boot(): void\r\n{\r\n    Fortify::authenticateUsing(function (Request $request) {\r\n        $user = User::where('email', $request->email)->first();\r\n\r\n        if ($user &&\r\n            Hash::check($request->password, $user->password)) {\r\n            return $user;\r\n        }\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\n\n<a name=\"authentication-guard\"></a>\r\n#### 身份验证看守器\r\n\r\n你可以在应用程序的 `fortify` 文件中自定义 Fortify 使用的身份验证看守器。但是，你应该确保配置的看守器是 `Illuminate\\Contracts\\Auth\\StatefulGuard` 的实现。如果你尝试使用 Laravel Fortify 对 SPA 进行身份验证，你应该将 Laravel 的默认 `web` 防护与 [Laravel Sanctum](https://laravel.com/docs/sanctum) 结合使用。\r\n\r\n<a name=\"customizing-the-authentication-pipeline\"></a>\r\n### 自定义身份验证管道\r\n\r\nLaravel Fortify 通过可调用类的管道对登录请求进行身份验证。如果你愿意，你可以定义一个自定义的类管道，登录请求应该通过管道传输。每个类都应该有一个 `__invoke` 方法，该方法接收传入 `Illuminate\\Http\\Request` 实例的方法，并且像 [中间件](/docs/laravel/10.x/middleware) 一样，调用一个 `$next` 变量，以便将请求传递给管道中的下一个类。\r\n\r\n要定义自定义管道，可以使用 `Fortify::authenticateThrough` 方法。此方法接受一个闭包，该闭包应返回类数组，以通过管道传递登录请求。通常，应该从 `App\\Providers\\FortifyServiceProvider` 的 `boot` 方法调用此方法。\r\n\r\n下面的示例包含默认管道定义，你可以在自己进行修改时将其用作开始：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Actions\\AttemptToAuthenticate;\r\nuse Laravel\\Fortify\\Actions\\EnsureLoginIsNotThrottled;\r\nuse Laravel\\Fortify\\Actions\\PrepareAuthenticatedSession;\r\nuse Laravel\\Fortify\\Actions\\RedirectIfTwoFactorAuthenticatable;\r\nuse Laravel\\Fortify\\Fortify;\r\nuse Illuminate\\Http\\Request;\r\n\r\nFortify::authenticateThrough(function (Request $request) {\r\n    return array_filter([\r\n            config('fortify.limiters.login') ? null : EnsureLoginIsNotThrottled::class,\r\n            Features::enabled(Features::twoFactorAuthentication()) ? RedirectIfTwoFactorAuthenticatable::class : null,\r\n            AttemptToAuthenticate::class,\r\n            PrepareAuthenticatedSession::class,\r\n    ]);\r\n});\r\n```\r\n\r\n\n\n<a name=\"customizing-authentication-redirects\"></a>\r\n### 自定义跳转\r\n\r\n如果登录尝试成功，Fortify 会将你重定向到你应用程序 `Fortify` 的配置文件中的 `home` 配置选项的 URI 值。如果登录请求是 XHR 请求，将返回 200 HTTP 响应。用户注销应用程序后，该用户将被重定向到 `/` 地址。\r\n\r\n如果需要对这种行为进行高级定制，可以将 `LoginResponse` 和 `LogoutResponse` 契约的实现绑定到 Laravel [服务容器](/docs/laravel/10.x/container) 。通常，这应该在你应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `register` 方法中完成：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Contracts\\LogoutResponse;\r\nuse Illuminate\\Http\\RedirectResponse;\r\nuse Illuminate\\Http\\Request;\r\n\r\n/**\r\n * 注册任何应用程序服务。\r\n */\r\npublic function register(): void\r\n{\r\n    $this->app->instance(LogoutResponse::class, new class implements LogoutResponse {\r\n        public function toResponse(Request $request): RedirectResponse\r\n        {\r\n            return redirect('/');\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n<a name=\"two-factor-authentication\"></a>\r\n## 双因素认证\r\n\r\n当 Fortify 的双因素身份验证功能启用时，用户需要在身份验证过程中输入一个六位数的数字令牌。该令牌使用基于时间的一次性密码（TOTP）生成，该密码可以从任何与 TOTP 兼容的移动认证应用程序（如 Google Authenticator）中检索。\r\n\r\n在开始之前，你应该首先确保应用程序的 `App\\Models\\User` 模型使用 `Laravel\\Fortify\\TwoFactorAuthenticatable` trait：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\nuse Illuminate\\Notifications\\Notifiable;\r\nuse Laravel\\Fortify\\TwoFactorAuthenticatable;\r\n\r\nclass User extends Authenticatable\r\n{\r\n    use Notifiable, TwoFactorAuthenticatable;\r\n}\r\n ```\r\n\r\n接下来，你应该在应用程序中构建一个页面，用户可以在其中管理他们的双因素身份验证设置。该页面应允许用户启用和禁用双因素身份验证，以及重新生成双因素身份验证恢复的代码。\r\n\r\n> 默认情况下， `fortify` 配置文件的 `features` 数组管理着 Fortify 的双因素身份验证设置在修改前需要密码确认。因此，在使用之前，你的应用程序应该实现 Fortify 的 [密码确认](#password-confirmation) 功能。\r\n\r\n\n\n<a name=\"enabling-two-factor-authentication\"></a>\r\n### 启用双因素身份验证\r\n\r\n要启用双重身份验证，你的应用程序应向 Fortify 定义的 `/user/two-factor-authentication` 发出 POST 请求。如果请求成功，用户将被重定向回之前的 URL，并且 `status` session 变量将设置为 `two-factor-authentication-enabled`。你可以在模板中检测这个 `status` session 变量以显示适当的成功消息。如果请求是 XHR 请求，将返回  `200` HTTP 响应：\r\n\r\n在选择启用双因素认证后，用户仍然必须通过提供一个有效的双因素认证代码来「确认」他们的双因素认证配置。因此，你的「成功」消息应该指示用户，双因素认证的确认仍然是必需的。\r\n\r\n```html\r\n@if (session('status') == 'two-factor-authentication-enabled')\r\n    <div class=\"mb-4 font-medium text-sm\">\r\n        Please finish configuring two factor authentication below.\r\n    </div>\r\n@endif\r\n```\r\n\r\n接下来，你应该显示双重身份验证二维码，供用户扫描到他们的身份验证器应用程序中。如果你使用 Blade 呈现应用程序的前端，则可以使用用户实例上可用的 `twoFactorQrCodeSvg` 方法检索二维码 SVG：\r\n\r\n```php\r\n$request->user()->twoFactorQrCodeSvg();\r\n```\r\n\r\n如果你正在构建由 JavaScript 驱动的前端，你可以向 `/user/two-factor-qr-code` 发出 XHR GET 请求以检索用户的双重身份验证二维码。将返回一个包含 `svg` 键的 JSON 对象。\r\n\r\n<a name=\"confirming-two-factor-authentication\"></a>\r\n#### 确认双因素认证\r\n\r\n除了显示用户的双因素认证 QR 码，你应该提供一个文本输入，用户可以提供一个有效的认证码来「确认」他们的双因素认证配置。这个代码应该通过 POST 请求提供到 `/user/confirmed-two-factor-authentication`，由 Fortify 来进行确认。\r\n\r\nIf the request is successful, the user will be redirected back to the previous URL and the `status` session variable will be set to `two-factor-authentication-confirmed`:\r\n\r\n如果请求成功，用户将被重定向到之前的URL，`status` 会话变量将被设置为 `two-factor-authentication-confirmed'。\r\n\r\n```html\r\n@if (session('status') == 'two-factor-authentication-confirmed')\r\n    <div class=\"mb-4 font-medium text-sm\">\r\n        Two factor authentication confirmed and enabled successfully.\r\n    </div>\r\n@endif\r\n```\r\n\r\n\n\n如果对双因素认证确认端点的请求是通过 XHR 请求进行的，将返回一个 `200` HTTP响应。\r\n\r\n<a name=\"displaying-the-recovery-codes\"></a>\r\n#### 显示恢复代码\r\n\r\n你还应该显示用户的两个因素恢复代码。这些恢复代码允许用户在无法访问其移动设备时进行身份验证。如果你使用 Blade 来渲染应用程序的前端，你可以通过经过身份验证的用户实例访问恢复代码：\r\n\r\n```php\r\n(array) $request->user()->recoveryCodes()\r\n```\r\n\r\n如果你正在构建一个 JavaScript 驱动的前端，你可以向 `/user/two-factor-recovery-codes` 端点发出 XHR GET 请求。此端点将返回一个包含用户恢复代码的 JSON 数组。\r\n\r\n要重新生成用户的恢复代码，你的应用程序应向 `/user/two-factor-recovery-codes` 端点发出 POST 请求。\r\n\r\n<a name=\"authenticating-with-two-factor-authentication\"></a>\r\n### 使用双因素身份验证进行身份验证\r\n\r\n在身份验证过程中，Fortify 将自动将用户重定向到你的应用程序的双因素身份验证检查页面。但是，如果你的应用程序正在发出 XHR 登录请求，则在成功进行身份验证尝试后返回的 JSON 响应将包含一个具有 `two_factor` 布尔属性的 JSON 对象。你应该检查此值以了解是否应该重定向到应用程序的双因素身份验证检查页面。\r\n\r\n要开始实现两因素身份验证功能，我们需要指示 Fortify 如何返回我们的双因素身份验证检查页面。Fortify 的所有身份验证视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。通常，你应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Fortify::twoFactorChallengeView(function () {\r\n        return view('auth.two-factor-challenge');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\n\nFortify 将负责定义返回此视图的 `/two-factor-challenge` 路由。你的 `two-factor-challenge` 模板应包含一个向 `/two-factor-challenge` 端点发出 POST 请求的表单。 `/two-factor-challenge` 操作需要包含有效 TOTP 令牌的 `code` 字段或包含用户恢复代码之一的 `recovery_code` 字段。\r\n\r\n如果登录尝试成功，Fortify 会将用户重定向到通过应用程序的 `fortify` 配置文件中的 `home` 配置选项配置的 URI。如果登录请求是 XHR 请求，将返回 204 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回两因素挑战屏幕，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/10.x/验证#快速显示验证错误)。或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n<a name=\"disabling-two-factor-authentication\"></a>\r\n### 禁用两因素身份验证\r\n\r\n要禁用双因素身份验证，你的应用程序应向 `/user/two-factor-authentication` 端点发出 DELETE 请求。请记住，Fortify 的两个因素身份验证端点在被调用之前需要 [密码确认](#password-confirmation)。\r\n\r\n<a name=\"registration\"></a>\r\n## 注册\r\n\r\n要开始实现我们应用程序的注册功能，我们需要指示 Fortify 如何返回我们的“注册”视图。请记住，Fortify 是一个无头身份验证库。如果你想要一个已经为你完成的 Laravel 身份验证功能的前端实现，你应该使用 [application starter kit](/docs/laravel/10.x/starter-kits)。\r\n\r\nFortify 的所有视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。通常，你应该从 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Fortify::registerView(function () {\r\n        return view('auth.register');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\n\nFortify 将负责定义返回此视图的 `/register` 路由。你的 `register` 模板应包含一个向 Fortify 定义的 `/register` 端点发出 POST 请求的表单。\r\n\r\n`/register` 端点需要一个字符串 `name`、字符串电子邮件地址/用户名、`password` 和 `password_confirmation` 字段。电子邮件/用户名字段的名称应与应用程序的 `fortify` 配置文件中定义的 `username` 配置值匹配。\r\n\r\n如果注册尝试成功，Fortify 会将用户重定向到通过应用程序的 `fortify` 配置文件中的 `home` 配置选项配置的 URI。如果登录请求是 XHR 请求，将返回 201 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回注册屏幕，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/10.x/validation#快速显示验证错误)。或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n<a name=\"customizing-registration\"></a>\r\n### 定制注册\r\n\r\n可以通过修改安装 Laravel Fortify 时生成的 `App\\Actions\\Fortify\\CreateNewUser` 操作来自定义用户验证和创建过程。\r\n\r\n<a name=\"password-reset\"></a>\r\n## 重设密码\r\n\r\n<a name=\"requesting-a-password-reset-link\"></a>\r\n### 请求密码重置链接\r\n\r\n要开始实现我们应用程序的密码重置功能，我们需要指示 Fortify 如何返回我们的“忘记密码”视图。请记住，Fortify 是一个无头身份验证库。如果你想要一个已经为你完成的 Laravel 身份验证功能的前端实现，你应该使用 [application starter kit](/docs/laravel/10.x/starter-kits)。\r\n\r\n\n\nFortify 的所有视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。通常，你应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Fortify::requestPasswordResetLinkView(function () {\r\n        return view('auth.forgot-password');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nFortify 将负责定义返回此视图的 `/forgot-password` 端点。你的 `forgot-password` 模板应该包含一个向 `/forgot-password` 端点发出 POST 请求的表单。\r\n\r\n`/forgot-password` 端点需要一个字符串 `email` 字段。此字段/数据库列的名称应与应用程序的 `fortify` 配置文件中的 `email` 配置值匹配。\r\n\r\n<a name=\"handling-the-password-reset-link-request-response\"></a>\r\n#### 处理密码重置链接请求响应\r\n\r\n如果密码重置链接请求成功，Fortify 会将用户重定向回 `/forgot-password` 端点，并向用户发送一封电子邮件，其中包含可用于重置密码的安全链接。如果请求是 XHR 请求，将返回 200 HTTP 响应。\r\n\r\n在请求成功后被重定向到 `/forgot-password` 端点，`status` 会话变量可用于显示密码重置链接请求的状态。\r\n\r\n在成功请求后被重定向回 `/forgot-password` 端点后，`status` 会话变量可用于显示密码重置链接请求尝试的状态。此会话变量的值将匹配应用程序的 `password` [语言文件](/docs/laravel/10.x/localization) 中定义的翻译字符串之一：\r\n\r\n```html\r\n@if (session('status'))\r\n    <div class=\"mb-4 font-medium text-sm text-green-600\">\r\n        {{ session('status') }}\r\n    </div>\r\n@endif\r\n```\r\n\r\n\n\n如果请求不成功，用户将被重定向回请求密码重置链接屏幕，验证错误将通过共享的 `$errors`  [Blade 模板变量](/docs/laravel/10.x/validation#quick-displaying-the-validation-errors) 提供给你。或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n<a name=\"resetting-the-password\"></a>\r\n### 重设密码\r\n\r\n为了完成应用程序的密码重置功能，我们需要指示 Fortify 如何返回我们的「重置密码」视图。\r\n\r\nFortify 的所有视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。通常，你应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\nuse Illuminate\\Http\\Request;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Fortify::resetPasswordView(function (Request $request) {\r\n        return view('auth.reset-password', ['request' => $request]);\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nFortify 将负责定义显示此视图的路线。你的 `reset-password` 模板应该包含一个向 `/reset-password` 发出 POST 请求的表单。\r\n\r\n`/reset-password` 端点需要一个字符串 `email` 字段、一个 `password` 字段、一个 `password_confirmation` 字段和一个名为 `token` 的隐藏字段，其中包含`request()->route('token')`。 `email` 字段/数据库列的名称应与应用程序的 `fortify` 配置文件中定义的 `email` 配置值匹配。\r\n\r\n<a name=\"handling-the-password-reset-response\"></a>\r\n#### 处理密码重置响应\r\n\r\n如果密码重置请求成功，Fortify 将重定向回 `/login` 路由，以便用户可以使用新密码登录。此外，还将设置一个 `status` 会话变量，以便你可以在登录屏幕上显示重置的成功状态：\r\n\r\n```blade\r\n@if (session('status'))\r\n    <div class=\"mb-4 font-medium text-sm text-green-600\">\r\n        {{ session('status') }}\r\n    </div>\r\n@endif\r\n```\r\n\r\n\n\n如果请求是 XHR 请求，将返回 200 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回重置密码屏幕，验证错误将通过共享的 `$errors` [Blade 模板变量](/docs/laravel/10.x/validation#快速显示验证错误)。或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\r\n<a name=\"customizing-password-resets\"></a>\r\n### 自定义密码重置\r\n\r\n可以通过修改安装 Laravel Fortify 时生成的 `App\\Actions\\ResetUserPassword` 操作来自定义密码重置过程。\r\n\r\n<a name=\"email-verification\"></a>\r\n## 电子邮件验证\r\n\r\n注册后，你可能希望用户在继续访问你的应用程序之前验证他们的电子邮件地址。要开始使用，请确保在 `fortify` 配置文件的 `features` 数组中启用了 `emailVerification` 功能。接下来，你应该确保你的 `App\\Models\\User` 类实现了 `Illuminate\\Contracts\\Auth\\MustVerifyEmail` 接口。\r\n\r\n完成这两个设置步骤后，新注册的用户将收到一封电子邮件，提示他们验证其电子邮件地址的所有权。但是，我们需要通知 Fortify 如何显示电子邮件验证屏幕，通知用户他们需要点击电子邮件中的验证链接。\r\n\r\nFortify 的所有视图的渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。通常，你应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导所有应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Fortify::verifyEmailView(function () {\r\n        return view('auth.verify-email');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n\n\n当用户被 Laravel 内置的 `verified` 中间件重定向到 `/email/verify` 端点时，Fortify 将负责定义显示此视图的路由。\r\n\r\n你的 `verify-email` 模板应包含一条信息性消息，指示用户单击发送到其电子邮件地址的电子邮件验证链接。\r\n\r\n<a name=\"resending-email-verification-links\"></a>\r\n#### 重新发送电子邮件验证链接\r\n\r\n如果你愿意，你可以在应用程序的 `verify-email` 模板中添加一个按钮，该按钮会触发对 `/email/verification-notification` 端点的 POST 请求。当此端点收到请求时，将通过电子邮件将新的验证电子邮件链接发送给用户，如果先前的验证链接被意外删除或丢失，则允许用户获取新的验证链接。\r\n\r\n如果重新发送验证链接电子邮件的请求成功，Fortify 将使用 `status` 会话变量将用户重定向回 `/email/verify` 端点，允许你向用户显示信息性消息，通知他们操作已完成成功的。如果请求是 XHR 请求，将返回 202 HTTP 响应：\r\n\r\n```blade\r\n@if (session('status') == 'verification-link-sent')\r\n    <div class=\"mb-4 font-medium text-sm text-green-600\">\r\n        A new email verification link has been emailed to you!\r\n    </div>\r\n@endif\r\n```\r\n\r\n<a name=\"protecting-routes\"></a>\r\n### 保护路由\r\n\r\n要指定一个路由或一组路由要求用户验证他们的电子邮件地址，你应该将 Laravel 的内置 `verified` 中间件附加到该路由。该中间件在你的应用程序的 `App\\Http\\Kernel` 类中注册：\r\n\r\n```php\r\nRoute::get('/dashboard', function () {\r\n    // ...\r\n})->middleware(['verified']);\r\n```\r\n\r\n<a name=\"password-confirmation\"></a>\r\n\n\n## 确认密码\r\n\r\n在构建应用程序时，你可能偶尔会有一些操作需要用户在执行操作之前确认其密码。通常，这些路由受到 Laravel 内置的 `password.confirm` 中间件的保护。\r\n\r\n要开始实现密码确认功能，我们需要指示 Fortify 如何返回应用程序的「密码确认」视图。请记住，Fortify 是一个无头身份验证库。如果你想要一个已经为你完成的 Laravel 身份验证功能的前端实现，你应该使用 [application starter kit](/docs/laravel/10.x/starter-kits)。\r\n\r\nFortify 的所有视图渲染逻辑都可以使用通过 `Laravel\\Fortify\\Fortify` 类提供的适当方法进行自定义。通常，你应该从应用程序的 `App\\Providers\\FortifyServiceProvider` 类的 `boot` 方法调用此方法：\r\n\r\n```php\r\nuse Laravel\\Fortify\\Fortify;\r\n\r\n/**\r\n * 引导所有应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Fortify::confirmPasswordView(function () {\r\n        return view('auth.confirm-password');\r\n    });\r\n\r\n    // ...\r\n}\r\n```\r\n\r\nFortify 将负责定义返回此视图的 `/user/confirm-password` 端点。你的 `confirm-password` 模板应包含一个表单，该表单向 `/user/confirm-password` 端点发出 POST 请求。 `/user/confirm-password` 端点需要一个包含用户当前密码的 `password` 字段。\r\n\r\n如果密码与用户的当前密码匹配，Fortify 会将用户重定向到他们尝试访问的路由。如果请求是 XHR 请求，将返回 201 HTTP 响应。\r\n\r\n如果请求不成功，用户将被重定向回确认密码屏幕，验证错误将通过共享的 `$errors` Blade 模板变量提供给你。或者，在 XHR 请求的情况下，验证错误将返回 422 HTTP 响应。\r\n\n","p":"docs/fortify.html"},{"t":"homestead (Laravel Homestead)","d":"\n# Laravel Homestead\r\n\r\n- [简介](#introduction)\r\n- [安装与设置](#installation-and-setup)\r\n    - [第一步](#first-steps)\r\n    - [配置 Homestead](#configuring-homestead)\r\n    - [配置 Nginx 站点](#configuring-nginx-sites)\r\n    - [配置服务](#configuring-services)\r\n    - [启动 Vagrant Box](#launching-the-vagrant-box)\r\n    - [为项目单独安装](#per-project-installation)\r\n    - [安装可选功能](#installing-optional-features)\r\n    - [别名](#aliases)\r\n- [更新 Homestead](#updating-homestead)\r\n- [日常使用方法](#daily-usage)\r\n    - [通过 SSH 连接](#connecting-via-ssh)\r\n    - [添加其他站点](#adding-additional-sites)\r\n    - [环境变量](#environment-variables)\r\n    - [端口](#ports)\r\n    - [多 PHP 版本](#php-versions)\r\n    - [连接数据库](#connecting-to-databases)\r\n    - [数据库备份](#database-backups)\r\n    - [配置 Cron 调度器](#configuring-cron-schedules)\r\n    - [配置 MailHog](#configuring-mailhog)\r\n    - [配置 Minio](#configuring-minio)\r\n    - [Laravel Dusk](#laravel-dusk)\r\n    - [共享你的环境](#sharing-your-environment)\r\n- [调试与性能分析](#debugging-and-profiling)\r\n    - [使用 Xdebug 调试 Web 请求](#debugging-web-requests)\r\n    - [调试 CLI 应用程序](#debugging-cli-applications)\r\n    - [使用 Blackfire 为应用程序分析性能](#profiling-applications-with-blackfire)\r\n- [网络接口](#network-interfaces)\r\n- [扩展 Homestead](#extending-homestead)\r\n- [针对虚拟机软件的特殊设置](#provider-specific-settings)\r\n    - [VirtualBox](#provider-specific-virtualbox)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\nLaravel 致力于让整个 PHP 开发体验变得愉悦，包括您的本地开发环境。 [Laravel Homestead](https://github.com/laravel/homestead) 是一个官方的预封装的 Vagrant box 套件，它为你提供了一个绝佳的开发环境，而无需你在本地机器上安装 PHP、Web 服务器及任何其他服务器软件。\r\n\r\n[Vagrant](https://www.vagrantup.com) 提供了一种简单、优雅的方式来管理和配置虚拟机。 Vagrant Box 完全是一次性的。如果出现问题，你可以在几分钟内销毁并重新创建 Box !\r\n\r\nHomestead 可以在任何 Windows、 macOS 或 Linux 系统上运行，它预装好了 Nginx、 PHP、 MySQL、 PostgreSQL、 Redis、 Memcached、 Node 以及开发令人惊叹的 Laravel 应用程序所需的所有其他软件。\r\n\r\n> **注意**  \r\n> 如果你使用的是 Windows ，你可能需要启用硬件虚拟化（ VT-x ）。该功能通常需要通过你的 BIOS 启用。如果你在 UEFI 系统上使用 Hyper-V ，则可能还需要禁用 Hyper-V 才能访问 VT-x 。\r\n\r\n\n\n<a name=\"included-software\"></a>\r\n### 内置软件\r\n\r\n<style>\r\n    #software-list > ul {\r\n        column-count: 2; -moz-column-count: 2; -webkit-column-count: 2;\r\n        column-gap: 5em; -moz-column-gap: 5em; -webkit-column-gap: 5em;\r\n        line-height: 1.9;\r\n    }\r\n</style>\r\n\r\n<div id=\"software-list\" markdown=\"1\">\r\n\r\n- Ubuntu 20.04\r\n- Git\r\n- PHP 8.2\r\n- PHP 8.1\r\n- PHP 8.0\r\n- PHP 7.4\r\n- PHP 7.3\r\n- PHP 7.2\r\n- PHP 7.1\r\n- PHP 7.0\r\n- PHP 5.6\r\n- Nginx\r\n- MySQL 8.0\r\n- lmm\r\n- Sqlite3\r\n- PostgreSQL 15\r\n- Composer\r\n- Docker\r\n- Node (With Yarn, Bower, Grunt, and Gulp)\r\n- Redis\r\n- Memcached\r\n- Beanstalkd\r\n- Mailhog\r\n- avahi\r\n- ngrok\r\n- Xdebug\r\n- XHProf / Tideways / XHGui\r\n- wp-cli\r\n\r\n</div>\r\n\r\n<a name=\"optional-software\"></a>\r\n### 可选软件\r\n\r\n<style>\r\n    #software-list > ul {\r\n        column-count: 2; -moz-column-count: 2; -webkit-column-count: 2;\r\n        column-gap: 5em; -moz-column-gap: 5em; -webkit-column-gap: 5em;\r\n        line-height: 1.9;\r\n    }\r\n</style>\r\n\r\n<div id=\"software-list\" markdown=\"1\">\r\n\r\n- Apache\r\n- Blackfire\r\n- Cassandra\r\n- Chronograf\r\n- CouchDB\r\n- Crystal & Lucky Framework\r\n- Elasticsearch\r\n- EventStoreDB\r\n- Gearman\r\n- Go\r\n- Grafana\r\n- InfluxDB\r\n- MariaDB\r\n- Meilisearch\r\n- MinIO\r\n- MongoDB\r\n- Neo4j\r\n- Oh My Zsh\r\n- Open Resty\r\n- PM2\r\n- Python\r\n- R\r\n- RabbitMQ\r\n- RVM (Ruby Version Manager)\r\n- Solr\r\n- TimescaleDB\r\n- Trader <small>(PHP extension)</small>\r\n- Webdriver & Laravel Dusk Utilities\r\n\r\n</div>\r\n\r\n<a name=\"installation-and-setup\"></a>\r\n## 安装 & 设置\r\n\r\n<a name=\"first-steps\"></a>\r\n### 第一步\r\n\r\n在启动 Homestead 环境之前，你必须安装 [Vagrant](https://developer.hashicorp.com/vagrant/downloads) 及以下受支持的虚拟机之一：\r\n\r\n- [VirtualBox 6.1.x](https://www.virtualbox.org/wiki/Downloads)\r\n- [Parallels](https://www.parallels.com/products/desktop/)\r\n\r\n以上这些软件包都为所有流行的操作系统提供了易于使用的可视化安装程序。\r\n\r\n\n\n如果要使用 Parallels 提供虚拟机服务，你需要安装 [Parallels Vagrant plug-in](https://github.com/Parallels/vagrant-parallels)。这个插件是免费的。\r\n\r\n<a name=\"installing-homestead\"></a>\r\n#### 安装 Homestead\r\n\r\n你可以通过将 Homestead 存储库克隆到你的主机上来安装 Homestead。 考虑将存储库克隆到 `home` 目录中的 `Homestead` 文件夹中，因为 Homestead 虚拟机将作为所有 Laravel 应用程序的主机。 在本文档中，我们将此目录称为你的「Homestead 目录」：\r\n\r\n```shell\r\ngit clone https://github.com/laravel/homestead.git ~/Homestead\r\n```\r\n\r\n克隆 Laravel Homestead 存储库后，你应该检出 `release` 分支。 这个分支总是包含 Homestead 的最新稳定版本：\r\n\r\n```shell\r\ncd ~/Homestead\r\n\r\ngit checkout release\r\n```\r\n\r\n接下来，从 Homestead 目录执行 `bash init.sh` 命令以创建 `Homestead.yaml` 配置文件。 `Homestead.yaml` 文件是你为 Homestead 安装配置所有设置的地方。 这个文件将被放置在 Homestead 目录中：\r\n\r\n```shell\r\n# macOS / Linux...\r\nbash init.sh\r\n\r\n# Windows...\r\ninit.bat\r\n```\r\n\r\n<a name=\"configuring-homestead\"></a>\r\n### 配置 Homestead\r\n\r\n<a name=\"setting-your-provider\"></a>\r\n#### 设置提供服务的虚拟机程序\r\n\r\n`Homestead.yaml` 文件中的 `provider` 键指示应该使用哪个 Vagrant 提供虚拟机服务：`virtualbox` 或 `parallels`：\r\n\r\n    provider: virtualbox\r\n\r\n> **注意**  \r\n> 如果你使用的是 Apple Silicon，你应该将 `box: laravel/homestead-arm` 添加到你的 `Homestead.yaml` 文件中。 Apple Silicon 下需要使用 Parallels 提供虚拟机服务。\r\n\r\n<a name=\"configuring-shared-folders\"></a>\r\n#### 配置共享文件夹\r\n\r\n`Homestead.yaml` 文件的 `folders` 属性列出了你希望与 Homestead 环境共享的所有文件夹。 当这些文件夹中的文件发生更改时，它们将在你的本地机器和 Homestead 虚拟环境之间保持同步。 你可以根据需要配置任意数量的共享文件夹：\r\n\r\n```yaml\r\nfolders:\r\n    - map: ~/code/project1\r\n      to: /home/vagrant/project1\r\n```\r\n\r\n> **注意**  \r\n> Windows 用户不应使用 `~/` 路径语法，而应使用其项目的完整路径，例如 `C:\\Users\\user\\Code\\project1`。\r\n\r\n\n\n你应该始终将单个应用程序映射到它们自己的文件夹映射，而不是映射包含所有应用程序的单个大目录。 映射文件夹时，虚拟机需要跟踪文件夹中每个文件的所有磁盘 IO。 如果文件夹中有大量文件，性能可能会降低：\r\n\r\n```yaml\r\nfolders:\r\n    - map: ~/code/project1\r\n      to: /home/vagrant/project1\r\n    - map: ~/code/project2\r\n      to: /home/vagrant/project2\r\n```\r\n\r\n> **注意**  \r\n> 在使用 Homestead 时，你永远不应该挂载 `.`（当前目录）。 这会导致 Vagrant 不会将当前文件夹映射到 `/vagrant`，并且会在配置时破坏可选功能并导致意外结果。\r\n\r\n要启用 [NFS](https://www.vagrantup.com/docs/synced-folders/nfs.html)，你可以在文件夹映射中添加一个 `type` 选项：\r\n\r\n```yaml\r\nfolders:\r\n    - map: ~/code/project1\r\n      to: /home/vagrant/project1\r\n      type: \"nfs\"\r\n```\r\n\r\n> **注意**  \r\n> 在 Windows 上使用 NFS 时，应考虑安装 [vagrant-winnfsd](https://github.com/winnfsd/vagrant-winnfsd) 插件。 该插件将维护 Homestead 虚拟机中文件和目录的正确用户 / 组权限。\r\n\r\n你还可以通过在 `options` 键下列出它们来传递 Vagrant 的 [同步文件夹](https://www.vagrantup.com/docs/synced-folders/basic_usage.html) 支持的任何选项：\r\n\r\n```yaml\r\nfolders:\r\n    - map: ~/code/project1\r\n      to: /home/vagrant/project1\r\n      type: \"rsync\"\r\n      options:\r\n          rsync__args: [\"--verbose\", \"--archive\", \"--delete\", \"-zz\"]\r\n          rsync__exclude: [\"node_modules\"]\r\n```\r\n\r\n<a name=\"configuring-nginx-sites\"></a>\r\n### 配置 Nginx 站点\r\n\r\n不熟悉 Nginx？ 没问题。 你的 `Homestead.yaml` 文件的 `sites` 属性允许你轻松地将「域」映射到 Homestead 环境中的文件夹。 `Homestead.yaml` 文件中包含一个示例站点配置。 同样，你可以根据需要向 Homestead 环境添加任意数量的站点。 Homestead 可以为你正在开发的每个 Laravel 应用程序提供方便的虚拟化环境：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n```\r\n\r\n\n\n如果你在配置 Homestead 虚拟机后更改了 `sites` 属性，你应该在终端中执行 `vagrant reload --provision` 命令来更新虚拟机上的 Nginx 配置。\r\n\r\n> **注意**  \r\n> Homestead 脚本被构建为尽可能具有幂等性。 但是，如果你在配置时遇到问题，你应该通过执行 `vagrant destroy && vagrant up` 命令来销毁和重建机器。\r\n\r\n<a name=\"hostname-resolution\"></a>\r\n#### 主机名解析\r\n\r\nHomestead 使用 `mDNS` 发布主机名以进行自动主机解析。 如果你在 `Homestead.yaml` 文件中设置 `hostname: homestead`，主机将在 `homestead.local` 中可用。 macOS、iOS 和 Linux 桌面发行版默认包含 `mDNS` 支持。 如果你使用的是 Windows，则必须安装 [Bonjour Print Services for Windows](https://support.apple.com/kb/DL999?viewlocale=en_US&locale=en_US)。\r\n\r\n使用自动主机名最适合 Homestead 的 [每个项目安装](#per-project-installation)。 如果你在单个 Homestead 实例上托管多个站点，你可以将你网站的「域名」添加到你机器上的 `hosts` 文件中。 `hosts` 文件会将你对 Homestead 站点的请求重定向到你的 Homestead 虚拟机中。 在 macOS 和 Linux 上，此文件位于 `/etc/hosts`。 在 Windows 上，它位于 `C:\\Windows\\System32\\drivers\\etc\\hosts` 。 你添加到此文件的行将如下所示：\r\n\r\n    192.168.56.56  homestead.test\r\n\r\n确保列出的 IP 地址是你在 `Homestead.yaml` 文件中设置的地址。将域名添加到 `hosts` 文件并启动 Vagrant 盒子后，你将能够通过 Web 浏览器访问该站点：\r\n\r\n```shell\r\nhttp://homestead.test\r\n```\r\n\r\n\n\n<a name=\"configuring-services\"></a>\r\n### 配置服务\r\n\r\nHomestead 默认会启动好几个服务； 但你可以在配置的时候自定义启用或禁用哪些服务。 例如，你可以通过修改 `Homestead.yaml` 文件中的 `services` 选项来启用 PostgreSQL 并禁用 MySQL：\r\n\r\n```yaml\r\nservices:\r\n    - enabled:\r\n        - \"postgresql\"\r\n    - disabled:\r\n        - \"mysql\"\r\n```\r\n\r\n指定的服务将根据它们在 `enabled` 和 `disabled` 指令中的顺序启动或停止。\r\n\r\n<a name=\"launching-the-vagrant-box\"></a>\r\n### 启动 The Vagrant Box\r\n\r\n你根据自己的需求修改 `Homestead.yaml` 后，你可以通过在 Homestead 目录运行 `vagrant up` 命令来启动 Vagrant 虚拟机。 Vagrant 将启动虚拟机并自动配置你的共享文件夹和 Nginx 站点。\r\n\r\n要销毁虚拟机实例，你可以使用 `vagrant destroy` 命令。\r\n\r\n<a name=\"per-project-installation\"></a>\r\n### 为项目单独安装\r\n\r\n你可以为你管理的每个项目配置一个 Homestead 实例，而不是全局安装 Homestead 并在所有项目中共享相同的 Homestead 虚拟机。 如果你希望随项目一起提供 `Vagrantfile`，允许其他人在克隆项目的存储库后立即 `vagrant up`，则为每个项目安装 Homestead 可能会有所帮助。\r\n\r\n你可以使用 Composer 包管理器将 Homestead 安装到你的项目中：\r\n\r\n```shell\r\ncomposer require laravel/homestead --dev\r\n```\r\n\r\n安装 Homestead 后，调用 Homestead 的 `make` 命令为你的项目生成 `Vagrantfile` 和 `Homestead.yaml` 文件。 这些文件将放置在项目的根目录中。 `make` 命令将自动配置 `Homestead.yaml` 文件中的站点和文件夹指令：\r\n\r\n```shell\r\n# macOS / Linux...\r\nphp vendor/bin/homestead make\r\n\r\n# Windows...\r\nvendor\\\\bin\\\\homestead make\r\n```\r\n\r\n\n\n接下来，在终端中运行 `vagrant up` 命令并在浏览器中通过 `http://homestead.test` 访问你的项目。 请记住，如果你不使用自动 [主机名解析](#hostname-resolution)，你仍然需要为 `homestead.test` 或你选择的域在 `/etc/hosts` 文件中添加一个主机名映射。\r\n\r\n<a name=\"installing-optional-features\"></a>\r\n### 安装可选功能\r\n\r\n使用 `Homestead.yaml` 文件中的 `features` 选项可以安装可选软件。 大多数功能可以使用布尔值启用或禁用，部分功能允许使用多个配置选项：\r\n\r\n```yaml\r\nfeatures:\r\n    - blackfire:\r\n        server_id: \"server_id\"\r\n        server_token: \"server_value\"\r\n        client_id: \"client_id\"\r\n        client_token: \"client_value\"\r\n    - cassandra: true\r\n    - chronograf: true\r\n    - couchdb: true\r\n    - crystal: true\r\n    - elasticsearch:\r\n        version: 7.9.0\r\n    - eventstore: true\r\n        version: 21.2.0\r\n    - gearman: true\r\n    - golang: true\r\n    - grafana: true\r\n    - influxdb: true\r\n    - mariadb: true\r\n    - meilisearch: true\r\n    - minio: true\r\n    - mongodb: true\r\n    - mysql: true\r\n    - neo4j: true\r\n    - ohmyzsh: true\r\n    - openresty: true\r\n    - pm2: true\r\n    - python: true\r\n    - r-base: true\r\n    - rabbitmq: true\r\n    - rvm: true\r\n    - solr: true\r\n    - timescaledb: true\r\n    - trader: true\r\n    - webdriver: true\r\n```\r\n\r\n<a name=\"elasticsearch\"></a>\r\n#### Elasticsearch\r\n\r\n你可以指定支持的 Elasticsearch 版本，该版本必须是确切的版本号 (major.minor.patch)。 默认安装将创建一个名为「homestead」的集群。 你永远不应该给 Elasticsearch 超过操作系统一半的内存，所以确保你的 Homestead 虚拟机至少有 Elasticsearch 分配的两倍。\r\n\r\n> **注意**  \r\n> 查看 [Elasticsearch 文档](https://www.elastic.co/guide/en/elasticsearch/reference/current) 了解如何自定义你的配置.\r\n\r\n\n\n<a name=\"mariadb\"></a>\r\n#### MariaDB\r\n\r\n启用 MariaDB 将会移除 MySQL 并安装 MariaDB。MariaDB 通常是 MySQL 的替代品，完全兼容 MySQL，所以在应用数据库配置中你仍然可以使用 `mysql` 驱动。\r\n\r\n<a name=\"mongodb\"></a>\r\n#### MongoDB\r\n\r\n默认安装的 MongoDB 将会设置数据库用户名为 `homestead` 及对应的密码为 `secret`。\r\n\r\n<a name=\"neo4j\"></a>\r\n#### Neo4j\r\n\r\nNeo4j 是一个图形数据库，默认安装的 Neo4j 会设置数据库用户名为 `homestead` 及对应的密码 `secret`。要通过浏览器访问 Neo4j ，请通过 Web 浏览器访问 `http://homestead.test:7474`。默认情况下，服务预设了端口 `7687`（Bolt）、`7474`（HTTP）和 `7473`（HTTPS）为来自 Neo4j 客户端的请求提供服务。\r\n\r\n<a name=\"aliases\"></a>\r\n### 系统命令别名\r\n\r\n您可以通过修改 Homestead 目录中的 `aliases` 文件将 Bash 命令别名添加到 Homestead 虚拟机：\r\n\r\n```shell\r\nalias c='clear'\r\nalias ..='cd ..'\r\n```\r\n\r\n当你更新完 `aliases` 文件后，你需要通过 `vagrant reload --provision` 命令重启 Homestead 机器，以确保新的别名在机器上生效。\r\n\r\n<a name=\"updating-homestead\"></a>\r\n## 更新 Homestead\r\n\r\n更新 Homestead 之前确保你已经在 Homestead 目录下通过如下命令移除了当前的虚拟机：\r\n\r\n```shell\r\nvagrant destroy\r\n```\r\n\r\n接下来，需要更新 Homestead 源码，如果你已经克隆仓库到本地，可以在项目根目录下运行如下命令进行更新：\r\n\r\n```shell\r\ngit fetch\r\n\r\ngit pull origin release\r\n```\r\n\r\n这些命令会从 Github 存储库中拉取最新的 Homestead 仓库代码到本地，包括最新的标签版本。你可以在 Homestead 的 [GitHub 发布页面](https://github.com/laravel/homestead/releases) 上找到最新的稳定版本。\r\n\r\n\n\n如果你是通过 Composer 在指定 Laravel 项目中安装的 Homestead，需要确保 `composer.json` 中包含了 `\"laravel/homestead\": \"^12\"`，然后更新这个依赖：\r\n\r\n```shell\r\ncomposer update\r\n```\r\n\r\n之后，你需要通过 `vagrant box update` 命令更新 Vagrant：\r\n\r\n```shell\r\nvagrant box update\r\n```\r\n\r\n接下来，你可以从 Homestead 目录下运行 `bash init.sh` 命令来更新 Homestead 额外的配置文件，你会被询问是否覆盖已存在的 `Homestead.yaml`、`after.sh` 以及 `aliases` 文件：\r\n\r\n```shell\r\n# macOS / Linux...\r\nbash init.sh\r\n\r\n# Windows...\r\ninit.bat\r\n```\r\n\r\n最后，你需要重新生成新的 Homestead 虚拟机来使用最新安装的 Vagrant：\r\n\r\n```shell\r\nvagrant up\r\n```\r\n\r\n<a name=\"daily-usage\"></a>\r\n## 日常使用方法\r\n\r\n<a name=\"connecting-via-ssh\"></a>\r\n### 通过 SSH 连接\r\n\r\n你可以在 Homestead 目录下通过运行 `vagrant ssh` 以 SSH 方式连接到虚拟机。如果你设置了全部访问 Homestead，也可以在任意路径下通过 homestead ssh 登录到虚拟机。\r\n\r\n<a name=\"adding-additional-sites\"></a>\r\n### 添加其他站点\r\n\r\nHomestead 虚拟机在运行时，可能需要添加多个 Laravel 应用到 Nginx 站点。如果是在单个 Homestead 环境中运行多个 Laravel 应用，添加站点很简单，只需将站点添加到 `Homestead.yaml` 文件：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n    - map: another.test\r\n      to: /home/vagrant/project2/public\r\n```\r\n\r\n> **注意**  \r\n> 在添加站点之前，你应该确保已经为项目的目录配置了[配置共享文件夹](#configuring-shared-folders)。\r\n\r\n如果 Vagrant 没有自动管理你的「hosts」文件，你可能还需要将新站点添加到该文件中。在 macOS 和 Linux 上，此文件位于 `/etc/hosts`。在 Windows 上，它位于 `C:\\Windows\\System32\\drivers\\etc\\hosts`：\r\n\r\n    192.168.56.56  homestead.test\r\n    192.168.56.56  another.test\r\n\r\n\n\n添加站点后，你需要从 Homestead 目录执行 `vagrant reload --provision` 命令以保证 Vagrant 加载新的站点。\r\n\r\n<a name=\"site-types\"></a>\r\n#### 站点类型\r\n\r\nHomestead 支持多种「类型」的站点，让你可以轻松运行不是基于 Laravel 的项目。 例如，我们可以使用 `statamic` 站点类型轻松地将 Statamic 应用程序添加到 Homestead：\r\n\r\n```yaml\r\nsites:\r\n    - map: statamic.test\r\n      to: /home/vagrant/my-symfony-project/web\r\n      type: \"statamic\"\r\n```\r\n可用的站点类型有： `apache`、`apigility`、`expressive`、`laravel`（默认）、`proxy`、`silverstripe`、`statamic`、`symfony2`、`symfony4` 和 `zf`。\r\n\r\n<a name=\"site-parameters\"></a>\r\n#### 站点参数\r\n\r\n你可以通过 `params` 站点指令向你的站点添加额外的 Nginx `fastcgi_param` 值：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n      params:\r\n          - key: FOO\r\n            value: BAR\r\n```\r\n\r\n<a name=\"environment-variables\"></a>\r\n### 环境变量\r\n\r\n你可以 `Homestead.yaml` 文件来定义全局环境变量：\r\n\r\n```yaml\r\nvariables:\r\n    - key: APP_ENV\r\n      value: local\r\n    - key: FOO\r\n      value: bar\r\n```\r\n\r\n更新 `Homestead.yaml` 文件后，请务必通过执行 `vagrant reload --provision` 命令重新配置机器。 这将更新所有已安装 PHP 版本的 PHP-FPM 配置，并为 `vagrant` 用户更新环境。\r\n\r\n<a name=\"ports\"></a>\r\n### 端口\r\n\r\n默认情况下，以下端口会转发到你的 Homestead 环境：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- **HTTP:** 8000 &rarr;  转发到 80\r\n- **HTTPS:** 44300 &rarr;  转发到 443\r\n\r\n</div>\r\n\r\n<a name=\"forwarding-additional-ports\"></a>\r\n#### 转发额外的端口\r\n\r\n如你所愿，你可以通过在你的 `Homestead.yaml` 文件中定义一个 `ports` 配置项来将额外的端口转发到 Vagrant 虚拟机。 更新 `Homestead.yaml` 文件后，请务必通过执行 `vagrant reload --provision` 命令重新载入虚拟机配置：\r\n\r\n```yaml\r\nports:\r\n    - send: 50000\r\n      to: 5000\r\n    - send: 7777\r\n      to: 777\r\n      protocol: udp\r\n```\r\n\r\n\n\n以下是你可能希望从主机映射到 Vagrant box 的其他 Homestead 服务的端口清单：\r\n\r\n<div class=\"content-list\" markdown=\"1\">\r\n\r\n- **SSH:** 2222 &rarr; 转发到 22\r\n- **ngrok UI:** 4040 &rarr; 转发到 4040\r\n- **MySQL:** 33060 &rarr; 转发到 3306\r\n- **PostgreSQL:** 54320 &rarr; 转发到 5432\r\n- **MongoDB:** 27017 &rarr; 转发到 27017\r\n- **Mailhog:** 8025 &rarr; 转发到 8025\r\n- **Minio:** 9600 &rarr; 转发到 9600\r\n\r\n</div>\r\n\r\n<a name=\"php-versions\"></a>\r\n### 多 PHP 版本\r\n\r\nHomestead 引入了对在同一虚拟机上运行多个版本的 PHP 的支持。 你可以在 `Homestead.yaml` 文件中指定用于特定站点的 PHP 版本。 可用的 PHP 版本有：「5.6」、「7.0」、「7.1」、「7.2」、「7.3」、「7.4」、「8.0」、「8.1」和「8.2」（默认）：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n      php: \"7.1\"\r\n```\r\n\r\n[在你的 Homestead 虚拟机中](#connecting-via-ssh)，你可以通过 CLI 使用任何支持的 PHP 版本：\r\n\r\n```shell\r\nphp5.6 artisan list\r\nphp7.0 artisan list\r\nphp7.1 artisan list\r\nphp7.2 artisan list\r\nphp7.3 artisan list\r\nphp7.4 artisan list\r\nphp8.0 artisan list\r\nphp8.1 artisan list\r\nphp8.2 artisan list\r\n```\r\n\r\n你可以通过在 Homestead 虚拟机中发出以下命令来更改 CLI 使用的默认 PHP 版本：\r\n\r\n```shell\r\nphp56\r\nphp70\r\nphp71\r\nphp72\r\nphp73\r\nphp74\r\nphp80\r\nphp81\r\nphp82\r\n```\r\n\r\n<a name=\"connecting-to-databases\"></a>\r\n### 连接到数据库\r\n\r\nHomestead 开箱即用地为 MySQL 和 PostgreSQL 配置了一个 `homestead` 数据库。如果你想用宿主机的数据库客户端连接到 MySQL 或 PostgreSQL 数据库，你可以通过连接 `127.0.0.1` （本地网络）的 `33060` 端口（MySQL） 或 `54320` 端口（PostgreSQL）。 两个数据库的用户名和密码都是 `homestead`/`secret`。\r\n\r\n> **注意**  \r\n> 只有在从宿主机连接到数据库时，你才需要使用这些非标准端口。 由于 Laravel 在虚拟机中运行，因此你将在 Laravel 应用程序的数据库配置文件中使用默认的 3306 和 5432 端口。\r\n\r\n\n\n<a name=\"database-backups\"></a>\r\n### 数据库备份\r\n\r\n当你的 Homestead 虚拟机被销毁时，Homestead 可以自动备份你的数据库。 要使用此功能，你必须使用 Vagrant 2.1.0 或更高版本。 或者，如果你使用的是旧版本的 Vagrant，则必须安装 `vagrant-triggers` 插件。要启用自动数据库备份，请将以下行添加到你的 `Homestead.yaml` 文件中：\r\n\r\n    backup: true\r\n\r\n配置完成后，当执行 `vagrant destroy` 命令时，Homestead 会将你的数据库导出到 `.backup/mysql_backup` 和 `.backup/postgres_backup` 目录。 如果你选择了[为项目单独安装](#per-project-installation) Homestead，你可以在项目安装 Homestead 的文件夹中找到这些目录，或者在你的项目根目录中找到它们。\r\n\r\n<a name=\"configuring-cron-schedules\"></a>\r\n### 配置 Cron 计划任务\r\n\r\nLaravel 提供了一种便捷方式来满足[任务调度](/docs/laravel/10.x/scheduling)，通过 Artisan 命令 `schedule:run` 实现了定时运行（每分钟执行一次）。 `schedule:run` 命令将检查在 `App\\Console\\Kernel` 类中定义的作业计划，以确定要运行哪些计划任务。\r\n\r\n如果你想为 Homestead 站点运行 `schedule:run` 命令，可以在定义站点时将 `schedule` 选项设置为 `true`：\r\n\r\n```yaml\r\nsites:\r\n    - map: homestead.test\r\n      to: /home/vagrant/project1/public\r\n      schedule: true\r\n```\r\n\r\n站点的 cron 作业将在 Homestead 虚拟机的 `/etc/cron.d` 目录中被定义。\r\n\r\n<a name=\"configuring-mailhog\"></a>\r\n### 配置 MailHog\r\n\r\n[MailHog](https://github.com/mailhog/MailHog) 会在你本地开发的过程中拦截应用程序发送的电子邮件，而不是将邮件实际发送给收件人。如果要使用 MailHog，你需要参考以下邮件配置并更新应用程序的 `.env` 文件：\r\n\r\n```ini\r\nMAIL_MAILER=smtp\r\nMAIL_HOST=localhost\r\nMAIL_PORT=1025\r\nMAIL_USERNAME=null\r\nMAIL_PASSWORD=null\r\nMAIL_ENCRYPTION=null\r\n```\r\n\r\n\n\n配置 MailHog 后，你可以通过 http://localhost:8025 访问 MailHog 仪表盘。\r\n\r\n<a name=\"configuring-minio\"></a>\r\n### 配置 Minio\r\n\r\n[Minio](https://github.com/minio/minio) 是一个具有 Amazon S3 兼容 API 的开源对象存储服务器。 要安装 Minio，请使用 [features](#installing-optional-features) 部分中的以下配置选项更新你的 `Homestead.yaml` 文件\r\n\r\n    minio: true\r\n\r\n默认情况下，Minio 在端口 9600 上可用。你可以通过访问 `http://localhost:9600` 访问 Minio 控制面板。 默认访问密钥是 `homestead`，而默认密钥是 `secretkey`。 访问 Minio 时，应始终使用区域 `us-east-1`\r\n\r\n为了使用 Minio，你需要在应用程序的 `config/filesystems.php` 配置文件中调整 S3 磁盘配置。 你需要将 `use_path_style_endpoint` 选项添加到磁盘配置中，并将 `url` 键更改为 `endpoint`:\r\n\r\n    's3' => [\r\n        'driver' => 's3',\r\n        'key' => env('AWS_ACCESS_KEY_ID'),\r\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n        'region' => env('AWS_DEFAULT_REGION'),\r\n        'bucket' => env('AWS_BUCKET'),\r\n        'endpoint' => env('AWS_URL'),\r\n        'use_path_style_endpoint' => true,\r\n    ]\r\n\r\n最后，确保你的 `.env` 文件包含以下选项：\r\n\r\n```ini\r\nAWS_ACCESS_KEY_ID=homestead\r\nAWS_SECRET_ACCESS_KEY=secretkey\r\nAWS_DEFAULT_REGION=us-east-1\r\nAWS_URL=http://localhost:9600\r\n```\r\n\r\n要配置 Minio 支持的「S3」存储桶，请在你的 `Homestead.yaml` 文件中添加 `buckets` 指令。 定义存储桶后，你应该在终端中执行 `vagrant reload --provision` 命令重载虚拟机：\r\n\r\n```yaml\r\nbuckets:\r\n    - name: your-bucket\r\n      policy: public\r\n    - name: your-private-bucket\r\n      policy: none\r\n```\r\n\r\n支持的 `policy` 值包括：`none`、`download`、`upload` 和 `public`。\r\n\r\n\n\n<a name=\"laravel-dusk\"></a>\r\n### Laravel Dusk 测试工具\r\n\r\n为了在 Homestead 中运行 [Laravel Dusk](/docs/laravel/10.x/duskk) 测试，你应该在 Homestead 配置中启用 [`webdriver` 功能](#installing-optional-features):\r\n\r\n```yaml\r\nfeatures:\r\n    - webdriver: true\r\n```\r\n\r\n启用 `webdriver` 功能后，你应该在终端中执行 `vagrant reload --provision` 命令重载虚拟机。\r\n\r\n<a name=\"sharing-your-environment\"></a>\r\n### 共享你的环境\r\n\r\n有时，你可能希望与同事或客户分享你目前正在做的事情。 Vagrant 通过 `vagrant share` 命令内置了对此的支持； 但是，如果你在 `Homestead.yaml` 文件中配置了多个站点，这个功能将不可用。\r\n\r\n为了解决这个问题，Homestead 包含了自己的 `share` 命令。 首先，通过 `vagrant ssh` [SSH 到你的 Homestead 虚拟机](#connecting-via-ssh) 并执行 `share homestead.test` 命令。 此命令将从你的 `Homestead.yaml` 配置文件中共享 `homestead.test` 站点。 你可以将任何其他配置的站点替换为 `homestead.test`：\r\n\r\n```shell\r\nshare homestead.test\r\n```\r\n\r\n运行该命令后，你将看到一个 Ngrok 屏幕出现，其中包含活动日志和共享站点的可公开访问的 URL。 如果你想指定自定义区域、子域或其他 Ngrok 运行时选项，你可以将它们添加到你的 `share` 命令中：\r\n\r\n```shell\r\nshare homestead.test -region=eu -subdomain=laravel\r\n```\r\n\r\n> **注意**  \r\n> 请记住，Vagrant 本质上是不安全的，并且你在运行 `share` 命令时会将虚拟机暴露在互联网上。\r\n\r\n<a name=\"debugging-and-profiling\"></a>\r\n## 调试和分析\r\n\r\n<a name=\"debugging-web-requests\"></a>\r\n### 使用 Xdebug 调试 Web 请求\r\n\r\n\n\nHomestead 支持使用 [Xdebug](https://xdebug.org) 进行步骤调试。例如，你可以在浏览器中访问一个页面，PHP 将连接到你的 IDE 以允许检查和修改正在运行的代码。\r\n\r\n默认情况下，Xdebug 将自动运行并准备好接受连接。 如果需要在 CLI 上启用 Xdebug，请在 Homestead 虚拟机中执行 `sudo phpenmod xdebug` 命令。接下来，按照 IDE 的说明启用调试。最后，配置你的浏览器以使用扩展或 [bookmarklet](https://www.jetbrains.com/phpstorm/marklets/) 触发 Xdebug。\r\n\r\n> **注意**  \r\n> Xdebug 导致 PHP 运行速度明显变慢。要禁用 Xdebug，请在 Homestead 虚拟机中运行 `sudo phpdismod xdebug` 并重新启动 FPM 服务。\r\n\r\n<a name=\"autostarting-xdebug\"></a>\r\n#### 自动启动 Xdebug\r\n\r\n在调试向 Web 服务器发出请求的功能测试时，自动启动调试比修改测试以通过自定义标头或 cookie 来触发调试更容易。 要强制 Xdebug 自动启动，请修改 Homestead 虚拟机中的 `/etc/php/7.x/fpm/conf.d/20-xdebug.ini` 文件并添加以下配置:\r\n\r\n```ini\r\n; 如果 Homestead.yaml 包含 IP 地址的不同子网，则这个 IP 地址可能会不一样\r\nxdebug.client_host = 192.168.10.1\r\nxdebug.mode = debug\r\nxdebug.start_with_request = yes\r\n```\r\n\r\n<a name=\"debugging-cli-applications\"></a>\r\n### 调试 CLI 应用程序\r\n\r\n要调试 PHP CLI 应用程序，请在 Homestead 虚拟机中使用 `xphp` shell 别名：\r\n\r\n    xphp /path/to/script\r\n\r\n<a name=\"profiling-applications-with-blackfire\"></a>\r\n### 使用 Blackfire 分析应用程序\r\n\r\n[Blackfire](https://blackfire.io/docs/introduction) 是一种用于分析 Web 请求和 CLI 应用程序的服务。它提供了一个交互式用户界面，可在调用图和时间线中显示配置文件数据。Blackfire 专为在开发、登台和生产中使用而构建，对最终用户没有任何开销。此外，Blackfire 还提供对代码和 `php.ini` 配置设置的性能、质量和安全检查。\r\n\r\n\n\n[Blackfire Player](https://blackfire.io/docs/player/index) 是一个开源的 Web 爬行、Web 测试和 Web 抓取应用程序，可以与 Blackfire 联合使用以编写分析场景的脚本。\r\n\r\n要启用 Blackfire，请使用 Homestead 配置文件中的「features」配置项：\r\n\r\n```yaml\r\nfeatures:\r\n    - blackfire:\r\n        server_id: \"server_id\"\r\n        server_token: \"server_value\"\r\n        client_id: \"client_id\"\r\n        client_token: \"client_value\"\r\n```\r\n\r\nBlackfire 服务器凭据和客户端凭据需要使用 [Blackfire 帐户](https://blackfire.io/signup)。 Blackfire 提供了多种选项来分析应用程序，包括 CLI 工具和浏览器扩展。 请查看 [Blackfire 文档](https://blackfire.io/docs/php/integrations/laravel/index)以获取更多详细信息。\r\n\r\n<a name=\"network-interfaces\"></a>\r\n## 网络接口\r\n\r\n`Homestead.yaml` 文件的 `networks` 属性为你的 Homestead 虚拟机配置网络接口。 你可以根据需要配置任意数量的接口：\r\n\r\n```yaml\r\nnetworks:\r\n    - type: \"private_network\"\r\n      ip: \"192.168.10.20\"\r\n```\r\n\r\n要启用 [bridged](https://www.vagrantup.com/docs/networking/public_network.html) 接口，请为将网络配置调整为 `bridge` 并将网络类型更改为 `public_network`：\r\n\r\n```yaml\r\nnetworks:\r\n    - type: \"public_network\"\r\n      ip: \"192.168.10.20\"\r\n      bridge: \"en1: Wi-Fi (AirPort)\"\r\n```\r\n\r\n要启用 [DHCP](https://www.vagrantup.com/docs/networking/public_network.html) 功能，你只需从配置中删除 `ip` 选项：\r\n\r\n```yaml\r\nnetworks:\r\n    - type: \"public_network\"\r\n      bridge: \"en1: Wi-Fi (AirPort)\"\r\n```\r\n\r\n<a name=\"extending-homestead\"></a>\r\n## 扩展 Homestead\r\n\r\n你可以使用 Homestead 目录根目录中的 `after.sh` 脚本扩展 Homestead。 在此文件中，你可以添加正确配置和自定义虚拟机所需的任何 shell 命令。\r\n\r\n\n\n当你自定义 Homestead 时，Ubuntu 可能会询问你是要保留软件包的原始配置还是使用新的配置文件覆盖它。 为了避免这种情况，你应该在安装软件包时使用以下命令，以避免覆盖 Homestead 之前编写的任何配置：\r\n\r\n```shell\r\nsudo apt-get -y \\\r\n    -o Dpkg::Options::=\"--force-confdef\" \\\r\n    -o Dpkg::Options::=\"--force-confold\" \\\r\n    install package-name\r\n```\r\n\r\n<a name=\"user-customizations\"></a>\r\n### 用户自定义\r\n\r\n与你的团队一起使用 Homestead 时，你可能需要调整 Homestead 以更好地适应你的个人开发风格。 为此，你可以在 Homestead 目录（包含 `Homestead.yaml` 文件的同一目录）的根目录中创建一个 `user-customizations.sh` 文件。 在此文件中，你可以进行任何你想要的自定义； 但是， `user-customizations.sh` 不应受版本管理工具控制。\r\n\r\n<a name=\"provider-specific-settings\"></a>\r\n## 针对虚拟机软件的特殊设置\r\n\r\n<a name=\"provider-specific-virtualbox\"></a>\r\n### VirtualBox\r\n\r\n<a name=\"natdnshostresolver\"></a>\r\n#### `natdnshostresolver`\r\n\r\n默认情况下，Homestead 将 `natdnshostresolver` 设置配置为 `on`。 这允许 Homestead 使用你的主机操作系统的 DNS 设置。 如果你想覆盖此行为，请将以下配置选项添加到你的 `Homestead.yaml` 文件中：\r\n\r\n```yaml\r\nprovider: virtualbox\r\nnatdnshostresolver: 'off'\r\n```\r\n\r\n<a name=\"symbolic-links-on-windows\"></a>\r\n#### Windows 上的符号链接\r\n\r\n如果符号链接在你的 Windows 机器上不能正常工作，你可能需要将以下代码块添加到你的 `Vagrantfile`：\r\n\r\n```ruby\r\nconfig.vm.provider \"virtualbox\" do |v|\r\n    v.customize [\"setextradata\", :id, \"VBoxInternal2/SharedFoldersEnableSymlinksCreate/v-root\", \"1\"]\r\nend\r\n```\r\n\n","p":"docs/homestead.html"},{"t":"horizon (Laravel Horizon)","d":"\n# Laravel Horizon\r\n\r\n- [介绍](#introduction)\r\n- [安装](#installation)\r\n    - [配置](#configuration)\r\n    - [均衡策略](#balancing-strategies)\r\n    - [控制面板授权](#dashboard-authorization)\r\n    - [静默作业](#silenced-jobs)\r\n- [升级 Horizon](#upgrading-horizon)\r\n- [运行 Horizon](#running-horizon)\r\n    - [部署 Horizon](#deploying-horizon)\r\n- [标记](#tags)\r\n- [通知](#notifications)\r\n- [指标](#metrics)\r\n- [删除失败的作业](#deleting-failed-jobs)\r\n- [从队列中清除作业](#clearing-jobs-from-queues)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n> **提示**  \r\n> 在深入了解 Laravel Horizon 之前，您应该熟悉 Laravel 的基础 [队列服务](/docs/laravel/10.x/queues)。 Horizon 为 Laravel 的队列增加了额外的功能，如果你还不熟悉 Laravel 提供的基本队列功能，这些功能可能会让人感到困惑。\r\n\r\n[Laravel Horizon](https://github.com/laravel/horizon) 为你的 Laravel [Redis queues](/docs/laravel/10.x/queues).提供了一个美观的仪表盘和代码驱动的配置。它可以方便的监控队列系统的关键指标：任务吞吐量、运行时间、作业失败情况。\r\n\r\n在使用 Horizon 时，所有队列的 worker 配置都存储在一个简单的配置文件中。通过在受版本控制的文件中定义应用程序的 worker 配置，你可以在部署应用程序时轻松扩展或修改应用程序的队列 worker。\r\n\r\n<img src=\"https://laravel.com/img/docs/horizon-example.png\">\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n> **注意**\r\n> Laravel Horizon 要求你使用 [Redis](https://redis.io) 来为你的队列服务。因此，你应该确保在应用程序的 `config/queue.php` 配置文件中将队列连接设置为 `redis`。\r\n\r\n你可以使用 Composer 将 Horizon 安装到你的 Laravel 项目里：\r\n\r\n```shell\r\ncomposer require laravel/horizon\r\n```\r\n\r\n\n\nHorizon 安装之后，使用 `horizon:install` Artisan 命令发布资源：\r\n\r\n```shell\r\nphp artisan horizon:install\r\n```\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\nHorizon 资源发布之后，其主要配置文件会被分配到 `config/horizon.php` 文件。可以用这个配置文件配置工作选项，每个配置选项包含一个用途描述，请务必仔细研究这个文件。\r\n\r\n\r\n>**注意：**Horizon 在内部使用名为 `horizon` 的 Redis 连接。此 Redis 连接名称是保留的，不应分配给 `database.php` 配置文件中的另一个 Redis 连接或作为 `horizon.php` 配置文件中的 `use` 选项的值。\r\n\r\n<a name=\"environments\"></a>\r\n#### 环境配置\r\n\r\n安装后，你需要熟悉的重点 Horizon 配置选项是 `environments` 配置选项。此配置选项定义了你的应用程序运行的一系列环境，并为每个环境定义了工作进程选项。默认情况下，此条目包含　`生产 (production)`　和 `本地 (local)`环境。简而言之，你可以根据自己的需要自由添加更多环境：\r\n\r\n    'environments' => [\r\n        'production' => [\r\n            'supervisor-1' => [\r\n                'maxProcesses' => 10,\r\n                'balanceMaxShift' => 1,\r\n                'balanceCooldown' => 3,\r\n            ],\r\n        ],\r\n\r\n        'local' => [\r\n            'supervisor-1' => [\r\n                'maxProcesses' => 3,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n当你启动 Horizon 时，它将使用指定应用程序运行环境所配置的 worker 进程选项。通常，环境配置由 `APP_ENV` [环境变量](/docs/laravel/10.x/configuration#determining-the-current-environment) 的值确定。例如，默认的 `local` Horizon 环境配置为启动三个工作进程，并自动平衡分配给每个队列的工作进程数量。默认的「生产」环境配置为最多启动 10 个 worker 进程，并自动平衡分配给每个队列的 worker 进程数量。\r\n\r\n> **注意：**你应该确保你的 `horizon` 配置文件的 `environments` 部分包含计划在其上运行 Horizon 的每个 [环境](/docs/laravel/10.x/configuration#environment-configuration) 的配置。\r\n\r\n\n\n<a name=\"supervisors\"></a>\r\n#### Supervisors\r\n\r\n正如你在 Horizon 的默认配置文件中看到的那样。每个环境可以包含一个或多个 Supervisor 配置。默认情况下，配置文件将这个Supervisor 定义为 `supervisor-1`；但是，你可以随意命名你的 Supervisor。每个 Supervisor 负责监督一组 worker，并负责平衡队列之间的 worker。\r\n\r\n如果你想定义一组在指定环境中运行的新 worker，可以向相应的环境添加额外的 Supervisor。如果你想为应用程序使用的特定队列定义不同的平衡策略或 worker 数量，也可以选择这样做。\r\n\r\n<a name=\"default-values\"></a>\r\n#### 默认值\r\n\r\n在 Horizon 的默认配置文件中，你会注意到一个 `defaults` 配置选项。这个配置选项指定应用程序的 [supervisors](#supervisors) 的默认值。Supervisor 的默认配置值将合并到每个环境的 Supervisor  配置中，让你在定义 Supervisor 时避免不必要的重复工作。\r\n\r\n<a name=\"balancing-strategies\"></a>\r\n### 均衡策略\r\n\r\n与 Laravel 的默认队列系统不同，Horizon 允许你从三个平衡策略中进行选择：`simple`， `auto`， 和 `false`。`simple` 策略是配置文件的默认选项，它会在进程之间平均分配进入的任务：\r\n\r\n    'balance' => 'simple',\r\n\r\n`auto` 策略根据队列的当前工作负载来调整每个队列的工作进程数量。举个例子，如果你的 `notifications` 队列有 1000 个等待的任务，而你的 `render` 队列是空的，那么 Horizon 将为 `notifications` 队列分配更多的工作线程，直到队列为空。\r\n\r\n\n\n当使用 `auto` 策略时，你可以定义 `minProcesses` 和 `maxProcesses` 的配置选项来控制 Horizon  扩展进程的最小和最大数量：\r\n\r\n    'environments' => [\r\n        'production' => [\r\n            'supervisor-1' => [\r\n                'connection' => 'redis',\r\n                'queue' => ['default'],\r\n                'balance' => 'auto',\r\n                'autoScalingStrategy' => 'time',\r\n                'minProcesses' => 1,\r\n                'maxProcesses' => 10,\r\n                'balanceMaxShift' => 1,\r\n                'balanceCooldown' => 3,\r\n                'tries' => 3,\r\n            ],\r\n        ],\r\n    ],\r\n\r\n`autoScalingStrategy` 配置值决定了 Horizon 是根据清除队列所需的总时间（`time` 策略）还是根据队列上的作业总数（`size` 策略）来为队列分配更多的Worker 进程。\r\n\r\n\r\n`balanceMaxShift` 和 `balanceCooldown` 配置项可以确定 Horizon 将以多快的速度扩展进程，在上面的示例中，每 3 秒钟最多创建或销毁一个新进程，你可以根据应用程序的需要随意调整这些值。\r\n\r\n当 `balance` 选项设置为 `false` 时，将使用默认的 Laravel 行为，它按照队列在配置中列出的顺序处理队列。\r\n\r\n<a name=\"dashboard-authorization\"></a>\r\n### 控制面板授权\r\n\r\nHorizon 在 `/horizon` 上显示了一个控制面板。默认情况下，你只能在 `local` 环境中访问这个面板。在你的 `app/Providers/HorizonServiceProvider.php` 文件中，有一个 [授权拦截器（Gates）](/docs/laravel/10.x/authorization#gates) 的方法定义，该拦截器用于控制在**非本地**环境中对 Horizon 的访问。末可以根据需要修改此方法，来限制对 Horizon 的访问：\r\n\r\n    /**\r\n     * 注册 Horizon 授权\r\n     *\r\n     * 此方法决定了谁可以在非本地环境中访问 Horizon\r\n     */\r\n    protected function gate(): void\r\n    {\r\n        Gate::define('viewHorizon', function (User $user) {\r\n            return in_array($user->email, [\r\n                'taylor@laravel.com',\r\n            ]);\r\n        });\r\n    }\r\n\r\n\n\n<a name=\"alternative-authentication-strategies\"></a>\r\n#### 可替代的身份验证策略\r\n\r\n需要留意的是，Laravel 会自动将经过认证的用户注入到拦截器（Gate）闭包中。如果你的应用程序通过其他方法（例如 IP 限制）提供 Horizon 安全性保障，那么你访问 Horizon 用户可能不需要实现这个「登录」动作。因此，你需要将上面的 `function ($user)` 更改为 `function ($user = null)` 以强制 Laravel 跳过身份验证。\r\n\r\n<a name=\"silenced-jobs\"></a>\r\n### 静默作业\r\n\r\n有时，你可能对查看某些由你的应用程序或第三方软件包发出的工作不感兴趣。与其让这些作业在你的「已完成作业」列表中占用空间，你可以让它们静默。要开始的话，在你的应用程序的 `horizon` 配置文件中的 `silenced` 配置选项中添加作业的类名。\r\n\r\n    'silenced' => [\r\n        App\\Jobs\\ProcessPodcast::class,\r\n    ],\r\n\r\n或者，你希望静默的作业可以实现 `Laravel\\Horizon\\Contracts\\Silenced` 接口。如果一个作业实现了这个接口，它将自动被静默，即使它不在 `silenced` 配置阵列中。\r\n\r\n    use Laravel\\Horizon\\Contracts\\Silenced;\r\n\r\n    class ProcessPodcast implements ShouldQueue, Silenced\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        // ...\r\n    }\r\n\r\n<a name=\"upgrading-horizon\"></a>\r\n## 升级 Horizon\r\n\r\n当你升级到 Horizon 的一个新的主要版本时，你需要仔细阅读 [升级指南](https://github.com/laravel/horizon/blob/master/UPGRADE.)。\r\n\r\n此外，升级到新的 Horizon 版本时，你应该重新发布 Horizon 资源：\r\n\r\n```shell\r\nphp artisan horizon:publish\r\n```\r\n\r\n为了使资源文件保持最新并避免以后的更新中出现问题，你可以将以下  `horizon:publish`  命令添加到 `composer.json` 文件中的 `post-update-cmd` 脚本中：\r\n\r\n```json\r\n{\r\n    \"scripts\": {\r\n        \"post-update-cmd\": [\r\n            \"@php artisan vendor:publish --tag=laravel-assets --ansi --force\"\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n\n\n<a name=\"running-horizon\"></a>\r\n## 运行 Horizon\r\n\r\n在 `config/horizon.php` 中配置了你的 workers 之后，你可以使用 `horizon` Artisan 命令启动 Horizon。只需这一个命令你就可以启动你的所有已配置的 workers：\r\n\r\n```shell\r\nphp artisan horizon\r\n```\r\n\r\n你可以暂停 Horizon 进程，并使用 `horizon:pause` 和 `horizon:continue` Artisan 命令指示它继续处理任务：\r\n\r\n```shell\r\nphp artisan horizon:pause\r\n\r\nphp artisan horizon:continue\r\n```\r\n\r\n你还可以使用 `horizon:pause-supervisor` 和 `horizon:continue-supervisor` Artisan 命令暂停和继续指定的 Horizon [supervisors](#supervisors)：\r\n\r\n```shell\r\nphp artisan horizon:pause-supervisor supervisor-1\r\n\r\nphp artisan horizon:continue-supervisor supervisor-1\r\n```\r\n\r\n你可以使用 `horizon:status` Artisan 命令检查 Horizon 进程的当前状态：\r\n\r\n```shell\r\nphp artisan horizon:status\r\n```\r\n\r\n你可以使用 `horizon:terminate` Artisan 命令优雅地终止机器上的主 Horizon 进程。Horizon 会等当前正在处理的所有任务都完成后退出：\r\n\r\n```shell\r\nphp artisan horizon:terminate\r\n```\r\n\r\n<a name=\"deploying-horizon\"></a>\r\n### 部署 Horizon\r\n\r\n如果要将 Horizon 部署到一个正在运行的服务器上，应该配置一个进程监视器来监视 `php artisan horizon` 命令，并在它意外退出时重新启动它。\r\n\r\n在将新代码部署到服务器时，你需要终止 Horizon 主进程，以便进程监视器重新启动它并接收代码的更改。\r\n\r\n```shell\r\nphp artisan horizon:terminate\r\n```\r\n\r\n<a name=\"installing-supervisor\"></a>\r\n\n\n#### 安装 Supervisor\r\n\r\nSupervisor 是一个用于 Linux 操作系统的进程监视器。如果 `Horizon` 进程被退出或终止，Supervisor 将自动重启你的 `Horizon` 进程。如果要在 Ubuntu 上安装 Supervisor，你可以使用以下命令。如果你不使用 Ubuntu，也可以使用操作系统的包管理器安装 Supervisor：\r\n\r\n```shell\r\nsudo apt-get install supervisor\r\n```\r\n\r\n> **技巧：**如果你觉得自己配置 Supervisor 难如登天，可以考虑使用 [Laravel Forge](https://forge.laravel.com)，它将自动为你的 Laravel 项目安装和配置 Supervisor。\r\n\r\n<a name=\"supervisor-configuration\"></a>\r\n#### Supervisor 配置\r\n\r\nSupervisor 配置文件通常存储在 `/etc/supervisor/conf.d` 目录下。在此目录中，你可以创建任意数量的配置文件，这些配置文件会告诉 supervisor 如何监视你的进程。例如，让我们创建一个 `horizon.conf` 文件，它启动并监视一个 `horizon` 进程：\r\n\r\n```ini\r\n[program:horizon]\r\nprocess_name=%(program_name)s\r\ncommand=php /home/forge/example.com/artisan horizon\r\nautostart=true\r\nautorestart=true\r\nuser=forge\r\nredirect_stderr=true\r\nstdout_logfile=/home/forge/example.com/horizon.log\r\nstopwaitsecs=3600\r\n```\r\n\r\n在定义 Supervisor 配置时，你应该确保 `stopwaitsecs` 的值大于最长运行作业所消耗的秒数。否则，Supervisor 可能会在作业处理完之前就将其杀死。\r\n\r\n> **注意：**虽然上面的例子对基于Ubuntu的服务器有效，但其他服务器操作系统对监督员配置文件的位置和文件扩展名可能有所不同。请查阅你的服务器的文档以了解更多信息。\r\n\r\n<a name=\"starting-supervisor\"></a>\r\n#### 启动 Supervisor\r\n\r\n创建了配置文件后，可以使用以下命令更新 Supervisor 配置并启动进程：\r\n\r\n```shell\r\nsudo supervisorctl reread\r\n\r\nsudo supervisorctl update\r\n\r\nsudo supervisorctl start horizon\r\n```\r\n\r\n> **技巧：**关于 Supervisor 的更多信息，可以查阅 [Supervisor 文档](http://supervisord.org/index.html)。\r\n\r\n\n\n<a name=\"tags\"></a>\r\n## 标记 (Tags)\r\n\r\nHorizon 允许你将 `tags` 分配给任务，包括邮件、事件广播、通知和排队的事件监听器。实际上，Horizon 会根据附加到作业上的有 Eloquent 模型，智能地、自动地标记大多数任务。例如，看看下面的任务：\r\n\r\n    <?php\r\n\r\n    namespace App\\Jobs;\r\n\r\n    use App\\Models\\Video;\r\n    use Illuminate\\Bus\\Queueable;\r\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n    use Illuminate\\Foundation\\Bus\\Dispatchable;\r\n    use Illuminate\\Queue\\InteractsWithQueue;\r\n    use Illuminate\\Queue\\SerializesModels;\r\n\r\n    class RenderVideo implements ShouldQueue\r\n    {\r\n        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n        /**\r\n         * 创建一个新的任务实例\r\n         */\r\n        public function __construct(\r\n            public Video $video,\r\n        ) {}\r\n\r\n        /**\r\n         * 执行任务\r\n         */\r\n        public function handle(): void\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n\r\n如果此任务与 `App\\Models\\Video` 实例一起排队，且该实例的 `id` 为 `1`，则该作业将自动接收 `App\\Models\\Video:1` 标记。这是因为 Horizon 将为任何有 Eloquent 的模型检查任务的属性。如果找到了有 Eloquent 的模型，Horizon 将智能地使用模型的类名和主键标记任务：\r\n\r\n    use App\\Jobs\\RenderVideo;\r\n    use App\\Models\\Video;\r\n\r\n    $video = Video::find(1);\r\n\r\n    RenderVideo::dispatch($video);\r\n\r\n<a name=\"manually-tagging-jobs\"></a>\r\n#### 手动标记作业\r\n\r\n如果你想手动定义你的一个队列对象的标签，你可以在类上定义一个 `tags` 方法：\r\n\r\n    class RenderVideo implements ShouldQueue\r\n    {\r\n        /**\r\n         * 获取应该分配给任务的标记\r\n         *\r\n         * @return array<int, string>\r\n         */\r\n        public function tags(): array\r\n        {\r\n            return ['render', 'video:'.$this->video->id];\r\n        }\r\n    }\r\n\r\n<a name=\"notifications\"></a>\r\n## 通知\r\n\r\n> **注意：** 当配置 Horizon 发送 Slack 或 SMS 通知时，你应该查看 [相关通知驱动程序的先决条件](/docs/laravel/10.x/notifications)。\r\n\r\n\n\n如果你希望在一个队列有较长的等待时间时得到通知，你可以使用 `Horizon::routeMailNotificationsTo`, `Horizon::routeSlackNotificationsTo`, 和 `Horizon::routeSmsNotificationsTo` 方法。你可以通过应用程序的 `App\\Providers\\HorizonServiceProvider` 中的 `boot` 方法来调用这些方法：\r\n\r\n\r\n    /**\r\n     * 服务引导\r\n     */\r\n    public function boot(): void\r\n    {\r\n        parent::boot();\r\n\r\n        Horizon::routeSmsNotificationsTo('15556667777');\r\n        Horizon::routeMailNotificationsTo('example@example.com');\r\n        Horizon::routeSlackNotificationsTo('slack-webhook-url', '#channel');\r\n    }\r\n\r\n<a name=\"configuring-notification-wait-time-thresholds\"></a>\r\n#### 配置通知等待时间阈值\r\n\r\n你可以在 `config/horizon.php` 的配置文件中配置多少秒算是「长等待」。你可以用该文件中的 `waits` 配置选项控制每个 连接 / 队列 组合的长等待阈值：\r\n\r\n    'waits' => [\r\n        'redis:default' => 60,\r\n        'redis:critical,high' => 90,\r\n    ],\r\n\r\n<a name=\"metrics\"></a>\r\n## 指标\r\n\r\nHorizon 有一个指标控制面板，它提供了任务和队列的等待时间和吞吐量等信息。要让这些信息显示在这个控制面板上，你应该配置 Horizon 的 `snapshot` Artisan 命令，通过你的应用程序的 [调度器](/docs/laravel/10.x/scheduling) 每五分钟运行一次：\r\n\r\n    /**\r\n     * 定义应用程序的命令调度\r\n     */\r\n    protected function schedule(Schedule $schedule): void\r\n    {\r\n        $schedule->command('horizon:snapshot')->everyFiveMinutes();\r\n    }\r\n\r\n<a name=\"deleting-failed-jobs\"></a>\r\n## 删除失败的作业\r\n\r\n如果你想删除失败的作业，可以使用 `horizon:forget` 命令。 `horizon:forget` 命令接受失败作业的 ID 或 UUID 作为其唯一参数：\r\n\r\n```shell\r\nphp artisan horizon:forget 5\r\n```\r\n\r\n<a name=\"clearing-jobs-from-queues\"></a>\r\n## 从队列中清除作业\r\n\r\n如果你想从应用程序的默认队列中删除所有作业，你可以使用 `horizon:clear` Artisan 命令执行此操作：\r\n\r\n```shell\r\nphp artisan horizon:clear\r\n```\r\n\r\n你可以设置 `queue` 选项来从特定队列中删除作业：\r\n\r\n```shell\r\nphp artisan horizon:clear --queue=emails\r\n```\r\n\n","p":"docs/horizon.html"},{"t":"jetstream (Jetstream)","d":"\n# Jetstream\r\n\r\n请查看 [Laravel Jetstream](https://jetstream.laravel.com/3.x/introduction.html) 文档.\n","p":"docs/jetstream.html"},{"t":"mix (Laravel Mix)","d":"\n# Laravel Mix\r\n\r\n- [介绍](#introduction)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Mix](https://github.com/laravel-mix/laravel-mix) 是一个由 [Laracasts](https://laracasts.com) 的创始人 Jeffrey Way 开发的包，它提供了一个流畅的API，用于定义 [Webpack](https://webpack.js.org) 构建步骤，以在 Laravel 应用程序中使用多种常见的 CSS 和 JavaScript 预处理器。\r\n\r\n换句话说，Mix 让编译和压缩应用程序的 CSS 和 JavaScript 文件变得轻而易举。您可以通过简单的方法链接，流畅地定义资源文件管道。例如：\r\n\r\n```js\r\nmix.js('resources/js/app.js', 'public/js')\r\n    .postCss('resources/css/app.css', 'public/css');\r\n```\r\n如果您曾经因为开始使用 Webpack 和资源编译而感到困惑和不知所措，那么您会喜欢上 Laravel Mix 。然而，在开发应用程序时，并不需要强制使用它；您可以自由选择任何资源文件管道工具，甚至不使用任何工具。\r\n\r\n> **注意**  \r\n> 在新安装 Laravel 中，Vite 已经取代了 Laravel Mix 。如果您需要 Mix 的文档，请访问 [Laravel Mix 官方](https://laravel-mix.com/) 网站。如果您想切换到 Vite，请阅读我们的 [Vite 迁移指南](https://github.com/laravel/vite-plugin/blob/main/UPGRADE.md#migrating-from-laravel-mix-to-vite)。\n","p":"docs/mix.html"},{"t":"octane (Laravel Octane)","d":"\n# Laravel Octane\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n- [服务器先决条件](#server-prerequisites)\r\n    - [RoadRunner](#roadrunner)\r\n    - [Swoole](#swoole)\r\n- [为应用程序提供服务](#serving-your-application)\r\n    - [通过 HTTPS 服务应用程序](#serving-your-application-via-https)\r\n    - [通过 Nginx 提供服务](#serving-your-application-via-nginx)\r\n    - [监听文件修改](#watching-for-file-changes)\r\n    - [指定 Worker 数量](#specifying-the-worker-count)\r\n    - [指定最大请求数量](#specifying-the-max-request-count)\r\n    - [重载 Workers](#reloading-the-workers)\r\n    - [停止服务](#stopping-the-server)\r\n- [依赖注入与 Octane](#dependency-injection-and-octane)\r\n    - [容器注入](#container-injection)\r\n    - [请求注入](#request-injection)\r\n    - [配置文件注入](#configuration-repository-injection)\r\n- [管理内存泄漏](#managing-memory-leaks)\r\n- [并发任务](#concurrent-tasks)\r\n- [计时与间隔](#ticks-and-intervals)\r\n- [Octane 缓存](#the-octane-cache)\r\n- [表](#tables)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Octane](https://github.com/laravel/octane) 通过使用高性能应用程序服务器为您的应用程序提供服务来增强您的应用程序的性能，包括 [Open Swoole](https://openswoole.com/)，[Swoole](https://github.com/swoole/swoole-src)，和 [RoadRunner](https://roadrunner.dev)。Octane 启动您的应用程序一次，将其保存在内存中，然后以极快的速度向它提供请求。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\nOctane 可以通过 Composer 包管理器安装：\r\n\r\n```shell\r\ncomposer require laravel/octane\r\n```\r\n\r\n安装 Octane 后，您可以执行 `octane:install` 命令，该命令会将 Octane 的配置文件安装到您的应用程序中：\r\n\r\n```shell\r\nphp artisan octane:install\r\n```\r\n\r\n<a name=\"server-prerequisites\"></a>\r\n## 服务器先决条件\r\n\r\n> **注意**\r\n> Laravel Octane 需要 [PHP 8.1+](https://php.net/releases/).\r\n\r\n<a name=\"roadrunner\"></a>\r\n### RoadRunner\r\n\r\n[RoadRunner](https://roadrunner.dev) 由使用 Go 构建的 RoadRunner 二进制文件提供支持。当您第一次启动基于 RoadRunner 的 Octane 服务器时，Octane 将为您提供下载和安装 RoadRunner 二进制文件。\r\n\r\n\n\n<a name=\"roadrunner-via-laravel-sail\"></a>\r\n#### 通过 Laravel Sail 使用 RoadRunner\r\n\r\n如果你打算使用 [Laravel Sail](/docs/laravel/10.x/sail) 开发应用，你应该运行如下命令安装 Octane 和 RoadRunner:\r\n\r\n```shell\r\n./vendor/bin/sail up\r\n\r\n./vendor/bin/sail composer require laravel/octane spiral/roadrunner\r\n```\r\n\r\n接下来，你应该启动一个 Sail Shell，并运行 `rr` 可执行文件检索基于 Linux 的最新版 RoadRunner 二进制文件：\r\n\r\n```shell\r\n./vendor/bin/sail shell\r\n\r\n# Within the Sail shell...\r\n./vendor/bin/rr get-binary\r\n```\r\n\r\n安装完 RoadRunner 二进制文件后，你可以退出 Sail Shell 会话。然后，需要调整 Sail 用来保持应用运行的 `supervisor.conf` 文件。首先，请执行 `sail:publish` Artisan 命令：\r\n\r\n```shell\r\n./vendor/bin/sail artisan sail:publish\r\n```\r\n\r\n接着，更新应用 `docker/supervisord.confd` 文件中的 `command` 指令，这样 Sail 就可以使用 Octane 作为服务器，而非 PHP 开发服务器，运行服务了：\r\n\r\n```ini\r\ncommand=/usr/bin/php -d variables_order=EGPCS /var/www/html/artisan octane:start --server=roadrunner --host=0.0.0.0 --rpc-port=6001 --port=80\r\n```\r\n\r\n最后，请确保 `rr` 二进制文件是可执行的并重新构建 Sail 镜像：\r\n\r\n```shell\r\nchmod +x ./rr\r\n\r\n./vendor/bin/sail build --no-cache\r\n```\r\n\r\n<a name=\"swoole\"></a>\r\n### Swoole\r\n\r\n如果你打算使用 Swoole 服务器来运行 Laravel Octane 应用，你必须安装 Swoole PHP 组件。通常可以通过 PECL 安装：\r\n\r\n```shell\r\npecl install swoole\r\n```\r\n\r\n<a name=\"openswoole\"></a>\r\n#### Open Swoole\r\n\r\n如果你想要使用 Open Swoole 服务器运行 Laravel Octane 应用，你必须安装 Open Swoole PHP 扩展。通常可以通过 PECL 完成安装：\r\n\r\n```shell\r\npecl install openswoole\r\n```\r\n\r\n\n\n通过 Open Swoole 使用 Laravel Octane，可以获得 Swoole 提供的相同功能，如并发任务，计时和间隔。\r\n\r\n<a name=\"swoole-via-laravel-sail\"></a>\r\n#### 通过 Laravel Sail 使用 Swoole\r\n\r\n> **注意**\r\n> 在通过 Sail 提供 Octane 应用程序之前，请确保你使用的是最新版本的 Laravel Sail 并在应用程序的根目录中执行 `./vendor/bin/sail build --no-cache`。\r\n\r\n你可以使用 Laravel 的官方 Docker 开发环境 [Laravel Sail](/docs/laravel/10.x/sail) 开发基于 Swoole 的 Octane 应用程序。 Laravel Sail 默认包含 Swoole 扩展。但是，你仍然需要调整 Sail 使用的 `supervisor.conf` 件以保持应用运行。首先，执行 `sail:publish` Artisan 命令：\r\n\r\n```shell\r\n./vendor/bin/sail artisan sail:publish\r\n```\r\n\r\n接下来，更新应用程序的 `docker/supervisord.conf` 文件的 `command` 指令，使得 Sail 使用 Octane 替代 PHP 开发服务器：\r\n\r\n```ini\r\ncommand=/usr/bin/php -d variables_order=EGPCS /var/www/html/artisan octane:start --server=swoole --host=0.0.0.0 --port=80\r\n```\r\n\r\n最后，构建你的 Sail 镜像：\r\n\r\n```shell\r\n./vendor/bin/sail build --no-cache\r\n```\r\n\r\n<a name=\"swoole-configuration\"></a>\r\n#### Swoole 配置\r\n\r\nSwoole 支持一些额外的配置选项，如果需要，你可以将它们添加到你的 `octane` 配置文件中。因为它们很少需要修改，所以这些选项不包含在默认配置文件中：\r\n\r\n```php\r\n'swoole' => [\r\n    'options' => [\r\n        'log_file' => storage_path('logs/swoole_http.log'),\r\n        'package_max_length' => 10 * 1024 * 1024,\r\n    ],\r\n],\r\n```\r\n\r\n<a name=\"serving-your-application\"></a>\r\n## 为应用程序提供服务\r\n\r\nOctane 服务器可以通过 `octane:start`  Artisan 命令启动。此命令将使用由应用程序的 `octane` 配置文件的 `server` 配置选项指定的服务器：\r\n\r\n```shell\r\nphp artisan octane:start\r\n```\r\n\r\n\n\n默认情况下，Octane 将在 8000 端口上启动服务器（可配置），因此你可以在 Web 浏览器中通过 `http://localhost:8000` 访问你的应用程序。\r\n\r\n<a name=\"serving-your-application-via-https\"></a>\r\n### 通过 HTTPS 为应用程序提供服务\r\n\r\n默认情况下，通过 Octane 运行的应用程序会生成以 `http://` 为前缀的链接。当使用 HTTPS 时，可将在应用的 `config/octane.php` 配置文件中使用的 `OCTANE_HTTPS` 环境变量设置为 `true`。当此配置值设置为 `true` 时，Octane 将指示 Laravel 在所有生成的链接前加上 `https://`：\r\n\r\n```php\r\n'https' => env('OCTANE_HTTPS', false),\r\n```\r\n\r\n<a name=\"serving-your-application-via-nginx\"></a>\r\n### 通过 Nginx 为应用提供服务\r\n\r\n> **提示**\r\n> 如果你还没有准备好管理自己的服务器配置，或者不习惯配置运行健壮的 Laravel Octane 应用所需的所有各种服务，请查看 [Laravel Forge](https://forge.laravel.com)。\r\n\r\n在生产环境中，你应该在传统 Web 服务器（例如 Nginx 或 Apache）之后为 Octane 应用提供服务。 这样做将允许 Web 服务器为你的静态资源（例如图片和样式表）提供服务，并管理 SSL 证书。\r\n\r\n在下面的 Nginx 配置示例文件中，Nginx 将向在端口 8000 上运行的 Octane 服务器提供站点的静态资源和代理请求：\r\n\r\n```nginx\r\nmap $http_upgrade $connection_upgrade {\r\n    default upgrade;\r\n    ''      close;\r\n}\r\n\r\nserver {\r\n    listen 80;\r\n    listen [::]:80;\r\n    server_name domain.com;\r\n    server_tokens off;\r\n    root /home/forge/domain.com/public;\r\n\r\n    index index.php;\r\n\r\n    charset utf-8;\r\n\r\n    location /index.php {\r\n        try_files /not_exists @octane;\r\n    }\r\n\r\n    location / {\r\n        try_files $uri $uri/ @octane;\r\n    }\r\n\r\n    location = /favicon.ico { access_log off; log_not_found off; }\r\n    location = /robots.txt  { access_log off; log_not_found off; }\r\n\r\n    access_log off;\r\n    error_log  /var/log/nginx/domain.com-error.log error;\r\n\r\n    error_page 404 /index.php;\r\n\r\n    location @octane {\r\n        set $suffix \"\";\r\n\r\n        if ($uri = /index.php) {\r\n            set $suffix ?$query_string;\r\n        }\r\n\r\n        proxy_http_version 1.1;\r\n        proxy_set_header Host $http_host;\r\n        proxy_set_header Scheme $scheme;\r\n        proxy_set_header SERVER_PORT $server_port;\r\n        proxy_set_header REMOTE_ADDR $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection $connection_upgrade;\r\n\r\n        proxy_pass http://127.0.0.1:8000$suffix;\r\n    }\r\n}\r\n```\r\n\r\n\n\n<a name=\"watching-for-file-changes\"></a>\r\n### 监视文件更改\r\n\r\n由于 Octane 服务器启动时应用程序被加载到内存中一次，因此对应用程序文件的任何更改都不会在您刷新浏览器时反映出来。例如，添加到 `routes/web.php` 文件的路由定义在服务器重新启动之前不会反映出来。为了方便起见，你可以使用 `--watch` 标志指示 Octane 在应用程序中的任何文件更改时自动重新启动服务器：\r\n\r\n```shell\r\nphp artisan octane:start --watch\r\n```\r\n\r\n在使用此功能之前，您应该确保在本地开发环境中安装了 [Node](https://nodejs.org/)。此外，你还应该在项目中安装 [Chokidar](https://github.com/paulmillr/chokidar) 文件监视库：\r\n\r\n```shell\r\nnpm install --save-dev chokidar\r\n```\r\n\r\n你可以使用应用程序的 `config/octane.php` 配置文件中的 `watch` 配置选项来配置应该被监视的目录和文件。\r\n\r\n<a name=\"specifying-the-worker-count\"></a>\r\n### 指定工作进程数\r\n\r\n默认情况下，Octane 会为机器提供的每个 CPU 核心启动一个应用程序请求工作进程。这些工作进程将用于在进入应用程序时服务传入的 HTTP 请求。你可以使用 `--workers` 选项手动指定要启动的工作进程数量，当调用 `octane:start` 命令时：\r\n\r\n```shell\r\nphp artisan octane:start --workers=4\r\n```\r\n\r\n如果你使用 Swoole 应用程序服务器，则还可以指定要启动的任务工作进程数量：\r\n\r\n```shell\r\nphp artisan octane:start --workers=4 --task-workers=6\r\n```\r\n\r\n<a name=\"specifying-the-max-request-count\"></a>\r\n\n\n### 指定最大请求数量\r\n\r\n为了防止内存泄漏，Octane 在处理完 500 个请求后会优雅地重新启动任何 worker。要调整这个数字，你可以使用 `--max-requests` 选项：\r\n\r\n```shell\r\nphp artisan octane:start --max-requests=250\r\n```\r\n\r\n<a name=\"reloading-the-workers\"></a>\r\n### 重载 Workers\r\n\r\n你可以使用 `octane:reload` 命令优雅地重新启动 Octane 服务器的应用 workers。通常，这应该在部署后完成，以便将新部署的代码加载到内存中并用于为后续请求提供服务：\r\n\r\n```shell\r\nphp artisan octane:reload\r\n```\r\n\r\n<a name=\"stopping-the-server\"></a>\r\n### 停止服务器\r\n\r\n你可以使用  `octane:stop` Artisan 命令停止 Octane 服务器：\r\n\r\n```shell\r\nphp artisan octane:stop\r\n```\r\n\r\n<a name=\"checking-the-server-status\"></a>\r\n#### 检查服务器状态\r\n\r\n你可以使用 `octane:status` Artisan 命令检查 Octane 服务器的当前状态：\r\n\r\n```shell\r\nphp artisan octane:status\r\n```\r\n\r\n<a name=\"dependency-injection-and-octane\"></a>\r\n## 依赖注入和 Octane\r\n\r\n由于 Octane 只启动你的应用程序一次，并在服务请求时将其保留在内存中，所以在构建你的应用程序时，你应该考虑一些注意事项。例如，你的应用程序的服务提供者的 `register` 和 `boot` 方法将只在 request worker 最初启动时执行一次。在随后的请求中，将重用相同的应用程序实例。\r\n\r\n鉴于这个机制，在将应用服务容器或请求注入任何对象的构造函数时应特别小心。这样一来，该对象在随后的请求中就可能有一个稳定版本的容器或请求。\r\n\r\nOctane 会在两次请求之间自动处理重置任何第一方框架的状态。然而，Octane 并不总是知道如何重置由你的应用程序创建的全局状态。因此，你应该知道如何以一种对 Octane 友好的方式来构建你的应用程序。下面，我们将讨论在使用 Octane 时可能引起问题的最常见情况。\r\n\r\n\n\n<a name=\"container-injection\"></a>\r\n### 容器注入\r\n\r\n通常来说，你应该避免将应用服务容器或 HTTP 请求实例注入到其他对象的构造函数中。例如，下面的绑定将整个应用服务容器注入到绑定为单例的对象中：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n/**\r\n * Register any application services.\r\n */\r\npublic function register(): void\r\n{\r\n    $this->app->singleton(Service::class, function (Application $app) {\r\n        return new Service($app);\r\n    });\r\n}\r\n```\r\n\r\n在这个例子中，如果在应用程序引导过程中解析 `Service` 实例，容器将被注入到该服务中，并且该容器将在后续的请求中保留。这对于你的特定应用程序**可能**不是一个问题，但是它可能会导致容器意外地缺少后来在引导过程中添加的绑定或后续请求中添加的绑定。\r\n\r\n为了解决这个问题，你可以停止将绑定注册为单例，或者你可以将一个容器解析器闭包注入到服务中，该闭包总是解析当前的容器实例：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Container\\Container;\r\nuse Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n$this->app->bind(Service::class, function (Application $app) {\r\n    return new Service($app);\r\n});\r\n\r\n$this->app->singleton(Service::class, function () {\r\n    return new Service(fn () => Container::getInstance());\r\n});\r\n```\r\n\r\n全局的 `app` 辅助函数和 `Container::getInstance()` 方法将始终返回应用程序容器的最新版本。\r\n\r\n<a name=\"request-injection\"></a>\r\n### 请求注入\r\n\r\n通常来说，你应该避免将应用服务容器或 HTTP 请求实例注入到其他对象的构造函数中。例如，下面的绑定将整个请求实例注入到绑定为单例的对象中：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n/**\r\n * Register any application services.\r\n */\r\npublic function register(): void\r\n{\r\n    $this->app->singleton(Service::class, function (Application $app) {\r\n        return new Service($app['request']);\r\n    });\r\n}\r\n```\r\n\r\n\n\n在这个例子中，如果在应用程序启动过程中解析 `Service` 实例，则会将 HTTP 请求注入到服务中，并且相同的请求将由 `Service` 实例保持在后续请求中。因此，所有标头、输入和查询字符串数据以及所有其他请求数据都将不正确。\r\n\r\n为了解决这个问题，你可以停止将绑定注册为单例，或者你可以将请求解析器闭包注入到服务中，该闭包始终解析当前请求实例。或者，最推荐的方法是在运行时将对象所需的特定请求信息传递给对象的方法之一：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n$this->app->bind(Service::class, function (Application $app) {\r\n    return new Service($app['request']);\r\n});\r\n\r\n$this->app->singleton(Service::class, function (Application $app) {\r\n    return new Service(fn () => $app['request']);\r\n});\r\n\r\n// Or...\r\n\r\n$service->method($request->input('name'));\r\n```\r\n\r\n全局的 `request` 帮助函数将始终返回应用程序当前处理的请求，因此可以在应用程序中安全使用它。\r\n\r\n> **警告**\r\n> 在控制器方法和路由闭包中类型提示 Illuminate\\Http\\Request 实例是可以接受的。\r\n\r\n<a name=\"configuration-repository-injection\"></a>\r\n### 配置库注入\r\n\r\n一般来说，你应该避免将配置库实例注入到其他对象的构造函数中。例如，以下绑定将配置库注入到绑定为单例的对象中：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n/**\r\n * Register any application services.\r\n */\r\npublic function register(): void\r\n{\r\n    $this->app->singleton(Service::class, function (Application $app) {\r\n        return new Service($app->make('config'));\r\n    });\r\n}\r\n```\r\n\r\n\n\n在这个示例中，如果在请求之间的配置值更改了，那么这个服务将无法访问新的值，因为它依赖于原始存储库实例。\r\n\r\n作为解决方法，你可以停止将绑定注册为单例，或者将配置存储库解析器闭包注入到类中：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Container\\Container;\r\nuse Illuminate\\Contracts\\Foundation\\Application;\r\n\r\n$this->app->bind(Service::class, function (Application $app) {\r\n    return new Service($app->make('config'));\r\n});\r\n\r\n$this->app->singleton(Service::class, function () {\r\n    return new Service(fn () => Container::getInstance()->make('config'));\r\n});\r\n```\r\n\r\n全局 `config` 将始终返回配置存储库的最新版本，因此在应用程序中使用是安全的。\r\n\r\n<a name=\"managing-memory-leaks\"></a>\r\n### 管理内存泄漏\r\n\r\n请记住，Octane 在请求之间保留应用程序，因此将数据添加到静态维护的数组中将导致内存泄漏。例如，以下控制器具有内存泄漏，因为对应用程序的每个请求将继续向静态的 `$data` 数组添加数据：\r\n\r\n```php\r\nuse App\\Service;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Str;\r\n\r\n/**\r\n * 处理传入的请求。\r\n */\r\npublic function index(Request $request): array\r\n{\r\n    Service::$data[] = Str::random(10);\r\n\r\n    return [\r\n        // ...\r\n    ];\r\n}\r\n```\r\n\r\n在构建应用程序时，你应特别注意避免创建此类内存泄漏。建议在本地开发期间监视应用程序的内存使用情况，以确保您不会在应用程序中引入新的内存泄漏。\r\n\r\n<a name=\"concurrent-tasks\"></a>\r\n## 并发任务\r\n\r\n> **警告**\r\n> 此功能需要 [Swoole](#swoole)。\r\n\r\n\n\n当使用 Swoole 时，你可以通过轻量级的后台任务并发执行操作。你可以使用 Octane 的 `concurrently` 方法实现此目的。你可以将此方法与 PHP 数组解构结合使用，以检索每个操作的结果：\r\n\r\n```php\r\nuse App\\User;\r\nuse App\\Server;\r\nuse Laravel\\Octane\\Facades\\Octane;\r\n\r\n[$users, $servers] = Octane::concurrently([\r\n    fn () => User::all(),\r\n    fn () => Server::all(),\r\n]);\r\n```\r\n\r\n由 Octane 处理的并发任务利用 Swoole 的 「task workers」 并在与传入请求完全不同的进程中执行。可用于处理并发任务的工作程序的数量由 `octane:start` 命令的 `--task-workers` 指令确定：\r\n\r\n```shell\r\nphp artisan octane:start --workers=4 --task-workers=6\r\n```\r\n\r\n在调用 `concurrently` 方法时，你应该不要提供超过 1024 个任务，因为 Swoole 任务系统强制执行此限制。\r\n\r\n<a name=\"ticks-and-intervals\"></a>\r\n## 刻度和间隔\r\n\r\n> **警告**\r\n> 此功能需要 [Swoole](#swoole).\r\n\r\n当使用 Swoole 时，你可以注册定期执行的 「tick」 操作。你可以通过 `tick` 方法注册 「tick」 回调函数。提供给 `tick` 方法的第一个参数应该是一个字符串，表示定时器的名称。第二个参数应该是在指定间隔内调用的可调用对象。\r\n\r\n在此示例中，我们将注册一个闭包，每 10 秒调用一次。通常，`tick` 方法应该在你应用程序的任何服务提供程序的 `boot` 方法中调用：\r\n\r\n```php\r\nOctane::tick('simple-ticker', fn () => ray('Ticking...'))\r\n        ->seconds(10);\r\n```\r\n\r\n使用 `immediate` 方法，你可以指示 Octane 在 Octane 服务器初始启动时立即调用 tick 回调，并在 N 秒后每次调用：\r\n\r\n```php\r\nOctane::tick('simple-ticker', fn () => ray('Ticking...'))\r\n        ->seconds(10)\r\n        ->immediate();\r\n```\r\n\r\n\n\n<a name=\"the-octane-cache\"></a>\r\n## Octane 缓存\r\n\r\n> **警告**\r\n> 此功能需要 [Swoole](#swoole).\r\n\r\n使用 Swoole 时，你可以利用 Octane 缓存驱动程序，该驱动程序提供每秒高达 200 万次的读写速度。因此，这个缓存驱动程序是需要从缓存层中获得极高读写速度的应用程序的绝佳选择。\r\n\r\n该缓存驱动程序由 [Swoole tables](https://www.swoole.co.uk/docs/modules/swoole-table) 驱动。缓存中的所有数据可供服务器上的所有工作进程访问。但是，当服务器重新启动时，缓存数据将被清除：\r\n\r\n```php\r\nCache::store('octane')->put('framework', 'Laravel', 30);\r\n```\r\n\r\n> **注意**\r\n> Octane 缓存中允许的最大条目数可以在您的应用程序的 octane 配置文件中定义。\r\n\r\n<a name=\"cache-intervals\"></a>\r\n### 缓存间隔\r\n\r\n除了 Laravel 缓存系统提供的典型方法外，Octane 缓存驱动程序还提供了基于间隔的缓存。这些缓存会在指定的间隔自动刷新，并应在一个应用程序服务提供程序的 `boot` 方法中注册。例如，以下缓存将每五秒刷新一次：\r\n\r\n```php\r\nuse Illuminate\\Support\\Str;\r\n\r\nCache::store('octane')->interval('random', function () {\r\n    return Str::random(10);\r\n}, seconds: 5);\r\n```\r\n\r\n<a name=\"tables\"></a>\r\n## 表格\r\n\r\n> **警告**\r\n> 此功能需要 [Swoole](#swoole).\r\n\r\n使用 Swoole 时，你可以定义和与自己的任意 [Swoole tables](https://www.swoole.co.uk/docs/modules/swoole-table) 进行交互。Swoole tables 提供极高的性能吞吐量，并且可以通过服务器上的所有工作进程访问其中的数据。但是，当它们内部的数据在服务器重新启动时将被丢失。\r\n\n\n表在应用 `octane` 配置文件 `tables` 数组配置中设定。最大运行 1000 行的示例表已经配置。像下面这样，字符串行支持的最大长度在列类型后面设置：\r\n\r\n```php\r\n'tables' => [\r\n    'example:1000' => [\r\n        'name' => 'string:1000',\r\n        'votes' => 'int',\r\n    ],\r\n],\r\n```\r\n\r\n通过 `Octane::table` 方法访问表：\r\n\r\n```php\r\nuse Laravel\\Octane\\Facades\\Octane;\r\n\r\nOctane::table('example')->set('uuid', [\r\n    'name' => 'Nuno Maduro',\r\n    'votes' => 1000,\r\n]);\r\n\r\nreturn Octane::table('example')->get('uuid');\r\n```\r\n\r\n> **注意**\r\n> Swoole table 支持的列类型有： `string` ，`int` 和 `float` 。\r\n\n","p":"docs/octane.html"},{"t":"passport (Laravel Passport)","d":"# Laravel Passport\r\n\r\n- [简介](#introduction)\r\n    - [选择 Passport 还是 Sanctum?](#passport-or-sanctum)\r\n- [安装](#installation)\r\n    - [部署 Passport](#deploying-passport)\r\n    - [自定义迁移](#migration-customization)\r\n    - [升级 Passport](#upgrading-passport)\r\n- [配置](#configuration)\r\n    - [客户端密钥 Hashing](#client-secret-hashing)\r\n    - [Token 生命周期](#token-lifetimes)\r\n    - [重载默认模型](#overriding-default-models)\r\n    - [重载路由](#overriding-routes)\r\n- [发布访问令牌](#issuing-access-tokens)\r\n    - [客户端管理](#managing-clients)\r\n    - [请求令牌](#requesting-tokens)\r\n    - [刷新令牌](#refreshing-tokens)\r\n    - [撤销令牌](#revoking-tokens)\r\n    - [清除令牌](#purging-tokens)\r\n- [通过 PKCE 发布令牌](#code-grant-pkce)\r\n    - [创建客户端](#creating-a-auth-pkce-grant-client)\r\n    - [请求令牌](#requesting-auth-pkce-grant-tokens)\r\n- [密码授权方式的令牌](#password-grant-tokens)\r\n    - [创建密码授权方式客户端](#creating-a-password-grant-client)\r\n    - [请求令牌](#requesting-password-grant-tokens)\r\n    - [请求所有的作用域](#requesting-all-scopes)\r\n    - [自定义用户提供者](#customizing-the-user-provider)\r\n    - [自定义用户名字段](#customizing-the-username-field)\r\n    - [自定义密码验证](#customizing-the-password-validation)\r\n- [隐式授权令牌](#implicit-grant-tokens)\r\n- [客户端授权令牌](#client-credentials-grant-tokens)\r\n- [个人访问令牌](#personal-access-tokens)\r\n    - [创建个人访问令牌的客户端](#creating-a-personal-access-client)\r\n    - [管理个人访问令牌](#managing-personal-access-tokens)\r\n- [路由保护](#protecting-routes)\r\n    - [通过中间件](#via-middleware)\r\n    - [传递访问令牌](#passing-the-access-token)\r\n- [令牌作用域](#token-scopes)\r\n    - [定义作用域](#defining-scopes)\r\n    - [默认作用域](#default-scope)\r\n    - [给令牌分配作用域](#assigning-scopes-to-tokens)\r\n    - [检查作用域](#checking-scopes)\r\n- [使用 JavaScript 接入 API](#consuming-your-api-with-javascript)\r\n- [事件](#events)\r\n- [测试](#testing)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Passport](https://github.com/laravel/passport) 可以在几分钟之内为你的应用程序提供完整的 OAuth2 服务端实现。Passport 是基于由 Andy Millington 和 Simon Hamp 维护的 [League OAuth2 server](https://github.com/thephpleague/oauth2-server) 建立的。\r\n\r\n> **注意**  \r\n> 本文档假定你已熟悉 OAuth2 。如果你并不了解 OAuth2 ，阅读之前请先熟悉下 OAuth2 的 [常用术语](https://oauth2.thephpleague.com/terminology/) 和特性。\r\n\r\n\r\n\r\n<a name=\"passport-or-sanctum\"></a>\r\n### Passport 还是 Sanctum?\r\n\r\n在开始之前，我们希望你先确认下是 Laravel Passport 还是 [Laravel Sanctum](/docs/laravel/10.x/sanctum) 能为你的应用提供更好的服务。如果你的应用确确实实需要支持 OAuth2，那没疑问，你需要选用 Laravel Passport。\r\n\r\n然而，如果你只是试图要去认证一个单页应用，或者手机应用，或者发布 API 令牌，你应该选用 [Laravel Sanctum](/docs/laravel/10.x/sanctum)。 Laravel Sanctum 不支持 OAuth2，它提供了更为简单的 API 授权开发体验。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n在开始使用之前，使用 Composer 包管理器安装 Passport：\r\n\r\n```shell\r\ncomposer require laravel/passport\r\n```\r\n\r\nPassport 的 [服务提供器](/docs/laravel/10.x/providers) 注册了自己的数据库迁移脚本目录， 所以你应该在安装软件包完成后迁移你自己的数据库。 Passport 的迁移脚本将为你的应用创建用于存储 OAuth2 客户端和访问令牌的数据表：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n接下来，你需要执行 Artisan 命令 `passport:install`。这个命令将会创建一个用于生成安全访问令牌的加密秘钥。另外，这个命令也将创建用于生成访问令牌的 「个人访问」 客户端和 「密码授权」 客户端 ：\r\n\r\n```shell\r\nphp artisan passport:install\r\n```\r\n\r\n> **技巧**  \r\n> 如果你想用使用 UUID 作为 Passport `Client` 模型的主键，代替默认的自动增长整形字段，请在安装 Passport 时使用 [uuids 参数](#client-uuids) 。\r\n\r\n在执行 `passport:install` 命令后， 添加 `Laravel\\Passport\\HasApiTokens` trait 到你的 `App\\Models\\User` 模型中。 这个 trait 会提供一些帮助方法用于检查已认证用户的令牌和权限范围。如果你的模型已经在使用 `Laravel\\Sanctum\\HasApiTokens` trait，你可以删除该 trait：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Laravel\\Passport\\HasApiTokens;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use HasApiTokens, HasFactory, Notifiable;\r\n    }\r\n\r\n\r\n\r\n最后，在您的应用的 `config/auth.php` 配置文件中，您应当定义一个 `api` 的授权看守器，并且将其 `driver` 选项设置为 `passport` 。这个调整将会让您的应用程序使用 Passport 的 `TokenGuard` 来鉴权 API 接口请求：\r\n\r\n    'guards' => [\r\n        'web' => [\r\n            'driver' => 'session',\r\n            'provider' => 'users',\r\n        ],\r\n\r\n        'api' => [\r\n            'driver' => 'passport',\r\n            'provider' => 'users',\r\n        ],\r\n    ],\r\n\r\n<a name=\"client-uuids\"></a>\r\n#### 客户端 UUID\r\n\r\n您也可以在运行 `passport:install` 命令的时候使用 `--uuids` 选项。这个参数将会让 Passport 使用 UUID 来替代默认的自增长形式的 Passport `Client` 模型主键。在您运行带有 `--uuids` 参数的 `passport:install` 命令后，您将得到关于禁用 Passport 默认迁移的相关指令说明：\r\n\r\n```shell\r\nphp artisan passport:install --uuids\r\n```\r\n\r\n<a name=\"deploying-passport\"></a>\r\n### 部署 Passport\r\n\r\n在您第一次部署 Passport 到您的应用服务器时，您需要执行 `passport:keys` 命令。该命令用于生成 Passport 用于生成 access token 的一个加密密钥。生成的加密密钥不应到添加到源代码控制系统中：\r\n\r\n```shell\r\nphp artisan passport:keys\r\n```\r\n\r\n如有必要，您可以定义 Passport 的密钥应当加载的位置。您可以使用 `Passport:loadKeysFrom` 方法来实现。通常，这个方法应当在您的 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中调用：\r\n\r\n    /**\r\n     * Register any authentication / authorization services.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Passport::loadKeysFrom(__DIR__.'/../secrets/oauth');\r\n    }\r\n\r\n<a name=\"loading-keys-from-the-environment\"></a>\r\n#### 从环境中加载密钥\r\n\r\n此外，您可以使用 `vendor:publish` Artisan 命令来发布您的 Passport 配置文件：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=passport-config\r\n```\r\n\r\n\r\n\r\n在发布配置文件之后，您可以将加密密钥配置为环境变量，再加载它们：\r\n\r\n```ini\r\nPASSPORT_PRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY-----\r\n<private key here>\r\n-----END RSA PRIVATE KEY-----\"\r\n\r\nPASSPORT_PUBLIC_KEY=\"-----BEGIN PUBLIC KEY-----\r\n<public key here>\r\n-----END PUBLIC KEY-----\"\r\n```\r\n\r\n<a name=\"migration-customization\"></a>\r\n### 自定义迁移\r\n\r\n如果您不打算使用 Passport 的默认迁移，您应当在 `App\\Providers\\AppServiceProvider` 类的 `register` 方法中调用 `Passport::ignoreMigrations` 方法。您可以 使用 `vendor:publish` Artisan 命令来导出默认的迁移文件：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=passport-migrations\r\n```\r\n\r\n<a name=\"upgrading-passport\"></a>\r\n### Passport 的升级\r\n\r\n当升级到 Passport 的主要版本时，请务必查阅 [升级指南](https://github.com/laravel/passport/blob/master/UPGRADE.).\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"client-secret-hashing\"></a>\r\n### 客户端密钥的 Hash 加密\r\n\r\n如果您希望客户端密钥在存储到数据库时使用 Hash 对其进行加密，您应当在 `App\\Provider\\AuthServiceProvider` 类的 `boot` 方法中调用 `Passport:hashClientSecrets` ：\r\n\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    Passport::hashClientSecrets();\r\n\r\n一旦启用后，所有的客户端密钥都将只在创建的时候显示。由于明文的客户端密钥没有存储到数据库中，因此一旦其丢失后便无法恢复。\r\n\r\n<a name=\"token-lifetimes\"></a>\r\n### Token 生命周期\r\n\r\n默认情况下，Passport 会颁发长达一年的长期 token 。如果您想要配置一个更长或更短的 token 生命周期，您可以在 `App\\Provider\\AuthServiceProvider` 类的 `boot` 方法中调用 `tokensExpiresIn` 、`refresgTokensExpireIn` 和 `personalAccessTokensExpireIn` 方法：\r\n\r\n    /**\r\n     * 注册身份验证/授权服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Passport::tokensExpireIn(now()->addDays(15));\r\n        Passport::refreshTokensExpireIn(now()->addDays(30));\r\n        Passport::personalAccessTokensExpireIn(now()->addMonths(6));\r\n    }\r\n\r\n> **注意**  \r\n>  Passport 数据库表中的 `expires_at` 列是只读的，仅仅用于显示。在颁发 token 的时候，Passport 将过期信息存储在已签名和加密的 token 中。如果你想让 token 失效，你应当 [撤销它](#revoking-tokens) 。\r\n\r\n\r\n\r\n<a name=\"overriding-default-models\"></a>\r\n### 重写 Passport 的默认模型\r\n\r\n您可以通过定义自己的模型并继承相应的 Passport 模型来实现自由自由扩展 Passport 内部使用的模型：\r\n\r\n    use Laravel\\Passport\\Client as PassportClient;\r\n\r\n    class Client extends PassportClient\r\n    {\r\n        // ...\r\n    }\r\n\r\n在定义您的模型之后，您可以在 `Laravel\\Passport\\Passport` 类中指定 Passport 使用您自定义的模型。一样的，您应该在应用程序的 `App\\Providers\\AuthServiceProvider` 类中的 `boot` 方法中指定 Passport 使用您自定义的模型：\r\n\r\n    use App\\Models\\Passport\\AuthCode;\r\n    use App\\Models\\Passport\\Client;\r\n    use App\\Models\\Passport\\PersonalAccessClient;\r\n    use App\\Models\\Passport\\RefreshToken;\r\n    use App\\Models\\Passport\\Token;\r\n\r\n    /**\r\n     * 注册任意认证/授权服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Passport::useTokenModel(Token::class);\r\n        Passport::useRefreshTokenModel(RefreshToken::class);\r\n        Passport::useAuthCodeModel(AuthCode::class);\r\n        Passport::useClientModel(Client::class);\r\n        Passport::usePersonalAccessClientModel(PersonalAccessClient::class);\r\n    }\r\n\r\n<a name=\"overriding-routes\"></a>\r\n### 重写路由\r\n\r\n您可能希望自定义 Passport 定义的路由。要实现这个功能，第一步，您需要在应用程序的 `AppServiceProvider` 中的 `register` 方法中添加 `Passport:ignoreRoutes` 语句，以忽略由 Passport 注册的路由：\r\n\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    /**\r\n     * 注册任意的应用程序服务。\r\n     */\r\n    public function register(): void\r\n    {\r\n        Passport::ignoreRoutes();\r\n    }\r\n\r\n然后，您可以复制 Passport [在自己的文件中](https://github.com/laravel/passport/blob/11.x/routes/web.php) 定义的路由到应用程序的 `routes/web.php` 文件中，并且将其修改为您喜欢的任何形式：\r\n\r\n    Route::group([\r\n        'as' => 'passport.',\r\n        'prefix' => config('passport.path', 'oauth'),\r\n        'namespace' => 'Laravel\\Passport\\Http\\Controllers',\r\n    ], function () {\r\n        // Passport 路由……\r\n    });\r\n\r\n<a name=\"issuing-access-tokens\"></a>\r\n## 发布访问令牌\r\n\r\n通过授权码使用 OAuth2 是大多数开发人员熟悉的方式。使用授权码方式时，客户端应用程序会将用户重定向到你的服务器，在那里他们会批准或拒绝向客户端发出访问令牌的请求。\r\n\r\n\r\n\r\n<a name=\"managing-clients\"></a>\r\n### 客户端管理\r\n\r\n首先，开发者如果想要搭建一个与你的服务端接口交互的应用端，需要在服务端这边注册一个「客户端」。通常，这需要开发者提供应用程序的名称和一个 URL，在应用软件的使用者授权请求后，应用程序会被重定向到该 URL。\r\n\r\n<a name=\"the-passportclient-command\"></a>\r\n#### `passport:client` 命令\r\n\r\n使用 Artisan 命令 `passport:client` 是一种最简单的创建客户端的方式。 这个命令可以创建你自己私有的客户端，用于 Oauth2 功能测试。 当你执行 `client` 命令后， Passport 将会给你更多关于客户端的提示，以及生成的客户端 ID\r\n\r\n```shell\r\nphp artisan passport:client\r\n```\r\n\r\n**多重定向 URL 地址的设置**\r\n\r\n如果你想为你的客户端提供多个重定向 URL ，你可以在执行 `Passport:client` 命令出现提示输入 URL 地址的时候，输入用逗号分割的多个 URL 。任何包含逗号的 URL 都需要先执行 URL 转码：\r\n\r\n```shell\r\nhttp://example.com/callback,http://examplefoo.com/callback\r\n```\r\n\r\n<a name=\"clients-json-api\"></a>\r\n#### JSON API\r\n\r\n因为应用程序的开发者是无法使用 `client` 命令的，所以 Passport 提供了 JSON 格式的 API ，用于创建客户端。 这解决了你还要去手动创建控制器代码（代码用于添加，更新，删除客户端）的麻烦。\r\n\r\n但是，你需要结合 Passport 的 JSON API 接口和你的前端面板管理页面， 为你的用户提供客户端管理功能。接下里，我们会回顾所有用于管理客户端的的 API 接口。方便起见，我们使用 [Axios](https://github.com/axios/axios) 模拟对端点的 HTTP 请求。\r\n\r\n\r\n\r\n这些 JSON API 接口被 `web` 和 `auth` 两个中间件保护着，因此，你只能从你的应用中调用。 外部来源的调用是被禁止的。\r\n\r\n<a name=\"get-oauthclients\"></a>\r\n#### `GET /oauth/clients`\r\n\r\n下面的路由将为授权用户返回所有的客户端。最主要的作用是列出所有的用户客户端，接下来就可以编辑或删除它们了：\r\n\r\n```js\r\naxios.get('/oauth/clients')\r\n    .then(response => {\r\n        console.log(response.data);\r\n    });\r\n```\r\n\r\n<a name=\"post-oauthclients\"></a>\r\n#### `POST /oauth/clients`\r\n\r\n下面的路由用于创建新的客户端。 它需要两个参数： `客户端名称`和`重定向URL` 地址。 `重定向URL` 地址是使用者在授权或者拒绝授权后被重定向到的地方。\r\n\r\n客户端被创建后，将会生成客户端 ID 和客户端秘钥。 这对值用于从你的应用获取访问令牌。 调用下面的客户端创建路由将创建新的客户端实例：\r\n\r\n```js\r\nconst data = {\r\n    name: 'Client Name',\r\n    redirect: 'http://example.com/callback'\r\n};\r\n\r\naxios.post('/oauth/clients', data)\r\n    .then(response => {\r\n        console.log(response.data);\r\n    })\r\n    .catch (response => {\r\n        // 列出响应的错误...\r\n    });\r\n```\r\n\r\n<a name=\"put-oauthclientsclient-id\"></a>\r\n#### `PUT /oauth/clients/{client-id}`\r\n\r\n下面的路由用来更新客户端。它需要两个参数： 客户端名称和重定向 URL 地址。 重定向 URL 地址是用户在授权或者拒绝授权后被重定向到的地方。路由将返回更新后的客户端实例：\r\n\r\n```js\r\nconst data = {\r\n    name: 'New Client Name',\r\n    redirect: 'http://example.com/callback'\r\n};\r\n\r\naxios.put('/oauth/clients/' + clientId, data)\r\n    .then(response => {\r\n        console.log(response.data);\r\n    })\r\n    .catch (response => {\r\n        // 列出响应的错误...\r\n    });\r\n```\r\n\r\n\r\n\r\n<a name=\"delete-oauthclientsclient-id\"></a>\r\n#### `DELETE /oauth/clients/{client-id}`\r\n\r\n下面的路由用于删除客户端：\r\n\r\n```js\r\naxios.delete('/oauth/clients/' + clientId)\r\n    .then(response => {\r\n        // ...\r\n    });\r\n```\r\n\r\n<a name=\"requesting-tokens\"></a>\r\n### 请求令牌\r\n\r\n<a name=\"requesting-tokens-redirecting-for-authorization\"></a>\r\n#### 授权重定向\r\n\r\n客户端创建好后，开发者使用 client ID 和秘钥向你的应用服务器发送请求，以便获取授权码和访问令牌。 首先，接收到请求的业务端服务器会重定向到你应用的 `/oauth/authorize` 路由上，如下所示：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    Route::get('/redirect', function (Request $request) {\r\n        $request->session()->put('state', $state = Str::random(40));\r\n\r\n        $query = http_build_query([\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'response_type' => 'code',\r\n            'scope' => '',\r\n            'state' => $state,\r\n            // 'prompt' => '', // \"none\", \"consent\", or \"login\"\r\n        ]);\r\n\r\n        return redirect('http://passport-app.test/oauth/authorize?'.$query);\r\n    });\r\n\r\n`prompt` 参数可用于指定 Passport 应用程序的认证行为。\r\n\r\n如果 `prompt` 值为 `none`，如果用户还没有通过 Passport 应用程序的认证，Passport 将总是抛出一个认证错误。如果值是 `同意`，Passport 将总是显示授权批准屏幕，即使所有的作用域以前都被授予消费应用程序。如果值是 `login`，Passport 应用程序将总是提示用户重新登录到应用程序，即使他们已经有一个现有的会话。\r\n\r\n如果没有提供 `prompt` 值，只有当用户以前没有授权访问所请求范围的消费应用程序时，才会提示用户进行授权。\r\n\r\n> **技巧：**请记住，`/oauth/authorize` 路由默认已经在 `Passport::route` 方法中定义，你无需手动定义它。\r\n\r\n\r\n\r\n<a name=\"approving-the-request\"></a>\r\n#### 请求认证\r\n\r\n当接收到一个请求后， Passport 会自动展示一个模板页面给用户，用户可以选择授权或者拒绝授权。如果请求被认证，用户将被重定向到之前业务服务器设置的 `redirect_uri` 上去。 这个 `redirect_uri` 就是客户端在创建时提供的重定向地址参数。\r\n\r\n\r\n如果你想自定义授权页面，你可以先使用 Artisan 命令 `vendor:publish` 发布 Passport 的视图页面。 被发布的视图页面位于 `resources/views/vendor/passport` 路径下：\r\n\r\n```shell\r\nphp artisan vendor:publish --tag=passport-views\r\n```\r\n\r\n有时，你可能希望跳过授权提示，比如在授权第一梯队客户端的时候。你可以通过 [继承 `Client` 模型](#overriding-default-models)并实现 `skipsAuthorization` 方法。如果 `skipsAuthorization` 方法返回 `true`， 客户端就会直接被认证并立即重定向到设置的重定向地址：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models\\Passport;\r\n\r\n    use Laravel\\Passport\\Client as BaseClient;\r\n\r\n    class Client extends BaseClient\r\n    {\r\n        /**\r\n         * 确定客户端是否应跳过授权提示。\r\n         */\r\n        public function skipsAuthorization(): bool\r\n        {\r\n            return $this->firstParty();\r\n        }\r\n    }\r\n\r\n<a name=\"requesting-tokens-converting-authorization-codes-to-access-tokens\"></a>\r\n#### 授权码到授权令牌的转化\r\n\r\n如果用户授权了访问，他们会被重定向到业务服务端。首先，业务端服务需要检查 `state` 参数是否和重定向之前存储的值一致。 如果 state 参数的值正确，业务端服务器需要对你的应用发起获取 access token 的 `POST` 请求。 请求需要携带有授权码，授权码就是之前用户授权后由你的应用服务器生成的码：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Route::get('/callback', function (Request $request) {\r\n        $state = $request->session()->pull('state');\r\n\r\n        throw_unless(\r\n            strlen($state) > 0 && $state === $request->state,\r\n            InvalidArgumentException::class\r\n        );\r\n\r\n        $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n            'grant_type' => 'authorization_code',\r\n            'client_id' => 'client-id',\r\n            'client_secret' => 'client-secret',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'code' => $request->code,\r\n        ]);\r\n\r\n        return $response->json();\r\n    });\r\n\r\n\r\n\r\n调用路由 `/oauth/token` 将返回一串 json 字符串，包含了 `access_token`, `refresh_token` 和 `expires_in` 属性。`expires_in` 属性的值是 access_token 剩余的有效时间。\r\n\r\n> **技巧：**就和 `/oauth/authorize` 路由一样， `/oauth/token` 路由已经在 `Passport::routes` 方法中定义，你无需再自定义这个路由。\r\n\r\n<a name=\"tokens-json-api\"></a>\r\n#### JSON API\r\n\r\nPassport 同样包含了一个 JSON API 接口用来管理授权访问令牌。你可以使用该接口为用户搭建一个管理访问令牌的控制面板。方便来着，我们将使用 [Axios](https://github.com/mzabriskie/axios) 模拟 HTTP 对端点发起请求。由于 JSON API 被中间件 `web` 和 `auth` 保护着，我们只能在应用内部调用。\r\n\r\n<a name=\"get-oauthtokens\"></a>\r\n#### `GET /oauth/tokens`\r\n\r\n下面的路由包含了授权用户创建的所有授权访问令牌。接口的主要作用是列出用户所有可撤销的令牌：\r\n\r\n```js\r\naxios.get('/oauth/tokens')\r\n    .then(response => {\r\n        console.log(response.data);\r\n    });\r\n```\r\n\r\n<a name=\"delete-oauthtokenstoken-id\"></a>\r\n#### `DELETE /oauth/tokens/{token-id}`\r\n\r\n下面的路由用于撤销授权访问令牌以及相关的刷新令牌：\r\n\r\n```js\r\naxios.delete('/oauth/tokens/' + tokenId);\r\n```\r\n\r\n<a name=\"refreshing-tokens\"></a>\r\n### 刷新令牌\r\n\r\n如果你的应用发布的是短生命周期访问令牌，用户需要使用刷新令牌来延长访问令牌的生命周期，刷新令牌是在生成访问令牌时同时生成的：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n        'grant_type' => 'refresh_token',\r\n        'refresh_token' => 'the-refresh-token',\r\n        'client_id' => 'client-id',\r\n        'client_secret' => 'client-secret',\r\n        'scope' => '',\r\n    ]);\r\n\r\n    return $response->json();\r\n\r\n调用路由 `/oauth/token` 将返回一串 json 字符串，包含了 `access_token`, `refresh_token` 和 `expires_in` 属性。`expires_in` 属性的值是 access_token 剩余的有效时间。\r\n\r\n\r\n\r\n<a name=\"revoking-tokens\"></a>\r\n### 撤销令牌\r\n\r\n你可以使用 `Laravel\\Passport\\TokenRepository` 类的 `revokeAccessToken` 方法撤销令牌。你可以使用 `Laravel\\Passport\\RefreshTokenRepository` 类的 `revokeRefreshTokensByAccessTokenId` 方法撤销刷新令牌。这两个类可以通过 Laravel 的[服务容器](/docs/laravel/10.x/container)得到：\r\n\r\n    use Laravel\\Passport\\TokenRepository;\r\n    use Laravel\\Passport\\RefreshTokenRepository;\r\n\r\n    $tokenRepository = app(TokenRepository::class);\r\n    $refreshTokenRepository = app(RefreshTokenRepository::class);\r\n\r\n    // 撤销一个访问令牌...\r\n    $tokenRepository->revokeAccessToken($tokenId);\r\n\r\n    // 撤销该令牌的所有刷新令牌...\r\n    $refreshTokenRepository->revokeRefreshTokensByAccessTokenId($tokenId);\r\n\r\n<a name=\"purging-tokens\"></a>\r\n### 清除令牌\r\n\r\n如果令牌已经被撤销或者已经过期了，你可能希望把它们从数据库中清理掉。Passport 提供了 Artisan 命令 `passport:purge` 帮助你实现这个操作:\r\n\r\n```shell\r\n# 清除已经撤销或者过期的令牌以及授权码...\r\nphp artisan passport:purge\r\n\r\n# 只清理过期6小时的令牌以及授权码...\r\nphp artisan passport:purge --hours=6\r\n\r\n# 只清理撤销的令牌以及授权码...\r\nphp artisan passport:purge --revoked\r\n\r\n# 只清理过期的令牌以及授权码...\r\nphp artisan passport:purge --expired\r\n```\r\n\r\n你可以在应用的 `App\\Console\\Kernel` 类中配置一个[定时任务](/docs/laravel/10.x/scheduling)，每天自动的清理令牌：\r\n\r\n    /**\r\n     * Define the application's command schedule.\r\n     */\r\n    protected function schedule(Schedule $schedule): void\r\n    {\r\n        $schedule->command('passport:purge')->hourly();\r\n    }\r\n\r\n<a name=\"code-grant-pkce\"></a>\r\n## 通过 PKCE 发布授权码\r\n\r\n通过 PKCE 「 Proof Key for Code Exchange, 中文译为 代码交换的证明密钥」 发放授权码是对单页面应用或原生应用进行认证以便访问 API 接口的安全方式。这种发放授权码是用于不能保证客户端密码被安全储存，或为降低攻击者拦截授权码的威胁。在这种模式下，当授权码获取令牌时，用 「验证码」( code verifier ) 和 「质疑码」（ code challenge, challenge, 名词可译为：挑战；异议；质疑等）的组合来交换客户端访问密钥。\r\n\r\n\r\n\r\n<a name=\"creating-a-auth-pkce-grant-client\"></a>\r\n### 创建客户端\r\n\r\n在使用 PKCE 方式发布令牌之前，你需要先创建一个启用了 PKCE 的客户端。你可以使用 Artisan 命令 `passport:client` 并带上 `--public` 参数来完成该操作：\r\n\r\n```shell\r\nphp artisan passport:client --public\r\n```\r\n\r\n<a name=\"requesting-auth-pkce-grant-tokens\"></a>\r\n### 请求令牌\r\n\r\n<a name=\"code-verifier-code-challenge\"></a>\r\n#### 验证码（Code Verifier ）和质疑码（Code Challenge）\r\n\r\n这种授权方式不提供授权秘钥，开发者需要创建一个验证码和质疑码的组合来请求得到一个令牌。\r\n\r\n验证码是一串包含 43 位到 128 位字符的随机字符串。可用字符包括字母，数字以及下面这些字符：`\"-\"`, `\".\"`, `\"_\"`, `\"~\"`，可参考 [RFC 7636 specification](https://tools.ietf.org/html/rfc7636) 定义。\r\n\r\n质疑码是一串 Base64 编码包含 URL 和文件名安全字符的字符串，字符串结尾的 `'='` 号需要删除，并且不能包含换行符，空白符或其他附加字符。\r\n\r\n    $encoded = base64_encode(hash('sha256', $code_verifier, true));\r\n\r\n    $codeChallenge = strtr(rtrim($encoded, '='), '+/', '-_');\r\n\r\n<a name=\"code-grant-pkce-redirecting-for-authorization\"></a>\r\n#### 授权重定向\r\n\r\n客户端创建完后，你可以使用客户端 ID 以及生成的验证码，质疑码从你的应用请求获取授权码和访问令牌。首先，业务端应用需要向服务端路由 `/oauth/authorize` 发起重定向请求：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Str;\r\n\r\n    Route::get('/redirect', function (Request $request) {\r\n        $request->session()->put('state', $state = Str::random(40));\r\n\r\n        $request->session()->put(\r\n            'code_verifier', $code_verifier = Str::random(128)\r\n        );\r\n\r\n        $codeChallenge = strtr(rtrim(\r\n            base64_encode(hash('sha256', $code_verifier, true))\r\n        , '='), '+/', '-_');\r\n\r\n        $query = http_build_query([\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'response_type' => 'code',\r\n            'scope' => '',\r\n            'state' => $state,\r\n            'code_challenge' => $codeChallenge,\r\n            'code_challenge_method' => 'S256',\r\n            // 'prompt' => '', // \"none\", \"consent\", or \"login\"\r\n        ]);\r\n\r\n        return redirect('http://passport-app.test/oauth/authorize?'.$query);\r\n    });\r\n\r\n\r\n\r\n<a name=\"code-grant-pkce-converting-authorization-codes-to-access-tokens\"></a>\r\n#### 验证码到访问令牌的转换\r\n\r\n用户授权访问后，将重定向到业务端服务。正如标准授权定义那样，业务端需要验证回传的 `state` 参数的值和在重定向之前设置的值是否一致。\r\n\r\n如果 state 的值验证通过，业务接入端需要向应用端发起一个获取访问令牌的 `POST` 请求。请求的参数需要包括之前用户授权通过后你的应用生成的授权码，以及之前生成的验证码：\r\n\r\n    use Illuminate\\Http\\Request;\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    Route::get('/callback', function (Request $request) {\r\n        $state = $request->session()->pull('state');\r\n\r\n        $codeVerifier = $request->session()->pull('code_verifier');\r\n\r\n        throw_unless(\r\n            strlen($state) > 0 && $state === $request->state,\r\n            InvalidArgumentException::class\r\n        );\r\n\r\n        $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n            'grant_type' => 'authorization_code',\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'code_verifier' => $codeVerifier,\r\n            'code' => $request->code,\r\n        ]);\r\n\r\n        return $response->json();\r\n    });\r\n\r\n<a name=\"password-grant-tokens\"></a>\r\n## 密码授权方式的令牌\r\n\r\n> **注意**  \r\n> 我们不再建议使用密码授予令牌。相反，你应该选择 [OAuth2 服务器当前推荐的授权类型](https://oauth2.thephpleague.com/authorization-server/which-grant/) 。\r\n\r\nOAuth2 的密码授权方式允许你自己的客户端（比如手机端应用），通过使用邮箱 / 用户名和密码获取访问秘钥。这样你就可以安全的为自己发放令牌，而不需要完整地走 OAuth2 的重定向授权访问流程。\r\n\r\n\r\n\r\n<a name=\"creating-a-password-grant-client\"></a>\r\n### 创建密码授权方式客户端\r\n\r\n在你使用密码授权方式发布令牌前，你需要先创建密码授权方式的客户端。你可以通过 Artisan 命令 `passport:client` ， 并加上 `--password` 参数来创建这样的客户端。 **如果你已经运行过 `passport:install` 命令，则不需要再运行下面的命令:**\r\n\r\n```shell\r\nphp artisan passport:client --password\r\n```\r\n\r\n<a name=\"requesting-password-grant-tokens\"></a>\r\n### 请求令牌\r\n\r\n密码授权方式的客户端创建好后，你就可以使用用户邮箱和密码向 `/oauth/token` 路由发起 `POST` 请求，以获取访问令牌。请记住，该路由已经在 `Passport::routes` 方法中定义，你无需再手动实现它。如果请求成功，你将在返回 JSON 串中获取到 `access_token` 和 `refresh_token` :\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n        'grant_type' => 'password',\r\n        'client_id' => 'client-id',\r\n        'client_secret' => 'client-secret',\r\n        'username' => 'taylor@laravel.com',\r\n        'password' => 'my-password',\r\n        'scope' => '',\r\n    ]);\r\n\r\n    return $response->json();\r\n\r\n> **技巧**  \r\n> 请记住，默认情况下 access token 都是长生命周期的，但是如果有需要的话，你可以主动去 [设置 access token 的过期时间](#configuration) 。\r\n\r\n<a name=\"requesting-all-scopes\"></a>\r\n### 请求所有的作用域\r\n\r\n当使用密码授权（password grant）或者客户端认证授权（client credentials grant）方式时，你可能希望将应用所有的作用域范围都授权给令牌。你可以通过设置 scope 参数为 `*` 来实现。 一旦你这样设置了，所有的 `can` 方法都将返回 `true` 值。 此范围只能在密码授权 `password` 或客户端认证授权 `client_credentials` 下使用：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n        'grant_type' => 'password',\r\n        'client_id' => 'client-id',\r\n        'client_secret' => 'client-secret',\r\n        'username' => 'taylor@laravel.com',\r\n        'password' => 'my-password',\r\n        'scope' => '*',\r\n    ]);\r\n\r\n\r\n\r\n<a name=\"customizing-the-user-provider\"></a>\r\n### 自定义用户提供者\r\n\r\n如果你的应用程序使用多个 [用户认证提供器](/docs/laravel/10.x/authentication#introduction)，你可以在创建客户端通过 `artisan passport:client --password` 命令时使用 `--provider` 选项来指定提供器。 给定的提供器名称应与应用程序的 `config/auth.php` 配置文件中定义的有效提供器匹配。 然后，你可以 [使用中间件保护你的路由](#via-middleware) 以确保只有来自守卫指定提供器的用户才被授权。\r\n\r\n<a name=\"customizing-the-username-field\"></a>\r\n### 自定义用户名字段\r\n\r\n当使用密码授权进行身份验证时，Passport 将使用可验证模型的 `email` 属性作为 「用户名」 。 但是，你可以通过在模型上定义 `findForPassport` 方法来自定义此行为：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Laravel\\Passport\\HasApiTokens;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use HasApiTokens, Notifiable;\r\n\r\n        /**\r\n         * 查找给定用户名的用户实例。\r\n         */\r\n        public function findForPassport(string $username): User\r\n        {\r\n            return $this->where('username', $username)->first();\r\n        }\r\n    }\r\n\r\n<a name=\"customizing-the-password-validation\"></a>\r\n### 自定义密码验证\r\n\r\n当使用密码授权进行身份验证时，Passport 将使用模型的 `password` 属性来验证给定的密码。 如果你的模型没有 `password` 属性或者你希望自定义密码验证逻辑，你可以在模型上定义 `validateForPassportPasswordGrant` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n    use Illuminate\\Notifications\\Notifiable;\r\n    use Illuminate\\Support\\Facades\\Hash;\r\n    use Laravel\\Passport\\HasApiTokens;\r\n\r\n    class User extends Authenticatable\r\n    {\r\n        use HasApiTokens, Notifiable;\r\n\r\n        /**\r\n         * 验证用户的密码以获得 Passport 密码授权。\r\n         */\r\n        public function validateForPassportPasswordGrant(string $password): bool\r\n        {\r\n            return Hash::check($password, $this->password);\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"implicit-grant-tokens\"></a>\r\n## 隐式授权令牌\r\n\r\n> **注意**  \r\n> 我们不再推荐使用隐式授权令牌。 相反，你应该选择 [ OAuth2 服务器当前推荐的授权类型](https://oauth2.thephpleague.com/authorization-server/which-grant/) 。\r\n\r\n隐式授权类似于授权码授权； 但是，令牌会在不交换授权码的情况下返回给客户端。 此授权最常用于无法安全存储客户端凭据的 JavaScript 或移动应用程序。 要启用授权，请在应用程序的 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中调用 `enableImplicitGrant` 方法：\r\n\r\n    /**\r\n     * 注册任何身份验证/授权服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Passport::enableImplicitGrant();\r\n    }\r\n\r\n启用授权后，开发人员可以使用他们的客户端 ID 从你的应用程序请求访问令牌。 消费应用程序应该向应用程序的 `/oauth/authorize` 路由发出重定向请求，如下所示：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/redirect', function (Request $request) {\r\n        $request->session()->put('state', $state = Str::random(40));\r\n\r\n        $query = http_build_query([\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://third-party-app.com/callback',\r\n            'response_type' => 'token',\r\n            'scope' => '',\r\n            'state' => $state,\r\n            // 'prompt' => '', // \"none\", \"consent\", or \"login\"\r\n        ]);\r\n\r\n        return redirect('http://passport-app.test/oauth/authorize?'.$query);\r\n    });\r\n\r\n> **技巧**  \r\n> 请记住， `/oauth/authorize` 路由已经由 `Passport::routes` 方法定义。 你无需手动定义此路由。\r\n\r\n<a name=\"client-credentials-grant-tokens\"></a>\r\n## 客户凭证授予令牌\r\n\r\n客户端凭据授予适用于机器对机器身份验证。 例如，你可以在通过 API 执行维护任务的计划作业中使用此授权。\r\n\r\n\r\n\r\n要想让应用程序可以通过客户端凭据授权发布令牌，首先，你需要创建一个客户端凭据授权客户端。你可以使用 `passport:client` Artisan 命令的 `--client` 选项来执行此操作：\r\n\r\n```shell\r\nphp artisan passport:client --client\r\n```\r\n\r\n接下来，要使用这种授权，你首先需要在 `app/Http/Kernel.php` 的 `$routeMiddleware` 属性中添加 `CheckClientCredentials` 中间件：\r\n\r\n    use Laravel\\Passport\\Http\\Middleware\\CheckClientCredentials;\r\n\r\n    protected $middlewareAliases = [\r\n        'client' => CheckClientCredentials::class,\r\n    ];\r\n\r\n之后，在路由上附加中间件：\r\n\r\n    Route::get('/orders', function (Request $request) {\r\n        ...\r\n    })->middleware('client');\r\n\r\n要将对路由的访问限制为特定范围，你可以在将 `client` 中间件附加到路由时提供所需范围的逗号分隔列表：\r\n\r\n    Route::get('/orders', function (Request $request) {\r\n        ...\r\n    })->middleware('client:check-status,your-scope');\r\n\r\n<a name=\"retrieving-tokens\"></a>\r\n### 检索令牌\r\n\r\n要使用此授权类型检索令牌，请向 `oauth/token` 端点发出请求：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::asForm()->post('http://passport-app.test/oauth/token', [\r\n        'grant_type' => 'client_credentials',\r\n        'client_id' => 'client-id',\r\n        'client_secret' => 'client-secret',\r\n        'scope' => 'your-scope',\r\n    ]);\r\n\r\n    return $response->json()['access_token'];\r\n\r\n<a name=\"personal-access-tokens\"></a>\r\n## 个人访问令牌\r\n\r\n有时，你的用户要在不经过传统的授权码重定向流程的情况下向自己颁发访问令牌。允许用户通过应用程序用户界面对自己发布令牌，有助于用户体验你的 API，或者也可以将其作为一种更简单的发布访问令牌的方式。\r\n\r\n> **技巧**  \r\n> 如果你的应用程序主要使用 Passport 来发布个人访问令牌，请考虑使用 Laravel 的轻量级第一方库 [Laravel Sanctum](/docs/laravel/10.x/sanctum) 来发布 API 访问令牌。\r\n\r\n\r\n\r\n<a name=\"creating-a-personal-access-client\"></a>\r\n### 创建个人访问客户端\r\n\r\n在应用程序发出个人访问令牌前，你需要在 `passport:client` 命令后带上 `--personal` 参数来创建对应的客户端。如果你已经运行了 `passport:install` 命令，则无需再运行此命令:\r\n\r\n```shell\r\nphp artisan passport:client --personal\r\n```\r\n\r\n创建个人访问客户端后，将客户端的 ID 和纯文本密钥放在应用程序的 `.env` 文件中:\r\n\r\n```ini\r\nPASSPORT_PERSONAL_ACCESS_CLIENT_ID=\"client-id-value\"\r\nPASSPORT_PERSONAL_ACCESS_CLIENT_SECRET=\"unhashed-client-secret-value\"\r\n```\r\n\r\n<a name=\"managing-personal-access-tokens\"></a>\r\n### 管理个人令牌\r\n\r\n创建个人访问客户端后，你可以使用 `App\\Models\\User` 模型实例的 `createToken` 方法来为给定用户发布令牌。 `createToken` 方法接受令牌的名称作为其第一个参数和可选的 [作用域](#token-scopes) 数组作为其第二个参数:\r\n\r\n    use App\\Models\\User;\r\n\r\n    $user = User::find(1);\r\n\r\n    // 创建没有作用域的令牌...\r\n    $token = $user->createToken('Token Name')->accessToken;\r\n\r\n    // 创建具有作用域的令牌...\r\n    $token = $user->createToken('My Token', ['place-orders'])->accessToken;\r\n\r\n<a name=\"personal-access-tokens-json-api\"></a>\r\n#### JSON API\r\n\r\nPassport 中还有一个用于管理个人访问令牌的 JSON API。你可以将其与你自己的前端配对，为你的用户提供一个用于管理个人访问令牌的仪表板。下面，我们将回顾所有用于管理个人访问令牌的 API 。为了方便起见，我们将使用 [Axios](https://github.com/mzabriskie/axios) 来演示向 API 发出 HTTP 请求。\r\n\r\n\r\n\r\nJSON API 由 `web` 和 `auth` 这两个中间件保护；因此，只能从你自己的应用程序中调用它。无法从外部源调用它。\r\n\r\n<a name=\"get-oauthscopes\"></a>\r\n#### `GET /oauth/scopes`\r\n\r\n此路由会返回应用中定义的所有 [作用域](#token-scopes) 。你可以使用此路由列出用户可以分配给个人访问令牌的范围:\r\n\r\n```js\r\naxios.get('/oauth/scopes')\r\n    .then(response => {\r\n        console.log(response.data);\r\n    });\r\n```\r\n\r\n<a name=\"get-oauthpersonal-access-tokens\"></a>\r\n#### `GET /oauth/personal-access-tokens`\r\n\r\n此路由返回认证用户创建的所有个人访问令牌。这主要用于列出用户的所有令牌，以便他们可以编辑和撤销它们:\r\n\r\n```js\r\naxios.get('/oauth/personal-access-tokens')\r\n    .then(response => {\r\n        console.log(response.data);\r\n    });\r\n```\r\n\r\n<a name=\"post-oauthpersonal-access-tokens\"></a>\r\n#### `POST /oauth/personal-access-tokens`\r\n\r\n此路由创建新的个人访问令牌。它需要两个数据：令牌的 `name` 和 `scopes` 。\r\n\r\n```js\r\nconst data = {\r\n    name: 'Token Name',\r\n    scopes: []\r\n};\r\n\r\naxios.post('/oauth/personal-access-tokens', data)\r\n    .then(response => {\r\n        console.log(response.data.accessToken);\r\n    })\r\n    .catch (response => {\r\n        // 列出响应的错误...\r\n    });\r\n```\r\n\r\n<a name=\"delete-oauthpersonal-access-tokenstoken-id\"></a>\r\n#### `DELETE /oauth/personal-access-tokens/{token-id}`\r\n\r\n此路由可用于撤销个人访问令牌：\r\n\r\n```js\r\naxios.delete('/oauth/personal-access-tokens/' + tokenId);\r\n```\r\n\r\n<a name=\"protecting-routes\"></a>\r\n## 路由保护\r\n\r\n<a name=\"via-middleware\"></a>\r\n### 通过中间件\r\n\r\nPassport 包含一个 [验证保护机制](/docs/laravel/10.x/authentication#adding-custom-guards) 验证请求中传入的访问令牌。 若配置 `api` 的看守器使用 `passport` 驱动，你只要在需要有效访问令牌的路由上指定 `auth:api` 中间件即可：\r\n\r\n    Route::get('/user', function () {\r\n        // ...\r\n    })->middleware('auth:api');\r\n\r\n> **注意**  \r\n> 如果你正在使用 [客户端授权令牌](#client-credentials-grant-tokens) ，你应该使用 [ `client` 中间件](#client-credentials-grant-tokens) 来保护你的路由，而不是使用 `auth:api` 中间件。\r\n\r\n\r\n\r\n<a name=\"multiple-authentication-guards\"></a>\r\n#### 多个身份验证看守器\r\n\r\n如果你的应用程序可能使用完全不同的 `Eloquent` 模型、不同类型的用户进行身份验证，则可能需要为应用程序中的每种用户设置看守器。这使你可以保护特定看守器的请求。例如，在配置文件 `config/auth.php` 中设置以下看守器：\r\n\r\n    'api' => [\r\n        'driver' => 'passport',\r\n        'provider' => 'users',\r\n    ],\r\n\r\n    'api-customers' => [\r\n        'driver' => 'passport',\r\n        'provider' => 'customers',\r\n    ],\r\n\r\n以下路由将使用 `customers` 用户提供者的 `api-customers` 看守器来验证传入的请求：\r\n\r\n    Route::get('/customer', function () {\r\n        // ...\r\n    })->middleware('auth:api-customers');\r\n\r\n> **技巧**  \r\n> 关于使用 Passport 的多个用户提供器的更多信息，请参考 [密码认证文档](#customizing-the-user-provider) 。\r\n\r\n<a name=\"passing-the-access-token\"></a>\r\n### 传递访问令牌\r\n\r\n当调用 Passport 保护下的路由时，接入的 API 应用需要将访问令牌作为 `Bearer` 令牌放在请求头 `Authorization` 中。例如，使用 Guzzle HTTP 库时：\r\n\r\n    use Illuminate\\Support\\Facades\\Http;\r\n\r\n    $response = Http::withHeaders([\r\n        'Accept' => 'application/json',\r\n        'Authorization' => 'Bearer '.$accessToken,\r\n    ])->get('https://passport-app.test/api/user');\r\n\r\n    return $response->json();\r\n\r\n<a name=\"token-scopes\"></a>\r\n## 令牌作用域\r\n\r\n作用域可以让 API 客户端在请求账户授权时请求特定的权限。例如，如果你正在构建电子商务应用程序，并不是所有接入的 API 应用都需要下订单的功能。你可以让接入的 API 应用只被允许授权访问订单发货状态。换句话说，作用域允许应用程序的用户限制第三方应用程序执行的操作。\r\n\r\n\r\n\r\n<a name=\"defining-scopes\"></a>\r\n### 定义作用域\r\n\r\n你可以在 `App\\Providers\\AuthServiceProvider` 的 `boot` 方法中使用 `Passport::tokensCan` 方法来定义 API 的作用域。`tokensCan` 方法接受一个包含作用域名称和描述的数组作为参数。作用域描述将会在授权确认页中直接展示给用户，你可以将其定义为任何你需要的内容：\r\n\r\n    /**\r\n     * 注册身份验证/授权服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Passport::tokensCan([\r\n            'place-orders' => 'Place orders',\r\n            'check-status' => 'Check order status',\r\n        ]);\r\n    }\r\n\r\n<a name=\"default-scope\"></a>\r\n### 默认作用域\r\n\r\n如果客户端没有请求任何特定的范围，你可以在 `App\\Providers\\AuthServiceProvider` 类的 `boot`   方法中使用 `setDefaultScope` 方法来定义默认的作用域。\r\n\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    Passport::tokensCan([\r\n        'place-orders' => 'Place orders',\r\n        'check-status' => 'Check order status',\r\n    ]);\r\n\r\n    Passport::setDefaultScope([\r\n        'check-status',\r\n        'place-orders',\r\n    ]);\r\n\r\n> **技巧**\r\n> Passport 的默认作用域不适用于由用户生成的个人访问令牌。\r\n\r\n<a name=\"assigning-scopes-to-tokens\"></a>\r\n### 给令牌分配作用域\r\n\r\n<a name=\"when-requesting-authorization-codes\"></a>\r\n#### 请求授权码\r\n\r\n使用授权码请求访问令牌时，接入的应用需为 `scope` 参数指定所需作用域。 `scope` 参数包含多个作用域时，名称之间使用空格分割：\r\n\r\n    Route::get('/redirect', function () {\r\n        $query = http_build_query([\r\n            'client_id' => 'client-id',\r\n            'redirect_uri' => 'http://example.com/callback',\r\n            'response_type' => 'code',\r\n            'scope' => 'place-orders check-status',\r\n        ]);\r\n\r\n        return redirect('http://passport-app.test/oauth/authorize?'.$query);\r\n    });\r\n\r\n<a name=\"when-issuing-personal-access-tokens\"></a>\r\n#### 分发个人访问令牌\r\n\r\n\r\n\r\n使用 `App\\Models\\User` 模型的 `createToken` 方法发放个人访问令牌时，可以将所需作用域的数组作为第二个参数传给此方法：\r\n\r\n    $token = $user->createToken('My Token', ['place-orders'])->accessToken;\r\n\r\n<a name=\"checking-scopes\"></a>\r\n### 检查作用域\r\n\r\nPassport 包含两个中间件，可用于验证传入的请求是否包含访问指定作用域的令牌。使用之前，需要将下面的中间件添加到 `app/Http/Kernel.php` 文件的 `$middlewareAliases` 属性中：\r\n\r\n    'scopes' => \\Laravel\\Passport\\Http\\Middleware\\CheckScopes::class,\r\n    'scope' => \\Laravel\\Passport\\Http\\Middleware\\CheckForAnyScope::class,\r\n\r\n<a name=\"check-for-all-scopes\"></a>\r\n#### 检查所有作用域\r\n\r\n路由可以使用 `scopes` 中间件来检查当前请求是否拥有指定的所有作用域：\r\n\r\n    Route::get('/orders', function () {\r\n        // 访问令牌具有 \"check-status\" 和 \"place-orders\" 作用域...\r\n    })->middleware(['auth:api', 'scopes:check-status,place-orders']);\r\n\r\n<a name=\"check-for-any-scopes\"></a>\r\n#### 检查任意作用域\r\n\r\n路由可以使用 `scope` 中间件来检查当前请求是否拥有指定的 *任意* 作用域：\r\n\r\n    Route::get('/orders', function () {\r\n        // 访问令牌具有 \"check-status\" 或 \"place-orders\" 作用域...\r\n    })->middleware(['auth:api', 'scope:check-status,place-orders']);\r\n\r\n<a name=\"checking-scopes-on-a-token-instance\"></a>\r\n#### 检查令牌实例上的作用域\r\n\r\n即使含有访问令牌验证的请求已经通过应用程序的验证，你仍然可以使用当前授权 `App\\Models\\User` 实例上的 `tokenCan` 方法来验证令牌是否拥有指定的作用域：\r\n\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/orders', function (Request $request) {\r\n        if ($request->user()->tokenCan('place-orders')) {\r\n            // ...\r\n        }\r\n    });\r\n\r\n\r\n\r\n<a name=\"additional-scope-methods\"></a>\r\n#### 附加作用域方法\r\n\r\n`scopeIds` 方法将返回所有已定义 ID / 名称的数组：\r\n\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    Passport::scopeIds();\r\n\r\n`scopes` 方法将返回一个包含所有已定义作用域数组的 `Laravel\\Passport\\Scope` 实例：\r\n\r\n    Passport::scopes();\r\n\r\n`scopesFor` 方法将返回与给定 ID / 名称匹配的 `Laravel\\Passport\\Scope` 实例数组：\r\n\r\n    Passport::scopesFor(['place-orders', 'check-status']);\r\n\r\n你可以使用 `hasScope` 方法确定是否已定义给定作用域：\r\n\r\n    Passport::hasScope('place-orders');\r\n\r\n<a name=\"consuming-your-api-with-javascript\"></a>\r\n## 使用 JavaScript 接入 API\r\n\r\n在构建 API 时， 如果能通过 JavaScript 应用接入自己的 API 将会给开发过程带来极大的便利。这种 API 开发方法允许你使用自己的应用程序的 API 和别人共享的 API 。你的 Web 应用程序、移动应用程序、第三方应用程序以及可能在各种软件包管理器上发布的任何 SDK 都可能会使用相同的 API 。\r\n\r\n通常，如果要在 JavaScript 应用程序中使用 API ，需要手动向应用程序发送访问令牌，并将其传递给应用程序。但是， Passport 有一个可以处理这个问题的中间件。将 `CreateFreshApiToken` 中间件添加到 `app/Http/Kernel.php` 文件中的 `web` 中间件组就可以了：\r\n\r\n    'web' => [\r\n        // 其他中间件...\r\n        \\Laravel\\Passport\\Http\\Middleware\\CreateFreshApiToken::class,\r\n    ],\r\n\r\n> **注意**  \r\n> 你需要确保 `CreateFreshApiToken` 中间件是你的中间件堆栈中的最后一个中间件。\r\n\r\n该中间件会将 `laravel_token` cookie 附加到你的响应中。该 cookie 将包含一个加密后的 JWT ， Passport 将用来验证来自 JavaScript 应用程序的 API 请求。JWT 的生命周期等于你的 `session.lifetime` 配置值。至此，你可以在不明确传递访问令牌的情况下向应用程序的 API 发出请求：\r\n\r\n    axios.get('/api/user')\r\n        .then(response => {\r\n            console.log(response.data);\r\n        });\r\n\r\n\r\n\r\n<a name=\"customizing-the-cookie-name\"></a>\r\n#### 自定义 Cookie 名称\r\n\r\n如果需要，你可以在 `App\\Providers\\AuthServiceProvider` 类的 `boot` 方法中使用 `Passport::cookie` 方法来自定义 `laravel_token` cookie 的名称：\r\n\r\n    /**\r\n     * 注册认证 / 授权服务.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Passport::cookie('custom_name');\r\n    }\r\n\r\n<a name=\"csrf-protection\"></a>\r\n#### CSRF 保护\r\n\r\n当使用这种授权方法时，你需要确认请求中包含有效的 CSRF 令牌。默认的 Laravel JavaScript 脚手架会包含一个 Axios 实例，该实例是自动使用加密的 `XSRF-TOKEN` cookie 值在同源请求上发送 `X-XSRF-TOKEN` 请求头。\r\n\r\n> **技巧**  \r\n> 如果你选择发送 `X-CSRF-TOKEN` 请求头而不是 `X-XSRF-TOKEN` ，则需要使用 `csrf_token()` 提供的未加密令牌。\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\nPassport 在发出访问令牌和刷新令牌时引发事件。 你可以使用这些事件来修改或撤消数据库中的其他访问令牌。如果你愿意，可以在应用程序的 `App\\Providers\\EventServiceProvider` 类中将监听器注册到这些事件：\r\n\r\n    /**\r\n     * 应用程序的事件监听器映射\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        'Laravel\\Passport\\Events\\AccessTokenCreated' => [\r\n            'App\\Listeners\\RevokeOldTokens',\r\n        ],\r\n\r\n        'Laravel\\Passport\\Events\\RefreshTokenCreated' => [\r\n            'App\\Listeners\\PruneOldTokens',\r\n        ],\r\n    ];\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\nPassport 的 `actingAs` 方法可以指定当前已认证用户及其作用域。`actingAs` 方法的第一个参数是用户实例，第二个参数是用户令牌作用域数组：\r\n\r\n    use App\\Models\\User;\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    public function test_servers_can_be_created(): void\r\n    {\r\n        Passport::actingAs(\r\n            User::factory()->create(),\r\n            ['create-servers']\r\n        );\r\n\r\n        $response = $this->post('/api/create-server');\r\n\r\n        $response->assertStatus(201);\r\n    }\r\n\r\n\r\n\r\nPassport 的 `actingAsClient` 方法可以指定当前已认证用户及其作用域。 `actingAsClient` 方法的第一个参数是用户实例，第二个参数是用户令牌作用域数组：\r\n\r\n    use Laravel\\Passport\\Client;\r\n    use Laravel\\Passport\\Passport;\r\n\r\n    public function test_orders_can_be_retrieved(): void\r\n    {\r\n        Passport::actingAsClient(\r\n            Client::factory()->create(),\r\n            ['check-status']\r\n        );\r\n\r\n        $response = $this->get('/api/orders');\r\n\r\n        $response->assertStatus(200);\r\n    }\r\n\r\n","p":"docs/passport.html"},{"t":"pennant (Laravel Pennant)","d":"# Laravel Pennant\r\n\r\n- [介绍](#introduction)\r\n- [安装](#installation)\r\n- [配置 ](#configuration)\r\n- [定义特性](#defining-features)\r\n    - [基于类的特性](#class-based-features)\r\n- [检查特性](#checking-features)\r\n    - [条件执行](#conditional-execution)\r\n    - [HasFeatures Trait](#the-has-features-trait)\r\n    - [Blade 指令](#blade-directive)\r\n    - [中间件](#middleware)\r\n    - [内存缓存](#in-memory-cache)\r\n- [作用域](#scope)\r\n    - [指定作用域](#specifying-the-scope)\r\n    - [默认作用域](#default-scope)\r\n    - [空作用域](#nullable-scope)\r\n    - [标识作用域](#identifying-scope)\r\n- [富特征值](#rich-feature-values)\r\n- [获取多个特性](#retrieving-multiple-features)\r\n- [预加载](#eager-loading)\r\n- [更新特征值](#updating-values)\r\n    - [批量更新](#bulk-updates)\r\n    - [清除特性](#purging-features)\r\n- [测试 ](#testing)\r\n- [添加自定义 Pennant 驱动](#adding-custom-pennant-drivers)\r\n    - [实现驱动](#implementing-the-driver)\r\n    - [注册驱动](#registering-the-driver)\r\n- [事件](#events)\r\n\r\n<a name=\"introduction\"></a>\r\n\r\n## 介绍\r\n\r\n[Laravel Pennant](https://github.com/laravel/pennant) 是一个简单轻量的特性标志包，没有臃肿。特性标志使你可以有信心地逐步推出新的应用程序功能，测试新的界面设计，支持基干开发策略等等。\r\n\r\n<a name=\"installation\"></a>\r\n\r\n## 安装\r\n\r\n首先，使用 Composer 包管理器将 Pennant 安装到你的项目中：\r\n\r\n```shell\r\ncomposer require laravel/pennant\r\n```\r\n\r\n接下来，你应该使用 `vendor:publish` Artisan 命令发布 Pennant 配置和迁移文件： `vendor:publish` Artisan command:\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Pennant\\PennantServiceProvider\"\r\n```\r\n\r\n最后，你应该运行应用程序的数据库迁移。这将创建一个 `features` 表，`Pennant` 使用它来驱动其 `database` 驱动程序：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"configuration\"></a>\r\n\r\n## 配置\r\n\r\n在发布 Pennant 资源之后，配置文件将位于 `config/pennant.php`。此配置文件允许你指定 Pennant 用于存储已解析的特性标志值的默认存储机制。\r\n\r\nPennant 支持使用 `array` 驱动程序在内存数组中存储已解析的特性标志值。或者，Pennant 可以使用 `database` 驱动程序在关系数据库中持久存储已解析的特性标志值，这是 Pennant 使用的默认存储机制。\r\n\r\n<a name=\"defining-features\"></a>\r\n\r\n## 定义特性\r\n\r\n要定义特性，你可以使用 `Feature` 门面提供的 `define` 方法。你需要为该特性提供一个名称以及一个闭包，用于解析该特性的初始值。\r\n\r\n通常，特性是在服务提供程序中使用 `Feature` 门面定义的。闭包将接收特性检查的“作用域”。最常见的是，作用域是当前已认证的用户。在此示例中，我们将定义一个功能，用于逐步向应用程序用户推出新的 API：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Providers;\r\n\r\nuse App\\Models\\User;\r\nuse Illuminate\\Support\\Lottery;\r\nuse Illuminate\\Support\\ServiceProvider;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nclass AppServiceProvider extends ServiceProvider\r\n{\r\n    /**\r\n     * Bootstrap any application services.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Feature::define('new-api', fn (User $user) => match (true) {\r\n            $user->isInternalTeamMember() => true,\r\n            $user->isHighTrafficCustomer() => false,\r\n            default => Lottery::odds(1 / 100),\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n正如你所看到的，我们对我们的特性有以下规则：\r\n- 所有内部团队成员应使用新 API。\r\n- 任何高流量客户不应使用新 API。\r\n- 否则，该特性应在具有 1/100 概率激活的用户中随机分配。\r\n\r\n首次检查给定用户的 `new-api`特性时，存储驱动程序将存储闭包的结果。下一次针对相同用户检查特性时，将从存储中检索该值，不会调用闭包。\r\n\r\n为方便起见，如果特性定义仅返回一个 Lottery，你可以完全省略闭包：\r\n\r\n    Feature::define('site-redesign', Lottery::odds(1, 1000));\r\n\r\n<a name=\"class-based-features\"></a>\r\n\r\n### 基于类的特性\r\n\r\nPennant 还允许你定义基于类的特性。不像基于闭包的特性定义，不需要在服务提供者中注册基于类的特性。为了创建一个基于类的特性，你可以调用 `pennant:feature` Artisan 命令。默认情况下，特性类将被放置在你的应用程序的 `app/Features` 目录中：\r\n\r\n```shell\r\nphp artisan pennant:feature NewApi\r\n```\r\n\r\n在编写特性类时，你只需要定义一个 `resolve` 方法，用于为给定的范围解析特性的初始值。同样，范围通常是当前经过身份验证的用户：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Features;\r\n\r\nuse Illuminate\\Support\\Lottery;\r\n\r\nclass NewApi\r\n{\r\n    /**\r\n     * 解析特性的初始值.\r\n     */\r\n    public function resolve(User $user): mixed\r\n    {\r\n        return match (true) {\r\n            $user->isInternalTeamMember() => true,\r\n            $user->isHighTrafficCustomer() => false,\r\n            default => Lottery::odds(1 / 100),\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n> **注** 特性类是通过[容器](/docs/laravel/10.x/container),解析的，因此在需要时可以在特性类的构造函数中注入依赖项。\r\n\r\n<a name=\"checking-features\"></a>\r\n\r\n## 检查特性\r\n\r\n要确定一个特性是否处于活动状态，你可以在 `Feature` 门面上使用 `active` 方法。默认情况下，特性针对当前已认证的用户进行检查：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Http\\Response;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nclass PodcastController\r\n{\r\n    /**\r\n     * 显示资源的列表.\r\n     */\r\n    public function index(Request $request): Response\r\n    {\r\n        return Feature::active('new-api')\r\n                ? $this->resolveNewApiResponse($request)\r\n                : $this->resolveLegacyApiResponse($request);\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n为了方便起见，如果一个特征定义只返回一个抽奖结果，你可以完全省略闭包:\r\n\r\n    Feature::define('site-redesign', Lottery::odds(1, 1000));\r\n\r\n<a name=\"class-based-features\"></a>\r\n\r\n### 基于类的特征\r\n\r\nPennant 还允许你定义基于类的特征。与基于闭包的特征定义不同，无需在服务提供者中注册基于类的特征。要创建基于类的特征，你可以调用 pennant:feature Artisan 命令。默认情况下，特征类将被放置在你的应用程序的 app/Features 目录中。:\r\n\r\n```php\r\nphp artisan pennant:feature NewApi\r\n```\r\n\r\n编写特征类时，你只需要定义一个 `resolve` 方法，该方法将被调用以解析给定作用域的特征的初始值。同样，该作用域通常是当前已验证的用户。:\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Features;\r\n\r\nuse Illuminate\\Support\\Lottery;\r\n\r\nclass NewApi\r\n{\r\n    /**\r\n     * 解析特征的初始值.\r\n     */\r\n    public function resolve(User $user): mixed\r\n    {\r\n        return match (true) {\r\n            $user->isInternalTeamMember() => true,\r\n            $user->isHighTrafficCustomer() => false,\r\n            default => Lottery::odds(1 / 100),\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n> **注意** 特征类通过 [容器](/docs/laravel/10.x/container), 解析，因此在需要时，你可以将依赖项注入到特征类的构造函数中.\r\n\r\n<a name=\"checking-features\"></a>\r\n\r\n## Checking Features\r\n\r\n要确定特征是否处于活动状态，你可以在 Feature 门面上使用 `active` 方法。默认情况下，特征将针对当前已验证的用户进行检查。:\r\n\r\n```php\r\n\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Http\\Response;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nclass PodcastController\r\n{\r\n    /**\r\n     *显示资源的列表.\r\n     */\r\n    public function index(Request $request): Response\r\n    {\r\n        return Feature::active('new-api')\r\n                ? $this->resolveNewApiResponse($request)\r\n                : $this->resolveLegacyApiResponse($request);\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n虽然默认情况下特性针对当前已认证的用户进行检查，但你可以轻松地针对其他用户或范围检查特性。为此，使用 `Feature` 门面提供的 `for` 方法：\r\n\r\n```php\r\nreturn Feature::for($user)->active('new-api')\r\n        ? $this->resolveNewApiResponse($request)\r\n        : $this->resolveLegacyApiResponse($request);\r\n```\r\n\r\nPennant 还提供了一些额外的方便方法，在确定特性是否活动或不活动时可能非常有用：\r\n\r\n```php\r\n//确定所有给定的特性是否都活动...\r\nFeature::allAreActive(['new-api', 'site-redesign']);\r\n\r\n// 确定任何给定的特性是否都活动...\r\nFeature::someAreActive(['new-api', 'site-redesign']);\r\n\r\n// 确定特性是否处于非活动状态...\r\nFeature::inactive('new-api');\r\n\r\n// 确定所有给定的特性是否都处于非活动状态...\r\nFeature::allAreInactive(['new-api', 'site-redesign']);\r\n\r\n// 确定任何给定的特性是否都处于非活动状态...\r\nFeature::someAreInactive(['new-api', 'site-redesign']);\r\n```\r\n\r\n> **注**\r\n\r\n>当在 HTTP 上下文之外使用 Pennant（例如在 Artisan 命令或排队作业中）时，你通常应[明确指定特性的作用域](#specifying-the-scope)。或者，你可以定义一个[默认作用域](#default-scope)，该作用域考虑到已认证的 HTTP 上下文和未经身份验证的上下文。\r\n\r\n<a name=\"checking-class-based-features\"></a>\r\n\r\n#### 检查基于类的特性\r\n\r\n对于基于类的特性，应该在检查特性时提供类名：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Features\\NewApi;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Http\\Response;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nclass PodcastController\r\n{\r\n\r\n    /**\r\n     * 显示资源的列表.\r\n     */\r\n    public function index(Request $request): Response\r\n    {\r\n        return Feature::active(NewApi::class)\r\n                ? $this->resolveNewApiResponse($request)\r\n                : $this->resolveLegacyApiResponse($request);\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n<a name=\"conditional-execution\"></a>\r\n\r\n### 条件执行\r\n\r\n`when` 方法可用于在特性激活时流畅地执行给定的闭包。此外，可以提供第二个闭包，如果特性未激活，则将执行它：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Features\\NewApi;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Http\\Response;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nclass PodcastController\r\n{\r\n    /**\r\n     * 显示资源的列表.\r\n     */\r\n    public function index(Request $request): Response\r\n    {\r\n        return Feature::when(NewApi::class,\r\n            fn () => $this->resolveNewApiResponse($request),\r\n            fn () => $this->resolveLegacyApiResponse($request),\r\n        );\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n`unless` 方法是 `when` 方法的相反，如果特性未激活，则执行第一个闭包：\r\n\r\n    return Feature::unless(NewApi::class,\r\n\r\n        fn () => $this->resolveLegacyApiResponse($request),\r\n\r\n        fn () => $this->resolveNewApiResponse($request),\r\n\r\n    );\r\n\r\n<a name=\"the-has-features-trait\"></a>\r\n\r\n### HasFeatures Trait\r\n\r\nPennant 的 `HasFeatures` Trait 可以添加到你的应用的 `User` 模型（或其他具有特性的模型）中，以提供一种流畅、方便的方式从模型直接检查特性：\r\n\r\n```php\r\n\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\nuse Laravel\\Pennant\\Concerns\\HasFeatures;\r\n\r\nclass User extends Authenticatable\r\n{\r\n    use HasFeatures;\r\n    // ...\r\n}\r\n```\r\n\r\n一旦将 HasFeatures Trait 添加到你的模型中，你可以通过调用 `features` 方法轻松检查特性：\r\n\r\n```php\r\nif ($user->features()->active('new-api')) {\r\n    // ...\r\n}\r\n```\r\n\r\n当然，`features` 方法提供了许多其他方便的方法来与特性交互：\r\n\r\n```php\r\n// 值...\r\n$value = $user->features()->value('purchase-button')\r\n$values = $user->features()->values(['new-api', 'purchase-button']);\r\n\r\n// 状态...\r\n$user->features()->active('new-api');\r\n$user->features()->allAreActive(['new-api', 'server-api']);\r\n$user->features()->someAreActive(['new-api', 'server-api']);\r\n$user->features()->inactive('new-api');\r\n$user->features()->allAreInactive(['new-api', 'server-api']);\r\n$user->features()->someAreInactive(['new-api', 'server-api']);\r\n\r\n// 条件执行...\r\n$user->features()->when('new-api',\r\n    fn () => /* ... */,\r\n    fn () => /* ... */,\r\n);\r\n\r\n$user->features()->unless('new-api',\r\n    fn () => /* ... */,\r\n    fn () => /* ... */,\r\n);\r\n```\r\n\r\n<a name=\"blade-directive\"></a>\r\n\r\n### Blade 指令\r\n\r\n为了使在 Blade 中检查特性的体验更加流畅，Pennant提供了一个 `@feature` 指令：\r\n\r\n```blade\r\n@feature('site-redesign')\r\n<!-- 'site-redesign' 活跃中 -->\r\n@else\r\n<!-- 'site-redesign' 不活跃-->\r\n@endfeature\r\n```\r\n\r\n<a name=\"middleware\"></a>\r\n\r\n### 中间件\r\n\r\nPennant 还包括一个[中间件](/docs/laravel/10.x/middleware)，它可以在路由调用之前验证当前认证用户是否有访问功能的权限。首先，你应该将 `EnsureFeaturesAreActive` 中间件的别名添加到你的应用程序的 `app/Http/Kernel.php` 文件中：\r\n\r\n```php\r\n\r\nuse Laravel\\Pennant\\Middleware\\EnsureFeaturesAreActive;\r\n\r\nprotected $middlewareAliases = [\r\n    // ...\r\n 'features' => EnsureFeaturesAreActive::class,\r\n];\r\n```\r\n\r\n接下来，你可以将中间件分配给一个路由并指定需要访问该路由的功能。如果当前认证用户的任何指定功能未激活，则路由将返回 `400 Bad Request` HTTP 响应。可以使用逗号分隔的列表指定多个功能：\r\n\r\n```php\r\nRoute::get('/api/servers', function () {\r\n    // ...\r\n})->middleware(['features:new-api,servers-api']);\r\n```\r\n\r\n<a name=\"customizing-the-response\"></a>\r\n\r\n#### 自定义响应\r\n\r\n如果你希望在未激活列表中的任何一个功能时自定义中间件返回的响应，可以使用 `EnsureFeaturesAreActive` 中间件提供的 `whenInactive` 方法。通常，这个方法应该在应用程序的服务提供者的 boot 方法中调用：\r\n\r\n```php\r\n\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Http\\Response;\r\nuse Laravel\\Pennant\\Middleware\\EnsureFeaturesAreActive;\r\n\r\n/**\r\n * 加载服务.\r\n */\r\npublic function boot(): void\r\n{\r\n    EnsureFeaturesAreActive::whenInactive(\r\n        function (Request $request, array $features) {\r\n            return new Response(status: 403);\r\n        }\r\n    );\r\n    // ...\r\n}\r\n```\r\n\r\n<a name=\"in-memory-cache\"></a>\r\n\r\n### 内存缓存\r\n\r\n当检查特性时，Pennant 将创建一个内存缓存以存储结果。如果你使用的是 `database` 驱动程序，则在单个请求中重新检查相同的功能标志将不会触发额外的数据库查询。这也确保了该功能在请求的持续时间内具有一致的结果。\r\n\r\n如果你需要手动刷新内存缓存，可以使用 `Feature` 门面提供的 `flushCache` 方法：\r\n\r\n    Feature::flushCache();\r\n\r\n<a name=\"scope\"></a>\r\n\r\n## 作用域\r\n\r\n<a name=\"specifying-the-scope\"></a>\r\n\r\n### 指定作用域\r\n\r\n如前所述，特性通常会针对当前已验证的用户进行检查。但这可能并不总是适合你的需求。因此，你可以通过 `Feature` 门面的 `for` 方法来指定要针对哪个作用域检查给定的特性：\r\n\r\n```php\r\nreturn Feature::for($user)->active('new-api')\r\n        ? $this->resolveNewApiResponse($request)\r\n        : $this->resolveLegacyApiResponse($request);\r\n```\r\n\r\n当然，特性作用域不限于“用户”。假设你构建了一个新的结算体验，你要将其推出给整个团队而不是单个用户。也许你希望年龄最大的团队的推出速度比年轻的团队慢。你的特性解析闭包可能如下所示：\r\n\r\n```php\r\n\r\nuse App\\Models\\Team;\r\nuse Carbon\\Carbon;\r\nuse Illuminate\\Support\\Lottery;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nFeature::define('billing-v2', function (Team $team) {\r\n    if ($team->created_at->isAfter(new Carbon('1st Jan, 2023'))) {\r\n        return true;\r\n    }\r\n\r\n    if ($team->created_at->isAfter(new Carbon('1st Jan, 2019'))) {\r\n        return Lottery::odds(1 / 100);\r\n    }\r\n\r\n    return Lottery::odds(1 / 1000);\r\n});\r\n```\r\n\r\n你会注意到，我们定义的闭包不需要 `User`，而是需要一个 `Team` 模型。要确定该特性是否对用户的团队可用，你应该将团队传递给 `Feature` 门面提供的 `for` 方法：\r\n\r\n```php\r\nif (Feature::for($user->team)->active('billing-v2')) {\r\n    return redirect()->to('/billing/v2');\r\n}\r\n// ...\r\n```\r\n\r\n<a name=\"default-scope\"></a>\r\n\r\n### 默认作用域\r\n\r\n还可以自定义 Pennant 用于检查特性的默认作用域。例如，你可能希望所有特性都针对当前认证用户的团队进行检查，而不是针对用户。你可以在应用程序的服务提供程序中指定此作用域。通常，应该在一个应用程序的服务提供程序中完成这个过程:\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Providers;\r\n\r\nuse Illuminate\\Support\\Facades\\Auth;\r\nuse Illuminate\\Support\\ServiceProvider;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nclass AppServiceProvider extends ServiceProvider\r\n{\r\n    /**\r\n     * 加载程序服务.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Feature::resolveScopeUsing(fn ($driver) => Auth::user()?->team);\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n如果没有通过 `for` 方法显式提供作用域，则特性检查将使用当前认证用户的团队作为默认作用域：\r\n\r\n```php\r\nFeature::active('billing-v2');\r\n\r\n// 目前等价于...\r\nFeature::for($user->team)->active('billing-v2');\r\n```\r\n\r\n<a name=\"nullable-scope\"></a>\r\n\r\n### 空作用域\r\n\r\n如果你检查特性时提供的作用域范围为 `null`，且特性定义中不支持 `null`（即不是 nullable type 或者没有在 union type 中包含`null`），那么 Pennant 将自动返回 `false` 作为特性的结果值。\r\n\r\n因此，如果你传递给特性的作用域可能为 null 并且你想要特性值的解析器被调用，你应该在特性定义逻辑中处理 `null` 范围值。在一个 Artisan 命令、排队作业或未经身份验证的路由中检查特性可能会出现 `null` 作用域。因为在这些情况下通常没有经过身份验证的用户，所以默认的作用域将为 `null`。\r\n\r\n如果你不总是[明确指定特性作用域](#specifying-the-scope)，则应确保范围类型为\"nullable\"，并在特性定义逻辑中处理 `null` 范围值:\r\n\r\n```php\r\nuse App\\Models\\User;\r\nuse Illuminate\\Support\\Lottery;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nFeature::define('new-api', fn (User $user) => match (true) {// [tl! remove]\r\nFeature::define('new-api', fn (User|null $user) => match (true) {// [tl! add]\r\n    $user === null => true,// [tl! add]\r\n    $user->isInternalTeamMember() => true,\r\n    $user->isHighTrafficCustomer() => false,\r\n    default => Lottery::odds(1 / 100),\r\n});\r\n```\r\n\r\n<a name=\"identifying-scope\"></a>\r\n\r\n### 标识作用域\r\n\r\nPennant 的内置 `array` 和 `database` 存储驱动程序可以正确地存储所有 PHP 数据类型以及 Eloquent 模型的作用域标识符。但是，如果你的应用程序使用第三方的 Pennant 驱动程序，该驱动程序可能不知道如何正确地存储 Eloquent 模型或应用程序中其他自定义类型的标识符。\r\n\r\n因此，Pennant 允许你通过在应用程序中用作 Pennant 作用域的对象上实现 `FeatureScopeable` 协议来格式化存储范围值。\r\n\r\n例如，假设你在单个应用程序中使用了两个不同的特性驱动程序：内置 `database` 驱动程序和第三方的“Flag Rocket”驱动程序。 \"Flag Rocket\"驱动程序不知道如何正确地存储 Eloquent 模型。相反，它需要一个`FlagRocketUser` 实例。通过实现 `FeatureScopeable` 协议中的 `toFeatureIdentifier` 方法，我们可以自定义提供给应用程序中每个驱动程序的可存储范围值：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse FlagRocket\\FlagRocketUser;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\nuse Laravel\\Pennant\\Contracts\\FeatureScopeable;\r\n\r\nclass User extends Model implements FeatureScopeable\r\n{\r\n    /**\r\n     * 将对象强制转换为给定驱动程序的功能范围标识符.\r\n     */\r\n    public function toFeatureIdentifier(string $driver): mixed\r\n    {\r\n        return match($driver) {\r\n \t\t'database' => $this,\r\n \t\t'flag-rocket' => FlagRocketUser::fromId($this->flag_rocket_id),\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"rich-feature-values\"></a>\r\n\r\n## 丰富的特征值\r\n\r\n到目前为止，我们主要展示了特性的二进制状态，即它们是「活动的」还是「非活动的」，但是 Pennant 也允许你存储丰富的值。\r\n\r\n例如，假设你正在测试应用程序的「立即购买」按钮的三种新颜色。你可以从特性定义中返回一个字符串，而不是 `true` 或 `false`：\r\n\r\n```php\r\nuse Illuminate\\Support\\Arr;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nFeature::define('purchase-button', fn (User $user) => Arr::random([\r\n 'blue-sapphire',\r\n 'seafoam-green',\r\n 'tart-orange',\r\n]));\r\n\r\n```\r\n\r\n你可以使用 `value` 方法检索 `purchase-button` 特性的值：\r\n\r\n```php\r\n$color = Feature::value('purchase-button');\r\n```\r\n\r\nPennant 提供的 Blade 指令也使得根据特性的当前值条件性地呈现内容变得容易：\r\n\r\n```blade\r\n@feature('purchase-button', 'blue-sapphire')\r\n<!-- 'blue-sapphire' is active -->\r\n@elsefeature('purchase-button', 'seafoam-green')\r\n<!-- 'seafoam-green' is active -->\r\n@elsefeature('purchase-button', 'tart-orange')\r\n<!-- 'tart-orange' is active -->\r\n@endfeature\r\n```\r\n\r\n> 使用丰富值时，重要的是要知道，只要特性具有除 `false` 以外的任何值，它就被视为「活动」。\r\n\r\n在调用[条件](#conditional-execution) `when` 方法时，特性的丰富值将提供给第一个闭包：\r\n\r\n    Feature::when('purchase-button',\r\n        fn ($color) => /* ... */,\r\n        fn () => /* ... */,\r\n    );\r\n\r\n同样，当调用条件 `unless` 方法时，特性的丰富值将提供给可选的第二个闭包：\r\n\r\n    Feature::unless('purchase-button',\r\n        fn () => /* ... */,\r\n        fn ($color) => /* ... */,\r\n    );\r\n\r\n<a name=\"retrieving-multiple-features\"></a>\r\n\r\n## 获取多个特性\r\n\r\n`values` 方法允许检索给定作用域的多个特征：\r\n\r\n```php\r\nFeature::values(['billing-v2', 'purchase-button']);\r\n\r\n// [\r\n// 'billing-v2' => false,\r\n// 'purchase-button' => 'blue-sapphire',\r\n// ]\r\n```\r\n\r\n或者，你可以使用 `all` 方法检索给定范围内所有已定义功能的值：\r\n\r\n```php\r\nFeature::all();\r\n\r\n// [\r\n// 'billing-v2' => false,\r\n// 'purchase-button' => 'blue-sapphire',\r\n// 'site-redesign' => true,\r\n// ]\r\n```\r\n\r\n但是，基于类的功能是动态注册的，直到它们被显式检查之前，Pennant并不知道它们的存在。这意味着，如果在当前请求期间尚未检查过应用程序的基于类的功能，则这些功能可能不会出现在 `all` 方法返回的结果中。\r\n\r\n如果你想确保使用 `all` 方法时始终包括功能类，你可以使用Pennant的功能发现功能。要开始使用，请在你的应用程序的任何服务提供程序之一中调用 `discover` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Providers;\r\n\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Laravel\\Pennant\\Feature;\r\n\r\n    class AppServiceProvider extends ServiceProvider\r\n    {\r\n        /**\r\n         * Bootstrap any application services.\r\n         */\r\n        public function boot(): void\r\n        {\r\n            Feature::discover();\r\n            // ...\r\n        }\r\n    }\r\n\r\n`discover` 方法将注册应用程序 `app/Features` 目录中的所有功能类。`all` 方法现在将在其结果中包括这些类，无论它们是否在当前请求期间进行了检查：\r\n\r\n```php\r\nFeature::all();\r\n\r\n// [\r\n// 'App\\Features\\NewApi' => true,\r\n// 'billing-v2' => false,\r\n// 'purchase-button' => 'blue-sapphire',\r\n// 'site-redesign' => true,\r\n// ]\r\n```\r\n\r\n<a name=\"eager-loading\"></a>\r\n\r\n## 预加载\r\n\r\n尽管 Pennant 在单个请求中保留了所有已解析功能的内存缓存，但仍可能遇到性能问题。为了缓解这种情况，Pennant 提供了预加载功能。\r\n\r\n为了说明这一点，想象一下我们正在循环中检查功能是否处于活动状态：\r\n\r\n```php\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nforeach ($users as $user) {\r\n    if (Feature::for($user)->active('notifications-beta')) {\r\n        $user->notify(new RegistrationSuccess);\r\n    }\r\n}\r\n```\r\n\r\n假设我们正在使用数据库驱动程序，此代码将为循环中的每个用户执行数据库查询-执行潜在的数百个查询。但是，使用 Pennant 的 `load` 方法，我们可以通过预加载一组用户或作用域的功能值来消除这种潜在的性能瓶颈：\r\n\r\n```php\r\nFeature::for($users)->load(['notifications-beta']);\r\n\r\nforeach ($users as $user) {\r\n    if (Feature::for($user)->active('notifications-beta')) {\r\n        $user->notify(new RegistrationSuccess);\r\n    }\r\n}\r\n```\r\n\r\n为了仅在尚未加载功能值时加载它们，你可以使用 `loadMissing` 方法：\r\n\r\n```php\r\nFeature::for($users)->loadMissing([\r\n 'new-api',\r\n 'purchase-button',\r\n 'notifications-beta',\r\n]);\r\n```\r\n\r\n<a name=\"updating-values\"></a>\r\n\r\n## 更新值\r\n\r\n当首次解析功能的值时，底层驱动程序将把结果存储在存储中。这通常是为了确保在请求之间为你的用户提供一致的体验。但是，有时你可能想手动更新功能的存储值。\r\n\r\n为了实现这一点，你可以使用 `activate` 和 `deactivate` 方法来切换功能的 「打开」或「关闭」状态：\r\n\r\n```php\r\nuse Laravel\\Pennant\\Feature;\r\n\r\n// 激活默认作用域的功能...\r\nFeature::activate('new-api');\r\n\r\n// 在给定的范围中停用功能...\r\nFeature::for($user->team)->deactivate('billing-v2');\r\n```\r\n\r\n还可以通过向 `activate` 方法提供第二个参数来手动设置功能的丰富值：\r\n\r\n```php\r\nFeature::activate('purchase-button', 'seafoam-green');\r\n```\r\n\r\n要指示 Pennant 忘记功能的存储值，你可以使用 `forget` 方法。当再次检查功能时，Pennant 将从其功能定义中解析功能的值：\r\n\r\n```php\r\nFeature::forget('purchase-button');\r\n```\r\n\r\n<a name=\"bulk-updates\"></a>\r\n\r\n### 批量更新\r\n\r\n要批量更新存储的功能值，你可以使用 `activateForEveryone` 和 `deactivateForEveryone` 方法。\r\n\r\n例如，假设你现在对 `new-api` 功能的稳定性有信心，并为结帐流程找到了最佳的「purchase-button」颜色-你可以相应地更新所有用户的存储值：\r\n\r\n```php\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nFeature::activateForEveryone('new-api');\r\nFeature::activateForEveryone('purchase-button', 'seafoam-green');\r\n```\r\n\r\n或者，你可以停用所有用户的该功能：\r\n\r\n```php\r\nFeature::deactivateForEveryone('new-api');\r\n```\r\n\r\n> **注意：**这将仅更新已由 Pennant 存储驱动程序存储的已解析功能值。你还需要更新应用程序中的功能定义。\r\n\r\n<a name=\"purging-features\"></a>\r\n\r\n### 清除功能\r\n\r\n有时，清除存储中的整个功能可以非常有用。如果你已从应用程序中删除了功能或已对功能的定义进行了调整，并希望将其部署到所有用户，则通常需要这样做。\r\n\r\n你可以使用 `purge` 方法删除功能的所有存储值：\r\n\r\n```php\r\n// 清除单个功能...\r\nFeature::purge('new-api');\r\n\r\n// 清除多个功能...\r\nFeature::purge(['new-api', 'purchase-button']);\r\n```\r\n\r\n如果你想从存储中清除所有功能，则可以调用 `purge` 方法而不带任何参数：\r\n\r\n```php\r\nFeature::purge();\r\n```\r\n\r\n由于在应用程序的部署流程中清除功能可能非常有用，因此 Pennant 包括一个`pennant:purge` Artisan命令：\r\n\r\n```sh\r\nphp artisan pennant:purge new-api\r\nphp artisan pennant:purge new-api purchase-button\r\n```\r\n\r\n<a name=\"testing\"></a>\r\n\r\n## 测试\r\n\r\n当测试与功能标志交互的代码时，控制测试中返回的功能标志的最简单方法是简单地重新定义该功能。例如，假设你在应用程序的一个服务提供程序中定义了以下功能：\r\n\r\n```php\r\nuse Illuminate\\Support\\Arr;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nFeature::define('purchase-button', fn () => Arr::random([\r\n 'blue-sapphire',\r\n 'seafoam-green',\r\n 'tart-orange',\r\n]));\r\n```\r\n\r\n要在测试中修改功能的返回值，你可以在测试开始时重新定义该功能。以下测试将始终通过，即使 `Arr::random()` 实现仍然存在于服务提供程序中：\r\n\r\n```php\r\nuse Laravel\\Pennant\\Feature;\r\n\r\npublic function test_it_can_control_feature_values()\r\n{\r\n    Feature::define('purchase-button', 'seafoam-green');\r\n    $this->assertSame('seafoam-green', Feature::value('purchase-button'));\r\n}\r\n```\r\n\r\n相同的方法也可以用于基于类的功能：\r\n\r\n```php\r\nuse App\\Features\\NewApi;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\npublic function test_it_can_control_feature_values()\r\n{\r\n    Feature::define(NewApi::class, true);\r\n    $this->assertTrue(Feature::value(NewApi::class));\r\n}\r\n```\r\n\r\n如果你的功能返回一个 `Lottery` 实例，那么有一些有用的[测试辅助函数可用](/docs/laravel/10.x/helpers#testing-lotteries)。\r\n\r\n<a name=\"store-configuration\"></a>\r\n\r\n#### 存储配置\r\n\r\n你可以通过在应用程序的 `phpunit.xml` 文件中定义 `PENNANT_STORE` 环境变量来配置 Pennant 在测试期间使用的存储：\r\n\r\n```xml\r\n<?xml version=\"1.0\"  encoding=\"UTF-8\"?>\r\n<phpunit colors=\"true\">\r\n    <!-- ... -->\r\n    <php>\r\n<env name=\"PENNANT_STORE\"  value=\"array\"/>\r\n        <!-- ... -->\r\n    </php>\r\n</phpunit>\r\n```\r\n\r\n<a name=\"adding-custom-pennant-drivers\"></a>\r\n\r\n## 添加自定义Pennant驱动程序\r\n\r\n<a name=\"implementing-the-driver\"></a>\r\n\r\n#### 实现驱动程序\r\n\r\n如果 Pennant 现有的存储驱动程序都不符合你的应用程序需求，则可以编写自己的存储驱动程序。你的自定义驱动程序应实现 `Laravel\\Pennant\\Contracts\\Driver` 接口：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Extensions;\r\n\r\nuse Laravel\\Pennant\\Contracts\\Driver;\r\n\r\nclass RedisFeatureDriver implements Driver\r\n{\r\n    public function define(string $feature, callable $resolver): void {}\r\n    public function defined(): array {}\r\n    public function getAll(array $features): array {}\r\n    public function get(string $feature, mixed $scope): mixed {}\r\n    public function set(string $feature, mixed $scope, mixed $value): void {}\r\n    public function setForAllScopes(string $feature, mixed $value): void {}\r\n    public function delete(string $feature, mixed $scope): void {}\r\n    public function purge(array|null $features): void {}\r\n}\r\n```\r\n\r\n现在，我们只需要使用 Redis 连接实现这些方法。可以在 [Pennant](https://github.com/laravel/pennant/blob/1.x/src/Drivers/DatabaseDriver.php) 源代码中查看如何实现这些方法的示例。\r\n\r\n> **注意**\r\n\r\n> Laravel 不附带包含扩展的目录。你可以自由地将它们放在任何你喜欢的位置。在这个示例中，我们创建了一个 `Extensions` 目录来存放 `RedisFeatureDriver`。\r\n\r\n<a name=\"registering-the-driver\"></a>\r\n\r\n#### 注册驱动\r\n\r\n一旦你的驱动程序被实现，就可以将其注册到 Laravel 中。要向 Pennant 添加其他驱动程序，可以使用 `Feature` 门面提供的 `extend` 方法。应该在应用程序的 [服务提供者](/docs/laravel/10.x/providers) 的 `boot` 方法中调用 `extend` 方法：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Providers;\r\n\r\nuse App\\Extensions\\RedisFeatureDriver;\r\nuse Illuminate\\Contracts\\Foundation\\Application;\r\nuse Illuminate\\Support\\ServiceProvider;\r\nuse Laravel\\Pennant\\Feature;\r\n\r\nclass AppServiceProvider extends ServiceProvider\r\n{\r\n    /**\r\n     * 注册任何应用程序服务。\r\n     */\r\n    public function register(): void\r\n    {\r\n        // ...\r\n    }\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Feature::extend('redis', function (Application $app) {\r\n            return new RedisFeatureDriver($app->make('redis'), $app->make('events'), []);\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n一旦驱动程序被注册，就可以在应用程序的 `config/pennant.php` 配置文件中使用 `redis` 驱动程序：\r\n\r\n```php\r\n'stores' => [\r\n\t'redis' => [\r\n\t\t'driver' => 'redis',\r\n\t\t'connection' => null,\r\n\t],\r\n    // ...\r\n],\r\n```\r\n\r\n<a name=\"events\"></a>\r\n## 事件\r\n\r\nPennant 分发了各种事件，这些事件在跟踪应用程序中的特性标志时非常有用。\r\n\r\n### `Laravel\\Pennant\\Events\\RetrievingKnownFeature`\r\n\r\n该事件在请求特定作用域的已知特征值第一次被检索时被触发。此事件可用于创建和跟踪应用程序中使用的特征标记的度量标准。\r\n\r\n### `Laravel\\Pennant\\Events\\RetrievingUnknownFeature`\r\n\r\n当在请求特定作用域的情况下第一次检索未知特性时，将分派此事件。如果你打算从应用程序中删除功能标志，但可能在整个应用程序中留下了某些零散的引用，此事件可能会有用。你可能会发现有用的是监听此事件并在其发生时 `report` 或抛出异常：\r\n\r\n例如，你可能会发现在监听到此事件并出现此情况时，使用 `report` 或引发异常会很有用：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Providers;\r\n\r\nuse Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\nuse Illuminate\\Support\\Facades\\Event;\r\nuse Laravel\\Pennant\\Events\\RetrievingUnknownFeature;\r\n\r\nclass EventServiceProvider extends ServiceProvider\r\n{\r\n    /**\r\n     * Register any other events for your application.\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Event::listen(function (RetrievingUnknownFeature $event) {\r\n            report(\"Resolving unknown feature [{$event->feature}].\");\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n### `Laravel\\Pennant\\Events\\DynamicallyDefiningFeature`\r\n\r\n当在请求期间首次动态检查基于类的特性时，将分派此事件。","p":"docs/pennant.html"},{"t":"pint (Laravel Pint)","d":"\n# Laravel Pint\r\n\r\n- [介绍](#introduction)\r\n- [安装](#installation)\r\n- [运行 Pint](#running-pint)\r\n- [配置 Pint](#configuring-pint)\r\n  - [Presets (预设)](#presets)\r\n  - [规则](#rules)\r\n  - [排除文件/文件夹](#excluding-files-or-folders)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Pint](https://github.com/laravel/pint) 是一款面向极简主义者的 PHP 代码风格固定工具。Pint 是建立在 PHP-CS-Fixer 基础上，使保持代码风格的整洁和一致变得简单。\r\n\r\nPint 会随着所有新的 Laravel 应用程序自动安装，所以你可以立即开始使用它。默认情况下，Pint 不需要任何配置，将通过遵循 Laravel 的观点性编码风格来修复你的代码风格问题。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\nPint 已包含在 Laravel 框架的最近版本中，所以无需安装。然而，对于旧的应用程序，你可以通过 Composer 安装 Laravel Pint：\r\n\r\n```shell\r\ncomposer require laravel/pint --dev\r\n```\r\n\r\n<a name=\"running-pint\"></a>\r\n## 运行 Pint\r\n\r\n可以通过调用你项目中的 `vendor/bin` 目录下的 `pint` 二进制文件来指示 Pint 修复代码风格问题：\r\n\r\n```shell\r\n./vendor/bin/pint\r\n```\r\n\r\n你也可以在特定的文件或目录上运行 Pint：\r\n\r\n```shell\r\n./vendor/bin/pint app/Models\r\n\r\n./vendor/bin/pint app/Models/User.php\r\n```\r\n\r\nPint 将显示它所更新的所有文件的详细列表。 你可以在调用 Pint 时提供 `-v` 选项来查看更多关于 Pint 修改的细节。：\r\n\r\n```shell\r\n./vendor/bin/pint -v\r\n```\r\n\r\n如果你只想 Pint 检查代码中风格是否有错误，而不实际更改文件，则可以使用 `--test` 选项：\r\n\r\n```shell\r\n./vendor/bin/pint --test\r\n```\n\n如果你希望 Pint 根据 Git 仅修改未提交更改的文件，你可以使用 `--dirty` 选项：\r\n\r\n```shell\r\n./vendor/bin/pint --dirty\r\n```\r\n\r\n<a name=\"configuring-pint\"></a>\r\n## 配置 Pint\r\n\r\n如前面所述，Pint 不需要任何配置。但是，如果你希望自定义预设、规则或检查的文件夹，可以在项目的根目录中创建一个 `pint.json` 文件：\r\n\r\n```json\r\n{\r\n  \"preset\": \"laravel\"\r\n}\r\n```\r\n\r\n此外，如果你希望使用特定目录中的 `pint.json`，可以在调用 Pint 时提供 `--config` 选项：\r\n\r\n```shell\r\npint --config vendor/my-company/coding-style/pint.json\r\n```\r\n\r\n<a name=\"presets\"></a>\r\n### Presets(预设)\r\n\r\nPresets 定义了一组规则，可以用来修复代码风格问题。默认情况下，Pint 使用 laravel preset，通过遵循 `Laravel` 的固定编码风格来修复问题。但是，你可以通过向 Pint 提供 `--preset` 选项来指定一个不同的 preset 值：\r\n\r\n```shell\r\npint --preset psr12\r\n```\r\n\r\n如果你愿意，还可以在项目的 `pint.json` 文件中设置 preset ：\r\n\r\n```json\r\n{\r\n  \"preset\": \"psr12\"\r\n}\r\n```\r\n\r\nPint 目前支持的 presets 有：`laravel`、`psr12` 和 `symfony`。\r\n\r\n<a name=\"rules\"></a>\r\n### 规则\r\n\r\n规则是 Pint 用于修复代码风格问题的风格指南。如上所述，presets 是预定义的规则组，适用于大多数 PHP 项目，因此你通常不需要担心它们所包含的单个规则。\r\n\r\n但是，如果你愿意，可以在 `pint.json` 文件中启用或禁用特定规则：\r\n\r\n```json\r\n{\r\n    \"preset\": \"laravel\",\r\n    \"rules\": {\r\n        \"simplified_null_return\": true,\r\n        \"braces\": false,\r\n        \"new_with_braces\": {\r\n            \"anonymous_class\": false,\r\n            \"named_class\": false\r\n        }\r\n    }\r\n}\r\n```\n\nPint是基于 [PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) 构建的。因此，您可以使用它的任何规则来修复项目中的代码风格问题： [PHP-CS-Fixer Configurator](https://mlocati.github.io/php-cs-fixer-configurator).\r\n\r\n<a name=\"excluding-files-or-folders\"></a>\r\n### 排除文件/文件夹\r\n\r\n默认情况下，Pint将检查项目中除 `vendor` 目录以外的所有 `.php` 文件。如果您希望排除更多文件夹，可以使用 `exclude` 配置选项:\r\n\r\n```json\r\n{\r\n    \"exclude\": [\r\n        \"my-specific/folder\"\r\n    ]\r\n}\r\n```\r\n\r\n如果您希望排除包含给定名称模式的所有文件，则可以使用 `notName` 配置选项:\r\n\r\n```json\r\n{\r\n    \"notName\": [\r\n        \"*-my-file.php\"\r\n    ]\r\n}\r\n```\r\n\r\n如果您想要通过提供文件的完整路径来排除文件，则可以使用 `notPath` 配置选项:\r\n\r\n```json\r\n{\r\n    \"notPath\": [\r\n        \"path/to/excluded-file.php\"\r\n    ]\r\n}\r\n```\r\n\n","p":"docs/pint.html"},{"t":"sail (Laravel Sail)","d":"\n# Laravel Sail\r\n\r\n- [介绍](#introduction)\r\n- [安装 & 设定](#installation)\r\n    - [安装 Sail 到当前应用中](#installing-sail-into-existing-applications)\r\n    - [配置 Bash 别名](#configuring-a-bash-alias)\r\n- [启动 & 停止 Sail](#starting-and-stopping-sail)\r\n- [执行命令](#executing-sail-commands)\r\n    - [执行 PHP 命令](#executing-php-commands)\r\n    - [执行 Composer 命令](#executing-composer-commands)\r\n    - [执行 Artisan 命令](#executing-artisan-commands)\r\n    - [执行 Node / NPM 命令](#executing-node-npm-commands)\r\n- [与数据库交互](#interacting-with-sail-databases)\r\n    - [MySQL](#mysql)\r\n    - [Redis](#redis)\r\n    - [MeiliSearch](#meilisearch)\r\n- [文件存储](#file-storage)\r\n-   [运行测试](#running-tests)\r\n    - [Laravel Dusk](#laravel-dusk)\r\n- [预览电子邮件](#previewing-emails)\r\n- [容器 CLI](#sail-container-cli)\r\n- [PHP 版本](#sail-php-versions)\r\n- [Node 版本](#sail-node-versions)\r\n- [共享您的网站](#sharing-your-site)\r\n- [使用 Xdebug 进行调试](#debugging-with-xdebug)\r\n    - [通过命令行使用 Xdebug 进行调试](#xdebug-cli-usage)\r\n    - [通过浏览器使用 Xdebug 进行调试](#xdebug-browser-usage)\r\n- [定制化](#sail-customization)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Sail](https://github.com/laravel/sail) 是一个轻量级的命令行界面，用于与 Laravel 的默认 Docker 开发环境进行交互。Sail 为使用 PHP, MySQL, 和 Redis 构建 Laravel 应用提供了一个很好的起点，不需要事先有 Docker 经验。\r\n\r\nSail 的核心是 `docker-compose.yml` 文件和存储在项目根目录的 `sail` 脚本。`sail` 脚本为 CLI 提供了便捷的方法，可用于与 `docker-compose.yml` 文件定义的 Docker 容器进行交互。\r\n\r\nLaravel Sail 支持 macOS、Linux 和 Windows (通过 [WSL2](https://docs.microsoft.com/en-us/windows/wsl/about)）。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装 & 设定\r\n\r\nLaravel Sail 会随着所有全新的 Laravel 应用程序一起自动安装，因此你可以立即的开始使用它。要了解如何创建一个新的 Laravel 应用程序，请查阅适合您目前操作系统的 [安装文档](https://learnku.com/docs/laravel/10.x/installation)。在安装过程中，你将被要求选择你的应用程序将与哪些 Sail 支持的服务进行交互。\r\n\n\n<a name=\"installing-sail-into-existing-applications\"></a>\r\n### 安装 Sail 到当前应用中\r\n\r\n假如你有兴趣在你现有的 Laravel 应用程序中使用 Sail，你可以透过 Composer 套件管理简单的安装 Sail。当然，这些步骤的前提是假设你现有的本地开发环境允许你安装 Copmoser 依赖：\r\n\r\n```shell\r\ncomposer require laravel/sail --dev\r\n```\r\n\r\n在 Sail 完成安装后，你可以运行 Artisan 命令 `sail:install`。这个命令将会发布 Sail 的 `docker-compose.yml` 文件到你应用程序的根目录：\r\n\r\n```shell\r\nphp artisan sail:install\r\n```\r\n\r\n最后，你可以启动 Sail 的服务了。想要继续学习如何使用 Sail，请接着阅读本文挡的其余部分：\r\n\r\n```shell\r\n./vendor/bin/sail up\r\n```\r\n\r\n<a name=\"adding-additional-services\"></a>\r\n#### 增加额外服务\r\n\r\n如果你想在你现有的 Sail 安装中添加一个额外的服务，你可以运行`sail:add` Artisan 命令。\r\n\r\n```shell\r\nphp artisan sail:add\r\n```\r\n\r\n<a name=\"using-devcontainers\"></a>\r\n#### 使用开发容器\r\n\r\n如果你想在 [Devcontainer](https://code.visualstudio.com/docs/remote/containers) 中进行开发，你可以在执行 `sail:install` 命令时添加 `--devcontainer` 参数。`--devcontainer` 将指示 `sail:install` 命令将默认的 `.devcontainer/devcontainer.json` 文件发布到你的应用程序根目录：\r\n\r\n```shell\r\nphp artisan sail:install --devcontainer\r\n```\r\n\r\n<a name=\"configuring-a-shell-alias\"></a>\r\n### 配置 Shell 别名\r\n\r\n默认情况下，Sail 命令使用 `vendor/bin/sail` 脚本调用，该脚本已包含在所有新建的 Laravel 应用程序中：\r\n\r\n```shell\r\n./vendor/bin/sail up\r\n```\r\n\r\n但与其重复的输入 `vendor/bin/sail` 来执行 Sail 命令，你可能会希望配置一个 Shell 别名方便你更容易的执行 Sail 命令：\r\n\r\n```shell\r\nalias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'\r\n```\r\n\n\n为了确保这一点始终可用，你可以把它添加到你的主目录下的 shell 配置文件中，如 `~/.zshrc` 或 `~/.bashrc` ，然后重新启动你的 shell。\r\n\r\n一旦配置了 shell 别名，你可以通过简单地输入 `sail` 来执行 Sail 命令。本文接下来的示例都假定你已经配置了此别名：\r\n\r\n```shell\r\nsail up\r\n```\r\n\r\n<a name=\"starting-and-stopping-sail\"></a>\r\n## 启动 & 停止 Sail\r\n\r\nLaravel Sail 的 `docker-compose.yml` 文件定义了各种 Docker 容器，它们可以协同工作以帮助你构建 Laravel 应用程序。每一个容器都定义在 `docker-compose.yml` 文件的 `services` 的配置内。 `laravel.test` 容器是将服务于您的应用程序的主要应用程序容器。\r\n\r\n在开始 Sail 之前，你应该确认没有其他的网站服务器或数据库正运行在你的本地计算机上。要开始启用 `docker-compose.yml` 文件中定义的所有 Docker 容器，请执行 `up` 命令：\r\n\r\n```shell\r\nsail up\r\n```\r\n\r\n要在后台启动所有的 Docker 容器，你可以以 \"detached\" 模式启动 Sail。\r\n\r\n```shell\r\nsail up -d\r\n```\r\n\r\n启动应用程序的容器后，你可以通过 Web 浏览器中访问项目：[http://localhost](http://localhost/).\r\n\r\n要停止所有的容器，你可以简单的按 Control + C 来停止容器的执行。或者，如果容器是在后台运行的，你可以使用 `stop` 命令。\r\n\r\n```shell\r\nsail stop\r\n```\r\n\r\n<a name=\"executing-sail-commands\"></a>\r\n## 执行命令\r\n\r\n使用 Laravel Sail 时，应用程序在 Docker 容器中执行，并且与本地计算机隔离。不过 Sail 提供了一种针对应用程序运行各种命令的便捷方法，例如任意的 PHP 命令，Artisan 命令，Composer 命令和 Node / NPM 命令。\r\n\r\n\n\n**当你阅读 Laravel 文档时，你可能经常看到在未使用 Sail 的状况下运行 Composer，Artisan 或是 Node / NPM 命令。** 以下示例假设你已经在本地计算机上安装上述工具。如果你打算使用 Sail 建构你的本地开发环境 ，你需要改用 Sail 运行这些命令：\r\n\r\n```shell\r\n# 在本地运行 Artisan 命令...\r\nphp artisan queue:work\r\n\r\n# 在 Laravel Sail 中运行 Artisan 命令...\r\nsail artisan queue:work\r\n```\r\n\r\n<a name=\"executing-php-commands\"></a>\r\n### 执行 PHP 命令\r\n\r\nPHP 命令可以使用 `php` 命令执行。当然，这些命令将使用为你的应用程序配置的 PHP 版本执行。要了解更多关于 PHP 版本可用的 Laravel Sail 信息，请查阅 [PHP 版本文档](#sail-php-versions)：\r\n\r\n```shell\r\nsail php --version\r\n\r\nsail php script.php\r\n```\r\n\r\n<a name=\"executing-composer-commands\"></a>\r\n### 执行 Composer 命令\r\n\r\nComposer 命令可以使用 `composer` 命令执行。Laravel Sail 的应用程序容器中已经安装 Composer 2.x：\r\n\r\n```nothing\r\nsail composer require laravel/sanctum\r\n```\r\n\r\n<a name=\"installing-composer-dependencies-for-existing-projects\"></a>\r\n#### 在已运行的应用中安装 Composer 依赖\r\n\r\n假如你与团队一起开发应用程序，你也许不是最初创建 Laravel 应用程序的人。因此，当你克隆应用程序的仓库到本地计算机后，仓库默认不会安装的任何 Composer 依赖项，也包括 Sail。\r\n\r\n你可以进入到应用程序目录下并执行以下命令来安装应用所需的依赖，这个命令使用一个包含 PHP 与 Composer 的小型 Docker 容器进行应用程序依赖的安装：\r\n\r\n```shell\r\ndocker run --rm \\\r\n    -u \"$(id -u):$(id -g)\" \\\r\n    -v \"$(pwd):/var/www/html\" \\\r\n    -w /var/www/html \\\r\n    laravelsail/php82-composer:latest \\\r\n    composer install --ignore-platform-reqs\r\n```\r\n\r\n\n\n当你使用 `laravelsail/phpXX-composer` 镜像时，你应该选择和你的应用程序所用环境相同的 PHP 版本（`74`、`80`、`81`或 `82`）。\r\n\r\n<a name=\"executing-artisan-commands\"></a>\r\n### 执行 Artisan 命令\r\n\r\nArtisan 命令可以使用 `artisan` 命令执行：\r\n\r\n```shell\r\nsail artisan queue:work\r\n```\r\n\r\n<a name=\"executing-node-npm-commands\"></a>\r\n### 执行 Node / NPM 命令\r\n\r\nNode 命令可以使用 `node` 命令执行，而 NPM 命令可以使用 `npm` 命令执行：\r\n\r\n```shell\r\nsail node --version\r\n\r\nsail npm run dev\r\n```\r\n\r\n如果你愿意，你可以使用 Yarn 代替 NPM：\r\n\r\n```shell\r\nsail yarn\r\n```\r\n\r\n<a name=\"interacting-with-sail-databases\"></a>\r\n## 与数据库交互\r\n\r\n<a name=\"mysql\"></a>\r\n### MySQL\r\n\r\n你可能已经注意到，应用程序的 `docker-compose.yml` 文件包含一个 MySQL 容器的配置。该容器使用了 [Docker volume](https://docs.docker.com/storage/volumes/)，以便即使在停止和重新启动容器时依然可以持久存储数据库中存储的数据。\r\n\r\n此外，在MySQL容器第一次启动时，它将为你创建两个数据库。第一个数据库使用你的 `DB_DATABASE` 环境变量的值命名，用于你的本地开发。第二个是专门的测试数据库，名为 `testing`，将确保你的测试不会干扰你的开发数据。\r\n\r\n一旦你启动了你的容器，你可以通过在你的应用程序的 `.env` 文件中设置 `DB_HOST` 环境变量来连接到你的应用程序中的 MySQL 实例 `mysql`。\r\n\r\n要从你的本地机器连接到你的应用程序的 MySQL 数据库，你可以使用一个图形化的数据库管理应用程序，如 [TablePlus](https://tableplus.com/)。默认情况下，MySQL 数据库可以通过 `localhost` 端口 3306 访问，访问凭证与 `DB_USERNAME` 和 `DB_PASSWORD` 环境变量的值一致。或者，你可以以 `root` 用户的身份连接，它也利用 `DB_PASSWORD` 环境变量的值作为密码。\r\n\r\n\n\n<a name=\"redis\"></a>\r\n### Redis\r\n\r\n应用程序的 `docker-compose.yml` 文件也包含 [Redis](https://redis.io/) 容器的配置，此容器使用 [Docker volume](https://docs.docker.com/storage/volumes/)，以便即使在停止和重新启动容器后，Redis 数据中存储的数据也可以持久保存。启动容器后，可以通过将应用程序 `.env` 文件中的环境变量 `REDIS_HOST` 设置为 `redis` 来连接到应用程序中的 Redis 实例。\r\n\r\n\r\n要从本地计算机连接到应用程序的 Redis 数据库，可以使用图形数据库管理应用程序，例如 [TablePlus](https://tableplus.com/)。默认情况下，可以从 `localhost` 的 6379 端口访问 Redis 数据库。\r\n\r\n<a name=\"meilisearch\"></a>\r\n### Meilisearch\r\n\r\n如果你在安装 Sail 时选择安装 [MeiliSearch](https://www.meilisearch.com) 服务，你的应用程序的 `docker-compose.yml` 文件将包含一个 [Laravel Scout](/docs/laravel/10.x/scout) 兼容且强大的[搜索引擎服务组件配置](https://github.com/meilisearch/meilisearch-laravel-scout)。启动容器后，你可以通过将环境变量 `MEILISEARCH_HOST` 设置为 `http://meilisearch:7700` 来连接到应用程序中的 MeiliSearch 实例。\r\n\r\n要从本地计算机访问 MeiliSearch 的 Web 管理面板，你可以通过浏览器访问 `http://localhost:7700`。\r\n\r\n<a name=\"file-storage\"></a>\r\n## 文件存储\r\n\r\n如果你计划在生产环境中运行应用程序时使用 Amazon S3 存储文件，你可能希望在安装 Sail 时安装 [MinIO](https://min.io) 服务。 MinIO 提供了一个与 S3 兼容的 API，你可以使用 Laravel 的 `s3` 文件存储驱动程序在本地进行开发，而无需在生产 S3 环境中创建用于测试的存储桶。如果在安装 Sail 时选择安装 MinIO，部分 MinIO 相关的配置将添加到应用程序的 `docker-compose.yml` 文件中。\r\n\r\n\n\n默认情况下，应用程序的 `filesystems`  配置文件已经包含 `s3` 磁盘的磁盘配置。除了使用此磁盘与 Amazon S3 交互之外，你还可以使用它与任何 S3 兼容的文件存储服务（例如 MinIO）进行交互，只需修改控制其配置的关联环境变量即可。例如，在使用 MinIO 时，你的文件系统环境变量配置应定义如下：\r\n\r\n```ini\r\nFILESYSTEM_DISK=s3\r\nAWS_ACCESS_KEY_ID=sail\r\nAWS_SECRET_ACCESS_KEY=password\r\nAWS_DEFAULT_REGION=us-east-1\r\nAWS_BUCKET=local\r\nAWS_ENDPOINT=http://minio:9000\r\nAWS_USE_PATH_STYLE_ENDPOINT=true\r\n```\r\n\r\n为了让 Laravel 的 Flysystem 集成在使用 MinIO 时产生正确的 URL，你应该定义 `AWS_URL` 环境变量，使其与你的应用程序的本地 URL 相匹配，并在 URL 路径中包含桶的名称。\r\n\r\n```ini\r\nAWS_URL=http://localhost:9000/local\r\n```\r\n\r\n你可以通过 MinIO 控制台创建桶，该控制台可在 `http://localhost:8900` 。MinIO 控制台的默认用户名是 `sail`，默认密码是 `password`。\r\n\r\n> **警告**\r\n> 使用 MinIO 时，不支持通过 `temporaryUrl` 方法生成临时存储的 URL。\r\n\r\n<a name=\"running-tests\"></a>\r\n## 运行测试\r\n\r\nLaravel 提供了出色的开箱即用测试，你可以使用 Sail 的 `test` 命令运行应用程序的 [功能和单元测试](/docs/laravel/10.x/testing)。任何 PHPUnit 可接受的命令选项都可以透过 `test` 命令传递：\r\n\r\n```shell\r\nsail test\r\n\r\nsail test --group orders\r\n```\r\n\r\nSail `test` 命令相当于运行 Artisan `test` 命令：\r\n\r\n```shell\r\nsail artisan test\r\n```\r\n\r\n\n\n默认情况下, Sail会创建一个专门的 `测试` 数据库, 这样你的测试就不会干扰到你的数据库的当前状态. 在默认的Laravel安装中, Sail也会配置你的 `phpunit.xml` 文件, 在执行你的测试时使用这个数据库:\r\n\r\n```xml\r\n<env name=\"DB_DATABASE\" value=\"testing\"/>\r\n```\r\n\r\n<a name=\"laravel-dusk\"></a>\r\n### Laravel Dusk\r\n\r\n[Laravel Dusk](/docs/laravel/10.x/dusk) 提供了非常优雅、易于使用的浏览器自动化测试 API。有了 Sail，进行浏览器测试更加方便了，你甚至不用在你的本地电脑上安装 Selenium 或者任何其他工具。要开启这项功能，请在 `docker-compose.yml` 文件中取消 Selenium 服务相关配置的注释：\r\n\r\n```yaml\r\nselenium:\r\n    image: 'selenium/standalone-chrome'\r\n    volumes:\r\n        - '/dev/shm:/dev/shm'\r\n    networks:\r\n        - sail\r\n```\r\n\r\n下一步，请确认 `docker-compose.yml` 文件中的 `laravel.test` 服务配置 `depends_on` 是否包含了 `selenium` 选项：\r\n\r\n```yaml\r\ndepends_on:\r\n    - mysql\r\n    - redis\r\n    - selenium\r\n```\r\n\r\n最后，你可以透过启动 Sail 并运行 `dusk` 命令来进行 Dusk 测试：\r\n\r\n```shell\r\nsail dusk\r\n```\r\n\r\n<a name=\"selenium-on-apple-silicon\"></a>\r\n#### 在 Apple Silicon 上运行 Selenium\r\n\r\n如果你的本地机器包含 Apple Silicon 芯片，你的 `selenium` 服务必须使用 `seleniarm/standalone-chromium` 镜像：\r\n\r\n```yaml\r\nselenium:\r\n    image: 'seleniarm/standalone-chromium'\r\n    volumes:\r\n        - '/dev/shm:/dev/shm'\r\n    networks:\r\n        - sail\r\n```\r\n\r\n<a name=\"previewing-emails\"></a>\r\n## 预览电子邮件\r\n\r\nLaravel Sail 默认的 `docker-compose.yml` 文件中包含了一个服务项 [Mailpit](https://github.com/axllent/mailpit)。Mailpit 在本地开发过程中拦截应用程序发送的邮件，并提供一个便捷的 Web 界面，这样你就可以在浏览器中预览你的邮件。当使用 Sail 时，Mailpit 的默认主机是 `mailpit` ，可通过端口 1025 使用。\r\n\r\n```ini\r\nMAIL_HOST=mailpit\r\nMAIL_PORT=1025\r\nMAIL_ENCRYPTION=null\r\n```\r\n\r\n\n\n当 Sail 运行时，你可以透过 [http://localhost:8025](http://localhost:8025/) 访问 Mailpit 的 Web 界面。\r\n\r\n\r\n<a name=\"sail-container-cli\"></a>\r\n## 容器 CLI\r\n\r\n有时候，你可能想要在应用容器中开启一个 Bash 会话。 可以通过执行 `shell` 命令，以访问容器中的文件和已安装的服务，此外，你还可以执行其他任意 Shell 指令：\r\n\r\n```shell\r\nsail shell\r\n\r\nsail root-shell\r\n```\r\n\r\n想打开一个新的 [Laravel Tinker](https://github.com/laravel/tinker) 会话，你可以执行 `tinker` 命令：\r\n\r\n```shell\r\nsail tinker\r\n```\r\n\r\n<a name=\"sail-php-versions\"></a>\r\n## PHP 版本\r\n\r\nSail目前支持通过 PHP 8.2、8.1、PHP 8.0 或 PHP 7.4 为你的应用程序提供服务。目前 Sail 使用的默认 PHP 版本是 PHP 8.2。想更改应用程序使用的 PHP 版本，请在 `docker-compose.yml` 文件定义的容器 `laravel.test` 相应配置中调整 `build` 定义:\r\n\r\n```yaml\r\n# PHP 8.2\r\ncontext: ./vendor/laravel/sail/runtimes/8.2\r\n\r\n# PHP 8.1\r\ncontext: ./vendor/laravel/sail/runtimes/8.1\r\n\r\n# PHP 8.0\r\ncontext: ./vendor/laravel/sail/runtimes/8.0\r\n\r\n# PHP 7.4\r\ncontext: ./vendor/laravel/sail/runtimes/7.4\r\n```\r\n\r\n此外，你如果想更新你的镜像名称来反映当前使用的 PHP 版本，你可以在 `docker-compose.yml` 文件中调整 `image` 字段：\r\n\r\n```yaml\r\nimage: sail-8.1/app\r\n```\r\n\r\n在修改 `docker-compose.yml` 文件过后，你需要重建容器镜像并重启 Sail：\r\n\r\n```shell\r\nsail build --no-cache\r\n\r\nsail up\r\n```\r\n\r\n<a name=\"sail-node-versions\"></a>\r\n## Node 版本\r\n\r\nSail 默认安装 Node 18。要更改镜像构建时所安装的 Node 版本，你可以在应用程序的 `docker-compose.yml` 文件中更新 `laravel.test` 服务的 `build.args` 定义：\r\n\r\n```yaml\r\nbuild:\r\n    args:\r\n        WWWGROUP: '${WWWGROUP}'\r\n        NODE_VERSION: '14'\r\n```\r\n\r\n在修改 `docker-compose.yml` 文件过后，你需要重建容器镜像并重启 Sail：\r\n\r\n```shell\r\nsail build --no-cache\r\n\r\nsail up\r\n```\r\n\r\n\n\n<a name=\"sharing-your-site\"></a>\r\n## 共享你的网站\r\n\r\n有时候你可能需要公开分享你的网站给同事，或是测试应用与 Webhook 的集成。想共享你的网站时，可以使用 `share` 命令。当你执行此命令后，将会获取一个随机的网址，例如 `laravel-sail.site` 用来访问你的应用程序：\r\n\r\n```shell\r\nsail share\r\n```\r\n\r\n当通过 `share` 命令共享你的站点时，你应该在 `TrustProxies` 中间件中配置应用程序的可信代理。否则，相关的URL 生成的助手函数，例如 `url` 和 `route` 将无法在生成 URL 生成过程中选择正确 HTTP 主机地址：\r\n\r\n    /**\r\n     * 应用程序的受信任代理\r\n     *\r\n     * @var array|string|null\r\n     */\r\n    protected $proxies = '*';\r\n\r\n如果你想为你的共享站点自定义子域名，可以在执行 `share` 命令时加上 `subdomain` 参数：\r\n\r\n```shell\r\nsail share --subdomain=my-sail-site\r\n```\r\n\r\n> **注意**\r\n> `share` 命令是由 [Expose](https://github.com/beyondcode/expose) 提供，这是 [BeyondCode](https://beyondco.de/) 的一个开源网络隧道服务。\r\n\r\n<a name=\"debugging-with-xdebug\"></a>\r\n## 使用 Xdebug 进行调试\r\n\r\nLaravel Sail 的 Docker 配置包含对 [Xdebug](https://xdebug.org/) 的支持，这是一个流行且强大的 PHP 调试器。为了启用 Xdebug，你需要在应用程序的 `.env` 文件中添加一些变量以 [配置 Xdebug](https://xdebug.org/docs/step_debug#mode)。要启用 Xdebug，你必须在启动 Sail 之前设置适当的应用模式：\r\n\r\n```ini\r\nSAIL_XDEBUG_MODE=develop,debug,coverage\r\n```\r\n\r\n#### Linux 主机 IP 配置\r\n\r\n\n\n在容器内部，`XDEBUG_CONFIG` 环境变量被定义为 `client_host=host.docker.internal` 以便为 Mac 和 Windows (WSL2) 正确配置 Xdebug。如果你的本地机器运行的是 Linux，确保你运行的是 Docker Engine 17.06.0+ 和 Compose 1.16.0+。否则，你将需要手动定义这个环境变量。\r\n\r\n首先，你需要通过运行以下命令来确定要添加到环境变量中的正确主机 IP 地址。通常，`<container-name>` 应该是为你的应用程序提供服务的容器的名称，并且通常以 `_laravel.test_1` 结尾：\r\n\r\n```shell\r\ndocker inspect -f {{range.NetworkSettings.Networks}}{{.Gateway}}{{end}} <container-name>\r\n```\r\n\r\n在获得正确的主机 IP 地址后，你需要在应用程序的 `.env` 文件中定义 `SAIL_XDEBUG_CONFIG` 变量：\r\n\r\n```ini\r\nSAIL_XDEBUG_CONFIG=\"client_host=<host-ip-address>\"\r\n```\r\n\r\n<a name=\"xdebug-cli-usage\"></a>\r\n### 通过命令行使用 Xdebug 进行调试\r\n\r\n在运行 Artisan 命令时，可以使用 `sail debug` 命令启动调试会话：\r\n\r\n```shell\r\n# 在没有 Xdebug 的情况下运行 Artisan 命令...\r\nsail artisan migrate\r\n\r\n# 使用 Xdebug 运行 Artisan 命令...\r\nsail debug migrate\r\n```\r\n\r\n<a name=\"xdebug-browser-usage\"></a>\r\n### 通过浏览器使用 Xdebug 进行调试\r\n\r\n要在通过 Web 浏览器与应用程序交互时调试你的应用程序，请按照 [Xdebug 提供的说明](https://xdebug.org/docs/step_debug#web-application) 从 Web 浏览器启动 Xdebug 会话。\r\n\r\n如果你使用的是 PhpStorm，请查看 JetBrains 关于 [零配置调试](https://www.jetbrains.com/help/phpstorm/zero-configuration-debugging.html) 的文档。\r\n\r\n> **警告**\r\n> Laravel Sail 依赖于 `artisan serve` 来为你的应用程序提供服务。从 Laravel 8.53.0 版本开始，`artisan serve` 命令只接受 `XDEBUG_CONFIG` 和 `XDEBUG_MODE` 变量。从 Laravel 8.53.0 版本开始，旧版本的 Laravel（8.52.0 及以下）不支持这些变量并且不接受调试连接。\r\n\n\n<a name=\"sail-customization\"></a>\r\n## 定制化\r\n\r\n因为 Sail 就是 Docker，所以你可以自由的定制任何内容，使用 `sail:publish` 命令可以将 Sail 预设的 Dockerfile 发布到你的应用程序中，以便于进行定制：\r\n\r\n```shell\r\nsail artisan sail:publish\r\n```\r\n\r\n运行这个命令后，Laravel Sail 预设好的 Dockerfile 和其他配置文件将被生成发布到项目根目录的 `docker` 目录中。当你自行定制 Sail 配置之后，你可以在应用程序的 `docker-compose.yml` 文件中更改应用程序容器的映像名称。在完成上述操作后，你需要使用 `build` 命令重新构建容器。如果你使用 Sail 在单台机器上开发多个 Laravel 应用程序，那么为应用程序的镜像分配一个唯一的名称将尤为重要：\r\n\r\n```shell\r\nsail build --no-cache\r\n```\r\n\n","p":"docs/sail.html"},{"t":"sanctum (Laravel Sanctum)","d":"# Laravel Sanctum\r\n\r\n-   [介绍](#introduction)\r\n    -   [工作原理](#how-it-works)\r\n-   [安装](#installation)\r\n-   [配置](#configuration)\r\n    -   [覆盖默认模型](#overriding-default-models)\r\n-   [API 令牌认证](#api-token-authentication)\r\n    -   [发出 API 令牌](#issuing-api-tokens)\r\n    -   [令牌权限](#token-abilities)\r\n    -   [保护路由](#protecting-routes)\r\n    -   [吊销令牌](#revoking-tokens)\r\n    -   [令牌过期](#token-expiration)\r\n-   [SPA 认证](#spa-authentication)\r\n    -   [配置](#spa-configuration)\r\n    -   [认证](#spa-authenticating)\r\n    -   [保护路由](#protecting-spa-routes)\r\n    -   [授权私有广播频道](#authorizing-private-broadcast-channels)\r\n-   [移动应用程序认证](#mobile-application-authentication)\r\n    -   [发出 API 令牌](#issuing-mobile-api-tokens)\r\n    -   [保护路由](#protecting-mobile-api-routes)\r\n    -   [吊销令牌](#revoking-mobile-api-tokens)\r\n-   [测试](#testing)\r\n\r\n<a name=\"introduction\"></a>\r\n\r\n## 介绍\r\n\r\n[Laravel Sanctum](https://github.com/laravel/sanctum) 提供了一个轻量级的认证系统，可用于 SPA（单页应用程序）、移动应用程序和基于简单令牌的 API。Sanctum 允许的应用程序中的每个用户为他们的账户生成多个 API 令牌。这些令牌可以被授予权限/范围，以指定令牌允许执行哪些操作。\r\n\r\n<a name=\"how-it-works\"></a>\r\n\r\n### 工作原理\r\n\r\nLaravel Sanctum 旨在解决两个不同的问题。在深入探讨该库之前，让我们先讨论一下每个问题。\r\n\r\n<a name=\"how-it-works-api-tokens\"></a>\r\n\r\n#### API 令牌\r\n\r\n首先，Sanctum 是一个简单的包，你可以使用它向你的用户发出 API 令牌，而无需 OAuth 的复杂性。这个功能受到 GitHub 和其他应用程序发出「访问令牌」的启发。例如，假如你的应用程序的「账户设置」有一个界面，用户可以在其中为他们的账户生成 API 令牌。你可以使用 Sanctum 生成和管理这些令牌。这些令牌通常具有非常长的过期时间（以年计），但用户可以随时手动撤销它们。\r\n\r\nLaravel Sanctum 通过将用户 API 令牌存储在单个数据库表中，并通过应该包含有效 API 令牌的 `Authorization` 标头对传入的 HTTP 请求进行身份验证来提供此功能。\r\n\r\n<a name=\"how-it-works-spa-authentication\"></a>\r\n\r\n#### SPA 认证\r\n\r\n第二个功能，Sanctum 存在的目的是为需要与 Laravel 支持的 API 通信的单页应用程序 (SPAs) 提供一种简单的身份验证方式。这些 SPAs 可能存在于与 Laravel 应用程序相同的存储库中，也可能是一个完全独立的存储库，例如使用 Vue CLI 创建的 SPA 或 Next.js 应用程序。\r\n\r\n对于此功能，Sanctum 不使用任何类型的令牌。相反，Sanctum 使用 Laravel 内置基于 cookie 的会话身份验证服务。通常，Sanctum 使用 Laravel 的 `web` 认证保护方式实现这一点。这提供了 CSRF 保护、会话身份验证以及防止通过 XSS 泄漏身份验证凭据的好处。\r\n\r\n只有在传入请求来自你自己的 SPA 前端时，Sanctum 才会尝试使用 cookies 进行身份验证。当 Sanctum 检查传入的 HTTP 请求时，它首先会检查身份验证 cookie，如果不存在，则 Sanctum 会检查 `Authorization` 标头是否包含有效的 API 令牌。\r\n\r\n> **注意**\r\n> 完全可以只使用 Sanctum 进行 API 令牌身份验证或只使用 Sanctuary 进行 SPA 身份验证。仅因为你使用 Sanctum 并不意味着你必须使用它提供的两个功能。\r\n\r\n<a name=\"installation\"></a>\r\n\r\n## 安装\r\n\r\n> **注意**\r\n> 最近的 Laravel 版本已经包括 Laravel Sanctum。但如果你的应用程序的 `composer.json` 文件不包括 `laravel/sanctum`，你可以遵循下面的安装说明。\r\n\r\n你可以通过 Composer 包管理器安装 Laravel Sanctum：\r\n\r\n```shell\r\ncomposer require laravel/sanctum\r\n```\r\n\r\n接下来，你应该使用 `vendor:publish` Artisan 命令发布 Sanctum 配置文件和迁移文件。`sanctum` 配置文件将被放置在你的应用程序的 `config` 目录中：\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Sanctum\\SanctumServiceProvider\"\r\n```\r\n\r\n最后，你应该运行数据库迁移。Sanctum 会创建一个数据库表来存储 API 令牌：\r\n\r\n```shell\r\nphp artisan migrate\r\n```\r\n\r\n接下来，如果你打算使用 Sanctum 来对 SPA 单页应用程序进行认证，则应该将 Sanctum 的中间件添加到你的应用程序的 `app/Http/Kernel.php` 文件中的 `api` 中间件组中：\r\n\r\n```\r\n'api' => [\r\n\\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class,\r\n   \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class.':api',\r\n   \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n],\r\n```\r\n\r\n<a name=\"migration-customization\"></a>\r\n\r\n#### 自定义迁移\r\n\r\n如果你不打算使用 Sanctum 的默认迁移文件，则应该在 `App\\Providers\\AppServiceProvider` 类的 `register` 方法中调用 `Sanctum::ignoreMigrations` 方法。你可以通过执行以下命令导出默认的迁移文件：`php artisan vendor:publish --tag=sanctum-migrations`\r\n\r\n<a name=\"configuration\"></a>\r\n\r\n## 配置\r\n\r\n<a name=\"overriding-default-models\"></a>\r\n\r\n### 覆盖默认模型\r\n\r\n虽然通常不需要，但你可以自由扩展 Sanctum 内部使用的 `PersonalAccessToken` 模型:\r\n\r\n```\r\nuse Laravel\\Sanctum\\PersonalAccessToken as SanctumPersonalAccessToken;\r\n\r\nclass PersonalAccessToken extends SanctumPersonalAccessToken\r\n{\r\n    // ...\r\n}\r\n```\r\n\r\n然后，你可以通过 Sanctum 提供的 `usePersonalAccessTokenModel` 方法来指示 Sanctum 使用你的自定义模型。通常，你应该在一个应用程序的服务提供者的 `boot` 方法中调用此方法：\r\n\r\n```\r\nuse App\\Models\\Sanctum\\PersonalAccessToken;\r\nuse Laravel\\Sanctum\\Sanctum;\r\n\r\n/**\r\n * 引导任何应用程序服务。\r\n */\r\npublic function boot(): void\r\n{\r\n    Sanctum::usePersonalAccessTokenModel(PersonalAccessToken::class);\r\n}\r\n```\r\n\r\n<a name=\"api-token-authentication\"></a>\r\n\r\n## API 令牌认证\r\n\r\n> **注意**\r\n> 你不应该使用 API 令牌来认证你自己的第一方单页应用程序。而应该使用 Sanctum 内置的 [SPA 身份验证功能](#spa-authentication)。\r\n\r\n<a name=\"issuing-api-tokens\"></a>\r\n\r\n### 发行 API 令牌\r\n\r\nSanctum 允许你发行 API 令牌/个人访问令牌，可用于对你的应用程序的 API 请求进行身份验证。使用 API 令牌发出请求时，应将令牌作为 `Bearer` 令牌包括在 `Authorization` 头中。\r\n\r\n要开始为用户发行令牌，你的用户模型应该使用 `Laravel\\Sanctum\\HasApiTokens` trait：\r\n\r\n```\r\nuse Laravel\\Sanctum\\HasApiTokens;\r\n\r\nclass User extends Authenticatable\r\n{\r\n    use HasApiTokens, HasFactory, Notifiable;\r\n}\r\n```\r\n\r\n要发行令牌，你可以使用 `createToken` 方法。`createToken` 方法会返回一个 `Laravel\\Sanctum\\NewAccessToken` 实例。在将 API 令牌存储到数据库之前，令牌将使用 SHA-256 哈希进行哈希处理，但是你可以通过 `NewAccessToken` 实例的 `plainTextToken` 属性访问令牌的明文值。你应该在令牌被创建后立即将其值显示给用户：\r\n\r\n```\r\nuse Illuminate\\Http\\Request;\r\n\r\nRoute::post('/tokens/create', function (Request $request) {\r\n    $token = $request->user()->createToken($request->token_name);\r\n\r\n    return ['token' => $token->plainTextToken];\r\n});\r\n\r\n```\r\n你可以使用 `HasApiTokens` trait 提供的 `tokens` Eloquent 关联来访问用户的所有令牌：\r\n\r\n```\r\nforeach ($user->tokens as $token) {\r\n    // ...\r\n}\r\n```\r\n\r\n<a name=\"token-abilities\"></a>\r\n\r\n### 令牌能力\r\n\r\nSanctum 允许你为令牌分配「能力」 。能力的作用类似于 OAuth 的「Scope」 。你可以将一个字符串能力数组作为 `createToken` 方法的第二个参数传递：\r\n\r\n```\r\nreturn $user->createToken('token-name', ['server:update'])->plainTextToken;\r\n```\r\n\r\n当处理由 Sanctum 验证的入站请求时，你可以使用 `tokenCan` 方法确定令牌是否具有给定的能力：\r\n\r\n```\r\nif ($user->tokenCan('server:update')) {\r\n    // ...\r\n}\r\n```\r\n\r\n<a name=\"token-ability-middleware\"></a>\r\n\r\n#### 令牌能力中间件\r\n\r\nSanctum 还包括两个中间件，可用于验证传入的请求是否使用授予了给定能力的令牌进行了身份验证。首先，请将以下中间件添加到应用程序的 `app/Http/Kernel.php` 文件的 `$middlewareAliases` 属性中：\r\n\r\n```\r\n'abilities' => \\Laravel\\Sanctum\\Http\\Middleware\\CheckAbilities::class,\r\n'ability' => \\Laravel\\Sanctum\\Http\\Middleware\\CheckForAnyAbility::class,\r\n```\r\n\r\n可以将 `abilities` 中间件分配给路由，以验证传入请求的令牌是否具有所有列出的能力：\r\n\r\n```\r\nRoute::get('/orders', function () {\r\n    // 令牌具有「check-status」和「place-orders」能力...\r\n})->middleware(['auth:sanctum', 'abilities:check-status,place-orders']);\r\n\r\n```\r\n\r\n可以将 `ability` 中间件分配给路由，以验证传入请求的令牌是否至少具有一个列出的能力：\r\n\r\n```\r\nRoute::get('/orders', function () {\r\n    // 令牌具有「check-status」或「place-orders」能力...\r\n})->middleware(['auth:sanctum', 'ability:check-status,place-orders']);\r\n\r\n```\r\n\r\n<a name=\"first-party-ui-initiated-requests\"></a>\r\n\r\n#### 第一方 UI 启动的请求\r\n\r\n为了方便起见，如果入站身份验证请求来自你的第一方 SPA ，并且你正在使用 Sanctum 内置的 [SPA 认证](#spa-authentication)，`tokenCan` 方法将始终返回 `true`。\r\n\r\n然而，这并不一定意味着你的应用程序必须允许用户执行该操作。通常，你的应用程序的[授权策略](/docs/laravel/10.x/authorization#creating-policies) 将确定是否已授予令牌执行能力的权限，并检查用户实例本身是否允许执行该操作。\r\n\r\n例如，如果我们想象一个管理服务器的应用程序，这可能意味着检查令牌是否被授权更新服务器**并且**服务器属于用户：\r\n\r\n```php\r\nreturn $request->user()->id === $server->user_id &&\r\n       $request->user()->tokenCan('server:update')\r\n```\r\n\r\n首先允许 `tokenCan` 方法被调用并始终为第一方 UI 启动的请求返回 `true` 可能看起来很奇怪。然而，能够始终假设 API 令牌可用并可通过 `tokenCan` 方法进行检查非常方便。通过采用这种方法，你可以始终在应用程序的授权策略中调用 `tokenCan` 方法，而不用再担心请求是从应用程序的 UI 触发还是由 API 的第三方使用者发起的。\r\n\r\n<a name=\"protecting-routes\"></a>\r\n\r\n### 保护路由\r\n\r\n为了保护路由，使所有入站请求必须进行身份验证，你应该在你的 `routes/web.php` 和 `routes/api.php` 路由文件中，将 `sanctum` 认证守卫附加到受保护的路由上。如果该请求来自第三方，该守卫将确保传入的请求经过身份验证，要么是具有状态的 Cookie 身份验证请求，要么是包含有效的 API 令牌标头的请求。\r\n\r\n你可能想知道我们为什么建议你使用 `sanctum` 守卫在应用程序的 `routes/web.php` 文件中对路由进行身份验证。请记住，Sanctum 首先将尝试使用 Laravel 的典型会话身份验证 cookie 对传入请求进行身份验证。如果该 cookie 不存在，则 Sanctum 将尝试使用请求的 `Authorization` 标头中的令牌来验证请求。此外，使用 Sanctum 对所有请求进行身份验证，确保我们可以始终在当前经过身份验证的用户实例上调用 `tokenCan` 方法：\r\n\r\n```\r\nuse Illuminate\\Http\\Request;\r\n\r\nRoute::middleware('auth:sanctum')->get('/user', function (Request $request) {\r\n    return $request->user();\r\n});\r\n```\r\n\r\n<a name=\"revoking-tokens\"></a>\r\n\r\n### 撤销令牌\r\n\r\n你可以通过使用 `Laravel\\Sanctum\\HasApiTokens` trait 提供的 `tokens` 关系，从数据库中删除它们来达到「撤销」令牌的目的：\r\n\r\n```\r\n// 撤销所有令牌...\r\n$user->tokens()->delete();\r\n\r\n// 撤销用于验证当前请求的令牌...\r\n$request->user()->currentAccessToken()->delete();\r\n\r\n// 撤销特定的令牌...\r\n$user->tokens()->where('id', $tokenId)->delete();\r\n\r\n```\r\n\r\n<a name=\"token-expiration\"></a>\r\n\r\n### 令牌有效期\r\n\r\n默认情况下，Sanctum 令牌永不过期，并且只能通过[撤销令牌](#revoking-tokens)进行无效化。但是，如果你想为你的应用程序 API 令牌配置过期时间，可以通过在应用程序的 `sanctum` 配置文件中定义的 `expiration` 配置选项进行配置。此配置选项定义发放的令牌被视为过期之前的分钟数：\r\n\r\n```php\r\n// 365天后过期\r\n'expiration' => 525600,\r\n```\r\n\r\n如果你已为应用程序配置了令牌过期时间，你可能还希望[任务调度](/docs/laravel/10.x/scheduling)来删除应用程序过期的令牌。幸运的是，Sanctum 包括一个 `sanctum:prune-expired` Artisan 命令，你可以使用它来完成此操作。例如，你可以配置计划任务来删除所有过期至少24小时的令牌数据库记录：\r\n\r\n```php\r\n$schedule->command('sanctum:prune-expired --hours=24')->daily();\r\n```\r\n\r\n<a name=\"spa-authentication\"></a>\r\n\r\n## SPA 身份验证\r\n\r\nSanctum 还提供一种简单的方法来验证需要与 Laravel API 通信的单页面应用程序（SPA）。这些 SPA 可能存在于与你的 Laravel 应用程序相同的存储库中，也可能是一个完全独立的存储库。\r\n\r\n对于此功能，Sanctum 不使用任何类型的令牌。相反，Sanctum 使用 Laravel 内置的基于 cookie 的 session 身份验证服务。此身份验证方法提供了 CSRF 保护、session 身份验证以及防止身份验证凭据通过 XSS 泄漏的好处。\r\n\r\n> **警告**\r\n> 为了进行身份验证，你的 SPA 和 API 必须共享相同的顶级域。但是，它们可以放置在不同的子域中。此外，你应该确保你的请求中发送 `Accept: application/json` 头文件。\r\n\r\n<a name=\"spa-configuration\"></a>\r\n\r\n### 配置\r\n\r\n<a name=\"configuring-your-first-party-domains\"></a>\r\n\r\n#### 配置你的第一个域\r\n\r\n首先，你应该通过 `sanctum` 配置文件中的 `stateful` 配置选项来配置你的 SPA 将从哪些域发出请求。此配置设置确定哪些域将在向你的 API 发送请求时使用 Laravel session cookie 维护「有状态的」身份验证。\r\n\r\n> **警告**\r\n> 如果你通过包含端口的 URL（`127.0.0.1:8000`）访问应用程序，你应该确保在域名中包括端口号。\r\n\r\n<a name=\"sanctum-middleware\"></a>\r\n\r\n#### Sanctum 中间件\r\n\r\n接下来，你应该将 Sanctum 中间件添加到你的 `app/Http/Kernel.php` 文件中的 `api` 中间件组中。此中间件负责确保来自你的 SPA 的传入请求可以使用 Laravel 会话 cookie 进行身份验证，同时仍允许来自第三方或移动应用程序使用 API 令牌进行身份验证：\r\n\r\n```\r\n'api' => [ \\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class,\r\n   \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class.':api',\r\n   \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n],\r\n\r\n```\r\n\r\n<a name=\"cors-and-cookies\"></a>\r\n\r\n#### CORS 和 Cookies\r\n\r\n如果你无法从执行在单独子域上的 SPA 中进行应用程序身份验证的话，你可能已错误配置了 CORS（跨域资源共享）或会话 cookie 设置。\r\n\r\n你应该确保你的应用程序的 CORS 配置返回的 `Access-Control-Allow-Credentials` 请求头的值为 `True` 。这可以通过在应用程序的 `config/cors.php` 配置文件中设置 `supports_credentials` 选项为 `true` 来完成。\r\n\r\n此外，你应该在应用程序的全局 `axios` 实例中启用 `withCredentials` 选项。通常，这应该在你的 `resources/js/bootstrap.js` 文件中进行。如果你没有使用 Axios 从前端进行 HTTP 请求，你应该使用自己的 HTTP 客户端进行等效配置：\r\n\r\n```js\r\naxios.defaults.withCredentials = true;\r\n```\r\n\r\n最后，你应该确保应用程序的会话 cookie 域配置支持根域的任何子域。你可以通过在应用程序的 `config/session.php` 配置文件中使用前导 `.` 作为域的前缀来实现此目的：\r\n\r\n```\r\n'domain' => '.domain.com',\r\n```\r\n\r\n<a name=\"spa-authenticating\"></a>\r\n\r\n### 身份验证\r\n\r\n<a name=\"csrf-protection\"></a>\r\n\r\n#### CSRF 保护\r\n\r\n要验证你的 SPA，你的 SPA 的「登录」页面应首先向 `/sanctum/csrf-cookie` 发出请求以初始化应用程序的 CSRF 保护：\r\n\r\n```js\r\naxios.get('/sanctum/csrf-cookie').then(response => {\r\n    // Login...\r\n});\r\n```\r\n\r\n在此请求期间，Laravel 将设置一个包含当前 CSRF 令牌的 `XSRF-TOKEN` cookie。然后，此令牌应在随后的请求中通过 `X-XSRF-TOKEN` 标头传递，其中某些 HTTP 客户端库（如 Axios 和 Angular HttpClient）将自动为你执行此操作。如果你的 JavaScript HTTP 库没有为你设置值，你将需要手动设置 `X-XSRF-TOKEN` 请求头以匹配此路由设置的  `XSRF-TOKEN` cookie 的值。\r\n\r\n<a name=\"logging-in\"></a>\r\n\r\n#### 登录\r\n\r\n一旦已经初始化了 CSRF 保护，你应该向 Laravel 应用程序的 `/login` 路由发出 `POST` 请求。这个 `/login` 路由可以通过[手动实现](/docs/laravel/10.x/authentication#authenticating-users)或使用像 [Laravel Fortify](/docs/laravel/10.x/fortify) 这样的无请求头身份验证包来实现。\r\n\r\n如果登录请求成功，你将被验证，随后对应用程序路由的后续请求将通过 Laravel 应用程序发出的会话 cookie 自动进行身份验证。此外，由于你的应用程序已经发出了对 `/sanctum/csrf-cookie` 路由的请求，因此只要你的 JavaScript HTTP 客户端在 `X-XSRF-TOKEN` 标头中发送了 `XSRF-TOKEN` cookie 的值，后续的请求应该自动接受 CSRF 保护。\r\n\r\n当然，如果你的用户会话因缺乏活动而过期，那么对 Laravel 应用程序的后续请求可能会收到 401 或 419 HTTP 错误响应。在这种情况下，你应该将用户重定向到你 SPA 的登录页面。\r\n\r\n> **警告**\r\n> 你可以自己编写 `/login` 端点；但是，你应该确保使用 Laravel 提供的标准基于[会话的身份验证服务](/docs/laravel/10.x/authentication#authenticating-users)来验证用户。通常，这意味着使用 `web` 身份验证 Guard。\r\n\r\n<a name=\"protecting-spa-routes\"></a>\r\n\r\n### 保护路由\r\n\r\n为了保护路由，以便所有传入的请求必须进行身份验证，你应该将 `sanctum` 身份验证 guard 附加到 `routes/api.php` 文件中的 API 路由上。这个 guard 将确保传入的请求被验证为来自你的 SPA 的有状态身份验证请求，或者如果请求来自第三方，则包含有效的 API 令牌标头：\r\n\r\n```\r\nuse Illuminate\\Http\\Request;\r\n\r\nRoute::middleware('auth:sanctum')->get('/user', function (Request $request) {\r\n    return $request->user();\r\n});\r\n```\r\n\r\n<a name=\"authorizing-private-broadcast-channels\"></a>\r\n\r\n### 授权私有广播频道\r\n\r\n如果你的 SPA 需要对[私有/存在 broadcast 频道进行身份验证](/docs/laravel/10.x/broadcasting#authorizing-channels)，你应该在 `routes/api.php` 文件中调用 `Broadcast::routes` 方法：\r\n\r\n```\r\nBroadcast::routes(['middleware' => ['auth:sanctum']]);\r\n\r\n```\r\n\r\n接下来，为了让 Pusher 的授权请求成功，你需要在初始化 [Laravel Echo](/docs/laravel/10.x/broadcasting#client-side-installation) 时提供自定义的 Pusher `authorizer`。这允许你的应用程序配置 Pusher 以使用[为跨域请求正确配置的](#cors-and-cookies) `axios` 实例：\r\n\r\n```js\r\nwindow.Echo = new Echo({\r\n    broadcaster: \"pusher\",\r\n    cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,\r\n    encrypted: true,\r\n    key: import.meta.env.VITE_PUSHER_APP_KEY,\r\n    authorizer: (channel, options) => {\r\n        return {\r\n            authorize: (socketId, callback) => {\r\n                axios.post('/api/broadcasting/auth', {\r\n                    socket_id: socketId,\r\n                    channel_name: channel.name\r\n                })\r\n                .then(response => {\r\n                    callback(false, response.data);\r\n                })\r\n                .catch(error => {\r\n                    callback(true, error);\r\n                });\r\n            }\r\n        };\r\n    },\r\n})\r\n```\r\n\r\n<a name=\"mobile-application-authentication\"></a>\r\n\r\n## 移动应用程序身份验证\r\n\r\n你也可以使用 Sanctum 令牌来验证你的移动应用程序对 API 的请求。验证移动应用程序请求的过程类似于验证第三方 API 请求；但是，你将发布 API 令牌的方式有所不同。\r\n\r\n<a name=\"issuing-mobile-api-tokens\"></a>\r\n\r\n### 发布 API 令牌\r\n\r\n首先，请创建一个路由，该路由接受用户的电子邮件/用户名、密码和设备名称，然后将这些凭据交换为新的 Sanctum 令牌。给此端点提供「设备名称」的目的是为了记录信息，仅供参考。通常来说，设备名称值应该是用户能够识别的名称，例如「Nuno’s iPhone 12」。\r\n\r\n通常，你将从你的移动应用程序的「登录」页面向令牌端点发出请求。此端点将返回纯文本的 API 令牌，可以存储在移动设备上，并用于进行额外的 API 请求：\r\n\r\n```\r\nuse App\\Models\\User;\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Facades\\Hash;\r\nuse Illuminate\\Validation\\ValidationException;\r\n\r\nRoute::post('/sanctum/token', function (Request $request) {\r\n    $request->validate([\r\n        'email' => 'required|email',\r\n        'password' => 'required',\r\n        'device_name' => 'required',\r\n    ]);\r\n\r\n    $user = User::where('email', $request->email)->first();\r\n\r\n    if (! $user || ! Hash::check($request->password, $user->password)) {\r\n        throw ValidationException::withMessages([\r\n            'email' => ['The provided credentials are incorrect.'],\r\n        ]);\r\n    }\r\n\r\n    return $user->createToken($request->device_name)->plainTextToken;\r\n});\r\n\r\n```\r\n\r\n当移动应用程序使用令牌向你的应用程序发出 API 请求时，它应该将令牌作为 `Bearer` 令牌放在 `Authorization` 标头中传递。\r\n\r\n> **注意**\r\n> 当为移动应用程序发布令牌时，你可以自由指定[令牌权限](#token-abilities)。\r\n\r\n<a name=\"protecting-mobile-api-routes\"></a>\r\n\r\n### 路由保护\r\n\r\n如之前所述，你可以通过使用 `sanctum` 认证守卫附加到路由上来保护路由，以便所有传入请求都必须进行身份验证：\r\n\r\n```\r\nRoute::middleware('auth:sanctum')->get('/user', function (Request $request) {\r\n    return $request->user();\r\n});\r\n\r\n```\r\n\r\n<a name=\"revoking-mobile-api-tokens\"></a>\r\n\r\n### 撤销令牌\r\n\r\n为了允许用户撤销发放给移动设备的 API 令牌，你可以在 Web 应用程序 UI 的 「帐户设置」部分中按名称列出它们，并提供一个「撤销」按钮。当用户点击「撤销」按钮时，你可以从数据库中删除令牌。请记住，你可以通过 `Laravel\\Sanctum\\HasApiTokens` 特性提供的 `tokens` 关系访问用户的 API 令牌：\r\n\r\n```\r\n// 撤销所有令牌...\r\n$user->tokens()->delete();\r\n\r\n// 撤销特定令牌...\r\n$user->tokens()->where('id', $tokenId)->delete();\r\n```\r\n\r\n<a name=\"testing\"></a>\r\n## 测试\r\n\r\n在测试时，`Sanctum::actingAs` 方法可用于验证用户并指定为其令牌授予哪些能力：\r\n\r\n    use App\\Models\\User;\r\n    use Laravel\\Sanctum\\Sanctum;\r\n\r\n    public function test_task_list_can_be_retrieved(): void\r\n    {\r\n        Sanctum::actingAs(\r\n            User::factory()->create(),\r\n            ['view-tasks']\r\n        );\r\n\r\n        $response = $this->get('/api/task');\r\n\r\n        $response->assertOk();\r\n    }\r\n\r\n如果你想授予令牌所有的能力，你应该在提供给 `actingAs` 方法的能力列表中包含 `*` ：\r\n\r\n    Sanctum::actingAs(\r\n        User::factory()->create(),\r\n        ['*']\r\n    );\r\n\r\n","p":"docs/sanctum.html"},{"t":"scout (Laravel Scout)","d":"# Laravel Scout\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n    - [驱动必要条件](#driver-prerequisites)\r\n    - [队列](#queueing)\r\n- [配置](#configuration)\r\n    - [配置模型索引](#configuring-model-indexes)\r\n    - [配置可搜索数据](#configuring-searchable-data)\r\n    - [配置模型 ID](#configuring-the-model-id)\r\n    - [配置每个模型的搜索引擎](#configuring-search-engines-per-model)\r\n    - [识别用户](#identifying-users)\r\n- [数据库 / 收集引擎](#database-and-collection-engines)\r\n    - [数据库引擎](#database-engine)\r\n    - [Collection 引擎](#collection-engine)\r\n- [索引](#indexing)\r\n    - [批量导入](#batch-import)\r\n    - [添加记录](#adding-records)\r\n    - [修改记录](#updating-records)\r\n    - [删除记录](#removing-records)\r\n    - [暂停索引](#pausing-indexing)\r\n    - [有条件可搜索的模型实例](#conditionally-searchable-model-instances)\r\n- [搜索](#searching)\r\n    - [Where 语句](#where-clauses)\r\n    - [分页](#pagination)\r\n    - [软删除](#soft-deleting)\r\n    - [自定义引擎搜索](#customizing-engine-searches)\r\n- [自定义引擎](#custom-engines)\r\n- [生成器宏](#builder-macros)\r\n\r\n<a name=\"introduction\"></a>\r\n## 介绍\r\n\r\n[Laravel Scout](https://github.com/laravel/scout) 为 [Eloquent models](/docs/laravel/10.x/eloquent) 的全文搜索提供了一个简单的基于驱动程序的解决方案，通过使用模型观察者，Scout 将自动同步 Eloquent 记录的搜索索引。\r\n\r\n目前，Scout 附带 [Algolia](https://www.algolia.com/), [Meilisearch](https://www.meilisearch.com), 和 MySQL / PostgreSQL (`database`) 驱动程序。此外，Scout 包括一个「collection」驱动程序，该驱动程序专为本地开发使用而设计，不需要任何外部依赖项或第三方服务。此外，编写自定义驱动程序很简单，你可以使用自己的搜索实现自由扩展 Scout。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n首先，通过 Composer 软件包管理器安装 Scout：\r\n\r\n```shell\r\ncomposer require laravel/scout\r\n```\r\n\r\nScout 安装完成后，使用 Artisan 命令 `vendor:publish` 生成 Scout 配置文件。此命令将会在你的 `config` 目录下 生成一个 `scout.php` 配置文件:\r\n\r\n```shell\r\nphp artisan vendor:publish --provider=\"Laravel\\Scout\\ScoutServiceProvider\"\r\n```\r\n\r\n\r\n\r\n最后，在你要做搜索的模型中添加 `Laravel\\Scout\\Searchable` trait 。这个 trait 会注册一个模型观察者来保持模型和搜索驱动的同步:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class Post extends Model\r\n    {\r\n        use Searchable;\r\n    }\r\n\r\n<a name=\"driver-prerequisites\"></a>\r\n### 驱动的先决条件\r\n\r\n<a name=\"algolia\"></a>\r\n#### Algolia\r\n\r\n使用 Algolia 驱动时，需要在 `config/scout.php` 配置文件配置你的 `Algolia` `id` 和 `secret` 凭证。配置好凭证之后，还需要使用 Composer 安装 Algolia PHP SDK：\r\n\r\n```shell\r\ncomposer require algolia/algoliasearch-client-php\r\n```\r\n\r\n<a name=\"meilisearch\"></a>\r\n#### Meilisearch\r\n\r\n[Meilisearch](https://www.meilisearch.com) 是一个速度极快的开源搜索引擎。如果你不确定如何在本地机器上安装 MeiliSearch，你可以使用 Laravel 官方支持的 Docker 开发环境 [Laravel Sail](/docs/laravel/10.x/sail#meilisearch)。\r\n\r\n使用 MeiliSearch 驱动程序时，你需要通过 Composer 包管理器安装 MeiliSearch PHP SDK：\r\n\r\n```shell\r\ncomposer require meilisearch/meilisearch-php http-interop/http-factory-guzzle\r\n```\r\n\r\n然后，在应用程序的 `.env` 文件中设置 `SCOUT_DRIVER` 环境变量以及你的 MeiliSearch `host` 和 `key` 凭据：\r\n\r\n```ini\r\nSCOUT_DRIVER=meilisearch\r\nMEILISEARCH_HOST=http://127.0.0.1:7700\r\nMEILISEARCH_KEY=masterKey\r\n```\r\n\r\n更多关于 MeiliSearch 的信息，请参考 [MeiliSearch 技术文档](https://docs.meilisearch.com/learn/getting_started/quick_start.html)。\r\n\r\n此外，你应该通过查看 [MeiliSearch 关于二进制兼容性的文档](https://github.com/meilisearch/meilisearch-php#-compatibility-with-meilisearch)确保安装与你的 MeiliSearch 二进制版本兼容的 `meilisearch/meilisearch-php` 版本。\r\n\r\n>  Meilisearch service itself.\r\n注意：在使用 MeiliSearch 的应用程序上升级 Scout 时，你应该始终留意查看关于 MeiliSearch 升级发布的[其他重大（破坏性）更改](https://github.com/meilisearch/MeiliSearch/releases)，以保证升级顺利。\r\n\r\n\r\n\r\n<a name=\"queueing\"></a>\r\n### 队列\r\n\r\n虽然不强制要求使用 Scout，但在使用该库之前，强烈建议配置一个[队列驱动](/docs/laravel/10.x/queues)。运行队列 worker 将允许 Scout 将所有同步模型信息到搜索索引的操作都放入队列中，从而为你的应用程序的Web界面提供更快的响应时间。\r\n\r\n一旦你配置了队列驱动程序，请将 `config/scout.php` 配置文件中的 `queue` 选项的值设置为 `true`：\r\n\r\n    'queue' => true,\r\n\r\n即使将 `queue` 选项设置为 `false`，也要记住有些 Scout 驱动程序（如 Algolia 和 Meilisearch）始终异步记录索引。也就是说，即使索引操作已在 Laravel 应用程序中完成，但搜索引擎本身可能不会立即反映新记录和更新记录。\r\n\r\n要指定 Scout 使用的连接和队列，请将 `queue` 配置选项定义为数组：\r\n\r\n    'queue' => [\r\n        'connection' => 'redis',\r\n        'queue' => 'scout'\r\n    ],\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n<a name=\"configuring-model-indexes\"></a>\r\n### 配置模型索引\r\n\r\n每个 Eloquent 模型都与一个给定的搜索「索引」同步，该索引包含该模型的所有可搜索记录。换句话说，可以将每个索引视为 MySQL 表。默认情况下，每个模型将持久化到与模型的典型「表」名称匹配的索引中。通常，这是模型名称的复数形式；但是，你可以通过在模型上重写 `searchableAs` 方法来自定义模型的索引：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class Post extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取与模型关联的索引的名称.\r\n         */\r\n        public function searchableAs(): string\r\n        {\r\n            return 'posts_index';\r\n        }\r\n    }\r\n\r\n\r\n<a name=\"configuring-searchable-data\"></a>\r\n### 配置可搜索数据\r\n\r\n默认情况下，给定模型的 `toArray` 形式的整个内容将被持久化到其搜索索引中。如果要自定义同步到搜索索引的数据，可以重写模型上的 `toSearchableArray` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class Post extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取模型的可索引数据。\r\n         *\r\n         * @return array<string, mixed>\r\n         */\r\n        public function toSearchableArray(): array\r\n        {\r\n            $array = $this->toArray();\r\n\r\n            // 自定义数据数组...\r\n\r\n            return $array;\r\n        }\r\n    }\r\n\r\n一些搜索引擎（如 Meilisearch）只会在正确的数据类型上执行过滤操作（`>` 、 `<` 等）。因此，在使用这些搜索引擎并自定义可搜索数据时，你应该确保数值类型被转换为正确的类型：\r\n\r\n    public function toSearchableArray()\r\n    {\r\n        return [\r\n            'id' => (int) $this->id,\r\n            'name' => $this->name,\r\n            'price' => (float) $this->price,\r\n        ];\r\n    }\r\n\r\n<a name=\"configuring-filterable-data-for-meilisearch\"></a>\r\n#### 配置可过滤数据和索引设置 (Meilisearch)\r\n\r\n与 Scout 的其他驱动程序不同，Meilisearch 要求你预定义索引搜索设置，例如可过滤属性、可排序属性和[其他支持的设置字段](https://docs.meilisearch.com/reference/api/settings.html)。\r\n\r\n可过滤属性是你在调用 Scout 的 `where` 方法时想要过滤的任何属性，而可排序属性是你在调用 Scout 的 `orderBy` 方法时想要排序的任何属性。要定义索引设置，请调整应用程序的 `scout` 配置文件中 `meilisearch` 配置条目的 `index-settings` 部分：\r\n\r\n```php\r\nuse App\\Models\\User;\r\nuse App\\Models\\Flight;\r\n\r\n'meilisearch' => [\r\n    'host' => env('MEILISEARCH_HOST', 'http://localhost:7700'),\r\n    'key' => env('MEILISEARCH_KEY', null),\r\n    'index-settings' => [\r\n        User::class => [\r\n            'filterableAttributes'=> ['id', 'name', 'email'],\r\n            'sortableAttributes' => ['created_at'],\r\n            // 其他设置字段...\r\n        ],\r\n        Flight::class => [\r\n            'filterableAttributes'=> ['id', 'destination'],\r\n            'sortableAttributes' => ['updated_at'],\r\n        ],\r\n    ],\r\n],\r\n```\r\n\r\n\r\n\r\n如果给定索引下的模型可以进行软删除，并且已包含在`index-settings`数组中，Scout 将自动支持在该索引上过滤软删除的模型。如果你没有其他可过滤或可排序的属性来定义软删除的模型索引，则可以简单地向该模型的`index-settings`数组添加一个空条目：\r\n\r\n```php\r\n'index-settings' => [\r\n    Flight::class => []\r\n],\r\n```\r\n\r\n在配置应用程序的索引设置之后，你必须调用 `scout:sync-index-settings` Artisan 命令。此命令将向 Meilisearch 通知你当前配置的索引设置。为了方便起见，你可能希望将此命令作为部署过程的一部分：\r\n\r\n```shell\r\nphp artisan scout:sync-index-settings\r\n```\r\n\r\n<a name=\"configuring-the-model-id\"></a>\r\n### 配置模型ID\r\n\r\n默认情况下，Scout 将使用模型的主键作为存储在搜索索引中的模型唯一ID/键。如果你需要自定义此行为，可以重写模型的 `getScoutKey` 和 `getScoutKeyName` 方法：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class User extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取这个模型用于索引的值.\r\n         */\r\n        public function getScoutKey(): mixed\r\n        {\r\n            return $this->email;\r\n        }\r\n\r\n        /**\r\n         * 获取这个模型用于索引的键.\r\n         */\r\n        public function getScoutKeyName(): mixed\r\n        {\r\n            return 'email';\r\n        }\r\n    }\r\n\r\n<a name=\"configuring-search-engines-per-model\"></a>\r\n### 设置模型的搜索引擎\r\n\r\n当进行搜索时，Scout 通常会使用应用程序的 `scout` 配置文件中指定的默认搜索引擎。但是，可以通过在模型上覆盖 `searchableUsing` 方法来更改特定模型的搜索引擎：\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Engines\\Engine;\r\n    use Laravel\\Scout\\EngineManager;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class User extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取这个模型用于索引的搜索引擎.\r\n         */\r\n        public function searchableUsing(): Engine\r\n        {\r\n            return app(EngineManager::class)->engine('meilisearch');\r\n        }\r\n    }\r\n\r\n<a name=\"configuring-the-model-id\"></a>\r\n### 配置模型ID\r\n\r\n默认情况下，Scout 将使用模型的主键作为存储在搜索索引中的模型的唯一ID /键。如果你需要自定义此行为，你可以覆盖模型上的`getScoutKey`和`getScoutKeyName`方法:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class User extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取用于索引模型的值.\r\n         */\r\n        public function getScoutKey(): mixed\r\n        {\r\n            return $this->email;\r\n        }\r\n\r\n        /**\r\n         * 获取用于索引模型的键名.\r\n         */\r\n        public function getScoutKeyName(): mixed\r\n        {\r\n            return 'email';\r\n        }\r\n    }\r\n\r\n<a name=\"configuring-search-engines-per-model\"></a>\r\n### 按型号配置搜索引擎\r\n\r\n搜索时，Scout 通常使用你应用程序的 Scout 配置文件中指定的默认搜索引擎。然而，可以通过覆盖模型上的`searchableUsing`方法来更改特定模型的搜索引擎:\r\n\r\n    <?php\r\n\r\n    namespace App\\Models;\r\n\r\n    use Illuminate\\Database\\Eloquent\\Model;\r\n    use Laravel\\Scout\\Engines\\Engine;\r\n    use Laravel\\Scout\\EngineManager;\r\n    use Laravel\\Scout\\Searchable;\r\n\r\n    class User extends Model\r\n    {\r\n        use Searchable;\r\n\r\n        /**\r\n         * 获取用于索引模型的引擎.\r\n         */\r\n        public function searchableUsing(): Engine\r\n        {\r\n            return app(EngineManager::class)->engine('meilisearch');\r\n        }\r\n    }\r\n\r\n\r\n\r\n<a name=\"identifying-users\"></a>\r\n### 识别用户\r\n\r\n如果你在使用 [Algolia](https://algolia.com/) 时想要自动识别用户，Scout 可以帮助你。将已认证的用户与搜索操作相关联，可以在 Algolia 的仪表板中查看搜索分析时非常有用。你可以通过在应用程序的 `.env` 文件中将 `SCOUT_IDENTIFY` 环境变量定义为 `true` 来启用用户识别：\r\n\r\n```ini\r\nSCOUT_IDENTIFY=true\r\n```\r\n\r\n启用此功能还会将请求的 IP 地址和已验证的用户的主要标识符传递给 Algolia，以便将此数据与用户发出的任何搜索请求相关联。\r\n\r\n<a name=\"database-and-collection-engines\"></a>\r\n## 数据库/集合引擎\r\n\r\n<a name=\"database-engine\"></a>\r\n### 数据库引擎\r\n\r\n> 注意：目前，数据库引擎支持 MySQL 和 PostgreSQL。\r\n\r\n如果你的应用程序与小到中等大小的数据库交互或工作负载较轻，你可能会发现使用 Scout 的 「database」 引擎更为方便。数据库引擎将使用 「where like」子句和全文索引来过滤你现有数据库的结果，以确定适用于你查询的搜索结果。\r\n\r\n要使用数据库引擎，你可以简单地将 `SCOUT_DRIVER` 环境变量的值设置为 `database`，或直接在你的应用程序的 `scout` 配置文件中指定 `database` 驱动程序：\r\n\r\n```ini\r\nSCOUT_DRIVER=database\r\n```\r\n\r\n一旦你已将数据库引擎指定为首选驱动程序，你必须[配置你的可搜索数据](#configuring-searchable-data)。然后，你可以开始[执行搜索查询](#searching)来查询你的模型。使用数据库引擎时，不需要进行搜索引擎索引，例如用于填充 Algolia 或 Meilisearch 索引所需的索引。\r\n\r\n\r\n\r\n#### 自定义数据库搜索策略\r\n\r\n默认情况下，数据库引擎将对你所[配置为可搜索的](#configuring-searchable-data)每个模型属性执行 「where like」 查询。然而，在某些情况下，这可能会导致性能不佳。因此，数据库引擎的搜索策略可以配置，以便某些指定的列利用全文搜索查询，或者仅使用 「where like」 约束来搜索字符串的前缀(`example%`)，而不是在整个字符串中搜索(`%example%`)。\r\n\r\n为了定义这种行为，你可以将 PHP 属性赋值给你的模型的 toSearchableArray 方法。任何未被分配其他搜索策略行为的列将继续使用默认的「where like」策略：\r\n\r\n```php\r\nuse Laravel\\Scout\\Attributes\\SearchUsingFullText;\r\nuse Laravel\\Scout\\Attributes\\SearchUsingPrefix;\r\n\r\n/**\r\n * 获取模型的可索引数据数组。\r\n *\r\n * @return array<string, mixed>\r\n */\r\n#[SearchUsingPrefix(['id', 'email'])]\r\n#[SearchUsingFullText(['bio'])]\r\npublic function toSearchableArray(): array\r\n{\r\n    return [\r\n        'id' => $this->id,\r\n        'name' => $this->name,\r\n        'email' => $this->email,\r\n        'bio' => $this->bio,\r\n    ];\r\n}\r\n```\r\n\r\n> 注意：在指定列应使用全文查询约束之前，请确保已为该列分配[全文索引](/docs/laravel/10.x/migrations#available-index-types)。\r\n\r\n\r\n<a name=\"collection-engine\"></a>\r\n### 集合引擎\r\n\r\n在本地开发过程中，你可以自由地使用 Algolia 或 Meilisearch 搜索引擎，但你可能会发现使用「集合」引擎更加方便。集合引擎将使用「where」子句和集合过滤器来从你现有的数据库结果中确定适用于你查询的搜索结果。当使用此引擎时，无需对可搜索模型进行「索引」，因为它们只需从本地数据库中检索即可。\r\n\r\n\r\n\r\n要使用收集引擎，你可以简单地将 `SCOUT_DRIVER` 环境变量的值设置为 `collection`，或者直接在你的应用的 `scout` 配置文件中指定 `collection` 驱动程序：\r\n\r\n```ini\r\nSCOUT_DRIVER=collection\r\n```\r\n\r\n一旦你将收集驱动程序指定为首选驱动程序，你就可以开始针对你的模型[执行搜索查询](#searching)。使用收集引擎时，不需要进行搜索引擎索引，如种子 Algolia 或 Meilisearch 索引所需的索引。\r\n\r\n#### 与数据库引擎的区别\r\n\r\n乍一看，「数据库」和「收集」引擎非常相似。它们都直接与你的数据库交互以检索搜索结果。然而，收集引擎不使用全文索引或 `LIKE` 子句来查找匹配的记录。相反，它会拉取所有可能的记录，并使用 Laravel 的 `Str::is` 助手来确定搜索字符串是否存在于模型属性值中。\r\n\r\n收集引擎是最便携的搜索引擎，因为它适用于 Laravel 支持的所有关系型数据库（包括 SQLite 和 SQL Server）；然而，它的效率比 Scout 的数据库引擎低。\r\n\r\n<a name=\"indexing\"></a>\r\n## 索引\r\n\r\n<a name=\"batch-import\"></a>\r\n### 批量导入\r\n\r\n如果你要将 Scout 安装到现有项目中，你可能已经有需要导入到你的索引中的数据库记录。Scout 提供了一个 `scout:import` Artisan 命令，你可以使用它将所有现有记录导入到你的搜索索引中：\r\n\r\n```shell\r\nphp artisan scout:import \"App\\Models\\Post\"\r\n```\r\n\r\n`flush` 命令可用于从你的搜索索引中删除模型的所有记录：\r\n\r\n```shell\r\nphp artisan scout:flush \"App\\Models\\Post\"\r\n```\r\n\r\n\r\n\r\n<a name=\"modifying-the-import-query\"></a>\r\n#### 修改导入查询\r\n\r\n如果你想修改用于获取所有批量导入模型的查询，你可以在你的模型上定义一个`makeAllSearchableUsing`方法。这是一个很好的地方，可以在导入模型之前添加任何必要的关系加载:\r\n\r\n    use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n    /**\r\n     * 修改用于检索模型的查询，使所有模型都可搜索.\r\n     */\r\n    protected function makeAllSearchableUsing(Builder $query): Builder\r\n    {\r\n        return $query->with('author');\r\n    }\r\n\r\n<a name=\"adding-records\"></a>\r\n### 添加记录\r\n\r\n一旦你将`Laravel\\Scout\\Searchable` Trait添加到模型中，你所需要做的就是`保存`或`创建`一个模型实例，它将自动添加到你的搜索索引中。如果你将Scout配置为[使用队列](#queueing)，则此操作将由你的队列工作者在后台执行:\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $order = new Order;\r\n\r\n    // ...\r\n\r\n    $order->save();\r\n\r\n<a name=\"adding-records-via-query\"></a>\r\n#### 通过查询添加记录\r\n\r\n如果你想通过Eloquent查询将模型集合添加到你的搜索索引中，你可以将`searchable`方法链接到Eloquent查询中。`searchable`方法会将查询的[结果分块](/docs/laravel/10.x/eloquent#chunking-results)并将记录添加到你的搜索索引中。同样，如果你已经配置了Scout来使用队列，那么所有的块都将由你的队列工作程序在后台导入:\r\n\r\n    use App\\Models\\Order;\r\n\r\n    Order::where('price', '>', 100)->searchable();\r\n\r\n你也可以在Eloquent关系实例上调用`searchable`方法:\r\n\r\n    $user->orders()->searchable();\r\n\r\n\r\n\r\n如果你已经有一组Eloquent模型对象在内存中，可以在该集合实例上调用`searchable`方法，将模型实例添加到对应的索引中：\r\n\r\n    $orders->searchable();\r\n\r\n> **注意**\r\nsearchable 方法可以被视为「upsert」操作。换句话说，如果模型记录已经存在于索引中，它将被更新。如果它在搜索索引中不存在，则将其添加到索引中。\r\n\r\n<a name=\"updating-records\"></a>\r\n### 更新记录\r\n\r\n要更新可搜索的模型，只需更新模型实例的属性并将模型保存到你的数据库中。Scout 将自动将更改持久化到你的搜索索引中：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $order = Order::find(1);\r\n\r\n    // 更新订单…\r\n\r\n    $order->save();\r\n\r\n你还可以在Eloquent查询实例上调用 `searchable` 方法，以更新模型的集合。如果模型不存在于搜索索引中，则将创建它们：\r\n\r\n    Order::where('price', '>', 100)->searchable();\r\n\r\n如果想要更新关系中所有模型的搜索索引记录，可以在关系实例上调用`searchable`方法：\r\n\r\n    $user->orders()->searchable();\r\n\r\n或者，如果你已经在内存中有一组 Eloquent 模型，可以在该集合实例上调用`searchable` 方法，以更新对应索引中的模型实例：\r\n\r\n    $orders->searchable();\r\n\r\n<a name=\"removing-records\"></a>\r\n### 删除记录\r\n\r\n要从索引中删除记录，只需从数据库中删除模型即可。即使你正在使用[软删除](/docs/laravel/10.x/eloquent#soft-deleting)模型，也可以这样做：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $order = Order::find(1);\r\n\r\n    $order->delete();\r\n\r\n\r\n\r\n如果你不想在删除记录之前检索模型，你可以在 Eloquent 查询实例上使用 `unsearchable` 方法：\r\n\r\n    Order::where('price', '>', 100)->unsearchable();\r\n\r\n如果你想删除与关系中所有模型相关的搜索索引记录，你可以在关系实例上调用 `unsearchable` 方法：\r\n\r\n    $user->orders()->unsearchable();\r\n\r\n或者，如果你已经有一组 Eloquent 模型在内存中，你可以在集合实例上调用 `unsearchable` 方法，将模型实例从相应的索引中移除：\r\n\r\n    $orders->unsearchable();\r\n\r\n<a name=\"pausing-indexing\"></a>\r\n### 暂停索引\r\n\r\n有时你可能需要在不将模型数据同步到搜索索引的情况下对模型执行一批 Eloquent 操作。你可以使用 `withoutSyncingToSearch` 方法来实现这一点。该方法接受一个闭包，将立即执行。在闭包内发生的任何模型操作都不会同步到模型的索引：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    Order::withoutSyncingToSearch(function () {\r\n        // 执行模型动作…\r\n    });\r\n\r\n<a name=\"conditionally-searchable-model-instances\"></a>\r\n### 有条件地搜索模型实例\r\n\r\n有时你可能需要在某些条件下使模型可搜索。例如，假设你有一个 `App\\Models\\Post` 模型，它可能处于两种状态之一：「draft」（草稿）和 「published」（已发布）。你可能只想让 「published」（已发布）的帖子可以被搜索。为了实现这一点，你可以在你的模型中定义一个 `shouldBeSearchable` 方法：\r\n\r\n    /**\r\n     * 确定模型是否应该可搜索。\r\n     */\r\n    public function shouldBeSearchable(): bool\r\n    {\r\n        return $this->isPublished();\r\n    }\r\n\r\n`shouldBeSearchable` 方法仅在通过 `save` 和 `create` 方法、查询或关系操作模型时应用。直接使用 `searchable` 方法使模型或集合可搜索将覆盖 `shouldBeSearchable` 方法的结果。\r\n\r\n> **警告**  \r\n> 当使用 Scout 的「database」（数据库）引擎时，`shouldBeSearchable` 方法不适用，因为所有可搜索的数据都存储在数据库中。要在使用数据库引擎时实现类似的行为，你应该使用 [where 子句](#where-clauses)代替。\r\n\r\n\r\n\r\n<a name=\"searching\"></a>\r\n## 搜索\r\n\r\n你可以使用 `search` 方法开始搜索一个模型。搜索方法接受一个将用于搜索模型的字符串。然后，你应该在搜索查询上链接 `get` 方法以检索与给定搜索查询匹配的 Eloquent 模型：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $orders = Order::search('Star Trek')->get();\r\n\r\n由于 Scout 搜索返回一组 Eloquent 模型，你甚至可以直接从路由或控制器返回结果，它们将自动转换为 JSON：\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/search', function (Request $request) {\r\n        return Order::search($request->search)->get();\r\n    });\r\n\r\n如果你想在将搜索结果转换为 Eloquent 模型之前获取原始搜索结果，你可以使用 `raw` 方法：\r\n\r\n    $orders = Order::search('Star Trek')->raw();\r\n\r\n<a name=\"custom-indexes\"></a>\r\n#### 自定义索引\r\n\r\n搜索查询通常会在模型的 [`searchableAs`](#configuring-model-indexes) 方法指定的索引上执行。然而，你可以使用 `within` 方法指定一个应该被搜索的自定义索引：\r\n\r\n    $orders = Order::search('Star Trek')\r\n        ->within('tv_shows_popularity_desc')\r\n        ->get();\r\n\r\n<a name=\"where-clauses\"></a>\r\n### Where 子句\r\n\r\nScout 允许你在搜索查询中添加简单的「where」子句。目前，这些子句只支持基本的数值相等检查，主要用于通过所有者 ID 限定搜索查询：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $orders = Order::search('Star Trek')->where('user_id', 1)->get();\r\n\r\n你可以使用 `whereIn` 方法将结果约束在给定的一组值中：\r\n\r\n    $orders = Order::search('Star Trek')->whereIn(\r\n        'status', ['paid', 'open']\r\n    )->get();\r\n\r\n\r\n\r\n由于搜索索引不是关系数据库，所以目前不支持更高级的「where」子句。\r\n\r\n> **警告 **\r\n> 如果你的应用程序使用了 Meilisearch，你必须在使用 Scout 的「where」子句之前配置你的应用程序的[可过滤属性](#configuring-filterable-data-for-meilisearch)。\r\n\r\n<a name=\"pagination\"></a>\r\n### 分页\r\n\r\n除了检索模型集合之外，你还可以使用 `paginate` 方法对搜索结果进行分页。此方法将返回一个 `Illuminate\\Pagination\\LengthAwarePaginator` 实例，就像你对[传统的 Eloquent 查询进行分页](/docs/laravel/10.x/pagination)一样：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    $orders = Order::search('Star Trek')->paginate();\r\n\r\n你可以通过将数量作为第一个参数传递给 `paginate` 方法来指定每页检索多少个模型：\r\n\r\n    $orders = Order::search('Star Trek')->paginate(15);\r\n\r\n一旦你检索到了结果，你可以使用 [Blade](/docs/laravel/10.x/blade) 显示结果并渲染页面链接，就像你对传统的 Eloquent 查询进行分页一样：\r\n\r\n```html\r\n<div class=\"container\">\r\n    @foreach ($orders as $order)\r\n        {{ $order->price }}\r\n    @endforeach\r\n</div>\r\n\r\n{{ $orders->links() }}\r\n```\r\n\r\n当然，如果你想将分页结果作为 JSON 检索，可以直接从路由或控制器返回分页器实例：\r\n\r\n    use App\\Models\\Order;\r\n    use Illuminate\\Http\\Request;\r\n\r\n    Route::get('/orders', function (Request $request) {\r\n        return Order::search($request->input('query'))->paginate(15);\r\n    });\r\n\r\n> **警告**  \r\n> 由于搜索引擎不了解你的 Eloquent 模型的全局作用域定义，因此在使用 Scout 分页的应用程序中，你不应该使用全局作用域。或者，你应该在通过 Scout 搜索时重新创建全局作用域的约束。\r\n\r\n\r\n<a name=\"soft-deleting\"></a>\r\n### 软删除\r\n\r\n如果你的索引模型使用了软删除并且你需要搜索已软删除的模型，请将 `config/scout.php` 配置文件中的 `soft_delete` 选项设置为 `true`。\r\n\r\n    'soft_delete' => true,\r\n\r\n当这个配置选项为 `true` 时，Scout 不会从搜索索引中删除已软删除的模型。相反，它会在索引记录上设置一个隐藏的 `__soft_deleted` 属性。然后，你可以使用 `withTrashed` 或 `onlyTrashed` 方法在搜索时检索已软删除的记录：\r\n\r\n    use App\\Models\\Order;\r\n\r\n    // 在检索结果时包含已删除的记录。。。\r\n    $orders = Order::search('Star Trek')->withTrashed()->get();\r\n\r\n    // 仅在检索结果时包含已删除的记录。。。\r\n    $orders = Order::search('Star Trek')->onlyTrashed()->get();\r\n\r\n> 技巧：当使用 `forceDelete` 永久删除软删除模型时，Scout 将自动从搜索索引中移除它。\r\n\r\n<a name=\"customizing-engine-searches\"></a>\r\n### 自定义引擎搜索\r\n\r\n如果你需要对一个引擎的搜索行为进行高级定制，你可以将一个闭包作为 `search` 方法的第二个参数传递进去。例如，你可以使用这个回调在搜索查询传递给 Algolia 之前将地理位置数据添加到你的搜索选项中：\r\n\r\n    use Algolia\\AlgoliaSearch\\SearchIndex;\r\n    use App\\Models\\Order;\r\n\r\n    Order::search(\r\n        'Star Trek',\r\n        function (SearchIndex $algolia, string $query, array $options) {\r\n            $options['body']['query']['bool']['filter']['geo_distance'] = [\r\n                'distance' => '1000km',\r\n                'location' => ['lat' => 36, 'lon' => 111],\r\n            ];\r\n\r\n            return $algolia->search($query, $options);\r\n        }\r\n    )->get();\r\n\r\n<a name=\"customizing-the-eloquent-results-query\"></a>\r\n#### 自定义 Eloquent 结果查询\r\n\r\n在 Scout 从你的应用程序搜索引擎中检索到匹配的 Eloquent 模型列表后，Eloquent 会使用模型的主键检索所有匹配的模型。你可以通过调用 `query` 方法来自定义此查询。`query` 方法接受一个闭包，它将接收 Eloquent 查询构建器实例作为参数：\r\n\r\n```php\r\nuse App\\Models\\Order;\r\nuse Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n$orders = Order::search('Star Trek')\r\n    ->query(fn (Builder $query) => $query->with('invoices'))\r\n    ->get();\r\n```\r\n\r\n\r\n由于此回调是在从应用程序的搜索引擎中已经检索到相关模型之后调用的，因此 `query` 方法不应用于「过滤」结果。相反，你应该使用 [Scout where 子句](#where-clauses)。\r\n\r\n<a name=\"custom-engines\"></a>\r\n## 自定义引擎\r\n\r\n<a name=\"writing-the-engine\"></a>\r\n#### 编写引擎\r\n\r\n如果 Scout 内置的搜索引擎不符合你的需求，你可以编写自己的自定义引擎并将其注册到 Scout。你的引擎应该继承 `Laravel\\Scout\\Engines\\Engine` 抽象类。这个抽象类包含了你的自定义引擎必须实现的八个方法：\r\n\r\n    use Laravel\\Scout\\Builder;\r\n\r\n    abstract public function update($models);\r\n    abstract public function delete($models);\r\n    abstract public function search(Builder $builder);\r\n    abstract public function paginate(Builder $builder, $perPage, $page);\r\n    abstract public function mapIds($results);\r\n    abstract public function map(Builder $builder, $results, $model);\r\n    abstract public function getTotalCount($results);\r\n    abstract public function flush($model);\r\n\r\n你可能会发现，查看 `Laravel\\Scout\\Engines\\AlgoliaEngine` 类上这些方法的实现会很有帮助。这个类将为你提供一个良好的起点，以学习如何在自己的引擎中实现每个方法。\r\n\r\n<a name=\"registering-the-engine\"></a>\r\n\r\n#### 注册引擎\r\n一旦你编写好自己的引擎，就可以使用 Scout 的引擎管理器的 `extend` 方法将其注册到 Scout 中。Scout 的引擎管理器可以从Laravel服务容器中解析。你应该从 `App\\Providers\\AppServiceProvider` 类或应用程序使用的任何其他服务提供程序的 `boot` 方法中调用 `extend` 方法：\r\n\r\n    use App\\ScoutExtensions\\MySqlSearchEngine;\r\n    use Laravel\\Scout\\EngineManager;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        resolve(EngineManager::class)->extend('mysql', function () {\r\n            return new MySqlSearchEngine;\r\n        });\r\n    }\r\n\r\n\r\n\r\n引擎注册后，你可以在 `config/scout.php` , 配置文件中指定它为默认的 Scout `driver`\r\n\r\n    'driver' => 'mysql',\r\n\r\n<a name=\"builder-macros\"></a>\r\n## 生成宏命令\r\n\r\n如果你想要自定义生成器方法，你可以使用 `Laravel\\Scout\\Builder` 类下的 \"macro\" 方法。 通常，定义「macros」时，需要实现 [service provider’s](/docs/laravel/10.x/providers) `boot` 方法:\r\n\r\n    use Illuminate\\Support\\Facades\\Response;\r\n    use Illuminate\\Support\\ServiceProvider;\r\n    use Laravel\\Scout\\Builder;\r\n\r\n    /**\r\n     * 引导任何应用程序服务。\r\n     */\r\n    public function boot(): void\r\n    {\r\n        Builder::macro('count', function () {\r\n            return $this->engine()->getTotalCount(\r\n                $this->engine()->search($this)\r\n            );\r\n        });\r\n    }\r\n\r\n`macro` 函数接受一个名字作为第一个参数，第二个参数为一个闭包函数。当调用 `Laravel\\Scout\\Builder` 宏命令时，调用这个函数.\r\n\r\n    use App\\Models\\Order;\r\n\r\n    Order::search('Star Trek')->count();\r\n\r\n","p":"docs/scout.html"},{"t":"socialite (Laravel Socialite)","d":"\n# Laravel Socialite\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n- [升级](#upgrading-socialite)\r\n- [配置](#configuration)\r\n- [认证](#authentication)\r\n    - [路由](#routing)\r\n    - [身份验证和存储](#authentication-and-storage)\r\n    - [访问范围](#access-scopes)\r\n    - [可选参数](#optional-parameters)\r\n- [检索用户详细信息](#retrieving-user-details)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n除了典型的基于表单的身份验证之外，Laravel 还提供了一种使用 [Laravel Socialite](https://github.com/laravel/socialite)对 OAuth providers 进行身份验证的简单方便的方法。 Socialite 目前支持 Facebook，Twitter，LinkedIn，Google，GitHub，GitLab 和 Bitbucket 的身份验证。\r\n\r\n> 技巧：其他平台的驱动器可以在 [Socialite Providers](https://socialiteproviders.com/) 社区驱动网站查找。\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n在开始使用 Socialite 之前，通过 Composer 软件包管理器将软件包添加到项目的依赖项中:\r\n\r\n```shell\r\ncomposer require laravel/socialite\r\n```\r\n\r\n<a name=\"upgrading-socialite\"></a>\r\n## 升级\r\n\r\n升级到 Socialite 的新主要版本时，请务必仔细查看 [the upgrade guide](https://github.com/laravel/socialite/blob/master/UPGRADE.).\r\n\r\n<a name=\"configuration\"></a>\r\n## 配置\r\n\r\n在使用 Socialite 之前，你需要为应用程序使用的OAuth提供程序添加凭据。通常，可以通过在要验证的服务的仪表板中创建“开发人员应用程序”来检索这些凭据。\r\n\r\n这些凭证应该放在你的 `config/services.php` 配置文件中， 并且应该使用 `facebook`, `twitter` (OAuth 1.0), `twitter-oauth-2` (OAuth 2.0), `linkedin`, `google`, `github`, `gitlab`, 或者 `bitbucket`, 取决于应用程序所需的提供商：\r\n\r\n    'github' => [\r\n        'client_id' => env('GITHUB_CLIENT_ID'),\r\n        'client_secret' => env('GITHUB_CLIENT_SECRET'),\r\n        'redirect' => 'http://example.com/callback-url',\r\n    ],\r\n\r\n> 技巧：如果 `redirect` 项的值包含一个相对路径，它将会自动解析为全称 URL。\r\n\r\n\n\n<a name=\"authentication\"></a>\r\n## 认证\r\n\r\n<a name=\"routing\"></a>\r\n### 路由\r\n\r\n要使用 OAuth 提供程序对用户进行身份验证，你需要两个路由：一个用于将用户重定向到 OAuth provider，另一个用于在身份验证后接收来自 provider 的回调。下面的示例控制器演示了这两个路由的实现：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    Route::get('/auth/redirect', function () {\r\n        return Socialite::driver('github')->redirect();\r\n    });\r\n\r\n    Route::get('/auth/callback', function () {\r\n        $user = Socialite::driver('github')->user();\r\n\r\n        // $user->token\r\n    });\r\n\r\n`redirect` 提供的方法 `Socialite` facade 负责将用户重定向到 OAuth provider，而该 user 方法将读取传入的请求并在身份验证后从提供程序中检索用户的信息。\r\n\r\n<a name=\"authentication-and-storage\"></a>\r\n### 身份验证和存储\r\n\r\n从 OAuth 提供程序检索到用户后，你可以确定该用户是否存在于应用程序的数据库中并[验证用户](/docs/laravel/10.x/authentication#authenticate-a-user-instance)。如果用户在应用程序的数据库中不存在，通常会在数据库中创建一条新记录来代表该用户：\r\n\r\n    use App\\Models\\User;\r\n    use Illuminate\\Support\\Facades\\Auth;\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    Route::get('/auth/callback', function () {\r\n        $githubUser = Socialite::driver('github')->user();\r\n\r\n        $user = User::updateOrCreate([\r\n            'github_id' => $githubUser->id,\r\n        ], [\r\n            'name' => $githubUser->name,\r\n            'email' => $githubUser->email,\r\n            'github_token' => $githubUser->token,\r\n            'github_refresh_token' => $githubUser->refreshToken,\r\n        ]);\r\n\r\n        Auth::login($user);\r\n\r\n        return redirect('/dashboard');\r\n    });\r\n\r\n> 技巧：有关特定 OAuth 提供商提供哪些用户信息的更多信息，请参阅有关 [检索用户详细信息](#retrieving-user-details) 的文档。\r\n\r\n\n\n<a name=\"access-scopes\"></a>\r\n### 访问作用域\r\n\r\n在重定向用户之前，你还可以使用 `scopes` 方法在请求中添加其他「作用域」。此方法会将所有现有作用域与你提供的作用域合并：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    return Socialite::driver('github')\r\n        ->scopes(['read:user', 'public_repo'])\r\n        ->redirect();\r\n\r\n你可以使用 `setScopes` 方法覆盖所有现有范围：\r\n\r\n    return Socialite::driver('github')\r\n        ->setScopes(['read:user', 'public_repo'])\r\n        ->redirect();\r\n\r\n<a name=\"optional-parameters\"></a>\r\n### 可选参数\r\n\r\n许多 OAuth providers 支持重定向请求中的可选参数。 要在请求中包含任何可选参数，请使用关联数组调用 `with` 方法：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    return Socialite::driver('google')\r\n        ->with(['hd' => 'example.com'])\r\n        ->redirect();\r\n\r\n> 注意：使用  `with` 方法时, 注意不要传递任何保留的关键字，例如 `state` 或 `response_type`。\r\n\r\n<a name=\"retrieving-user-details\"></a>\r\n## 检索用户详细信息\r\n\r\n在将用户重定向回你的身份验证回调路由之后，你可以使用 Socialite 的 `user` 方法检索用户的详细信息。`user` 方法为返回的用户对象提供了各种属性和方法，你可以使用这些属性和方法在你自己的数据库中存储有关该用户的信息。\r\n\r\n你可以使用不同的属性和方法这取决于要进行身份验证的 OAuth 提供程序是否支持 OAuth 1.0 或 OAuth 2.0：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    Route::get('/auth/callback', function () {\r\n        $user = Socialite::driver('github')->user();\r\n\r\n        // OAuth 2.0 providers...\r\n        $token = $user->token;\r\n        $refreshToken = $user->refreshToken;\r\n        $expiresIn = $user->expiresIn;\r\n\r\n        // OAuth 1.0 providers...\r\n        $token = $user->token;\r\n        $tokenSecret = $user->tokenSecret;\r\n\r\n        // All providers...\r\n        $user->getId();\r\n        $user->getNickname();\r\n        $user->getName();\r\n        $user->getEmail();\r\n        $user->getAvatar();\r\n    });\r\n\r\n\n\n<a name=\"retrieving-user-details-from-a-token-oauth2\"></a>\r\n#### 从令牌中检索用户详细信息 (OAuth2)\r\n\r\n如果你已经有了一个用户的有效访问令牌，你可以使用 Socialite 的 `userFromToken` 方法检索其详细信息：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    $user = Socialite::driver('github')->userFromToken($token);\r\n\r\n<a name=\"retrieving-user-details-from-a-token-oauth2\"></a>\r\n#### 从令牌中检索用户详细信息 (OAuth2)\r\n\r\n如果你已经有了一对有效的用户令牌/秘钥，你可以使用 Socialite 的 `userFromTokenAndSecret` 方法检索他们的详细信息：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    $user = Socialite::driver('twitter')->userFromTokenAndSecret($token, $secret);\r\n\r\n<a name=\"stateless-authentication\"></a>\r\n#### 无认证状态\r\n\r\n`stateless` 方法可用于禁用会话状态验证。 这在向 API 添加社交身份验证时非常有用：\r\n\r\n    use Laravel\\Socialite\\Facades\\Socialite;\r\n\r\n    return Socialite::driver('google')->stateless()->user();\r\n\r\n> 注意：Twitter 驱动程序不支持无状态身份验证，它使用 OAuth 1.0 进行身份验证\r\n\n","p":"docs/socialite.html"},{"t":"telescope (Laravel Telescope)","d":"# Laravel Telescope\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n    - [仅本地安装](#local-only-installation)\r\n    - [配置](#configuration)\r\n    - [数据修改](#data-pruning)\r\n    - [仪表盘授权](#dashboard-authorization)\r\n- [升级 Telescope](#upgrading-telescope)\r\n- [过滤](#filtering)\r\n    - [单项过滤](#filtering-entries)\r\n    - [批量过滤](#filtering-batches)\r\n- [标记](#tagging)\r\n- [可用的监视器](#available-watchers)\r\n    - [批量监视器](#batch-watcher)\r\n    - [缓存监视器](#cache-watcher)\r\n    - [命令监视器](#command-watcher)\r\n    - [输出监视器](#dump-watcher)\r\n    - [事件监视器](#event-watcher)\r\n    - [异常监视器](#exception-watcher)\r\n    - [Gate 监视器](#gate-watcher)\r\n    - [HTTP Client 监视器](#http-client-watcher)\r\n    - [任务监视器](#job-watcher)\r\n    - [日志监视器](#log-watcher)\r\n    - [邮件监视器](#mail-watcher)\r\n    - [模型监视器](#model-watcher)\r\n    - [消息通知监视器](#notification-watcher)\r\n    - [数据查询监视器](#query-watcher)\r\n    - [Redis 监视器](#redis-watcher)\r\n    - [请求监视器](#request-watcher)\r\n    - [定时任务监视器](#schedule-watcher)\r\n    - [视图监视器](#view-watcher)\r\n- [显示用户头像](#displaying-user-avatars)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Telescope](https://github.com/laravel/telescope) 是 Laravel 本地开发环境的绝佳伴侣。Telescope 可以洞察你的应用程序的请求、异常、日志条目、数据库查询、排队的作业、邮件、消息通知、缓存操作、定时计划任务、变量打印等。\r\n\r\n<img src=\"https://laravel.com/img/docs/telescope-example.png\">\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n你可以使用 Composer 将 Telescope 安装到 Laravel 项目中：\r\n\r\n```shell\r\ncomposer require laravel/telescope\r\n```\r\n\r\n安装 Telescope 后，你应使用 `telescope:install` 命令来发布其公共资源，然后运行 `migrate` 命令执行数据库变更来创建和保存 Telescope 需要的数据：\r\n\r\n```shell\r\nphp artisan telescope:install\r\n\r\nphp artisan migrate\r\n```\r\n\r\n<a name=\"migration-customization\"></a>\r\n#### 自定义迁移\r\n\r\n\r\n\r\n如果不打算使用 Telescope 的默认迁移，则应在应用程序的 `App\\Providers\\AppServiceProvider` 类的 `register` 方法中调用 `Telescope::ignoreMigrations` 方法。你可以使用以下命令导出默认迁移：`php artisan vendor:publish --tag=telescope-migrations`\r\n\r\n<a name=\"local-only-installation\"></a>\r\n### 仅本地安装\r\n\r\n如果你仅打算使用 Telescope 来帮助你的本地开发，你可以使用 `--dev` 标记安装 Telescope：\r\n\r\n```shell\r\ncomposer require laravel/telescope --dev\r\n\r\nphp artisan telescope:install\r\n\r\nphp artisan migrate\r\n```\r\n\r\n运行 `telescope:install` 后，应该从应用程序的 `config/app.php` 配置文件中删除 `TelescopeServiceProvider` 服务提供者注册。手动在 `App\\Providers\\AppServiceProvider` 类的 `register` 方法中注册 telescope 的服务提供者来替代。在注册提供者之前，我们会确保当前环境是 `local`：\r\n\r\n    /**\r\n     * 注册应用服务。\r\n     */\r\n    public function register(): void\r\n    {\r\n        if ($this->app->environment('local')) {\r\n            $this->app->register(\\Laravel\\Telescope\\TelescopeServiceProvider::class);\r\n            $this->app->register(TelescopeServiceProvider::class);\r\n        }\r\n    }\r\n\r\n最后，你还应该将以下内容添加到你的 `composer.json` 文件中来防止 Telescope 扩展包被 [自动发现](/docs/laravel/10.x/packages#package-discovery)：\r\n\r\n```json\r\n\"extra\": {\r\n    \"laravel\": {\r\n        \"dont-discover\": [\r\n            \"laravel/telescope\"\r\n        ]\r\n    }\r\n},\r\n```\r\n\r\n<a name=\"configuration\"></a>\r\n### 配置\r\n\r\n发布 Telescope 的资源文件后，其主要配置文件将位于 `config/telescope.php`。此配置文件允许你配置监听 [观察者选项](#available-watchers)，每个配置选项都包含其用途说明，因此请务必彻底浏览此文件。\r\n\r\n如果需要，你可以使用 `enabled` 配置选项完全禁用 Telescope 的数据收集：\r\n\r\n    'enabled' => env('TELESCOPE_ENABLED', true),\r\n\r\n\r\n\r\n<a name=\"data-pruning\"></a>\r\n### 数据修改\r\n\r\n有了数据修改， `telescope_entries` 表可以非常快速地累积记录。 为了缓解这个问题，你应该使用 [调度](/docs/laravel/10.x/scheduling) 每天运行 `telescope:prune` 命令：\r\n\r\n    $schedule->command('telescope:prune')->daily();\r\n\r\n默认情况下，将获取超过 24 小时的所有数据。在调用命令时可以使用 `hours` 选项来确定保留 `Telescope` 数据的时间。例如，以下命令将删除 48 小时前创建的所有记录：\r\n\r\n    $schedule->command('telescope:prune --hours=48')->daily();\r\n\r\n<a name=\"dashboard-authorization\"></a>\r\n### 仪表板授权\r\n\r\n访问 `/telescope` 即可显示仪表盘。默认情况下，你只能在 `local` 环境中访问此仪表板。 在 `app/Providers/TelescopeServiceProvider.php` 文件中，有一个 [gate 授权](/docs/laravel/10.x/authorization#gates) 。此授权能控制在 **非本地** 环境中对 Telescope 的访问。你可以根据需要随意修改此权限以限制对 Telescope 安装和访问：\r\n\r\n    use App\\Models\\User;\r\n\r\n    /**\r\n     * 注册 Telescope gate。\r\n     *\r\n     * 该 gate 确定谁可以在非本地环境中访问 Telescope\r\n     */\r\n    protected function gate(): void\r\n    {\r\n        Gate::define('viewTelescope', function (User $user) {\r\n            return in_array($user->email, [\r\n                'taylor@laravel.com',\r\n            ]);\r\n        });\r\n    }\r\n\r\n> 注意：你应该确保在生产环境中将 `APP_ENV` 环境变量更改为 `Production`。 否则，你的 Telescope 调试工具将公开可用。\r\n\r\n<a name=\"upgrading-telescope\"></a>\r\n## 更新 Telescope\r\n\r\n升级到 Telescope 的新主要版本时，务必仔细阅读 [升级指南](https://github.com/laravel/telescope/blob/master/UPGRADE.).\r\n\r\n\r\n\r\n此外，升级到任何新的 Telescope 版本时，你都应该重建 Telescope 实例：\r\n\r\n```shell\r\nphp artisan telescope:publish\r\n```\r\n\r\n为了使实例保持最新状态并避免将来的更新中出现问题，可以在应用程序的 `composer.json` 文件中的 `post-update-cmd` 脚本添加 `telescope:publish` 命令：\r\n\r\n```json\r\n{\r\n    \"scripts\": {\r\n        \"post-update-cmd\": [\r\n            \"@php artisan vendor:publish --tag=laravel-assets --ansi --force\"\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"filtering\"></a>\r\n## 过滤\r\n\r\n<a name=\"filtering-entries\"></a>\r\n### 单项过滤\r\n\r\n你可以通过在 `App\\Providers\\TelescopeServiceProvider` 类中定义的 `filter` 闭包来过滤 Telescope 记录的数据。 默认情况下，此回调会记录 `local` 环境中的所有数据以及异常、失败任务、计划任务和带有受监控标记的数据：\r\n\r\n    use Laravel\\Telescope\\IncomingEntry;\r\n    use Laravel\\Telescope\\Telescope;\r\n\r\n    /**\r\n     * 注册应用服务\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->hideSensitiveRequestDetails();\r\n\r\n        Telescope::filter(function (IncomingEntry $entry) {\r\n            if ($this->app->environment('local')) {\r\n                return true;\r\n            }\r\n\r\n            return $entry->isReportableException() ||\r\n                $entry->isFailedJob() ||\r\n                $entry->isScheduledTask() ||\r\n                $entry->isSlowQuery() ||\r\n                $entry->hasMonitoredTag();\r\n        });\r\n    }\r\n\r\n<a name=\"filtering-batches\"></a>\r\n### 批量过滤\r\n\r\n`filter` 闭包过滤单个条目的数据， 你也可以使用 `filterBatch` 方法注册一个闭包，该闭包过滤给定请求或控制台命令的所有数据。如果闭包返回 `true`，则所有数据都由 Telescope 记录：\r\n\r\n    use Illuminate\\Support\\Collection;\r\n    use Laravel\\Telescope\\IncomingEntry;\r\n    use Laravel\\Telescope\\Telescope;\r\n\r\n    /**\r\n     *  注册应用服务\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->hideSensitiveRequestDetails();\r\n\r\n        Telescope::filterBatch(function (Collection $entries) {\r\n            if ($this->app->environment('local')) {\r\n                return true;\r\n            }\r\n\r\n            return $entries->contains(function (IncomingEntry $entry) {\r\n                return $entry->isReportableException() ||\r\n                    $entry->isFailedJob() ||\r\n                    $entry->isScheduledTask() ||\r\n                    $entry->isSlowQuery() ||\r\n                    $entry->hasMonitoredTag();\r\n                });\r\n        });\r\n    }\r\n\r\n\r\n\r\n<a name=\"tagging\"></a>\r\n## 标签\r\n\r\nTelescope 允许你通过 「tag」 搜索条目。通常，标签是 Eloquent 模型的类名或经过身份验证的用户 ID， 这些标签会自动添加到条目中。有时，你可能希望将自己的自定义标签附加到条目中。 你可以使用 `Telescope::tag` 方法。 `tag` 方法接受一个闭包，该闭包应返回一个标签数组。返回的标签将与 Telescope 自动附加到条目的所有标签合并。你应该在 `App\\Providers\\TelescopeServiceProvider` 类中的 `register` 方法调用 `tag` 方法：\r\n\r\n    use Laravel\\Telescope\\IncomingEntry;\r\n    use Laravel\\Telescope\\Telescope;\r\n\r\n    /**\r\n     * 注册应用服务\r\n     */\r\n    public function register(): void\r\n    {\r\n        $this->hideSensitiveRequestDetails();\r\n\r\n        Telescope::tag(function (IncomingEntry $entry) {\r\n            return $entry->type === 'request'\r\n                        ? ['status:'.$entry->content['response_status']]\r\n                        : [];\r\n        });\r\n     }\r\n\r\n<a name=\"available-watchers\"></a>\r\n## 可用的观察者\r\n\r\nTelescope 「观察者」 在执行请求或控制台命令时收集应用数据。你可以在 `config/telescope.php` 配置文件中自定义启用的观察者列表：\r\n\r\n    'watchers' => [\r\n        Watchers\\CacheWatcher::class => true,\r\n        Watchers\\CommandWatcher::class => true,\r\n        ...\r\n    ],\r\n\r\n一些监视器还允许你提供额外的自定义选项：\r\n\r\n    'watchers' => [\r\n        Watchers\\QueryWatcher::class => [\r\n            'enabled' => env('TELESCOPE_QUERY_WATCHER', true),\r\n            'slow' => 100,\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"batch-watcher\"></a>\r\n### 批量监视器\r\n\r\n批量监视器记录队列 [批量任务](/docs/laravel/10.x/queues#job-batching) 的信息，包括任务和连接信息。\r\n\r\n<a name=\"cache-watcher\"></a>\r\n### 缓存监视器\r\n\r\n当缓存键被命中、未命中、更新和删除时，缓存监视器会记录数据。\r\n\r\n<a name=\"command-watcher\"></a>\r\n\r\n\r\n### 命令监视器\r\n\r\n只要执行 Artisan 命令，命令监视器就会记录参数、选项、退出码和输出。如果你想排除监视器记录的某些命令，你可以在 `config/telescope.php` 文件的 `ignore` 选项中指定命令：\r\n\r\n    'watchers' => [\r\n        Watchers\\CommandWatcher::class => [\r\n            'enabled' => env('TELESCOPE_COMMAND_WATCHER', true),\r\n            'ignore' => ['key:generate'],\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"dump-watcher\"></a>\r\n### 输出监视器\r\n\r\n输出监视器在 Telescope 中记录并显示你的变量输出。使用 Laravel 时，可以使用全局 `dump` 函数输出变量。必须在浏览器中打开数据监视器选项卡，才能进行输出变量，否则监视器将忽略此次输出。\r\n\r\n<a name=\"event-watcher\"></a>\r\n### 事件监视器\r\n\r\n事件监视器记录应用分发的所有 [事件](/docs/laravel/10.x/events) 的有效负载、监听器和广播数据。事件监视器忽略了 Laravel 框架的内部事件。\r\n\r\n<a name=\"exception-watcher\"></a>\r\n### 异常监视器\r\n\r\n异常监视器记录应用抛出的任何可报告异常的数据和堆栈跟踪。\r\n\r\n<a name=\"gate-watcher\"></a>\r\n### Gate（拦截）监视器\r\n\r\nGate 监视器记录你的应用的 [gate 和策略](/docs/laravel/10.x/authorization) 检查的数据和结果。如果你希望将某些属性排除在监视器的记录之外，你可 `config/telescope.php` 文件的 `ignore_abilities` 选项中指定它们：\r\n\r\n    'watchers' => [\r\n        Watchers\\GateWatcher::class => [\r\n            'enabled' => env('TELESCOPE_GATE_WATCHER', true),\r\n            'ignore_abilities' => ['viewNova'],\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"http-client-watcher\"></a>\r\n### HTTP 客户端监视器\r\n\r\n\r\n\r\nHTTP 客户端监视器记录你的应用程序发出的传出 [HTTP 客户端请求](/docs/laravel/10.x/http-client)。\r\n\r\n<a name=\"job-watcher\"></a>\r\n### 任务监视器\r\n\r\n任务监视器记录应用程序分发的任何 [任务](/docs/laravel/10.x/queues) 的数据和状态。\r\n\r\n<a name=\"log-watcher\"></a>\r\n### 日志监视器\r\n\r\n日志监视器记录应用程序写入的任何日志的 [日志数据](/docs/laravel/10.x/logging)。\r\n\r\n默认情况下，Telescope 将只记录 [错误] 级别及以上的日志。但是，你可以修改应用程序的 `config/tescope.php` 配置文件中的 `level` 选项来修改此行为：\r\n\r\n    'watchers' => [\r\n        Watchers\\LogWatcher::class => [\r\n            'enabled' => env('TELESCOPE_LOG_WATCHER', true),\r\n            'level' => 'debug',\r\n        ],\r\n\r\n        // ...\r\n    ],\r\n\r\n<a name=\"mail-watcher\"></a>\r\n### 邮件监视器\r\n\r\n邮件监视器允许你查看应用发送的 [邮件](/docs/laravel/10.x/mail) 及其相关数据的浏览器内预览。你也可以将该电子邮件下载为 `.eml` 文件。\r\n\r\n<a name=\"model-watcher\"></a>\r\n### 模型监视器\r\n\r\n每当调度 Eloquent 的 [模型事件](/docs/laravel/10.x/eloquent#events) 时，模型监视器就会记录模型更改。你可以通过监视器的 `events` 选项指定应记录哪些模型事件：\r\n\r\n    'watchers' => [\r\n        Watchers\\ModelWatcher::class => [\r\n            'enabled' => env('TELESCOPE_MODEL_WATCHER', true),\r\n            'events' => ['eloquent.created*', 'eloquent.updated*'],\r\n        ],\r\n        ...\r\n    ],\r\n\r\n如果你想记录在给定请求期间融合的模型数量，请启用 `hydrations` 选项：\r\n\r\n    'watchers' => [\r\n        Watchers\\ModelWatcher::class => [\r\n            'enabled' => env('TELESCOPE_MODEL_WATCHER', true),\r\n            'events' => ['eloquent.created*', 'eloquent.updated*'],\r\n            'hydrations' => true,\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"notification-watcher\"></a>\r\n### 消息通知监视器\r\n\r\n消息通知监听器记录你的应用程序发送的所有 [消息通知](/docs/laravel/10.x/notifications) 。如果通知触发了电子邮件并且你启用了邮件监听器，则电子邮件也可以在邮件监视器屏幕上进行预览。\r\n\r\n\r\n\r\n<a name=\"query-watcher\"></a>\r\n### 数据查询监视器\r\n\r\n数据查询监视器记录应用程序执行的所有查询的原始 SQL、绑定和执行时间。监视器还将任何慢于 100 毫秒的查询标记为 `slow`。你可以使用监视器的 `slow` 选项自定义慢查询阈值：\r\n\r\n    'watchers' => [\r\n        Watchers\\QueryWatcher::class => [\r\n            'enabled' => env('TELESCOPE_QUERY_WATCHER', true),\r\n            'slow' => 50,\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"redis-watcher\"></a>\r\n### Redis 监视器\r\n\r\nRedis 监视器记录你的应用程序执行的所有 [Redis](/docs/laravel/10.x/redis) 命令。如果你使用 Redis 进行缓存，Redis 监视器也会记录缓存命令。\r\n\r\n<a name=\"request-watcher\"></a>\r\n### 请求监视器\r\n\r\n请求监视器记录与应用程序处理的任何请求相关联的请求、请求头、会话和响应数据。你可以通过 `size_limit`（以 KB 为单位）选项限制记录的响应数据：\r\n\r\n    'watchers' => [\r\n        Watchers\\RequestWatcher::class => [\r\n            'enabled' => env('TELESCOPE_REQUEST_WATCHER', true),\r\n            'size_limit' => env('TELESCOPE_RESPONSE_SIZE_LIMIT', 64),\r\n        ],\r\n        ...\r\n    ],\r\n\r\n<a name=\"schedule-watcher\"></a>\r\n### 定时任务监视器\r\n\r\n定时任务监视器记录应用程序运行的任何 [计划任务](/docs/laravel/10.x/scheduling) 的命令和输出。\r\n\r\n<a name=\"view-watcher\"></a>\r\n### 视图监视器\r\n\r\n视图监视器记录渲染视图时使用的 [视图](/docs/laravel/10.x/views) 名称、路径、数据和「composer」组件。\r\n\r\n<a name=\"displaying-user-avatars\"></a>\r\n## 显示用户头像\r\n\r\nTelescope 仪表盘显示保存给定条目时会有登录用户的用户头像。 默认情况下，Telescope 将使用 Gravatar Web 服务检索头像。 但是，你可以通过在 `App\\Providers\\TelescopeServiceProvider` 类中注册一个回调来自定义头像 URL。 回调将收到用户的 ID 和电子邮件地址，并应返回用户的头像 URL：\r\n\r\n    use App\\Models\\User;\r\n    use Laravel\\Telescope\\Telescope;\r\n\r\n    /**\r\n     * 注册应用服务\r\n     */\r\n    public function register(): void\r\n    {\r\n        // ...\r\n\r\n        Telescope::avatar(function (string $id, string $email) {\r\n            return '/avatars/'.User::find($id)->avatar_path;\r\n        });\r\n    }\r\n\r\n","p":"docs/telescope.html"},{"t":"valet (Laravel Valet)","d":"# Laravel Valet\r\n\r\n- [简介](#introduction)\r\n- [安装](#installation)\r\n    - [升级](#upgrading-valet)\r\n- [服务站点](#serving-sites)\r\n    - [Park 命令](#the-park-command)\r\n    - [Link 命令](#the-link-command)\r\n    - [使用 TLS 保护站点](#securing-sites)\r\n    - [服务默认站点](#serving-a-default-site)\r\n    - [默认 PHP 版本](#per-site-php-versions)\r\n- [共享站点](#sharing-sites)\r\n    - [通过 Ngrok 共享站点](#sharing-sites-via-ngrok)\r\n    - [通过 Expose 共享站点](#sharing-sites-via-expose)\r\n    - [共享本地网络站点](#sharing-sites-on-your-local-network)\r\n- [网站特定环境变量](#site-specific-environment-variables)\r\n- [代理服务](#proxying-services)\r\n- [自定义 Valet 驱动](#custom-valet-drivers)\r\n    - [本地驱动](#local-drivers)\r\n- [其他 Valet 命令](#other-valet-commands)\r\n- [Valet 目录和文件](#valet-directories-and-files)\r\n    - [磁盘访问](#disk-access)\r\n\r\n<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n[Laravel Valet](https://github.com/laravel/valet) 是一个面向 macOS 极简主义者的 Laravel 开发环境。Laravel Valet 为你的 Mac 设置了开机后始终在后台运行 [Nginx](https://www.nginx.com/) 服务。然后，使用 [DnsMasq](https://en.wikipedia.org/wiki/Dnsmasq) 将所有指向安装在本地的计算机站点请求代理到 `*.test` 结尾的域名上。\r\n\r\n总之，Valet 是一个速度极快的 Laravel 开发环境，仅仅占用了 7 MB 内存。Valet 并不能完全取代 [Sail](/docs/laravel/10.x/sail) 或 [Homestead](/docs/laravel/10.x/homestead)，只是提供了另外一种使用起来更加灵活、方便、以及内存占用更小的选择。\r\n\r\n开箱即用，Valet 支持但不局限于以下内容：\r\n\r\n<style>\r\n    #valet-support > ul {\r\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\r\n        line-height: 1.9;\r\n    }\r\n</style>\r\n\r\n<div id=\"valet-support\" markdown=\"1\">\r\n\r\n- [Laravel](https://laravel.com)\r\n- [Bedrock](https://roots.io/bedrock/)\r\n- [CakePHP 3](https://cakephp.org)\r\n- [ConcreteCMS](https://www.concretecms.com/)\r\n- [Contao](https://contao.org/en/)\r\n- [Craft](https://craftcms.com)\r\n- [Drupal](https://www.drupal.org/)\r\n- [ExpressionEngine](https://www.expressionengine.com/)\r\n- [Jigsaw](https://jigsaw.tighten.co)\r\n- [Joomla](https://www.joomla.org/)\r\n- [Katana](https://github.com/themsaid/katana)\r\n- [Kirby](https://getkirby.com/)\r\n- [Magento](https://magento.com/)\r\n- [OctoberCMS](https://octobercms.com/)\r\n- [Sculpin](https://sculpin.io/)\r\n- [Slim](https://www.slimframework.com)\r\n- [Statamic](https://statamic.com)\r\n- Static HTML\r\n- [Symfony](https://symfony.com)\r\n- [WordPress](https://wordpress.org)\r\n- [Zend](https://framework.zend.com)\r\n\r\n</div>\r\n\r\n\r\n\r\n但是，你可以使用自己的 [自定义驱动程序](#custom-valet-drivers) 扩展 Valet 。 .\r\n\r\n<a name=\"installation\"></a>\r\n## 安装\r\n\r\n> 注意：Valet 需要 macOS 和 [Homebrew](https://brew.sh/) ，你应该确保没有其他程序 (例如 Apache 或者 Nginx) 占用本地计算机的 80 端口。\r\n\r\n首先，你首先需要使用以下 `update` 命令确保 Homebrew 是最新的：\r\n\r\n```shell\r\nbrew update\r\n```\r\n\r\n接下来，你应该使用 Homebrew 安装 PHP:\r\n\r\n```shell\r\nbrew install php\r\n```\r\n\r\n在安装 PHP 之后，就可以安装 [Composer 软件包管理器](https://getcomposer.org) 了。 另外，你应该确保 `~/.composer/vendor/bin` 目录位于系统的「PATH」 中。安装 Composer 之后，你可以将 Laravel Valet 安装为全局 Composer 软件包：\r\n\r\n```shell\r\ncomposer global require laravel/valet\r\n```\r\n\r\n最后，你可以执行 Valet 的 `install` 命令。这将配置并安装 Valet 和 DnsMasq。此外，Valet 依赖的守护程序将配置为在系统启动时启动：\r\n\r\n```shell\r\nvalet install\r\n```\r\n\r\n安装 Valet 后，请尝试使用如 之类的命令 `ping foobar.test` ping 终端上的任何 `*.test` 域。 如果 Valet 安装正确，你应该看到该域在 `127.0.0.1` 上响应。\r\n\r\n每当你的机器启动时，Valet 将自动启动其所需的相关服务。\r\n\r\n<a name=\"php-versions\"></a>\r\n#### PHP 版本\r\n\r\n> 注意：你无需修改全局的 PHP 版本，你可以通过 `isolate` [命令](#per-site-php-versions)指定 Valet 使用每个站点的 PHP 版本\r\n\r\n\r\nValet 允许你使用 `valet use php@version` 命令切换 PHP 版本。如果尚未安装， Valet 将通过 Homebrew 安装指定的 PHP 版本：\r\n\r\n```shell\r\nvalet use php@8.1\r\n\r\nvalet use php\r\n```\r\n\r\n\r\n\r\n你还可以在项目的根目录中创建一个 `.valetphprc` 文件。 `.valetphprc` 文件应包含站点应使用的PHP版本：\r\n\r\n```shell\r\nphp@8.1\r\n```\r\n\r\n创建此文件后，你只需执行 `valet use` 命令，命令将通过读取文件来确定站点的首选PHP版本。\r\n\r\n> **注意**  \r\n> Valet一次仅提供一个PHP版本，即使你安装了多个PHP版本。\r\n\r\n<a name=\"database\"></a>\r\n#### 数据库\r\n\r\n如果应用程序需要数据库，请查看[DBngin](https://dbngin.com/)，它提供了一个免费的全合一数据库管理工具，包括MySQL、PostgreSQL和Redis。安装DBngin后，你可以使用`root`用户名和空字符串作为密码连接到你的数据库`127.0.0.1`。\r\n\r\n<a name=\"resetting-your-installation\"></a>\r\n#### 重置安装\r\n\r\n如果你无法使Valet安装正常运行，请执行`composer global require laravel/valet`命令，然后执行`valet install`将重置你的安装并可以解决各种问题。在极少数情况下，可能需要通过执行`valet uninstall --force`，然后执行`valet install`来进行“硬重置”Valet。\r\n\r\n<a name=\"upgrading-valet\"></a>\r\n### 升级 Valet\r\n\r\n你可以通过在终端中执行`composer global require laravel/valet`命令来更新Valet安装。升级后，建议运行`valet install`命令，以便Valet可以根据需要对你的配置文件进行其他升级。\r\n\r\n<a name=\"serving-sites\"></a>\r\n## 运行站点服务\r\n\r\n安装Valet后，你可以开始为你的Laravel应用程序提供服务。Valet提供了两个命令来帮助你服务你的应用程序： `park` 和 `link` 。\r\n\r\n\r\n\r\n<a name=\"the-park-command\"></a>\r\n### `park` 命令\r\n\r\n`park` 命令在你的电脑上注册一个包含应用程序的目录。 一旦该目录被 Valet「parked」，该目录下所有应用都可以使用 `http://文件夹名.test` 来访问：\r\n\r\n```shell\r\ncd ~/Sites\r\n\r\nvalet park\r\n```\r\n\r\n这就是所有需要手动的操作。现在，任何你创建在「parked」目录中的应用都可以使用 `http://文件夹名.test` 域名访问。例如，如果你的「parked」路径下包括一个名为「laravel」的目录，可以使用 `http://laravel.test` 来访问。此外，Valet 自动允许二级域名访问此站点。 (`http://foo.laravel.test`)。\r\n\r\n<a name=\"the-link-command\"></a>\r\n### `link` 命令\r\n\r\n该 `link` 命令也可以用来为你的 Laravel 站点提供服务。如果要为目录中的单个站点而不是整个目录提供服务，则此命令非常有用。\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nvalet link\r\n```\r\n\r\n使用 `link` 命令链接一个站点后，你可以使用目录名称来访问。例如，你可以在浏览器中通过 `http://laravel.test` 访问。另外，Valet 自动添加了站点二级目录的访问功能，例如 (`http://foo.laravel.test`)。\r\n\r\n如果你想要使用不同的域名来访问相同站点，你可以使用 `link` 命令来构造站点。例如，你可以使用以下命令来指定域名 `http://application.test` ：\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nvalet link application\r\n```\r\n\r\n\r\n\r\n当然，你也可以使用 `link` 命令来设置子域名访问：\r\n\r\n```shell\r\nvalet link api.application\r\n```\r\n\r\n你可以使用 `links` 命令来查看所有的目录链接：\r\n\r\n```shell\r\nvalet links\r\n```\r\n\r\n`unlink` 命令可以用来删除目录链接：\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nvalet unlink\r\n```\r\n\r\n<a name=\"securing-sites\"></a>\r\n### 使用 TLS 保护站点\r\n\r\n默认情况下，Valet 使用 HTTP 协议提供服务。当然，如果你想使用 HTTP/2 通过 TLS 加密你的站点，你可以使用 `secure` 命令。例如， 如果你的站点由 `laravel.test` 域名的 Valet 提供服务，可以使用以下命令为站点实现安全保护功能：\r\n\r\n```shell\r\nvalet secure laravel\r\n```\r\n\r\n要 「解除保护」并恢复 HTTP 访问 ，请使用 `unsecure` 命令。像 `secure` 命令一样，该命令接受你想要解除保护的主机名：\r\n\r\n```shell\r\nvalet unsecure laravel\r\n```\r\n\r\n<a name=\"serving-a-default-site\"></a>\r\n### 默认站点\r\n\r\n有时，当访问未知的 `test` 域时，你可能希望访问「默认」站点，而不是 `404` 。要实现这一点，你可以在 `~/.config/valet/config.json` 配置文件中添加一个 `default` 选项。 并设置默认站点的路径：\r\n\r\n    \"default\": \"/Users/Sally/Sites/example-site\",\r\n\r\n<a name=\"per-site-php-versions\"></a>\r\n### 站点 PHP 版本\r\n\r\n默认情况下，Valet 使用你的全局 PHP 安装来为你的站点提供服务。 但是，如果你需要跨多个站点支持多个 PHP 版本，则可以使用 `isolate` 命令指定特定站点的 PHP 版本。 `isolate` 命令将 Valet 配置为当前工作目录的站点使用指定的 PHP 版本：\r\n\r\n```shell\r\ncd ~/Sites/example-site\r\n\r\nvalet isolate php@8.0\r\n```\r\n\r\n\r\n\r\n如果你的站点名称与目录名称不一致，你可以使用 `--site` 选项指定站点名称：\r\n\r\n```shell\r\nvalet isolate php@8.0 --site=\"site-name\"\r\n```\r\n\r\n为方便起见，你可以使用 `valet php`、`composer` 和 `which-php` 命令根据站点配置的 PHP 版本代理对适合的 PHP CLI 或工具的调用：\r\n\r\n```shell\r\nvalet php\r\nvalet composer\r\nvalet which-php\r\n```\r\n\r\n你可以执行 `isolated` 命令来显示所有隔离站点及其 PHP 版本的列表：\r\n\r\n```shell\r\nvalet isolated\r\n```\r\n\r\n要将站点恢复为 Valet 全局安装的 PHP 版本，你可以从站点的根目录调用 `unisolate` 命令：\r\n\r\n```shell\r\nvalet unisolate\r\n```\r\n\r\n<a name=\"sharing-sites\"></a>\r\n## 共享站点\r\n\r\nValet 甚至包含了一个与全世界共享你的本地站点的命令，提供了一种在移动设备上测试你的站点或与团队成员和客户共享的简单方法。\r\n\r\n<a name=\"sharing-sites-via-ngrok\"></a>\r\n### 使用 Ngrok 共享站点\r\n\r\n要共享站点，请在终端中进到站点目录，并运行 `valet share` 命令。一个公开可访问的 URL 将会插入到你的剪贴板中，你可以分享给团队成员或在浏览器中打开它:\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nvalet share\r\n```\r\n\r\n要停止共享你的站点，可以按 `Control + C` 。使用 Ngrok 共享你的网站需要你 [创建一个  Ngrok 帐户](https://dashboard.ngrok.com/signup) 和 [设置身份验证令牌](https://dashboard.ngrok.com/get-started/your-authtoken)。\r\n\r\n> **提示**\r\n> 你可以向 share 命令传递额外的参数， 如 `valet share --region=eu`。 详细信息，请参考 [ngrok 文档](https://ngrok.com/docs)。\r\n\r\n\r\n\r\n<a name=\"sharing-sites-via-expose\"></a>\r\n### 通过 Expose 共享网站\r\n\r\n如果你已经安装了 [Expose](https://expose.dev/)，你可以在终端里进入网站目录运行 `expose` 命令来共享你的网站。可以访问 [Expose 文档](https://expose.dev/docs) 查看命令行参数说明。共享网站后，Expose 将显示共享 URL，你可以在其他设备或团队成员之间使用它：\r\n\r\n```shell\r\ncd ~/Sites/laravel\r\n\r\nexpose\r\n```\r\n你可以按下 `Control + C` 停止共享网站。\r\n\r\n<a name=\"sharing-sites-on-your-local-network\"></a>\r\n### 在局域网里共享网站\r\n\r\nValet 默认限制本机 `127.0.0.1` 访问，以便你的开发机器不会受到来自互联网的安全风险。\r\n\r\n如果你想让局域网里的其他设备通过你的局域网 IP 地址访问 Valet 网站（例如：`192.168.1.10/application.test`），则需要手动编辑该网站的 Nginx 配置文件，删除 `listen` 指令上的限制。你需要删除端口 80 和 443 的 `listen` 指令前缀 `127.0.0.1：`。\r\n\r\n如果你没有在项目上运行 `valet secure`，则可以通过编辑 `/usr/local/etc/nginx/valet/valet.conf` 文件来为所有非 HTTPS 网站打开网络访问。但是，如果你通过 HTTPS 提供项目站点（即你已经对站点运行了 `valet secure`），则应编辑 `~/.config/valet/Nginx/app-name.test` 文件。\r\n\r\n更新了 Nginx 配置后，需要运行 `valet restart` 命令让配置更改生效。\r\n\r\n\r\n\r\n<a name=\"site-specific-environment-variables\"></a>\r\n## 站点特定环境变量\r\n\r\n一些使用其他框架的应用程序可能依赖于服务器环境变量，但不提供在你的项目中配置这些变量的方法。 Valet 允许你通过在项目根目录内添加 `.valet-env.php` 文件来配置站点特定环境变量。此文件应返回一个站点 / 环境变量对数组，该数组将添加到数组中指定的每个站点的全局 `$_SERVER` 数组中：\r\n\r\n    <?php\r\n\r\n    return [\r\n        // 将 laravel.test 站点的 $_SERVER['key'] 设置为 \"value\"...\r\n        'laravel' => [\r\n            'key' => 'value',\r\n        ],\r\n\r\n        // 将所有站点的 $_SERVER['key'] 设置为 \"value\"...\r\n        '*' => [\r\n            'key' => 'value',\r\n        ],\r\n    ];\r\n\r\n<a name=\"proxying-services\"></a>\r\n## 代理服务\r\n\r\n有时你可能希望将 Valet 域名代理到本地计算机上的另一项服务。 例如，你可能偶尔需要运行 Valet，同时在 Docker 中运行单独的站点； 但是， Valet 和 Docker 不能同时绑定到80端口。\r\n\r\n为了解决这个问题，你可以用 `proxy` 命令去生成一个代理。例如，你可以代理所有流量从 `http://elasticsearch.test` 到 `http://127.0.0.1:9200`：\r\n\r\n```shell\r\n# 通过 HTTP 代理...\r\nvalet proxy elasticsearch http://127.0.0.1:9200\r\n\r\n# 通过 TLS + HTTP/2 代理...\r\nvalet proxy elasticsearch http://127.0.0.1:9200 --secure\r\n```\r\n\r\n你可以用 `unproxy` 命令去删除一个代理：\r\n\r\n```shell\r\nvalet unproxy elasticsearch\r\n```\r\n\r\n你可以用 `proxies` 命令列出所有被代理的站点配置：\r\n\r\n```shell\r\nvalet proxies\r\n```\r\n\r\n<a name=\"custom-valet-drivers\"></a>\r\n## 定制 Valet 驱动\r\n\r\n你可以编写自己的 Valet「驱动」来为在 Valet 本身不支持的框架或 CMS 上运行的 PHP 应用程序提供服务。安装 Valet 时，创建了一个 `~/.config/valet/Drivers` 目录，其中包含一个 `SampleValetDriver.php` 文件。该文件包含一个示例驱动程序实现，用于演示如何编写自定义驱动程序。编写驱动只需要你实现三种方法：  `serves` ， `isStaticFile` ， 和 `frontControllerPath`。\r\n\r\n\r\n\r\n这三种方法都接收 `$sitePath`, `$siteName`, 和 `$uri` 值作为其参数。 `$sitePath` 是你机器上服务的网站的完整的路径， 如 `/Users/Lisa/Sites/my-project`。 `$siteName` 是 「host」/「site name」域名的一部分 (`my-project`)。`$uri` 是传入的请求 URI (`/foo/bar`)。\r\n\r\n完成你的自定义 Valet 驱动后，使用 `frameworkvaletdriver.php` 命名约定将它放在`~/.config/valet/Drivers` 目录中。 例如，如果你正在为 WordPress 编写自定义 Valet 驱动，则文件名应为 `WordPressValetDriver.php`。\r\n\r\n我们来看看自定义的 Valet 驱动程序应该实现的每种方法的示例实现。\r\n\r\n<a name=\"the-serves-method\"></a>\r\n#### `serves` 方法\r\n\r\n如果驱动程序应该处理传入的请求，`serves` 方法应该返回 `true`。否则，该方法应返回 `false`。因此，在这个方法中，你应该尝试确定给定的`$sitePath` 是否包含你试图服务的类型的项目。\r\n\r\n例如，假设我们正在编写一个 `WordPressValetDriver`。我们的 `serves` 方法可能看起来如下所示：\r\n\r\n    /**\r\n     * 确定驱动程序是否为请求服务。\r\n     *\r\n     * @param  string  $sitePath\r\n     * @param  string  $siteName\r\n     * @param  string  $uri\r\n     * @return bool\r\n     */\r\n    public function serves($sitePath, $siteName, $uri)\r\n    {\r\n        return is_dir($sitePath.'/wp-admin');\r\n    }\r\n\r\n<a name=\"the-isstaticfile-method\"></a>\r\n#### `isStaticFile` 方法\r\n\r\n`isStaticFile` 应当确定即将到来的请求是否针对一个「静态」文件，比如：图片和样式表。如果文件是静态的，此方法应当返回静态文件在磁盘上的完全限定路径。如果即将到来的请求不是针对一个静态文件，这个方法应当返回 `false`：\r\n\r\n    /**\r\n     * 确定传入请求是否针对静态文件。\r\n     *\r\n     * @param  string  $sitePath\r\n     * @param  string  $siteName\r\n     * @param  string  $uri\r\n     * @return string|false\r\n     */\r\n    public function isStaticFile($sitePath, $siteName, $uri)\r\n    {\r\n        if (file_exists($staticFilePath = $sitePath.'/public/'.$uri)) {\r\n            return $staticFilePath;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n> **注意**  \r\n> 仅当 `serves` 方法对传入请求返回 `true` 且请求 URI 不是 `/` 时，才会调用 `isStaticFile` 方法。\r\n\r\n\r\n\r\n<a name=\"the-frontcontrollerpath-method\"></a>\r\n#### `frontControllerPath` 方法\r\n\r\n`frontControllerPath` 方法应该返回你的应用的「前端控制器」的完全限定路径，它通常是 「index.php」 或等效的文件：\r\n\r\n    /**\r\n     * 获取应用程序前端控制器的完全解析路径。\r\n     *\r\n     * @param  string  $sitePath\r\n     * @param  string  $siteName\r\n     * @param  string  $uri\r\n     * @return string\r\n     */\r\n    public function frontControllerPath($sitePath, $siteName, $uri)\r\n    {\r\n        return $sitePath.'/public/index.php';\r\n    }\r\n\r\n<a name=\"local-drivers\"></a>\r\n### 本地驱动\r\n\r\n如果你想要为单个应用自定义一个 Valet 驱动，请在应用根目录创建一个 `LocalValetDriver.php`  文件。你的自定义驱动可以继承 `ValetDriver`  基类或继承现有应用的特定驱动程序，如 `LaravelValetDriver`：\r\n\r\n\r\n    use Valet\\Drivers\\LaravelValetDriver;\r\n\r\n    class LocalValetDriver extends LaravelValetDriver\r\n    {\r\n        /**\r\n         * 确定驱动程序是否给请求提供服务。\r\n         *\r\n         * @param  string  $sitePath\r\n         * @param  string  $siteName\r\n         * @param  string  $uri\r\n         * @return bool\r\n         */\r\n        public function serves($sitePath, $siteName, $uri)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * 获取对应用程序的前端控制器的完全解析路径。\r\n         *\r\n         * @param  string  $sitePath\r\n         * @param  string  $siteName\r\n         * @param  string  $uri\r\n         * @return string\r\n         */\r\n        public function frontControllerPath($sitePath, $siteName, $uri)\r\n        {\r\n            return $sitePath.'/public_html/index.php';\r\n        }\r\n    }\r\n\r\n<a name=\"other-valet-commands\"></a>\r\n## 其他 Valet 命令\r\n\r\n<div class=\"overflow-auto\">\r\n\r\n命令  | 描述\r\n------------- | -------------\r\n`valet list` | 列出所有 Valet 命令\r\n`valet forget` | 从「驻留」目录运行此命令，将其从驻留目录列表中删除。\r\n`valet log` | 查看 Valet 服务记录的日志列表。\r\n`valet paths` | 查看所有「驻留」的路径。\r\n`valet restart` | 重启 Valet 守护进程。\r\n`valet start` | 启动 Valet 守护进程。\r\n`valet stop` | 停止 Valet 守护进程。\r\n`valet trust` | 为 Brew 和 Valet 添加 sudoers 文件，使 Valet 输入命令的时候不需要输入密码。\r\n`valet uninstall` | 卸载 Valet：显示手动卸载的说明。 传递 `--force` 选项来主动删除 Valet 的所有资源。\r\n\r\n</div>\r\n\r\n\r\n\r\n<a name=\"valet-directories-and-files\"></a>\r\n## Valet 目录和文件\r\n\r\n你可能会发现以下目录和文件信息对排查你的 Valet 环境故障问题很有帮助：\r\n\r\n#### `~/.config/valet`\r\n\r\n包含 Valet 所有的配置，你可能希望对此文件夹进行备份。\r\n\r\n#### `~/.config/valet/dnsmasq.d/`\r\n\r\n此目录包含 DNSMasq 的配置。\r\n\r\n#### `~/.config/valet/Drivers/`\r\n\r\n此目录包含 Valet 的驱动，驱动判断如何为特定的 framework/CMS 提供服务。\r\n\r\n#### `~/.config/valet/Extensions/`\r\n\r\n此目录包括自定义的 Valet 扩展和指令。\r\n\r\n#### `~/.config/valet/Nginx/`\r\n\r\n此目录包含所有 Valet 的 Nginx 站点配置，当运行 `install`、`secure`、`tld` 指令时会重建这些配置文件。\r\n\r\n#### `~/.config/valet/Sites/`\r\n\r\n此目录包含所有 [链接项目](#the-link-command)的符号链接。\r\n\r\n#### `~/.config/valet/config.json`\r\n\r\n此文件是 Valet 的主要配置文件。\r\n\r\n#### `~/.config/valet/valet.sock`\r\n\r\n这个文件是 Valet 中 Nginx 安装使用的 PHP-FPM 套接字，只有在 PHP 正常运行的情况下，它才会存在。\r\n\r\n#### `~/.config/valet/Log/fpm-php.www.log`\r\n\r\n此文件是 PHP 错误的用户日志。\r\n\r\n#### `~/.config/valet/Log/nginx-error.log`\r\n\r\n此文件是 Nginx 错误的用户日志。\r\n\r\n#### `/usr/local/var/log/php-fpm.log`\r\n\r\n此文件是 PHP-FPM 错误的系统日志。\r\n\r\n#### `/usr/local/var/log/nginx`\r\n\r\n此目录包含 Nginx 的访问和错误日志。\r\n\r\n#### `/usr/local/etc/php/X.X/conf.d`\r\n\r\n此目录包含用于各种 PHP 配置设置的 `*.ini` 文件\r\n\r\n#### `/usr/local/etc/php/X.X/php-fpm.d/valet-fpm.conf`\r\n\r\n此文件是 PHP-FPM 池配置文件。\r\n\r\n#### `~/.composer/vendor/laravel/valet/cli/stubs/secure.valet.conf`\r\n\r\n\r\n\r\n该文件是默认的 Nginx 配置文件，用来为你的网站生成 SSL 证书。\r\n\r\n<a name=\"disk-access\"></a>\r\n### 磁盘访问权限\r\n\r\n从 maxOS 10.14 开始，[访问部分文件和目录默认受限](https://manuals.info.apple.com/MANUALS/1000/MA1902/en_US/apple-platform-security-guide.pdf)。这些限制包括桌面，文档，以及下载目录。此外，网络磁盘和可卸载磁盘访问也受限。因此，Valet 推荐你不要将网站目录放在这些受保护的地方。\r\n\r\n尽管如此，如果你希望在上述这些地方里提供网站服务，则要给予 Nginx「完全磁盘访问权限」。否则，Nginx 可能会出现服务器错误或其他不可预知的行为，尤其是访问静态资源时。通常来说，macOS 会自动询问你是否给予 Nginx 对这些地方的完全访问权限。或者，你也可以通过 `系统偏好设置` > `安全性与隐私` > `隐私`，然后选择 `完全磁盘访问权限` 手动设置。接下来，在主窗口中启用所有 `nginx` 选项。\r\n\r\n","p":"docs/valet.html"}]